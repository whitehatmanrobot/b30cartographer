 *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn(PGroupIndicationOnArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes(ASN1encoding_t enc, PCpSetupRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpSetupRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_CpSetupRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpSetupRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes(ASN1decoding_t dec, PCpSetupRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpSetupRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpSetupRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpSetupRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupRes_extensionRes(PCpSetupRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpSetupRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpSetupRes_extensionRes_ElmFn(PCpSetupRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg(ASN1encoding_t enc, PCpSetupArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpSetupArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpSetupArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpSetupArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg(ASN1decoding_t dec, PCpSetupArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpSetupArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpSetupArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpSetupArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupArg_extensionArg(PCpSetupArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpSetupArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpSetupArg_extensionArg_ElmFn(PCpSetupArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes(ASN1encoding_t enc, PCpRequestRes_extensionRes *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpRequestRes_extensionRes_ElmFn);
}

static int ASN1CALL ASN1Enc_CpRequestRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpRequestRes_extensionRes val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes(ASN1decoding_t dec, PCpRequestRes_extensionRes *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpRequestRes_extensionRes_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpRequestRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpRequestRes_extensionRes val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestRes_extensionRes(PCpRequestRes_extensionRes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpRequestRes_extensionRes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpRequestRes_extensionRes_ElmFn(PCpRequestRes_extensionRes val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg(ASN1encoding_t enc, PCpRequestArg_extensionArg *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CpRequestArg_extensionArg_ElmFn);
}

static int ASN1CALL ASN1Enc_CpRequestArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpRequestArg_extensionArg val)
{
    if (!ASN1Enc_MixedExtension(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg(ASN1decoding_t dec, PCpRequestArg_extensionArg *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CpRequestArg_extensionArg_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CpRequestArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpRequestArg_extensionArg val)
{
    if (!ASN1Dec_MixedExtension(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestArg_extensionArg(PCpRequestArg_extensionArg *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CpRequestArg_extensionArg_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CpRequestArg_extensionArg_ElmFn(PCpRequestArg_extensionArg val)
{
    if (val) {
    ASN1Free_MixedExtension(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus(ASN1encoding_t enc, PServiceApdus_rosApdus *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ServiceApdus_rosApdus_ElmFn);
}

static int ASN1CALL ASN1Enc_ServiceApdus_rosApdus_ElmFn(ASN1encoding_t enc, PServiceApdus_rosApdus val)
{
    if (!ASN1Enc_H4503ROS(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus(ASN1decoding_t dec, PServiceApdus_rosApdus *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ServiceApdus_rosApdus_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ServiceApdus_rosApdus_ElmFn(ASN1decoding_t dec, PServiceApdus_rosApdus val)
{
    if (!ASN1Dec_H4503ROS(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ServiceApdus_rosApdus(PServiceApdus_rosApdus *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ServiceApdus_rosApdus_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ServiceApdus_rosApdus_ElmFn(PServiceApdus_rosApdus val)
{
    if (val) {
    ASN1Free_H4503ROS(&val->value);
    }
}

static ASN1stringtableentry_t AliasAddress_e164_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t AliasAddress_e164_StringTable = {
    4, AliasAddress_e164_StringTableEntries
};

static int ASN1CALL ASN1Enc_AliasAddress(ASN1encoding_t enc, AliasAddress *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    t = lstrlenA((val)->u.e164);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
        return 0;
    break;
    case 2:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->u.h323_ID).length - 1))
        return 0;
    if (!ASN1PEREncChar16String(enc, ((val)->u.h323_ID).length, ((val)->u.h323_ID).value, 16))
        return 0;
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    t = lstrlenA((val)->u.url_ID);
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 16, t - 1))
        return 0;
    if (!ASN1PEREncCharString(ee, t, (val)->u.url_ID, 8))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TransportAddress(ee, &(val)->u.transportID))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 5:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    t = lstrlenA((val)->u.email_ID);
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 16, t - 1))
        return 0;
    if (!ASN1PEREncCharString(ee, t, (val)->u.email_ID, 8))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 6:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_PartyNumber(ee, &(val)->u.partyNumber))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AliasAddress(ASN1decoding_t dec, AliasAddress *val)
{
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.e164) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164, 4, &AliasAddress_e164_StringTable))
        return 0;
    break;
    case 2:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &((val)->u.h323_ID).length))
        return 0;
    ((val)->u.h323_ID).length += 1;
    if (!ASN1PERDecChar16String(dec, ((val)->u.h323_ID).length, &((val)->u.h323_ID).value, 16))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU32Val(dd, 16, &l))
        return 0;
    l += 1;

    //NikhilB: Fix for the overflow bug 03/02/26
    if (l >= sizeof((val)->u.url_ID)) { 
        ASN1DecSetError(dd, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.url_ID, 8))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TransportAddress(dd, &(val)->u.transportID))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 5:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU32Val(dd, 16, &l))
        return 0;
    l += 1;

    //NikhilB: Fix for the overflow bug 03/02/26
    if (l >= sizeof((val)->u.email_ID)) { 
        ASN1DecSetError(dd, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroCharStringNoAlloc(dd, l, (val)->u.email_ID, 8))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 6:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_PartyNumber(dd, &(val)->u.partyNumber))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AliasAddress(AliasAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        break;
    case 2:
        ASN1char16string_free(&(val)->u.h323_ID);
        break;
    case 3:
        break;
    case 4:
        ASN1Free_TransportAddress(&(val)->u.transportID);
        break;
    case 5:
        break;
    case 6:
        ASN1Free_PartyNumber(&(val)->u.partyNumber);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress(ASN1encoding_t enc, PEndpointAddress_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EndpointAddress_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress_ElmFn(ASN1encoding_t enc, PEndpointAddress_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress(ASN1decoding_t dec, PEndpointAddress_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EndpointAddress_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress_ElmFn(ASN1decoding_t dec, PEndpointAddress_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress(PEndpointAddress_destinationAddress *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EndpointAddress_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EndpointAddress_destinationAddress_ElmFn(PEndpointAddress_destinationAddress val)
{
    if (val) {
    ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_AddressInformation(ASN1encoding_t enc, AddressInformation *val)
{
    if (!ASN1Enc_AliasAddress(enc, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AddressInformation(ASN1decoding_t dec, AddressInformation *val)
{
    if (!ASN1Dec_AliasAddress(dec, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AddressInformation(AddressInformation *val)
{
    if (val) {
    ASN1Free_AliasAddress(val);
    }
}

static int ASN1CALL ASN1Enc_EndpointAddress(ASN1encoding_t enc, EndpointAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress_destinationAddress(enc, &(val)->destinationAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_AliasAddress(enc, &(val)->remoteExtensionAddress))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndpointAddress(ASN1decoding_t dec, EndpointAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress_destinationAddress(dec, &(val)->destinationAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_AliasAddress(dec, &(val)->remoteExtensionAddress))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndpointAddress(EndpointAddress *val)
{
    if (val) {
    ASN1Free_EndpointAddress_destinationAddress(&(val)->destinationAddress);
    if ((val)->o[0] & 0x80) {
        ASN1Free_AliasAddress(&(val)->remoteExtensionAddress);
    }
    }
}

static int ASN1CALL ASN1Enc_NetworkFacilityExtension(ASN1encoding_t enc, NetworkFacilityExtension *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_EntityType(enc, &(val)->sourceEntity))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_AddressInformation(enc, &(val)->sourceEntityAddress))
        return 0;
    }
    if (!ASN1Enc_EntityType(enc, &(val)->destinationEntity))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_AddressInformation(enc, &(val)->destinationEntityAddress))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkFacilityExtension(ASN1decoding_t dec, NetworkFacilityExtension *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EntityType(dec, &(val)->sourceEntity))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_AddressInformation(dec, &(val)->sourceEntityAddress))
        return 0;
    }
    if (!ASN1Dec_EntityType(dec, &(val)->destinationEntity))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_AddressInformation(dec, &(val)->destinationEntityAddress))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkFacilityExtension(NetworkFacilityExtension *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_AddressInformation(&(val)->sourceEntityAddress);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_AddressInformation(&(val)->destinationEntityAddress);
    }
    }
}

static int ASN1CALL ASN1Enc_ActivateDiversionQArgument(ASN1encoding_t enc, ActivateDiversionQArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
    return 0;
    switch ((val)->basicService) {
    case 0:
    u = 0;
    break;
    case 1:
    u = 1;
    break;
    case 2:
    u = 2;
    break;
    case 3:
    u = 3;
    break;
    case 32:
    u = 4;
    break;
    case 33:
    u = 5;
    break;
    case 34:
    u = 6;
    break;
    case 35:
    u = 7;
    break;
    case 36:
    u = 8;
    break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToAddress))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->activatingUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_ActivateDiversionQArgument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ActivateDiversionQArgument(ASN1decoding_t dec, ActivateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 4, &u))
        return 0;
    switch (u) {
    case 0:
        (val)->basicService = 0;
        break;
    case 1:
        (val)->basicService = 1;
        break;
    case 2:
        (val)->basicService = 2;
        break;
    case 3:
        (val)->basicService = 3;
        break;
    case 4:
        (val)->basicService = 32;
        break;
    case 5:
        (val)->basicService = 33;
        break;
    case 6:
        (val)->basicService = 34;
        break;
    case 7:
        (val)->basicService = 35;
        break;
    case 8:
        (val)->basicService = 36;
        break;
    }
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToAddress))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->activatingUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_ActivateDiversionQArgument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ActivateDiversionQArgument(ActivateDiversionQArgument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->divertedToAddress);
    ASN1Free_EndpointAddress(&(val)->servedUserNr);
    ASN1Free_EndpointAddress(&(val)->activatingUserNr);
    if ((val)->o[0] & 0x80) {
        ASN1Free_ActivateDiversionQArgument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_DeactivateDiversionQArgument(ASN1encoding_t enc, DeactivateDiversionQArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
    return 0;
    switch ((val)->basicService) {
    case 0:
    u = 0;
    break;
    case 1:
    u = 1;
    break;
    case 2:
    u = 2;
    break;
    case 3:
    u = 3;
    break;
    case 32:
    u = 4;
    break;
    case 33:
    u = 5;
    break;
    case 34:
    u = 6;
    break;
    case 35:
    u = 7;
    break;
    case 36:
    u = 8;
    break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->deactivatingUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_DeactivateDiversionQArgument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DeactivateDiversionQArgument(ASN1decoding_t dec, DeactivateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 4, &u))
        return 0;
    switch (u) {
    case 0:
        (val)->basicService = 0;
        break;
    case 1:
        (val)->basicService = 1;
        break;
    case 2:
        (val)->basicService = 2;
        break;
    case 3:
        (val)->basicService = 3;
        break;
    case 4:
        (val)->basicService = 32;
        break;
    case 5:
        (val)->basicService = 33;
        break;
    case 6:
        (val)->basicService = 34;
        break;
    case 7:
        (val)->basicService = 35;
        break;
    case 8:
        (val)->basicService = 36;
        break;
    }
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->deactivatingUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_DeactivateDiversionQArgument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DeactivateDiversionQArgument(DeactivateDiversionQArgument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->servedUserNr);
    ASN1Free_EndpointAddress(&(val)->deactivatingUserNr);
    if ((val)->o[0] & 0x80) {
        ASN1Free_DeactivateDiversionQArgument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_InterrogateDiversionQArgument(ASN1encoding_t enc, InterrogateDiversionQArgument *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t u;
    CopyMemory(o, (val)->o, 1);
    if ((val)->basicService == 0)
    o[0] &= ~0x80;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
    return 0;
    if (o[0] & 0x80) {
    switch ((val)->basicService) {
    case 0:
        u = 0;
        break;
    case 1:
        u = 1;
        break;
    case 2:
        u = 2;
        break;
    case 3:
        u = 3;
        break;
    case 32:
        u = 4;
        break;
    case 33:
        u = 5;
        break;
    case 34:
        u = 6;
        break;
    case 35:
        u = 7;
        break;
    case 36:
        u = 8;
        break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
        return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
        return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->interrogatingUserNr))
    return 0;
    if (o[0] & 0x40) {
    if (!ASN1Enc_InterrogateDiversionQArgument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_InterrogateDiversionQArgument(ASN1decoding_t dec, InterrogateDiversionQArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecExtensionBit(dec, &x))
        return 0;
    if (!x) {
        if (!ASN1PERDecU32Val(dec, 4, &u))
        return 0;
        switch (u) {
        case 0:
        (val)->basicService = 0;
        break;
        case 1:
        (val)->basicService = 1;
        break;
        case 2:
        (val)->basicService = 2;
        break;
        case 3:
        (val)->basicService = 3;
        break;
        case 4:
        (val)->basicService = 32;
        break;
        case 5:
        (val)->basicService = 33;
        break;
        case 6:
        (val)->basicService = 34;
        break;
        case 7:
        (val)->basicService = 35;
        break;
        case 8:
        (val)->basicService = 36;
        break;
        }
    } else {
        if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->interrogatingUserNr))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_InterrogateDiversionQArgument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    if (!((val)->o[0] & 0x80))
    (val)->basicService = 0;
    return 1;
}

static void ASN1CALL ASN1Free_InterrogateDiversionQArgument(InterrogateDiversionQArgument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->servedUserNr);
    ASN1Free_EndpointAddress(&(val)->interrogatingUserNr);
    if ((val)->o[0] & 0x40) {
        ASN1Free_InterrogateDiversionQArgument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_CheckRestrictionArgument(ASN1encoding_t enc, CheckRestrictionArgument *val)
{
    ASN1uint32_t u;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
    return 0;
    switch ((val)->basicService) {
    case 0:
    u = 0;
    break;
    case 1:
    u = 1;
    break;
    case 2:
    u = 2;
    break;
    case 3:
    u = 3;
    break;
    case 32:
    u = 4;
    break;
    case 33:
    u = 5;
    break;
    case 34:
    u = 6;
    break;
    case 35:
    u = 7;
    break;
    case 36:
    u = 8;
    break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CheckRestrictionArgument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CheckRestrictionArgument(ASN1decoding_t dec, CheckRestrictionArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 4, &u))
        return 0;
    switch (u) {
    case 0:
        (val)->basicService = 0;
        break;
    case 1:
        (val)->basicService = 1;
        break;
    case 2:
        (val)->basicService = 2;
        break;
    case 3:
        (val)->basicService = 3;
        break;
    case 4:
        (val)->basicService = 32;
        break;
    case 5:
        (val)->basicService = 33;
        break;
    case 6:
        (val)->basicService = 34;
        break;
    case 7:
        (val)->basicService = 35;
        break;
    case 8:
        (val)->basicService = 36;
        break;
    }
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CheckRestrictionArgument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CheckRestrictionArgument(CheckRestrictionArgument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->servedUserNr);
    ASN1Free_EndpointAddress(&(val)->divertedToNr);
    if ((val)->o[0] & 0x80) {
        ASN1Free_CheckRestrictionArgument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_CallReroutingArgument(ASN1encoding_t enc, CallReroutingArgument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->reroutingReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncExtensionBitClear(enc))
        return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->originalReroutingReason))
        return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->calledAddress))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->diversionCounter - 1))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->h225InfoElement))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->lastReroutingNr))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_PartySubaddress(enc, &(val)->callingPartySubaddress))
        return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->callingNumber))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->callingInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->callingInfo).length, ((val)->callingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->originalCalledNr))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->originalCalledInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->originalCalledInfo).length, ((val)->originalCalledInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Enc_CallReroutingArgument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CallReroutingArgument(ASN1decoding_t dec, CallReroutingArgument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->reroutingReason))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecExtensionBit(dec, &x))
        return 0;
    if (!x) {
        if (!ASN1PERDecU32Val(dec, 2, &(val)->originalReroutingReason))
        return 0;
    } else {
        if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->calledAddress))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->diversionCounter))
    return 0;
    (val)->diversionCounter += 1;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->h225InfoElement))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->lastReroutingNr))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_PartySubaddress(dec, &(val)->callingPartySubaddress))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->callingNumber))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->callingInfo).length))
        return 0;
    ((val)->callingInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->callingInfo).length, &((val)->callingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->originalCalledNr))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
        return 0;
    ((val)->redirectingInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->originalCalledInfo).length))
        return 0;
    ((val)->originalCalledInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->originalCalledInfo).length, &((val)->originalCalledInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1Dec_CallReroutingArgument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CallReroutingArgument(CallReroutingArgument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->calledAddress);
    ASN1octetstring_free(&(val)->h225InfoElement);
    ASN1Free_EndpointAddress(&(val)->lastReroutingNr);
    if ((val)->o[0] & 0x40) {
        ASN1Free_PartySubaddress(&(val)->callingPartySubaddress);
    }
    ASN1Free_EndpointAddress(&(val)->callingNumber);
    if ((val)->o[0] & 0x20) {
        ASN1char16string_free(&(val)->callingInfo);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_EndpointAddress(&(val)->originalCalledNr);
    }
    if ((val)->o[0] & 0x8) {
        ASN1char16string_free(&(val)->redirectingInfo);
    }
    if ((val)->o[0] & 0x4) {
        ASN1char16string_free(&(val)->originalCalledInfo);
    }
    if ((val)->o[0] & 0x2) {
        ASN1Free_CallReroutingArgument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation1Argument(ASN1encoding_t enc, DivertingLegInformation1Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->nominatedNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->nominatedInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->nominatedInfo).length, ((val)->nominatedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectingNr))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_DivertingLegInformation1Argument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation1Argument(ASN1decoding_t dec, DivertingLegInformation1Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->nominatedNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->nominatedInfo).length))
        return 0;
    ((val)->nominatedInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->nominatedInfo).length, &((val)->nominatedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectingNr))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
        return 0;
    ((val)->redirectingInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_DivertingLegInformation1Argument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation1Argument(DivertingLegInformation1Argument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->nominatedNr);
    if ((val)->o[0] & 0x80) {
        ASN1char16string_free(&(val)->nominatedInfo);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_EndpointAddress(&(val)->redirectingNr);
    }
    if ((val)->o[0] & 0x20) {
        ASN1char16string_free(&(val)->redirectingInfo);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_DivertingLegInformation1Argument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation2Argument(ASN1encoding_t enc, DivertingLegInformation2Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->diversionCounter - 1))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncExtensionBitClear(enc))
        return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->originalDiversionReason))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertingNr))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->originalCalledNr))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectingInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectingInfo).length, ((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->originalCalledInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->originalCalledInfo).length, ((val)->originalCalledInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Enc_DivertingLegInformation2Argument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation2Argument(ASN1decoding_t dec, DivertingLegInformation2Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->diversionCounter))
    return 0;
    (val)->diversionCounter += 1;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecExtensionBit(dec, &x))
        return 0;
    if (!x) {
        if (!ASN1PERDecU32Val(dec, 2, &(val)->originalDiversionReason))
        return 0;
    } else {
        if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertingNr))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->originalCalledNr))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectingInfo).length))
        return 0;
    ((val)->redirectingInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectingInfo).length, &((val)->redirectingInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->originalCalledInfo).length))
        return 0;
    ((val)->originalCalledInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->originalCalledInfo).length, &((val)->originalCalledInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_DivertingLegInformation2Argument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation2Argument(DivertingLegInformation2Argument *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1Free_EndpointAddress(&(val)->divertingNr);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_EndpointAddress(&(val)->originalCalledNr);
    }
    if ((val)->o[0] & 0x10) {
        ASN1char16string_free(&(val)->redirectingInfo);
    }
    if ((val)->o[0] & 0x8) {
        ASN1char16string_free(&(val)->originalCalledInfo);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_DivertingLegInformation2Argument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation3Argument(ASN1encoding_t enc, DivertingLegInformation3Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->presentationAllowedIndicator))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNr))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_DivertingLegInformation3Argument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation3Argument(ASN1decoding_t dec, DivertingLegInformation3Argument *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->presentationAllowedIndicator))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNr))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
        return 0;
    ((val)->redirectionInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_DivertingLegInformation3Argument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation3Argument(DivertingLegInformation3Argument *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EndpointAddress(&(val)->redirectionNr);
    }
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->redirectionInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_DivertingLegInformation3Argument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_DivertingLegInformation4Argument(ASN1encoding_t enc, DivertingLegInformation4Argument *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->diversionReason))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->subscriptionOption))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->callingNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->callingInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->callingInfo).length, ((val)->callingInfo).value, 16))
        return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->nominatedNr))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->nominatedInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->nominatedInfo).length, ((val)->nominatedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_DivertingLegInformation4Argument_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DivertingLegInformation4Argument(ASN1decoding_t dec, DivertingLegInformation4Argument *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->diversionReason))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->subscriptionOption))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->callingNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->callingInfo).length))
        return 0;
    ((val)->callingInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->callingInfo).length, &((val)->callingInfo).value, 16))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->nominatedNr))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->nominatedInfo).length))
        return 0;
    ((val)->nominatedInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->nominatedInfo).length, &((val)->nominatedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_DivertingLegInformation4Argument_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DivertingLegInformation4Argument(DivertingLegInformation4Argument *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->callingNr);
    if ((val)->o[0] & 0x80) {
        ASN1char16string_free(&(val)->callingInfo);
    }
    ASN1Free_EndpointAddress(&(val)->nominatedNr);
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->nominatedInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_DivertingLegInformation4Argument_extension(&(val)->extension);
    }
    }
}

static int ASN1CALL ASN1Enc_IntResult(ASN1encoding_t enc, IntResult *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t u;
    CopyMemory(o, (val)->o, 1);
    if (!(val)->remoteEnabled)
    o[0] &= ~0x80;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->servedUserNr))
    return 0;
    switch ((val)->basicService) {
    case 0:
    u = 0;
    break;
    case 1:
    u = 1;
    break;
    case 2:
    u = 2;
    break;
    case 3:
    u = 3;
    break;
    case 32:
    u = 4;
    break;
    case 33:
    u = 5;
    break;
    case 34:
    u = 6;
    break;
    case 35:
    u = 7;
    break;
    case 36:
    u = 8;
    break;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, u))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->procedure))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->divertedToAddress))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1PEREncBoolean(enc, (val)->remoteEnabled))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1Enc_IntResult_extension(enc, &(val)->extension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResult(ASN1decoding_t dec, IntResult *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    ASN1uint32_t u;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->servedUserNr))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 4, &u))
        return 0;
    switch (u) {
    case 0:
        (val)->basicService = 0;
        break;
    case 1:
        (val)->basicService = 1;
        break;
    case 2:
        (val)->basicService = 2;
        break;
    case 3:
        (val)->basicService = 3;
        break;
    case 4:
        (val)->basicService = 32;
        break;
    case 5:
        (val)->basicService = 33;
        break;
    case 6:
        (val)->basicService = 34;
        break;
    case 7:
        (val)->basicService = 35;
        break;
    case 8:
        (val)->basicService = 36;
        break;
    }
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->procedure))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->divertedToAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecBoolean(dec, &(val)->remoteEnabled))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_IntResult_extension(dec, &(val)->extension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    if (!((val)->o[0] & 0x80))
    (val)->remoteEnabled = 0;
    return 1;
}

static void ASN1CALL ASN1Free_IntResult(IntResult *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->servedUserNr);
    ASN1Free_EndpointAddress(&(val)->divertedToAddress);
    if ((val)->o[0] & 0x40) {
        ASN1Free_IntResult_extension(&(val)->extension);
    }
    }
}

static ASN1stringtableentry_t CTInitiateArg_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTInitiateArg_callIdentity_StringTable = {
    2, CTInitiateArg_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTInitiateArg(ASN1encoding_t enc, CTInitiateArg *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
    return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTInitiateArg_callIdentity_StringTable))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->reroutingNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CTInitiateArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTInitiateArg(ASN1decoding_t dec, CTInitiateArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
    return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->callIdentity) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTInitiateArg_callIdentity_StringTable))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->reroutingNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CTInitiateArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTInitiateArg(CTInitiateArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->reroutingNumber);
    if ((val)->o[0] & 0x80) {
        ASN1Free_CTInitiateArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static ASN1stringtableentry_t CTSetupArg_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTSetupArg_callIdentity_StringTable = {
    2, CTSetupArg_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTSetupArg(ASN1encoding_t enc, CTSetupArg *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
    return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTSetupArg_callIdentity_StringTable))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->transferringNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CTSetupArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTSetupArg(ASN1decoding_t dec, CTSetupArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
    return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->callIdentity) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTSetupArg_callIdentity_StringTable))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->transferringNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CTSetupArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTSetupArg(CTSetupArg *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EndpointAddress(&(val)->transferringNumber);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_CTSetupArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static ASN1stringtableentry_t CTIdentifyRes_callIdentity_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t CTIdentifyRes_callIdentity_StringTable = {
    2, CTIdentifyRes_callIdentity_StringTableEntries
};

static int ASN1CALL ASN1Enc_CTIdentifyRes(ASN1encoding_t enc, CTIdentifyRes *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    t = lstrlenA((val)->callIdentity);
    if (!ASN1PEREncBitVal(enc, 3, t))
    return 0;
    //nik
    if (t!=0) ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->callIdentity, 4, &CTIdentifyRes_callIdentity_StringTable))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->reroutingNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CTIdentifyRes_resultExtension(enc, &(val)->resultExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTIdentifyRes(ASN1decoding_t dec, CTIdentifyRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecU32Val(dec, 3, &l))
    return 0;
    //nik
    if (l!=0) ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->callIdentity) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->callIdentity, 4, &CTIdentifyRes_callIdentity_StringTable))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->reroutingNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CTIdentifyRes_resultExtension(dec, &(val)->resultExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTIdentifyRes(CTIdentifyRes *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->reroutingNumber);
    if ((val)->o[0] & 0x80) {
        ASN1Free_CTIdentifyRes_resultExtension(&(val)->resultExtension);
    }
    }
}

static int ASN1CALL ASN1Enc_CTUpdateArg(ASN1encoding_t enc, CTUpdateArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_CTUpdateArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTUpdateArg(ASN1decoding_t dec, CTUpdateArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
        return 0;
    ((val)->redirectionInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_CTUpdateArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTUpdateArg(CTUpdateArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->redirectionNumber);
    if ((val)->o[0] & 0x80) {
        ASN1char16string_free(&(val)->redirectionInfo);
    }
    if ((val)->o[0] & 0x40) {
        ASN1octetstring_free(&(val)->basicCallInfoElements);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_CTUpdateArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static int ASN1CALL ASN1Enc_CTCompleteArg(ASN1encoding_t enc, CTCompleteArg *val)
{
    ASN1octet_t o[1];
    CopyMemory(o, (val)->o, 1);
    if ((val)->callStatus == 0)
    o[0] &= ~0x20;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, o))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->endDesignation))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->redirectionNumber))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->redirectionInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->redirectionInfo).length, ((val)->redirectionInfo).value, 16))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1PEREncExtensionBitClear(enc))
        return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->callStatus))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1Enc_CTCompleteArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTCompleteArg(ASN1decoding_t dec, CTCompleteArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 1, &(val)->endDesignation))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->redirectionNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->redirectionInfo).length))
        return 0;
    ((val)->redirectionInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->redirectionInfo).length, &((val)->redirectionInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecExtensionBit(dec, &x))
        return 0;
    if (!x) {
        if (!ASN1PERDecU32Val(dec, 1, &(val)->callStatus))
        return 0;
    } else {
        if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_CTCompleteArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    if (!((val)->o[0] & 0x20))
    (val)->callStatus = 0;
    return 1;
}

static void ASN1CALL ASN1Free_CTCompleteArg(CTCompleteArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->redirectionNumber);
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->basicCallInfoElements);
    }
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->redirectionInfo);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_CTCompleteArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static int ASN1CALL ASN1Enc_CTActiveArg(ASN1encoding_t enc, CTActiveArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->connectedAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->basicCallInfoElements))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 7, ((val)->connectedInfo).length - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->connectedInfo).length, ((val)->connectedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_CTActiveArg_argumentExtension(enc, &(val)->argumentExtension))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CTActiveArg(ASN1decoding_t dec, CTActiveArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->connectedAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->basicCallInfoElements))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 7, &((val)->connectedInfo).length))
        return 0;
    ((val)->connectedInfo).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->connectedInfo).length, &((val)->connectedInfo).value, 16))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_CTActiveArg_argumentExtension(dec, &(val)->argumentExtension))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CTActiveArg(CTActiveArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->connectedAddress);
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->basicCallInfoElements);
    }
    if ((val)->o[0] & 0x40) {
        ASN1char16string_free(&(val)->connectedInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_CTActiveArg_argumentExtension(&(val)->argumentExtension);
    }
    }
}

static int ASN1CALL ASN1Enc_CpRequestArg(ASN1encoding_t enc, CpRequestArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedNumber))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpRequestArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestArg(ASN1decoding_t dec, CpRequestArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedNumber))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpRequestArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestArg(CpRequestArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->parkingNumber);
    ASN1Free_EndpointAddress(&(val)->parkedNumber);
    ASN1Free_EndpointAddress(&(val)->parkedToNumber);
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpRequestArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_CpRequestRes(ASN1encoding_t enc, CpRequestRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
        return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->parkCondition))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpRequestRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpRequestRes(ASN1decoding_t dec, CpRequestRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->parkCondition))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpRequestRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpRequestRes(CpRequestRes *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->parkedToNumber);
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpRequestRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_CpSetupArg(ASN1encoding_t enc, CpSetupArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedNumber))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpSetupArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupArg(ASN1decoding_t dec, CpSetupArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedNumber))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpSetupArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupArg(CpSetupArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->parkingNumber);
    ASN1Free_EndpointAddress(&(val)->parkedNumber);
    ASN1Free_EndpointAddress(&(val)->parkedToNumber);
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpSetupArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_CpSetupRes(ASN1encoding_t enc, CpSetupRes *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkedToPosition))
        return 0;
    }
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->parkCondition))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpSetupRes_extensionRes(enc, &(val)->extensionRes))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpSetupRes(ASN1decoding_t dec, CpSetupRes *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkedToNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkedToPosition))
        return 0;
    }
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 2, &(val)->parkCondition))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpSetupRes_extensionRes(dec, &(val)->extensionRes))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpSetupRes(CpSetupRes *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->parkedToNumber);
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpSetupRes_extensionRes(&(val)->extensionRes);
    }
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOnArg(ASN1encoding_t enc, GroupIndicationOnArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->groupMemberUserNr))
    return 0;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->retrieveCallType))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->retrieveAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_GroupIndicationOnArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOnArg(ASN1decoding_t dec, GroupIndicationOnArg *val)
{
    ASN1uint32_t y;
    ASN1uint32_t x;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->groupMemberUserNr))
    return 0;
    if (!ASN1PERDecExtensionBit(dec, &x))
    return 0;
    if (!x) {
    if (!ASN1PERDecU32Val(dec, 1, &(val)->retrieveCallType))
        return 0;
    } else {
    if (!ASN1PERDecSkipNormallySmall(dec))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->retrieveAddress))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkPosition))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_GroupIndicationOnArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOnArg(GroupIndicationOnArg *val)
{
    if (val) {
    ASN1Free_CallIdentifier(&(val)->callPickupId);
    ASN1Free_EndpointAddress(&(val)->groupMemberUserNr);
    ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
    ASN1Free_EndpointAddress(&(val)->retrieveAddress);
    if ((val)->o[0] & 0x40) {
        ASN1Free_GroupIndicationOnArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_GroupIndicationOffArg(ASN1encoding_t enc, GroupIndicationOffArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->groupMemberUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_GroupIndicationOffArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_GroupIndicationOffArg(ASN1decoding_t dec, GroupIndicationOffArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->groupMemberUserNr))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_GroupIndicationOffArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_GroupIndicationOffArg(GroupIndicationOffArg *val)
{
    if (val) {
    ASN1Free_CallIdentifier(&(val)->callPickupId);
    ASN1Free_EndpointAddress(&(val)->groupMemberUserNr);
    if ((val)->o[0] & 0x80) {
        ASN1Free_GroupIndicationOffArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_PickrequArg(ASN1encoding_t enc, PickrequArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 4, (val)->o))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
        return 0;
    }
    if (!ASN1Enc_EndpointAddress(enc, &(val)->retrieveAddress))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->parkPosition))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_PickrequArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickrequArg(ASN1decoding_t dec, PickrequArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 4, (val)->o))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
        return 0;
    }
    if (!ASN1Dec_EndpointAddress(dec, &(val)->retrieveAddress))
    return 0;
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->parkPosition))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_PickrequArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickrequArg(PickrequArg *val)
{
    if (val) {
    ASN1Free_EndpointAddress(&(val)->picking_upNumber);
    if ((val)->o[0] & 0x80) {
        ASN1Free_CallIdentifier(&(val)->callPickupId);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
    }
    ASN1Free_EndpointAddress(&(val)->retrieveAddress);
    if ((val)->o[0] & 0x10) {
        ASN1Free_PickrequArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_PickupArg(ASN1encoding_t enc, PickupArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_PickupArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickupArg(ASN1decoding_t dec, PickupArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_PickupArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickupArg(PickupArg *val)
{
    if (val) {
    ASN1Free_CallIdentifier(&(val)->callPickupId);
    ASN1Free_EndpointAddress(&(val)->picking_upNumber);
    if ((val)->o[0] & 0x80) {
        ASN1Free_PickupArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_PickExeArg(ASN1encoding_t enc, PickExeArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_CallIdentifier(enc, &(val)->callPickupId))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
    return 0;
    if (!ASN1Enc_EndpointAddress(enc, &(val)->partyToRetrieve))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_PickExeArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_PickExeArg(ASN1decoding_t dec, PickExeArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_CallIdentifier(dec, &(val)->callPickupId))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
    return 0;
    if (!ASN1Dec_EndpointAddress(dec, &(val)->partyToRetrieve))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_PickExeArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_PickExeArg(PickExeArg *val)
{
    if (val) {
    ASN1Free_CallIdentifier(&(val)->callPickupId);
    ASN1Free_EndpointAddress(&(val)->picking_upNumber);
    ASN1Free_EndpointAddress(&(val)->partyToRetrieve);
    if ((val)->o[0] & 0x80) {
        ASN1Free_PickExeArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_CpNotifyArg(ASN1encoding_t enc, CpNotifyArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->parkingNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpNotifyArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpNotifyArg(ASN1decoding_t dec, CpNotifyArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->parkingNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpNotifyArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpNotifyArg(CpNotifyArg *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EndpointAddress(&(val)->parkingNumber);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpNotifyArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_CpickupNotifyArg(ASN1encoding_t enc, CpickupNotifyArg *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EndpointAddress(enc, &(val)->picking_upNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CpickupNotifyArg_extensionArg(enc, &(val)->extensionArg))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CpickupNotifyArg(ASN1decoding_t dec, CpickupNotifyArg *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EndpointAddress(dec, &(val)->picking_upNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CpickupNotifyArg_extensionArg(dec, &(val)->extensionArg))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CpickupNotifyArg(CpickupNotifyArg *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EndpointAddress(&(val)->picking_upNumber);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_CpickupNotifyArg_extensionArg(&(val)->extensionArg);
    }
    }
}

static int ASN1CALL ASN1Enc_H4501SupplementaryService(ASN1encoding_t enc, H4501SupplementaryService *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NetworkFacilityExtension(enc, &(val)->networkFacilityExtension))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_InterpretationApdu(enc, &(val)->interpretationApdu))
        return 0;
    }
    if (!ASN1Enc_ServiceApdus(enc, &(val)->serviceApdu))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H4501SupplementaryService(ASN1decoding_t dec, H4501SupplementaryService *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NetworkFacilityExtension(dec, &(val)->networkFacilityExtension))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_InterpretationApdu(dec, &(val)->interpretationApdu))
        return 0;
    }
    if (!ASN1Dec_ServiceApdus(dec, &(val)->serviceApdu))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H4501SupplementaryService(H4501SupplementaryService *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NetworkFacilityExtension(&(val)->networkFacilityExtension);
    }
    ASN1Free_ServiceApdus(&(val)->serviceApdu);
    }
}

static int ASN1CALL ASN1Enc_IntResultList(ASN1encoding_t enc, IntResultList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 5, (val)->count))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_IntResult(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntResultList(ASN1decoding_t dec, IntResultList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 5, &(val)->count))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_IntResult(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntResultList(IntResultList *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_IntResult(&(val)->value[i]);
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\asn\h245asn.c ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#include <windows.h>
#include "h245asn.h"

ASN1module_t H245ASN_Module = NULL;

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val);
static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val);
static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val);
static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val);
static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val);
static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val);
static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val);
static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val);
static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val);
static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val);
static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val);
static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val);
static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val);
static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val);
static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val);
static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val);
static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val);
static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val);
static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val);
static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val);
static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val);
static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val);
static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val);
static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val);
static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val);
static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val);
static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val);
static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val);
static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val);
static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val);
static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val);
static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val);
static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val);
static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val);
static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val);
static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val);
static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val);
static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val);
static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val);
static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val);
static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val);
static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val);
static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val);
static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val);
static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val);
static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val);
static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val);
static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val);
static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val);
static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val);
static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val);
static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val);
static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val);
static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val);
static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val);
static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val);
static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val);
static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val);
static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val);
static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val);
static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val);
static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val);
static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val);
static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val);
static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val);
static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val);
static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val);
static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val);
static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val);
static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val);
static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val);
static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val);
static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val);
static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val);
static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val);
static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val);
static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val);
static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val);
static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val);
static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val);
static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val);
static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val);
static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val);
static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val);
static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val);
static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val);
static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val);
static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val);
static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val);
static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val);
static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val);
static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val);
static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val);
static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val);
static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val);
static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val);
static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val);
static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val);
static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val);
static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val);
static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val);
static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val);
static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val);
static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val);
static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val);
static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val);
static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val);
static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val);
static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val);
static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val);
static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val);
static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val);
static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val);
static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val);
static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val);
static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val);
static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val);
static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val);
static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val);
static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val);
static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val);
static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val);
static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val);
static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val);
static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val);
static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val);
static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val);
static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val);
static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val);
static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val);
static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val);
static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val);
static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val);
static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val);
static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val);
static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val);
static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val);
static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val);
static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val);
static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val);
static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val);
static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val);
static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val);
static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val);
static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val);
static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val);
static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val);
static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val);
static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val);
static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val);
static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val);
static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val);
static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val);
static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val);
static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val);
static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val);
static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val);
static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val);
static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val);
static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val);
static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val);
static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val);
static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val);
static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val);
static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val);
static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val);
static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val);
static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val);
static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val);
static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val);
static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val);
static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val);
static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val);
static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val);
static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val);
static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val);
static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val);
static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val);
static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val);
static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val);
static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val);
static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val);
static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val);
static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val);
static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val);
static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val);
static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val);
static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val);
static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val);
static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val);
static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val);
static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val);
static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val);
static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val);
static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val);
static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val);
static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val);
static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val);
static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val);
static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val);
static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val);
static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val);
static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val);
static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val);
static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val);
static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val);
static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val);
static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val);
static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val);
static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val);
static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val);
static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val);
static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val);
static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val);
static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val);
static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val);
static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val);
static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val);
static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val);
static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val);
static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val);
static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val);
static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val);
static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val);
static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val);
static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val);
static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val);
static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val);
static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val);
static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val);
static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val);
static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val);
static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val);
static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val);
static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val);
static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val);
static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val);
static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val);
static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val);
static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val);
static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val);
static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val);
static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val);
static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val);
static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val);
static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val);
static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val);
static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val);
static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val);
static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val);
static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val);
static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val);
static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val);
static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val);
static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val);
static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val);
static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val);
static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val);
static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val);
static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val);
static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val);
static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val);
static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val);
static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val);
static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val);
static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val);
static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val);
static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val);
static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val);
static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val);
static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val);
static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val);
static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val);
static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val);
static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val);
static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val);
static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val);
static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val);
static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val);
static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val);
static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val);
static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val);
static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val);
static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val);
static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val);
static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val);
static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val);
static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val);
static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val);
static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val);
static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val);
static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val);
static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val);
static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val);
static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val);
static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val);
static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val);
static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val);
static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val);
static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val);
static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val);
static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val);
static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val);
static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val);
static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val);
static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val);
static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val);
static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val);
static void ASN1CALL ASN1Free_H222Capability(H222Capability *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val);
static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val);
static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val);
static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val);
static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val);
static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_EscrowData(EscrowData *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val);
static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val);
static void ASN1CALL ASN1Free_RequestMode(RequestMode *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val);
static void ASN1CALL ASN1Free_Criteria(Criteria *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val);
static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val);
static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val);
static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val);
static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val);
static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val);
static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val);
static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val);
static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val);
static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val);
static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val);
static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val);
static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val);
static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val);
static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val);
static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val);
static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val);
static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val);
static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val);
static void ASN1CALL ASN1Free_H263Options(H263Options *val);
static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val);
static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val);
static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val);
static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val);
static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val);
static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val);
static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val);
static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val);
static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val);
static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val);
static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val);
static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val);
static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val);
static void ASN1CALL ASN1Free_AudioMode(AudioMode *val);
static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val);
static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val);
static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val);
static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val);
static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val);
static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val);
static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val);
static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val);
static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val);
static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val);
static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val);
static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val);
static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val);
static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val);
static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val);
static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val);
static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val);
static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val);
static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val);
static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val);
static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val);
static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val);
static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val);
static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val);
static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val);
static void ASN1CALL ASN1Free_VideoMode(VideoMode *val);
static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val);
static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val);
static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val);
static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val);
static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val);
static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val);
static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val);
static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val);
static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val);
static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val);
static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val);
static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val);
static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val);
static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val);
static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val);
static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val);
static void ASN1CALL ASN1Free_DataMode(DataMode *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val);
static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val);
static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val);
static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val);
static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val);
static void ASN1CALL ASN1Free_Capability(Capability *val);
static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val);
static void ASN1CALL ASN1Free_H235Media(H235Media *val);
static void ASN1CALL ASN1Free_H235Mode(H235Mode *val);
static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val);
static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val);
static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val);
static void ASN1CALL ASN1Free_DataType(DataType *val);
static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val);
static void ASN1CALL ASN1Free_ModeElement(ModeElement *val);
static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val);
static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val);
static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val);
static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val);
static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val);
static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val);
static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val);
static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val);
static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val);
static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val);
static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val);
static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val);
static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val);
static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val);
static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[2] = {
    (ASN1EncFun_t) ASN1Enc_FastConnectOLC,
    (ASN1EncFun_t) ASN1Enc_MultimediaSystemControlMessage,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[2] = {
    (ASN1DecFun_t) ASN1Dec_FastConnectOLC,
    (ASN1DecFun_t) ASN1Dec_MultimediaSystemControlMessage,
};
static const ASN1FreeFun_t freefntab[2] = {
    (ASN1FreeFun_t) ASN1Free_FastConnectOLC,
    (ASN1FreeFun_t) ASN1Free_MultimediaSystemControlMessage,
};
static const ULONG sizetab[2] = {
    SIZE_H245ASN_Module_PDU_0,
    SIZE_H245ASN_Module_PDU_1,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL H245ASN_Module_Startup(void)
{
    H245ASN_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 2, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x35343268);
}

void ASN1CALL H245ASN_Module_Cleanup(void)
{
    ASN1_CloseModule(H245ASN_Module);
    H245ASN_Module = NULL;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_errorCorrection *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(ASN1encoding_t enc, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(ASN1decoding_t dec, NewATMVCIndication_aal_aal1_clockRecovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM_recovery *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->width - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->height - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->width))
    return 0;
    (val)->width += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->height))
    return 0;
    (val)->height += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF_Set *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->customMPI - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF_Set *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
    return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
    return 0;
    (val)->clockDivisor += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->customMPI))
    return 0;
    (val)->customMPI += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1encoding_t enc, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PEREncUnsignedShort(enc, (val)->lowerBitRate - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->higherBitRate - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(ASN1decoding_t dec, VCCapability_availableBitRates_type_rangeOfBitRates *val)
{
    if (!ASN1PERDecUnsignedShort(dec, &(val)->lowerBitRate))
    return 0;
    (val)->lowerBitRate += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->higherBitRate))
    return 0;
    (val)->higherBitRate += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1encoding_t enc, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.highestEntryNumberProcessed - 1))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(ASN1decoding_t dec, TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.highestEntryNumberProcessed))
        return 0;
    (val)->u.highestEntryNumberProcessed += 1;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates_type(ASN1encoding_t enc, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.singleBitRate - 1))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_VCCapability_availableBitRates_type_rangeOfBitRates(enc, &(val)->u.rangeOfBitRates))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates_type(ASN1decoding_t dec, VCCapability_availableBitRates_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.singleBitRate))
        return 0;
    (val)->u.singleBitRate += 1;
    break;
    case 2:
    if (!ASN1Dec_VCCapability_availableBitRates_type_rangeOfBitRates(dec, &(val)->u.rangeOfBitRates))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->maximumNestingDepth - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumElementListSize - 2))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumSubElementListSize - 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability_enhanced *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->maximumNestingDepth))
    return 0;
    (val)->maximumNestingDepth += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumElementListSize))
    return 0;
    (val)->maximumElementListSize += 2;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumSubElementListSize))
    return 0;
    (val)->maximumSubElementListSize += 2;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI_customPCF(ASN1encoding_t enc, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_CustomPictureFormat_mPI_customPCF_Set(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI_customPCF(ASN1decoding_t dec, CustomPictureFormat_mPI_customPCF *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_CustomPictureFormat_mPI_customPCF_Set(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI_customPCF(CustomPictureFormat_mPI_customPCF *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR_Set(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(CustomPictureFormat_pixelAspectInformation_extendedPAR *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(CustomPictureFormat_pixelAspectInformation_pixelAspectCode *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
    return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode_eRM(ASN1encoding_t enc, V76LogicalChannelParameters_mode_eRM *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->windowSize - 1))
    return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM_recovery(enc, &(val)->recovery))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode_eRM(ASN1decoding_t dec, V76LogicalChannelParameters_mode_eRM *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->windowSize))
    return 0;
    (val)->windowSize += 1;
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM_recovery(dec, &(val)->recovery))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route(PUnicastAddress_iPSourceRouteAddress_route *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress_routing *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType_al3(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncBitVal(enc, 2, (val)->controlFieldOctets))
    return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType_al3(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType_al3 *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->controlFieldOctets))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, 1, 65535, 16);
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn, sizeof(**val), 1, 65535, 16);
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
    return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn);
    }
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ASN1encoding_t enc, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(enc, &(val)->repeatCount))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(ASN1decoding_t dec, MiscellaneousCommand_type_progressiveRefinementStart *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(dec, &(val)->repeatCount))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->firstGOB))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
        return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateMB *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->firstGOB))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
        return 0;
    (val)->firstMB += 1;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
    return 0;
    (val)->numberOfMBs += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1encoding_t enc, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PEREncBitVal(enc, 5, (val)->firstGOB))
    return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->numberOfGOBs - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(ASN1decoding_t dec, MiscellaneousCommand_type_videoFastUpdateGOB *val)
{
    if (!ASN1PERDecU16Val(dec, 5, &(val)->firstGOB))
    return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->numberOfGOBs))
    return 0;
    (val)->numberOfGOBs += 1;
    return 1;
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1encoding_t enc, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->firstMB - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numberOfMBs - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->temporalReference))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(ASN1decoding_t dec, MiscellaneousIndication_type_videoNotDecodedMBs *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->firstMB))
    return 0;
    (val)->firstMB += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numberOfMBs))
    return 0;
    (val)->numberOfMBs += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->temporalReference))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal5(ASN1encoding_t enc, NewATMVCIndication_aal_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal5(ASN1decoding_t dec, NewATMVCIndication_aal_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal_aal1(ASN1encoding_t enc, NewATMVCIndication_aal_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_clockRecovery(enc, &(val)->clockRecovery))
    return 0;
    if (!ASN1Enc_NewATMVCIndication_aal_aal1_errorCorrection(enc, &(val)->errorCorrection))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal_aal1(ASN1decoding_t dec, NewATMVCIndication_aal_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_clockRecovery(dec, &(val)->clockRecovery))
    return 0;
    if (!ASN1Dec_NewATMVCIndication_aal_aal1_errorCorrection(dec, &(val)->errorCorrection))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(ASN1encoding_t enc, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(ASN1decoding_t dec, NewATMVCIndication_reverseParameters_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal_rtp(ASN1encoding_t enc, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->timestamp);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->timestamp))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->expirationTime);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->expirationTime))
        return 0;
    }
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal_rtp(ASN1decoding_t dec, UserInputIndication_signal_rtp *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->timestamp))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->expirationTime))
        return 0;
    }
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
    return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate_rtp(ASN1encoding_t enc, UserInputIndication_signalUpdate_rtp *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate_rtp(ASN1decoding_t dec, UserInputIndication_signalUpdate_rtp *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
    return 0;
    (val)->logicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signalUpdate(ASN1encoding_t enc, UserInputIndication_signalUpdate *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_UserInputIndication_signalUpdate_rtp(enc, &(val)->rtp))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signalUpdate(ASN1decoding_t dec, UserInputIndication_signalUpdate *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
    return 0;
    (val)->duration += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_UserInputIndication_signalUpdate_rtp(dec, &(val)->rtp))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UserInputIndication_signal(ASN1encoding_t enc, UserInputIndication_signal *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    t = lstrlenA((val)->signalType);
    if (!ASN1PEREncCharString(enc, t, (val)->signalType, 8))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->duration - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_UserInputIndication_signal_rtp(enc, &(val)->rtp))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_signal(ASN1decoding_t dec, UserInputIndication_signal *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;

    //NikhilB: Fix for the overflow bug 03/02/26
    if (1 >= sizeof((val)->signalType)) { 
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroCharStringNoAlloc(dec, 1, (val)->signalType, 8))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->duration))
        return 0;
    (val)->duration += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_UserInputIndication_signal_rtp(dec, &(val)->rtp))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_signal(UserInputIndication_signal *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_reverseParameters(ASN1encoding_t enc, NewATMVCIndication_reverseParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
    return 0;
    if (!ASN1Enc_NewATMVCIndication_reverseParameters_multiplex(enc, &(val)->multiplex))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_reverseParameters(ASN1decoding_t dec, NewATMVCIndication_reverseParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
    return 0;
    if (!ASN1Dec_NewATMVCIndication_reverseParameters_multiplex(dec, &(val)->multiplex))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_multiplex(ASN1encoding_t enc, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_multiplex(ASN1decoding_t dec, NewATMVCIndication_multiplex *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NewATMVCIndication_aal(ASN1encoding_t enc, NewATMVCIndication_aal *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NewATMVCIndication_aal_aal1(enc, &(val)->u.aal1))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_NewATMVCIndication_aal_aal5(enc, &(val)->u.aal5))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication_aal(ASN1decoding_t dec, NewATMVCIndication_aal *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NewATMVCIndication_aal_aal1(dec, &(val)->u.aal1))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_NewATMVCIndication_aal_aal5(dec, &(val)->u.aal5))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication_scope(ASN1encoding_t enc, JitterIndication_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
        return 0;
    break;
    case 3:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication_scope(ASN1decoding_t dec, JitterIndication_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
        return 0;
    (val)->u.logicalChannelNumber += 1;
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
        return 0;
    break;
    case 3:
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported_cause(ASN1encoding_t enc, FunctionNotSupported_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported_cause(ASN1decoding_t dec, FunctionNotSupported_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1encoding_t enc, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(ASN1decoding_t dec, H223MultiplexReconfiguration_h223AnnexADoubleFlag *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(ASN1encoding_t enc, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(ASN1decoding_t dec, H223MultiplexReconfiguration_h223ModeChange *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_isdnOptions(ASN1encoding_t enc, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_isdnOptions(ASN1decoding_t dec, EndSessionCommand_isdnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EndSessionCommand_gstnOptions(ASN1encoding_t enc, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand_gstnOptions(ASN1decoding_t dec, EndSessionCommand_gstnOptions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_restriction(ASN1encoding_t enc, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    l = ASN1uint32_uoctets((val)->u.maximumBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->u.maximumBitRate))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_restriction(ASN1decoding_t dec, FlowControlCommand_restriction *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->u.maximumBitRate))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FlowControlCommand_scope(ASN1encoding_t enc, FlowControlCommand_scope *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber - 1))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.resourceID))
        return 0;
    break;
    case 3:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand_scope(ASN1decoding_t dec, FlowControlCommand_scope *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
        return 0;
    (val)->u.logicalChannelNumber += 1;
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.resourceID))
        return 0;
    break;
    case 3:
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest(ASN1encoding_t enc, SendTerminalCapabilitySet_specificRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiplexCapability))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(enc, &(val)->capabilityTableEntryNumbers))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(enc, &(val)->capabilityDescriptorNumbers))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest(ASN1decoding_t dec, SendTerminalCapabilitySet_specificRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiplexCapability))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(dec, &(val)->capabilityTableEntryNumbers))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(dec, &(val)->capabilityDescriptorNumbers))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest(SendTerminalCapabilitySet_specificRequest *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers(&(val)->capabilityTableEntryNumbers);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers(&(val)->capabilityDescriptorNumbers);
    }
    }
}

static int ASN1CALL ASN1Enc_RemoteMCResponse_reject(ASN1encoding_t enc, RemoteMCResponse_reject *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse_reject(ASN1decoding_t dec, RemoteMCResponse_reject *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_sendThisSourceResponse(ASN1encoding_t enc, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_sendThisSourceResponse(ASN1decoding_t dec, ConferenceResponse_sendThisSourceResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1encoding_t enc, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(ASN1decoding_t dec, ConferenceResponse_makeTerminalBroadcasterResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1encoding_t enc, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(ASN1decoding_t dec, ConferenceResponse_broadcastMyLogicalChannelResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceResponse_extensionAddressResponse(ASN1encoding_t enc, ConferenceResponse_extensionAddressResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_extensionAddressResponse(ASN1decoding_t dec, ConferenceResponse_extensionAddressResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->extensionAddress, 1, 128, 7))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_extensionAddressResponse(ConferenceResponse_extensionAddressResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_makeMeChairResponse(ASN1encoding_t enc, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_makeMeChairResponse(ASN1decoding_t dec, ConferenceResponse_makeMeChairResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_cause(ASN1encoding_t enc, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_cause(ASN1decoding_t dec, MaintenanceLoopReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject_type(ASN1encoding_t enc, MaintenanceLoopReject_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
        return 0;
    break;
    case 3:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject_type(ASN1decoding_t dec, MaintenanceLoopReject_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
        return 0;
    (val)->u.mediaLoop += 1;
    break;
    case 3:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
        return 0;
    (val)->u.logicalChannelLoop += 1;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck_type(ASN1encoding_t enc, MaintenanceLoopAck_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
        return 0;
    break;
    case 3:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck_type(ASN1decoding_t dec, MaintenanceLoopAck_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
        return 0;
    (val)->u.mediaLoop += 1;
    break;
    case 3:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
        return 0;
    (val)->u.logicalChannelLoop += 1;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest_type(ASN1encoding_t enc, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.mediaLoop - 1))
        return 0;
    break;
    case 3:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelLoop - 1))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest_type(ASN1decoding_t dec, MaintenanceLoopRequest_type *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.mediaLoop))
        return 0;
    (val)->u.mediaLoop += 1;
    break;
    case 3:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelLoop))
        return 0;
    (val)->u.logicalChannelLoop += 1;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCMode_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
    return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
    return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
    return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
    return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
    return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
    return 0;
    (val)->sidMode1 += 6;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_multichannelType(ASN1encoding_t enc, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_multichannelType(ASN1decoding_t dec, IS13818AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioSampling(ASN1encoding_t enc, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioSampling(ASN1decoding_t dec, IS13818AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode_audioLayer(ASN1encoding_t enc, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode_audioLayer(ASN1decoding_t dec, IS13818AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_multichannelType(ASN1encoding_t enc, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_multichannelType(ASN1decoding_t dec, IS11172AudioMode_multichannelType *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioSampling(ASN1encoding_t enc, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioSampling(ASN1decoding_t dec, IS11172AudioMode_audioSampling *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode_audioLayer(ASN1encoding_t enc, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode_audioLayer(ASN1decoding_t dec, IS11172AudioMode_audioLayer *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_AudioMode_g7231(ASN1encoding_t enc, AudioMode_g7231 *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode_g7231(ASN1decoding_t dec, AudioMode_g7231 *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoMode_resolution(ASN1encoding_t enc, H263VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode_resolution(ASN1decoding_t dec, H263VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode_profileAndLevel(ASN1encoding_t enc, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode_profileAndLevel(ASN1decoding_t dec, H262VideoMode_profileAndLevel *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode_resolution(ASN1encoding_t enc, H261VideoMode_resolution *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode_resolution(ASN1decoding_t dec, H261VideoMode_resolution *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject_cause(ASN1encoding_t enc, RequestModeReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject_cause(ASN1decoding_t dec, RequestModeReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeAck_response(ASN1encoding_t enc, RequestModeAck_response *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck_response(ASN1decoding_t dec, RequestModeAck_response *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryRelease_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease_entryNumbers(RequestMultiplexEntryRelease_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryReject_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_entryNumbers(RequestMultiplexEntryReject_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntryAck_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck_entryNumbers(RequestMultiplexEntryAck_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry_entryNumbers(ASN1encoding_t enc, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry_entryNumbers(ASN1decoding_t dec, RequestMultiplexEntry_entryNumbers *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry_entryNumbers(RequestMultiplexEntry_entryNumbers *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(MultiplexEntrySendRelease_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions_cause(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions_cause(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1encoding_t enc, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(ASN1decoding_t dec, MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(MultiplexEntrySendAck_multiplexTableEntryNumber *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_repeatCount(ASN1encoding_t enc, MultiplexElement_repeatCount *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.finite - 1))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_repeatCount(ASN1decoding_t dec, MultiplexElement_repeatCount *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.finite))
        return 0;
    (val)->u.finite += 1;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexElement_type(ASN1encoding_t enc, MultiplexElement_type *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.logicalChannelNumber))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MultiplexElement_type_subElementList(enc, &(val)->u.subElementList))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type(ASN1decoding_t dec, MultiplexElement_type *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.logicalChannelNumber))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MultiplexElement_type_subElementList(dec, &(val)->u.subElementList))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type(MultiplexElement_type *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1Free_MultiplexElement_type_subElementList(&(val)->u.subElementList);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject_cause(ASN1encoding_t enc, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject_cause(ASN1decoding_t dec, RequestChannelCloseReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelClose_reason(ASN1encoding_t enc, RequestChannelClose_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose_reason(ASN1decoding_t dec, RequestChannelClose_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_reason(ASN1encoding_t enc, CloseLogicalChannel_reason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_reason(ASN1decoding_t dec, CloseLogicalChannel_reason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel_source(ASN1encoding_t enc, CloseLogicalChannel_source *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel_source(ASN1decoding_t dec, CloseLogicalChannel_source *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject_cause(ASN1encoding_t enc, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject_cause(ASN1decoding_t dec, OpenLogicalChannelReject_cause *val)
{
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MulticastAddress_iP6Address(ASN1encoding_t enc, MulticastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iP6Address(ASN1decoding_t dec, MulticastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iP6Address(MulticastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress_iPAddress(ASN1encoding_t enc, MulticastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress_iPAddress(ASN1decoding_t dec, MulticastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress_iPAddress(MulticastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress(ASN1encoding_t enc, UnicastAddress_iPSourceRouteAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_routing(enc, &(val)->routing))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
    return 0;
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress_route(enc, &(val)->route))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress(ASN1decoding_t dec, UnicastAddress_iPSourceRouteAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_routing(dec, &(val)->routing))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
    return 0;
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress_route(dec, &(val)->route))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress(UnicastAddress_iPSourceRouteAddress *val)
{
    if (val) {
    ASN1Free_UnicastAddress_iPSourceRouteAddress_route(&(val)->route);
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iP6Address(ASN1encoding_t enc, UnicastAddress_iP6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 16))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iP6Address(ASN1decoding_t dec, UnicastAddress_iP6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 16))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iP6Address(UnicastAddress_iP6Address *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPXAddress(ASN1encoding_t enc, UnicastAddress_iPXAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPXAddress(ASN1decoding_t dec, UnicastAddress_iPXAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->tsapIdentifier, 2))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPXAddress(UnicastAddress_iPXAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_UnicastAddress_iPAddress(ASN1encoding_t enc, UnicastAddress_iPAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->tsapIdentifier))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress_iPAddress(ASN1decoding_t dec, UnicastAddress_iPAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->network, 4))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->tsapIdentifier))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress_iPAddress(UnicastAddress_iPAddress *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_mode(ASN1encoding_t enc, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_V76LogicalChannelParameters_mode_eRM(enc, &(val)->u.eRM))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_mode(ASN1decoding_t dec, V76LogicalChannelParameters_mode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_V76LogicalChannelParameters_mode_eRM(dec, &(val)->u.eRM))
        return 0;
    break;
    case 2:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters_suspendResume(ASN1encoding_t enc, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters_suspendResume(ASN1decoding_t dec, V76LogicalChannelParameters_suspendResume *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(ASN1encoding_t enc, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncBitVal(enc, 5, (val)->u.finite))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(ASN1decoding_t dec, H223AnnexCArqParameters_numberOfRetransmissions *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU16Val(dec, 5, &(val)->u.finite))
        return 0;
    break;
    case 2:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_crcLength(ASN1encoding_t enc, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_crcLength(ASN1decoding_t dec, H223AL3MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_headerFormat(ASN1encoding_t enc, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_headerFormat(ASN1decoding_t dec, H223AL3MParameters_headerFormat *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL2MParameters_headerFEC(ASN1encoding_t enc, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters_headerFEC(ASN1decoding_t dec, H223AL2MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_crcLength(ASN1encoding_t enc, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_crcLength(ASN1decoding_t dec, H223AL1MParameters_crcLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_headerFEC(ASN1encoding_t enc, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_headerFEC(ASN1decoding_t dec, H223AL1MParameters_headerFEC *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_transferMode(ASN1encoding_t enc, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_transferMode(ASN1decoding_t dec, H223AL1MParameters_transferMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static ASN1stringtableentry_t Q2931Address_address_internationalNumber_StringTableEntries[] = {
    { 32, 32, 0 }, { 48, 57, 1 }, 
};

static ASN1stringtable_t Q2931Address_address_internationalNumber_StringTable = {
    2, Q2931Address_address_internationalNumber_StringTableEntries
};

static int ASN1CALL ASN1Enc_Q2931Address_address(ASN1encoding_t enc, Q2931Address_address *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    t = lstrlenA((val)->u.internationalNumber);
    if (!ASN1PEREncBitVal(enc, 4, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address_address(ASN1decoding_t dec, Q2931Address_address *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU32Val(dec, 4, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.internationalNumber) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.internationalNumber, 4, &Q2931Address_address_internationalNumber_StringTable))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->u.nsapAddress, 1, 20, 5))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address_address(Q2931Address_address *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        break;
    case 2:
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ASN1encoding_t enc, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_t120SetupProcedure(ASN1decoding_t dec, NetworkAccessParameters_t120SetupProcedure *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters_distribution(ASN1encoding_t enc, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_distribution(ASN1decoding_t dec, NetworkAccessParameters_distribution *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile_t84Restricted(ASN1encoding_t enc, T84Profile_t84Restricted *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->qcif))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->cif))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Seq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->ccir601Prog))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvSeq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->hdtvProg))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x100))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g3FacsMH200x200))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x100))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->g4FacsMMR200x200))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Seq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig200x200Prog))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Seq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->jbig300x300Prog))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoLow))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedSeq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoMedProg))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighSeq))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->digPhotoHighProg))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile_t84Restricted(ASN1decoding_t dec, T84Profile_t84Restricted *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->qcif))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->cif))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Seq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->ccir601Prog))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvSeq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->hdtvProg))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x100))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g3FacsMH200x200))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x100))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->g4FacsMMR200x200))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Seq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig200x200Prog))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Seq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->jbig300x300Prog))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoLow))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedSeq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoMedProg))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighSeq))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->digPhotoHighProg))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1encoding_t enc, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode0 - 27))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->highRateMode1 - 27))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode0 - 23))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->lowRateMode1 - 23))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode0 - 6))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->sidMode1 - 6))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(ASN1decoding_t dec, G7231AnnexCCapability_g723AnnexCAudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode0))
    return 0;
    (val)->highRateMode0 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->highRateMode1))
    return 0;
    (val)->highRateMode1 += 27;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode0))
    return 0;
    (val)->lowRateMode0 += 23;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->lowRateMode1))
    return 0;
    (val)->lowRateMode1 += 23;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode0))
    return 0;
    (val)->sidMode0 += 6;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->sidMode1))
    return 0;
    (val)->sidMode1 += 6;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_AudioCapability_g7231(ASN1encoding_t enc, AudioCapability_g7231 *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability_g7231(ASN1decoding_t dec, AudioCapability_g7231 *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
    return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_pixelAspectInformation(ASN1encoding_t enc, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncBoolean(enc, (val)->u.anyPixelAspectRatio))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(enc, &(val)->u.pixelAspectCode))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation_extendedPAR(enc, &(val)->u.extendedPAR))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_pixelAspectInformation(ASN1decoding_t dec, CustomPictureFormat_pixelAspectInformation *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecBoolean(dec, &(val)->u.anyPixelAspectRatio))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(dec, &(val)->u.pixelAspectCode))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation_extendedPAR(dec, &(val)->u.extendedPAR))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_pixelAspectInformation(CustomPictureFormat_pixelAspectInformation *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1Free_CustomPictureFormat_pixelAspectInformation_pixelAspectCode(&(val)->u.pixelAspectCode);
        break;
    case 3:
        ASN1Free_CustomPictureFormat_pixelAspectInformation_extendedPAR(&(val)->u.extendedPAR);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CustomPictureFormat_mPI(ASN1encoding_t enc, CustomPictureFormat_mPI *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->standardMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CustomPictureFormat_mPI_customPCF(enc, &(val)->customPCF))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat_mPI(ASN1decoding_t dec, CustomPictureFormat_mPI *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->standardMPI))
        return 0;
    (val)->standardMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CustomPictureFormat_mPI_customPCF(dec, &(val)->customPCF))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat_mPI(CustomPictureFormat_mPI *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1Free_CustomPictureFormat_mPI_customPCF(&(val)->customPCF);
    }
    }
}

static int ASN1CALL ASN1Enc_RefPictureSelection_videoBackChannelSend(ASN1encoding_t enc, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_videoBackChannelSend(ASN1decoding_t dec, RefPictureSelection_videoBackChannelSend *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection_additionalPictureMemory(ASN1encoding_t enc, RefPictureSelection_additionalPictureMemory *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sqcifAdditionalPictureMemory - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->qcifAdditionalPictureMemory - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cifAdditionalPictureMemory - 1))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cif4AdditionalPictureMemory - 1))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->cif16AdditionalPictureMemory - 1))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->bigCpfAdditionalPictureMemory - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection_additionalPictureMemory(ASN1decoding_t dec, RefPictureSelection_additionalPictureMemory *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sqcifAdditionalPictureMemory))
        return 0;
    (val)->sqcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x40) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->qcifAdditionalPictureMemory))
        return 0;
    (val)->qcifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x20) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cifAdditionalPictureMemory))
        return 0;
    (val)->cifAdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x10) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cif4AdditionalPictureMemory))
        return 0;
    (val)->cif4AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x8) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->cif16AdditionalPictureMemory))
        return 0;
    (val)->cif16AdditionalPictureMemory += 1;
    }
    if ((val)->o[0] & 0x4) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->bigCpfAdditionalPictureMemory))
        return 0;
    (val)->bigCpfAdditionalPictureMemory += 1;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, ((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(RTPH263VideoRedundancyFrameMapping_frameSequence *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncBitVal(enc, 4, ((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecU16Val(dec, 4, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(RTPH263VideoRedundancyEncoding_containedThreads *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(enc, &(val)->u.custom))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(dec, &(val)->u.custom))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(RTPH263VideoRedundancyEncoding_frameToThreadMapping *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(&(val)->u.custom);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PEREncUnsignedShort(enc, val->value - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (!ASN1PERDecUnsignedShort(dec, &val->value))
    return 0;
    val->value += 1;
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding(PRedundancyEncodingCapability_secondaryEncoding *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_mcCapability(ASN1encoding_t enc, H2250Capability_mcCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedConferenceMC))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->decentralizedConferenceMC))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_mcCapability(ASN1decoding_t dec, H2250Capability_mcCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedConferenceMC))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->decentralizedConferenceMC))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_mobileOperationTransmitCapability(ASN1encoding_t enc, H223Capability_mobileOperationTransmitCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modeChangeCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexA))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexADoubleFlag))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexB))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h223AnnexBwithHeader))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_mobileOperationTransmitCapability(ASN1decoding_t dec, H223Capability_mobileOperationTransmitCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modeChangeCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexA))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexADoubleFlag))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexB))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h223AnnexBwithHeader))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223Capability_h223MultiplexTableCapability(ASN1encoding_t enc, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability_enhanced(enc, &(val)->u.enhanced))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability_h223MultiplexTableCapability(ASN1decoding_t dec, H223Capability_h223MultiplexTableCapability *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability_enhanced(dec, &(val)->u.enhanced))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_availableBitRates(ASN1encoding_t enc, VCCapability_availableBitRates *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_VCCapability_availableBitRates_type(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_availableBitRates(ASN1decoding_t dec, VCCapability_availableBitRates *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_VCCapability_availableBitRates_type(dec, &(val)->type))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal5(ASN1encoding_t enc, VCCapability_aal5 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardMaximumSDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->backwardMaximumSDUSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal5(ASN1decoding_t dec, VCCapability_aal5 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardMaximumSDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->backwardMaximumSDUSize))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VCCapability_aal1(ASN1encoding_t enc, VCCapability_aal1 *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullClockRecovery))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->srtsClockRecovery))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->adaptiveClockRecovery))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->nullErrorCorrection))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->longInterleaver))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->shortInterleaver))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->errorCorrectionOnly))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->structuredDataTransfer))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partiallyFilledCells))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability_aal1(ASN1decoding_t dec, VCCapability_aal1 *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullClockRecovery))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->srtsClockRecovery))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->adaptiveClockRecovery))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->nullErrorCorrection))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->longInterleaver))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->shortInterleaver))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->errorCorrectionOnly))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->structuredDataTransfer))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partiallyFilledCells))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_Capability_h233EncryptionReceiveCapability(ASN1encoding_t enc, Capability_h233EncryptionReceiveCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233IVResponseTime))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Capability_h233EncryptionReceiveCapability(ASN1decoding_t dec, Capability_h233EncryptionReceiveCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233IVResponseTime))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject_cause(ASN1encoding_t enc, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    if (!ASN1Enc_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(enc, &(val)->u.tableEntryCapacityExceeded))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject_cause(ASN1decoding_t dec, TerminalCapabilitySetReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    if (!ASN1Dec_TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(dec, &(val)->u.tableEntryCapacityExceeded))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject_cause(ASN1encoding_t enc, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject_cause(ASN1decoding_t dec, MasterSlaveDeterminationReject_cause *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck_decision(ASN1encoding_t enc, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck_decision(ASN1decoding_t dec, MasterSlaveDeterminationAck_decision *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier_h221NonStandard(ASN1encoding_t enc, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier_h221NonStandard(ASN1decoding_t dec, NonStandardIdentifier_h221NonStandard *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_NonStandardIdentifier_h221NonStandard(enc, &(val)->u.h221NonStandard))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_NonStandardIdentifier_h221NonStandard(dec, &(val)->u.h221NonStandard))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1objectidentifier_free(&(val)->u.object);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MasterSlaveDetermination(ASN1encoding_t enc, MasterSlaveDetermination *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalType))
    return 0;
    l = ASN1uint32_uoctets((val)->statusDeterminationNumber);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->statusDeterminationNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDetermination(ASN1decoding_t dec, MasterSlaveDetermination *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalType))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->statusDeterminationNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationAck(ASN1encoding_t enc, MasterSlaveDeterminationAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MasterSlaveDeterminationAck_decision(enc, &(val)->decision))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationAck(ASN1decoding_t dec, MasterSlaveDeterminationAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MasterSlaveDeterminationAck_decision(dec, &(val)->decision))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationReject(ASN1encoding_t enc, MasterSlaveDeterminationReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MasterSlaveDeterminationReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationReject(ASN1decoding_t dec, MasterSlaveDeterminationReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MasterSlaveDeterminationReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MasterSlaveDeterminationRelease(ASN1encoding_t enc, MasterSlaveDeterminationRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MasterSlaveDeterminationRelease(ASN1decoding_t dec, MasterSlaveDeterminationRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor(ASN1encoding_t enc, CapabilityDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->capabilityDescriptorNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(enc, &(val)->simultaneousCapabilities))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor(ASN1decoding_t dec, CapabilityDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->capabilityDescriptorNumber))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(dec, &(val)->simultaneousCapabilities))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor(CapabilityDescriptor *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_CapabilityDescriptor_simultaneousCapabilities(&(val)->simultaneousCapabilities);
    }
    }
}

static int ASN1CALL ASN1Enc_AlternativeCapabilitySet(ASN1encoding_t enc, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PEREncUnsignedShort(enc, ((val)->value)[i] - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AlternativeCapabilitySet(ASN1decoding_t dec, AlternativeCapabilitySet *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1PERDecUnsignedShort(dec, &((val)->value)[i]))
        return 0;
    ((val)->value)[i] += 1;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AlternativeCapabilitySet(AlternativeCapabilitySet *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetAck(ASN1encoding_t enc, TerminalCapabilitySetAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetAck(ASN1decoding_t dec, TerminalCapabilitySetAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetReject(ASN1encoding_t enc, TerminalCapabilitySetReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_TerminalCapabilitySetReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetReject(ASN1decoding_t dec, TerminalCapabilitySetReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_TerminalCapabilitySetReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySetRelease(ASN1encoding_t enc, TerminalCapabilitySetRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySetRelease(ASN1decoding_t dec, TerminalCapabilitySetRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222Capability(ASN1encoding_t enc, H222Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->numberOfVCs - 1))
    return 0;
    if (!ASN1Enc_H222Capability_vcCapability(enc, &(val)->vcCapability))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability(ASN1decoding_t dec, H222Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->numberOfVCs))
    return 0;
    (val)->numberOfVCs += 1;
    if (!ASN1Dec_H222Capability_vcCapability(dec, &(val)->vcCapability))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability(H222Capability *val)
{
    if (val) {
    ASN1Free_H222Capability_vcCapability(&(val)->vcCapability);
    }
}

static int ASN1CALL ASN1Enc_VCCapability(ASN1encoding_t enc, VCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_VCCapability_aal1(enc, &(val)->aal1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_VCCapability_aal5(enc, &(val)->aal5))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->transportStream))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->programStream))
    return 0;
    if (!ASN1Enc_VCCapability_availableBitRates(enc, &(val)->availableBitRates))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VCCapability(ASN1decoding_t dec, VCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_VCCapability_aal1(dec, &(val)->aal1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_VCCapability_aal5(dec, &(val)->aal5))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->transportStream))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->programStream))
    return 0;
    if (!ASN1Dec_VCCapability_availableBitRates(dec, &(val)->availableBitRates))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCCapability(ASN1encoding_t enc, H223AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3M))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL1MPDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL2MSDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAL3MSDUSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCCapability(ASN1decoding_t dec, H223AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3M))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL1MPDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL2MSDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAL3MSDUSize))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V75Capability(ASN1encoding_t enc, V75Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeader))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Capability(ASN1decoding_t dec, V75Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeader))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSMode(ASN1encoding_t enc, QOSMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_QOSMode(ASN1decoding_t dec, QOSMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_ATMParameters(ASN1encoding_t enc, ATMParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxNTUSize))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmUBR))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmrtVBR))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmnrtVBR))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmABR))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->atmCBR))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ATMParameters(ASN1decoding_t dec, ATMParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxNTUSize))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmUBR))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmrtVBR))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmnrtVBR))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmABR))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->atmCBR))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaTransportType(ASN1encoding_t enc, MediaTransportType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaTransportType(ASN1decoding_t dec, MediaTransportType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_MediaChannelCapability(ASN1encoding_t enc, MediaChannelCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_MediaTransportType(enc, &(val)->mediaTransport))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaChannelCapability(ASN1decoding_t dec, MediaChannelCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_MediaTransportType(dec, &(val)->mediaTransport))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding(ASN1encoding_t enc, RTPH263VideoRedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->numberOfThreads - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->framesBetweenSyncPoints - 1))
    return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping(enc, &(val)->frameToThreadMapping))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding_containedThreads(enc, &(val)->containedThreads))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding(ASN1decoding_t dec, RTPH263VideoRedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->numberOfThreads))
    return 0;
    (val)->numberOfThreads += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->framesBetweenSyncPoints))
    return 0;
    (val)->framesBetweenSyncPoints += 1;
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping(dec, &(val)->frameToThreadMapping))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding_containedThreads(dec, &(val)->containedThreads))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding(RTPH263VideoRedundancyEncoding *val)
{
    if (val) {
    ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping(&(val)->frameToThreadMapping);
    if ((val)->o[0] & 0x80) {
        ASN1Free_RTPH263VideoRedundancyEncoding_containedThreads(&(val)->containedThreads);
    }
    }
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyFrameMapping(ASN1encoding_t enc, RTPH263VideoRedundancyFrameMapping *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->threadNumber))
    return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping_frameSequence(enc, &(val)->frameSequence))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyFrameMapping(ASN1decoding_t dec, RTPH263VideoRedundancyFrameMapping *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->threadNumber))
    return 0;
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping_frameSequence(dec, &(val)->frameSequence))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyFrameMapping(RTPH263VideoRedundancyFrameMapping *val)
{
    if (val) {
    ASN1Free_RTPH263VideoRedundancyFrameMapping_frameSequence(&(val)->frameSequence);
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability(ASN1encoding_t enc, MultipointCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multicastCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multiUniCastConference))
    return 0;
    if (!ASN1Enc_MultipointCapability_mediaDistributionCapability(enc, &(val)->mediaDistributionCapability))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability(ASN1decoding_t dec, MultipointCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multicastCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multiUniCastConference))
    return 0;
    if (!ASN1Dec_MultipointCapability_mediaDistributionCapability(dec, &(val)->mediaDistributionCapability))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability(MultipointCapability *val)
{
    if (val) {
    ASN1Free_MultipointCapability_mediaDistributionCapability(&(val)->mediaDistributionCapability);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability(ASN1encoding_t enc, MediaDistributionCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedControl))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedControl))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedAudio))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedAudio))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->centralizedVideo))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->distributedVideo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_MediaDistributionCapability_centralizedData(enc, &(val)->centralizedData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_MediaDistributionCapability_distributedData(enc, &(val)->distributedData))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability(ASN1decoding_t dec, MediaDistributionCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedControl))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedControl))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedAudio))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedAudio))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->centralizedVideo))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->distributedVideo))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_MediaDistributionCapability_centralizedData(dec, &(val)->centralizedData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_MediaDistributionCapability_distributedData(dec, &(val)->distributedData))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability(MediaDistributionCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_MediaDistributionCapability_centralizedData(&(val)->centralizedData);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_MediaDistributionCapability_distributedData(&(val)->distributedData);
    }
    }
}

static int ASN1CALL ASN1Enc_H261VideoCapability(ASN1encoding_t enc, H261VideoCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 2, (val)->qcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 2, (val)->cifMPI - 1))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxBitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoCapability(ASN1decoding_t dec, H261VideoCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 2, &(val)->qcifMPI))
        return 0;
    (val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 2, &(val)->cifMPI))
        return 0;
    (val)->cifMPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxBitRate))
    return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoCapability(ASN1encoding_t enc, H262VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SPatML))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatLL))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatML))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatH_14))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_MPatHL))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatLL))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SNRatML))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_SpatialatH_14))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatML))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatH_14))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->profileAndLevel_HPatHL))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->videoBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->vbvBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->luminanceSampleRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoCapability(ASN1decoding_t dec, H262VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SPatML))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatLL))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatML))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatH_14))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_MPatHL))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatLL))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SNRatML))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_SpatialatH_14))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatML))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatH_14))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->profileAndLevel_HPatHL))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo(ASN1encoding_t enc, EnhancementLayerInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->baseBitRateConstrained))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EnhancementLayerInfo_snrEnhancement(enc, &(val)->snrEnhancement))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_EnhancementLayerInfo_spatialEnhancement(enc, &(val)->spatialEnhancement))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(enc, &(val)->bPictureEnhancement))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo(ASN1decoding_t dec, EnhancementLayerInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->baseBitRateConstrained))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EnhancementLayerInfo_snrEnhancement(dec, &(val)->snrEnhancement))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_EnhancementLayerInfo_spatialEnhancement(dec, &(val)->spatialEnhancement))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(dec, &(val)->bPictureEnhancement))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo(EnhancementLayerInfo *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EnhancementLayerInfo_snrEnhancement(&(val)->snrEnhancement);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_EnhancementLayerInfo_spatialEnhancement(&(val)->spatialEnhancement);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_EnhancementLayerInfo_bPictureEnhancement(&(val)->bPictureEnhancement);
    }
    }
}

static int ASN1CALL ASN1Enc_TransparencyParameters(ASN1encoding_t enc, TransparencyParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->presentationOrder - 1))
    return 0;
    l = ASN1uint32_uoctets((val)->offset_x + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_x + 262144))
    return 0;
    l = ASN1uint32_uoctets((val)->offset_y + 262144);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->offset_y + 262144))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_x - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->scale_y - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransparencyParameters(ASN1decoding_t dec, TransparencyParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->presentationOrder))
    return 0;
    (val)->presentationOrder += 1;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_x))
    return 0;
    (val)->offset_x += 0 - 262144;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->offset_y))
    return 0;
    (val)->offset_y += 0 - 262144;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_x))
    return 0;
    (val)->scale_x += 1;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->scale_y))
    return 0;
    (val)->scale_y += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RefPictureSelection(ASN1encoding_t enc, RefPictureSelection *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_RefPictureSelection_additionalPictureMemory(enc, &(val)->additionalPictureMemory))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->videoMux))
    return 0;
    if (!ASN1Enc_RefPictureSelection_videoBackChannelSend(enc, &(val)->videoBackChannelSend))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RefPictureSelection(ASN1decoding_t dec, RefPictureSelection *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_RefPictureSelection_additionalPictureMemory(dec, &(val)->additionalPictureMemory))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->videoMux))
    return 0;
    if (!ASN1Dec_RefPictureSelection_videoBackChannelSend(dec, &(val)->videoBackChannelSend))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureClockFrequency(ASN1encoding_t enc, CustomPictureClockFrequency *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
    return 0;
    if (!ASN1PEREncBitVal(enc, 1, (val)->clockConversionCode - 1000))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->clockDivisor - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->sqcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->qcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->cifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->cif4MPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->cif16MPI - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureClockFrequency(ASN1decoding_t dec, CustomPictureClockFrequency *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if (!ASN1PERDecU16Val(dec, 1, &(val)->clockConversionCode))
    return 0;
    (val)->clockConversionCode += 1000;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->clockDivisor))
    return 0;
    (val)->clockDivisor += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->sqcifMPI))
        return 0;
    (val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->qcifMPI))
        return 0;
    (val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->cifMPI))
        return 0;
    (val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->cif4MPI))
        return 0;
    (val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->cif16MPI))
        return 0;
    (val)->cif16MPI += 1;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CustomPictureFormat(ASN1encoding_t enc, CustomPictureFormat *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureWidth - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maxCustomPictureHeight - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureWidth - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->minCustomPictureHeight - 1))
    return 0;
    if (!ASN1Enc_CustomPictureFormat_mPI(enc, &(val)->mPI))
    return 0;
    if (!ASN1Enc_CustomPictureFormat_pixelAspectInformation(enc, &(val)->pixelAspectInformation))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CustomPictureFormat(ASN1decoding_t dec, CustomPictureFormat *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureWidth))
    return 0;
    (val)->maxCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maxCustomPictureHeight))
    return 0;
    (val)->maxCustomPictureHeight += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureWidth))
    return 0;
    (val)->minCustomPictureWidth += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->minCustomPictureHeight))
    return 0;
    (val)->minCustomPictureHeight += 1;
    if (!ASN1Dec_CustomPictureFormat_mPI(dec, &(val)->mPI))
    return 0;
    if (!ASN1Dec_CustomPictureFormat_pixelAspectInformation(dec, &(val)->pixelAspectInformation))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CustomPictureFormat(CustomPictureFormat *val)
{
    if (val) {
    ASN1Free_CustomPictureFormat_mPI(&(val)->mPI);
    ASN1Free_CustomPictureFormat_pixelAspectInformation(&(val)->pixelAspectInformation);
    }
}

static int ASN1CALL ASN1Enc_H263ModeComboFlags(ASN1encoding_t enc, H263ModeComboFlags *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->referencePicSelect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263ModeComboFlags(ASN1decoding_t dec, H263ModeComboFlags *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->referencePicSelect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoCapability(ASN1encoding_t enc, IS11172VideoCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->videoBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->vbvBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->luminanceSampleRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoCapability(ASN1decoding_t dec, IS11172VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCCapability(ASN1encoding_t enc, G7231AnnexCCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_G7231AnnexCCapability_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCCapability(ASN1decoding_t dec, G7231AnnexCCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
    return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_G7231AnnexCCapability_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioCapability(ASN1encoding_t enc, IS11172AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioCapability(ASN1decoding_t dec, IS11172AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioCapability(ASN1encoding_t enc, IS13818AudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioLayer3))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling16k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling22k05))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling24k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling32k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling44k1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioSampling48k))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->singleChannel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoChannels))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels2_1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->threeChannels3_0))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_0_2_0))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels2_2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fourChannels3_1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_0_2_0))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fiveChannels3_2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioCapability(ASN1decoding_t dec, IS13818AudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioLayer3))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling16k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling22k05))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling24k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling32k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling44k1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioSampling48k))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->singleChannel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->twoChannels))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels2_1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->threeChannels3_0))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_0_2_0))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels2_2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fourChannels3_1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_0_2_0))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fiveChannels3_2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_GSMAudioCapability(ASN1encoding_t enc, GSMAudioCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->audioUnitSize - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->comfortNoise))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->scrambled))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_GSMAudioCapability(ASN1decoding_t dec, GSMAudioCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->audioUnitSize))
    return 0;
    (val)->audioUnitSize += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->comfortNoise))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->scrambled))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V42bis(ASN1encoding_t enc, V42bis *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, (val)->numberOfCodewords - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maximumStringLength - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V42bis(ASN1decoding_t dec, V42bis *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &(val)->numberOfCodewords))
    return 0;
    (val)->numberOfCodewords += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maximumStringLength))
    return 0;
    (val)->maximumStringLength += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_T84Profile(ASN1encoding_t enc, T84Profile *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_T84Profile_t84Restricted(enc, &(val)->u.t84Restricted))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_T84Profile(ASN1decoding_t dec, T84Profile *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_T84Profile_t84Restricted(dec, &(val)->u.t84Restricted))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceCapability(ASN1encoding_t enc, ConferenceCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_ConferenceCapability_nonStandardData(enc, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->chairControlCapability))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->videoIndicateMixingCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability(ASN1decoding_t dec, ConferenceCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_ConferenceCapability_nonStandardData(dec, &(val)->nonStandardData))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->chairControlCapability))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->videoIndicateMixingCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability(ConferenceCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_ConferenceCapability_nonStandardData(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_Q2931Address(ASN1encoding_t enc, Q2931Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_Q2931Address_address(enc, &(val)->address))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Q2931Address(ASN1decoding_t dec, Q2931Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_Q2931Address_address(dec, &(val)->address))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->subaddress, 1, 20, 5))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Q2931Address(Q2931Address *val)
{
    if (val) {
    ASN1Free_Q2931Address_address(&(val)->address);
    if ((val)->o[0] & 0x80) {
    }
    }
}

static int ASN1CALL ASN1Enc_V75Parameters(ASN1encoding_t enc, V75Parameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioHeaderPresent))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V75Parameters(ASN1decoding_t dec, V75Parameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioHeaderPresent))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H222LogicalChannelParameters(ASN1encoding_t enc, H222LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->subChannelID))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->pcr_pid))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->programDescriptors))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->streamDescriptors))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H222LogicalChannelParameters(ASN1decoding_t dec, H222LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->subChannelID))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->pcr_pid))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->programDescriptors))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->streamDescriptors))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H222LogicalChannelParameters(H222LogicalChannelParameters *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1octetstring_free(&(val)->programDescriptors);
    }
    if ((val)->o[0] & 0x20) {
        ASN1octetstring_free(&(val)->streamDescriptors);
    }
    }
}

static int ASN1CALL ASN1Enc_H223AL2MParameters(ASN1encoding_t enc, H223AL2MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223AL2MParameters_headerFEC(enc, &(val)->headerFEC))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL2MParameters(ASN1decoding_t dec, H223AL2MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223AL2MParameters_headerFEC(dec, &(val)->headerFEC))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AnnexCArqParameters(ASN1encoding_t enc, H223AnnexCArqParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223AnnexCArqParameters_numberOfRetransmissions(enc, &(val)->numberOfRetransmissions))
    return 0;
    l = ASN1uint32_uoctets((val)->sendBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sendBufferSize))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AnnexCArqParameters(ASN1decoding_t dec, H223AnnexCArqParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223AnnexCArqParameters_numberOfRetransmissions(dec, &(val)->numberOfRetransmissions))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sendBufferSize))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CRCLength(ASN1encoding_t enc, CRCLength *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRCLength(ASN1decoding_t dec, CRCLength *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_EscrowData(ASN1encoding_t enc, EscrowData *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->escrowID))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 16, ((val)->escrowValue).length - 1))
    return 0;
    if (!ASN1PEREncBits(enc, ((val)->escrowValue).length, ((val)->escrowValue).value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EscrowData(ASN1decoding_t dec, EscrowData *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->escrowID))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 16, &((val)->escrowValue).length))
    return 0;
    ((val)->escrowValue).length += 1;
    if (!ASN1PERDecBits(dec, ((val)->escrowValue).length, &((val)->escrowValue).value))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EscrowData(EscrowData *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->escrowID);
    ASN1bitstring_free(&(val)->escrowValue);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelReject(ASN1encoding_t enc, OpenLogicalChannelReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_OpenLogicalChannelReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelReject(ASN1decoding_t dec, OpenLogicalChannelReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannelReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelConfirm(ASN1encoding_t enc, OpenLogicalChannelConfirm *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelConfirm(ASN1decoding_t dec, OpenLogicalChannelConfirm *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannel(ASN1encoding_t enc, CloseLogicalChannel *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_CloseLogicalChannel_source(enc, &(val)->source))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1Enc_CloseLogicalChannel_reason(ee, &(val)->reason))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannel(ASN1decoding_t dec, CloseLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_CloseLogicalChannel_source(dec, &(val)->source))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_CloseLogicalChannel_reason(dd, &(val)->reason))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CloseLogicalChannelAck(ASN1encoding_t enc, CloseLogicalChannelAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CloseLogicalChannelAck(ASN1decoding_t dec, CloseLogicalChannelAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseAck(ASN1encoding_t enc, RequestChannelCloseAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseAck(ASN1decoding_t dec, RequestChannelCloseAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseReject(ASN1encoding_t enc, RequestChannelCloseReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_RequestChannelCloseReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseReject(ASN1decoding_t dec, RequestChannelCloseReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_RequestChannelCloseReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestChannelCloseRelease(ASN1encoding_t enc, RequestChannelCloseRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelCloseRelease(ASN1decoding_t dec, RequestChannelCloseRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend(ASN1encoding_t enc, MultiplexEntrySend *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(enc, &(val)->multiplexEntryDescriptors))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend(ASN1decoding_t dec, MultiplexEntrySend *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(dec, &(val)->multiplexEntryDescriptors))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend(MultiplexEntrySend *val)
{
    if (val) {
    ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(&(val)->multiplexEntryDescriptors);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement(ASN1encoding_t enc, MultiplexElement *val)
{
    if (!ASN1Enc_MultiplexElement_type(enc, &(val)->type))
    return 0;
    if (!ASN1Enc_MultiplexElement_repeatCount(enc, &(val)->repeatCount))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement(ASN1decoding_t dec, MultiplexElement *val)
{
    if (!ASN1Dec_MultiplexElement_type(dec, &(val)->type))
    return 0;
    if (!ASN1Dec_MultiplexElement_repeatCount(dec, &(val)->repeatCount))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement(MultiplexElement *val)
{
    if (val) {
    ASN1Free_MultiplexElement_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendAck(ASN1encoding_t enc, MultiplexEntrySendAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_MultiplexEntrySendAck_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendAck(ASN1decoding_t dec, MultiplexEntrySendAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_MultiplexEntrySendAck_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendAck(MultiplexEntrySendAck *val)
{
    if (val) {
    ASN1Free_MultiplexEntrySendAck_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryRejectionDescriptions(ASN1encoding_t enc, MultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
    return 0;
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryRejectionDescriptions(ASN1decoding_t dec, MultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
    return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendRelease(ASN1encoding_t enc, MultiplexEntrySendRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MultiplexEntrySendRelease_multiplexTableEntryNumber(enc, &(val)->multiplexTableEntryNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendRelease(ASN1decoding_t dec, MultiplexEntrySendRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MultiplexEntrySendRelease_multiplexTableEntryNumber(dec, &(val)->multiplexTableEntryNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendRelease(MultiplexEntrySendRelease *val)
{
    if (val) {
    ASN1Free_MultiplexEntrySendRelease_multiplexTableEntryNumber(&(val)->multiplexTableEntryNumber);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntry(ASN1encoding_t enc, RequestMultiplexEntry *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntry_entryNumbers(enc, &(val)->entryNumbers))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntry(ASN1decoding_t dec, RequestMultiplexEntry *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_RequestMultiplexEntry_entryNumbers(dec, &(val)->entryNumbers))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntry(RequestMultiplexEntry *val)
{
    if (val) {
    ASN1Free_RequestMultiplexEntry_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryAck(ASN1encoding_t enc, RequestMultiplexEntryAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntryAck_entryNumbers(enc, &(val)->entryNumbers))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryAck(ASN1decoding_t dec, RequestMultiplexEntryAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_RequestMultiplexEntryAck_entryNumbers(dec, &(val)->entryNumbers))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryAck(RequestMultiplexEntryAck *val)
{
    if (val) {
    ASN1Free_RequestMultiplexEntryAck_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryRejectionDescriptions *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryRejectionDescriptions *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
    return 0;
    (val)->multiplexTableEntryNumber += 1;
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryRelease(ASN1encoding_t enc, RequestMultiplexEntryRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntryRelease_entryNumbers(enc, &(val)->entryNumbers))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryRelease(ASN1decoding_t dec, RequestMultiplexEntryRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_RequestMultiplexEntryRelease_entryNumbers(dec, &(val)->entryNumbers))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryRelease(RequestMultiplexEntryRelease *val)
{
    if (val) {
    ASN1Free_RequestMultiplexEntryRelease_entryNumbers(&(val)->entryNumbers);
    }
}

static int ASN1CALL ASN1Enc_RequestMode(ASN1encoding_t enc, RequestMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_RequestMode_requestedModes(enc, &(val)->requestedModes))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode(ASN1decoding_t dec, RequestMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_RequestMode_requestedModes(dec, &(val)->requestedModes))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode(RequestMode *val)
{
    if (val) {
    ASN1Free_RequestMode_requestedModes(&(val)->requestedModes);
    }
}

static int ASN1CALL ASN1Enc_RequestModeAck(ASN1encoding_t enc, RequestModeAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_RequestModeAck_response(enc, &(val)->response))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeAck(ASN1decoding_t dec, RequestModeAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_RequestModeAck_response(dec, &(val)->response))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeReject(ASN1encoding_t enc, RequestModeReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_RequestModeReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeReject(ASN1decoding_t dec, RequestModeReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_RequestModeReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestModeRelease(ASN1encoding_t enc, RequestModeRelease *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestModeRelease(ASN1decoding_t dec, RequestModeRelease *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76ModeParameters(ASN1encoding_t enc, V76ModeParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76ModeParameters(ASN1decoding_t dec, V76ModeParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_H261VideoMode(ASN1encoding_t enc, H261VideoMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H261VideoMode_resolution(enc, &(val)->resolution))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->stillImageTransmission))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H261VideoMode(ASN1decoding_t dec, H261VideoMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H261VideoMode_resolution(dec, &(val)->resolution))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->stillImageTransmission))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H262VideoMode(ASN1encoding_t enc, H262VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if (!ASN1Enc_H262VideoMode_profileAndLevel(enc, &(val)->profileAndLevel))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->videoBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->vbvBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 4, (val)->framesPerSecond))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->luminanceSampleRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H262VideoMode(ASN1decoding_t dec, H262VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if (!ASN1Dec_H262VideoMode_profileAndLevel(dec, &(val)->profileAndLevel))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 4, &(val)->framesPerSecond))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172VideoMode(ASN1encoding_t enc, IS11172VideoMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->constrainedBitstream))
    return 0;
    if ((val)->o[0] & 0x80) {
    l = ASN1uint32_uoctets((val)->videoBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->vbvBufferSize);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 4, (val)->pictureRate))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->luminanceSampleRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->luminanceSampleRate))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172VideoMode(ASN1decoding_t dec, IS11172VideoMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->constrainedBitstream))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->videoBitRate))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->vbvBufferSize))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->samplesPerLine))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->linesPerFrame))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 4, &(val)->pictureRate))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->luminanceSampleRate))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS11172AudioMode(ASN1encoding_t enc, IS11172AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_IS11172AudioMode_audioLayer(enc, &(val)->audioLayer))
    return 0;
    if (!ASN1Enc_IS11172AudioMode_audioSampling(enc, &(val)->audioSampling))
    return 0;
    if (!ASN1Enc_IS11172AudioMode_multichannelType(enc, &(val)->multichannelType))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS11172AudioMode(ASN1decoding_t dec, IS11172AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_IS11172AudioMode_audioLayer(dec, &(val)->audioLayer))
    return 0;
    if (!ASN1Dec_IS11172AudioMode_audioSampling(dec, &(val)->audioSampling))
    return 0;
    if (!ASN1Dec_IS11172AudioMode_multichannelType(dec, &(val)->multichannelType))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_IS13818AudioMode(ASN1encoding_t enc, IS13818AudioMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_IS13818AudioMode_audioLayer(enc, &(val)->audioLayer))
    return 0;
    if (!ASN1Enc_IS13818AudioMode_audioSampling(enc, &(val)->audioSampling))
    return 0;
    if (!ASN1Enc_IS13818AudioMode_multichannelType(enc, &(val)->multichannelType))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->lowFrequencyEnhancement))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->multilingual))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IS13818AudioMode(ASN1decoding_t dec, IS13818AudioMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_IS13818AudioMode_audioLayer(dec, &(val)->audioLayer))
    return 0;
    if (!ASN1Dec_IS13818AudioMode_audioSampling(dec, &(val)->audioSampling))
    return 0;
    if (!ASN1Dec_IS13818AudioMode_multichannelType(dec, &(val)->multichannelType))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->lowFrequencyEnhancement))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->multilingual))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_G7231AnnexCMode(ASN1encoding_t enc, G7231AnnexCMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->maxAl_sduAudioFrames - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
    return 0;
    if (!ASN1Enc_G7231AnnexCMode_g723AnnexCAudioMode(enc, &(val)->g723AnnexCAudioMode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_G7231AnnexCMode(ASN1decoding_t dec, G7231AnnexCMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->maxAl_sduAudioFrames))
    return 0;
    (val)->maxAl_sduAudioFrames += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
    return 0;
    if (!ASN1Dec_G7231AnnexCMode_g723AnnexCAudioMode(dec, &(val)->g723AnnexCAudioMode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayRequest(ASN1encoding_t enc, RoundTripDelayRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayRequest(ASN1decoding_t dec, RoundTripDelayRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RoundTripDelayResponse(ASN1encoding_t enc, RoundTripDelayResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RoundTripDelayResponse(ASN1decoding_t dec, RoundTripDelayResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopRequest(ASN1encoding_t enc, MaintenanceLoopRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MaintenanceLoopRequest_type(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopRequest(ASN1decoding_t dec, MaintenanceLoopRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MaintenanceLoopRequest_type(dec, &(val)->type))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopAck(ASN1encoding_t enc, MaintenanceLoopAck *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MaintenanceLoopAck_type(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopAck(ASN1decoding_t dec, MaintenanceLoopAck *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MaintenanceLoopAck_type(dec, &(val)->type))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopReject(ASN1encoding_t enc, MaintenanceLoopReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_MaintenanceLoopReject_type(enc, &(val)->type))
    return 0;
    if (!ASN1Enc_MaintenanceLoopReject_cause(enc, &(val)->cause))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopReject(ASN1decoding_t dec, MaintenanceLoopReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_MaintenanceLoopReject_type(dec, &(val)->type))
    return 0;
    if (!ASN1Dec_MaintenanceLoopReject_cause(dec, &(val)->cause))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MaintenanceLoopOffCommand(ASN1encoding_t enc, MaintenanceLoopOffCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MaintenanceLoopOffCommand(ASN1decoding_t dec, MaintenanceLoopOffCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand(ASN1encoding_t enc, CommunicationModeCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_CommunicationModeCommand_communicationModeTable(enc, &(val)->communicationModeTable))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand(ASN1decoding_t dec, CommunicationModeCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_CommunicationModeCommand_communicationModeTable(dec, &(val)->communicationModeTable))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand(CommunicationModeCommand *val)
{
    if (val) {
    ASN1Free_CommunicationModeCommand_communicationModeTable(&(val)->communicationModeTable);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeRequest(ASN1encoding_t enc, CommunicationModeRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeRequest(ASN1decoding_t dec, CommunicationModeRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse(ASN1encoding_t enc, CommunicationModeResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_CommunicationModeResponse_communicationModeTable(enc, &(val)->u.communicationModeTable))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse(ASN1decoding_t dec, CommunicationModeResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_CommunicationModeResponse_communicationModeTable(dec, &(val)->u.communicationModeTable))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse(CommunicationModeResponse *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_CommunicationModeResponse_communicationModeTable(&(val)->u.communicationModeTable);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_Criteria(ASN1encoding_t enc, Criteria *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->field))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Criteria(ASN1decoding_t dec, Criteria *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->field))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->value, 1, 65535, 16))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Criteria(Criteria *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->field);
    }
}

static int ASN1CALL ASN1Enc_TerminalLabel(ASN1encoding_t enc, TerminalLabel *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->mcuNumber))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalLabel(ASN1decoding_t dec, TerminalLabel *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->mcuNumber))
    return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse(ASN1encoding_t enc, RequestAllTerminalIDsResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(enc, &(val)->terminalInformation))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse(ASN1decoding_t dec, RequestAllTerminalIDsResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(dec, &(val)->terminalInformation))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse(RequestAllTerminalIDsResponse *val)
{
    if (val) {
    ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(&(val)->terminalInformation);
    }
}

static int ASN1CALL ASN1Enc_TerminalInformation(ASN1encoding_t enc, TerminalInformation *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalInformation(ASN1decoding_t dec, TerminalInformation *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalInformation(TerminalInformation *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_RemoteMCRequest(ASN1encoding_t enc, RemoteMCRequest *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCRequest(ASN1decoding_t dec, RemoteMCRequest *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_RemoteMCResponse(ASN1encoding_t enc, RemoteMCResponse *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_RemoteMCResponse_reject(enc, &(val)->u.reject))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RemoteMCResponse(ASN1decoding_t dec, RemoteMCResponse *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_RemoteMCResponse_reject(dec, &(val)->u.reject))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SendTerminalCapabilitySet(ASN1encoding_t enc, SendTerminalCapabilitySet *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_SendTerminalCapabilitySet_specificRequest(enc, &(val)->u.specificRequest))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_SendTerminalCapabilitySet(ASN1decoding_t dec, SendTerminalCapabilitySet *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_SendTerminalCapabilitySet_specificRequest(dec, &(val)->u.specificRequest))
        return 0;
    break;
    case 2:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SendTerminalCapabilitySet(SendTerminalCapabilitySet *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_SendTerminalCapabilitySet_specificRequest(&(val)->u.specificRequest);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_FlowControlCommand(ASN1encoding_t enc, FlowControlCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_FlowControlCommand_scope(enc, &(val)->scope))
    return 0;
    if (!ASN1Enc_FlowControlCommand_restriction(enc, &(val)->restriction))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FlowControlCommand(ASN1decoding_t dec, FlowControlCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_FlowControlCommand_scope(dec, &(val)->scope))
    return 0;
    if (!ASN1Dec_FlowControlCommand_restriction(dec, &(val)->restriction))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_SubstituteConferenceIDCommand(ASN1encoding_t enc, SubstituteConferenceIDCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SubstituteConferenceIDCommand(ASN1decoding_t dec, SubstituteConferenceIDCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->conferenceIdentifier, 16))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_SubstituteConferenceIDCommand(SubstituteConferenceIDCommand *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_KeyProtectionMethod(ASN1encoding_t enc, KeyProtectionMethod *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->secureChannel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sharedSecret))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->certProtectedKey))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyProtectionMethod(ASN1decoding_t dec, KeyProtectionMethod *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->secureChannel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sharedSecret))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->certProtectedKey))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_EncryptionUpdateRequest(ASN1encoding_t enc, EncryptionUpdateRequest *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_KeyProtectionMethod(enc, &(val)->keyProtectionMethod))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionUpdateRequest(ASN1decoding_t dec, EncryptionUpdateRequest *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_KeyProtectionMethod(dec, &(val)->keyProtectionMethod))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223MultiplexReconfiguration(ASN1encoding_t enc, H223MultiplexReconfiguration *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H223MultiplexReconfiguration_h223ModeChange(enc, &(val)->u.h223ModeChange))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H223MultiplexReconfiguration_h223AnnexADoubleFlag(enc, &(val)->u.h223AnnexADoubleFlag))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223MultiplexReconfiguration(ASN1decoding_t dec, H223MultiplexReconfiguration *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H223MultiplexReconfiguration_h223ModeChange(dec, &(val)->u.h223ModeChange))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H223MultiplexReconfiguration_h223AnnexADoubleFlag(dec, &(val)->u.h223AnnexADoubleFlag))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_FunctionNotSupported(ASN1encoding_t enc, FunctionNotSupported *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_FunctionNotSupported_cause(enc, &(val)->cause))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->returnedFunction))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotSupported(ASN1decoding_t dec, FunctionNotSupported *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_FunctionNotSupported_cause(dec, &(val)->cause))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->returnedFunction))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotSupported(FunctionNotSupported *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1octetstring_free(&(val)->returnedFunction);
    }
    }
}

static int ASN1CALL ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ASN1encoding_t enc, TerminalYouAreSeeingInSubPictureNumber *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBitVal(enc, 8, (val)->terminalNumber))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->subPictureNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(ASN1decoding_t dec, TerminalYouAreSeeingInSubPictureNumber *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecU16Val(dec, 8, &(val)->terminalNumber))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->subPictureNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VideoIndicateCompose(ASN1encoding_t enc, VideoIndicateCompose *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->compositionNumber))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_VideoIndicateCompose(ASN1decoding_t dec, VideoIndicateCompose *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->compositionNumber))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_ConferenceIndication(ASN1encoding_t enc, ConferenceIndication *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncBitVal(enc, 4, (val)->u.sbeNumber))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalNumberAssign))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalJoinedConference))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalLeftConference))
        return 0;
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.terminalYouAreSeeing))
        return 0;
    break;
    case 10:
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TerminalLabel(ee, &(val)->u.floorRequested))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TerminalYouAreSeeingInSubPictureNumber(ee, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 14:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_VideoIndicateCompose(ee, &(val)->u.videoIndicateCompose))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceIndication(ASN1decoding_t dec, ConferenceIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecU16Val(dec, 4, &(val)->u.sbeNumber))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalNumberAssign))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalJoinedConference))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalLeftConference))
        return 0;
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.terminalYouAreSeeing))
        return 0;
    break;
    case 10:
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TerminalLabel(dd, &(val)->u.floorRequested))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TerminalYouAreSeeingInSubPictureNumber(dd, &(val)->u.terminalYouAreSeeingInSubPictureNumber))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 14:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_VideoIndicateCompose(dd, &(val)->u.videoIndicateCompose))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_JitterIndication(ASN1encoding_t enc, JitterIndication *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_JitterIndication_scope(enc, &(val)->scope))
    return 0;
    if (!ASN1PEREncBitVal(enc, 2, (val)->estimatedReceivedJitterMantissa))
    return 0;
    if (!ASN1PEREncBitVal(enc, 3, (val)->estimatedReceivedJitterExponent))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 4, (val)->skippedFrameCount))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->additionalDecoderBuffer);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->additionalDecoderBuffer))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_JitterIndication(ASN1decoding_t dec, JitterIndication *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_JitterIndication_scope(dec, &(val)->scope))
    return 0;
    if (!ASN1PERDecU16Val(dec, 2, &(val)->estimatedReceivedJitterMantissa))
    return 0;
    if (!ASN1PERDecU16Val(dec, 3, &(val)->estimatedReceivedJitterExponent))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 4, &(val)->skippedFrameCount))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->additionalDecoderBuffer))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223SkewIndication(ASN1encoding_t enc, H223SkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->skew))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223SkewIndication(ASN1decoding_t dec, H223SkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
    return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
    return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->skew))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H2250MaximumSkewIndication(ASN1encoding_t enc, H2250MaximumSkewIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber1 - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber2 - 1))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumSkew))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250MaximumSkewIndication(ASN1decoding_t dec, H2250MaximumSkewIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber1))
    return 0;
    (val)->logicalChannelNumber1 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber2))
    return 0;
    (val)->logicalChannelNumber2 += 1;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumSkew))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_VendorIdentification(ASN1encoding_t enc, VendorIdentification *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->vendor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VendorIdentification(ASN1decoding_t dec, VendorIdentification *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->vendor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->productNumber, 1, 256, 8))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->versionNumber, 1, 256, 8))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VendorIdentification(VendorIdentification *val)
{
    if (val) {
    ASN1Free_NonStandardIdentifier(&(val)->vendor);
    if ((val)->o[0] & 0x80) {
    }
    if ((val)->o[0] & 0x40) {
    }
    }
}

static int ASN1CALL ASN1Enc_NewATMVCIndication(ASN1encoding_t enc, NewATMVCIndication *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->resourceID))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToPCRClock))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->bitRateLockedToNetworkClock))
    return 0;
    if (!ASN1Enc_NewATMVCIndication_aal(enc, &(val)->aal))
    return 0;
    if (!ASN1Enc_NewATMVCIndication_multiplex(enc, &(val)->multiplex))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1Enc_NewATMVCIndication_reverseParameters(ee, &(val)->reverseParameters))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NewATMVCIndication(ASN1decoding_t dec, NewATMVCIndication *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->resourceID))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToPCRClock))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->bitRateLockedToNetworkClock))
    return 0;
    if (!ASN1Dec_NewATMVCIndication_aal(dec, &(val)->aal))
    return 0;
    if (!ASN1Dec_NewATMVCIndication_multiplex(dec, &(val)->multiplex))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_NewATMVCIndication_reverseParameters(dd, &(val)->reverseParameters))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Enc_RTPH263VideoRedundancyFrameMapping(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (!ASN1Dec_RTPH263VideoRedundancyFrameMapping(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val)
{
    if (val) {
    ASN1Free_RTPH263VideoRedundancyFrameMapping(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MultiplexElement_type_subElementList(ASN1encoding_t enc, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 8, (*val)->count - 2))
    return 0;
    for (i = 0; i < (*val)->count; i++) {
    if (!ASN1Enc_MultiplexElement(enc, &((*val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexElement_type_subElementList(ASN1decoding_t dec, PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 8, &(*val)->count))
    return 0;
    (*val)->count += 2;
    for (i = 0; i < (*val)->count; i++) {
    if (!ASN1Dec_MultiplexElement(dec, &((*val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexElement_type_subElementList(PMultiplexElement_type_subElementList *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (*val)->count; i++) {
        ASN1Free_MultiplexElement(&(*val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
}

static int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Enc_TerminalInformation(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (!ASN1Dec_TerminalInformation(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation(PRequestAllTerminalIDsResponse_terminalInformation *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val)
{
    if (val) {
    ASN1Free_TerminalInformation(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalCertificateResponse(ASN1encoding_t enc, ConferenceResponse_terminalCertificateResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalCertificateResponse(ASN1decoding_t dec, ConferenceResponse_terminalCertificateResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->certificateResponse, 1, 65535, 16))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalCertificateResponse(ConferenceResponse_terminalCertificateResponse *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
    }
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ASN1encoding_t enc, ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(ASN1decoding_t dec, ConferenceResponse_chairTokenOwnerResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_chairTokenOwnerResponse(ConferenceResponse_chairTokenOwnerResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalListResponse(ASN1encoding_t enc, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_TerminalLabel(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalListResponse(ASN1decoding_t dec, ConferenceResponse_terminalListResponse *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_TerminalLabel(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalListResponse(ConferenceResponse_terminalListResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_passwordResponse(ASN1encoding_t enc, ConferenceResponse_passwordResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_passwordResponse(ASN1decoding_t dec, ConferenceResponse_passwordResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->password, 1, 32, 5))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_passwordResponse(ConferenceResponse_passwordResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_conferenceIDResponse(ASN1encoding_t enc, ConferenceResponse_conferenceIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_conferenceIDResponse(ASN1decoding_t dec, ConferenceResponse_conferenceIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->conferenceID, 1, 32, 5))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_conferenceIDResponse(ConferenceResponse_conferenceIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_terminalIDResponse(ASN1encoding_t enc, ConferenceResponse_terminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_terminalIDResponse(ASN1decoding_t dec, ConferenceResponse_terminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_terminalIDResponse(ConferenceResponse_terminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse_mCTerminalIDResponse(ASN1encoding_t enc, ConferenceResponse_mCTerminalIDResponse *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse_mCTerminalIDResponse(ASN1decoding_t dec, ConferenceResponse_mCTerminalIDResponse *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->terminalID, 1, 128, 7))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse_mCTerminalIDResponse(ConferenceResponse_mCTerminalIDResponse *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest_requestTerminalCertificate(ASN1encoding_t enc, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_CertSelectionCriteria(enc, &(val)->certSelectionCriteria))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    l = ASN1uint32_uoctets((val)->sRandom - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->sRandom - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest_requestTerminalCertificate(ASN1decoding_t dec, ConferenceRequest_requestTerminalCertificate *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_CertSelectionCriteria(dec, &(val)->certSelectionCriteria))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->sRandom))
        return 0;
    (val)->sRandom += 1;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest_requestTerminalCertificate(ConferenceRequest_requestTerminalCertificate *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1Free_CertSelectionCriteria(&(val)->certSelectionCriteria);
    }
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(ASN1encoding_t enc, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_RequestMultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(ASN1decoding_t dec, RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_RequestMultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(RequestMultiplexEntryReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(ASN1encoding_t enc, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_MultiplexEntryRejectionDescriptions(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(ASN1decoding_t dec, MultiplexEntrySendReject_rejectionDescriptions *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_MultiplexEntryRejectionDescriptions(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(MultiplexEntrySendReject_rejectionDescriptions *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor_elementList(ASN1encoding_t enc, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_MultiplexElement(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor_elementList(ASN1decoding_t dec, MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_MultiplexElement(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor_elementList(MultiplexEntryDescriptor_elementList *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_MultiplexElement(&(val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry(ASN1encoding_t enc, PEncryptionSync_escrowentry *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionSync_escrowentry_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val)
{
    if (!ASN1Enc_EscrowData(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry(ASN1decoding_t dec, PEncryptionSync_escrowentry *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionSync_escrowentry_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val)
{
    if (!ASN1Dec_EscrowData(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry(PEncryptionSync_escrowentry *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionSync_escrowentry_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val)
{
    if (val) {
    ASN1Free_EscrowData(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223AL3MParameters_arqType(ASN1encoding_t enc, H223AL3MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters_arqType(ASN1decoding_t dec, H223AL3MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL1MParameters_arqType(ASN1encoding_t enc, H223AL1MParameters_arqType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIArq))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H223AnnexCArqParameters(enc, &(val)->u.typeIIArq))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters_arqType(ASN1decoding_t dec, H223AL1MParameters_arqType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIArq))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H223AnnexCArqParameters(dec, &(val)->u.typeIIArq))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(ASN1encoding_t enc, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_H263ModeComboFlags(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(ASN1decoding_t dec, H263VideoModeCombos_h263VideoCoupledModes *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_H263ModeComboFlags(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(H263VideoModeCombos_h263VideoCoupledModes *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat(ASN1encoding_t enc, PH263Options_customPictureFormat *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureFormat_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val)
{
    if (!ASN1Enc_CustomPictureFormat(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat(ASN1decoding_t dec, PH263Options_customPictureFormat *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureFormat_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val)
{
    if (!ASN1Dec_CustomPictureFormat(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat(PH263Options_customPictureFormat *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureFormat_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val)
{
    if (val) {
    ASN1Free_CustomPictureFormat(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency(ASN1encoding_t enc, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_customPictureClockFrequency_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Enc_CustomPictureClockFrequency(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency(ASN1decoding_t dec, PH263Options_customPictureClockFrequency *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_customPictureClockFrequency_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val)
{
    if (!ASN1Dec_CustomPictureClockFrequency(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency(PH263Options_customPictureClockFrequency *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_customPictureClockFrequency_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Enc_MediaDistributionCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val)
{
    if (!ASN1Dec_MediaDistributionCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability(PMultipointCapability_mediaDistributionCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val)
{
    if (val) {
    ASN1Free_MediaDistributionCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_mediaChannelCapabilities(ASN1encoding_t enc, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_MediaChannelCapability(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_mediaChannelCapabilities(ASN1decoding_t dec, TransportCapability_mediaChannelCapabilities *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_MediaChannelCapability(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_mediaChannelCapabilities(TransportCapability_mediaChannelCapabilities *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability(ASN1encoding_t enc, PH222Capability_vcCapability *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H222Capability_vcCapability_ElmFn);
}

static int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val)
{
    if (!ASN1Enc_VCCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability(ASN1decoding_t dec, PH222Capability_vcCapability *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H222Capability_vcCapability_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val)
{
    if (!ASN1Dec_VCCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability(PH222Capability_vcCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H222Capability_vcCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Enc_AlternativeCapabilitySet(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (!ASN1Dec_AlternativeCapabilitySet(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities(PCapabilityDescriptor_simultaneousCapabilities *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val)
{
    if (val) {
    ASN1Free_AlternativeCapabilitySet(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(ASN1encoding_t enc, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_CapabilityDescriptor(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(ASN1decoding_t dec, TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_CapabilityDescriptor(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityDescriptors(TerminalCapabilitySet_capabilityDescriptors *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_CapabilityDescriptor(&(val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_NonStandardParameter(ASN1encoding_t enc, NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardParameter(ASN1decoding_t dec, NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardParameter(NonStandardParameter *val)
{
    if (val) {
    ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
    ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_H223Capability(ASN1encoding_t enc, H223Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->transportWithI_frames))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoWithAL3))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->audioWithAL3))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dataWithAL3))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl2SDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAl3SDUSize))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumDelayJitter))
    return 0;
    if (!ASN1Enc_H223Capability_h223MultiplexTableCapability(enc, &(val)->h223MultiplexTableCapability))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->maxMUXPDUSizeCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x40) {
        if (!ASN1PEREncBoolean(ee, (val)->nsrpSupport))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x20) {
        if (!ASN1Enc_H223Capability_mobileOperationTransmitCapability(ee, &(val)->mobileOperationTransmitCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x10) {
        if (!ASN1Enc_H223AnnexCCapability(ee, &(val)->h223AnnexCCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223Capability(ASN1decoding_t dec, H223Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->transportWithI_frames))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoWithAL3))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->audioWithAL3))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL1))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL2))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dataWithAL3))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl2SDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAl3SDUSize))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumDelayJitter))
    return 0;
    if (!ASN1Dec_H223Capability_h223MultiplexTableCapability(dec, &(val)->h223MultiplexTableCapability))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->maxMUXPDUSizeCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->nsrpSupport))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H223Capability_mobileOperationTransmitCapability(dd, &(val)->mobileOperationTransmitCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H223AnnexCCapability(dd, &(val)->h223AnnexCCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76Capability(ASN1encoding_t enc, V76Capability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywAddress))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->suspendResumeCapabilitywoAddress))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rejCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->sREJCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->mREJCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc8bitCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc16bitCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->crc32bitCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uihCapability))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->numOfDLCS - 2))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->twoOctetAddressFieldCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopBackTestCapability))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401Capability - 1))
    return 0;
    if (!ASN1PEREncBitVal(enc, 7, (val)->maxWindowSizeCapability - 1))
    return 0;
    if (!ASN1Enc_V75Capability(enc, &(val)->v75Capability))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76Capability(ASN1decoding_t dec, V76Capability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywAddress))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->suspendResumeCapabilitywoAddress))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rejCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->sREJCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->mREJCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc8bitCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc16bitCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->crc32bitCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uihCapability))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->numOfDLCS))
    return 0;
    (val)->numOfDLCS += 2;
    if (!ASN1PERDecBoolean(dec, &(val)->twoOctetAddressFieldCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->loopBackTestCapability))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401Capability))
    return 0;
    (val)->n401Capability += 1;
    if (!ASN1PERDecU16Val(dec, 7, &(val)->maxWindowSizeCapability))
    return 0;
    (val)->maxWindowSizeCapability += 1;
    if (!ASN1Dec_V75Capability(dec, &(val)->v75Capability))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RSVPParameters(ASN1encoding_t enc, RSVPParameters *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_QOSMode(enc, &(val)->qosMode))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    l = ASN1uint32_uoctets((val)->tokenRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->tokenRate - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    l = ASN1uint32_uoctets((val)->bucketSize - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bucketSize - 1))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    l = ASN1uint32_uoctets((val)->peakRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->peakRate - 1))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    l = ASN1uint32_uoctets((val)->minPoliced - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->minPoliced - 1))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->maxPktSize - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxPktSize - 1))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RSVPParameters(ASN1decoding_t dec, RSVPParameters *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_QOSMode(dec, &(val)->qosMode))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->tokenRate))
        return 0;
    (val)->tokenRate += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bucketSize))
        return 0;
    (val)->bucketSize += 1;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->peakRate))
        return 0;
    (val)->peakRate += 1;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->minPoliced))
        return 0;
    (val)->minPoliced += 1;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxPktSize))
        return 0;
    (val)->maxPktSize += 1;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_QOSCapability(ASN1encoding_t enc, QOSCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_RSVPParameters(enc, &(val)->rsvpParameters))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_ATMParameters(enc, &(val)->atmParameters))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_QOSCapability(ASN1decoding_t dec, QOSCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_RSVPParameters(dec, &(val)->rsvpParameters))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_ATMParameters(dec, &(val)->atmParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_QOSCapability(QOSCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
    }
}

static int ASN1CALL ASN1Enc_TransportCapability(ASN1encoding_t enc, TransportCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_TransportCapability_qOSCapabilities(enc, &(val)->qOSCapabilities))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_TransportCapability_mediaChannelCapabilities(enc, &(val)->mediaChannelCapabilities))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability(ASN1decoding_t dec, TransportCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_TransportCapability_qOSCapabilities(dec, &(val)->qOSCapabilities))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_TransportCapability_mediaChannelCapabilities(dec, &(val)->mediaChannelCapabilities))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability(TransportCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NonStandardParameter(&(val)->nonStandard);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_TransportCapability_qOSCapabilities(&(val)->qOSCapabilities);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_TransportCapability_mediaChannelCapabilities(&(val)->mediaChannelCapabilities);
    }
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMethod(ASN1encoding_t enc, RedundancyEncodingMethod *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RTPH263VideoRedundancyEncoding(ee, &(val)->u.rtpH263VideoRedundancyEncoding))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMethod(ASN1decoding_t dec, RedundancyEncodingMethod *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RTPH263VideoRedundancyEncoding(dd, &(val)->u.rtpH263VideoRedundancyEncoding))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMethod(RedundancyEncodingMethod *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1Free_RTPH263VideoRedundancyEncoding(&(val)->u.rtpH263VideoRedundancyEncoding);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H263Options(ASN1encoding_t enc, H263Options *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedIntraCodingMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->deblockingFilterMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->improvedPBFramesMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unlimitedMotionVectors))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureFreeze))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureFreezeAndRelease))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->resizingPartPicFreezeAndRelease))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->fullPictureSnapshot))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->partialPictureSnapshot))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->videoSegmentTagging))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->progressiveRefinement))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingByFour))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicPictureResizingSixteenthPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingHalfPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->dynamicWarpingSixteenthPel))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->independentSegmentDecoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_NonRect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesInOrder_Rect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_NonRect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->slicesNoOrder_Rect))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alternateInterVLCMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->modifiedQuantizationMode))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reducedResolutionUpdate))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_TransparencyParameters(enc, &(val)->transparencyParameters))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->separateVideoBackChannel))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_RefPictureSelection(enc, &(val)->refPictureSelection))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_H263Options_customPictureClockFrequency(enc, &(val)->customPictureClockFrequency))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_H263Options_customPictureFormat(enc, &(val)->customPictureFormat))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_H263Options_modeCombos(enc, &(val)->modeCombos))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options(ASN1decoding_t dec, H263Options *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedIntraCodingMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->deblockingFilterMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->improvedPBFramesMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->unlimitedMotionVectors))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureFreeze))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureFreezeAndRelease))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->resizingPartPicFreezeAndRelease))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->fullPictureSnapshot))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->partialPictureSnapshot))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->videoSegmentTagging))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->progressiveRefinement))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingByFour))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicPictureResizingSixteenthPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingHalfPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->dynamicWarpingSixteenthPel))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->independentSegmentDecoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_NonRect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesInOrder_Rect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_NonRect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->slicesNoOrder_Rect))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alternateInterVLCMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->modifiedQuantizationMode))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reducedResolutionUpdate))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_TransparencyParameters(dec, &(val)->transparencyParameters))
        return 0;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->separateVideoBackChannel))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_RefPictureSelection(dec, &(val)->refPictureSelection))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_H263Options_customPictureClockFrequency(dec, &(val)->customPictureClockFrequency))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_H263Options_customPictureFormat(dec, &(val)->customPictureFormat))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_H263Options_modeCombos(dec, &(val)->modeCombos))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263Options(H263Options *val)
{
    if (val) {
    if ((val)->o[0] & 0x20) {
        ASN1Free_H263Options_customPictureClockFrequency(&(val)->customPictureClockFrequency);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_H263Options_customPictureFormat(&(val)->customPictureFormat);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_H263Options_modeCombos(&(val)->modeCombos);
    }
    }
}

static int ASN1CALL ASN1Enc_H263VideoModeCombos(ASN1encoding_t enc, H263VideoModeCombos *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H263ModeComboFlags(enc, &(val)->h263VideoUncoupledModes))
    return 0;
    if (!ASN1Enc_H263VideoModeCombos_h263VideoCoupledModes(enc, &(val)->h263VideoCoupledModes))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoModeCombos(ASN1decoding_t dec, H263VideoModeCombos *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H263ModeComboFlags(dec, &(val)->h263VideoUncoupledModes))
    return 0;
    if (!ASN1Dec_H263VideoModeCombos_h263VideoCoupledModes(dec, &(val)->h263VideoCoupledModes))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoModeCombos(H263VideoModeCombos *val)
{
    if (val) {
    ASN1Free_H263VideoModeCombos_h263VideoCoupledModes(&(val)->h263VideoCoupledModes);
    }
}

static int ASN1CALL ASN1Enc_AudioCapability(ASN1encoding_t enc, AudioCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw64k - 1))
        return 0;
    break;
    case 3:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Alaw56k - 1))
        return 0;
    break;
    case 4:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw64k - 1))
        return 0;
    break;
    case 5:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g711Ulaw56k - 1))
        return 0;
    break;
    case 6:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_64k - 1))
        return 0;
    break;
    case 7:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_56k - 1))
        return 0;
    break;
    case 8:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g722_48k - 1))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_AudioCapability_g7231(enc, &(val)->u.g7231))
        return 0;
    break;
    case 10:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g728 - 1))
        return 0;
    break;
    case 11:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729 - 1))
        return 0;
    break;
    case 12:
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->u.g729AnnexA - 1))
        return 0;
    break;
    case 13:
    if (!ASN1Enc_IS11172AudioCapability(enc, &(val)->u.is11172AudioCapability))
        return 0;
    break;
    case 14:
    if (!ASN1Enc_IS13818AudioCapability(enc, &(val)->u.is13818AudioCapability))
        return 0;
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 17:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_G7231AnnexCCapability(ee, &(val)->u.g7231AnnexCCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 18:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 19:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 20:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioCapability(ASN1decoding_t dec, AudioCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw64k))
        return 0;
    (val)->u.g711Alaw64k += 1;
    break;
    case 3:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Alaw56k))
        return 0;
    (val)->u.g711Alaw56k += 1;
    break;
    case 4:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw64k))
        return 0;
    (val)->u.g711Ulaw64k += 1;
    break;
    case 5:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g711Ulaw56k))
        return 0;
    (val)->u.g711Ulaw56k += 1;
    break;
    case 6:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_64k))
        return 0;
    (val)->u.g722_64k += 1;
    break;
    case 7:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_56k))
        return 0;
    (val)->u.g722_56k += 1;
    break;
    case 8:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g722_48k))
        return 0;
    (val)->u.g722_48k += 1;
    break;
    case 9:
    if (!ASN1Dec_AudioCapability_g7231(dec, &(val)->u.g7231))
        return 0;
    break;
    case 10:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g728))
        return 0;
    (val)->u.g728 += 1;
    break;
    case 11:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729))
        return 0;
    (val)->u.g729 += 1;
    break;
    case 12:
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->u.g729AnnexA))
        return 0;
    (val)->u.g729AnnexA += 1;
    break;
    case 13:
    if (!ASN1Dec_IS11172AudioCapability(dec, &(val)->u.is11172AudioCapability))
        return 0;
    break;
    case 14:
    if (!ASN1Dec_IS13818AudioCapability(dec, &(val)->u.is13818AudioCapability))
        return 0;
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
        return 0;
    (val)->u.g729wAnnexB += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
        return 0;
    (val)->u.g729AnnexAwAnnexB += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 17:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_G7231AnnexCCapability(dd, &(val)->u.g7231AnnexCCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 18:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 19:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 20:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    //ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    //nik: any number greate than 20 is extension case.
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioCapability(AudioCapability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CompressionType(ASN1encoding_t enc, CompressionType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_V42bis(enc, &(val)->u.v42bis))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CompressionType(ASN1decoding_t dec, CompressionType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_V42bis(dec, &(val)->u.v42bis))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_MediaEncryptionAlgorithm(ASN1encoding_t enc, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.algorithm))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaEncryptionAlgorithm(ASN1decoding_t dec, MediaEncryptionAlgorithm *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.algorithm))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaEncryptionAlgorithm(MediaEncryptionAlgorithm *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1objectidentifier_free(&(val)->u.algorithm);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_AuthenticationCapability(ASN1encoding_t enc, AuthenticationCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticationCapability(ASN1decoding_t dec, AuthenticationCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticationCapability(AuthenticationCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NonStandardParameter(&(val)->nonStandard);
    }
    }
}

static int ASN1CALL ASN1Enc_IntegrityCapability(ASN1encoding_t enc, IntegrityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IntegrityCapability(ASN1decoding_t dec, IntegrityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IntegrityCapability(IntegrityCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NonStandardParameter(&(val)->nonStandard);
    }
    }
}

static int ASN1CALL ASN1Enc_H223AL1MParameters(ASN1encoding_t enc, H223AL1MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223AL1MParameters_transferMode(enc, &(val)->transferMode))
    return 0;
    if (!ASN1Enc_H223AL1MParameters_headerFEC(enc, &(val)->headerFEC))
    return 0;
    if (!ASN1Enc_H223AL1MParameters_crcLength(enc, &(val)->crcLength))
    return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
    return 0;
    if (!ASN1Enc_H223AL1MParameters_arqType(enc, &(val)->arqType))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alsduSplitting))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL1MParameters(ASN1decoding_t dec, H223AL1MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223AL1MParameters_transferMode(dec, &(val)->transferMode))
    return 0;
    if (!ASN1Dec_H223AL1MParameters_headerFEC(dec, &(val)->headerFEC))
    return 0;
    if (!ASN1Dec_H223AL1MParameters_crcLength(dec, &(val)->crcLength))
    return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
    return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL1MParameters_arqType(dec, &(val)->arqType))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alsduSplitting))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H223AL3MParameters(ASN1encoding_t enc, H223AL3MParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223AL3MParameters_headerFormat(enc, &(val)->headerFormat))
    return 0;
    if (!ASN1Enc_H223AL3MParameters_crcLength(enc, &(val)->crcLength))
    return 0;
    if (!ASN1PEREncBitVal(enc, 5, (val)->rcpcCodeRate - 8))
    return 0;
    if (!ASN1Enc_H223AL3MParameters_arqType(enc, &(val)->arqType))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->alpduInterleaving))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223AL3MParameters(ASN1decoding_t dec, H223AL3MParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223AL3MParameters_headerFormat(dec, &(val)->headerFormat))
    return 0;
    if (!ASN1Dec_H223AL3MParameters_crcLength(dec, &(val)->crcLength))
    return 0;
    if (!ASN1PERDecU16Val(dec, 5, &(val)->rcpcCodeRate))
    return 0;
    (val)->rcpcCodeRate += 8;
    if (!ASN1Dec_H223AL3MParameters_arqType(dec, &(val)->arqType))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->alpduInterleaving))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_V76HDLCParameters(ASN1encoding_t enc, V76HDLCParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_CRCLength(enc, &(val)->crcLength))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->n401 - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->loopbackTestProcedure))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76HDLCParameters(ASN1decoding_t dec, V76HDLCParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_CRCLength(dec, &(val)->crcLength))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->n401))
    return 0;
    (val)->n401 += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->loopbackTestProcedure))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_UnicastAddress(ASN1encoding_t enc, UnicastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_UnicastAddress_iPAddress(enc, &(val)->u.iPAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_UnicastAddress_iPXAddress(enc, &(val)->u.iPXAddress))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_UnicastAddress_iP6Address(enc, &(val)->u.iP6Address))
        return 0;
    break;
    case 4:
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_UnicastAddress_iPSourceRouteAddress(enc, &(val)->u.iPSourceRouteAddress))
        return 0;
    break;
    case 6:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 7:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UnicastAddress(ASN1decoding_t dec, UnicastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_UnicastAddress_iPAddress(dec, &(val)->u.iPAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_UnicastAddress_iPXAddress(dec, &(val)->u.iPXAddress))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_UnicastAddress_iP6Address(dec, &(val)->u.iP6Address))
        return 0;
    break;
    case 4:
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->u.netBios, 16))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_UnicastAddress_iPSourceRouteAddress(dec, &(val)->u.iPSourceRouteAddress))
        return 0;
    break;
    case 6:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 7:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UnicastAddress(UnicastAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_UnicastAddress_iPAddress(&(val)->u.iPAddress);
        break;
    case 2:
        ASN1Free_UnicastAddress_iPXAddress(&(val)->u.iPXAddress);
        break;
    case 3:
        ASN1Free_UnicastAddress_iP6Address(&(val)->u.iP6Address);
        break;
    case 4:
        break;
    case 5:
        ASN1Free_UnicastAddress_iPSourceRouteAddress(&(val)->u.iPSourceRouteAddress);
        break;
    case 6:
        break;
    case 7:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MulticastAddress(ASN1encoding_t enc, MulticastAddress *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_MulticastAddress_iPAddress(enc, &(val)->u.iPAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MulticastAddress_iP6Address(enc, &(val)->u.iP6Address))
        return 0;
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncOctetString_VarSize(ee, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.nonStandardAddress))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MulticastAddress(ASN1decoding_t dec, MulticastAddress *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_MulticastAddress_iPAddress(dec, &(val)->u.iPAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MulticastAddress_iP6Address(dec, &(val)->u.iP6Address))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1PERDecOctetString_VarSize(dd, (ASN1octetstring2_t *) &(val)->u.nsap, 1, 20, 5))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.nonStandardAddress))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MulticastAddress(MulticastAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_MulticastAddress_iPAddress(&(val)->u.iPAddress);
        break;
    case 2:
        ASN1Free_MulticastAddress_iP6Address(&(val)->u.iP6Address);
        break;
    case 3:
        break;
    case 4:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandardAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionSync(ASN1encoding_t enc, EncryptionSync *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandard))
        return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->synchFlag))
    return 0;
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_EncryptionSync_escrowentry(enc, &(val)->escrowentry))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionSync(ASN1decoding_t dec, EncryptionSync *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandard))
        return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->synchFlag))
    return 0;
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->h235Key, 1, 65535, 16))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_EncryptionSync_escrowentry(dec, &(val)->escrowentry))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionSync(EncryptionSync *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_NonStandardParameter(&(val)->nonStandard);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_EncryptionSync_escrowentry(&(val)->escrowentry);
    }
    }
}

static int ASN1CALL ASN1Enc_RequestChannelClose(ASN1encoding_t enc, RequestChannelClose *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x40;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1Enc_QOSCapability(ee, &(val)->qosCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x40) {
        if (!ASN1Enc_RequestChannelClose_reason(ee, &(val)->reason))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestChannelClose(ASN1decoding_t dec, RequestChannelClose *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_QOSCapability(dd, &(val)->qosCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RequestChannelClose_reason(dd, &(val)->reason))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestChannelClose(RequestChannelClose *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_QOSCapability(&(val)->qosCapability);
    }
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntryDescriptor(ASN1encoding_t enc, MultiplexEntryDescriptor *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncBitVal(enc, 4, (val)->multiplexTableEntryNumber - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_MultiplexEntryDescriptor_elementList(enc, &(val)->elementList))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntryDescriptor(ASN1decoding_t dec, MultiplexEntryDescriptor *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecU16Val(dec, 4, &(val)->multiplexTableEntryNumber))
    return 0;
    (val)->multiplexTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_MultiplexEntryDescriptor_elementList(dec, &(val)->elementList))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntryDescriptor(MultiplexEntryDescriptor *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_MultiplexEntryDescriptor_elementList(&(val)->elementList);
    }
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySendReject(ASN1encoding_t enc, MultiplexEntrySendReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1Enc_MultiplexEntrySendReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySendReject(ASN1decoding_t dec, MultiplexEntrySendReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1Dec_MultiplexEntrySendReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySendReject(MultiplexEntrySendReject *val)
{
    if (val) {
    ASN1Free_MultiplexEntrySendReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_RequestMultiplexEntryReject(ASN1encoding_t enc, RequestMultiplexEntryReject *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_entryNumbers(enc, &(val)->entryNumbers))
    return 0;
    if (!ASN1Enc_RequestMultiplexEntryReject_rejectionDescriptions(enc, &(val)->rejectionDescriptions))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMultiplexEntryReject(ASN1decoding_t dec, RequestMultiplexEntryReject *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_entryNumbers(dec, &(val)->entryNumbers))
    return 0;
    if (!ASN1Dec_RequestMultiplexEntryReject_rejectionDescriptions(dec, &(val)->rejectionDescriptions))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMultiplexEntryReject(RequestMultiplexEntryReject *val)
{
    if (val) {
    ASN1Free_RequestMultiplexEntryReject_entryNumbers(&(val)->entryNumbers);
    ASN1Free_RequestMultiplexEntryReject_rejectionDescriptions(&(val)->rejectionDescriptions);
    }
}

static int ASN1CALL ASN1Enc_H263VideoMode(ASN1encoding_t enc, H263VideoMode *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x80;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1Enc_H263VideoMode_resolution(enc, &(val)->resolution))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->bitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x40) {
        if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x20) {
        if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoMode(ASN1decoding_t dec, H263VideoMode *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H263VideoMode_resolution(dec, &(val)->resolution))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bitRate))
    return 0;
    (val)->bitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoMode(H263VideoMode *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_H263Options(&(val)->h263Options);
    }
    }
}

static int ASN1CALL ASN1Enc_AudioMode(ASN1encoding_t enc, AudioMode *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    break;
    case 10:
    break;
    case 11:
    break;
    case 12:
    if (!ASN1Enc_AudioMode_g7231(enc, &(val)->u.g7231))
        return 0;
    break;
    case 13:
    if (!ASN1Enc_IS11172AudioMode(enc, &(val)->u.is11172AudioMode))
        return 0;
    break;
    case 14:
    if (!ASN1Enc_IS13818AudioMode(enc, &(val)->u.is13818AudioMode))
        return 0;
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729wAnnexB - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 8, (val)->u.g729AnnexAwAnnexB - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 17:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_G7231AnnexCMode(ee, &(val)->u.g7231AnnexCMode))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 18:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmFullRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 19:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmHalfRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 20:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_GSMAudioCapability(ee, &(val)->u.gsmEnhancedFullRate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_AudioMode(ASN1decoding_t dec, AudioMode *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    break;
    case 10:
    break;
    case 11:
    break;
    case 12:
    if (!ASN1Dec_AudioMode_g7231(dec, &(val)->u.g7231))
        return 0;
    break;
    case 13:
    if (!ASN1Dec_IS11172AudioMode(dec, &(val)->u.is11172AudioMode))
        return 0;
    break;
    case 14:
    if (!ASN1Dec_IS13818AudioMode(dec, &(val)->u.is13818AudioMode))
        return 0;
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729wAnnexB))
        return 0;
    (val)->u.g729wAnnexB += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU16Val(dd, 8, &(val)->u.g729AnnexAwAnnexB))
        return 0;
    (val)->u.g729AnnexAwAnnexB += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 17:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_G7231AnnexCMode(dd, &(val)->u.g7231AnnexCMode))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 18:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmFullRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 19:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmHalfRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 20:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_GSMAudioCapability(dd, &(val)->u.gsmEnhancedFullRate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_AudioMode(AudioMode *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionMode(ASN1encoding_t enc, EncryptionMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionMode(ASN1decoding_t dec, EncryptionMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionMode(EncryptionMode *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ConferenceRequest(ASN1encoding_t enc, ConferenceRequest *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.dropTerminal))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.requestTerminalID))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceRequest_requestTerminalCertificate(ee, &(val)->u.requestTerminalCertificate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncUnsignedShort(ee, (val)->u.broadcastMyLogicalChannel - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TerminalLabel(ee, &(val)->u.makeTerminalBroadcaster))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 14:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TerminalLabel(ee, &(val)->u.sendThisSource))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RemoteMCRequest(ee, &(val)->u.remoteMCRequest))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceRequest(ASN1decoding_t dec, ConferenceRequest *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.dropTerminal))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.requestTerminalID))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceRequest_requestTerminalCertificate(dd, &(val)->u.requestTerminalCertificate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1PERDecUnsignedShort(dd, &(val)->u.broadcastMyLogicalChannel))
        return 0;
    (val)->u.broadcastMyLogicalChannel += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TerminalLabel(dd, &(val)->u.makeTerminalBroadcaster))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 14:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TerminalLabel(dd, &(val)->u.sendThisSource))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RemoteMCRequest(dd, &(val)->u.remoteMCRequest))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceRequest(ConferenceRequest *val)
{
    if (val) {
    switch ((val)->choice) {
    case 11:
        ASN1Free_ConferenceRequest_requestTerminalCertificate(&(val)->u.requestTerminalCertificate);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria(ASN1encoding_t enc, PCertSelectionCriteria *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CertSelectionCriteria_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val)
{
    if (!ASN1Enc_Criteria(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria(ASN1decoding_t dec, PCertSelectionCriteria *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CertSelectionCriteria_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val)
{
    if (!ASN1Dec_Criteria(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertSelectionCriteria(PCertSelectionCriteria *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CertSelectionCriteria_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val)
{
    if (val) {
    ASN1Free_Criteria(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConferenceResponse(ASN1encoding_t enc, ConferenceResponse *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_ConferenceResponse_mCTerminalIDResponse(enc, &(val)->u.mCTerminalIDResponse))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_ConferenceResponse_terminalIDResponse(enc, &(val)->u.terminalIDResponse))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_ConferenceResponse_conferenceIDResponse(enc, &(val)->u.conferenceIDResponse))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_ConferenceResponse_passwordResponse(enc, &(val)->u.passwordResponse))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_ConferenceResponse_terminalListResponse(enc, &(val)->u.terminalListResponse))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (!ASN1Enc_ConferenceResponse_makeMeChairResponse(enc, &(val)->u.makeMeChairResponse))
        return 0;
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_extensionAddressResponse(ee, &(val)->u.extensionAddressResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_chairTokenOwnerResponse(ee, &(val)->u.chairTokenOwnerResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_terminalCertificateResponse(ee, &(val)->u.terminalCertificateResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_broadcastMyLogicalChannelResponse(ee, &(val)->u.broadcastMyLogicalChannelResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_makeTerminalBroadcasterResponse(ee, &(val)->u.makeTerminalBroadcasterResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 14:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse_sendThisSourceResponse(ee, &(val)->u.sendThisSourceResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RequestAllTerminalIDsResponse(ee, &(val)->u.requestAllTerminalIDsResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RemoteMCResponse(ee, &(val)->u.remoteMCResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceResponse(ASN1decoding_t dec, ConferenceResponse *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 8))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_ConferenceResponse_mCTerminalIDResponse(dec, &(val)->u.mCTerminalIDResponse))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_ConferenceResponse_terminalIDResponse(dec, &(val)->u.terminalIDResponse))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_ConferenceResponse_conferenceIDResponse(dec, &(val)->u.conferenceIDResponse))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_ConferenceResponse_passwordResponse(dec, &(val)->u.passwordResponse))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_ConferenceResponse_terminalListResponse(dec, &(val)->u.terminalListResponse))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (!ASN1Dec_ConferenceResponse_makeMeChairResponse(dec, &(val)->u.makeMeChairResponse))
        return 0;
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_extensionAddressResponse(dd, &(val)->u.extensionAddressResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_chairTokenOwnerResponse(dd, &(val)->u.chairTokenOwnerResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_terminalCertificateResponse(dd, &(val)->u.terminalCertificateResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_broadcastMyLogicalChannelResponse(dd, &(val)->u.broadcastMyLogicalChannelResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_makeTerminalBroadcasterResponse(dd, &(val)->u.makeTerminalBroadcasterResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 14:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse_sendThisSourceResponse(dd, &(val)->u.sendThisSourceResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RequestAllTerminalIDsResponse(dd, &(val)->u.requestAllTerminalIDsResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RemoteMCResponse(dd, &(val)->u.remoteMCResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceResponse(ConferenceResponse *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_ConferenceResponse_mCTerminalIDResponse(&(val)->u.mCTerminalIDResponse);
        break;
    case 2:
        ASN1Free_ConferenceResponse_terminalIDResponse(&(val)->u.terminalIDResponse);
        break;
    case 3:
        ASN1Free_ConferenceResponse_conferenceIDResponse(&(val)->u.conferenceIDResponse);
        break;
    case 4:
        ASN1Free_ConferenceResponse_passwordResponse(&(val)->u.passwordResponse);
        break;
    case 5:
        ASN1Free_ConferenceResponse_terminalListResponse(&(val)->u.terminalListResponse);
        break;
    case 9:
        ASN1Free_ConferenceResponse_extensionAddressResponse(&(val)->u.extensionAddressResponse);
        break;
    case 10:
        ASN1Free_ConferenceResponse_chairTokenOwnerResponse(&(val)->u.chairTokenOwnerResponse);
        break;
    case 11:
        ASN1Free_ConferenceResponse_terminalCertificateResponse(&(val)->u.terminalCertificateResponse);
        break;
    case 15:
        ASN1Free_RequestAllTerminalIDsResponse(&(val)->u.requestAllTerminalIDsResponse);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EndSessionCommand(ASN1encoding_t enc, EndSessionCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Enc_EndSessionCommand_gstnOptions(enc, &(val)->u.gstnOptions))
        return 0;
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_EndSessionCommand_isdnOptions(ee, &(val)->u.isdnOptions))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EndSessionCommand(ASN1decoding_t dec, EndSessionCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Dec_EndSessionCommand_gstnOptions(dec, &(val)->u.gstnOptions))
        return 0;
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_EndSessionCommand_isdnOptions(dd, &(val)->u.isdnOptions))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EndSessionCommand(EndSessionCommand *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ConferenceCommand(ASN1encoding_t enc, ConferenceCommand *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.broadcastMyLogicalChannel - 1))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.cancelBroadcastMyLogicalChannel - 1))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.makeTerminalBroadcaster))
        return 0;
    break;
    case 4:
    break;
    case 5:
    if (!ASN1Enc_TerminalLabel(enc, &(val)->u.sendThisSource))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_SubstituteConferenceIDCommand(ee, &(val)->u.substituteConferenceIDCommand))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCommand(ASN1decoding_t dec, ConferenceCommand *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.broadcastMyLogicalChannel))
        return 0;
    (val)->u.broadcastMyLogicalChannel += 1;
    break;
    case 2:
    if (!ASN1PERDecUnsignedShort(dec, &(val)->u.cancelBroadcastMyLogicalChannel))
        return 0;
    (val)->u.cancelBroadcastMyLogicalChannel += 1;
    break;
    case 3:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.makeTerminalBroadcaster))
        return 0;
    break;
    case 4:
    break;
    case 5:
    if (!ASN1Dec_TerminalLabel(dec, &(val)->u.sendThisSource))
        return 0;
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_SubstituteConferenceIDCommand(dd, &(val)->u.substituteConferenceIDCommand))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCommand(ConferenceCommand *val)
{
    if (val) {
    switch ((val)->choice) {
    case 8:
        ASN1Free_SubstituteConferenceIDCommand(&(val)->u.substituteConferenceIDCommand);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication_userInputSupportIndication(ASN1encoding_t enc, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication_userInputSupportIndication(ASN1decoding_t dec, UserInputIndication_userInputSupportIndication *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication_userInputSupportIndication(UserInputIndication_userInputSupportIndication *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication_type(ASN1encoding_t enc, MiscellaneousIndication_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    break;
    case 10:
    if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
        return 0;
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_MiscellaneousIndication_type_videoNotDecodedMBs(ee, &(val)->u.videoNotDecodedMBs))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_TransportCapability(ee, &(val)->u.transportCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication_type(ASN1decoding_t dec, MiscellaneousIndication_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    break;
    case 9:
    break;
    case 10:
    if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
        return 0;
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_MiscellaneousIndication_type_videoNotDecodedMBs(dd, &(val)->u.videoNotDecodedMBs))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_TransportCapability(dd, &(val)->u.transportCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication_type(MiscellaneousIndication_type *val)
{
    if (val) {
    switch ((val)->choice) {
    case 12:
        ASN1Free_TransportCapability(&(val)->u.transportCapability);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand_type(ASN1encoding_t enc, MiscellaneousCommand_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateGOB(enc, &(val)->u.videoFastUpdateGOB))
        return 0;
    break;
    case 8:
    if (!ASN1PEREncBitVal(enc, 5, (val)->u.videoTemporalSpatialTradeOff))
        return 0;
    break;
    case 9:
    break;
    case 10:
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_videoFastUpdateMB(ee, &(val)->u.videoFastUpdateMB))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncUnsignedShort(ee, (val)->u.maxH223MUXPDUsize - 1))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_EncryptionSync(ee, &(val)->u.encryptionUpdate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 14:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_EncryptionUpdateRequest(ee, &(val)->u.encryptionUpdateRequest))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 17:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_MiscellaneousCommand_type_progressiveRefinementStart(ee, &(val)->u.progressiveRefinementStart))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 18:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 19:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand_type(ASN1decoding_t dec, MiscellaneousCommand_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateGOB(dec, &(val)->u.videoFastUpdateGOB))
        return 0;
    break;
    case 8:
    if (!ASN1PERDecU16Val(dec, 5, &(val)->u.videoTemporalSpatialTradeOff))
        return 0;
    break;
    case 9:
    break;
    case 10:
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_videoFastUpdateMB(dd, &(val)->u.videoFastUpdateMB))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1PERDecUnsignedShort(dd, &(val)->u.maxH223MUXPDUsize))
        return 0;
    (val)->u.maxH223MUXPDUsize += 1;
    ASN1_CloseDecoder(dd);
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_EncryptionSync(dd, &(val)->u.encryptionUpdate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 14:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_EncryptionUpdateRequest(dd, &(val)->u.encryptionUpdateRequest))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 17:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_MiscellaneousCommand_type_progressiveRefinementStart(dd, &(val)->u.progressiveRefinementStart))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 18:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 19:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand_type(MiscellaneousCommand_type *val)
{
    if (val) {
    switch ((val)->choice) {
    case 13:
        ASN1Free_EncryptionSync(&(val)->u.encryptionUpdate);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand_encryptionAlgorithmID(ASN1encoding_t enc, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->h233AlgorithmIdentifier))
    return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->associatedAlgorithm))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand_encryptionAlgorithmID(ASN1decoding_t dec, EncryptionCommand_encryptionAlgorithmID *val)
{
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->h233AlgorithmIdentifier))
    return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->associatedAlgorithm))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand_encryptionAlgorithmID(EncryptionCommand_encryptionAlgorithmID *val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&(val)->associatedAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard(PCommunicationModeTableEntry_nonStandard *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode_secondaryEncoding(ASN1encoding_t enc, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_AudioMode(enc, &(val)->u.audioData))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode_secondaryEncoding(ASN1decoding_t dec, RedundancyEncodingMode_secondaryEncoding *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_AudioMode(dec, &(val)->u.audioData))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode_secondaryEncoding(RedundancyEncodingMode_secondaryEncoding *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_AudioMode(&(val)->u.audioData);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters_adaptationLayerType(ASN1encoding_t enc, H223ModeParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
        return 0;
    break;
    case 7:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters_adaptationLayerType(ASN1decoding_t dec, H223ModeParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
        return 0;
    break;
    case 7:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters_adaptationLayerType(H223ModeParameters_adaptationLayerType *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, 1, 15, 4);
}

static int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Enc_MultiplexEntryDescriptor(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn, sizeof(**val), 1, 15, 4);
}

static int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (!ASN1Dec_MultiplexEntryDescriptor(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors(PMultiplexEntrySend_multiplexEntryDescriptors *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val)
{
    if (val) {
    ASN1Free_MultiplexEntryDescriptor(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard(PH2250LogicalChannelAckParameters_nonStandard *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_RTPPayloadType_payloadDescriptor(ASN1encoding_t enc, RTPPayloadType_payloadDescriptor *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandardIdentifier))
        return 0;
    break;
    case 2:
    if (!ASN1PEREncExtensionBitClear(enc))
        return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->u.rfc_number - 1))
        return 0;
    break;
    case 3:
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.oid))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType_payloadDescriptor(ASN1decoding_t dec, RTPPayloadType_payloadDescriptor *val)
{
    ASN1uint32_t x;
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandardIdentifier))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecExtensionBit(dec, &x))
        return 0;
    if (!x) {
        if (!ASN1PERDecUnsignedShort(dec, &(val)->u.rfc_number))
        return 0;
        (val)->u.rfc_number += 1;
    } else {
        ASN1PERDecAlignment(dec);
        if (!ASN1PERDecFragmentedLength(dec, &l))
        return 0;
        if (!ASN1PERDecSkipBits(dec, l * 8))
        return 0;
    }
    break;
    case 3:
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.oid))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType_payloadDescriptor(RTPPayloadType_payloadDescriptor *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandardIdentifier);
        break;
    case 3:
        ASN1objectidentifier_free(&(val)->u.oid);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn);
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard(PH2250LogicalChannelParameters_nonStandard *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(ASN1encoding_t enc, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType_al3(enc, &(val)->u.al3))
        return 0;
    break;
    case 7:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL1MParameters(ee, &(val)->u.al1M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL2MParameters(ee, &(val)->u.al2M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223AL3MParameters(ee, &(val)->u.al3M))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(ASN1decoding_t dec, H223LogicalChannelParameters_adaptationLayerType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType_al3(dec, &(val)->u.al3))
        return 0;
    break;
    case 7:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL1MParameters(dd, &(val)->u.al1M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL2MParameters(dd, &(val)->u.al2M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223AL3MParameters(dd, &(val)->u.al3M))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters_adaptationLayerType(H223LogicalChannelParameters_adaptationLayerType *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData(ASN1encoding_t enc, PConferenceCapability_nonStandardData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConferenceCapability_nonStandardData_ElmFn);
}

static int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Enc_NonStandardParameter(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData(ASN1decoding_t dec, PConferenceCapability_nonStandardData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConferenceCapability_nonStandardData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val)
{
    if (!ASN1Dec_NonStandardParameter(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData(PConferenceCapability_nonStandardData *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConferenceCapability_nonStandardData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability_nonStandard(ASN1encoding_t enc, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PEREncBitVal(enc, 4, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_NonStandardParameter(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability_nonStandard(ASN1decoding_t dec, UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (!ASN1PERDecU32Val(dec, 4, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_NonStandardParameter(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability_nonStandard(UserInputCapability_nonStandard *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_NonStandardParameter(&(val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability_v76wCompression(ASN1encoding_t enc, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitCompression))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_CompressionType(enc, &(val)->u.receiveCompression))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_CompressionType(enc, &(val)->u.transmitAndReceiveCompression))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability_v76wCompression(ASN1decoding_t dec, DataProtocolCapability_v76wCompression *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitCompression))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_CompressionType(dec, &(val)->u.receiveCompression))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_CompressionType(dec, &(val)->u.transmitAndReceiveCompression))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos(ASN1encoding_t enc, PH263Options_modeCombos *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H263Options_modeCombos_ElmFn, 1, 16, 4);
}

static int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val)
{
    if (!ASN1Enc_H263VideoModeCombos(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos(ASN1decoding_t dec, PH263Options_modeCombos *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H263Options_modeCombos_ElmFn, sizeof(**val), 1, 16, 4);
}

static int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val)
{
    if (!ASN1Dec_H263VideoModeCombos(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H263Options_modeCombos(PH263Options_modeCombos *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H263Options_modeCombos_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val)
{
    if (val) {
    ASN1Free_H263VideoModeCombos(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities(ASN1encoding_t enc, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TransportCapability_qOSCapabilities_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Enc_QOSCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities(ASN1decoding_t dec, PTransportCapability_qOSCapabilities *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TransportCapability_qOSCapabilities_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val)
{
    if (!ASN1Dec_QOSCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities(PTransportCapability_qOSCapabilities *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TransportCapability_qOSCapabilities_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val)
{
    if (val) {
    ASN1Free_QOSCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_NonStandardMessage(ASN1encoding_t enc, NonStandardMessage *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->nonStandardData))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardMessage(ASN1decoding_t dec, NonStandardMessage *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->nonStandardData))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardMessage(NonStandardMessage *val)
{
    if (val) {
    ASN1Free_NonStandardParameter(&(val)->nonStandardData);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingCapability(ASN1encoding_t enc, RedundancyEncodingCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->primaryEncoding - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_RedundancyEncodingCapability_secondaryEncoding(enc, &(val)->secondaryEncoding))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingCapability(ASN1decoding_t dec, RedundancyEncodingCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->primaryEncoding))
    return 0;
    (val)->primaryEncoding += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_RedundancyEncodingCapability_secondaryEncoding(dec, &(val)->secondaryEncoding))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingCapability(RedundancyEncodingCapability *val)
{
    if (val) {
    ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
    if ((val)->o[0] & 0x80) {
        ASN1Free_RedundancyEncodingCapability_secondaryEncoding(&(val)->secondaryEncoding);
    }
    }
}

static int ASN1CALL ASN1Enc_H263VideoCapability(ASN1encoding_t enc, H263VideoCapability *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x4;
    y = ASN1PEREncCheckExtensions(8, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 7, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
        return 0;
    }
    if (o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
        return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->advancedPrediction))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->pbFrames))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
    return 0;
    if (o[0] & 0x4) {
    l = ASN1uint32_uoctets((val)->hrd_B);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->hrd_B))
        return 0;
    }
    if (o[0] & 0x2) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->bppMaxKb))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 8, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->slowSqcifMPI - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->slowQcifMPI - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x20) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->slowCifMPI - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x10) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif4MPI - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x8) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->slowCif16MPI - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x4) {
        if (!ASN1PEREncBoolean(ee, (val)->errorCompensation))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x2) {
        if (!ASN1Enc_EnhancementLayerInfo(ee, &(val)->enhancementLayerInfo))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x1) {
        if (!ASN1Enc_H263Options(ee, &(val)->h263Options))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H263VideoCapability(ASN1decoding_t dec, H263VideoCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
        return 0;
    (val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
        return 0;
    (val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
        return 0;
    (val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
        return 0;
    (val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
        return 0;
    (val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
    return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->advancedPrediction))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->pbFrames))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
    return 0;
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecU32Val(dec, 2, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->hrd_B))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->bppMaxKb))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 8, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->slowSqcifMPI))
        return 0;
        (val)->slowSqcifMPI += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->slowQcifMPI))
        return 0;
        (val)->slowQcifMPI += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCifMPI))
        return 0;
        (val)->slowCifMPI += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif4MPI))
        return 0;
        (val)->slowCif4MPI += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x8) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->slowCif16MPI))
        return 0;
        (val)->slowCif16MPI += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x4) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->errorCompensation))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x2) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EnhancementLayerInfo(dd, &(val)->enhancementLayerInfo))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x1) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H263Options(dd, &(val)->h263Options))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H263VideoCapability(H263VideoCapability *val)
{
    if (val) {
    if ((val)->o[1] & 0x2) {
        ASN1Free_EnhancementLayerInfo(&(val)->enhancementLayerInfo);
    }
    if ((val)->o[1] & 0x1) {
        ASN1Free_H263Options(&(val)->h263Options);
    }
    }
}

static int ASN1CALL ASN1Enc_EnhancementOptions(ASN1encoding_t enc, EnhancementOptions *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 11, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->sqcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->qcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cif4MPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->cif16MPI - 1))
        return 0;
    }
    l = ASN1uint32_uoctets((val)->maxBitRate - 1);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate - 1))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->unrestrictedVector))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->arithmeticCoding))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->temporalSpatialTradeOffCapability))
    return 0;
    if ((val)->o[0] & 0x4) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->slowSqcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->slowQcifMPI - 1))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->slowCifMPI - 1))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif4MPI - 1))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->slowCif16MPI - 1))
        return 0;
    }
    if (!ASN1PEREncBoolean(enc, (val)->errorCompensation))
    return 0;
    if ((val)->o[1] & 0x20) {
    if (!ASN1Enc_H263Options(enc, &(val)->h263Options))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementOptions(ASN1decoding_t dec, EnhancementOptions *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 11, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->sqcifMPI))
        return 0;
    (val)->sqcifMPI += 1;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->qcifMPI))
        return 0;
    (val)->qcifMPI += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cifMPI))
        return 0;
    (val)->cifMPI += 1;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cif4MPI))
        return 0;
    (val)->cif4MPI += 1;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->cif16MPI))
        return 0;
    (val)->cif16MPI += 1;
    }
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
    return 0;
    (val)->maxBitRate += 1;
    if (!ASN1PERDecBoolean(dec, &(val)->unrestrictedVector))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->arithmeticCoding))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->temporalSpatialTradeOffCapability))
    return 0;
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->slowSqcifMPI))
        return 0;
    (val)->slowSqcifMPI += 1;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->slowQcifMPI))
        return 0;
    (val)->slowQcifMPI += 1;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCifMPI))
        return 0;
    (val)->slowCifMPI += 1;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif4MPI))
        return 0;
    (val)->slowCif4MPI += 1;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->slowCif16MPI))
        return 0;
    (val)->slowCif16MPI += 1;
    }
    if (!ASN1PERDecBoolean(dec, &(val)->errorCompensation))
    return 0;
    if ((val)->o[1] & 0x20) {
    if (!ASN1Dec_H263Options(dec, &(val)->h263Options))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementOptions(EnhancementOptions *val)
{
    if (val) {
    if ((val)->o[1] & 0x20) {
        ASN1Free_H263Options(&(val)->h263Options);
    }
    }
}

static int ASN1CALL ASN1Enc_DataProtocolCapability(ASN1encoding_t enc, DataProtocolCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_DataProtocolCapability_v76wCompression(ee, &(val)->u.v76wCompression))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataProtocolCapability(ASN1decoding_t dec, DataProtocolCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 7:
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_DataProtocolCapability_v76wCompression(dd, &(val)->u.v76wCompression))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataProtocolCapability(DataProtocolCapability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionAuthenticationAndIntegrity(ASN1encoding_t enc, EncryptionAuthenticationAndIntegrity *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_EncryptionCapability(enc, &(val)->encryptionCapability))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_AuthenticationCapability(enc, &(val)->authenticationCapability))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_IntegrityCapability(enc, &(val)->integrityCapability))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAuthenticationAndIntegrity(ASN1decoding_t dec, EncryptionAuthenticationAndIntegrity *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_EncryptionCapability(dec, &(val)->encryptionCapability))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_AuthenticationCapability(dec, &(val)->authenticationCapability))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_IntegrityCapability(dec, &(val)->integrityCapability))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAuthenticationAndIntegrity(EncryptionAuthenticationAndIntegrity *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_EncryptionCapability(&(val)->encryptionCapability);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_AuthenticationCapability(&(val)->authenticationCapability);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_IntegrityCapability(&(val)->integrityCapability);
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionCapability(ASN1encoding_t enc, PEncryptionCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EncryptionCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val)
{
    if (!ASN1Enc_MediaEncryptionAlgorithm(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCapability(ASN1decoding_t dec, PEncryptionCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EncryptionCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val)
{
    if (!ASN1Dec_MediaEncryptionAlgorithm(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCapability(PEncryptionCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EncryptionCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val)
{
    if (val) {
    ASN1Free_MediaEncryptionAlgorithm(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UserInputCapability(ASN1encoding_t enc, UserInputCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_UserInputCapability_nonStandard(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputCapability(ASN1decoding_t dec, UserInputCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_UserInputCapability_nonStandard(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    break;
    case 4:
    break;
    case 5:
    break;
    case 6:
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputCapability(UserInputCapability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_UserInputCapability_nonStandard(&(val)->u.nonStandard);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H223LogicalChannelParameters(ASN1encoding_t enc, H223LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223LogicalChannelParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223LogicalChannelParameters(ASN1decoding_t dec, H223LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223LogicalChannelParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223LogicalChannelParameters(H223LogicalChannelParameters *val)
{
    if (val) {
    ASN1Free_H223LogicalChannelParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_V76LogicalChannelParameters(ASN1encoding_t enc, V76LogicalChannelParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_V76HDLCParameters(enc, &(val)->hdlcParameters))
    return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_suspendResume(enc, &(val)->suspendResume))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->uIH))
    return 0;
    if (!ASN1Enc_V76LogicalChannelParameters_mode(enc, &(val)->mode))
    return 0;
    if (!ASN1Enc_V75Parameters(enc, &(val)->v75Parameters))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_V76LogicalChannelParameters(ASN1decoding_t dec, V76LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_V76HDLCParameters(dec, &(val)->hdlcParameters))
    return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_suspendResume(dec, &(val)->suspendResume))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->uIH))
    return 0;
    if (!ASN1Dec_V76LogicalChannelParameters_mode(dec, &(val)->mode))
    return 0;
    if (!ASN1Dec_V75Parameters(dec, &(val)->v75Parameters))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_RTPPayloadType(ASN1encoding_t enc, RTPPayloadType *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_RTPPayloadType_payloadDescriptor(enc, &(val)->payloadDescriptor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 7, (val)->payloadType))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RTPPayloadType(ASN1decoding_t dec, RTPPayloadType *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_RTPPayloadType_payloadDescriptor(dec, &(val)->payloadDescriptor))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 7, &(val)->payloadType))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RTPPayloadType(RTPPayloadType *val)
{
    if (val) {
    ASN1Free_RTPPayloadType_payloadDescriptor(&(val)->payloadDescriptor);
    }
}

static int ASN1CALL ASN1Enc_H245TransportAddress(ASN1encoding_t enc, H245TransportAddress *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_UnicastAddress(enc, &(val)->u.unicastAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MulticastAddress(enc, &(val)->u.multicastAddress))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H245TransportAddress(ASN1decoding_t dec, H245TransportAddress *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_UnicastAddress(dec, &(val)->u.unicastAddress))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MulticastAddress(dec, &(val)->u.multicastAddress))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H245TransportAddress(H245TransportAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_UnicastAddress(&(val)->u.unicastAddress);
        break;
    case 2:
        ASN1Free_MulticastAddress(&(val)->u.multicastAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters(ASN1encoding_t enc, H2250LogicalChannelAckParameters *val)
{
    ASN1octet_t o[2];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 2);
    o[1] |= 0x80;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 5, o))
    return 0;
    if (o[0] & 0x80) {
    if (!ASN1Enc_H2250LogicalChannelAckParameters_nonStandard(enc, &(val)->nonStandard))
        return 0;
    }
    if (o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
        return 0;
    }
    if (o[0] & 0x20) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
        return 0;
    }
    if (o[0] & 0x10) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
        return 0;
    }
    if (o[0] & 0x8) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[1] & 0x80) {
        if (!ASN1PEREncBoolean(ee, (val)->flowControlToZero))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[1] & 0x40) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->portNumber))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters(ASN1decoding_t dec, H2250LogicalChannelAckParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H2250LogicalChannelAckParameters_nonStandard(dec, &(val)->nonStandard))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
        return 0;
    (val)->sessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
        return 0;
    (val)->dynamicRTPPayloadType += 96;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->flowControlToZero))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->portNumber))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters(H2250LogicalChannelAckParameters *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H2250LogicalChannelAckParameters_nonStandard(&(val)->nonStandard);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_H245TransportAddress(&(val)->mediaChannel);
    }
    if ((val)->o[0] & 0x10) {
        ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
    }
    }
}

static int ASN1CALL ASN1Enc_H223ModeParameters(ASN1encoding_t enc, H223ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H223ModeParameters_adaptationLayerType(enc, &(val)->adaptationLayerType))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->segmentableFlag))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H223ModeParameters(ASN1decoding_t dec, H223ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H223ModeParameters_adaptationLayerType(dec, &(val)->adaptationLayerType))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->segmentableFlag))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H223ModeParameters(H223ModeParameters *val)
{
    if (val) {
    ASN1Free_H223ModeParameters_adaptationLayerType(&(val)->adaptationLayerType);
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncodingMode(ASN1encoding_t enc, RedundancyEncodingMode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_RedundancyEncodingMode_secondaryEncoding(enc, &(val)->secondaryEncoding))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncodingMode(ASN1decoding_t dec, RedundancyEncodingMode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_RedundancyEncodingMode_secondaryEncoding(dec, &(val)->secondaryEncoding))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncodingMode(RedundancyEncodingMode *val)
{
    if (val) {
    ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
    if ((val)->o[0] & 0x80) {
        ASN1Free_RedundancyEncodingMode_secondaryEncoding(&(val)->secondaryEncoding);
    }
    }
}

static int ASN1CALL ASN1Enc_VideoMode(ASN1encoding_t enc, VideoMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H261VideoMode(enc, &(val)->u.h261VideoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H262VideoMode(enc, &(val)->u.h262VideoMode))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_H263VideoMode(enc, &(val)->u.h263VideoMode))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_IS11172VideoMode(enc, &(val)->u.is11172VideoMode))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoMode(ASN1decoding_t dec, VideoMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H261VideoMode(dec, &(val)->u.h261VideoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H262VideoMode(dec, &(val)->u.h262VideoMode))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_H263VideoMode(dec, &(val)->u.h263VideoMode))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_IS11172VideoMode(dec, &(val)->u.is11172VideoMode))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoMode(VideoMode *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 4:
        ASN1Free_H263VideoMode(&(val)->u.h263VideoMode);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EncryptionCommand(ASN1encoding_t enc, EncryptionCommand *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->u.encryptionSE))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Enc_EncryptionCommand_encryptionAlgorithmID(enc, &(val)->u.encryptionAlgorithmID))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionCommand(ASN1decoding_t dec, EncryptionCommand *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->u.encryptionSE))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Dec_EncryptionCommand_encryptionAlgorithmID(dec, &(val)->u.encryptionAlgorithmID))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionCommand(EncryptionCommand *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1octetstring_free(&(val)->u.encryptionSE);
        break;
    case 3:
        ASN1Free_EncryptionCommand_encryptionAlgorithmID(&(val)->u.encryptionAlgorithmID);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousCommand(ASN1encoding_t enc, MiscellaneousCommand *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_MiscellaneousCommand_type(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousCommand(ASN1decoding_t dec, MiscellaneousCommand *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
    return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousCommand_type(dec, &(val)->type))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousCommand(MiscellaneousCommand *val)
{
    if (val) {
    ASN1Free_MiscellaneousCommand_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MiscellaneousIndication(ASN1encoding_t enc, MiscellaneousIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->logicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_MiscellaneousIndication_type(enc, &(val)->type))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MiscellaneousIndication(ASN1decoding_t dec, MiscellaneousIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->logicalChannelNumber))
    return 0;
    (val)->logicalChannelNumber += 1;
    if (!ASN1Dec_MiscellaneousIndication_type(dec, &(val)->type))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MiscellaneousIndication(MiscellaneousIndication *val)
{
    if (val) {
    ASN1Free_MiscellaneousIndication_type(&(val)->type);
    }
}

static int ASN1CALL ASN1Enc_MCLocationIndication(ASN1encoding_t enc, MCLocationIndication *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->signalAddress))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MCLocationIndication(ASN1decoding_t dec, MCLocationIndication *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->signalAddress))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MCLocationIndication(MCLocationIndication *val)
{
    if (val) {
    ASN1Free_H245TransportAddress(&(val)->signalAddress);
    }
}

static int ASN1CALL ASN1Enc_UserInputIndication(ASN1encoding_t enc, UserInputIndication *val)
{
    ASN1uint32_t t;
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    t = lstrlenA((val)->u.alphanumeric);
    if (!ASN1PEREncFragmentedCharString(enc, t, (val)->u.alphanumeric, 8))
        return 0;
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputIndication_userInputSupportIndication(ee, &(val)->u.userInputSupportIndication))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputIndication_signal(ee, &(val)->u.signal))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 5:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputIndication_signalUpdate(ee, &(val)->u.signalUpdate))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_UserInputIndication(ASN1decoding_t dec, UserInputIndication *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecFragmentedZeroCharString(dec, &(val)->u.alphanumeric, 8))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputIndication_userInputSupportIndication(dd, &(val)->u.userInputSupportIndication))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputIndication_signal(dd, &(val)->u.signal))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 5:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputIndication_signalUpdate(dd, &(val)->u.signalUpdate))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_UserInputIndication(UserInputIndication *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1ztcharstring_free((val)->u.alphanumeric);
        break;
    case 3:
        ASN1Free_UserInputIndication_userInputSupportIndication(&(val)->u.userInputSupportIndication);
        break;
    case 4:
        ASN1Free_UserInputIndication_signal(&(val)->u.signal);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_nlpid(ASN1encoding_t enc, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_nlpid(ASN1decoding_t dec, DataApplicationCapability_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_nlpid(DataApplicationCapability_application_nlpid *val)
{
    if (val) {
    ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
    ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application_t84(ASN1encoding_t enc, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->t84Protocol))
    return 0;
    if (!ASN1Enc_T84Profile(enc, &(val)->t84Profile))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application_t84(ASN1decoding_t dec, DataApplicationCapability_application_t84 *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->t84Protocol))
    return 0;
    if (!ASN1Dec_T84Profile(dec, &(val)->t84Profile))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application_t84(DataApplicationCapability_application_t84 *val)
{
    if (val) {
    ASN1Free_DataProtocolCapability(&(val)->t84Protocol);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application_nlpid(ASN1encoding_t enc, DataMode_application_nlpid *val)
{
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->nlpidProtocol))
    return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->nlpidData))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application_nlpid(ASN1decoding_t dec, DataMode_application_nlpid *val)
{
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->nlpidProtocol))
    return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->nlpidData))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application_nlpid(DataMode_application_nlpid *val)
{
    if (val) {
    ASN1Free_DataProtocolCapability(&(val)->nlpidProtocol);
    ASN1octetstring_free(&(val)->nlpidData);
    }
}

static int ASN1CALL ASN1Enc_DataMode_application(ASN1encoding_t enc, DataMode_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t84))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_DataMode_application_nlpid(enc, &(val)->u.nlpid))
        return 0;
    break;
    case 9:
    break;
    case 10:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
        return 0;
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode_application(ASN1decoding_t dec, DataMode_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t84))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_DataMode_application_nlpid(dec, &(val)->u.nlpid))
        return 0;
    break;
    case 9:
    break;
    case 10:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
        return 0;
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode_application(DataMode_application *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_DataProtocolCapability(&(val)->u.t120);
        break;
    case 3:
        ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
        break;
    case 4:
        ASN1Free_DataProtocolCapability(&(val)->u.userData);
        break;
    case 5:
        ASN1Free_DataProtocolCapability(&(val)->u.t84);
        break;
    case 6:
        ASN1Free_DataProtocolCapability(&(val)->u.t434);
        break;
    case 7:
        ASN1Free_DataProtocolCapability(&(val)->u.h224);
        break;
    case 8:
        ASN1Free_DataMode_application_nlpid(&(val)->u.nlpid);
        break;
    case 10:
        ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
        break;
    case 11:
        ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
        break;
    case 12:
        ASN1Free_DataProtocolCapability(&(val)->u.t140);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1encoding_t enc, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H2250LogicalChannelAckParameters(enc, &(val)->u.h2250LogicalChannelAckParameters))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(ASN1decoding_t dec, OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 0))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H2250LogicalChannelAckParameters(dec, &(val)->u.h2250LogicalChannelAckParameters))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(OpenLogicalChannelAck_forwardMultiplexAckParameters *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H2250LogicalChannelAckParameters(&(val)->u.h2250LogicalChannelAckParameters);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(ASN1encoding_t enc, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_RTPPayloadType(ee, &(val)->u.rtpPayloadType))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(ASN1decoding_t dec, H2250LogicalChannelParameters_mediaPacketization *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    break;
    case 2:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_RTPPayloadType(dd, &(val)->u.rtpPayloadType))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters_mediaPacketization(H2250LogicalChannelParameters_mediaPacketization *val)
{
    if (val) {
    switch ((val)->choice) {
    case 2:
        ASN1Free_RTPPayloadType(&(val)->u.rtpPayloadType);
        break;
    }
    }
}

static ASN1stringtableentry_t NetworkAccessParameters_networkAddress_e164Address_StringTableEntries[] = {
    { 35, 35, 0 }, { 42, 42, 1 }, { 44, 44, 2 }, 
    { 48, 57, 3 }, 
};

static ASN1stringtable_t NetworkAccessParameters_networkAddress_e164Address_StringTable = {
    4, NetworkAccessParameters_networkAddress_e164Address_StringTableEntries
};

static int ASN1CALL ASN1Enc_NetworkAccessParameters_networkAddress(ASN1encoding_t enc, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t t;
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_Q2931Address(enc, &(val)->u.q2931Address))
        return 0;
    break;
    case 2:
    t = lstrlenA((val)->u.e164Address);
    if (!ASN1PEREncBitVal(enc, 7, t - 1))
        return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncTableCharString(enc, t, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->u.localAreaAddress))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters_networkAddress(ASN1decoding_t dec, NetworkAccessParameters_networkAddress *val)
{
    ASN1uint32_t l;
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_Q2931Address(dec, &(val)->u.q2931Address))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecU32Val(dec, 7, &l))
        return 0;
    l += 1;
    ASN1PERDecAlignment(dec);

    //NikhilB: Fix for the overflow bug 03/02/27
    if ( l >= sizeof((val)->u.e164Address) ) {
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
        return 0; 
    }

    if (!ASN1PERDecZeroTableCharStringNoAlloc(dec, l, (val)->u.e164Address, 4, &NetworkAccessParameters_networkAddress_e164Address_StringTable))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->u.localAreaAddress))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters_networkAddress(NetworkAccessParameters_networkAddress *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_Q2931Address(&(val)->u.q2931Address);
        break;
    case 2:
        break;
    case 3:
        ASN1Free_H245TransportAddress(&(val)->u.localAreaAddress);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability_application(ASN1encoding_t enc, DataApplicationCapability_application *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t120))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.dsm_cc))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.userData))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_DataApplicationCapability_application_t84(enc, &(val)->u.t84))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.t434))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h224))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_DataApplicationCapability_application_nlpid(enc, &(val)->u.nlpid))
        return 0;
    break;
    case 9:
    break;
    case 10:
    if (!ASN1Enc_DataProtocolCapability(enc, &(val)->u.h222DataPartitioning))
        return 0;
    break;
    case 11:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t30fax))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_DataProtocolCapability(ee, &(val)->u.t140))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability_application(ASN1decoding_t dec, DataApplicationCapability_application *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 10))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t120))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.dsm_cc))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.userData))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_DataApplicationCapability_application_t84(dec, &(val)->u.t84))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.t434))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h224))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_DataApplicationCapability_application_nlpid(dec, &(val)->u.nlpid))
        return 0;
    break;
    case 9:
    break;
    case 10:
    if (!ASN1Dec_DataProtocolCapability(dec, &(val)->u.h222DataPartitioning))
        return 0;
    break;
    case 11:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t30fax))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_DataProtocolCapability(dd, &(val)->u.t140))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability_application(DataApplicationCapability_application *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_DataProtocolCapability(&(val)->u.t120);
        break;
    case 3:
        ASN1Free_DataProtocolCapability(&(val)->u.dsm_cc);
        break;
    case 4:
        ASN1Free_DataProtocolCapability(&(val)->u.userData);
        break;
    case 5:
        ASN1Free_DataApplicationCapability_application_t84(&(val)->u.t84);
        break;
    case 6:
        ASN1Free_DataProtocolCapability(&(val)->u.t434);
        break;
    case 7:
        ASN1Free_DataProtocolCapability(&(val)->u.h224);
        break;
    case 8:
        ASN1Free_DataApplicationCapability_application_nlpid(&(val)->u.nlpid);
        break;
    case 10:
        ASN1Free_DataProtocolCapability(&(val)->u.h222DataPartitioning);
        break;
    case 11:
        ASN1Free_DataProtocolCapability(&(val)->u.t30fax);
        break;
    case 12:
        ASN1Free_DataProtocolCapability(&(val)->u.t140);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement(PEnhancementLayerInfo_spatialEnhancement *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val)
{
    if (val) {
    ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Enc_EnhancementOptions(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val)
{
    if (!ASN1Dec_EnhancementOptions(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement(PEnhancementLayerInfo_snrEnhancement *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val)
{
    if (val) {
    ASN1Free_EnhancementOptions(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ASN1encoding_t enc, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_RTPPayloadType(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability_rtpPayloadType(ASN1decoding_t dec, MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_RTPPayloadType(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability_rtpPayloadType(MediaPacketizationCapability_rtpPayloadType *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_RTPPayloadType(&(val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Enc_RedundancyEncodingCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val)
{
    if (!ASN1Dec_RedundancyEncodingCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability(PH2250Capability_redundancyEncodingCapability *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn);
    }
}

static void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val)
{
    if (val) {
    ASN1Free_RedundancyEncodingCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommandMessage(ASN1encoding_t enc, CommandMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MaintenanceLoopOffCommand(enc, &(val)->u.maintenanceLoopOffCommand))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_SendTerminalCapabilitySet(enc, &(val)->u.sendTerminalCapabilitySet))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_EncryptionCommand(enc, &(val)->u.encryptionCommand))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_FlowControlCommand(enc, &(val)->u.flowControlCommand))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_EndSessionCommand(enc, &(val)->u.endSessionCommand))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_MiscellaneousCommand(enc, &(val)->u.miscellaneousCommand))
        return 0;
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_CommunicationModeCommand(ee, &(val)->u.communicationModeCommand))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 9:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceCommand(ee, &(val)->u.conferenceCommand))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 10:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H223MultiplexReconfiguration(ee, &(val)->u.h223MultiplexReconfiguration))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommandMessage(ASN1decoding_t dec, CommandMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 7))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MaintenanceLoopOffCommand(dec, &(val)->u.maintenanceLoopOffCommand))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_SendTerminalCapabilitySet(dec, &(val)->u.sendTerminalCapabilitySet))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_EncryptionCommand(dec, &(val)->u.encryptionCommand))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_FlowControlCommand(dec, &(val)->u.flowControlCommand))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_EndSessionCommand(dec, &(val)->u.endSessionCommand))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_MiscellaneousCommand(dec, &(val)->u.miscellaneousCommand))
        return 0;
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_CommunicationModeCommand(dd, &(val)->u.communicationModeCommand))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 9:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceCommand(dd, &(val)->u.conferenceCommand))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 10:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H223MultiplexReconfiguration(dd, &(val)->u.h223MultiplexReconfiguration))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommandMessage(CommandMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1Free_SendTerminalCapabilitySet(&(val)->u.sendTerminalCapabilitySet);
        break;
    case 4:
        ASN1Free_EncryptionCommand(&(val)->u.encryptionCommand);
        break;
    case 6:
        ASN1Free_EndSessionCommand(&(val)->u.endSessionCommand);
        break;
    case 7:
        ASN1Free_MiscellaneousCommand(&(val)->u.miscellaneousCommand);
        break;
    case 8:
        ASN1Free_CommunicationModeCommand(&(val)->u.communicationModeCommand);
        break;
    case 9:
        ASN1Free_ConferenceCommand(&(val)->u.conferenceCommand);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H235SecurityCapability(ASN1encoding_t enc, H235SecurityCapability *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->mediaCapability - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235SecurityCapability(ASN1decoding_t dec, H235SecurityCapability *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->mediaCapability))
    return 0;
    (val)->mediaCapability += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235SecurityCapability(H235SecurityCapability *val)
{
    if (val) {
    ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    }
}

static int ASN1CALL ASN1Enc_MediaPacketizationCapability(ASN1encoding_t enc, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->h261aVideoPacketization))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1Enc_MediaPacketizationCapability_rtpPayloadType(ee, &(val)->rtpPayloadType))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MediaPacketizationCapability(ASN1decoding_t dec, MediaPacketizationCapability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->h261aVideoPacketization))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_MediaPacketizationCapability_rtpPayloadType(dd, &(val)->rtpPayloadType))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_MediaPacketizationCapability(MediaPacketizationCapability *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_MediaPacketizationCapability_rtpPayloadType(&(val)->rtpPayloadType);
    }
    }
}

static int ASN1CALL ASN1Enc_VideoCapability(ASN1encoding_t enc, VideoCapability *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H261VideoCapability(enc, &(val)->u.h261VideoCapability))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H262VideoCapability(enc, &(val)->u.h262VideoCapability))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_H263VideoCapability(enc, &(val)->u.h263VideoCapability))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_IS11172VideoCapability(enc, &(val)->u.is11172VideoCapability))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_VideoCapability(ASN1decoding_t dec, VideoCapability *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H261VideoCapability(dec, &(val)->u.h261VideoCapability))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H262VideoCapability(dec, &(val)->u.h262VideoCapability))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_H263VideoCapability(dec, &(val)->u.h263VideoCapability))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_IS11172VideoCapability(dec, &(val)->u.is11172VideoCapability))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_VideoCapability(VideoCapability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 4:
        ASN1Free_H263VideoCapability(&(val)->u.h263VideoCapability);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_BEnhancementParameters(ASN1encoding_t enc, BEnhancementParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_EnhancementOptions(enc, &(val)->enhancementOptions))
    return 0;
    if (!ASN1PEREncBitVal(enc, 6, (val)->numberOfBPictures - 1))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_BEnhancementParameters(ASN1decoding_t dec, BEnhancementParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_EnhancementOptions(dec, &(val)->enhancementOptions))
    return 0;
    if (!ASN1PERDecU16Val(dec, 6, &(val)->numberOfBPictures))
    return 0;
    (val)->numberOfBPictures += 1;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_BEnhancementParameters(BEnhancementParameters *val)
{
    if (val) {
    ASN1Free_EnhancementOptions(&(val)->enhancementOptions);
    }
}

static int ASN1CALL ASN1Enc_DataApplicationCapability(ASN1encoding_t enc, DataApplicationCapability *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_DataApplicationCapability_application(enc, &(val)->application))
    return 0;
    l = ASN1uint32_uoctets((val)->maxBitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->maxBitRate))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataApplicationCapability(ASN1decoding_t dec, DataApplicationCapability *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_DataApplicationCapability_application(dec, &(val)->application))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->maxBitRate))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataApplicationCapability(DataApplicationCapability *val)
{
    if (val) {
    ASN1Free_DataApplicationCapability_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_NetworkAccessParameters(ASN1encoding_t enc, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_NetworkAccessParameters_distribution(enc, &(val)->distribution))
        return 0;
    }
    if (!ASN1Enc_NetworkAccessParameters_networkAddress(enc, &(val)->networkAddress))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->associateConference))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncOctetString_VarSize(enc, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_NetworkAccessParameters_t120SetupProcedure(ee, &(val)->t120SetupProcedure))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NetworkAccessParameters(ASN1decoding_t dec, NetworkAccessParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_NetworkAccessParameters_distribution(dec, &(val)->distribution))
        return 0;
    }
    if (!ASN1Dec_NetworkAccessParameters_networkAddress(dec, &(val)->networkAddress))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->associateConference))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecOctetString_VarSize(dec, (ASN1octetstring2_t *) &(val)->externalReference, 1, 255, 8))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_NetworkAccessParameters_t120SetupProcedure(dd, &(val)->t120SetupProcedure))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_NetworkAccessParameters(NetworkAccessParameters *val)
{
    if (val) {
    ASN1Free_NetworkAccessParameters_networkAddress(&(val)->networkAddress);
    if ((val)->o[0] & 0x40) {
    }
    }
}

static int ASN1CALL ASN1Enc_H2250ModeParameters(ASN1encoding_t enc, H2250ModeParameters *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_RedundancyEncodingMode(enc, &(val)->redundancyEncodingMode))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250ModeParameters(ASN1decoding_t dec, H2250ModeParameters *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_RedundancyEncodingMode(dec, &(val)->redundancyEncodingMode))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250ModeParameters(H2250ModeParameters *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_RedundancyEncodingMode(&(val)->redundancyEncodingMode);
    }
    }
}

static int ASN1CALL ASN1Enc_DataMode(ASN1encoding_t enc, DataMode *val)
{
    ASN1uint32_t l;
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_DataMode_application(enc, &(val)->application))
    return 0;
    l = ASN1uint32_uoctets((val)->bitRate);
    if (!ASN1PEREncBitVal(enc, 2, l - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, l * 8, (val)->bitRate))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DataMode(ASN1decoding_t dec, DataMode *val)
{
    ASN1uint32_t y;
    ASN1uint32_t l;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_DataMode_application(dec, &(val)->application))
    return 0;
    if (!ASN1PERDecU32Val(dec, 2, &l))
    return 0;
    l += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, l * 8, &(val)->bitRate))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataMode(DataMode *val)
{
    if (val) {
    ASN1Free_DataMode_application(&(val)->application);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry_dataType(ASN1encoding_t enc, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry_dataType(ASN1decoding_t dec, CommunicationModeTableEntry_dataType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry_dataType(CommunicationModeTableEntry_dataType *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_VideoCapability(&(val)->u.videoData);
        break;
    case 2:
        ASN1Free_AudioCapability(&(val)->u.audioData);
        break;
    case 3:
        ASN1Free_DataApplicationCapability(&(val)->u.data);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H235Mode_mediaMode(ASN1encoding_t enc, H235Mode_mediaMode *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode_mediaMode(ASN1decoding_t dec, H235Mode_mediaMode *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode_mediaMode(H235Mode_mediaMode *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_VideoMode(&(val)->u.videoMode);
        break;
    case 3:
        ASN1Free_AudioMode(&(val)->u.audioMode);
        break;
    case 4:
        ASN1Free_DataMode(&(val)->u.dataMode);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H235Media_mediaType(ASN1encoding_t enc, H235Media_mediaType *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media_mediaType(ASN1decoding_t dec, H235Media_mediaType *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media_mediaType(H235Media_mediaType *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_VideoCapability(&(val)->u.videoData);
        break;
    case 3:
        ASN1Free_AudioCapability(&(val)->u.audioData);
        break;
    case 4:
        ASN1Free_DataApplicationCapability(&(val)->u.data);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn, 1, 14, 4);
}

static int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Enc_BEnhancementParameters(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn, sizeof(**val), 1, 14, 4);
}

static int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (!ASN1Dec_BEnhancementParameters(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement(PEnhancementLayerInfo_bPictureEnhancement *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn);
    }
}

static void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val)
{
    if (val) {
    ASN1Free_BEnhancementParameters(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData(ASN1encoding_t enc, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_distributedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData(ASN1decoding_t dec, PMediaDistributionCapability_distributedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_distributedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData(PMediaDistributionCapability_distributedData *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_distributedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val)
{
    if (val) {
    ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn);
}

static int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Enc_DataApplicationCapability(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val)
{
    if (!ASN1Dec_DataApplicationCapability(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData(PMediaDistributionCapability_centralizedData *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_MediaDistributionCapability_centralizedData_ElmFn);
    }
}

static void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val)
{
    if (val) {
    ASN1Free_DataApplicationCapability(&val->value);
    }
}

static int ASN1CALL ASN1Enc_Capability(ASN1encoding_t enc, Capability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 12))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveVideoCapability))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.transmitVideoCapability))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.receiveAndTransmitVideoCapability))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAudioCapability))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.transmitAudioCapability))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.receiveAndTransmitAudioCapability))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveDataApplicationCapability))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.transmitDataApplicationCapability))
        return 0;
    break;
    case 10:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.receiveAndTransmitDataApplicationCapability))
        return 0;
    break;
    case 11:
    if (!ASN1PEREncBoolean(enc, (val)->u.h233EncryptionTransmitCapability))
        return 0;
    break;
    case 12:
    if (!ASN1Enc_Capability_h233EncryptionReceiveCapability(enc, &(val)->u.h233EncryptionReceiveCapability))
        return 0;
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceCapability(ee, &(val)->u.conferenceCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 14:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H235SecurityCapability(ee, &(val)->u.h235SecurityCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    ASN1PEREncAlignment(ee);
    if (!ASN1PEREncBitVal(ee, 8, (val)->u.maxPendingReplacementFor))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveUserInputCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 17:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputCapability(ee, &(val)->u.transmitUserInputCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 18:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_UserInputCapability(ee, &(val)->u.receiveAndTransmitUserInputCapability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_Capability(ASN1decoding_t dec, Capability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 12))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveVideoCapability))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.transmitVideoCapability))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.receiveAndTransmitVideoCapability))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAudioCapability))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.transmitAudioCapability))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.receiveAndTransmitAudioCapability))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveDataApplicationCapability))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.transmitDataApplicationCapability))
        return 0;
    break;
    case 10:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.receiveAndTransmitDataApplicationCapability))
        return 0;
    break;
    case 11:
    if (!ASN1PERDecBoolean(dec, &(val)->u.h233EncryptionTransmitCapability))
        return 0;
    break;
    case 12:
    if (!ASN1Dec_Capability_h233EncryptionReceiveCapability(dec, &(val)->u.h233EncryptionReceiveCapability))
        return 0;
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceCapability(dd, &(val)->u.conferenceCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 14:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H235SecurityCapability(dd, &(val)->u.h235SecurityCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1PERDecAlignment(dd);
    if (!ASN1PERDecU16Val(dd, 8, &(val)->u.maxPendingReplacementFor))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveUserInputCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 17:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputCapability(dd, &(val)->u.transmitUserInputCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 18:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_UserInputCapability(dd, &(val)->u.receiveAndTransmitUserInputCapability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_Capability(Capability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_VideoCapability(&(val)->u.receiveVideoCapability);
        break;
    case 3:
        ASN1Free_VideoCapability(&(val)->u.transmitVideoCapability);
        break;
    case 4:
        ASN1Free_VideoCapability(&(val)->u.receiveAndTransmitVideoCapability);
        break;
    case 5:
        ASN1Free_AudioCapability(&(val)->u.receiveAudioCapability);
        break;
    case 6:
        ASN1Free_AudioCapability(&(val)->u.transmitAudioCapability);
        break;
    case 7:
        ASN1Free_AudioCapability(&(val)->u.receiveAndTransmitAudioCapability);
        break;
    case 8:
        ASN1Free_DataApplicationCapability(&(val)->u.receiveDataApplicationCapability);
        break;
    case 9:
        ASN1Free_DataApplicationCapability(&(val)->u.transmitDataApplicationCapability);
        break;
    case 10:
        ASN1Free_DataApplicationCapability(&(val)->u.receiveAndTransmitDataApplicationCapability);
        break;
    case 13:
        ASN1Free_ConferenceCapability(&(val)->u.conferenceCapability);
        break;
    case 14:
        ASN1Free_H235SecurityCapability(&(val)->u.h235SecurityCapability);
        break;
    case 16:
        ASN1Free_UserInputCapability(&(val)->u.receiveUserInputCapability);
        break;
    case 17:
        ASN1Free_UserInputCapability(&(val)->u.transmitUserInputCapability);
        break;
    case 18:
        ASN1Free_UserInputCapability(&(val)->u.receiveAndTransmitUserInputCapability);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_H2250Capability(ASN1encoding_t enc, H2250Capability *val)
{
    ASN1octet_t o[1];
    ASN1uint32_t y;
    ASN1encoding_t ee;
    CopyMemory(o, (val)->o, 1);
    o[0] |= 0x20;
    o[0] |= 0x10;
    y = ASN1PEREncCheckExtensions(4, (val)->o + 0);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->maximumAudioDelayJitter))
    return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveMultipointCapability))
    return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->transmitMultipointCapability))
    return 0;
    if (!ASN1Enc_MultipointCapability(enc, &(val)->receiveAndTransmitMultipointCapability))
    return 0;
    if (!ASN1Enc_H2250Capability_mcCapability(enc, &(val)->mcCapability))
    return 0;
    if (!ASN1PEREncBoolean(enc, (val)->rtcpVideoControlCapability))
    return 0;
    if (!ASN1Enc_MediaPacketizationCapability(enc, &(val)->mediaPacketizationCapability))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 4, o + 0))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (o[0] & 0x80) {
        if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x40) {
        if (!ASN1Enc_H2250Capability_redundancyEncodingCapability(ee, &(val)->redundancyEncodingCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x20) {
        if (!ASN1PEREncBoolean(ee, (val)->logicalChannelSwitchingCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if (o[0] & 0x10) {
        if (!ASN1PEREncBoolean(ee, (val)->t120DynamicPortCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250Capability(ASN1decoding_t dec, H2250Capability *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->maximumAudioDelayJitter))
    return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveMultipointCapability))
    return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->transmitMultipointCapability))
    return 0;
    if (!ASN1Dec_MultipointCapability(dec, &(val)->receiveAndTransmitMultipointCapability))
    return 0;
    if (!ASN1Dec_H2250Capability_mcCapability(dec, &(val)->mcCapability))
    return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->rtcpVideoControlCapability))
    return 0;
    if (!ASN1Dec_MediaPacketizationCapability(dec, &(val)->mediaPacketizationCapability))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 0, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 4, (val)->o + 0))
        return 0;
    if ((val)->o[0] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H2250Capability_redundancyEncodingCapability(dd, &(val)->redundancyEncodingCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->logicalChannelSwitchingCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[0] & 0x10) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecBoolean(dd, &(val)->t120DynamicPortCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250Capability(H2250Capability *val)
{
    if (val) {
    ASN1Free_MultipointCapability(&(val)->receiveMultipointCapability);
    ASN1Free_MultipointCapability(&(val)->transmitMultipointCapability);
    ASN1Free_MultipointCapability(&(val)->receiveAndTransmitMultipointCapability);
    ASN1Free_MediaPacketizationCapability(&(val)->mediaPacketizationCapability);
    if ((val)->o[0] & 0x80) {
        ASN1Free_TransportCapability(&(val)->transportCapability);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_H2250Capability_redundancyEncodingCapability(&(val)->redundancyEncodingCapability);
    }
    }
}

static int ASN1CALL ASN1Enc_H235Media(ASN1encoding_t enc, H235Media *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1Enc_H235Media_mediaType(enc, &(val)->mediaType))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Media(ASN1decoding_t dec, H235Media *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1Dec_H235Media_mediaType(dec, &(val)->mediaType))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Media(H235Media *val)
{
    if (val) {
    ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    ASN1Free_H235Media_mediaType(&(val)->mediaType);
    }
}

static int ASN1CALL ASN1Enc_H235Mode(ASN1encoding_t enc, H235Mode *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1Enc_EncryptionAuthenticationAndIntegrity(enc, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1Enc_H235Mode_mediaMode(enc, &(val)->mediaMode))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H235Mode(ASN1decoding_t dec, H235Mode *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1Dec_EncryptionAuthenticationAndIntegrity(dec, &(val)->encryptionAuthenticationAndIntegrity))
    return 0;
    if (!ASN1Dec_H235Mode_mediaMode(dec, &(val)->mediaMode))
    return 0;
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_H235Mode(H235Mode *val)
{
    if (val) {
    ASN1Free_EncryptionAuthenticationAndIntegrity(&(val)->encryptionAuthenticationAndIntegrity);
    ASN1Free_H235Mode_mediaMode(&(val)->mediaMode);
    }
}

static int ASN1CALL ASN1Enc_ModeElement_type(ASN1encoding_t enc, ModeElement_type *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 5))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_VideoMode(enc, &(val)->u.videoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_AudioMode(enc, &(val)->u.audioMode))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_DataMode(enc, &(val)->u.dataMode))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionMode))
        return 0;
    break;
    case 6:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H235Mode(ee, &(val)->u.h235Mode))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement_type(ASN1decoding_t dec, ModeElement_type *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 5))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_VideoMode(dec, &(val)->u.videoMode))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_AudioMode(dec, &(val)->u.audioMode))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_DataMode(dec, &(val)->u.dataMode))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionMode))
        return 0;
    break;
    case 6:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H235Mode(dd, &(val)->u.h235Mode))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement_type(ModeElement_type *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_VideoMode(&(val)->u.videoMode);
        break;
    case 3:
        ASN1Free_AudioMode(&(val)->u.audioMode);
        break;
    case 4:
        ASN1Free_DataMode(&(val)->u.dataMode);
        break;
    case 5:
        ASN1Free_EncryptionMode(&(val)->u.encryptionMode);
        break;
    case 6:
        ASN1Free_H235Mode(&(val)->u.h235Mode);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_CapabilityTableEntry(ASN1encoding_t enc, CapabilityTableEntry *val)
{
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->capabilityTableEntryNumber - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_Capability(enc, &(val)->capability))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CapabilityTableEntry(ASN1decoding_t dec, CapabilityTableEntry *val)
{
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->capabilityTableEntryNumber))
    return 0;
    (val)->capabilityTableEntryNumber += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_Capability(dec, &(val)->capability))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CapabilityTableEntry(CapabilityTableEntry *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_Capability(&(val)->capability);
    }
    }
}

static int ASN1CALL ASN1Enc_MultiplexCapability(ASN1encoding_t enc, MultiplexCapability *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 4))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H222Capability(enc, &(val)->u.h222Capability))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_H223Capability(enc, &(val)->u.h223Capability))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_V76Capability(enc, &(val)->u.v76Capability))
        return 0;
    break;
    case 5:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H2250Capability(ee, &(val)->u.h2250Capability))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultiplexCapability(ASN1decoding_t dec, MultiplexCapability *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 4))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H222Capability(dec, &(val)->u.h222Capability))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_H223Capability(dec, &(val)->u.h223Capability))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_V76Capability(dec, &(val)->u.v76Capability))
        return 0;
    break;
    case 5:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H2250Capability(dd, &(val)->u.h2250Capability))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultiplexCapability(MultiplexCapability *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_H222Capability(&(val)->u.h222Capability);
        break;
    case 5:
        ASN1Free_H2250Capability(&(val)->u.h2250Capability);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_DataType(ASN1encoding_t enc, DataType *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardParameter(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Enc_VideoCapability(enc, &(val)->u.videoData))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_AudioCapability(enc, &(val)->u.audioData))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_DataApplicationCapability(enc, &(val)->u.data))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_EncryptionMode(enc, &(val)->u.encryptionData))
        return 0;
    break;
    case 7:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_NonStandardParameter(ee, &(val)->u.h235Control))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 8:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H235Media(ee, &(val)->u.h235Media))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DataType(ASN1decoding_t dec, DataType *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 3, 6))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardParameter(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    break;
    case 3:
    if (!ASN1Dec_VideoCapability(dec, &(val)->u.videoData))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_AudioCapability(dec, &(val)->u.audioData))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_DataApplicationCapability(dec, &(val)->u.data))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_EncryptionMode(dec, &(val)->u.encryptionData))
        return 0;
    break;
    case 7:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_NonStandardParameter(dd, &(val)->u.h235Control))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 8:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H235Media(dd, &(val)->u.h235Media))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DataType(DataType *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardParameter(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1Free_VideoCapability(&(val)->u.videoData);
        break;
    case 4:
        ASN1Free_AudioCapability(&(val)->u.audioData);
        break;
    case 5:
        ASN1Free_DataApplicationCapability(&(val)->u.data);
        break;
    case 6:
        ASN1Free_EncryptionMode(&(val)->u.encryptionData);
        break;
    case 7:
        ASN1Free_NonStandardParameter(&(val)->u.h235Control);
        break;
    case 8:
        ASN1Free_H235Media(&(val)->u.h235Media);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_RedundancyEncoding(ASN1encoding_t enc, RedundancyEncoding *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_RedundancyEncodingMethod(enc, &(val)->redundancyEncodingMethod))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_DataType(enc, &(val)->secondaryEncoding))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RedundancyEncoding(ASN1decoding_t dec, RedundancyEncoding *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_RedundancyEncodingMethod(dec, &(val)->redundancyEncodingMethod))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_DataType(dec, &(val)->secondaryEncoding))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RedundancyEncoding(RedundancyEncoding *val)
{
    if (val) {
    ASN1Free_RedundancyEncodingMethod(&(val)->redundancyEncodingMethod);
    if ((val)->o[0] & 0x80) {
        ASN1Free_DataType(&(val)->secondaryEncoding);
    }
    }
}

static int ASN1CALL ASN1Enc_ModeElement(ASN1encoding_t enc, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_ModeElement_type(enc, &(val)->type))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H223ModeParameters(enc, &(val)->h223ModeParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_V76ModeParameters(ee, &(val)->v76ModeParameters))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_H2250ModeParameters(ee, &(val)->h2250ModeParameters))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeElement(ASN1decoding_t dec, ModeElement *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_ModeElement_type(dec, &(val)->type))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H223ModeParameters(dec, &(val)->h223ModeParameters))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_V76ModeParameters(dd, &(val)->v76ModeParameters))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_H2250ModeParameters(dd, &(val)->h2250ModeParameters))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeElement(ModeElement *val)
{
    if (val) {
    ASN1Free_ModeElement_type(&(val)->type);
    if ((val)->o[0] & 0x80) {
        ASN1Free_H223ModeParameters(&(val)->h223ModeParameters);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H2250ModeParameters(&(val)->h2250ModeParameters);
    }
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeTableEntry(ASN1encoding_t enc, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_CommunicationModeTableEntry_nonStandard(enc, &(val)->nonStandard))
        return 0;
    }
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID - 1))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_TerminalLabel(enc, &(val)->terminalLabel))
        return 0;
    }
    if (!ASN1PEREncBitVal(enc, 7, ((val)->sessionDescription).length - 1))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncChar16String(enc, ((val)->sessionDescription).length, ((val)->sessionDescription).value, 16))
    return 0;
    if (!ASN1Enc_CommunicationModeTableEntry_dataType(enc, &(val)->dataType))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PEREncBitVal(ee, 8, (val)->sessionDependency - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_TerminalLabel(ee, &(val)->destination))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeTableEntry(ASN1decoding_t dec, CommunicationModeTableEntry *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_CommunicationModeTableEntry_nonStandard(dec, &(val)->nonStandard))
        return 0;
    }
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
    return 0;
    (val)->sessionID += 1;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
        return 0;
    (val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_TerminalLabel(dec, &(val)->terminalLabel))
        return 0;
    }
    if (!ASN1PERDecU32Val(dec, 7, &((val)->sessionDescription).length))
    return 0;
    ((val)->sessionDescription).length += 1;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecChar16String(dec, ((val)->sessionDescription).length, &((val)->sessionDescription).value, 16))
    return 0;
    if (!ASN1Dec_CommunicationModeTableEntry_dataType(dec, &(val)->dataType))
    return 0;
    if ((val)->o[0] & 0x10) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecU16Val(dd, 8, &(val)->sessionDependency))
        return 0;
        (val)->sessionDependency += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TerminalLabel(dd, &(val)->destination))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeTableEntry(CommunicationModeTableEntry *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_CommunicationModeTableEntry_nonStandard(&(val)->nonStandard);
    }
    ASN1char16string_free(&(val)->sessionDescription);
    ASN1Free_CommunicationModeTableEntry_dataType(&(val)->dataType);
    if ((val)->o[0] & 0x10) {
        ASN1Free_H245TransportAddress(&(val)->mediaChannel);
    }
    if ((val)->o[0] & 0x4) {
        ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
    }
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable(PCommunicationModeResponse_communicationModeTable *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val)
{
    if (val) {
    ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Enc_CommunicationModeTableEntry(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val)
{
    if (!ASN1Dec_CommunicationModeTableEntry(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable(PCommunicationModeCommand_communicationModeTable *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val)
{
    if (val) {
    ASN1Free_CommunicationModeTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Enc_CapabilityTableEntry(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val)
{
    if (!ASN1Dec_CapabilityTableEntry(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable(PTerminalCapabilitySet_capabilityTable *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn);
    }
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val)
{
    if (val) {
    ASN1Free_CapabilityTableEntry(&val->value);
    }
}

static int ASN1CALL ASN1Enc_TerminalCapabilitySet(ASN1encoding_t enc, TerminalCapabilitySet *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
    return 0;
    if (!ASN1PEREncBits(enc, 3, (val)->o))
    return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sequenceNumber))
    return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_MultiplexCapability(enc, &(val)->multiplexCapability))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_TerminalCapabilitySet_capabilityTable(enc, &(val)->capabilityTable))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_TerminalCapabilitySet_capabilityDescriptors(enc, &(val)->capabilityDescriptors))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_TerminalCapabilitySet(ASN1decoding_t dec, TerminalCapabilitySet *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 3, (val)->o))
    return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sequenceNumber))
    return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_MultiplexCapability(dec, &(val)->multiplexCapability))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_TerminalCapabilitySet_capabilityTable(dec, &(val)->capabilityTable))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_TerminalCapabilitySet_capabilityDescriptors(dec, &(val)->capabilityDescriptors))
        return 0;
    }
    if (y) {
    if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_TerminalCapabilitySet(TerminalCapabilitySet *val)
{
    if (val) {
    ASN1objectidentifier_free(&(val)->protocolIdentifier);
    if ((val)->o[0] & 0x80) {
        ASN1Free_MultiplexCapability(&(val)->multiplexCapability);
    }
    if ((val)->o[0] & 0x40) {
        ASN1Free_TerminalCapabilitySet_capabilityTable(&(val)->capabilityTable);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_TerminalCapabilitySet_capabilityDescriptors(&(val)->capabilityDescriptors);
    }
    }
}

static int ASN1CALL ASN1Enc_H2250LogicalChannelParameters(ASN1encoding_t enc, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 2);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 10, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_H2250LogicalChannelParameters_nonStandard(enc, &(val)->nonStandard))
        return 0;
    }
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->sessionID))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PEREncBitVal(enc, 8, (val)->associatedSessionID - 1))
        return 0;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaChannel))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PEREncBoolean(enc, (val)->mediaGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Enc_H245TransportAddress(enc, &(val)->mediaControlChannel))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PEREncBoolean(enc, (val)->mediaControlGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PEREncBoolean(enc, (val)->silenceSuppression))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1Enc_TerminalLabel(enc, &(val)->destination))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1PEREncBitVal(enc, 5, (val)->dynamicRTPPayloadType - 96))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1Enc_H2250LogicalChannelParameters_mediaPacketization(enc, &(val)->mediaPacketization))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 2))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[2] & 0x80) {
        if (!ASN1Enc_TransportCapability(ee, &(val)->transportCapability))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[2] & 0x40) {
        if (!ASN1Enc_RedundancyEncoding(ee, &(val)->redundancyEncoding))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[2] & 0x20) {
        if (!ASN1Enc_TerminalLabel(ee, &(val)->source))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_H2250LogicalChannelParameters(ASN1decoding_t dec, H2250LogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 10, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_H2250LogicalChannelParameters_nonStandard(dec, &(val)->nonStandard))
        return 0;
    }
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->sessionID))
    return 0;
    if ((val)->o[0] & 0x40) {
    if (!ASN1PERDecU16Val(dec, 8, &(val)->associatedSessionID))
        return 0;
    (val)->associatedSessionID += 1;
    }
    if ((val)->o[0] & 0x20) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaChannel))
        return 0;
    }
    if ((val)->o[0] & 0x10) {
    if (!ASN1PERDecBoolean(dec, &(val)->mediaGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x8) {
    if (!ASN1Dec_H245TransportAddress(dec, &(val)->mediaControlChannel))
        return 0;
    }
    if ((val)->o[0] & 0x4) {
    if (!ASN1PERDecBoolean(dec, &(val)->mediaControlGuaranteedDelivery))
        return 0;
    }
    if ((val)->o[0] & 0x2) {
    if (!ASN1PERDecBoolean(dec, &(val)->silenceSuppression))
        return 0;
    }
    if ((val)->o[0] & 0x1) {
    if (!ASN1Dec_TerminalLabel(dec, &(val)->destination))
        return 0;
    }
    if ((val)->o[1] & 0x80) {
    if (!ASN1PERDecU16Val(dec, 5, &(val)->dynamicRTPPayloadType))
        return 0;
    (val)->dynamicRTPPayloadType += 96;
    }
    if ((val)->o[1] & 0x40) {
    if (!ASN1Dec_H2250LogicalChannelParameters_mediaPacketization(dec, &(val)->mediaPacketization))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 2, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 2))
        return 0;
    if ((val)->o[2] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TransportCapability(dd, &(val)->transportCapability))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_RedundancyEncoding(dd, &(val)->redundancyEncoding))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[2] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_TerminalLabel(dd, &(val)->source))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_H2250LogicalChannelParameters(H2250LogicalChannelParameters *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_H2250LogicalChannelParameters_nonStandard(&(val)->nonStandard);
    }
    if ((val)->o[0] & 0x20) {
        ASN1Free_H245TransportAddress(&(val)->mediaChannel);
    }
    if ((val)->o[0] & 0x8) {
        ASN1Free_H245TransportAddress(&(val)->mediaControlChannel);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_H2250LogicalChannelParameters_mediaPacketization(&(val)->mediaPacketization);
    }
    if ((val)->o[2] & 0x80) {
        ASN1Free_TransportCapability(&(val)->transportCapability);
    }
    if ((val)->o[2] & 0x40) {
        ASN1Free_RedundancyEncoding(&(val)->redundancyEncoding);
    }
    }
}

static int ASN1CALL ASN1Enc_ModeDescription(ASN1encoding_t enc, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->count - 1))
    return 0;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Enc_ModeElement(enc, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ModeDescription(ASN1decoding_t dec, ModeDescription *val)
{
    ASN1uint32_t i;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU32Val(dec, 8, &(val)->count))
    return 0;
    (val)->count += 1;
    for (i = 0; i < (val)->count; i++) {
    if (!ASN1Dec_ModeElement(dec, &((val)->value)[i]))
        return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ModeDescription(ModeDescription *val)
{
    ASN1uint32_t i;
    if (val) {
    for (i = 0; i < (val)->count; i++) {
        ASN1Free_ModeElement(&(val)->value[i]);
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 2, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
        return 0;
    break;
    case 4:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 5:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 2, 3))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
        return 0;
    break;
    case 4:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 5:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
        break;
    case 2:
        ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
        break;
    case 4:
        ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H223LogicalChannelParameters(enc, &(val)->u.h223LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_V76LogicalChannelParameters(enc, &(val)->u.v76LogicalChannelParameters))
        return 0;
    break;
    case 3:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 1, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H223LogicalChannelParameters(dec, &(val)->u.h223LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_V76LogicalChannelParameters(dec, &(val)->u.v76LogicalChannelParameters))
        return 0;
    break;
    case 3:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H223LogicalChannelParameters(&(val)->u.h223LogicalChannelParameters);
        break;
    case 3:
        ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 0, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_H222LogicalChannelParameters(enc, &(val)->u.h222LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H2250LogicalChannelParameters(ee, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 0, 1))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_H222LogicalChannelParameters(dec, &(val)->u.h222LogicalChannelParameters))
        return 0;
    break;
    case 2:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H2250LogicalChannelParameters(dd, &(val)->u.h2250LogicalChannelParameters))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_H222LogicalChannelParameters(&(val)->u.h222LogicalChannelParameters);
        break;
    case 2:
        ASN1Free_H2250LogicalChannelParameters(&(val)->u.h2250LogicalChannelParameters);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes(ASN1encoding_t enc, PRequestMode_requestedModes *val)
{
    return ASN1PEREncSeqOf_VarSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_RequestMode_requestedModes_ElmFn, 1, 256, 8);
}

static int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val)
{
    if (!ASN1Enc_ModeDescription(enc, &val->value))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes(ASN1decoding_t dec, PRequestMode_requestedModes *val)
{
    return ASN1PERDecSeqOf_VarSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_RequestMode_requestedModes_ElmFn, sizeof(**val), 1, 256, 8);
}

static int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val)
{
    if (!ASN1Dec_ModeDescription(dec, &val->value))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes(PRequestMode_requestedModes *val)
{
    if (val) {
    ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_RequestMode_requestedModes_ElmFn);
    }
}

static void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val)
{
    if (val) {
    ASN1Free_ModeDescription(&val->value);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(1, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 2, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->reverseLogicalChannelNumber - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 1, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 2, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->reverseLogicalChannelNumber))
    return 0;
    (val)->reverseLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
        return 0;
    }
    if ((val)->o[0] & 0x40) {
    if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 1, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
        return 0;
        (val)->replacementFor += 1;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(OpenLogicalChannelAck_reverseLogicalChannelParameters *val)
{
    if (val) {
    if ((val)->o[0] & 0x40) {
        ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->reverseLogicalChannelDependency - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->reverseLogicalChannelDependency))
        return 0;
        (val)->reverseLogicalChannelDependency += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
        return 0;
        (val)->replacementFor += 1;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(OpenLogicalChannel_reverseLogicalChannelParameters *val)
{
    if (val) {
    ASN1Free_DataType(&(val)->dataType);
    if ((val)->o[0] & 0x80) {
        ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1encoding_t enc, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PEREncUnsignedShort(enc, (val)->portNumber))
        return 0;
    }
    if (!ASN1Enc_DataType(enc, &(val)->dataType))
    return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(enc, &(val)->multiplexParameters))
    return 0;
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->forwardLogicalChannelDependency - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PEREncUnsignedShort(ee, (val)->replacementFor - 1))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(ASN1decoding_t dec, OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1PERDecUnsignedShort(dec, &(val)->portNumber))
        return 0;
    }
    if (!ASN1Dec_DataType(dec, &(val)->dataType))
    return 0;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(dec, &(val)->multiplexParameters))
    return 0;
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->forwardLogicalChannelDependency))
        return 0;
        (val)->forwardLogicalChannelDependency += 1;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1PERDecUnsignedShort(dd, &(val)->replacementFor))
        return 0;
        (val)->replacementFor += 1;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(OpenLogicalChannel_forwardLogicalChannelParameters *val)
{
    if (val) {
    ASN1Free_DataType(&(val)->dataType);
    ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(&(val)->multiplexParameters);
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannel(ASN1encoding_t enc, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(2, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if (!ASN1Enc_OpenLogicalChannel_forwardLogicalChannelParameters(enc, &(val)->forwardLogicalChannelParameters))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_OpenLogicalChannel_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 2, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannel(ASN1decoding_t dec, OpenLogicalChannel *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if (!ASN1Dec_OpenLogicalChannel_forwardLogicalChannelParameters(dec, &(val)->forwardLogicalChannelParameters))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_OpenLogicalChannel_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 2, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannel(OpenLogicalChannel *val)
{
    if (val) {
    ASN1Free_OpenLogicalChannel_forwardLogicalChannelParameters(&(val)->forwardLogicalChannelParameters);
    if ((val)->o[0] & 0x80) {
        ASN1Free_OpenLogicalChannel_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_NetworkAccessParameters(&(val)->separateStack);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_EncryptionSync(&(val)->encryptionSync);
    }
    }
}

static int ASN1CALL ASN1Enc_OpenLogicalChannelAck(ASN1encoding_t enc, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1encoding_t ee;
    y = ASN1PEREncCheckExtensions(3, (val)->o + 1);
    if (!ASN1PEREncBitVal(enc, 1, y))
    return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
    return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->forwardLogicalChannelNumber - 1))
    return 0;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Enc_OpenLogicalChannelAck_reverseLogicalChannelParameters(enc, &(val)->reverseLogicalChannelParameters))
        return 0;
    }
    if (y) {
    if (!ASN1PEREncNormallySmallBits(enc, 3, (val)->o + 1))
        return 0;
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1Enc_NetworkAccessParameters(ee, &(val)->separateStack))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1Enc_OpenLogicalChannelAck_forwardMultiplexAckParameters(ee, &(val)->forwardMultiplexAckParameters))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1Enc_EncryptionSync(ee, &(val)->encryptionSync))
        return 0;
        if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    }
    ASN1_CloseEncoder2(ee);
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OpenLogicalChannelAck(ASN1decoding_t dec, OpenLogicalChannelAck *val)
{
    ASN1uint32_t y;
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    ASN1uint32_t i;
    ASN1uint32_t e;
    if (!ASN1PERDecExtensionBit(dec, &y))
    return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
    return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->forwardLogicalChannelNumber))
    return 0;
    (val)->forwardLogicalChannelNumber += 1;
    if ((val)->o[0] & 0x80) {
    if (!ASN1Dec_OpenLogicalChannelAck_reverseLogicalChannelParameters(dec, &(val)->reverseLogicalChannelParameters))
        return 0;
    }
    if (!y) {
    ZeroMemory((val)->o + 1, 1);
    } else {
    if (!ASN1PERDecNormallySmallExtension(dec, &e, 3, (val)->o + 1))
        return 0;
    if ((val)->o[1] & 0x80) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_NetworkAccessParameters(dd, &(val)->separateStack))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x40) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_OpenLogicalChannelAck_forwardMultiplexAckParameters(dd, &(val)->forwardMultiplexAckParameters))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    if ((val)->o[1] & 0x20) {
        if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
        if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
        if (!ASN1Dec_EncryptionSync(dd, &(val)->encryptionSync))
        return 0;
        ASN1_CloseDecoder(dd);
    }
    for (i = 0; i < e; i++) {
        if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    }
    }
    return 1;
}

static void ASN1CALL ASN1Free_OpenLogicalChannelAck(OpenLogicalChannelAck *val)
{
    if (val) {
    if ((val)->o[0] & 0x80) {
        ASN1Free_OpenLogicalChannelAck_reverseLogicalChannelParameters(&(val)->reverseLogicalChannelParameters);
    }
    if ((val)->o[1] & 0x80) {
        ASN1Free_NetworkAccessParameters(&(val)->separateStack);
    }
    if ((val)->o[1] & 0x40) {
        ASN1Free_OpenLogicalChannelAck_forwardMultiplexAckParameters(&(val)->forwardMultiplexAckParameters);
    }
    if ((val)->o[1] & 0x20) {
        ASN1Free_EncryptionSync(&(val)->encryptionSync);
    }
    }
}

static int ASN1CALL ASN1Enc_RequestMessage(ASN1encoding_t enc, RequestMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 11))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MasterSlaveDetermination(enc, &(val)->u.masterSlaveDetermination))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_TerminalCapabilitySet(enc, &(val)->u.terminalCapabilitySet))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_OpenLogicalChannel(enc, &(val)->u.openLogicalChannel))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_CloseLogicalChannel(enc, &(val)->u.closeLogicalChannel))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_RequestChannelClose(enc, &(val)->u.requestChannelClose))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_MultiplexEntrySend(enc, &(val)->u.multiplexEntrySend))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_RequestMultiplexEntry(enc, &(val)->u.requestMultiplexEntry))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_RequestMode(enc, &(val)->u.requestMode))
        return 0;
    break;
    case 10:
    if (!ASN1Enc_RoundTripDelayRequest(enc, &(val)->u.roundTripDelayRequest))
        return 0;
    break;
    case 11:
    if (!ASN1Enc_MaintenanceLoopRequest(enc, &(val)->u.maintenanceLoopRequest))
        return 0;
    break;
    case 12:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_CommunicationModeRequest(ee, &(val)->u.communicationModeRequest))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 13:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceRequest(ee, &(val)->u.conferenceRequest))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RequestMessage(ASN1decoding_t dec, RequestMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 11))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MasterSlaveDetermination(dec, &(val)->u.masterSlaveDetermination))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_TerminalCapabilitySet(dec, &(val)->u.terminalCapabilitySet))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_OpenLogicalChannel(dec, &(val)->u.openLogicalChannel))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_CloseLogicalChannel(dec, &(val)->u.closeLogicalChannel))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_RequestChannelClose(dec, &(val)->u.requestChannelClose))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_MultiplexEntrySend(dec, &(val)->u.multiplexEntrySend))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_RequestMultiplexEntry(dec, &(val)->u.requestMultiplexEntry))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_RequestMode(dec, &(val)->u.requestMode))
        return 0;
    break;
    case 10:
    if (!ASN1Dec_RoundTripDelayRequest(dec, &(val)->u.roundTripDelayRequest))
        return 0;
    break;
    case 11:
    if (!ASN1Dec_MaintenanceLoopRequest(dec, &(val)->u.maintenanceLoopRequest))
        return 0;
    break;
    case 12:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_CommunicationModeRequest(dd, &(val)->u.communicationModeRequest))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 13:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceRequest(dd, &(val)->u.conferenceRequest))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RequestMessage(RequestMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
        break;
    case 3:
        ASN1Free_TerminalCapabilitySet(&(val)->u.terminalCapabilitySet);
        break;
    case 4:
        ASN1Free_OpenLogicalChannel(&(val)->u.openLogicalChannel);
        break;
    case 6:
        ASN1Free_RequestChannelClose(&(val)->u.requestChannelClose);
        break;
    case 7:
        ASN1Free_MultiplexEntrySend(&(val)->u.multiplexEntrySend);
        break;
    case 8:
        ASN1Free_RequestMultiplexEntry(&(val)->u.requestMultiplexEntry);
        break;
    case 9:
        ASN1Free_RequestMode(&(val)->u.requestMode);
        break;
    case 13:
        ASN1Free_ConferenceRequest(&(val)->u.conferenceRequest);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_ResponseMessage(ASN1encoding_t enc, ResponseMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 5, 19))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_MasterSlaveDeterminationAck(enc, &(val)->u.masterSlaveDeterminationAck))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_MasterSlaveDeterminationReject(enc, &(val)->u.masterSlaveDeterminationReject))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_TerminalCapabilitySetAck(enc, &(val)->u.terminalCapabilitySetAck))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_TerminalCapabilitySetReject(enc, &(val)->u.terminalCapabilitySetReject))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_OpenLogicalChannelAck(enc, &(val)->u.openLogicalChannelAck))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_OpenLogicalChannelReject(enc, &(val)->u.openLogicalChannelReject))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_CloseLogicalChannelAck(enc, &(val)->u.closeLogicalChannelAck))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_RequestChannelCloseAck(enc, &(val)->u.requestChannelCloseAck))
        return 0;
    break;
    case 10:
    if (!ASN1Enc_RequestChannelCloseReject(enc, &(val)->u.requestChannelCloseReject))
        return 0;
    break;
    case 11:
    if (!ASN1Enc_MultiplexEntrySendAck(enc, &(val)->u.multiplexEntrySendAck))
        return 0;
    break;
    case 12:
    if (!ASN1Enc_MultiplexEntrySendReject(enc, &(val)->u.multiplexEntrySendReject))
        return 0;
    break;
    case 13:
    if (!ASN1Enc_RequestMultiplexEntryAck(enc, &(val)->u.requestMultiplexEntryAck))
        return 0;
    break;
    case 14:
    if (!ASN1Enc_RequestMultiplexEntryReject(enc, &(val)->u.requestMultiplexEntryReject))
        return 0;
    break;
    case 15:
    if (!ASN1Enc_RequestModeAck(enc, &(val)->u.requestModeAck))
        return 0;
    break;
    case 16:
    if (!ASN1Enc_RequestModeReject(enc, &(val)->u.requestModeReject))
        return 0;
    break;
    case 17:
    if (!ASN1Enc_RoundTripDelayResponse(enc, &(val)->u.roundTripDelayResponse))
        return 0;
    break;
    case 18:
    if (!ASN1Enc_MaintenanceLoopAck(enc, &(val)->u.maintenanceLoopAck))
        return 0;
    break;
    case 19:
    if (!ASN1Enc_MaintenanceLoopReject(enc, &(val)->u.maintenanceLoopReject))
        return 0;
    break;
    case 20:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_CommunicationModeResponse(ee, &(val)->u.communicationModeResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 21:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceResponse(ee, &(val)->u.conferenceResponse))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ResponseMessage(ASN1decoding_t dec, ResponseMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 5, 19))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_MasterSlaveDeterminationAck(dec, &(val)->u.masterSlaveDeterminationAck))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_MasterSlaveDeterminationReject(dec, &(val)->u.masterSlaveDeterminationReject))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_TerminalCapabilitySetAck(dec, &(val)->u.terminalCapabilitySetAck))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_TerminalCapabilitySetReject(dec, &(val)->u.terminalCapabilitySetReject))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_OpenLogicalChannelAck(dec, &(val)->u.openLogicalChannelAck))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_OpenLogicalChannelReject(dec, &(val)->u.openLogicalChannelReject))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_CloseLogicalChannelAck(dec, &(val)->u.closeLogicalChannelAck))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_RequestChannelCloseAck(dec, &(val)->u.requestChannelCloseAck))
        return 0;
    break;
    case 10:
    if (!ASN1Dec_RequestChannelCloseReject(dec, &(val)->u.requestChannelCloseReject))
        return 0;
    break;
    case 11:
    if (!ASN1Dec_MultiplexEntrySendAck(dec, &(val)->u.multiplexEntrySendAck))
        return 0;
    break;
    case 12:
    if (!ASN1Dec_MultiplexEntrySendReject(dec, &(val)->u.multiplexEntrySendReject))
        return 0;
    break;
    case 13:
    if (!ASN1Dec_RequestMultiplexEntryAck(dec, &(val)->u.requestMultiplexEntryAck))
        return 0;
    break;
    case 14:
    if (!ASN1Dec_RequestMultiplexEntryReject(dec, &(val)->u.requestMultiplexEntryReject))
        return 0;
    break;
    case 15:
    if (!ASN1Dec_RequestModeAck(dec, &(val)->u.requestModeAck))
        return 0;
    break;
    case 16:
    if (!ASN1Dec_RequestModeReject(dec, &(val)->u.requestModeReject))
        return 0;
    break;
    case 17:
    if (!ASN1Dec_RoundTripDelayResponse(dec, &(val)->u.roundTripDelayResponse))
        return 0;
    break;
    case 18:
    if (!ASN1Dec_MaintenanceLoopAck(dec, &(val)->u.maintenanceLoopAck))
        return 0;
    break;
    case 19:
    if (!ASN1Dec_MaintenanceLoopReject(dec, &(val)->u.maintenanceLoopReject))
        return 0;
    break;
    case 20:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_CommunicationModeResponse(dd, &(val)->u.communicationModeResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 21:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceResponse(dd, &(val)->u.conferenceResponse))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ResponseMessage(ResponseMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
        break;
    case 6:
        ASN1Free_OpenLogicalChannelAck(&(val)->u.openLogicalChannelAck);
        break;
    case 11:
        ASN1Free_MultiplexEntrySendAck(&(val)->u.multiplexEntrySendAck);
        break;
    case 12:
        ASN1Free_MultiplexEntrySendReject(&(val)->u.multiplexEntrySendReject);
        break;
    case 13:
        ASN1Free_RequestMultiplexEntryAck(&(val)->u.requestMultiplexEntryAck);
        break;
    case 14:
        ASN1Free_RequestMultiplexEntryReject(&(val)->u.requestMultiplexEntryReject);
        break;
    case 20:
        ASN1Free_CommunicationModeResponse(&(val)->u.communicationModeResponse);
        break;
    case 21:
        ASN1Free_ConferenceResponse(&(val)->u.conferenceResponse);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_FastConnectOLC(ASN1encoding_t enc, FastConnectOLC *val)
{
    if (!ASN1Enc_OpenLogicalChannel(enc, val))
    return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FastConnectOLC(ASN1decoding_t dec, FastConnectOLC *val)
{
    if (!ASN1Dec_OpenLogicalChannel(dec, val))
    return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FastConnectOLC(FastConnectOLC *val)
{
    if (val) {
    ASN1Free_OpenLogicalChannel(val);
    }
}

static int ASN1CALL ASN1Enc_FunctionNotUnderstood(ASN1encoding_t enc, FunctionNotUnderstood *val)
{
    if (!ASN1PEREncSimpleChoice(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_FunctionNotUnderstood(ASN1decoding_t dec, FunctionNotUnderstood *val)
{
    if (!ASN1PERDecSimpleChoice(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_FunctionNotUnderstood(FunctionNotUnderstood *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_RequestMessage(&(val)->u.request);
        break;
    case 2:
        ASN1Free_ResponseMessage(&(val)->u.response);
        break;
    case 3:
        ASN1Free_CommandMessage(&(val)->u.command);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_IndicationMessage(ASN1encoding_t enc, IndicationMessage *val)
{
    ASN1encoding_t ee;
    if (!ASN1PEREncComplexChoice(enc, (val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_NonStandardMessage(enc, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_FunctionNotUnderstood(enc, &(val)->u.functionNotUnderstood))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_MasterSlaveDeterminationRelease(enc, &(val)->u.masterSlaveDeterminationRelease))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_TerminalCapabilitySetRelease(enc, &(val)->u.terminalCapabilitySetRelease))
        return 0;
    break;
    case 5:
    if (!ASN1Enc_OpenLogicalChannelConfirm(enc, &(val)->u.openLogicalChannelConfirm))
        return 0;
    break;
    case 6:
    if (!ASN1Enc_RequestChannelCloseRelease(enc, &(val)->u.requestChannelCloseRelease))
        return 0;
    break;
    case 7:
    if (!ASN1Enc_MultiplexEntrySendRelease(enc, &(val)->u.multiplexEntrySendRelease))
        return 0;
    break;
    case 8:
    if (!ASN1Enc_RequestMultiplexEntryRelease(enc, &(val)->u.requestMultiplexEntryRelease))
        return 0;
    break;
    case 9:
    if (!ASN1Enc_RequestModeRelease(enc, &(val)->u.requestModeRelease))
        return 0;
    break;
    case 10:
    if (!ASN1Enc_MiscellaneousIndication(enc, &(val)->u.miscellaneousIndication))
        return 0;
    break;
    case 11:
    if (!ASN1Enc_JitterIndication(enc, &(val)->u.jitterIndication))
        return 0;
    break;
    case 12:
    if (!ASN1Enc_H223SkewIndication(enc, &(val)->u.h223SkewIndication))
        return 0;
    break;
    case 13:
    if (!ASN1Enc_NewATMVCIndication(enc, &(val)->u.newATMVCIndication))
        return 0;
    break;
    case 14:
    if (!ASN1Enc_UserInputIndication(enc, &(val)->u.userInput))
        return 0;
    break;
    case 15:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_H2250MaximumSkewIndication(ee, &(val)->u.h2250MaximumSkewIndication))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 16:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_MCLocationIndication(ee, &(val)->u.mcLocationIndication))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 17:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_ConferenceIndication(ee, &(val)->u.conferenceIndication))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 18:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_VendorIdentification(ee, &(val)->u.vendorIdentification))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    case 19:
    if (ASN1_CreateEncoder(enc->module, &ee, NULL, 0, enc) < 0)
        return 0;
    if (!ASN1Enc_FunctionNotSupported(ee, &(val)->u.functionNotSupported))
        return 0;
    if (!ASN1PEREncFlushFragmentedToParent(ee))
        return 0;
    ASN1_CloseEncoder2(ee);
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_IndicationMessage(ASN1decoding_t dec, IndicationMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *db;
    ASN1uint32_t ds;
    if (!ASN1PERDecComplexChoice(dec, &(val)->choice, 4, 14))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_NonStandardMessage(dec, &(val)->u.nonStandard))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_FunctionNotUnderstood(dec, &(val)->u.functionNotUnderstood))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_MasterSlaveDeterminationRelease(dec, &(val)->u.masterSlaveDeterminationRelease))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_TerminalCapabilitySetRelease(dec, &(val)->u.terminalCapabilitySetRelease))
        return 0;
    break;
    case 5:
    if (!ASN1Dec_OpenLogicalChannelConfirm(dec, &(val)->u.openLogicalChannelConfirm))
        return 0;
    break;
    case 6:
    if (!ASN1Dec_RequestChannelCloseRelease(dec, &(val)->u.requestChannelCloseRelease))
        return 0;
    break;
    case 7:
    if (!ASN1Dec_MultiplexEntrySendRelease(dec, &(val)->u.multiplexEntrySendRelease))
        return 0;
    break;
    case 8:
    if (!ASN1Dec_RequestMultiplexEntryRelease(dec, &(val)->u.requestMultiplexEntryRelease))
        return 0;
    break;
    case 9:
    if (!ASN1Dec_RequestModeRelease(dec, &(val)->u.requestModeRelease))
        return 0;
    break;
    case 10:
    if (!ASN1Dec_MiscellaneousIndication(dec, &(val)->u.miscellaneousIndication))
        return 0;
    break;
    case 11:
    if (!ASN1Dec_JitterIndication(dec, &(val)->u.jitterIndication))
        return 0;
    break;
    case 12:
    if (!ASN1Dec_H223SkewIndication(dec, &(val)->u.h223SkewIndication))
        return 0;
    break;
    case 13:
    if (!ASN1Dec_NewATMVCIndication(dec, &(val)->u.newATMVCIndication))
        return 0;
    break;
    case 14:
    if (!ASN1Dec_UserInputIndication(dec, &(val)->u.userInput))
        return 0;
    break;
    case 15:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_H2250MaximumSkewIndication(dd, &(val)->u.h2250MaximumSkewIndication))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 16:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_MCLocationIndication(dd, &(val)->u.mcLocationIndication))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 17:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_ConferenceIndication(dd, &(val)->u.conferenceIndication))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 18:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_VendorIdentification(dd, &(val)->u.vendorIdentification))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 19:
    if (!ASN1PERDecFragmented(dec, &ds, &db, 8))
        return 0;
    if (ASN1_CreateDecoderEx(dec->module, &dd, db, ds, dec, ASN1DECODE_AUTOFREEBUFFER) < 0)
        return 0;
    if (!ASN1Dec_FunctionNotSupported(dd, &(val)->u.functionNotSupported))
        return 0;
    ASN1_CloseDecoder(dd);
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_IndicationMessage(IndicationMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_NonStandardMessage(&(val)->u.nonStandard);
        break;
    case 2:
        ASN1Free_FunctionNotUnderstood(&(val)->u.functionNotUnderstood);
        break;
    case 7:
        ASN1Free_MultiplexEntrySendRelease(&(val)->u.multiplexEntrySendRelease);
        break;
    case 8:
        ASN1Free_RequestMultiplexEntryRelease(&(val)->u.requestMultiplexEntryRelease);
        break;
    case 10:
        ASN1Free_MiscellaneousIndication(&(val)->u.miscellaneousIndication);
        break;
    case 14:
        ASN1Free_UserInputIndication(&(val)->u.userInput);
        break;
    case 16:
        ASN1Free_MCLocationIndication(&(val)->u.mcLocationIndication);
        break;
    case 18:
        ASN1Free_VendorIdentification(&(val)->u.vendorIdentification);
        break;
    case 19:
        ASN1Free_FunctionNotSupported(&(val)->u.functionNotSupported);
        break;
    }
    }
}

static int ASN1CALL ASN1Enc_MultimediaSystemControlMessage(ASN1encoding_t enc, MultimediaSystemControlMessage *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Enc_RequestMessage(enc, &(val)->u.request))
        return 0;
    break;
    case 2:
    if (!ASN1Enc_ResponseMessage(enc, &(val)->u.response))
        return 0;
    break;
    case 3:
    if (!ASN1Enc_CommandMessage(enc, &(val)->u.command))
        return 0;
    break;
    case 4:
    if (!ASN1Enc_IndicationMessage(enc, &(val)->u.indication))
        return 0;
    break;
    default:
    /* impossible */
    ASN1EncSetError(enc, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_MultimediaSystemControlMessage(ASN1decoding_t dec, MultimediaSystemControlMessage *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
    return 0;
    switch ((val)->choice) {
    case 1:
    if (!ASN1Dec_RequestMessage(dec, &(val)->u.request))
        return 0;
    break;
    case 2:
    if (!ASN1Dec_ResponseMessage(dec, &(val)->u.response))
        return 0;
    break;
    case 3:
    if (!ASN1Dec_CommandMessage(dec, &(val)->u.command))
        return 0;
    break;
    case 4:
    if (!ASN1Dec_IndicationMessage(dec, &(val)->u.indication))
        return 0;
    break;
    case 0:
    /* extension case */
    if (!ASN1PERDecSkipFragmented(dec, 8))
        return 0;
    break;
    default:
    /* impossible */
    ASN1DecSetError(dec, ASN1_ERR_CHOICE);
    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_MultimediaSystemControlMessage(MultimediaSystemControlMessage *val)
{
    if (val) {
    switch ((val)->choice) {
    case 1:
        ASN1Free_RequestMessage(&(val)->u.request);
        break;
    case 2:
        ASN1Free_ResponseMessage(&(val)->u.response);
        break;
    case 3:
        ASN1Free_CommandMessage(&(val)->u.command);
        break;
    case 4:
        ASN1Free_IndicationMessage(&(val)->u.indication);
        break;
    }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\cctostrm.h ===
/*++

Copyright ) ( c) 1997 Microsoft Corporation

Module Name:

    cctostrm.h

Abstract:

    defines interfaces between the stream object and the cc module

Author:
    
    Mu Han (muhan) 10-JUNE-1999

--*/
#ifndef __CCTOSTRM_H_
#define __CCTOSTRM_H_

typedef struct tag_H323MSPEndpointVersion
{
	BYTE bH221CountryCode;
	BYTE bH221CountryExtension;
	WORD wH221MfrCode;
	BSTR *pProductIdentifier;
	BSTR *pVersionIdentifier;
} H323MSPEndpointVersion;

// {4ab1fe8c-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_IH245ChannelControl,
0x4ab1fe8c, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8c-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
IH245ChannelControl : public IUnknown
{
    STDMETHOD (SetFormat) (
        IN   AM_MEDIA_TYPE *pMediaType
        ) PURE;

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        ) PURE;

    STDMETHOD (GetStreamCaps) (
        IN   DWORD dwIndex, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  BOOL *pfEnabled
        ) PURE;


    STDMETHOD (Start) (BOOL fRequestedByApplication) PURE;

    STDMETHOD (Stop) (BOOL fRequestedByApplication) PURE;

    STDMETHOD (Pause) (
        IN   BOOL fPause
        ) PURE;

    STDMETHOD (SetMaxBitrate) (
        IN   DWORD dwMaxBitrate
        ) PURE;


    STDMETHOD (GetRemoteVersion) (
        OUT  H323MSPEndpointVersion *pEndpointVersion
        ) PURE;
        
    STDMETHOD (SelectTerminal) (
        IN   ITTerminal *pTerminal
        ) PURE;

    STDMETHOD (UnselectTerminal) (
        IN   ITTerminal *pTerminal
        ) PURE;

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        ) PURE;
};

// {4ab1fe8d-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_ISubstreamControl,
0x4ab1fe8d, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8d-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
ISubstreamControl : public IUnknown
{
    STDMETHOD (SC_SetFormat) ( 
        IN   AM_MEDIA_TYPE *pMediaType,
        IN   DWORD dwFormatID,
        IN   DWORD dwPayloadType  
        ) PURE;
        
    STDMETHOD (SC_Start) (BOOL fRequestedByApplication) PURE;
    
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication) PURE;
    
    STDMETHOD (SC_Pause) (VOID) PURE;

    STDMETHOD (SC_SetBitrate) ( 
        IN   DWORD dwBitsPerSecond
        ) PURE;
        
    STDMETHOD (SC_RemoteTemporalSpatialTradeoff) ( 
        IN   USHORT uTSRemoteValue
        ) PURE;
    
    STDMETHOD (SC_CreateSubstream) ( 
        OUT  ISubstreamControl *pSubStream
        ) PURE;

    STDMETHOD (SC_SetRemoteAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pRemoteMediaAddr,
        IN   PSOCKADDR_IN pRemoteControlAddr
        ) PURE;
        
    STDMETHOD (SC_SetSource) (  
        // indicates the low 8 bits of the local SSRC (if this is a send substream)  
        // or the low 8 bits of the senders SSRC (if this is a receive substream)
        IN   BYTE bSource
        ) PURE;

    STDMETHOD (SC_SelectLocalAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalAddress,            // local IP address (same as H.245)
        OUT  PSOCKADDR_IN pLocalMediaAddress, // NULL if opening TX channel, else we want to know the local RTP receive address
        OUT  PSOCKADDR_IN pLocalControlAddress    // We want to know the local RTCP address
        ) PURE;

    STDMETHOD (SC_SetLocalReceiveAddress) (             // only called when the receive address is non-negotiable (e.g. multicast case)
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalMediaAddr,  // local IP address (same as H.245)
        IN   PSOCKADDR_IN pLocalControlAddress, 
        IN   PSOCKADDR_IN pRemoteControlAddress
        ) PURE;

    STDMETHOD (SC_SendDTMF) ( 
        IN   LPWSTR pwstrDialChars
        ) PURE;
        
    STDMETHOD (SC_SetDESKey52) ( 
        IN   BYTE *pKey
        ) PURE;

    STDMETHOD (SC_SelectTerminal) ( 
        IN   ITTerminal *pTerminal
        ) PURE;
        
    STDMETHOD (SC_UnselectTerminal) (  
        IN   ITTerminal *pTerminal
        ) PURE;

};

// {4ab1fe8e-1f97-11d3-a577-00c04f8ef6e3}
DEFINE_GUID(IID_IH245SubstreamControl,
0x4ab1fe8e, 0x1f97, 0x11d3, 0xa5, 0x77, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

struct DECLSPEC_UUID("4ab1fe8e-1f97-11d3-a577-00c04f8ef6e3") DECLSPEC_NOVTABLE
IH245SubstreamControl : public IUnknown
{
    STDMETHOD (H245SC_BeginControlSession) ( 
        IN   IH245ChannelControl *pIChannelControl
        ) PURE;
    
    STDMETHOD (H245SC_EndControlSession) (VOID) PURE;   
    
    STDMETHOD (H245SC_GetNumberOfCapabilities) ( 
        OUT DWORD *pdwTemplateCount, 
        OUT DWORD *pdwFormatCount
        ) PURE;

    STDMETHOD (H245SC_GetStreamCaps) ( 
        IN   DWORD dwIndex, 
        OUT  const H245MediaCapability** pph245Capability, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  DWORD *pdwUniqueID,
        OUT  UINT *puResourceBoundArrayEntries,
        OUT  const FormatResourceBounds **ppResourceBoundArray    
        ) PURE;

    STDMETHOD (H245SC_RefineStreamCap) ( 
        IN   DWORD dwUniqueID,
        IN   DWORD dwResourceBoundIndex,
        IN OUT H245MediaCapability* ph245Capability
        ) PURE;
     
    STDMETHOD (H245SC_SetIDBase) ( 
        IN   UINT uNewBase
        ) PURE;
    
    STDMETHOD (H245SC_FindIDByRange) ( 
        IN   AM_MEDIA_TYPE *pAMMediaType,
        OUT  DWORD *pdwUniqueID
        ) PURE;     

    STDMETHOD (H245SC_FindIDByMode) ( 
        IN   H245_MODE_ELEMENT *pModeElement,
        OUT  DWORD *pdwUniqueID
        ) PURE;

    STDMETHOD (H245SC_IntersectFormats) ( 
        IN   const H245MediaCapability *pLocalCapability, 
        IN   DWORD dwUniqueID,
        IN   const H245MediaCapability *pRemoteCapability, 
        OUT  const H245MediaCapability **pIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        ) PURE;

	STDMETHOD (H245SC_GetLocalFormat) (
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability, 
		OUT AM_MEDIA_TYPE **ppAMMediaType
		) PURE;
		
    STDMETHOD (H245SC_ReleaseNegotiatedCapability) ( 
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability 
        ) PURE;
};


// {20A0D46A-2D95-11d3-89D1-00C04F8EC972}
DEFINE_GUID(IID_IVidEncChannelControl,
0x20A0D46A, 0x2D95, 0x11d3, 0x89, 0xD1, 0x00, 0xc0, 0x4f, 0x8e, 0xC9, 0x72);

struct DECLSPEC_UUID("20A0D46A-2D95-11d3-89D1-00C04F8EC972") DECLSPEC_NOVTABLE
IVidEncChannelControl : IUnknown  
{

	STDMETHOD (VideoFastUpdatePicture)(void) PURE;

	STDMETHOD (VideoFastUpdateGOB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwNumberOfGOBs
		) PURE;

	STDMETHOD (VideoFastUpdateMB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs
		) PURE;

	STDMETHOD (VideoSendSyncEveryGOB)(
		IN  BOOL fEnable
		) PURE;

	STDMETHOD (VideoNotDecodedMBs)(
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs, 
		IN  DWORD dwTemporalReference
		) PURE;


	STDMETHOD (VideoEncTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		) PURE;

};


// {0276FFED-3590-11d3-89D1-00C04F8EC972}
DEFINE_GUID(IID_IVidDecChannelControl, 
0x276ffed, 0x3590, 0x11d3, 0x89, 0xd1, 0x0, 0xc0, 0x4f, 0x8e, 0xc9, 0x72);

struct DECLSPEC_UUID("0276FFED-3590-11d3-89D1-00C04F8EC972") DECLSPEC_NOVTABLE
IVidDecChannelControl : IUnknown  
{

	STDMETHOD (VideoFreezePicture)(void) PURE;

	STDMETHOD (VideoDecTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		) PURE;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h225asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.235 Security Messages v1 (H.235) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for H.323 Messages v2 (H.225) */

#ifndef _H225ASN_Module_H_
#define _H225ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs * PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs;

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct RTPSession_associatedSessionIds * PRTPSession_associatedSessionIds;

typedef struct GatekeeperRequest_algorithmOIDs * PGatekeeperRequest_algorithmOIDs;

typedef struct Progress_UUIE_fastStart * PProgress_UUIE_fastStart;

typedef struct Facility_UUIE_fastStart * PFacility_UUIE_fastStart;

typedef struct Setup_UUIE_fastStart * PSetup_UUIE_fastStart;

typedef struct Setup_UUIE_destExtraCRV * PSetup_UUIE_destExtraCRV;

typedef struct Connect_UUIE_fastStart * PConnect_UUIE_fastStart;

typedef struct CallProceeding_UUIE_fastStart * PCallProceeding_UUIE_fastStart;

typedef struct Alerting_UUIE_fastStart * PAlerting_UUIE_fastStart;

typedef struct H323_UU_PDU_h245Control * PH323_UU_PDU_h245Control;

typedef struct H323_UU_PDU_h4501SupplementaryService * PH323_UU_PDU_h4501SupplementaryService;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens * PInfoRequestResponse_perCallInfo_Seq_tokens;

typedef struct ResourcesAvailableConfirm_tokens * PResourcesAvailableConfirm_tokens;

typedef struct ResourcesAvailableIndicate_tokens * PResourcesAvailableIndicate_tokens;

typedef struct RequestInProgress_tokens * PRequestInProgress_tokens;

typedef struct UnknownMessageResponse_tokens * PUnknownMessageResponse_tokens;

typedef struct H225NonStandardMessage_tokens * PH225NonStandardMessage_tokens;

typedef struct InfoRequestNak_tokens * PInfoRequestNak_tokens;

typedef struct InfoRequestAck_tokens * PInfoRequestAck_tokens;

typedef struct InfoRequestResponse_tokens * PInfoRequestResponse_tokens;

typedef struct InfoRequest_tokens * PInfoRequest_tokens;

typedef struct DisengageReject_tokens * PDisengageReject_tokens;

typedef struct DisengageConfirm_tokens * PDisengageConfirm_tokens;

typedef struct DisengageRequest_tokens * PDisengageRequest_tokens;

typedef struct LocationReject_tokens * PLocationReject_tokens;

typedef struct LocationConfirm_tokens * PLocationConfirm_tokens;

typedef struct LocationRequest_tokens * PLocationRequest_tokens;

typedef struct BandwidthReject_tokens * PBandwidthReject_tokens;

typedef struct BandwidthConfirm_tokens * PBandwidthConfirm_tokens;

typedef struct BandwidthRequest_tokens * PBandwidthRequest_tokens;

typedef struct AdmissionReject_tokens * PAdmissionReject_tokens;

typedef struct AdmissionConfirm_tokens * PAdmissionConfirm_tokens;

typedef struct AdmissionRequest_tokens * PAdmissionRequest_tokens;

typedef struct UnregistrationReject_tokens * PUnregistrationReject_tokens;

typedef struct UnregistrationConfirm_tokens * PUnregistrationConfirm_tokens;

typedef struct UnregistrationRequest_tokens * PUnregistrationRequest_tokens;

typedef struct RegistrationReject_tokens * PRegistrationReject_tokens;

typedef struct RegistrationConfirm_tokens * PRegistrationConfirm_tokens;

typedef struct RegistrationRequest_tokens * PRegistrationRequest_tokens;

typedef struct GatekeeperReject_tokens * PGatekeeperReject_tokens;

typedef struct GatekeeperConfirm_tokens * PGatekeeperConfirm_tokens;

typedef struct GatekeeperRequest_authenticationCapability * PGatekeeperRequest_authenticationCapability;

typedef struct GatekeeperRequest_tokens * PGatekeeperRequest_tokens;

typedef struct Endpoint_tokens * PEndpoint_tokens;

typedef struct Progress_UUIE_tokens * PProgress_UUIE_tokens;

typedef struct Facility_UUIE_tokens * PFacility_UUIE_tokens;

typedef struct Setup_UUIE_tokens * PSetup_UUIE_tokens;

typedef struct Connect_UUIE_tokens * PConnect_UUIE_tokens;

typedef struct CallProceeding_UUIE_tokens * PCallProceeding_UUIE_tokens;

typedef struct Alerting_UUIE_tokens * PAlerting_UUIE_tokens;

typedef struct GatekeeperConfirm_integrity * PGatekeeperConfirm_integrity;

typedef struct GatekeeperRequest_integrity * PGatekeeperRequest_integrity;

typedef struct NonStandardProtocol_dataRatesSupported * PNonStandardProtocol_dataRatesSupported;

typedef struct T120OnlyCaps_dataRatesSupported * PT120OnlyCaps_dataRatesSupported;

typedef struct VoiceCaps_dataRatesSupported * PVoiceCaps_dataRatesSupported;

typedef struct H324Caps_dataRatesSupported * PH324Caps_dataRatesSupported;

typedef struct H323Caps_dataRatesSupported * PH323Caps_dataRatesSupported;

typedef struct H322Caps_dataRatesSupported * PH322Caps_dataRatesSupported;

typedef struct H321Caps_dataRatesSupported * PH321Caps_dataRatesSupported;

typedef struct H320Caps_dataRatesSupported * PH320Caps_dataRatesSupported;

typedef struct H310Caps_dataRatesSupported * PH310Caps_dataRatesSupported;

typedef struct Setup_UUIE_h245SecurityCapability * PSetup_UUIE_h245SecurityCapability;

typedef struct H323_UU_PDU_nonStandardControl * PH323_UU_PDU_nonStandardControl;

typedef struct InfoRequestResponse_perCallInfo_Seq_data * PInfoRequestResponse_perCallInfo_Seq_data;

typedef struct InfoRequestResponse_perCallInfo_Seq_video * PInfoRequestResponse_perCallInfo_Seq_video;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio * PInfoRequestResponse_perCallInfo_Seq_audio;

typedef struct InfoRequestResponse_perCallInfo * PInfoRequestResponse_perCallInfo;

typedef struct InfoRequestResponse_callSignalAddress * PInfoRequestResponse_callSignalAddress;

typedef struct AdmissionReject_callSignalAddress * PAdmissionReject_callSignalAddress;

typedef struct UnregistrationRequest_callSignalAddress * PUnregistrationRequest_callSignalAddress;

typedef struct RegistrationConfirm_alternateGatekeeper * PRegistrationConfirm_alternateGatekeeper;

typedef struct RegistrationConfirm_callSignalAddress * PRegistrationConfirm_callSignalAddress;

typedef struct RegistrationRequest_rasAddress * PRegistrationRequest_rasAddress;

typedef struct RegistrationRequest_callSignalAddress * PRegistrationRequest_callSignalAddress;

typedef struct GatekeeperConfirm_alternateGatekeeper * PGatekeeperConfirm_alternateGatekeeper;

typedef struct AltGKInfo_alternateGatekeeper * PAltGKInfo_alternateGatekeeper;

typedef struct Endpoint_rasAddress * PEndpoint_rasAddress;

typedef struct Endpoint_callSignalAddress * PEndpoint_callSignalAddress;

typedef struct ResourcesAvailableIndicate_protocols * PResourcesAvailableIndicate_protocols;

typedef struct InfoRequestResponse_endpointAlias * PInfoRequestResponse_endpointAlias;

typedef struct LocationConfirm_alternateEndpoints * PLocationConfirm_alternateEndpoints;

typedef struct LocationConfirm_remoteExtensionAddress * PLocationConfirm_remoteExtensionAddress;

typedef struct LocationConfirm_destExtraCallInfo * PLocationConfirm_destExtraCallInfo;

typedef struct LocationConfirm_destinationInfo * PLocationConfirm_destinationInfo;

typedef struct LocationRequest_sourceInfo * PLocationRequest_sourceInfo;

typedef struct LocationRequest_destinationInfo * PLocationRequest_destinationInfo;

typedef struct AdmissionConfirm_alternateEndpoints * PAdmissionConfirm_alternateEndpoints;

typedef struct AdmissionConfirm_remoteExtensionAddress * PAdmissionConfirm_remoteExtensionAddress;

typedef struct AdmissionConfirm_destExtraCallInfo * PAdmissionConfirm_destExtraCallInfo;

typedef struct AdmissionConfirm_destinationInfo * PAdmissionConfirm_destinationInfo;

typedef struct AdmissionRequest_destAlternatives * PAdmissionRequest_destAlternatives;

typedef struct AdmissionRequest_srcAlternatives * PAdmissionRequest_srcAlternatives;

typedef struct AdmissionRequest_srcInfo * PAdmissionRequest_srcInfo;

typedef struct AdmissionRequest_destExtraCallInfo * PAdmissionRequest_destExtraCallInfo;

typedef struct AdmissionRequest_destinationInfo * PAdmissionRequest_destinationInfo;

typedef struct UnregistrationRequest_alternateEndpoints * PUnregistrationRequest_alternateEndpoints;

typedef struct UnregistrationRequest_endpointAlias * PUnregistrationRequest_endpointAlias;

typedef struct RegistrationRejectReason_duplicateAlias * PRegistrationRejectReason_duplicateAlias;

typedef struct RegistrationConfirm_terminalAlias * PRegistrationConfirm_terminalAlias;

typedef struct RegistrationRequest_alternateEndpoints * PRegistrationRequest_alternateEndpoints;

typedef struct RegistrationRequest_terminalAlias * PRegistrationRequest_terminalAlias;

typedef struct GatekeeperRequest_alternateEndpoints * PGatekeeperRequest_alternateEndpoints;

typedef struct GatekeeperRequest_endpointAlias * PGatekeeperRequest_endpointAlias;

typedef struct Endpoint_destExtraCallInfo * PEndpoint_destExtraCallInfo;

typedef struct Endpoint_remoteExtensionAddress * PEndpoint_remoteExtensionAddress;

typedef struct Endpoint_aliasAddress * PEndpoint_aliasAddress;

typedef struct NonStandardProtocol_supportedPrefixes * PNonStandardProtocol_supportedPrefixes;

typedef struct T120OnlyCaps_supportedPrefixes * PT120OnlyCaps_supportedPrefixes;

typedef struct VoiceCaps_supportedPrefixes * PVoiceCaps_supportedPrefixes;

typedef struct H324Caps_supportedPrefixes * PH324Caps_supportedPrefixes;

typedef struct H323Caps_supportedPrefixes * PH323Caps_supportedPrefixes;

typedef struct H322Caps_supportedPrefixes * PH322Caps_supportedPrefixes;

typedef struct H321Caps_supportedPrefixes * PH321Caps_supportedPrefixes;

typedef struct H320Caps_supportedPrefixes * PH320Caps_supportedPrefixes;

typedef struct H310Caps_supportedPrefixes * PH310Caps_supportedPrefixes;

typedef struct GatewayInfo_protocol * PGatewayInfo_protocol;

typedef struct Facility_UUIE_destExtraCallInfo * PFacility_UUIE_destExtraCallInfo;

typedef struct Facility_UUIE_alternativeAliasAddress * PFacility_UUIE_alternativeAliasAddress;

typedef struct Setup_UUIE_destExtraCallInfo * PSetup_UUIE_destExtraCallInfo;

typedef struct Setup_UUIE_destinationAddress * PSetup_UUIE_destinationAddress;

typedef struct Setup_UUIE_sourceAddress * PSetup_UUIE_sourceAddress;

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens * PInfoRequestResponse_perCallInfo_Seq_cryptoTokens;

typedef struct ResourcesAvailableConfirm_cryptoTokens * PResourcesAvailableConfirm_cryptoTokens;

typedef struct ResourcesAvailableIndicate_cryptoTokens * PResourcesAvailableIndicate_cryptoTokens;

typedef struct RequestInProgress_cryptoTokens * PRequestInProgress_cryptoTokens;

typedef struct UnknownMessageResponse_cryptoTokens * PUnknownMessageResponse_cryptoTokens;

typedef struct H225NonStandardMessage_cryptoTokens * PH225NonStandardMessage_cryptoTokens;

typedef struct InfoRequestNak_cryptoTokens * PInfoRequestNak_cryptoTokens;

typedef struct InfoRequestAck_cryptoTokens * PInfoRequestAck_cryptoTokens;

typedef struct InfoRequestResponse_cryptoTokens * PInfoRequestResponse_cryptoTokens;

typedef struct InfoRequest_cryptoTokens * PInfoRequest_cryptoTokens;

typedef struct DisengageReject_cryptoTokens * PDisengageReject_cryptoTokens;

typedef struct DisengageConfirm_cryptoTokens * PDisengageConfirm_cryptoTokens;

typedef struct DisengageRequest_cryptoTokens * PDisengageRequest_cryptoTokens;

typedef struct LocationReject_cryptoTokens * PLocationReject_cryptoTokens;

typedef struct LocationConfirm_cryptoTokens * PLocationConfirm_cryptoTokens;

typedef struct LocationRequest_cryptoTokens * PLocationRequest_cryptoTokens;

typedef struct BandwidthReject_cryptoTokens * PBandwidthReject_cryptoTokens;

typedef struct BandwidthConfirm_cryptoTokens * PBandwidthConfirm_cryptoTokens;

typedef struct BandwidthRequest_cryptoTokens * PBandwidthRequest_cryptoTokens;

typedef struct AdmissionReject_cryptoTokens * PAdmissionReject_cryptoTokens;

typedef struct AdmissionConfirm_cryptoTokens * PAdmissionConfirm_cryptoTokens;

typedef struct AdmissionRequest_cryptoTokens * PAdmissionRequest_cryptoTokens;

typedef struct UnregistrationReject_cryptoTokens * PUnregistrationReject_cryptoTokens;

typedef struct UnregistrationConfirm_cryptoTokens * PUnregistrationConfirm_cryptoTokens;

typedef struct UnregistrationRequest_cryptoTokens * PUnregistrationRequest_cryptoTokens;

typedef struct RegistrationReject_cryptoTokens * PRegistrationReject_cryptoTokens;

typedef struct RegistrationConfirm_cryptoTokens * PRegistrationConfirm_cryptoTokens;

typedef struct RegistrationRequest_cryptoTokens * PRegistrationRequest_cryptoTokens;

typedef struct GatekeeperReject_cryptoTokens * PGatekeeperReject_cryptoTokens;

typedef struct GatekeeperConfirm_cryptoTokens * PGatekeeperConfirm_cryptoTokens;

typedef struct GatekeeperRequest_cryptoTokens * PGatekeeperRequest_cryptoTokens;

typedef struct Endpoint_cryptoTokens * PEndpoint_cryptoTokens;

typedef struct Progress_UUIE_cryptoTokens * PProgress_UUIE_cryptoTokens;

typedef struct Facility_UUIE_conferences * PFacility_UUIE_conferences;

typedef struct Facility_UUIE_cryptoTokens * PFacility_UUIE_cryptoTokens;

typedef struct Setup_UUIE_cryptoTokens * PSetup_UUIE_cryptoTokens;

typedef struct Connect_UUIE_cryptoTokens * PConnect_UUIE_cryptoTokens;

typedef struct CallProceeding_UUIE_cryptoTokens * PCallProceeding_UUIE_cryptoTokens;

typedef struct Alerting_UUIE_cryptoTokens * PAlerting_UUIE_cryptoTokens;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu * PInfoRequestResponse_perCallInfo_Seq_pdu;

typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h4501SupplementaryService_Seq;

typedef ASN1octetstring_t H323_UU_PDU_h245Control_Seq;

typedef ASN1octetstring_t Alerting_UUIE_fastStart_Seq;

typedef ASN1octetstring_t CallProceeding_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Connect_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Setup_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Facility_UUIE_fastStart_Seq;

typedef ASN1octetstring_t Progress_UUIE_fastStart_Seq;

typedef ASN1objectidentifier_t GatekeeperRequest_algorithmOIDs_Seq;

typedef ASN1uint16_t RTPSession_associatedSessionIds_Seq;

typedef struct ChallengeString {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} ChallengeString;

typedef ASN1uint32_t TimeStamp;

typedef ASN1int32_t RandomVal;

typedef ASN1char16string_t Password;

typedef ASN1char16string_t Identifier;

typedef struct IV8 {
    ASN1uint32_t length;
    ASN1octet_t value[8];
} IV8;

typedef ASN1char_t NumberDigits[129];

typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef GloballyUniqueID ConferenceIdentifier;

typedef ASN1uint16_t RequestSeqNum;

typedef ASN1char16string_t GatekeeperIdentifier;

typedef ASN1uint32_t BandWidth;

typedef ASN1uint16_t CallReferenceValue;

typedef ASN1char16string_t EndpointIdentifier;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef ASN1uint32_t TimeToLive;

typedef struct InfoRequestResponse_perCallInfo_Seq_substituteConfIDs {
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs next;
    ConferenceIdentifier value;
} InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_Element;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define TransportAddress_ipSourceRoute_routing_strict_chosen 1
#   define TransportAddress_ipSourceRoute_routing_loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct RTPSession_associatedSessionIds {
    PRTPSession_associatedSessionIds next;
    RTPSession_associatedSessionIds_Seq value;
} RTPSession_associatedSessionIds_Element;

typedef struct RegistrationConfirm_preGrantedARQ {
    ASN1bool_t makeCall;
    ASN1bool_t useGKCallSignalAddressToMakeCall;
    ASN1bool_t answerCall;
    ASN1bool_t useGKCallSignalAddressToAnswer;
} RegistrationConfirm_preGrantedARQ;

typedef struct GatekeeperRequest_algorithmOIDs {
    PGatekeeperRequest_algorithmOIDs next;
    GatekeeperRequest_algorithmOIDs_Seq value;
} GatekeeperRequest_algorithmOIDs_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;

typedef struct Progress_UUIE_fastStart {
    PProgress_UUIE_fastStart next;
    Progress_UUIE_fastStart_Seq value;
} Progress_UUIE_fastStart_Element;

typedef struct Facility_UUIE_fastStart {
    PFacility_UUIE_fastStart next;
    Facility_UUIE_fastStart_Seq value;
} Facility_UUIE_fastStart_Element;

typedef struct Setup_UUIE_fastStart {
    PSetup_UUIE_fastStart next;
    Setup_UUIE_fastStart_Seq value;
} Setup_UUIE_fastStart_Element;

typedef struct Setup_UUIE_conferenceGoal {
    ASN1choice_t choice;
#   define create_chosen 1
#   define join_chosen 2
#   define invite_chosen 3
#   define capability_negotiation_chosen 4
#   define callIndependentSupplementaryService_chosen 5
} Setup_UUIE_conferenceGoal;

typedef struct Setup_UUIE_destExtraCRV {
    PSetup_UUIE_destExtraCRV next;
    CallReferenceValue value;
} Setup_UUIE_destExtraCRV_Element;

typedef struct Connect_UUIE_fastStart {
    PConnect_UUIE_fastStart next;
    Connect_UUIE_fastStart_Seq value;
} Connect_UUIE_fastStart_Element;

typedef struct CallProceeding_UUIE_fastStart {
    PCallProceeding_UUIE_fastStart next;
    CallProceeding_UUIE_fastStart_Seq value;
} CallProceeding_UUIE_fastStart_Element;

typedef struct Alerting_UUIE_fastStart {
    PAlerting_UUIE_fastStart next;
    Alerting_UUIE_fastStart_Seq value;
} Alerting_UUIE_fastStart_Element;

typedef struct H323_UU_PDU_h245Control {
    PH323_UU_PDU_h245Control next;
    H323_UU_PDU_h245Control_Seq value;
} H323_UU_PDU_h245Control_Element;

typedef struct H323_UU_PDU_h4501SupplementaryService {
    PH323_UU_PDU_h4501SupplementaryService next;
    H323_UU_PDU_h4501SupplementaryService_Seq value;
} H323_UU_PDU_h4501SupplementaryService_Element;

typedef struct H323_UserInformation_user_data {
    ASN1uint16_t protocol_discriminator;
    struct H323_UserInformation_user_data_user_information_user_information {
	ASN1uint32_t length;
	ASN1octet_t value[131];
    } user_information;
} H323_UserInformation_user_data;

typedef struct H235NonStandardParameter {
    ASN1objectidentifier_t nonStandardIdentifier;
    ASN1octetstring_t data;
} H235NonStandardParameter;

typedef struct DHset {
    ASN1bitstring_t halfkey;
    ASN1bitstring_t modSize;
    ASN1bitstring_t generator;
} DHset;

typedef struct TypedCertificate {
    ASN1objectidentifier_t type;
    ASN1octetstring_t certificate;
} TypedCertificate;

typedef struct AuthenticationMechanism {
    ASN1choice_t choice;
    union {
#	define dhExch_chosen 1
#	define pwdSymEnc_chosen 2
#	define pwdHash_chosen 3
#	define certSign_chosen 4
#	define AuthenticationMechanism_ipsec_chosen 5
#	define AuthenticationMechanism_tls_chosen 6
#	define AuthenticationMechanism_nonStandard_chosen 7
	H235NonStandardParameter nonStandard;
    } u;
} AuthenticationMechanism;

typedef struct ClearToken {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1objectidentifier_t tokenOID;
#   define ClearToken_timeStamp_present 0x80
    TimeStamp timeStamp;
#   define password_present 0x40
    Password password;
#   define dhkey_present 0x20
    DHset dhkey;
#   define challenge_present 0x10
    ChallengeString challenge;
#   define random_present 0x8
    RandomVal random;
#   define ClearToken_certificate_present 0x4
    TypedCertificate certificate;
#   define generalID_present 0x2
    Identifier generalID;
#   define ClearToken_nonStandard_present 0x1
    H235NonStandardParameter nonStandard;
} ClearToken;

typedef struct Params {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ranInt_present 0x80
    ASN1int32_t ranInt;
#   define iv8_present 0x40
    IV8 iv8;
} Params;

typedef struct EncodedGeneralToken {
    ASN1objectidentifier_t id;
    ClearToken type;
} EncodedGeneralToken;

typedef ClearToken PwdCertToken;

typedef struct EncodedPwdCertToken {
    ASN1objectidentifier_t id;
    PwdCertToken type;
} EncodedPwdCertToken;

typedef struct ReleaseCompleteReason {
    ASN1choice_t choice;
#   define noBandwidth_chosen 1
#   define gatekeeperResources_chosen 2
#   define unreachableDestination_chosen 3
#   define destinationRejection_chosen 4
#   define ReleaseCompleteReason_invalidRevision_chosen 5
#   define noPermission_chosen 6
#   define unreachableGatekeeper_chosen 7
#   define gatewayResources_chosen 8
#   define badFormatAddress_chosen 9
#   define adaptiveBusy_chosen 10
#   define inConf_chosen 11
#   define ReleaseCompleteReason_undefinedReason_chosen 12
#   define facilityCallDeflection_chosen 13
#   define securityDenied_chosen 14
#   define ReleaseCompleteReason_calledPartyNotRegistered_chosen 15
#   define ReleaseCompleteReason_callerNotRegistered_chosen 16
} ReleaseCompleteReason;

typedef struct FacilityReason {
    ASN1choice_t choice;
#   define FacilityReason_routeCallToGatekeeper_chosen 1
#   define callForwarded_chosen 2
#   define routeCallToMC_chosen 3
#   define FacilityReason_undefinedReason_chosen 4
#   define conferenceListChoice_chosen 5
#   define startH245_chosen 6
} FacilityReason;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define H225NonStandardIdentifier_object_chosen 1
	ASN1objectidentifier_t object;
#	define H225NonStandardIdentifier_h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define PublicTypeOfNumber_internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct AltGKInfo {
    PAltGKInfo_alternateGatekeeper alternateGatekeeper;
    ASN1bool_t altGKisPermanent;
} AltGKInfo;

typedef struct Q954Details {
    ASN1bool_t conferenceCalling;
    ASN1bool_t threePartyService;
} Q954Details;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;

typedef struct ICV {
    ASN1objectidentifier_t algorithmOID;
    ASN1bitstring_t icv;
} ICV;

typedef struct GatekeeperRejectReason {
    ASN1choice_t choice;
#   define GatekeeperRejectReason_resourceUnavailable_chosen 1
#   define terminalExcluded_chosen 2
#   define GatekeeperRejectReason_invalidRevision_chosen 3
#   define GatekeeperRejectReason_undefinedReason_chosen 4
#   define GatekeeperRejectReason_securityDenial_chosen 5
} GatekeeperRejectReason;

typedef struct RegistrationRejectReason {
    ASN1choice_t choice;
    union {
#	define discoveryRequired_chosen 1
#	define RegistrationRejectReason_invalidRevision_chosen 2
#	define invalidCallSignalAddress_chosen 3
#	define invalidRASAddress_chosen 4
#	define duplicateAlias_chosen 5
	PRegistrationRejectReason_duplicateAlias duplicateAlias;
#	define invalidTerminalType_chosen 6
#	define RegistrationRejectReason_undefinedReason_chosen 7
#	define transportNotSupported_chosen 8
#	define transportQOSNotSupported_chosen 9
#	define RegistrationRejectReason_resourceUnavailable_chosen 10
#	define invalidAlias_chosen 11
#	define RegistrationRejectReason_securityDenial_chosen 12
    } u;
} RegistrationRejectReason;

typedef struct UnregRequestReason {
    ASN1choice_t choice;
#   define reregistrationRequired_chosen 1
#   define ttlExpired_chosen 2
#   define UnregRequestReason_securityDenial_chosen 3
#   define UnregRequestReason_undefinedReason_chosen 4
} UnregRequestReason;

typedef struct UnregRejectReason {
    ASN1choice_t choice;
#   define notCurrentlyRegistered_chosen 1
#   define callInProgress_chosen 2
#   define UnregRejectReason_undefinedReason_chosen 3
#   define permissionDenied_chosen 4
#   define UnregRejectReason_securityDenial_chosen 5
} UnregRejectReason;

typedef struct CallType {
    ASN1choice_t choice;
#   define pointToPoint_chosen 1
#   define oneToN_chosen 2
#   define nToOne_chosen 3
#   define nToN_chosen 4
} CallType;

typedef struct CallModel {
    ASN1choice_t choice;
#   define direct_chosen 1
#   define gatekeeperRouted_chosen 2
} CallModel;

typedef struct TransportQOS {
    ASN1choice_t choice;
#   define endpointControlled_chosen 1
#   define gatekeeperControlled_chosen 2
#   define noControl_chosen 3
} TransportQOS;

typedef struct UUIEsRequested {
    ASN1bool_t setup;
    ASN1bool_t callProceeding;
    ASN1bool_t connect;
    ASN1bool_t alerting;
    ASN1bool_t information;
    ASN1bool_t releaseComplete;
    ASN1bool_t facility;
    ASN1bool_t progress;
    ASN1bool_t empty;
} UUIEsRequested;

typedef struct AdmissionRejectReason {
    ASN1choice_t choice;
#   define AdmissionRejectReason_calledPartyNotRegistered_chosen 1
#   define AdmissionRejectReason_invalidPermission_chosen 2
#   define AdmissionRejectReason_requestDenied_chosen 3
#   define AdmissionRejectReason_undefinedReason_chosen 4
#   define AdmissionRejectReason_callerNotRegistered_chosen 5
#   define AdmissionRejectReason_routeCallToGatekeeper_chosen 6
#   define invalidEndpointIdentifier_chosen 7
#   define AdmissionRejectReason_resourceUnavailable_chosen 8
#   define AdmissionRejectReason_securityDenial_chosen 9
#   define qosControlNotSupported_chosen 10
#   define incompleteAddress_chosen 11
} AdmissionRejectReason;

typedef struct BandRejectReason {
    ASN1choice_t choice;
#   define notBound_chosen 1
#   define invalidConferenceID_chosen 2
#   define BandRejectReason_invalidPermission_chosen 3
#   define insufficientResources_chosen 4
#   define BandRejectReason_invalidRevision_chosen 5
#   define BandRejectReason_undefinedReason_chosen 6
#   define BandRejectReason_securityDenial_chosen 7
} BandRejectReason;

typedef struct LocationRejectReason {
    ASN1choice_t choice;
#   define LocationRejectReason_notRegistered_chosen 1
#   define LocationRejectReason_invalidPermission_chosen 2
#   define LocationRejectReason_requestDenied_chosen 3
#   define LocationRejectReason_undefinedReason_chosen 4
#   define LocationRejectReason_securityDenial_chosen 5
} LocationRejectReason;

typedef struct DisengageReason {
    ASN1choice_t choice;
#   define forcedDrop_chosen 1
#   define normalDrop_chosen 2
#   define DisengageReason_undefinedReason_chosen 3
} DisengageReason;

typedef struct DisengageRejectReason {
    ASN1choice_t choice;
#   define DisengageRejectReason_notRegistered_chosen 1
#   define requestToDropOther_chosen 2
#   define DisengageRejectReason_securityDenial_chosen 3
} DisengageRejectReason;

typedef struct InfoRequestNakReason {
    ASN1choice_t choice;
#   define InfoRequestNakReason_notRegistered_chosen 1
#   define InfoRequestNakReason_securityDenial_chosen 2
#   define InfoRequestNakReason_undefinedReason_chosen 3
} InfoRequestNakReason;

typedef struct UnknownMessageResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define UnknownMessageResponse_tokens_present 0x80
    PUnknownMessageResponse_tokens tokens;
#   define UnknownMessageResponse_cryptoTokens_present 0x40
    PUnknownMessageResponse_cryptoTokens cryptoTokens;
#   define UnknownMessageResponse_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} UnknownMessageResponse;

typedef struct InfoRequestResponse_perCallInfo_Seq_tokens {
    PInfoRequestResponse_perCallInfo_Seq_tokens next;
    ClearToken value;
} InfoRequestResponse_perCallInfo_Seq_tokens_Element;

typedef struct ResourcesAvailableConfirm_tokens {
    PResourcesAvailableConfirm_tokens next;
    ClearToken value;
} ResourcesAvailableConfirm_tokens_Element;

typedef struct ResourcesAvailableIndicate_tokens {
    PResourcesAvailableIndicate_tokens next;
    ClearToken value;
} ResourcesAvailableIndicate_tokens_Element;

typedef struct RequestInProgress_tokens {
    PRequestInProgress_tokens next;
    ClearToken value;
} RequestInProgress_tokens_Element;

typedef struct UnknownMessageResponse_tokens {
    PUnknownMessageResponse_tokens next;
    ClearToken value;
} UnknownMessageResponse_tokens_Element;

typedef struct H225NonStandardMessage_tokens {
    PH225NonStandardMessage_tokens next;
    ClearToken value;
} H225NonStandardMessage_tokens_Element;

typedef struct InfoRequestNak_tokens {
    PInfoRequestNak_tokens next;
    ClearToken value;
} InfoRequestNak_tokens_Element;

typedef struct InfoRequestAck_tokens {
    PInfoRequestAck_tokens next;
    ClearToken value;
} InfoRequestAck_tokens_Element;

typedef struct InfoRequestResponse_tokens {
    PInfoRequestResponse_tokens next;
    ClearToken value;
} InfoRequestResponse_tokens_Element;

typedef struct InfoRequest_tokens {
    PInfoRequest_tokens next;
    ClearToken value;
} InfoRequest_tokens_Element;

typedef struct DisengageReject_tokens {
    PDisengageReject_tokens next;
    ClearToken value;
} DisengageReject_tokens_Element;

typedef struct DisengageConfirm_tokens {
    PDisengageConfirm_tokens next;
    ClearToken value;
} DisengageConfirm_tokens_Element;

typedef struct DisengageRequest_tokens {
    PDisengageRequest_tokens next;
    ClearToken value;
} DisengageRequest_tokens_Element;

typedef struct LocationReject_tokens {
    PLocationReject_tokens next;
    ClearToken value;
} LocationReject_tokens_Element;

typedef struct LocationConfirm_tokens {
    PLocationConfirm_tokens next;
    ClearToken value;
} LocationConfirm_tokens_Element;

typedef struct LocationRequest_tokens {
    PLocationRequest_tokens next;
    ClearToken value;
} LocationRequest_tokens_Element;

typedef struct BandwidthReject_tokens {
    PBandwidthReject_tokens next;
    ClearToken value;
} BandwidthReject_tokens_Element;

typedef struct BandwidthConfirm_tokens {
    PBandwidthConfirm_tokens next;
    ClearToken value;
} BandwidthConfirm_tokens_Element;

typedef struct BandwidthRequest_tokens {
    PBandwidthRequest_tokens next;
    ClearToken value;
} BandwidthRequest_tokens_Element;

typedef struct AdmissionReject_tokens {
    PAdmissionReject_tokens next;
    ClearToken value;
} AdmissionReject_tokens_Element;

typedef struct AdmissionConfirm_tokens {
    PAdmissionConfirm_tokens next;
    ClearToken value;
} AdmissionConfirm_tokens_Element;

typedef struct AdmissionRequest_tokens {
    PAdmissionRequest_tokens next;
    ClearToken value;
} AdmissionRequest_tokens_Element;

typedef struct UnregistrationReject_tokens {
    PUnregistrationReject_tokens next;
    ClearToken value;
} UnregistrationReject_tokens_Element;

typedef struct UnregistrationConfirm_tokens {
    PUnregistrationConfirm_tokens next;
    ClearToken value;
} UnregistrationConfirm_tokens_Element;

typedef struct UnregistrationRequest_tokens {
    PUnregistrationRequest_tokens next;
    ClearToken value;
} UnregistrationRequest_tokens_Element;

typedef struct RegistrationReject_tokens {
    PRegistrationReject_tokens next;
    ClearToken value;
} RegistrationReject_tokens_Element;

typedef struct RegistrationConfirm_tokens {
    PRegistrationConfirm_tokens next;
    ClearToken value;
} RegistrationConfirm_tokens_Element;

typedef struct RegistrationRequest_tokens {
    PRegistrationRequest_tokens next;
    ClearToken value;
} RegistrationRequest_tokens_Element;

typedef struct GatekeeperReject_tokens {
    PGatekeeperReject_tokens next;
    ClearToken value;
} GatekeeperReject_tokens_Element;

typedef struct GatekeeperConfirm_tokens {
    PGatekeeperConfirm_tokens next;
    ClearToken value;
} GatekeeperConfirm_tokens_Element;

typedef struct GatekeeperRequest_authenticationCapability {
    PGatekeeperRequest_authenticationCapability next;
    AuthenticationMechanism value;
} GatekeeperRequest_authenticationCapability_Element;

typedef struct GatekeeperRequest_tokens {
    PGatekeeperRequest_tokens next;
    ClearToken value;
} GatekeeperRequest_tokens_Element;

typedef struct Endpoint_tokens {
    PEndpoint_tokens next;
    ClearToken value;
} Endpoint_tokens_Element;

typedef struct Progress_UUIE_tokens {
    PProgress_UUIE_tokens next;
    ClearToken value;
} Progress_UUIE_tokens_Element;

typedef struct Facility_UUIE_tokens {
    PFacility_UUIE_tokens next;
    ClearToken value;
} Facility_UUIE_tokens_Element;

typedef struct Setup_UUIE_tokens {
    PSetup_UUIE_tokens next;
    ClearToken value;
} Setup_UUIE_tokens_Element;

typedef struct Connect_UUIE_tokens {
    PConnect_UUIE_tokens next;
    ClearToken value;
} Connect_UUIE_tokens_Element;

typedef struct CallProceeding_UUIE_tokens {
    PCallProceeding_UUIE_tokens next;
    ClearToken value;
} CallProceeding_UUIE_tokens_Element;

typedef struct Alerting_UUIE_tokens {
    PAlerting_UUIE_tokens next;
    ClearToken value;
} Alerting_UUIE_tokens_Element;

typedef struct SIGNED_EncodedGeneralToken {
    EncodedGeneralToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedGeneralToken;

typedef struct ENCRYPTED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1octetstring_t encryptedData;
} ENCRYPTED;

typedef struct HASHED {
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t hash;
} HASHED;

typedef struct SIGNED_EncodedPwdCertToken {
    EncodedPwdCertToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedPwdCertToken;

typedef struct Information_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Information_UUIE_callIdentifier_present 0x80
    CallIdentifier callIdentifier;
} Information_UUIE;

typedef struct ReleaseComplete_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ReleaseComplete_UUIE_reason_present 0x80
    ReleaseCompleteReason reason;
#   define ReleaseComplete_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
} ReleaseComplete_UUIE;

typedef struct VendorIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H221NonStandard vendor;
#   define productId_present 0x80
    struct VendorIdentifier_productId_productId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productId;
#   define versionId_present 0x40
    struct VendorIdentifier_versionId_versionId {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionId;
} VendorIdentifier;

typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct SecurityServiceMode {
    ASN1choice_t choice;
    union {
#	define SecurityServiceMode_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define SecurityServiceMode_none_chosen 2
#	define SecurityServiceMode_default_chosen 3
    } u;
} SecurityServiceMode;

typedef struct SecurityCapabilities {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SecurityCapabilities_nonStandard_present 0x80
    H225NonStandardParameter nonStandard;
    SecurityServiceMode encryption;
    SecurityServiceMode authenticaton;
    SecurityServiceMode integrity;
} SecurityCapabilities;

typedef struct H245Security {
    ASN1choice_t choice;
    union {
#	define H245Security_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define noSecurity_chosen 2
#	define H245Security_tls_chosen 3
	SecurityCapabilities tls;
#	define H245Security_ipsec_chosen 4
	SecurityCapabilities ipsec;
    } u;
} H245Security;

typedef struct QseriesOptions {
    ASN1bool_t q932Full;
    ASN1bool_t q951Full;
    ASN1bool_t q952Full;
    ASN1bool_t q953Full;
    ASN1bool_t q955Full;
    ASN1bool_t q956Full;
    ASN1bool_t q957Full;
    Q954Details q954Info;
} QseriesOptions;

typedef struct EncryptIntAlg {
    ASN1choice_t choice;
    union {
#	define EncryptIntAlg_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define isoAlgorithm_chosen 2
	ASN1objectidentifier_t isoAlgorithm;
    } u;
} EncryptIntAlg;

typedef struct NonIsoIntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define hMAC_MD5_chosen 1
#	define hMAC_iso10118_2_s_chosen 2
	EncryptIntAlg hMAC_iso10118_2_s;
#	define hMAC_iso10118_2_l_chosen 3
	EncryptIntAlg hMAC_iso10118_2_l;
#	define hMAC_iso10118_3_chosen 4
	ASN1objectidentifier_t hMAC_iso10118_3;
    } u;
} NonIsoIntegrityMechanism;

typedef struct IntegrityMechanism {
    ASN1choice_t choice;
    union {
#	define IntegrityMechanism_nonStandard_chosen 1
	H225NonStandardParameter nonStandard;
#	define digSig_chosen 2
#	define iso9797_chosen 3
	ASN1objectidentifier_t iso9797;
#	define nonIsoIM_chosen 4
	NonIsoIntegrityMechanism nonIsoIM;
    } u;
} IntegrityMechanism;

typedef ClearToken FastStartToken;

typedef struct EncodedFastStartToken {
    ASN1objectidentifier_t id;
    FastStartToken type;
} EncodedFastStartToken;

typedef struct DataRate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define DataRate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    BandWidth channelRate;
#   define channelMultiplier_present 0x40
    ASN1uint16_t channelMultiplier;
} DataRate;

typedef struct GatekeeperReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    GatekeeperRejectReason rejectReason;
#   define GatekeeperReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define GatekeeperReject_tokens_present 0x4000
    PGatekeeperReject_tokens tokens;
#   define GatekeeperReject_cryptoTokens_present 0x2000
    PGatekeeperReject_cryptoTokens cryptoTokens;
#   define GatekeeperReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} GatekeeperReject;

typedef struct RegistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    PRegistrationConfirm_callSignalAddress callSignalAddress;
#   define RegistrationConfirm_terminalAlias_present 0x40
    PRegistrationConfirm_terminalAlias terminalAlias;
#   define RegistrationConfirm_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    EndpointIdentifier endpointIdentifier;
#   define RegistrationConfirm_alternateGatekeeper_present 0x8000
    PRegistrationConfirm_alternateGatekeeper alternateGatekeeper;
#   define RegistrationConfirm_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationConfirm_tokens_present 0x2000
    PRegistrationConfirm_tokens tokens;
#   define RegistrationConfirm_cryptoTokens_present 0x1000
    PRegistrationConfirm_cryptoTokens cryptoTokens;
#   define RegistrationConfirm_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define RegistrationConfirm_willRespondToIRR_present 0x400
    ASN1bool_t willRespondToIRR;
#   define preGrantedARQ_present 0x200
    RegistrationConfirm_preGrantedARQ preGrantedARQ;
} RegistrationConfirm;

typedef struct RegistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RegistrationRejectReason rejectReason;
#   define RegistrationReject_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define RegistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define RegistrationReject_tokens_present 0x4000
    PRegistrationReject_tokens tokens;
#   define RegistrationReject_cryptoTokens_present 0x2000
    PRegistrationReject_cryptoTokens cryptoTokens;
#   define RegistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} RegistrationReject;

typedef struct UnregistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    PUnregistrationRequest_callSignalAddress callSignalAddress;
#   define UnregistrationRequest_endpointAlias_present 0x80
    PUnregistrationRequest_endpointAlias endpointAlias;
#   define UnregistrationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define UnregistrationRequest_endpointIdentifier_present 0x20
    EndpointIdentifier endpointIdentifier;
#   define UnregistrationRequest_alternateEndpoints_present 0x8000
    PUnregistrationRequest_alternateEndpoints alternateEndpoints;
#   define UnregistrationRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define UnregistrationRequest_tokens_present 0x2000
    PUnregistrationRequest_tokens tokens;
#   define UnregistrationRequest_cryptoTokens_present 0x1000
    PUnregistrationRequest_cryptoTokens cryptoTokens;
#   define UnregistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define UnregistrationRequest_reason_present 0x400
    UnregRequestReason reason;
} UnregistrationRequest;

typedef struct UnregistrationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define UnregistrationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationConfirm_tokens_present 0x8000
    PUnregistrationConfirm_tokens tokens;
#   define UnregistrationConfirm_cryptoTokens_present 0x4000
    PUnregistrationConfirm_cryptoTokens cryptoTokens;
#   define UnregistrationConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} UnregistrationConfirm;

typedef struct UnregistrationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    UnregRejectReason rejectReason;
#   define UnregistrationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define UnregistrationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define UnregistrationReject_tokens_present 0x4000
    PUnregistrationReject_tokens tokens;
#   define UnregistrationReject_cryptoTokens_present 0x2000
    PUnregistrationReject_cryptoTokens cryptoTokens;
#   define UnregistrationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} UnregistrationReject;

typedef struct AdmissionReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    AdmissionRejectReason rejectReason;
#   define AdmissionReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define AdmissionReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define AdmissionReject_tokens_present 0x4000
    PAdmissionReject_tokens tokens;
#   define AdmissionReject_cryptoTokens_present 0x2000
    PAdmissionReject_cryptoTokens cryptoTokens;
#   define AdmissionReject_callSignalAddress_present 0x1000
    PAdmissionReject_callSignalAddress callSignalAddress;
#   define AdmissionReject_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
} AdmissionReject;

typedef struct BandwidthRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
#   define callType_present 0x80
    CallType callType;
    BandWidth bandWidth;
#   define BandwidthRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define BandwidthRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define BandwidthRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define BandwidthRequest_tokens_present 0x2000
    PBandwidthRequest_tokens tokens;
#   define BandwidthRequest_cryptoTokens_present 0x1000
    PBandwidthRequest_cryptoTokens cryptoTokens;
#   define BandwidthRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define BandwidthRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} BandwidthRequest;

typedef struct BandwidthConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
#   define BandwidthConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthConfirm_tokens_present 0x8000
    PBandwidthConfirm_tokens tokens;
#   define BandwidthConfirm_cryptoTokens_present 0x4000
    PBandwidthConfirm_cryptoTokens cryptoTokens;
#   define BandwidthConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} BandwidthConfirm;

typedef struct BandwidthReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    BandRejectReason rejectReason;
    BandWidth allowedBandWidth;
#   define BandwidthReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define BandwidthReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define BandwidthReject_tokens_present 0x4000
    PBandwidthReject_tokens tokens;
#   define BandwidthReject_cryptoTokens_present 0x2000
    PBandwidthReject_cryptoTokens cryptoTokens;
#   define BandwidthReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} BandwidthReject;

typedef struct LocationReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    LocationRejectReason rejectReason;
#   define LocationReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define LocationReject_tokens_present 0x4000
    PLocationReject_tokens tokens;
#   define LocationReject_cryptoTokens_present 0x2000
    PLocationReject_cryptoTokens cryptoTokens;
#   define LocationReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} LocationReject;

typedef struct DisengageRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    EndpointIdentifier endpointIdentifier;
    ConferenceIdentifier conferenceID;
    CallReferenceValue callReferenceValue;
    DisengageReason disengageReason;
#   define DisengageRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define DisengageRequest_gatekeeperIdentifier_present 0x4000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define DisengageRequest_tokens_present 0x2000
    PDisengageRequest_tokens tokens;
#   define DisengageRequest_cryptoTokens_present 0x1000
    PDisengageRequest_cryptoTokens cryptoTokens;
#   define DisengageRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define DisengageRequest_answeredCall_present 0x400
    ASN1bool_t answeredCall;
} DisengageRequest;

typedef struct DisengageConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define DisengageConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageConfirm_tokens_present 0x8000
    PDisengageConfirm_tokens tokens;
#   define DisengageConfirm_cryptoTokens_present 0x4000
    PDisengageConfirm_cryptoTokens cryptoTokens;
#   define DisengageConfirm_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
} DisengageConfirm;

typedef struct DisengageReject {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    DisengageRejectReason rejectReason;
#   define DisengageReject_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define DisengageReject_altGKInfo_present 0x8000
    AltGKInfo altGKInfo;
#   define DisengageReject_tokens_present 0x4000
    PDisengageReject_tokens tokens;
#   define DisengageReject_cryptoTokens_present 0x2000
    PDisengageReject_cryptoTokens cryptoTokens;
#   define DisengageReject_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
} DisengageReject;

typedef struct InfoRequestAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestAck_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define InfoRequestAck_tokens_present 0x40
    PInfoRequestAck_tokens tokens;
#   define InfoRequestAck_cryptoTokens_present 0x20
    PInfoRequestAck_cryptoTokens cryptoTokens;
#   define InfoRequestAck_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} InfoRequestAck;

typedef struct InfoRequestNak {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define InfoRequestNak_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    InfoRequestNakReason nakReason;
#   define InfoRequestNak_altGKInfo_present 0x40
    AltGKInfo altGKInfo;
#   define InfoRequestNak_tokens_present 0x20
    PInfoRequestNak_tokens tokens;
#   define InfoRequestNak_cryptoTokens_present 0x10
    PInfoRequestNak_cryptoTokens cryptoTokens;
#   define InfoRequestNak_integrityCheckValue_present 0x8
    ICV integrityCheckValue;
} InfoRequestNak;

typedef struct H225NonStandardMessage {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    H225NonStandardParameter nonStandardData;
#   define H225NonStandardMessage_tokens_present 0x80
    PH225NonStandardMessage_tokens tokens;
#   define H225NonStandardMessage_cryptoTokens_present 0x40
    PH225NonStandardMessage_cryptoTokens cryptoTokens;
#   define H225NonStandardMessage_integrityCheckValue_present 0x20
    ICV integrityCheckValue;
} H225NonStandardMessage;

typedef struct RequestInProgress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
#   define RequestInProgress_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define RequestInProgress_tokens_present 0x40
    PRequestInProgress_tokens tokens;
#   define RequestInProgress_cryptoTokens_present 0x20
    PRequestInProgress_cryptoTokens cryptoTokens;
#   define RequestInProgress_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
    ASN1uint16_t delay;
} RequestInProgress;

typedef struct ResourcesAvailableIndicate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableIndicate_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    EndpointIdentifier endpointIdentifier;
    PResourcesAvailableIndicate_protocols protocols;
    ASN1bool_t almostOutOfResources;
#   define ResourcesAvailableIndicate_tokens_present 0x40
    PResourcesAvailableIndicate_tokens tokens;
#   define ResourcesAvailableIndicate_cryptoTokens_present 0x20
    PResourcesAvailableIndicate_cryptoTokens cryptoTokens;
#   define ResourcesAvailableIndicate_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableIndicate;

typedef struct ResourcesAvailableConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define ResourcesAvailableConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define ResourcesAvailableConfirm_tokens_present 0x40
    PResourcesAvailableConfirm_tokens tokens;
#   define ResourcesAvailableConfirm_cryptoTokens_present 0x20
    PResourcesAvailableConfirm_cryptoTokens cryptoTokens;
#   define ResourcesAvailableConfirm_integrityCheckValue_present 0x10
    ICV integrityCheckValue;
} ResourcesAvailableConfirm;

typedef struct GatekeeperConfirm_integrity {
    PGatekeeperConfirm_integrity next;
    IntegrityMechanism value;
} GatekeeperConfirm_integrity_Element;

typedef struct GatekeeperRequest_integrity {
    PGatekeeperRequest_integrity next;
    IntegrityMechanism value;
} GatekeeperRequest_integrity_Element;

typedef struct CryptoH323Token_cryptoGKPwdHash {
    GatekeeperIdentifier gatekeeperId;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoGKPwdHash;

typedef struct NonStandardProtocol_dataRatesSupported {
    PNonStandardProtocol_dataRatesSupported next;
    DataRate value;
} NonStandardProtocol_dataRatesSupported_Element;

typedef struct T120OnlyCaps_dataRatesSupported {
    PT120OnlyCaps_dataRatesSupported next;
    DataRate value;
} T120OnlyCaps_dataRatesSupported_Element;

typedef struct VoiceCaps_dataRatesSupported {
    PVoiceCaps_dataRatesSupported next;
    DataRate value;
} VoiceCaps_dataRatesSupported_Element;

typedef struct H324Caps_dataRatesSupported {
    PH324Caps_dataRatesSupported next;
    DataRate value;
} H324Caps_dataRatesSupported_Element;

typedef struct H323Caps_dataRatesSupported {
    PH323Caps_dataRatesSupported next;
    DataRate value;
} H323Caps_dataRatesSupported_Element;

typedef struct H322Caps_dataRatesSupported {
    PH322Caps_dataRatesSupported next;
    DataRate value;
} H322Caps_dataRatesSupported_Element;

typedef struct H321Caps_dataRatesSupported {
    PH321Caps_dataRatesSupported next;
    DataRate value;
} H321Caps_dataRatesSupported_Element;

typedef struct H320Caps_dataRatesSupported {
    PH320Caps_dataRatesSupported next;
    DataRate value;
} H320Caps_dataRatesSupported_Element;

typedef struct H310Caps_dataRatesSupported {
    PH310Caps_dataRatesSupported next;
    DataRate value;
} H310Caps_dataRatesSupported_Element;

typedef struct Setup_UUIE_h245SecurityCapability {
    PSetup_UUIE_h245SecurityCapability next;
    H245Security value;
} Setup_UUIE_h245SecurityCapability_Element;

typedef struct H323_UU_PDU_nonStandardControl {
    PH323_UU_PDU_nonStandardControl next;
    H225NonStandardParameter value;
} H323_UU_PDU_nonStandardControl_Element;

typedef struct CryptoToken_cryptoHashedToken {
    ASN1objectidentifier_t tokenOID;
    ClearToken hashedVals;
    HASHED token;
} CryptoToken_cryptoHashedToken;

typedef struct CryptoToken_cryptoSignedToken {
    ASN1objectidentifier_t tokenOID;
    SIGNED_EncodedGeneralToken token;
} CryptoToken_cryptoSignedToken;

typedef struct CryptoToken_cryptoEncryptedToken {
    ASN1objectidentifier_t tokenOID;
    ENCRYPTED token;
} CryptoToken_cryptoEncryptedToken;

typedef struct CryptoToken {
    ASN1choice_t choice;
    union {
#	define cryptoEncryptedToken_chosen 1
	CryptoToken_cryptoEncryptedToken cryptoEncryptedToken;
#	define cryptoSignedToken_chosen 2
	CryptoToken_cryptoSignedToken cryptoSignedToken;
#	define cryptoHashedToken_chosen 3
	CryptoToken_cryptoHashedToken cryptoHashedToken;
#	define cryptoPwdEncr_chosen 4
	ENCRYPTED cryptoPwdEncr;
    } u;
} CryptoToken;

typedef struct SIGNED_EncodedFastStartToken {
    EncodedFastStartToken toBeSigned;
    ASN1objectidentifier_t algorithmOID;
    Params paramS;
    ASN1bitstring_t signature;
} SIGNED_EncodedFastStartToken;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define TransportAddress_netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define TransportAddress_nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define TransportAddress_nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;

typedef struct GatewayInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define protocol_present 0x80
    PGatewayInfo_protocol protocol;
#   define GatewayInfo_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
} GatewayInfo;

typedef struct H310Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H310Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H310Caps_dataRatesSupported_present 0x8000
    PH310Caps_dataRatesSupported dataRatesSupported;
#   define H310Caps_supportedPrefixes_present 0x4000
    PH310Caps_supportedPrefixes supportedPrefixes;
} H310Caps;

typedef struct H320Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H320Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H320Caps_dataRatesSupported_present 0x8000
    PH320Caps_dataRatesSupported dataRatesSupported;
#   define H320Caps_supportedPrefixes_present 0x4000
    PH320Caps_supportedPrefixes supportedPrefixes;
} H320Caps;

typedef struct H321Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H321Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H321Caps_dataRatesSupported_present 0x8000
    PH321Caps_dataRatesSupported dataRatesSupported;
#   define H321Caps_supportedPrefixes_present 0x4000
    PH321Caps_supportedPrefixes supportedPrefixes;
} H321Caps;

typedef struct H322Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H322Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H322Caps_dataRatesSupported_present 0x8000
    PH322Caps_dataRatesSupported dataRatesSupported;
#   define H322Caps_supportedPrefixes_present 0x4000
    PH322Caps_supportedPrefixes supportedPrefixes;
} H322Caps;

typedef struct H323Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H323Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H323Caps_dataRatesSupported_present 0x8000
    PH323Caps_dataRatesSupported dataRatesSupported;
#   define H323Caps_supportedPrefixes_present 0x4000
    PH323Caps_supportedPrefixes supportedPrefixes;
} H323Caps;

typedef struct H324Caps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H324Caps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define H324Caps_dataRatesSupported_present 0x8000
    PH324Caps_dataRatesSupported dataRatesSupported;
#   define H324Caps_supportedPrefixes_present 0x4000
    PH324Caps_supportedPrefixes supportedPrefixes;
} H324Caps;

typedef struct VoiceCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define VoiceCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define VoiceCaps_dataRatesSupported_present 0x8000
    PVoiceCaps_dataRatesSupported dataRatesSupported;
#   define VoiceCaps_supportedPrefixes_present 0x4000
    PVoiceCaps_supportedPrefixes supportedPrefixes;
} VoiceCaps;

typedef struct T120OnlyCaps {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define T120OnlyCaps_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define T120OnlyCaps_dataRatesSupported_present 0x8000
    PT120OnlyCaps_dataRatesSupported dataRatesSupported;
#   define T120OnlyCaps_supportedPrefixes_present 0x4000
    PT120OnlyCaps_supportedPrefixes supportedPrefixes;
} T120OnlyCaps;

typedef struct NonStandardProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NonStandardProtocol_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define NonStandardProtocol_dataRatesSupported_present 0x40
    PNonStandardProtocol_dataRatesSupported dataRatesSupported;
    PNonStandardProtocol_supportedPrefixes supportedPrefixes;
} NonStandardProtocol;

typedef struct McuInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define McuInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} McuInfo;

typedef struct TerminalInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TerminalInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} TerminalInfo;

typedef struct GatekeeperInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GatekeeperInfo_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
} GatekeeperInfo;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct AlternateGK {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransportAddress rasAddress;
#   define AlternateGK_gatekeeperIdentifier_present 0x80
    GatekeeperIdentifier gatekeeperIdentifier;
    ASN1bool_t needToRegister;
    ASN1uint16_t priority;
} AlternateGK;

typedef struct GatekeeperConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define GatekeeperConfirm_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
    TransportAddress rasAddress;
#   define GatekeeperConfirm_alternateGatekeeper_present 0x8000
    PGatekeeperConfirm_alternateGatekeeper alternateGatekeeper;
#   define authenticationMode_present 0x4000
    AuthenticationMechanism authenticationMode;
#   define GatekeeperConfirm_tokens_present 0x2000
    PGatekeeperConfirm_tokens tokens;
#   define GatekeeperConfirm_cryptoTokens_present 0x1000
    PGatekeeperConfirm_cryptoTokens cryptoTokens;
#   define algorithmOID_present 0x800
    ASN1objectidentifier_t algorithmOID;
#   define GatekeeperConfirm_integrity_present 0x400
    PGatekeeperConfirm_integrity integrity;
#   define GatekeeperConfirm_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperConfirm;

typedef struct AdmissionRequest {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    CallType callType;
#   define callModel_present 0x80
    CallModel callModel;
    EndpointIdentifier endpointIdentifier;
#   define AdmissionRequest_destinationInfo_present 0x40
    PAdmissionRequest_destinationInfo destinationInfo;
#   define AdmissionRequest_destCallSignalAddress_present 0x20
    TransportAddress destCallSignalAddress;
#   define AdmissionRequest_destExtraCallInfo_present 0x10
    PAdmissionRequest_destExtraCallInfo destExtraCallInfo;
    PAdmissionRequest_srcInfo srcInfo;
#   define srcCallSignalAddress_present 0x8
    TransportAddress srcCallSignalAddress;
    BandWidth bandWidth;
    CallReferenceValue callReferenceValue;
#   define AdmissionRequest_nonStandardData_present 0x4
    H225NonStandardParameter nonStandardData;
#   define AdmissionRequest_callServices_present 0x2
    QseriesOptions callServices;
    ConferenceIdentifier conferenceID;
    ASN1bool_t activeMC;
    ASN1bool_t answerCall;
#   define AdmissionRequest_canMapAlias_present 0x8000
    ASN1bool_t canMapAlias;
#   define AdmissionRequest_callIdentifier_present 0x4000
    CallIdentifier callIdentifier;
#   define srcAlternatives_present 0x2000
    PAdmissionRequest_srcAlternatives srcAlternatives;
#   define destAlternatives_present 0x1000
    PAdmissionRequest_destAlternatives destAlternatives;
#   define AdmissionRequest_gatekeeperIdentifier_present 0x800
    GatekeeperIdentifier gatekeeperIdentifier;
#   define AdmissionRequest_tokens_present 0x400
    PAdmissionRequest_tokens tokens;
#   define AdmissionRequest_cryptoTokens_present 0x200
    PAdmissionRequest_cryptoTokens cryptoTokens;
#   define AdmissionRequest_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionRequest_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionRequest_willSupplyUUIEs_present 0x400000
    ASN1bool_t willSupplyUUIEs;
} AdmissionRequest;

typedef struct LocationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
#   define LocationRequest_endpointIdentifier_present 0x80
    EndpointIdentifier endpointIdentifier;
    PLocationRequest_destinationInfo destinationInfo;
#   define LocationRequest_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
    TransportAddress replyAddress;
#   define sourceInfo_present 0x8000
    PLocationRequest_sourceInfo sourceInfo;
#   define LocationRequest_canMapAlias_present 0x4000
    ASN1bool_t canMapAlias;
#   define LocationRequest_gatekeeperIdentifier_present 0x2000
    GatekeeperIdentifier gatekeeperIdentifier;
#   define LocationRequest_tokens_present 0x1000
    PLocationRequest_tokens tokens;
#   define LocationRequest_cryptoTokens_present 0x800
    PLocationRequest_cryptoTokens cryptoTokens;
#   define LocationRequest_integrityCheckValue_present 0x400
    ICV integrityCheckValue;
} LocationRequest;

typedef struct InfoRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    CallReferenceValue callReferenceValue;
#   define InfoRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define replyAddress_present 0x40
    TransportAddress replyAddress;
#   define InfoRequest_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequest_tokens_present 0x4000
    PInfoRequest_tokens tokens;
#   define InfoRequest_cryptoTokens_present 0x2000
    PInfoRequest_cryptoTokens cryptoTokens;
#   define InfoRequest_integrityCheckValue_present 0x1000
    ICV integrityCheckValue;
#   define InfoRequest_uuiesRequested_present 0x800
    UUIEsRequested uuiesRequested;
} InfoRequest;

typedef struct TransportChannelInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sendAddress_present 0x80
    TransportAddress sendAddress;
#   define recvAddress_present 0x40
    TransportAddress recvAddress;
} TransportChannelInfo;

typedef struct RTPSession {
    TransportChannelInfo rtpAddress;
    TransportChannelInfo rtcpAddress;
    ASN1ztcharstring_t cname;
    ASN1uint32_t ssrc;
    ASN1uint16_t sessionId;
    PRTPSession_associatedSessionIds associatedSessionIds;
} RTPSession;

typedef struct InfoRequestResponse_perCallInfo_Seq_data {
    PInfoRequestResponse_perCallInfo_Seq_data next;
    TransportChannelInfo value;
} InfoRequestResponse_perCallInfo_Seq_data_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_video {
    PInfoRequestResponse_perCallInfo_Seq_video next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_video_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq_audio {
    PInfoRequestResponse_perCallInfo_Seq_audio next;
    RTPSession value;
} InfoRequestResponse_perCallInfo_Seq_audio_Element;

typedef struct InfoRequestResponse_perCallInfo_Seq {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_perCallInfo_Seq_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    CallReferenceValue callReferenceValue;
    ConferenceIdentifier conferenceID;
#   define originator_present 0x40
    ASN1bool_t originator;
#   define audio_present 0x20
    PInfoRequestResponse_perCallInfo_Seq_audio audio;
#   define video_present 0x10
    PInfoRequestResponse_perCallInfo_Seq_video video;
#   define data_present 0x8
    PInfoRequestResponse_perCallInfo_Seq_data data;
    TransportChannelInfo h245;
    TransportChannelInfo callSignaling;
    CallType callType;
    BandWidth bandWidth;
    CallModel callModel;
#   define InfoRequestResponse_perCallInfo_Seq_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define InfoRequestResponse_perCallInfo_Seq_tokens_present 0x4000
    PInfoRequestResponse_perCallInfo_Seq_tokens tokens;
#   define InfoRequestResponse_perCallInfo_Seq_cryptoTokens_present 0x2000
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens cryptoTokens;
#   define substituteConfIDs_present 0x1000
    PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs substituteConfIDs;
#   define pdu_present 0x800
    PInfoRequestResponse_perCallInfo_Seq_pdu pdu;
} InfoRequestResponse_perCallInfo_Seq;

typedef struct InfoRequestResponse_perCallInfo {
    PInfoRequestResponse_perCallInfo next;
    InfoRequestResponse_perCallInfo_Seq value;
} InfoRequestResponse_perCallInfo_Element;

typedef struct InfoRequestResponse_callSignalAddress {
    PInfoRequestResponse_callSignalAddress next;
    TransportAddress value;
} InfoRequestResponse_callSignalAddress_Element;

typedef struct AdmissionReject_callSignalAddress {
    PAdmissionReject_callSignalAddress next;
    TransportAddress value;
} AdmissionReject_callSignalAddress_Element;

typedef struct UnregistrationRequest_callSignalAddress {
    PUnregistrationRequest_callSignalAddress next;
    TransportAddress value;
} UnregistrationRequest_callSignalAddress_Element;

typedef struct RegistrationConfirm_alternateGatekeeper {
    PRegistrationConfirm_alternateGatekeeper next;
    AlternateGK value;
} RegistrationConfirm_alternateGatekeeper_Element;

typedef struct RegistrationConfirm_callSignalAddress {
    PRegistrationConfirm_callSignalAddress next;
    TransportAddress value;
} RegistrationConfirm_callSignalAddress_Element;

typedef struct RegistrationRequest_rasAddress {
    PRegistrationRequest_rasAddress next;
    TransportAddress value;
} RegistrationRequest_rasAddress_Element;

typedef struct RegistrationRequest_callSignalAddress {
    PRegistrationRequest_callSignalAddress next;
    TransportAddress value;
} RegistrationRequest_callSignalAddress_Element;

typedef struct GatekeeperConfirm_alternateGatekeeper {
    PGatekeeperConfirm_alternateGatekeeper next;
    AlternateGK value;
} GatekeeperConfirm_alternateGatekeeper_Element;

typedef struct AltGKInfo_alternateGatekeeper {
    PAltGKInfo_alternateGatekeeper next;
    AlternateGK value;
} AltGKInfo_alternateGatekeeper_Element;

typedef struct Endpoint_rasAddress {
    PEndpoint_rasAddress next;
    TransportAddress value;
} Endpoint_rasAddress_Element;

typedef struct Endpoint_callSignalAddress {
    PEndpoint_callSignalAddress next;
    TransportAddress value;
} Endpoint_callSignalAddress_Element;

typedef struct EndpointType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EndpointType_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define vendor_present 0x40
    VendorIdentifier vendor;
#   define gatekeeper_present 0x20
    GatekeeperInfo gatekeeper;
#   define gateway_present 0x10
    GatewayInfo gateway;
#   define mcu_present 0x8
    McuInfo mcu;
#   define terminal_present 0x4
    TerminalInfo terminal;
    ASN1bool_t mc;
    ASN1bool_t undefinedNode;
} EndpointType;

typedef struct SupportedProtocols {
    ASN1choice_t choice;
    union {
#	define nonStandardData_chosen 1
	H225NonStandardParameter nonStandardData;
#	define h310_chosen 2
	H310Caps h310;
#	define h320_chosen 3
	H320Caps h320;
#	define h321_chosen 4
	H321Caps h321;
#	define h322_chosen 5
	H322Caps h322;
#	define h323_chosen 6
	H323Caps h323;
#	define h324_chosen 7
	H324Caps h324;
#	define voice_chosen 8
	VoiceCaps voice;
#	define t120_only_chosen 9
	T120OnlyCaps t120_only;
#	define nonStandardProtocol_chosen 10
	NonStandardProtocol nonStandardProtocol;
    } u;
} SupportedProtocols;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;

typedef struct Endpoint {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define Endpoint_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define aliasAddress_present 0x40
    PEndpoint_aliasAddress aliasAddress;
#   define Endpoint_callSignalAddress_present 0x20
    PEndpoint_callSignalAddress callSignalAddress;
#   define rasAddress_present 0x10
    PEndpoint_rasAddress rasAddress;
#   define endpointType_present 0x8
    EndpointType endpointType;
#   define Endpoint_tokens_present 0x4
    PEndpoint_tokens tokens;
#   define Endpoint_cryptoTokens_present 0x2
    PEndpoint_cryptoTokens cryptoTokens;
#   define priority_present 0x1
    ASN1uint16_t priority;
#   define Endpoint_remoteExtensionAddress_present 0x8000
    PEndpoint_remoteExtensionAddress remoteExtensionAddress;
#   define Endpoint_destExtraCallInfo_present 0x4000
    PEndpoint_destExtraCallInfo destExtraCallInfo;
} Endpoint;

typedef struct SupportedPrefix {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define SupportedPrefix_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    AliasAddress prefix;
} SupportedPrefix;

typedef struct GatekeeperRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define GatekeeperRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    TransportAddress rasAddress;
    EndpointType endpointType;
#   define GatekeeperRequest_gatekeeperIdentifier_present 0x40
    GatekeeperIdentifier gatekeeperIdentifier;
#   define GatekeeperRequest_callServices_present 0x20
    QseriesOptions callServices;
#   define GatekeeperRequest_endpointAlias_present 0x10
    PGatekeeperRequest_endpointAlias endpointAlias;
#   define GatekeeperRequest_alternateEndpoints_present 0x8000
    PGatekeeperRequest_alternateEndpoints alternateEndpoints;
#   define GatekeeperRequest_tokens_present 0x4000
    PGatekeeperRequest_tokens tokens;
#   define GatekeeperRequest_cryptoTokens_present 0x2000
    PGatekeeperRequest_cryptoTokens cryptoTokens;
#   define GatekeeperRequest_authenticationCapability_present 0x1000
    PGatekeeperRequest_authenticationCapability authenticationCapability;
#   define algorithmOIDs_present 0x800
    PGatekeeperRequest_algorithmOIDs algorithmOIDs;
#   define GatekeeperRequest_integrity_present 0x400
    PGatekeeperRequest_integrity integrity;
#   define GatekeeperRequest_integrityCheckValue_present 0x200
    ICV integrityCheckValue;
} GatekeeperRequest;

typedef struct RegistrationRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    ProtocolIdentifier protocolIdentifier;
#   define RegistrationRequest_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    ASN1bool_t discoveryComplete;
    PRegistrationRequest_callSignalAddress callSignalAddress;
    PRegistrationRequest_rasAddress rasAddress;
    EndpointType terminalType;
#   define RegistrationRequest_terminalAlias_present 0x40
    PRegistrationRequest_terminalAlias terminalAlias;
#   define RegistrationRequest_gatekeeperIdentifier_present 0x20
    GatekeeperIdentifier gatekeeperIdentifier;
    VendorIdentifier endpointVendor;
#   define RegistrationRequest_alternateEndpoints_present 0x8000
    PRegistrationRequest_alternateEndpoints alternateEndpoints;
#   define RegistrationRequest_timeToLive_present 0x4000
    TimeToLive timeToLive;
#   define RegistrationRequest_tokens_present 0x2000
    PRegistrationRequest_tokens tokens;
#   define RegistrationRequest_cryptoTokens_present 0x1000
    PRegistrationRequest_cryptoTokens cryptoTokens;
#   define RegistrationRequest_integrityCheckValue_present 0x800
    ICV integrityCheckValue;
#   define keepAlive_present 0x400
    ASN1bool_t keepAlive;
#   define RegistrationRequest_endpointIdentifier_present 0x200
    EndpointIdentifier endpointIdentifier;
#   define RegistrationRequest_willSupplyUUIEs_present 0x100
    ASN1bool_t willSupplyUUIEs;
} RegistrationRequest;

typedef struct AdmissionConfirm {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    RequestSeqNum requestSeqNum;
    BandWidth bandWidth;
    CallModel callModel;
    TransportAddress destCallSignalAddress;
#   define irrFrequency_present 0x80
    ASN1uint16_t irrFrequency;
#   define AdmissionConfirm_nonStandardData_present 0x40
    H225NonStandardParameter nonStandardData;
#   define AdmissionConfirm_destinationInfo_present 0x8000
    PAdmissionConfirm_destinationInfo destinationInfo;
#   define AdmissionConfirm_destExtraCallInfo_present 0x4000
    PAdmissionConfirm_destExtraCallInfo destExtraCallInfo;
#   define AdmissionConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define AdmissionConfirm_remoteExtensionAddress_present 0x1000
    PAdmissionConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define AdmissionConfirm_alternateEndpoints_present 0x800
    PAdmissionConfirm_alternateEndpoints alternateEndpoints;
#   define AdmissionConfirm_tokens_present 0x400
    PAdmissionConfirm_tokens tokens;
#   define AdmissionConfirm_cryptoTokens_present 0x200
    PAdmissionConfirm_cryptoTokens cryptoTokens;
#   define AdmissionConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
#   define AdmissionConfirm_transportQOS_present 0x800000
    TransportQOS transportQOS;
#   define AdmissionConfirm_willRespondToIRR_present 0x400000
    ASN1bool_t willRespondToIRR;
#   define AdmissionConfirm_uuiesRequested_present 0x200000
    UUIEsRequested uuiesRequested;
} AdmissionConfirm;

typedef struct LocationConfirm {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    RequestSeqNum requestSeqNum;
    TransportAddress callSignalAddress;
    TransportAddress rasAddress;
#   define LocationConfirm_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define LocationConfirm_destinationInfo_present 0x8000
    PLocationConfirm_destinationInfo destinationInfo;
#   define LocationConfirm_destExtraCallInfo_present 0x4000
    PLocationConfirm_destExtraCallInfo destExtraCallInfo;
#   define LocationConfirm_destinationType_present 0x2000
    EndpointType destinationType;
#   define LocationConfirm_remoteExtensionAddress_present 0x1000
    PLocationConfirm_remoteExtensionAddress remoteExtensionAddress;
#   define LocationConfirm_alternateEndpoints_present 0x800
    PLocationConfirm_alternateEndpoints alternateEndpoints;
#   define LocationConfirm_tokens_present 0x400
    PLocationConfirm_tokens tokens;
#   define LocationConfirm_cryptoTokens_present 0x200
    PLocationConfirm_cryptoTokens cryptoTokens;
#   define LocationConfirm_integrityCheckValue_present 0x100
    ICV integrityCheckValue;
} LocationConfirm;

typedef struct InfoRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define InfoRequestResponse_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
    RequestSeqNum requestSeqNum;
    EndpointType endpointType;
    EndpointIdentifier endpointIdentifier;
    TransportAddress rasAddress;
    PInfoRequestResponse_callSignalAddress callSignalAddress;
#   define InfoRequestResponse_endpointAlias_present 0x40
    PInfoRequestResponse_endpointAlias endpointAlias;
#   define perCallInfo_present 0x20
    PInfoRequestResponse_perCallInfo perCallInfo;
#   define InfoRequestResponse_tokens_present 0x8000
    PInfoRequestResponse_tokens tokens;
#   define InfoRequestResponse_cryptoTokens_present 0x4000
    PInfoRequestResponse_cryptoTokens cryptoTokens;
#   define InfoRequestResponse_integrityCheckValue_present 0x2000
    ICV integrityCheckValue;
#   define needResponse_present 0x1000
    ASN1bool_t needResponse;
} InfoRequestResponse;

typedef struct ResourcesAvailableIndicate_protocols {
    PResourcesAvailableIndicate_protocols next;
    SupportedProtocols value;
} ResourcesAvailableIndicate_protocols_Element;

typedef struct InfoRequestResponse_endpointAlias {
    PInfoRequestResponse_endpointAlias next;
    AliasAddress value;
} InfoRequestResponse_endpointAlias_Element;

typedef struct LocationConfirm_alternateEndpoints {
    PLocationConfirm_alternateEndpoints next;
    Endpoint value;
} LocationConfirm_alternateEndpoints_Element;

typedef struct LocationConfirm_remoteExtensionAddress {
    PLocationConfirm_remoteExtensionAddress next;
    AliasAddress value;
} LocationConfirm_remoteExtensionAddress_Element;

typedef struct LocationConfirm_destExtraCallInfo {
    PLocationConfirm_destExtraCallInfo next;
    AliasAddress value;
} LocationConfirm_destExtraCallInfo_Element;

typedef struct LocationConfirm_destinationInfo {
    PLocationConfirm_destinationInfo next;
    AliasAddress value;
} LocationConfirm_destinationInfo_Element;

typedef struct LocationRequest_sourceInfo {
    PLocationRequest_sourceInfo next;
    AliasAddress value;
} LocationRequest_sourceInfo_Element;

typedef struct LocationRequest_destinationInfo {
    PLocationRequest_destinationInfo next;
    AliasAddress value;
} LocationRequest_destinationInfo_Element;

typedef struct AdmissionConfirm_alternateEndpoints {
    PAdmissionConfirm_alternateEndpoints next;
    Endpoint value;
} AdmissionConfirm_alternateEndpoints_Element;

typedef struct AdmissionConfirm_remoteExtensionAddress {
    PAdmissionConfirm_remoteExtensionAddress next;
    AliasAddress value;
} AdmissionConfirm_remoteExtensionAddress_Element;

typedef struct AdmissionConfirm_destExtraCallInfo {
    PAdmissionConfirm_destExtraCallInfo next;
    AliasAddress value;
} AdmissionConfirm_destExtraCallInfo_Element;

typedef struct AdmissionConfirm_destinationInfo {
    PAdmissionConfirm_destinationInfo next;
    AliasAddress value;
} AdmissionConfirm_destinationInfo_Element;

typedef struct AdmissionRequest_destAlternatives {
    PAdmissionRequest_destAlternatives next;
    Endpoint value;
} AdmissionRequest_destAlternatives_Element;

typedef struct AdmissionRequest_srcAlternatives {
    PAdmissionRequest_srcAlternatives next;
    Endpoint value;
} AdmissionRequest_srcAlternatives_Element;

typedef struct AdmissionRequest_srcInfo {
    PAdmissionRequest_srcInfo next;
    AliasAddress value;
} AdmissionRequest_srcInfo_Element;

typedef struct AdmissionRequest_destExtraCallInfo {
    PAdmissionRequest_destExtraCallInfo next;
    AliasAddress value;
} AdmissionRequest_destExtraCallInfo_Element;

typedef struct AdmissionRequest_destinationInfo {
    PAdmissionRequest_destinationInfo next;
    AliasAddress value;
} AdmissionRequest_destinationInfo_Element;

typedef struct UnregistrationRequest_alternateEndpoints {
    PUnregistrationRequest_alternateEndpoints next;
    Endpoint value;
} UnregistrationRequest_alternateEndpoints_Element;

typedef struct UnregistrationRequest_endpointAlias {
    PUnregistrationRequest_endpointAlias next;
    AliasAddress value;
} UnregistrationRequest_endpointAlias_Element;

typedef struct RegistrationRejectReason_duplicateAlias {
    PRegistrationRejectReason_duplicateAlias next;
    AliasAddress value;
} RegistrationRejectReason_duplicateAlias_Element;

typedef struct RegistrationConfirm_terminalAlias {
    PRegistrationConfirm_terminalAlias next;
    AliasAddress value;
} RegistrationConfirm_terminalAlias_Element;

typedef struct RegistrationRequest_alternateEndpoints {
    PRegistrationRequest_alternateEndpoints next;
    Endpoint value;
} RegistrationRequest_alternateEndpoints_Element;

typedef struct RegistrationRequest_terminalAlias {
    PRegistrationRequest_terminalAlias next;
    AliasAddress value;
} RegistrationRequest_terminalAlias_Element;

typedef struct GatekeeperRequest_alternateEndpoints {
    PGatekeeperRequest_alternateEndpoints next;
    Endpoint value;
} GatekeeperRequest_alternateEndpoints_Element;

typedef struct GatekeeperRequest_endpointAlias {
    PGatekeeperRequest_endpointAlias next;
    AliasAddress value;
} GatekeeperRequest_endpointAlias_Element;

typedef struct CryptoH323Token_cryptoEPPwdHash {
    AliasAddress alias;
    TimeStamp timeStamp;
    HASHED token;
} CryptoH323Token_cryptoEPPwdHash;

typedef struct Endpoint_destExtraCallInfo {
    PEndpoint_destExtraCallInfo next;
    AliasAddress value;
} Endpoint_destExtraCallInfo_Element;

typedef struct Endpoint_remoteExtensionAddress {
    PEndpoint_remoteExtensionAddress next;
    AliasAddress value;
} Endpoint_remoteExtensionAddress_Element;

typedef struct Endpoint_aliasAddress {
    PEndpoint_aliasAddress next;
    AliasAddress value;
} Endpoint_aliasAddress_Element;

typedef struct NonStandardProtocol_supportedPrefixes {
    PNonStandardProtocol_supportedPrefixes next;
    SupportedPrefix value;
} NonStandardProtocol_supportedPrefixes_Element;

typedef struct T120OnlyCaps_supportedPrefixes {
    PT120OnlyCaps_supportedPrefixes next;
    SupportedPrefix value;
} T120OnlyCaps_supportedPrefixes_Element;

typedef struct VoiceCaps_supportedPrefixes {
    PVoiceCaps_supportedPrefixes next;
    SupportedPrefix value;
} VoiceCaps_supportedPrefixes_Element;

typedef struct H324Caps_supportedPrefixes {
    PH324Caps_supportedPrefixes next;
    SupportedPrefix value;
} H324Caps_supportedPrefixes_Element;

typedef struct H323Caps_supportedPrefixes {
    PH323Caps_supportedPrefixes next;
    SupportedPrefix value;
} H323Caps_supportedPrefixes_Element;

typedef struct H322Caps_supportedPrefixes {
    PH322Caps_supportedPrefixes next;
    SupportedPrefix value;
} H322Caps_supportedPrefixes_Element;

typedef struct H321Caps_supportedPrefixes {
    PH321Caps_supportedPrefixes next;
    SupportedPrefix value;
} H321Caps_supportedPrefixes_Element;

typedef struct H320Caps_supportedPrefixes {
    PH320Caps_supportedPrefixes next;
    SupportedPrefix value;
} H320Caps_supportedPrefixes_Element;

typedef struct H310Caps_supportedPrefixes {
    PH310Caps_supportedPrefixes next;
    SupportedPrefix value;
} H310Caps_supportedPrefixes_Element;

typedef struct GatewayInfo_protocol {
    PGatewayInfo_protocol next;
    SupportedProtocols value;
} GatewayInfo_protocol_Element;

typedef struct Facility_UUIE_destExtraCallInfo {
    PFacility_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Facility_UUIE_destExtraCallInfo_Element;

typedef struct Facility_UUIE_alternativeAliasAddress {
    PFacility_UUIE_alternativeAliasAddress next;
    AliasAddress value;
} Facility_UUIE_alternativeAliasAddress_Element;

typedef struct Setup_UUIE_destExtraCallInfo {
    PSetup_UUIE_destExtraCallInfo next;
    AliasAddress value;
} Setup_UUIE_destExtraCallInfo_Element;

typedef struct Setup_UUIE_destinationAddress {
    PSetup_UUIE_destinationAddress next;
    AliasAddress value;
} Setup_UUIE_destinationAddress_Element;

typedef struct Setup_UUIE_sourceAddress {
    PSetup_UUIE_sourceAddress next;
    AliasAddress value;
} Setup_UUIE_sourceAddress_Element;

typedef struct Alerting_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Alerting_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define Alerting_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Alerting_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Alerting_UUIE_tokens_present 0x2000
    PAlerting_UUIE_tokens tokens;
#   define Alerting_UUIE_cryptoTokens_present 0x1000
    PAlerting_UUIE_cryptoTokens cryptoTokens;
#   define Alerting_UUIE_fastStart_present 0x800
    PAlerting_UUIE_fastStart fastStart;
} Alerting_UUIE;

typedef struct CallProceeding_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define CallProceeding_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define CallProceeding_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define CallProceeding_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define CallProceeding_UUIE_tokens_present 0x2000
    PCallProceeding_UUIE_tokens tokens;
#   define CallProceeding_UUIE_cryptoTokens_present 0x1000
    PCallProceeding_UUIE_cryptoTokens cryptoTokens;
#   define CallProceeding_UUIE_fastStart_present 0x800
    PCallProceeding_UUIE_fastStart fastStart;
} CallProceeding_UUIE;

typedef struct Connect_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Connect_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    EndpointType destinationInfo;
    ConferenceIdentifier conferenceID;
#   define Connect_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Connect_UUIE_h245SecurityMode_present 0x4000
    H245Security h245SecurityMode;
#   define Connect_UUIE_tokens_present 0x2000
    PConnect_UUIE_tokens tokens;
#   define Connect_UUIE_cryptoTokens_present 0x1000
    PConnect_UUIE_cryptoTokens cryptoTokens;
#   define Connect_UUIE_fastStart_present 0x800
    PConnect_UUIE_fastStart fastStart;
} Connect_UUIE;

typedef struct Setup_UUIE {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
    ProtocolIdentifier protocolIdentifier;
#   define Setup_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
#   define sourceAddress_present 0x40
    PSetup_UUIE_sourceAddress sourceAddress;
    EndpointType sourceInfo;
#   define destinationAddress_present 0x20
    PSetup_UUIE_destinationAddress destinationAddress;
#   define Setup_UUIE_destCallSignalAddress_present 0x10
    TransportAddress destCallSignalAddress;
#   define Setup_UUIE_destExtraCallInfo_present 0x8
    PSetup_UUIE_destExtraCallInfo destExtraCallInfo;
#   define destExtraCRV_present 0x4
    PSetup_UUIE_destExtraCRV destExtraCRV;
    ASN1bool_t activeMC;
    ConferenceIdentifier conferenceID;
    Setup_UUIE_conferenceGoal conferenceGoal;
#   define Setup_UUIE_callServices_present 0x2
    QseriesOptions callServices;
    CallType callType;
#   define sourceCallSignalAddress_present 0x8000
    TransportAddress sourceCallSignalAddress;
#   define Setup_UUIE_remoteExtensionAddress_present 0x4000
    AliasAddress remoteExtensionAddress;
#   define Setup_UUIE_callIdentifier_present 0x2000
    CallIdentifier callIdentifier;
#   define h245SecurityCapability_present 0x1000
    PSetup_UUIE_h245SecurityCapability h245SecurityCapability;
#   define Setup_UUIE_tokens_present 0x800
    PSetup_UUIE_tokens tokens;
#   define Setup_UUIE_cryptoTokens_present 0x400
    PSetup_UUIE_cryptoTokens cryptoTokens;
#   define Setup_UUIE_fastStart_present 0x200
    PSetup_UUIE_fastStart fastStart;
#   define mediaWaitForConnect_present 0x100
    ASN1bool_t mediaWaitForConnect;
#   define canOverlapSend_present 0x800000
    ASN1bool_t canOverlapSend;
} Setup_UUIE;

typedef struct Facility_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ProtocolIdentifier protocolIdentifier;
#   define alternativeAddress_present 0x80
    TransportAddress alternativeAddress;
#   define alternativeAliasAddress_present 0x40
    PFacility_UUIE_alternativeAliasAddress alternativeAliasAddress;
#   define Facility_UUIE_conferenceID_present 0x20
    ConferenceIdentifier conferenceID;
    FacilityReason reason;
#   define Facility_UUIE_callIdentifier_present 0x8000
    CallIdentifier callIdentifier;
#   define Facility_UUIE_destExtraCallInfo_present 0x4000
    PFacility_UUIE_destExtraCallInfo destExtraCallInfo;
#   define Facility_UUIE_remoteExtensionAddress_present 0x2000
    AliasAddress remoteExtensionAddress;
#   define Facility_UUIE_tokens_present 0x1000
    PFacility_UUIE_tokens tokens;
#   define Facility_UUIE_cryptoTokens_present 0x800
    PFacility_UUIE_cryptoTokens cryptoTokens;
#   define conferences_present 0x400
    PFacility_UUIE_conferences conferences;
#   define Facility_UUIE_h245Address_present 0x200
    TransportAddress h245Address;
#   define Facility_UUIE_fastStart_present 0x100
    PFacility_UUIE_fastStart fastStart;
} Facility_UUIE;

typedef struct ConferenceList {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceList_conferenceID_present 0x80
    ConferenceIdentifier conferenceID;
#   define conferenceAlias_present 0x40
    AliasAddress conferenceAlias;
#   define ConferenceList_nonStandardData_present 0x20
    H225NonStandardParameter nonStandardData;
} ConferenceList;

typedef struct Progress_UUIE {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    EndpointType destinationInfo;
#   define Progress_UUIE_h245Address_present 0x80
    TransportAddress h245Address;
    CallIdentifier callIdentifier;
#   define Progress_UUIE_h245SecurityMode_present 0x40
    H245Security h245SecurityMode;
#   define Progress_UUIE_tokens_present 0x20
    PProgress_UUIE_tokens tokens;
#   define Progress_UUIE_cryptoTokens_present 0x10
    PProgress_UUIE_cryptoTokens cryptoTokens;
#   define Progress_UUIE_fastStart_present 0x8
    PProgress_UUIE_fastStart fastStart;
} Progress_UUIE;

typedef struct CryptoH323Token {
    ASN1choice_t choice;
    union {
#	define cryptoEPPwdHash_chosen 1
	CryptoH323Token_cryptoEPPwdHash cryptoEPPwdHash;
#	define cryptoGKPwdHash_chosen 2
	CryptoH323Token_cryptoGKPwdHash cryptoGKPwdHash;
#	define cryptoEPPwdEncr_chosen 3
	ENCRYPTED cryptoEPPwdEncr;
#	define cryptoGKPwdEncr_chosen 4
	ENCRYPTED cryptoGKPwdEncr;
#	define cryptoEPCert_chosen 5
	SIGNED_EncodedPwdCertToken cryptoEPCert;
#	define cryptoGKCert_chosen 6
	SIGNED_EncodedPwdCertToken cryptoGKCert;
#	define cryptoFastStart_chosen 7
	SIGNED_EncodedFastStartToken cryptoFastStart;
#	define nestedcryptoToken_chosen 8
	CryptoToken nestedcryptoToken;
    } u;
} CryptoH323Token;

typedef struct RasMessage {
    ASN1choice_t choice;
    union {
#	define gatekeeperRequest_chosen 1
	GatekeeperRequest gatekeeperRequest;
#	define gatekeeperConfirm_chosen 2
	GatekeeperConfirm gatekeeperConfirm;
#	define gatekeeperReject_chosen 3
	GatekeeperReject gatekeeperReject;
#	define registrationRequest_chosen 4
	RegistrationRequest registrationRequest;
#	define registrationConfirm_chosen 5
	RegistrationConfirm registrationConfirm;
#	define registrationReject_chosen 6
	RegistrationReject registrationReject;
#	define unregistrationRequest_chosen 7
	UnregistrationRequest unregistrationRequest;
#	define unregistrationConfirm_chosen 8
	UnregistrationConfirm unregistrationConfirm;
#	define unregistrationReject_chosen 9
	UnregistrationReject unregistrationReject;
#	define admissionRequest_chosen 10
	AdmissionRequest admissionRequest;
#	define admissionConfirm_chosen 11
	AdmissionConfirm admissionConfirm;
#	define admissionReject_chosen 12
	AdmissionReject admissionReject;
#	define bandwidthRequest_chosen 13
	BandwidthRequest bandwidthRequest;
#	define bandwidthConfirm_chosen 14
	BandwidthConfirm bandwidthConfirm;
#	define bandwidthReject_chosen 15
	BandwidthReject bandwidthReject;
#	define disengageRequest_chosen 16
	DisengageRequest disengageRequest;
#	define disengageConfirm_chosen 17
	DisengageConfirm disengageConfirm;
#	define disengageReject_chosen 18
	DisengageReject disengageReject;
#	define locationRequest_chosen 19
	LocationRequest locationRequest;
#	define locationConfirm_chosen 20
	LocationConfirm locationConfirm;
#	define locationReject_chosen 21
	LocationReject locationReject;
#	define infoRequest_chosen 22
	InfoRequest infoRequest;
#	define infoRequestResponse_chosen 23
	InfoRequestResponse infoRequestResponse;
#	define nonStandardMessage_chosen 24
	H225NonStandardMessage nonStandardMessage;
#	define unknownMessageResponse_chosen 25
	UnknownMessageResponse unknownMessageResponse;
#	define requestInProgress_chosen 26
	RequestInProgress requestInProgress;
#	define resourcesAvailableIndicate_chosen 27
	ResourcesAvailableIndicate resourcesAvailableIndicate;
#	define resourcesAvailableConfirm_chosen 28
	ResourcesAvailableConfirm resourcesAvailableConfirm;
#	define infoRequestAck_chosen 29
	InfoRequestAck infoRequestAck;
#	define infoRequestNak_chosen 30
	InfoRequestNak infoRequestNak;
    } u;
} RasMessage;
#define RasMessage_PDU 0
#define SIZE_H225ASN_Module_PDU_0 sizeof(RasMessage)

typedef struct InfoRequestResponse_perCallInfo_Seq_cryptoTokens {
    PInfoRequestResponse_perCallInfo_Seq_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_perCallInfo_Seq_cryptoTokens_Element;

typedef struct ResourcesAvailableConfirm_cryptoTokens {
    PResourcesAvailableConfirm_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableConfirm_cryptoTokens_Element;

typedef struct ResourcesAvailableIndicate_cryptoTokens {
    PResourcesAvailableIndicate_cryptoTokens next;
    CryptoH323Token value;
} ResourcesAvailableIndicate_cryptoTokens_Element;

typedef struct RequestInProgress_cryptoTokens {
    PRequestInProgress_cryptoTokens next;
    CryptoH323Token value;
} RequestInProgress_cryptoTokens_Element;

typedef struct UnknownMessageResponse_cryptoTokens {
    PUnknownMessageResponse_cryptoTokens next;
    CryptoH323Token value;
} UnknownMessageResponse_cryptoTokens_Element;

typedef struct H225NonStandardMessage_cryptoTokens {
    PH225NonStandardMessage_cryptoTokens next;
    CryptoH323Token value;
} H225NonStandardMessage_cryptoTokens_Element;

typedef struct InfoRequestNak_cryptoTokens {
    PInfoRequestNak_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestNak_cryptoTokens_Element;

typedef struct InfoRequestAck_cryptoTokens {
    PInfoRequestAck_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestAck_cryptoTokens_Element;

typedef struct InfoRequestResponse_cryptoTokens {
    PInfoRequestResponse_cryptoTokens next;
    CryptoH323Token value;
} InfoRequestResponse_cryptoTokens_Element;

typedef struct InfoRequest_cryptoTokens {
    PInfoRequest_cryptoTokens next;
    CryptoH323Token value;
} InfoRequest_cryptoTokens_Element;

typedef struct DisengageReject_cryptoTokens {
    PDisengageReject_cryptoTokens next;
    CryptoH323Token value;
} DisengageReject_cryptoTokens_Element;

typedef struct DisengageConfirm_cryptoTokens {
    PDisengageConfirm_cryptoTokens next;
    CryptoH323Token value;
} DisengageConfirm_cryptoTokens_Element;

typedef struct DisengageRequest_cryptoTokens {
    PDisengageRequest_cryptoTokens next;
    CryptoH323Token value;
} DisengageRequest_cryptoTokens_Element;

typedef struct LocationReject_cryptoTokens {
    PLocationReject_cryptoTokens next;
    CryptoH323Token value;
} LocationReject_cryptoTokens_Element;

typedef struct LocationConfirm_cryptoTokens {
    PLocationConfirm_cryptoTokens next;
    CryptoH323Token value;
} LocationConfirm_cryptoTokens_Element;

typedef struct LocationRequest_cryptoTokens {
    PLocationRequest_cryptoTokens next;
    CryptoH323Token value;
} LocationRequest_cryptoTokens_Element;

typedef struct BandwidthReject_cryptoTokens {
    PBandwidthReject_cryptoTokens next;
    CryptoH323Token value;
} BandwidthReject_cryptoTokens_Element;

typedef struct BandwidthConfirm_cryptoTokens {
    PBandwidthConfirm_cryptoTokens next;
    CryptoH323Token value;
} BandwidthConfirm_cryptoTokens_Element;

typedef struct BandwidthRequest_cryptoTokens {
    PBandwidthRequest_cryptoTokens next;
    CryptoH323Token value;
} BandwidthRequest_cryptoTokens_Element;

typedef struct AdmissionReject_cryptoTokens {
    PAdmissionReject_cryptoTokens next;
    CryptoH323Token value;
} AdmissionReject_cryptoTokens_Element;

typedef struct AdmissionConfirm_cryptoTokens {
    PAdmissionConfirm_cryptoTokens next;
    CryptoH323Token value;
} AdmissionConfirm_cryptoTokens_Element;

typedef struct AdmissionRequest_cryptoTokens {
    PAdmissionRequest_cryptoTokens next;
    CryptoH323Token value;
} AdmissionRequest_cryptoTokens_Element;

typedef struct UnregistrationReject_cryptoTokens {
    PUnregistrationReject_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationReject_cryptoTokens_Element;

typedef struct UnregistrationConfirm_cryptoTokens {
    PUnregistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationConfirm_cryptoTokens_Element;

typedef struct UnregistrationRequest_cryptoTokens {
    PUnregistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} UnregistrationRequest_cryptoTokens_Element;

typedef struct RegistrationReject_cryptoTokens {
    PRegistrationReject_cryptoTokens next;
    CryptoH323Token value;
} RegistrationReject_cryptoTokens_Element;

typedef struct RegistrationConfirm_cryptoTokens {
    PRegistrationConfirm_cryptoTokens next;
    CryptoH323Token value;
} RegistrationConfirm_cryptoTokens_Element;

typedef struct RegistrationRequest_cryptoTokens {
    PRegistrationRequest_cryptoTokens next;
    CryptoH323Token value;
} RegistrationRequest_cryptoTokens_Element;

typedef struct GatekeeperReject_cryptoTokens {
    PGatekeeperReject_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperReject_cryptoTokens_Element;

typedef struct GatekeeperConfirm_cryptoTokens {
    PGatekeeperConfirm_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperConfirm_cryptoTokens_Element;

typedef struct GatekeeperRequest_cryptoTokens {
    PGatekeeperRequest_cryptoTokens next;
    CryptoH323Token value;
} GatekeeperRequest_cryptoTokens_Element;

typedef struct Endpoint_cryptoTokens {
    PEndpoint_cryptoTokens next;
    CryptoH323Token value;
} Endpoint_cryptoTokens_Element;

typedef struct Progress_UUIE_cryptoTokens {
    PProgress_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Progress_UUIE_cryptoTokens_Element;

typedef struct Facility_UUIE_conferences {
    PFacility_UUIE_conferences next;
    ConferenceList value;
} Facility_UUIE_conferences_Element;

typedef struct Facility_UUIE_cryptoTokens {
    PFacility_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Facility_UUIE_cryptoTokens_Element;

typedef struct Setup_UUIE_cryptoTokens {
    PSetup_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Setup_UUIE_cryptoTokens_Element;

typedef struct Connect_UUIE_cryptoTokens {
    PConnect_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Connect_UUIE_cryptoTokens_Element;

typedef struct CallProceeding_UUIE_cryptoTokens {
    PCallProceeding_UUIE_cryptoTokens next;
    CryptoH323Token value;
} CallProceeding_UUIE_cryptoTokens_Element;

typedef struct Alerting_UUIE_cryptoTokens {
    PAlerting_UUIE_cryptoTokens next;
    CryptoH323Token value;
} Alerting_UUIE_cryptoTokens_Element;

typedef struct H323_UU_PDU_h323_message_body {
    ASN1choice_t choice;
    union {
#	define setup_chosen 1
	Setup_UUIE setup;
#	define callProceeding_chosen 2
	CallProceeding_UUIE callProceeding;
#	define connect_chosen 3
	Connect_UUIE connect;
#	define alerting_chosen 4
	Alerting_UUIE alerting;
#	define information_chosen 5
	Information_UUIE information;
#	define releaseComplete_chosen 6
	ReleaseComplete_UUIE releaseComplete;
#	define facility_chosen 7
	Facility_UUIE facility;
#	define progress_chosen 8
	Progress_UUIE progress;
#	define empty_chosen 9
    } u;
} H323_UU_PDU_h323_message_body;

typedef struct H323_UU_PDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    H323_UU_PDU_h323_message_body h323_message_body;
#   define H323_UU_PDU_nonStandardData_present 0x80
    H225NonStandardParameter nonStandardData;
#   define h4501SupplementaryService_present 0x8000
    PH323_UU_PDU_h4501SupplementaryService h4501SupplementaryService;
#   define h245Tunneling_present 0x4000
    ASN1bool_t h245Tunneling;
#   define h245Control_present 0x2000
    PH323_UU_PDU_h245Control h245Control;
#   define nonStandardControl_present 0x1000
    PH323_UU_PDU_nonStandardControl nonStandardControl;
} H323_UU_PDU;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu_Seq {
    H323_UU_PDU h323pdu;
    ASN1bool_t sent;
} InfoRequestResponse_perCallInfo_Seq_pdu_Seq;

typedef struct InfoRequestResponse_perCallInfo_Seq_pdu {
    PInfoRequestResponse_perCallInfo_Seq_pdu next;
    InfoRequestResponse_perCallInfo_Seq_pdu_Seq value;
} InfoRequestResponse_perCallInfo_Seq_pdu_Element;

typedef struct H323_UserInformation {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H323_UU_PDU h323_uu_pdu;
#   define user_data_present 0x80
    H323_UserInformation_user_data user_data;
} H323_UserInformation;
#define H323_UserInformation_PDU 1
#define SIZE_H225ASN_Module_PDU_1 sizeof(H323_UserInformation)


extern ASN1module_t H225ASN_Module;
extern void ASN1CALL H225ASN_Module_Startup(void);
extern void ASN1CALL H225ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_substituteConfIDs_ElmFn(PInfoRequestResponse_perCallInfo_Seq_substituteConfIDs val);
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_RTPSession_associatedSessionIds_ElmFn(ASN1encoding_t enc, PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Dec_RTPSession_associatedSessionIds_ElmFn(ASN1decoding_t dec, PRTPSession_associatedSessionIds val);
	extern void ASN1CALL ASN1Free_RTPSession_associatedSessionIds_ElmFn(PRTPSession_associatedSessionIds val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_algorithmOIDs_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_algorithmOIDs val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_algorithmOIDs_ElmFn(PGatekeeperRequest_algorithmOIDs val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PProgress_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_fastStart_ElmFn(PProgress_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PFacility_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_fastStart_ElmFn(PFacility_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PSetup_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_fastStart_ElmFn(PSetup_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCRV_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCRV_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCRV val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCRV_ElmFn(PSetup_UUIE_destExtraCRV val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PConnect_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_fastStart_ElmFn(PConnect_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_fastStart_ElmFn(PCallProceeding_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_fastStart_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_fastStart_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_fastStart val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_fastStart_ElmFn(PAlerting_UUIE_fastStart val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h245Control_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h245Control_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h245Control val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h245Control_ElmFn(PH323_UU_PDU_h245Control val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_h4501SupplementaryService_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_h4501SupplementaryService val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_h4501SupplementaryService_ElmFn(PH323_UU_PDU_h4501SupplementaryService val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_tokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_tokens_ElmFn(PResourcesAvailableConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_tokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_tokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_tokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_tokens_ElmFn(PResourcesAvailableIndicate_tokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_tokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_tokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_tokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_tokens_ElmFn(PRequestInProgress_tokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_tokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_tokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_tokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_tokens_ElmFn(PUnknownMessageResponse_tokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_tokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_tokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_tokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_tokens_ElmFn(PH225NonStandardMessage_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_tokens_ElmFn(PInfoRequestNak_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_tokens_ElmFn(PInfoRequestAck_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_tokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_tokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_tokens_ElmFn(PInfoRequestResponse_tokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_tokens_ElmFn(ASN1encoding_t enc, PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_tokens_ElmFn(ASN1decoding_t dec, PInfoRequest_tokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_tokens_ElmFn(PInfoRequest_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_tokens_ElmFn(ASN1encoding_t enc, PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_tokens_ElmFn(ASN1decoding_t dec, PDisengageReject_tokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_tokens_ElmFn(PDisengageReject_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_tokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_tokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_tokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_tokens_ElmFn(PDisengageConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_tokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_tokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_tokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_tokens_ElmFn(PDisengageRequest_tokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_tokens_ElmFn(ASN1encoding_t enc, PLocationReject_tokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_tokens_ElmFn(ASN1decoding_t dec, PLocationReject_tokens val);
	extern void ASN1CALL ASN1Free_LocationReject_tokens_ElmFn(PLocationReject_tokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_tokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_tokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_tokens_ElmFn(PLocationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_tokens_ElmFn(ASN1encoding_t enc, PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_tokens_ElmFn(ASN1decoding_t dec, PLocationRequest_tokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_tokens_ElmFn(PLocationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_tokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_tokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_tokens_ElmFn(PBandwidthReject_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_tokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_tokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_tokens_ElmFn(PBandwidthConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_tokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_tokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_tokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_tokens_ElmFn(PBandwidthRequest_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_tokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_tokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_tokens_ElmFn(PAdmissionReject_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_tokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_tokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_tokens_ElmFn(PAdmissionConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_tokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_tokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_tokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_tokens_ElmFn(PAdmissionRequest_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_tokens_ElmFn(PUnregistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_tokens_ElmFn(PUnregistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_tokens_ElmFn(PUnregistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_tokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_tokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_tokens_ElmFn(PRegistrationReject_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_tokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_tokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_tokens_ElmFn(PRegistrationConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_tokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_tokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_tokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_tokens_ElmFn(PRegistrationRequest_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_tokens_ElmFn(PGatekeeperReject_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_tokens_ElmFn(PGatekeeperConfirm_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_authenticationCapability_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_authenticationCapability_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_authenticationCapability val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_authenticationCapability_ElmFn(PGatekeeperRequest_authenticationCapability val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_tokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_tokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_tokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_tokens_ElmFn(PGatekeeperRequest_tokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_tokens_ElmFn(ASN1encoding_t enc, PEndpoint_tokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_tokens_ElmFn(ASN1decoding_t dec, PEndpoint_tokens val);
	extern void ASN1CALL ASN1Free_Endpoint_tokens_ElmFn(PEndpoint_tokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_tokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_tokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_tokens_ElmFn(PProgress_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_tokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_tokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_tokens_ElmFn(PFacility_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_tokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_tokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_tokens_ElmFn(PSetup_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_tokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_tokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_tokens_ElmFn(PConnect_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_tokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_tokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_tokens_ElmFn(PCallProceeding_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_tokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_tokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_tokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_tokens_ElmFn(PAlerting_UUIE_tokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_integrity_ElmFn(PGatekeeperConfirm_integrity val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_integrity_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_integrity_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_integrity val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_integrity_ElmFn(PGatekeeperRequest_integrity val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_dataRatesSupported_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_dataRatesSupported_ElmFn(PNonStandardProtocol_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_dataRatesSupported_ElmFn(PT120OnlyCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PVoiceCaps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_VoiceCaps_dataRatesSupported_ElmFn(PVoiceCaps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H324Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H324Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH324Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H324Caps_dataRatesSupported_ElmFn(PH324Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H323Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H323Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH323Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H323Caps_dataRatesSupported_ElmFn(PH323Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H322Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H322Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH322Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H322Caps_dataRatesSupported_ElmFn(PH322Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H321Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H321Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH321Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H321Caps_dataRatesSupported_ElmFn(PH321Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H320Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H320Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH320Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H320Caps_dataRatesSupported_ElmFn(PH320Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_H310Caps_dataRatesSupported_ElmFn(ASN1encoding_t enc, PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Dec_H310Caps_dataRatesSupported_ElmFn(ASN1decoding_t dec, PH310Caps_dataRatesSupported val);
	extern void ASN1CALL ASN1Free_H310Caps_dataRatesSupported_ElmFn(PH310Caps_dataRatesSupported val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1encoding_t enc, PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_h245SecurityCapability_ElmFn(ASN1decoding_t dec, PSetup_UUIE_h245SecurityCapability val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_h245SecurityCapability_ElmFn(PSetup_UUIE_h245SecurityCapability val);
    extern int ASN1CALL ASN1Enc_H323_UU_PDU_nonStandardControl_ElmFn(ASN1encoding_t enc, PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Dec_H323_UU_PDU_nonStandardControl_ElmFn(ASN1decoding_t dec, PH323_UU_PDU_nonStandardControl val);
	extern void ASN1CALL ASN1Free_H323_UU_PDU_nonStandardControl_ElmFn(PH323_UU_PDU_nonStandardControl val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_data val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_data_ElmFn(PInfoRequestResponse_perCallInfo_Seq_data val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_video val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_video_ElmFn(PInfoRequestResponse_perCallInfo_Seq_video val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_audio val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_audio_ElmFn(PInfoRequestResponse_perCallInfo_Seq_audio val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_ElmFn(PInfoRequestResponse_perCallInfo val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_callSignalAddress_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_callSignalAddress_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_callSignalAddress val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_callSignalAddress_ElmFn(PInfoRequestResponse_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_callSignalAddress_ElmFn(ASN1encoding_t enc, PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_callSignalAddress_ElmFn(ASN1decoding_t dec, PAdmissionReject_callSignalAddress val);
	extern void ASN1CALL ASN1Free_AdmissionReject_callSignalAddress_ElmFn(PAdmissionReject_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_callSignalAddress_ElmFn(PUnregistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_alternateGatekeeper_ElmFn(PRegistrationConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_callSignalAddress_ElmFn(PRegistrationConfirm_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_rasAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_rasAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_rasAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_rasAddress_ElmFn(PRegistrationRequest_rasAddress val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_callSignalAddress_ElmFn(ASN1encoding_t enc, PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_callSignalAddress_ElmFn(ASN1decoding_t dec, PRegistrationRequest_callSignalAddress val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_callSignalAddress_ElmFn(PRegistrationRequest_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_alternateGatekeeper_ElmFn(PGatekeeperConfirm_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_AltGKInfo_alternateGatekeeper_ElmFn(ASN1encoding_t enc, PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Dec_AltGKInfo_alternateGatekeeper_ElmFn(ASN1decoding_t dec, PAltGKInfo_alternateGatekeeper val);
	extern void ASN1CALL ASN1Free_AltGKInfo_alternateGatekeeper_ElmFn(PAltGKInfo_alternateGatekeeper val);
    extern int ASN1CALL ASN1Enc_Endpoint_rasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_rasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_rasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_rasAddress_ElmFn(PEndpoint_rasAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_callSignalAddress_ElmFn(ASN1encoding_t enc, PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_callSignalAddress_ElmFn(ASN1decoding_t dec, PEndpoint_callSignalAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_callSignalAddress_ElmFn(PEndpoint_callSignalAddress val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_protocols_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_protocols_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_protocols val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_protocols_ElmFn(PResourcesAvailableIndicate_protocols val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_endpointAlias_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_endpointAlias_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_endpointAlias val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_endpointAlias_ElmFn(PInfoRequestResponse_endpointAlias val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PLocationConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_LocationConfirm_alternateEndpoints_ElmFn(PLocationConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PLocationConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_LocationConfirm_remoteExtensionAddress_ElmFn(PLocationConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destExtraCallInfo_ElmFn(PLocationConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationConfirm_destinationInfo_ElmFn(PLocationConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_sourceInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_sourceInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_sourceInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_sourceInfo_ElmFn(PLocationRequest_sourceInfo val);
    extern int ASN1CALL ASN1Enc_LocationRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_LocationRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PLocationRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_LocationRequest_destinationInfo_ElmFn(PLocationRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_alternateEndpoints_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_alternateEndpoints_ElmFn(PAdmissionConfirm_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_remoteExtensionAddress_ElmFn(PAdmissionConfirm_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destExtraCallInfo_ElmFn(PAdmissionConfirm_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_destinationInfo_ElmFn(PAdmissionConfirm_destinationInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destAlternatives_ElmFn(PAdmissionRequest_destAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcAlternatives_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcAlternatives_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcAlternatives val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcAlternatives_ElmFn(PAdmissionRequest_srcAlternatives val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_srcInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_srcInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_srcInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_srcInfo_ElmFn(PAdmissionRequest_srcInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destExtraCallInfo_ElmFn(PAdmissionRequest_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_destinationInfo_ElmFn(ASN1encoding_t enc, PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_destinationInfo_ElmFn(ASN1decoding_t dec, PAdmissionRequest_destinationInfo val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_destinationInfo_ElmFn(PAdmissionRequest_destinationInfo val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_alternateEndpoints_ElmFn(PUnregistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_endpointAlias_ElmFn(PUnregistrationRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1encoding_t enc, PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRejectReason_duplicateAlias_ElmFn(ASN1decoding_t dec, PRegistrationRejectReason_duplicateAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRejectReason_duplicateAlias_ElmFn(PRegistrationRejectReason_duplicateAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_terminalAlias_ElmFn(PRegistrationConfirm_terminalAlias val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PRegistrationRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_alternateEndpoints_ElmFn(PRegistrationRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_terminalAlias_ElmFn(ASN1encoding_t enc, PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_terminalAlias_ElmFn(ASN1decoding_t dec, PRegistrationRequest_terminalAlias val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_terminalAlias_ElmFn(PRegistrationRequest_terminalAlias val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_alternateEndpoints_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_alternateEndpoints val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_alternateEndpoints_ElmFn(PGatekeeperRequest_alternateEndpoints val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_endpointAlias_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_endpointAlias_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_endpointAlias val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_endpointAlias_ElmFn(PGatekeeperRequest_endpointAlias val);
    extern int ASN1CALL ASN1Enc_Endpoint_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Endpoint_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PEndpoint_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Endpoint_destExtraCallInfo_ElmFn(PEndpoint_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Endpoint_remoteExtensionAddress_ElmFn(ASN1encoding_t enc, PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_remoteExtensionAddress_ElmFn(ASN1decoding_t dec, PEndpoint_remoteExtensionAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_remoteExtensionAddress_ElmFn(PEndpoint_remoteExtensionAddress val);
    extern int ASN1CALL ASN1Enc_Endpoint_aliasAddress_ElmFn(ASN1encoding_t enc, PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Dec_Endpoint_aliasAddress_ElmFn(ASN1decoding_t dec, PEndpoint_aliasAddress val);
	extern void ASN1CALL ASN1Free_Endpoint_aliasAddress_ElmFn(PEndpoint_aliasAddress val);
    extern int ASN1CALL ASN1Enc_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1encoding_t enc, PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_NonStandardProtocol_supportedPrefixes_ElmFn(ASN1decoding_t dec, PNonStandardProtocol_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_NonStandardProtocol_supportedPrefixes_ElmFn(PNonStandardProtocol_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_T120OnlyCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PT120OnlyCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_T120OnlyCaps_supportedPrefixes_ElmFn(PT120OnlyCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_VoiceCaps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_VoiceCaps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PVoiceCaps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_VoiceCaps_supportedPrefixes_ElmFn(PVoiceCaps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H324Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H324Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH324Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H324Caps_supportedPrefixes_ElmFn(PH324Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H323Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H323Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH323Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H323Caps_supportedPrefixes_ElmFn(PH323Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H322Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H322Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH322Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H322Caps_supportedPrefixes_ElmFn(PH322Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H321Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H321Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH321Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H321Caps_supportedPrefixes_ElmFn(PH321Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H320Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H320Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH320Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H320Caps_supportedPrefixes_ElmFn(PH320Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_H310Caps_supportedPrefixes_ElmFn(ASN1encoding_t enc, PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Dec_H310Caps_supportedPrefixes_ElmFn(ASN1decoding_t dec, PH310Caps_supportedPrefixes val);
	extern void ASN1CALL ASN1Free_H310Caps_supportedPrefixes_ElmFn(PH310Caps_supportedPrefixes val);
    extern int ASN1CALL ASN1Enc_GatewayInfo_protocol_ElmFn(ASN1encoding_t enc, PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Dec_GatewayInfo_protocol_ElmFn(ASN1decoding_t dec, PGatewayInfo_protocol val);
	extern void ASN1CALL ASN1Free_GatewayInfo_protocol_ElmFn(PGatewayInfo_protocol val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PFacility_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_destExtraCallInfo_ElmFn(PFacility_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1encoding_t enc, PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_alternativeAliasAddress_ElmFn(ASN1decoding_t dec, PFacility_UUIE_alternativeAliasAddress val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_alternativeAliasAddress_ElmFn(PFacility_UUIE_alternativeAliasAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destExtraCallInfo_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destExtraCallInfo val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destExtraCallInfo_ElmFn(PSetup_UUIE_destExtraCallInfo val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_destinationAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_destinationAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_destinationAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_destinationAddress_ElmFn(PSetup_UUIE_destinationAddress val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_sourceAddress_ElmFn(ASN1encoding_t enc, PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_sourceAddress_ElmFn(ASN1decoding_t dec, PSetup_UUIE_sourceAddress val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_sourceAddress_ElmFn(PSetup_UUIE_sourceAddress val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_cryptoTokens_ElmFn(PInfoRequestResponse_perCallInfo_Seq_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableConfirm_cryptoTokens_ElmFn(PResourcesAvailableConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1encoding_t enc, PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_ResourcesAvailableIndicate_cryptoTokens_ElmFn(ASN1decoding_t dec, PResourcesAvailableIndicate_cryptoTokens val);
	extern void ASN1CALL ASN1Free_ResourcesAvailableIndicate_cryptoTokens_ElmFn(PResourcesAvailableIndicate_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RequestInProgress_cryptoTokens_ElmFn(ASN1encoding_t enc, PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RequestInProgress_cryptoTokens_ElmFn(ASN1decoding_t dec, PRequestInProgress_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RequestInProgress_cryptoTokens_ElmFn(PRequestInProgress_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnknownMessageResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnknownMessageResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnknownMessageResponse_cryptoTokens_ElmFn(PUnknownMessageResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1encoding_t enc, PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_H225NonStandardMessage_cryptoTokens_ElmFn(ASN1decoding_t dec, PH225NonStandardMessage_cryptoTokens val);
	extern void ASN1CALL ASN1Free_H225NonStandardMessage_cryptoTokens_ElmFn(PH225NonStandardMessage_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestNak_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestNak_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestNak_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestNak_cryptoTokens_ElmFn(PInfoRequestNak_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestAck_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestAck_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestAck_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestAck_cryptoTokens_ElmFn(PInfoRequestAck_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_cryptoTokens_ElmFn(PInfoRequestResponse_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_InfoRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PInfoRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_InfoRequest_cryptoTokens_ElmFn(PInfoRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageReject_cryptoTokens_ElmFn(PDisengageReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageConfirm_cryptoTokens_ElmFn(PDisengageConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_DisengageRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_DisengageRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PDisengageRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_DisengageRequest_cryptoTokens_ElmFn(PDisengageRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationReject_cryptoTokens_ElmFn(PLocationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationConfirm_cryptoTokens_ElmFn(PLocationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_LocationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_LocationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PLocationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_LocationRequest_cryptoTokens_ElmFn(PLocationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthReject_cryptoTokens_ElmFn(PBandwidthReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthConfirm_cryptoTokens_ElmFn(PBandwidthConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_BandwidthRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_BandwidthRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PBandwidthRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_BandwidthRequest_cryptoTokens_ElmFn(PBandwidthRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionReject_cryptoTokens_ElmFn(PAdmissionReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionConfirm_cryptoTokens_ElmFn(PAdmissionConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_AdmissionRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_AdmissionRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PAdmissionRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_AdmissionRequest_cryptoTokens_ElmFn(PAdmissionRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationReject_cryptoTokens_ElmFn(PUnregistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationConfirm_cryptoTokens_ElmFn(PUnregistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_UnregistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_UnregistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PUnregistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_UnregistrationRequest_cryptoTokens_ElmFn(PUnregistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationReject_cryptoTokens_ElmFn(PRegistrationReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationConfirm_cryptoTokens_ElmFn(PRegistrationConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_RegistrationRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_RegistrationRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PRegistrationRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_RegistrationRequest_cryptoTokens_ElmFn(PRegistrationRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperReject_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperReject_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperReject_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperReject_cryptoTokens_ElmFn(PGatekeeperReject_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperConfirm_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperConfirm_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperConfirm_cryptoTokens_ElmFn(PGatekeeperConfirm_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_GatekeeperRequest_cryptoTokens_ElmFn(ASN1encoding_t enc, PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_GatekeeperRequest_cryptoTokens_ElmFn(ASN1decoding_t dec, PGatekeeperRequest_cryptoTokens val);
	extern void ASN1CALL ASN1Free_GatekeeperRequest_cryptoTokens_ElmFn(PGatekeeperRequest_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Endpoint_cryptoTokens_ElmFn(ASN1encoding_t enc, PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Endpoint_cryptoTokens_ElmFn(ASN1decoding_t dec, PEndpoint_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Endpoint_cryptoTokens_ElmFn(PEndpoint_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Progress_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Progress_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PProgress_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Progress_UUIE_cryptoTokens_ElmFn(PProgress_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_conferences_ElmFn(ASN1encoding_t enc, PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_conferences_ElmFn(ASN1decoding_t dec, PFacility_UUIE_conferences val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_conferences_ElmFn(PFacility_UUIE_conferences val);
    extern int ASN1CALL ASN1Enc_Facility_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Facility_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PFacility_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Facility_UUIE_cryptoTokens_ElmFn(PFacility_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Setup_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Setup_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PSetup_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Setup_UUIE_cryptoTokens_ElmFn(PSetup_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Connect_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Connect_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PConnect_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Connect_UUIE_cryptoTokens_ElmFn(PConnect_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_CallProceeding_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PCallProceeding_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_CallProceeding_UUIE_cryptoTokens_ElmFn(PCallProceeding_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_Alerting_UUIE_cryptoTokens_ElmFn(ASN1encoding_t enc, PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Dec_Alerting_UUIE_cryptoTokens_ElmFn(ASN1decoding_t dec, PAlerting_UUIE_cryptoTokens val);
	extern void ASN1CALL ASN1Free_Alerting_UUIE_cryptoTokens_ElmFn(PAlerting_UUIE_cryptoTokens val);
    extern int ASN1CALL ASN1Enc_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1encoding_t enc, PInfoRequestResponse_perCallInfo_Seq_pdu val);
    extern int ASN1CALL ASN1Dec_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(ASN1decoding_t dec, PInfoRequestResponse_perCallInfo_Seq_pdu val);
	extern void ASN1CALL ASN1Free_InfoRequestResponse_perCallInfo_Seq_pdu_ElmFn(PInfoRequestResponse_perCallInfo_Seq_pdu val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H225ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h245asn.h ===
/* Copyright (C) Microsoft Corporation, 1995-1999. All rights reserved. */
/* ASN.1 definitions for Multimedia System Control (H.245) */

#ifndef _H245ASN_Module_H_
#define _H245ASN_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct UnicastAddress_iPSourceRouteAddress_route * PUnicastAddress_iPSourceRouteAddress_route;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers * PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers;

typedef struct RedundancyEncodingCapability_secondaryEncoding * PRedundancyEncodingCapability_secondaryEncoding;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom * PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom;

typedef struct MultiplexElement_type_subElementList * PMultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation * PRequestAllTerminalIDsResponse_terminalInformation;

typedef struct EncryptionSync_escrowentry * PEncryptionSync_escrowentry;

typedef struct H263Options_customPictureFormat * PH263Options_customPictureFormat;

typedef struct H263Options_customPictureClockFrequency * PH263Options_customPictureClockFrequency;

typedef struct MultipointCapability_mediaDistributionCapability * PMultipointCapability_mediaDistributionCapability;

typedef struct H222Capability_vcCapability * PH222Capability_vcCapability;

typedef struct CapabilityDescriptor_simultaneousCapabilities * PCapabilityDescriptor_simultaneousCapabilities;

typedef struct CertSelectionCriteria * PCertSelectionCriteria;

typedef struct CommunicationModeTableEntry_nonStandard * PCommunicationModeTableEntry_nonStandard;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors * PMultiplexEntrySend_multiplexEntryDescriptors;

typedef struct H2250LogicalChannelAckParameters_nonStandard * PH2250LogicalChannelAckParameters_nonStandard;

typedef struct H2250LogicalChannelParameters_nonStandard * PH2250LogicalChannelParameters_nonStandard;

typedef struct ConferenceCapability_nonStandardData * PConferenceCapability_nonStandardData;

typedef struct H263Options_modeCombos * PH263Options_modeCombos;

typedef struct TransportCapability_qOSCapabilities * PTransportCapability_qOSCapabilities;

typedef struct EncryptionCapability * PEncryptionCapability;

typedef struct EnhancementLayerInfo_spatialEnhancement * PEnhancementLayerInfo_spatialEnhancement;

typedef struct EnhancementLayerInfo_snrEnhancement * PEnhancementLayerInfo_snrEnhancement;

typedef struct H2250Capability_redundancyEncodingCapability * PH2250Capability_redundancyEncodingCapability;

typedef struct EnhancementLayerInfo_bPictureEnhancement * PEnhancementLayerInfo_bPictureEnhancement;

typedef struct MediaDistributionCapability_distributedData * PMediaDistributionCapability_distributedData;

typedef struct MediaDistributionCapability_centralizedData * PMediaDistributionCapability_centralizedData;

typedef struct CommunicationModeResponse_communicationModeTable * PCommunicationModeResponse_communicationModeTable;

typedef struct CommunicationModeCommand_communicationModeTable * PCommunicationModeCommand_communicationModeTable;

typedef struct TerminalCapabilitySet_capabilityTable * PTerminalCapabilitySet_capabilityTable;

typedef struct RequestMode_requestedModes * PRequestMode_requestedModes;

typedef struct UnicastAddress_iPSourceRouteAddress_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} UnicastAddress_iPSourceRouteAddress_route_Seq;

typedef ASN1uint16_t CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set;

typedef ASN1uint16_t RTPH263VideoRedundancyEncoding_containedThreads_Seq;

typedef ASN1uint16_t RTPH263VideoRedundancyFrameMapping_frameSequence_Seq;

typedef ASN1uint16_t SequenceNumber;

typedef ASN1uint16_t CapabilityTableEntryNumber;

typedef ASN1uint16_t CapabilityDescriptorNumber;

typedef ASN1uint16_t LogicalChannelNumber;

typedef ASN1uint16_t MultiplexTableEntryNumber;

typedef ASN1uint16_t McuNumber;

typedef ASN1uint16_t TerminalNumber;

typedef struct TerminalID {
    ASN1uint32_t length;
    ASN1octet_t value[128];
} TerminalID;

typedef struct ConferenceID {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} ConferenceID;

typedef struct H245Password {
    ASN1uint32_t length;
    ASN1octet_t value[32];
} H245Password;

typedef struct NewATMVCIndication_aal_aal1_errorCorrection {
    ASN1choice_t choice;
#   define nullErrorCorrection_chosen 1
#   define longInterleaver_chosen 2
#   define shortInterleaver_chosen 3
#   define errorCorrectionOnly_chosen 4
} NewATMVCIndication_aal_aal1_errorCorrection;

typedef struct NewATMVCIndication_aal_aal1_clockRecovery {
    ASN1choice_t choice;
#   define nullClockRecovery_chosen 1
#   define srtsClockRecovery_chosen 2
#   define adaptiveClockRecovery_chosen 3
} NewATMVCIndication_aal_aal1_clockRecovery;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart_repeatCount {
    ASN1choice_t choice;
#   define doOneProgression_chosen 1
#   define doContinuousProgressions_chosen 2
#   define doOneIndependentProgression_chosen 3
#   define doContinuousIndependentProgressions_chosen 4
} MiscellaneousCommand_type_progressiveRefinementStart_repeatCount;

typedef struct V76LogicalChannelParameters_mode_eRM_recovery {
    ASN1choice_t choice;
#   define rej_chosen 1
#   define sREJ_chosen 2
#   define mSREJ_chosen 3
} V76LogicalChannelParameters_mode_eRM_recovery;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR_Set {
    ASN1uint16_t width;
    ASN1uint16_t height;
} CustomPictureFormat_pixelAspectInformation_extendedPAR_Set;

typedef struct CustomPictureFormat_mPI_customPCF_Set {
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
    ASN1uint16_t customMPI;
} CustomPictureFormat_mPI_customPCF_Set;

typedef struct VCCapability_availableBitRates_type_rangeOfBitRates {
    ASN1uint16_t lowerBitRate;
    ASN1uint16_t higherBitRate;
} VCCapability_availableBitRates_type_rangeOfBitRates;

typedef struct TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded {
    ASN1choice_t choice;
    union {
#	define highestEntryNumberProcessed_chosen 1
	CapabilityTableEntryNumber highestEntryNumberProcessed;
#	define noneProcessed_chosen 2
    } u;
} TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded;

typedef struct VCCapability_availableBitRates_type {
    ASN1choice_t choice;
    union {
#	define singleBitRate_chosen 1
	ASN1uint16_t singleBitRate;
#	define rangeOfBitRates_chosen 2
	VCCapability_availableBitRates_type_rangeOfBitRates rangeOfBitRates;
    } u;
} VCCapability_availableBitRates_type;

typedef struct H223Capability_h223MultiplexTableCapability_enhanced {
    ASN1uint16_t maximumNestingDepth;
    ASN1uint16_t maximumElementListSize;
    ASN1uint16_t maximumSubElementListSize;
} H223Capability_h223MultiplexTableCapability_enhanced;

typedef struct CustomPictureFormat_mPI_customPCF {
    ASN1uint32_t count;
    CustomPictureFormat_mPI_customPCF_Set value[16];
} CustomPictureFormat_mPI_customPCF;

typedef struct CustomPictureFormat_pixelAspectInformation_extendedPAR {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_Set value[256];
} CustomPictureFormat_pixelAspectInformation_extendedPAR;

typedef struct CustomPictureFormat_pixelAspectInformation_pixelAspectCode {
    ASN1uint32_t count;
    CustomPictureFormat_pixelAspectInformation_pixelAspectCode_Set value[14];
} CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

typedef struct H223LogicalChannelParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223LogicalChannelParameters_adaptationLayerType_al3;

typedef struct V76LogicalChannelParameters_mode_eRM {
    ASN1uint16_t windowSize;
    V76LogicalChannelParameters_mode_eRM_recovery recovery;
} V76LogicalChannelParameters_mode_eRM;

typedef struct UnicastAddress_iPSourceRouteAddress_route {
    PUnicastAddress_iPSourceRouteAddress_route next;
    UnicastAddress_iPSourceRouteAddress_route_Seq value;
} UnicastAddress_iPSourceRouteAddress_route_Element;

typedef struct UnicastAddress_iPSourceRouteAddress_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} UnicastAddress_iPSourceRouteAddress_routing;

typedef struct H223ModeParameters_adaptationLayerType_al3 {
    ASN1uint16_t controlFieldOctets;
    ASN1uint32_t sendBufferSize;
} H223ModeParameters_adaptationLayerType_al3;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers {
    ASN1uint32_t count;
    CapabilityDescriptorNumber value[256];
} SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers;

typedef struct SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers {
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers next;
    CapabilityTableEntryNumber value;
} SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_Element;

typedef struct MiscellaneousCommand_type_progressiveRefinementStart {
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount repeatCount;
} MiscellaneousCommand_type_progressiveRefinementStart;

typedef struct MiscellaneousCommand_type_videoFastUpdateMB {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define firstGOB_present 0x80
    ASN1uint16_t firstGOB;
#   define firstMB_present 0x40
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
} MiscellaneousCommand_type_videoFastUpdateMB;

typedef struct MiscellaneousCommand_type_videoFastUpdateGOB {
    ASN1uint16_t firstGOB;
    ASN1uint16_t numberOfGOBs;
} MiscellaneousCommand_type_videoFastUpdateGOB;

typedef struct MiscellaneousIndication_type_videoNotDecodedMBs {
    ASN1uint16_t firstMB;
    ASN1uint16_t numberOfMBs;
    ASN1uint16_t temporalReference;
} MiscellaneousIndication_type_videoNotDecodedMBs;

typedef struct NewATMVCIndication_aal_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} NewATMVCIndication_aal_aal5;

typedef struct NewATMVCIndication_aal_aal1 {
    NewATMVCIndication_aal_aal1_clockRecovery clockRecovery;
    NewATMVCIndication_aal_aal1_errorCorrection errorCorrection;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} NewATMVCIndication_aal_aal1;

typedef struct NewATMVCIndication_reverseParameters_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_reverseParameters_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_reverseParameters_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_reverseParameters_multiplex_programStream_chosen 3
} NewATMVCIndication_reverseParameters_multiplex;

typedef struct UserInputIndication_signal_rtp {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define timestamp_present 0x80
    ASN1uint32_t timestamp;
#   define expirationTime_present 0x40
    ASN1uint32_t expirationTime;
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signal_rtp;

typedef struct UserInputIndication_signalUpdate_rtp {
    LogicalChannelNumber logicalChannelNumber;
} UserInputIndication_signalUpdate_rtp;

typedef struct UserInputIndication_signalUpdate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t duration;
#   define UserInputIndication_signalUpdate_rtp_present 0x80
    UserInputIndication_signalUpdate_rtp rtp;
} UserInputIndication_signalUpdate;

typedef struct UserInputIndication_signal {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1char_t signalType[2];
#   define duration_present 0x80
    ASN1uint16_t duration;
#   define UserInputIndication_signal_rtp_present 0x40
    UserInputIndication_signal_rtp rtp;
} UserInputIndication_signal;

typedef struct NewATMVCIndication_reverseParameters {
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_reverseParameters_multiplex multiplex;
} NewATMVCIndication_reverseParameters;

typedef struct NewATMVCIndication_multiplex {
    ASN1choice_t choice;
#   define NewATMVCIndication_multiplex_noMultiplex_chosen 1
#   define NewATMVCIndication_multiplex_transportStream_chosen 2
#   define NewATMVCIndication_multiplex_programStream_chosen 3
} NewATMVCIndication_multiplex;

typedef struct NewATMVCIndication_aal {
    ASN1choice_t choice;
    union {
#	define aal1_chosen 1
	NewATMVCIndication_aal_aal1 aal1;
#	define aal5_chosen 2
	NewATMVCIndication_aal_aal5 aal5;
    } u;
} NewATMVCIndication_aal;

typedef struct JitterIndication_scope {
    ASN1choice_t choice;
    union {
#	define JitterIndication_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define JitterIndication_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define JitterIndication_scope_wholeMultiplex_chosen 3
    } u;
} JitterIndication_scope;

typedef struct FunctionNotSupported_cause {
    ASN1choice_t choice;
#   define syntaxError_chosen 1
#   define semanticError_chosen 2
#   define unknownFunction_chosen 3
} FunctionNotSupported_cause;

typedef struct H223MultiplexReconfiguration_h223AnnexADoubleFlag {
    ASN1choice_t choice;
#   define start_chosen 1
#   define stop_chosen 2
} H223MultiplexReconfiguration_h223AnnexADoubleFlag;

typedef struct H223MultiplexReconfiguration_h223ModeChange {
    ASN1choice_t choice;
#   define toLevel0_chosen 1
#   define toLevel1_chosen 2
#   define toLevel2_chosen 3
#   define toLevel2withOptionalHeader_chosen 4
} H223MultiplexReconfiguration_h223ModeChange;

typedef struct EndSessionCommand_isdnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_isdnOptions_telephonyMode_chosen 1
#   define v140_chosen 2
#   define terminalOnHold_chosen 3
} EndSessionCommand_isdnOptions;

typedef struct EndSessionCommand_gstnOptions {
    ASN1choice_t choice;
#   define EndSessionCommand_gstnOptions_telephonyMode_chosen 1
#   define v8bis_chosen 2
#   define v34DSVD_chosen 3
#   define v34DuplexFAX_chosen 4
#   define v34H324_chosen 5
} EndSessionCommand_gstnOptions;

typedef struct FlowControlCommand_restriction {
    ASN1choice_t choice;
    union {
#	define maximumBitRate_chosen 1
	ASN1uint32_t maximumBitRate;
#	define noRestriction_chosen 2
    } u;
} FlowControlCommand_restriction;

typedef struct FlowControlCommand_scope {
    ASN1choice_t choice;
    union {
#	define FlowControlCommand_scope_logicalChannelNumber_chosen 1
	LogicalChannelNumber logicalChannelNumber;
#	define FlowControlCommand_scope_resourceID_chosen 2
	ASN1uint16_t resourceID;
#	define FlowControlCommand_scope_wholeMultiplex_chosen 3
    } u;
} FlowControlCommand_scope;

typedef struct SendTerminalCapabilitySet_specificRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t multiplexCapability;
#   define capabilityTableEntryNumbers_present 0x80
    PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers capabilityTableEntryNumbers;
#   define capabilityDescriptorNumbers_present 0x40
    SendTerminalCapabilitySet_specificRequest_capabilityDescriptorNumbers capabilityDescriptorNumbers;
} SendTerminalCapabilitySet_specificRequest;

typedef struct RemoteMCResponse_reject {
    ASN1choice_t choice;
#   define RemoteMCResponse_reject_unspecified_chosen 1
#   define RemoteMCResponse_reject_functionNotSupported_chosen 2
} RemoteMCResponse_reject;

typedef struct ConferenceResponse_sendThisSourceResponse {
    ASN1choice_t choice;
#   define grantedSendThisSource_chosen 1
#   define deniedSendThisSource_chosen 2
} ConferenceResponse_sendThisSourceResponse;

typedef struct ConferenceResponse_makeTerminalBroadcasterResponse {
    ASN1choice_t choice;
#   define grantedMakeTerminalBroadcaster_chosen 1
#   define deniedMakeTerminalBroadcaster_chosen 2
} ConferenceResponse_makeTerminalBroadcasterResponse;

typedef struct ConferenceResponse_broadcastMyLogicalChannelResponse {
    ASN1choice_t choice;
#   define grantedBroadcastMyLogicalChannel_chosen 1
#   define deniedBroadcastMyLogicalChannel_chosen 2
} ConferenceResponse_broadcastMyLogicalChannelResponse;

typedef struct ConferenceResponse_extensionAddressResponse {
    TerminalID extensionAddress;
} ConferenceResponse_extensionAddressResponse;

typedef struct ConferenceResponse_makeMeChairResponse {
    ASN1choice_t choice;
#   define grantedChairToken_chosen 1
#   define deniedChairToken_chosen 2
} ConferenceResponse_makeMeChairResponse;

typedef struct MaintenanceLoopReject_cause {
    ASN1choice_t choice;
#   define canNotPerformLoop_chosen 1
} MaintenanceLoopReject_cause;

typedef struct MaintenanceLoopReject_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopReject_type_systemLoop_chosen 1
#	define MaintenanceLoopReject_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopReject_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopReject_type;

typedef struct MaintenanceLoopAck_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopAck_type_systemLoop_chosen 1
#	define MaintenanceLoopAck_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopAck_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopAck_type;

typedef struct MaintenanceLoopRequest_type {
    ASN1choice_t choice;
    union {
#	define MaintenanceLoopRequest_type_systemLoop_chosen 1
#	define MaintenanceLoopRequest_type_mediaLoop_chosen 2
	LogicalChannelNumber mediaLoop;
#	define MaintenanceLoopRequest_type_logicalChannelLoop_chosen 3
	LogicalChannelNumber logicalChannelLoop;
    } u;
} MaintenanceLoopRequest_type;

typedef struct G7231AnnexCMode_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCMode_g723AnnexCAudioMode;

typedef struct IS13818AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS13818AudioMode_multichannelType_singleChannel_chosen 1
#   define IS13818AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS13818AudioMode_multichannelType_twoChannelDual_chosen 3
#   define threeChannels2_1_chosen 4
#   define threeChannels3_0_chosen 5
#   define fourChannels2_0_2_0_chosen 6
#   define fourChannels2_2_chosen 7
#   define fourChannels3_1_chosen 8
#   define fiveChannels3_0_2_0_chosen 9
#   define fiveChannels3_2_chosen 10
} IS13818AudioMode_multichannelType;

typedef struct IS13818AudioMode_audioSampling {
    ASN1choice_t choice;
#   define audioSampling16k_chosen 1
#   define audioSampling22k05_chosen 2
#   define audioSampling24k_chosen 3
#   define IS13818AudioMode_audioSampling_audioSampling32k_chosen 4
#   define IS13818AudioMode_audioSampling_audioSampling44k1_chosen 5
#   define IS13818AudioMode_audioSampling_audioSampling48k_chosen 6
} IS13818AudioMode_audioSampling;

typedef struct IS13818AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS13818AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS13818AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS13818AudioMode_audioLayer_audioLayer3_chosen 3
} IS13818AudioMode_audioLayer;

typedef struct IS11172AudioMode_multichannelType {
    ASN1choice_t choice;
#   define IS11172AudioMode_multichannelType_singleChannel_chosen 1
#   define IS11172AudioMode_multichannelType_twoChannelStereo_chosen 2
#   define IS11172AudioMode_multichannelType_twoChannelDual_chosen 3
} IS11172AudioMode_multichannelType;

typedef struct IS11172AudioMode_audioSampling {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioSampling_audioSampling32k_chosen 1
#   define IS11172AudioMode_audioSampling_audioSampling44k1_chosen 2
#   define IS11172AudioMode_audioSampling_audioSampling48k_chosen 3
} IS11172AudioMode_audioSampling;

typedef struct IS11172AudioMode_audioLayer {
    ASN1choice_t choice;
#   define IS11172AudioMode_audioLayer_audioLayer1_chosen 1
#   define IS11172AudioMode_audioLayer_audioLayer2_chosen 2
#   define IS11172AudioMode_audioLayer_audioLayer3_chosen 3
} IS11172AudioMode_audioLayer;

typedef struct AudioMode_g7231 {
    ASN1choice_t choice;
#   define noSilenceSuppressionLowRate_chosen 1
#   define noSilenceSuppressionHighRate_chosen 2
#   define silenceSuppressionLowRate_chosen 3
#   define silenceSuppressionHighRate_chosen 4
} AudioMode_g7231;

typedef struct H263VideoMode_resolution {
    ASN1choice_t choice;
#   define sqcif_chosen 1
#   define H263VideoMode_resolution_qcif_chosen 2
#   define H263VideoMode_resolution_cif_chosen 3
#   define cif4_chosen 4
#   define cif16_chosen 5
} H263VideoMode_resolution;

typedef struct H262VideoMode_profileAndLevel {
    ASN1choice_t choice;
#   define profileAndLevel_SPatML_chosen 1
#   define profileAndLevel_MPatLL_chosen 2
#   define profileAndLevel_MPatML_chosen 3
#   define profileAndLevel_MPatH_14_chosen 4
#   define profileAndLevel_MPatHL_chosen 5
#   define profileAndLevel_SNRatLL_chosen 6
#   define profileAndLevel_SNRatML_chosen 7
#   define profileAndLevel_SpatialatH_14_chosen 8
#   define profileAndLevel_HPatML_chosen 9
#   define profileAndLevel_HPatH_14_chosen 10
#   define profileAndLevel_HPatHL_chosen 11
} H262VideoMode_profileAndLevel;

typedef struct H261VideoMode_resolution {
    ASN1choice_t choice;
#   define H261VideoMode_resolution_qcif_chosen 1
#   define H261VideoMode_resolution_cif_chosen 2
} H261VideoMode_resolution;

typedef struct RequestModeReject_cause {
    ASN1choice_t choice;
#   define modeUnavailable_chosen 1
#   define multipointConstraint_chosen 2
#   define requestDenied_chosen 3
} RequestModeReject_cause;

typedef struct RequestModeAck_response {
    ASN1choice_t choice;
#   define willTransmitMostPreferredMode_chosen 1
#   define willTransmitLessPreferredMode_chosen 2
} RequestModeAck_response;

typedef struct RequestMultiplexEntryRelease_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryRelease_entryNumbers;

typedef struct RequestMultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define RequestMultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
} RequestMultiplexEntryRejectionDescriptions_cause;

typedef struct RequestMultiplexEntryReject_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryReject_entryNumbers;

typedef struct RequestMultiplexEntryAck_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntryAck_entryNumbers;

typedef struct RequestMultiplexEntry_entryNumbers {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} RequestMultiplexEntry_entryNumbers;

typedef struct MultiplexEntrySendRelease_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendRelease_multiplexTableEntryNumber;

typedef struct MultiplexEntryRejectionDescriptions_cause {
    ASN1choice_t choice;
#   define MultiplexEntryRejectionDescriptions_cause_unspecifiedCause_chosen 1
#   define descriptorTooComplex_chosen 2
} MultiplexEntryRejectionDescriptions_cause;

typedef struct MultiplexEntrySendAck_multiplexTableEntryNumber {
    ASN1uint32_t count;
    MultiplexTableEntryNumber value[15];
} MultiplexEntrySendAck_multiplexTableEntryNumber;

typedef struct MultiplexElement_repeatCount {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_repeatCount_finite_chosen 1
	ASN1uint16_t finite;
#	define untilClosingFlag_chosen 2
    } u;
} MultiplexElement_repeatCount;

typedef struct MultiplexElement_type {
    ASN1choice_t choice;
    union {
#	define MultiplexElement_type_logicalChannelNumber_chosen 1
	ASN1uint16_t logicalChannelNumber;
#	define subElementList_chosen 2
	PMultiplexElement_type_subElementList subElementList;
    } u;
} MultiplexElement_type;

typedef struct RequestChannelCloseReject_cause {
    ASN1choice_t choice;
#   define RequestChannelCloseReject_cause_unspecified_chosen 1
} RequestChannelCloseReject_cause;

typedef struct RequestChannelClose_reason {
    ASN1choice_t choice;
#   define RequestChannelClose_reason_unknown_chosen 1
#   define normal_chosen 2
#   define RequestChannelClose_reason_reopen_chosen 3
#   define RequestChannelClose_reason_reservationFailure_chosen 4
} RequestChannelClose_reason;

typedef struct CloseLogicalChannel_reason {
    ASN1choice_t choice;
#   define CloseLogicalChannel_reason_unknown_chosen 1
#   define CloseLogicalChannel_reason_reopen_chosen 2
#   define CloseLogicalChannel_reason_reservationFailure_chosen 3
} CloseLogicalChannel_reason;

typedef struct CloseLogicalChannel_source {
    ASN1choice_t choice;
#   define user_chosen 1
#   define lcse_chosen 2
} CloseLogicalChannel_source;

typedef struct OpenLogicalChannelReject_cause {
    ASN1choice_t choice;
#   define OpenLogicalChannelReject_cause_unspecified_chosen 1
#   define unsuitableReverseParameters_chosen 2
#   define dataTypeNotSupported_chosen 3
#   define dataTypeNotAvailable_chosen 4
#   define unknownDataType_chosen 5
#   define dataTypeALCombinationNotSupported_chosen 6
#   define multicastChannelNotAllowed_chosen 7
#   define insufficientBandwidth_chosen 8
#   define separateStackEstablishmentFailed_chosen 9
#   define invalidSessionID_chosen 10
#   define masterSlaveConflict_chosen 11
#   define waitForCommunicationMode_chosen 12
#   define invalidDependentChannel_chosen 13
#   define replacementForRejected_chosen 14
} OpenLogicalChannelReject_cause;

typedef struct MulticastAddress_iP6Address {
    struct MulticastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iP6Address;

typedef struct MulticastAddress_iPAddress {
    struct MulticastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} MulticastAddress_iPAddress;

typedef struct UnicastAddress_iPSourceRouteAddress {
    UnicastAddress_iPSourceRouteAddress_routing routing;
    struct UnicastAddress_iPSourceRouteAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
    PUnicastAddress_iPSourceRouteAddress_route route;
} UnicastAddress_iPSourceRouteAddress;

typedef struct UnicastAddress_iP6Address {
    struct UnicastAddress_iP6Address_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iP6Address;

typedef struct UnicastAddress_iPXAddress {
    struct UnicastAddress_iPXAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct UnicastAddress_iPXAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct UnicastAddress_iPXAddress_tsapIdentifier_tsapIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } tsapIdentifier;
} UnicastAddress_iPXAddress;

typedef struct UnicastAddress_iPAddress {
    struct UnicastAddress_iPAddress_network_network {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } network;
    ASN1uint16_t tsapIdentifier;
} UnicastAddress_iPAddress;

typedef struct V76LogicalChannelParameters_mode {
    ASN1choice_t choice;
    union {
#	define eRM_chosen 1
	V76LogicalChannelParameters_mode_eRM eRM;
#	define uNERM_chosen 2
    } u;
} V76LogicalChannelParameters_mode;

typedef struct V76LogicalChannelParameters_suspendResume {
    ASN1choice_t choice;
#   define noSuspendResume_chosen 1
#   define V76LogicalChannelParameters_suspendResume_suspendResumewAddress_chosen 2
#   define V76LogicalChannelParameters_suspendResume_suspendResumewoAddress_chosen 3
} V76LogicalChannelParameters_suspendResume;

typedef struct H223AnnexCArqParameters_numberOfRetransmissions {
    ASN1choice_t choice;
    union {
#	define H223AnnexCArqParameters_numberOfRetransmissions_finite_chosen 1
	ASN1uint16_t finite;
#	define infinite_chosen 2
    } u;
} H223AnnexCArqParameters_numberOfRetransmissions;

typedef struct H223AL3MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL3MParameters_crcLength_crc4bit_chosen 1
#   define H223AL3MParameters_crcLength_crc12bit_chosen 2
#   define H223AL3MParameters_crcLength_crc20bit_chosen 3
#   define H223AL3MParameters_crcLength_crc28bit_chosen 4
} H223AL3MParameters_crcLength;

typedef struct H223AL3MParameters_headerFormat {
    ASN1choice_t choice;
#   define H223AL3MParameters_headerFormat_sebch16_7_chosen 1
#   define H223AL3MParameters_headerFormat_golay24_12_chosen 2
} H223AL3MParameters_headerFormat;

typedef struct H223AL2MParameters_headerFEC {
    ASN1choice_t choice;
#   define sebch16_5_chosen 1
#   define H223AL2MParameters_headerFEC_golay24_12_chosen 2
} H223AL2MParameters_headerFEC;

typedef struct H223AL1MParameters_crcLength {
    ASN1choice_t choice;
#   define H223AL1MParameters_crcLength_crc4bit_chosen 1
#   define H223AL1MParameters_crcLength_crc12bit_chosen 2
#   define H223AL1MParameters_crcLength_crc20bit_chosen 3
#   define H223AL1MParameters_crcLength_crc28bit_chosen 4
} H223AL1MParameters_crcLength;

typedef struct H223AL1MParameters_headerFEC {
    ASN1choice_t choice;
#   define H223AL1MParameters_headerFEC_sebch16_7_chosen 1
#   define H223AL1MParameters_headerFEC_golay24_12_chosen 2
} H223AL1MParameters_headerFEC;

typedef struct H223AL1MParameters_transferMode {
    ASN1choice_t choice;
#   define framed_chosen 1
#   define unframed_chosen 2
} H223AL1MParameters_transferMode;

typedef struct Q2931Address_address {
    ASN1choice_t choice;
    union {
#	define internationalNumber_chosen 1
	ASN1char_t internationalNumber[17];
#	define nsapAddress_chosen 2
	struct Q2931Address_address_nsapAddress_nsapAddress {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsapAddress;
    } u;
} Q2931Address_address;

typedef struct NetworkAccessParameters_t120SetupProcedure {
    ASN1choice_t choice;
#   define originateCall_chosen 1
#   define waitForCall_chosen 2
#   define issueQuery_chosen 3
} NetworkAccessParameters_t120SetupProcedure;

typedef struct NetworkAccessParameters_distribution {
    ASN1choice_t choice;
#   define unicast_chosen 1
#   define multicast_chosen 2
} NetworkAccessParameters_distribution;

typedef struct T84Profile_t84Restricted {
    ASN1bool_t qcif;
    ASN1bool_t cif;
    ASN1bool_t ccir601Seq;
    ASN1bool_t ccir601Prog;
    ASN1bool_t hdtvSeq;
    ASN1bool_t hdtvProg;
    ASN1bool_t g3FacsMH200x100;
    ASN1bool_t g3FacsMH200x200;
    ASN1bool_t g4FacsMMR200x100;
    ASN1bool_t g4FacsMMR200x200;
    ASN1bool_t jbig200x200Seq;
    ASN1bool_t jbig200x200Prog;
    ASN1bool_t jbig300x300Seq;
    ASN1bool_t jbig300x300Prog;
    ASN1bool_t digPhotoLow;
    ASN1bool_t digPhotoMedSeq;
    ASN1bool_t digPhotoMedProg;
    ASN1bool_t digPhotoHighSeq;
    ASN1bool_t digPhotoHighProg;
} T84Profile_t84Restricted;

typedef struct G7231AnnexCCapability_g723AnnexCAudioMode {
    ASN1uint16_t highRateMode0;
    ASN1uint16_t highRateMode1;
    ASN1uint16_t lowRateMode0;
    ASN1uint16_t lowRateMode1;
    ASN1uint16_t sidMode0;
    ASN1uint16_t sidMode1;
} G7231AnnexCCapability_g723AnnexCAudioMode;

typedef struct AudioCapability_g7231 {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
} AudioCapability_g7231;

typedef struct CustomPictureFormat_pixelAspectInformation {
    ASN1choice_t choice;
    union {
#	define anyPixelAspectRatio_chosen 1
	ASN1bool_t anyPixelAspectRatio;
#	define pixelAspectCode_chosen 2
	CustomPictureFormat_pixelAspectInformation_pixelAspectCode pixelAspectCode;
#	define extendedPAR_chosen 3
	CustomPictureFormat_pixelAspectInformation_extendedPAR extendedPAR;
    } u;
} CustomPictureFormat_pixelAspectInformation;

typedef struct CustomPictureFormat_mPI {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define standardMPI_present 0x80
    ASN1uint16_t standardMPI;
#   define customPCF_present 0x40
    CustomPictureFormat_mPI_customPCF customPCF;
} CustomPictureFormat_mPI;

typedef struct RefPictureSelection_videoBackChannelSend {
    ASN1choice_t choice;
#   define RefPictureSelection_videoBackChannelSend_none_chosen 1
#   define ackMessageOnly_chosen 2
#   define nackMessageOnly_chosen 3
#   define ackOrNackMessageOnly_chosen 4
#   define ackAndNackMessage_chosen 5
} RefPictureSelection_videoBackChannelSend;

typedef struct RefPictureSelection_additionalPictureMemory {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define sqcifAdditionalPictureMemory_present 0x80
    ASN1uint16_t sqcifAdditionalPictureMemory;
#   define qcifAdditionalPictureMemory_present 0x40
    ASN1uint16_t qcifAdditionalPictureMemory;
#   define cifAdditionalPictureMemory_present 0x20
    ASN1uint16_t cifAdditionalPictureMemory;
#   define cif4AdditionalPictureMemory_present 0x10
    ASN1uint16_t cif4AdditionalPictureMemory;
#   define cif16AdditionalPictureMemory_present 0x8
    ASN1uint16_t cif16AdditionalPictureMemory;
#   define bigCpfAdditionalPictureMemory_present 0x4
    ASN1uint16_t bigCpfAdditionalPictureMemory;
} RefPictureSelection_additionalPictureMemory;

typedef struct RTPH263VideoRedundancyFrameMapping_frameSequence {
    ASN1uint32_t count;
    RTPH263VideoRedundancyFrameMapping_frameSequence_Seq value[256];
} RTPH263VideoRedundancyFrameMapping_frameSequence;

typedef struct RTPH263VideoRedundancyEncoding_containedThreads {
    ASN1uint32_t count;
    RTPH263VideoRedundancyEncoding_containedThreads_Seq value[256];
} RTPH263VideoRedundancyEncoding_containedThreads;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping {
    ASN1choice_t choice;
    union {
#	define roundrobin_chosen 1
#	define custom_chosen 2
	PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom custom;
    } u;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping;

typedef struct RedundancyEncodingCapability_secondaryEncoding {
    PRedundancyEncodingCapability_secondaryEncoding next;
    CapabilityTableEntryNumber value;
} RedundancyEncodingCapability_secondaryEncoding_Element;

typedef struct H2250Capability_mcCapability {
    ASN1bool_t centralizedConferenceMC;
    ASN1bool_t decentralizedConferenceMC;
} H2250Capability_mcCapability;

typedef struct H223Capability_mobileOperationTransmitCapability {
    ASN1bool_t modeChangeCapability;
    ASN1bool_t h223AnnexA;
    ASN1bool_t h223AnnexADoubleFlag;
    ASN1bool_t h223AnnexB;
    ASN1bool_t h223AnnexBwithHeader;
} H223Capability_mobileOperationTransmitCapability;

typedef struct H223Capability_h223MultiplexTableCapability {
    ASN1choice_t choice;
    union {
#	define basic_chosen 1
#	define enhanced_chosen 2
	H223Capability_h223MultiplexTableCapability_enhanced enhanced;
    } u;
} H223Capability_h223MultiplexTableCapability;

typedef struct VCCapability_availableBitRates {
    VCCapability_availableBitRates_type type;
} VCCapability_availableBitRates;

typedef struct VCCapability_aal5 {
    ASN1uint16_t forwardMaximumSDUSize;
    ASN1uint16_t backwardMaximumSDUSize;
} VCCapability_aal5;

typedef struct VCCapability_aal1 {
    ASN1bool_t nullClockRecovery;
    ASN1bool_t srtsClockRecovery;
    ASN1bool_t adaptiveClockRecovery;
    ASN1bool_t nullErrorCorrection;
    ASN1bool_t longInterleaver;
    ASN1bool_t shortInterleaver;
    ASN1bool_t errorCorrectionOnly;
    ASN1bool_t structuredDataTransfer;
    ASN1bool_t partiallyFilledCells;
} VCCapability_aal1;

typedef struct Capability_h233EncryptionReceiveCapability {
    ASN1uint16_t h233IVResponseTime;
} Capability_h233EncryptionReceiveCapability;

typedef struct TerminalCapabilitySetReject_cause {
    ASN1choice_t choice;
    union {
#	define TerminalCapabilitySetReject_cause_unspecified_chosen 1
#	define undefinedTableEntryUsed_chosen 2
#	define descriptorCapacityExceeded_chosen 3
#	define tableEntryCapacityExceeded_chosen 4
	TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded tableEntryCapacityExceeded;
    } u;
} TerminalCapabilitySetReject_cause;

typedef struct MasterSlaveDeterminationReject_cause {
    ASN1choice_t choice;
#   define identicalNumbers_chosen 1
} MasterSlaveDeterminationReject_cause;

typedef struct MasterSlaveDeterminationAck_decision {
    ASN1choice_t choice;
#   define master_chosen 1
#   define slave_chosen 2
} MasterSlaveDeterminationAck_decision;

typedef struct NonStandardIdentifier_h221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} NonStandardIdentifier_h221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	NonStandardIdentifier_h221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct MasterSlaveDetermination {
    ASN1uint16_t terminalType;
    ASN1uint32_t statusDeterminationNumber;
} MasterSlaveDetermination;

typedef struct MasterSlaveDeterminationAck {
    MasterSlaveDeterminationAck_decision decision;
} MasterSlaveDeterminationAck;

typedef struct MasterSlaveDeterminationReject {
    MasterSlaveDeterminationReject_cause cause;
} MasterSlaveDeterminationReject;

typedef struct MasterSlaveDeterminationRelease {
    char placeholder;
} MasterSlaveDeterminationRelease;

typedef struct CapabilityDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityDescriptorNumber capabilityDescriptorNumber;
#   define simultaneousCapabilities_present 0x80
    PCapabilityDescriptor_simultaneousCapabilities simultaneousCapabilities;
} CapabilityDescriptor;

typedef struct AlternativeCapabilitySet {
    ASN1uint32_t count;
    CapabilityTableEntryNumber value[256];
} AlternativeCapabilitySet;

typedef struct TerminalCapabilitySetAck {
    SequenceNumber sequenceNumber;
} TerminalCapabilitySetAck;

typedef struct TerminalCapabilitySetReject {
    SequenceNumber sequenceNumber;
    TerminalCapabilitySetReject_cause cause;
} TerminalCapabilitySetReject;

typedef struct TerminalCapabilitySetRelease {
    char placeholder;
} TerminalCapabilitySetRelease;

typedef struct H222Capability {
    ASN1uint16_t numberOfVCs;
    PH222Capability_vcCapability vcCapability;
} H222Capability;

typedef struct VCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define aal1_present 0x80
    VCCapability_aal1 aal1;
#   define aal5_present 0x40
    VCCapability_aal5 aal5;
    ASN1bool_t transportStream;
    ASN1bool_t programStream;
    VCCapability_availableBitRates availableBitRates;
} VCCapability;

typedef struct H223AnnexCCapability {
    ASN1bool_t videoWithAL1M;
    ASN1bool_t videoWithAL2M;
    ASN1bool_t videoWithAL3M;
    ASN1bool_t audioWithAL1M;
    ASN1bool_t audioWithAL2M;
    ASN1bool_t audioWithAL3M;
    ASN1bool_t dataWithAL1M;
    ASN1bool_t dataWithAL2M;
    ASN1bool_t dataWithAL3M;
    ASN1bool_t alpduInterleaving;
    ASN1uint16_t maximumAL1MPDUSize;
    ASN1uint16_t maximumAL2MSDUSize;
    ASN1uint16_t maximumAL3MSDUSize;
} H223AnnexCCapability;

typedef struct V75Capability {
    ASN1bool_t audioHeader;
} V75Capability;

typedef struct QOSMode {
    ASN1choice_t choice;
#   define guaranteedQOS_chosen 1
#   define controlledLoad_chosen 2
} QOSMode;

typedef struct ATMParameters {
    ASN1uint16_t maxNTUSize;
    ASN1bool_t atmUBR;
    ASN1bool_t atmrtVBR;
    ASN1bool_t atmnrtVBR;
    ASN1bool_t atmABR;
    ASN1bool_t atmCBR;
} ATMParameters;

typedef struct MediaTransportType {
    ASN1choice_t choice;
#   define ip_UDP_chosen 1
#   define ip_TCP_chosen 2
#   define atm_AAL5_UNIDIR_chosen 3
#   define atm_AAL5_BIDIR_chosen 4
} MediaTransportType;

typedef struct MediaChannelCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define mediaTransport_present 0x80
    MediaTransportType mediaTransport;
} MediaChannelCapability;

typedef struct RTPH263VideoRedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t numberOfThreads;
    ASN1uint16_t framesBetweenSyncPoints;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping frameToThreadMapping;
#   define containedThreads_present 0x80
    RTPH263VideoRedundancyEncoding_containedThreads containedThreads;
} RTPH263VideoRedundancyEncoding;

typedef struct RTPH263VideoRedundancyFrameMapping {
    ASN1uint16_t threadNumber;
    RTPH263VideoRedundancyFrameMapping_frameSequence frameSequence;
} RTPH263VideoRedundancyFrameMapping;

typedef struct MultipointCapability {
    ASN1bool_t multicastCapability;
    ASN1bool_t multiUniCastConference;
    PMultipointCapability_mediaDistributionCapability mediaDistributionCapability;
} MultipointCapability;

typedef struct MediaDistributionCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t centralizedControl;
    ASN1bool_t distributedControl;
    ASN1bool_t centralizedAudio;
    ASN1bool_t distributedAudio;
    ASN1bool_t centralizedVideo;
    ASN1bool_t distributedVideo;
#   define centralizedData_present 0x80
    PMediaDistributionCapability_centralizedData centralizedData;
#   define distributedData_present 0x40
    PMediaDistributionCapability_distributedData distributedData;
} MediaDistributionCapability;

typedef struct H261VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define H261VideoCapability_qcifMPI_present 0x80
    ASN1uint16_t qcifMPI;
#   define H261VideoCapability_cifMPI_present 0x40
    ASN1uint16_t cifMPI;
    ASN1bool_t temporalSpatialTradeOffCapability;
    ASN1uint16_t maxBitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoCapability;

typedef struct H262VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t profileAndLevel_SPatML;
    ASN1bool_t profileAndLevel_MPatLL;
    ASN1bool_t profileAndLevel_MPatML;
    ASN1bool_t profileAndLevel_MPatH_14;
    ASN1bool_t profileAndLevel_MPatHL;
    ASN1bool_t profileAndLevel_SNRatLL;
    ASN1bool_t profileAndLevel_SNRatML;
    ASN1bool_t profileAndLevel_SpatialatH_14;
    ASN1bool_t profileAndLevel_HPatML;
    ASN1bool_t profileAndLevel_HPatH_14;
    ASN1bool_t profileAndLevel_HPatHL;
#   define H262VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoCapability_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoCapability;

typedef struct EnhancementLayerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t baseBitRateConstrained;
#   define snrEnhancement_present 0x80
    PEnhancementLayerInfo_snrEnhancement snrEnhancement;
#   define spatialEnhancement_present 0x40
    PEnhancementLayerInfo_spatialEnhancement spatialEnhancement;
#   define bPictureEnhancement_present 0x20
    PEnhancementLayerInfo_bPictureEnhancement bPictureEnhancement;
} EnhancementLayerInfo;

typedef struct TransparencyParameters {
    ASN1uint16_t presentationOrder;
    ASN1int32_t offset_x;
    ASN1int32_t offset_y;
    ASN1uint16_t scale_x;
    ASN1uint16_t scale_y;
} TransparencyParameters;

typedef struct RefPictureSelection {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define additionalPictureMemory_present 0x80
    RefPictureSelection_additionalPictureMemory additionalPictureMemory;
    ASN1bool_t videoMux;
    RefPictureSelection_videoBackChannelSend videoBackChannelSend;
} RefPictureSelection;

typedef struct CustomPictureClockFrequency {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t clockConversionCode;
    ASN1uint16_t clockDivisor;
#   define CustomPictureClockFrequency_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define CustomPictureClockFrequency_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define CustomPictureClockFrequency_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define CustomPictureClockFrequency_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define CustomPictureClockFrequency_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
} CustomPictureClockFrequency;

typedef struct CustomPictureFormat {
    ASN1uint16_t maxCustomPictureWidth;
    ASN1uint16_t maxCustomPictureHeight;
    ASN1uint16_t minCustomPictureWidth;
    ASN1uint16_t minCustomPictureHeight;
    CustomPictureFormat_mPI mPI;
    CustomPictureFormat_pixelAspectInformation pixelAspectInformation;
} CustomPictureFormat;

typedef struct H263ModeComboFlags {
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t referencePicSelect;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t reducedResolutionUpdate;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
} H263ModeComboFlags;

typedef struct IS11172VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoCapability_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoCapability_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoCapability_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoCapability_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoCapability_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoCapability_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoCapability;

typedef struct G7231AnnexCCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
#   define g723AnnexCAudioMode_present 0x80
    G7231AnnexCCapability_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCCapability;

typedef struct IS11172AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1uint16_t bitRate;
} IS11172AudioCapability;

typedef struct IS13818AudioCapability {
    ASN1bool_t audioLayer1;
    ASN1bool_t audioLayer2;
    ASN1bool_t audioLayer3;
    ASN1bool_t audioSampling16k;
    ASN1bool_t audioSampling22k05;
    ASN1bool_t audioSampling24k;
    ASN1bool_t audioSampling32k;
    ASN1bool_t audioSampling44k1;
    ASN1bool_t audioSampling48k;
    ASN1bool_t singleChannel;
    ASN1bool_t twoChannels;
    ASN1bool_t threeChannels2_1;
    ASN1bool_t threeChannels3_0;
    ASN1bool_t fourChannels2_0_2_0;
    ASN1bool_t fourChannels2_2;
    ASN1bool_t fourChannels3_1;
    ASN1bool_t fiveChannels3_0_2_0;
    ASN1bool_t fiveChannels3_2;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioCapability;

typedef struct GSMAudioCapability {
    ASN1uint16_t audioUnitSize;
    ASN1bool_t comfortNoise;
    ASN1bool_t scrambled;
} GSMAudioCapability;

typedef struct V42bis {
    ASN1uint32_t numberOfCodewords;
    ASN1uint16_t maximumStringLength;
} V42bis;

typedef struct T84Profile {
    ASN1choice_t choice;
    union {
#	define t84Unrestricted_chosen 1
#	define t84Restricted_chosen 2
	T84Profile_t84Restricted t84Restricted;
    } u;
} T84Profile;

typedef struct ConferenceCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define ConferenceCapability_nonStandardData_present 0x80
    PConferenceCapability_nonStandardData nonStandardData;
    ASN1bool_t chairControlCapability;
#   define videoIndicateMixingCapability_present 0x8000
    ASN1bool_t videoIndicateMixingCapability;
} ConferenceCapability;

typedef struct Q2931Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Q2931Address_address address;
#   define subaddress_present 0x80
    struct Q2931Address_subaddress_subaddress {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } subaddress;
} Q2931Address;

typedef struct V75Parameters {
    ASN1bool_t audioHeaderPresent;
} V75Parameters;

typedef struct H222LogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t subChannelID;
#   define pcr_pid_present 0x80
    ASN1uint16_t pcr_pid;
#   define programDescriptors_present 0x40
    ASN1octetstring_t programDescriptors;
#   define streamDescriptors_present 0x20
    ASN1octetstring_t streamDescriptors;
} H222LogicalChannelParameters;

typedef struct H223AL2MParameters {
    H223AL2MParameters_headerFEC headerFEC;
    ASN1bool_t alpduInterleaving;
} H223AL2MParameters;

typedef struct H223AnnexCArqParameters {
    H223AnnexCArqParameters_numberOfRetransmissions numberOfRetransmissions;
    ASN1uint32_t sendBufferSize;
} H223AnnexCArqParameters;

typedef struct CRCLength {
    ASN1choice_t choice;
#   define crc8bit_chosen 1
#   define crc16bit_chosen 2
#   define crc32bit_chosen 3
} CRCLength;

typedef struct EscrowData {
    ASN1objectidentifier_t escrowID;
    ASN1bitstring_t escrowValue;
} EscrowData;

typedef struct OpenLogicalChannelReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannelReject_cause cause;
} OpenLogicalChannelReject;

typedef struct OpenLogicalChannelConfirm {
    LogicalChannelNumber forwardLogicalChannelNumber;
} OpenLogicalChannelConfirm;

typedef struct CloseLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    CloseLogicalChannel_source source;
#   define CloseLogicalChannel_reason_present 0x80
    CloseLogicalChannel_reason reason;
} CloseLogicalChannel;

typedef struct CloseLogicalChannelAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} CloseLogicalChannelAck;

typedef struct RequestChannelCloseAck {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseAck;

typedef struct RequestChannelCloseReject {
    LogicalChannelNumber forwardLogicalChannelNumber;
    RequestChannelCloseReject_cause cause;
} RequestChannelCloseReject;

typedef struct RequestChannelCloseRelease {
    LogicalChannelNumber forwardLogicalChannelNumber;
} RequestChannelCloseRelease;

typedef struct MultiplexEntrySend {
    SequenceNumber sequenceNumber;
    PMultiplexEntrySend_multiplexEntryDescriptors multiplexEntryDescriptors;
} MultiplexEntrySend;

typedef struct MultiplexElement {
    MultiplexElement_type type;
    MultiplexElement_repeatCount repeatCount;
} MultiplexElement;

typedef struct MultiplexEntrySendAck {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendAck_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendAck;

typedef struct MultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    MultiplexEntryRejectionDescriptions_cause cause;
} MultiplexEntryRejectionDescriptions;

typedef struct MultiplexEntrySendRelease {
    MultiplexEntrySendRelease_multiplexTableEntryNumber multiplexTableEntryNumber;
} MultiplexEntrySendRelease;

typedef struct RequestMultiplexEntry {
    RequestMultiplexEntry_entryNumbers entryNumbers;
} RequestMultiplexEntry;

typedef struct RequestMultiplexEntryAck {
    RequestMultiplexEntryAck_entryNumbers entryNumbers;
} RequestMultiplexEntryAck;

typedef struct RequestMultiplexEntryRejectionDescriptions {
    MultiplexTableEntryNumber multiplexTableEntryNumber;
    RequestMultiplexEntryRejectionDescriptions_cause cause;
} RequestMultiplexEntryRejectionDescriptions;

typedef struct RequestMultiplexEntryRelease {
    RequestMultiplexEntryRelease_entryNumbers entryNumbers;
} RequestMultiplexEntryRelease;

typedef struct RequestMode {
    SequenceNumber sequenceNumber;
    PRequestMode_requestedModes requestedModes;
} RequestMode;

typedef struct RequestModeAck {
    SequenceNumber sequenceNumber;
    RequestModeAck_response response;
} RequestModeAck;

typedef struct RequestModeReject {
    SequenceNumber sequenceNumber;
    RequestModeReject_cause cause;
} RequestModeReject;

typedef struct RequestModeRelease {
    char placeholder;
} RequestModeRelease;

typedef struct V76ModeParameters {
    ASN1choice_t choice;
#   define V76ModeParameters_suspendResumewAddress_chosen 1
#   define V76ModeParameters_suspendResumewoAddress_chosen 2
} V76ModeParameters;

typedef struct H261VideoMode {
    H261VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t stillImageTransmission;
} H261VideoMode;

typedef struct H262VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H262VideoMode_profileAndLevel profileAndLevel;
#   define H262VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define H262VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define H262VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define H262VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define H262VideoMode_framesPerSecond_present 0x8
    ASN1uint16_t framesPerSecond;
#   define H262VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} H262VideoMode;

typedef struct IS11172VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t constrainedBitstream;
#   define IS11172VideoMode_videoBitRate_present 0x80
    ASN1uint32_t videoBitRate;
#   define IS11172VideoMode_vbvBufferSize_present 0x40
    ASN1uint32_t vbvBufferSize;
#   define IS11172VideoMode_samplesPerLine_present 0x20
    ASN1uint16_t samplesPerLine;
#   define IS11172VideoMode_linesPerFrame_present 0x10
    ASN1uint16_t linesPerFrame;
#   define IS11172VideoMode_pictureRate_present 0x8
    ASN1uint16_t pictureRate;
#   define IS11172VideoMode_luminanceSampleRate_present 0x4
    ASN1uint32_t luminanceSampleRate;
} IS11172VideoMode;

typedef struct IS11172AudioMode {
    IS11172AudioMode_audioLayer audioLayer;
    IS11172AudioMode_audioSampling audioSampling;
    IS11172AudioMode_multichannelType multichannelType;
    ASN1uint16_t bitRate;
} IS11172AudioMode;

typedef struct IS13818AudioMode {
    IS13818AudioMode_audioLayer audioLayer;
    IS13818AudioMode_audioSampling audioSampling;
    IS13818AudioMode_multichannelType multichannelType;
    ASN1bool_t lowFrequencyEnhancement;
    ASN1bool_t multilingual;
    ASN1uint16_t bitRate;
} IS13818AudioMode;

typedef struct G7231AnnexCMode {
    ASN1uint16_t maxAl_sduAudioFrames;
    ASN1bool_t silenceSuppression;
    G7231AnnexCMode_g723AnnexCAudioMode g723AnnexCAudioMode;
} G7231AnnexCMode;

typedef struct RoundTripDelayRequest {
    SequenceNumber sequenceNumber;
} RoundTripDelayRequest;

typedef struct RoundTripDelayResponse {
    SequenceNumber sequenceNumber;
} RoundTripDelayResponse;

typedef struct MaintenanceLoopRequest {
    MaintenanceLoopRequest_type type;
} MaintenanceLoopRequest;

typedef struct MaintenanceLoopAck {
    MaintenanceLoopAck_type type;
} MaintenanceLoopAck;

typedef struct MaintenanceLoopReject {
    MaintenanceLoopReject_type type;
    MaintenanceLoopReject_cause cause;
} MaintenanceLoopReject;

typedef struct MaintenanceLoopOffCommand {
    char placeholder;
} MaintenanceLoopOffCommand;

typedef struct CommunicationModeCommand {
    PCommunicationModeCommand_communicationModeTable communicationModeTable;
} CommunicationModeCommand;

typedef struct CommunicationModeRequest {
    char placeholder;
} CommunicationModeRequest;

typedef struct CommunicationModeResponse {
    ASN1choice_t choice;
    union {
#	define communicationModeTable_chosen 1
	PCommunicationModeResponse_communicationModeTable communicationModeTable;
    } u;
} CommunicationModeResponse;

typedef struct Criteria {
    ASN1objectidentifier_t field;
    struct Criteria_value_value {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } value;
} Criteria;

typedef struct TerminalLabel {
    McuNumber mcuNumber;
    TerminalNumber terminalNumber;
} TerminalLabel;

typedef struct RequestAllTerminalIDsResponse {
    PRequestAllTerminalIDsResponse_terminalInformation terminalInformation;
} RequestAllTerminalIDsResponse;

typedef struct TerminalInformation {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} TerminalInformation;

typedef struct RemoteMCRequest {
    ASN1choice_t choice;
#   define masterActivate_chosen 1
#   define slaveActivate_chosen 2
#   define deActivate_chosen 3
} RemoteMCRequest;

typedef struct RemoteMCResponse {
    ASN1choice_t choice;
    union {
#	define accept_chosen 1
#	define reject_chosen 2
	RemoteMCResponse_reject reject;
    } u;
} RemoteMCResponse;

typedef struct SendTerminalCapabilitySet {
    ASN1choice_t choice;
    union {
#	define specificRequest_chosen 1
	SendTerminalCapabilitySet_specificRequest specificRequest;
#	define genericRequest_chosen 2
    } u;
} SendTerminalCapabilitySet;

typedef struct FlowControlCommand {
    FlowControlCommand_scope scope;
    FlowControlCommand_restriction restriction;
} FlowControlCommand;

typedef struct SubstituteConferenceIDCommand {
    struct SubstituteConferenceIDCommand_conferenceIdentifier_conferenceIdentifier {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } conferenceIdentifier;
} SubstituteConferenceIDCommand;

typedef struct KeyProtectionMethod {
    ASN1bool_t secureChannel;
    ASN1bool_t sharedSecret;
    ASN1bool_t certProtectedKey;
} KeyProtectionMethod;

typedef struct EncryptionUpdateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define keyProtectionMethod_present 0x80
    KeyProtectionMethod keyProtectionMethod;
} EncryptionUpdateRequest;

typedef struct H223MultiplexReconfiguration {
    ASN1choice_t choice;
    union {
#	define h223ModeChange_chosen 1
	H223MultiplexReconfiguration_h223ModeChange h223ModeChange;
#	define h223AnnexADoubleFlag_chosen 2
	H223MultiplexReconfiguration_h223AnnexADoubleFlag h223AnnexADoubleFlag;
    } u;
} H223MultiplexReconfiguration;

typedef struct FunctionNotSupported {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    FunctionNotSupported_cause cause;
#   define returnedFunction_present 0x80
    ASN1octetstring_t returnedFunction;
} FunctionNotSupported;

typedef struct TerminalYouAreSeeingInSubPictureNumber {
    TerminalNumber terminalNumber;
    ASN1uint16_t subPictureNumber;
} TerminalYouAreSeeingInSubPictureNumber;

typedef struct VideoIndicateCompose {
    ASN1uint16_t compositionNumber;
} VideoIndicateCompose;

typedef struct ConferenceIndication {
    ASN1choice_t choice;
    union {
#	define sbeNumber_chosen 1
	ASN1uint16_t sbeNumber;
#	define terminalNumberAssign_chosen 2
	TerminalLabel terminalNumberAssign;
#	define terminalJoinedConference_chosen 3
	TerminalLabel terminalJoinedConference;
#	define terminalLeftConference_chosen 4
	TerminalLabel terminalLeftConference;
#	define seenByAtLeastOneOther_chosen 5
#	define cancelSeenByAtLeastOneOther_chosen 6
#	define seenByAll_chosen 7
#	define cancelSeenByAll_chosen 8
#	define terminalYouAreSeeing_chosen 9
	TerminalLabel terminalYouAreSeeing;
#	define requestForFloor_chosen 10
#	define withdrawChairToken_chosen 11
#	define floorRequested_chosen 12
	TerminalLabel floorRequested;
#	define terminalYouAreSeeingInSubPictureNumber_chosen 13
	TerminalYouAreSeeingInSubPictureNumber terminalYouAreSeeingInSubPictureNumber;
#	define videoIndicateCompose_chosen 14
	VideoIndicateCompose videoIndicateCompose;
    } u;
} ConferenceIndication;

typedef struct JitterIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    JitterIndication_scope scope;
    ASN1uint16_t estimatedReceivedJitterMantissa;
    ASN1uint16_t estimatedReceivedJitterExponent;
#   define skippedFrameCount_present 0x80
    ASN1uint16_t skippedFrameCount;
#   define additionalDecoderBuffer_present 0x40
    ASN1uint32_t additionalDecoderBuffer;
} JitterIndication;

typedef struct H223SkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t skew;
} H223SkewIndication;

typedef struct H2250MaximumSkewIndication {
    LogicalChannelNumber logicalChannelNumber1;
    LogicalChannelNumber logicalChannelNumber2;
    ASN1uint16_t maximumSkew;
} H2250MaximumSkewIndication;

typedef struct VendorIdentification {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NonStandardIdentifier vendor;
#   define productNumber_present 0x80
    struct VendorIdentification_productNumber_productNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } productNumber;
#   define versionNumber_present 0x40
    struct VendorIdentification_versionNumber_versionNumber {
	ASN1uint32_t length;
	ASN1octet_t value[256];
    } versionNumber;
} VendorIdentification;

typedef struct NewATMVCIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t resourceID;
    ASN1uint16_t bitRate;
    ASN1bool_t bitRateLockedToPCRClock;
    ASN1bool_t bitRateLockedToNetworkClock;
    NewATMVCIndication_aal aal;
    NewATMVCIndication_multiplex multiplex;
#   define reverseParameters_present 0x80
    NewATMVCIndication_reverseParameters reverseParameters;
} NewATMVCIndication;

typedef struct RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom {
    PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom next;
    RTPH263VideoRedundancyFrameMapping value;
} RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_Element;

typedef struct MultiplexElement_type_subElementList {
    ASN1uint32_t count;
    MultiplexElement value[255];
} MultiplexElement_type_subElementList;

typedef struct RequestAllTerminalIDsResponse_terminalInformation {
    PRequestAllTerminalIDsResponse_terminalInformation next;
    TerminalInformation value;
} RequestAllTerminalIDsResponse_terminalInformation_Element;

typedef struct ConferenceResponse_terminalCertificateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceResponse_terminalCertificateResponse_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certificateResponse_present 0x40
    struct ConferenceResponse_terminalCertificateResponse_certificateResponse_certificateResponse {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } certificateResponse;
} ConferenceResponse_terminalCertificateResponse;

typedef struct ConferenceResponse_chairTokenOwnerResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_chairTokenOwnerResponse;

typedef struct ConferenceResponse_terminalListResponse {
    ASN1uint32_t count;
    TerminalLabel value[256];
} ConferenceResponse_terminalListResponse;

typedef struct ConferenceResponse_passwordResponse {
    TerminalLabel terminalLabel;
    H245Password password;
} ConferenceResponse_passwordResponse;

typedef struct ConferenceResponse_conferenceIDResponse {
    TerminalLabel terminalLabel;
    ConferenceID conferenceID;
} ConferenceResponse_conferenceIDResponse;

typedef struct ConferenceResponse_terminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_terminalIDResponse;

typedef struct ConferenceResponse_mCTerminalIDResponse {
    TerminalLabel terminalLabel;
    TerminalID terminalID;
} ConferenceResponse_mCTerminalIDResponse;

typedef struct ConferenceRequest_requestTerminalCertificate {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define ConferenceRequest_requestTerminalCertificate_terminalLabel_present 0x80
    TerminalLabel terminalLabel;
#   define certSelectionCriteria_present 0x40
    PCertSelectionCriteria certSelectionCriteria;
#   define sRandom_present 0x20
    ASN1uint32_t sRandom;
} ConferenceRequest_requestTerminalCertificate;

typedef struct RequestMultiplexEntryReject_rejectionDescriptions {
    ASN1uint32_t count;
    RequestMultiplexEntryRejectionDescriptions value[15];
} RequestMultiplexEntryReject_rejectionDescriptions;

typedef struct MultiplexEntrySendReject_rejectionDescriptions {
    ASN1uint32_t count;
    MultiplexEntryRejectionDescriptions value[15];
} MultiplexEntrySendReject_rejectionDescriptions;

typedef struct MultiplexEntryDescriptor_elementList {
    ASN1uint32_t count;
    MultiplexElement value[256];
} MultiplexEntryDescriptor_elementList;

typedef struct EncryptionSync_escrowentry {
    PEncryptionSync_escrowentry next;
    EscrowData value;
} EncryptionSync_escrowentry_Element;

typedef struct H223AL3MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL3MParameters_arqType_noArq_chosen 1
#	define H223AL3MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL3MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL3MParameters_arqType;

typedef struct H223AL1MParameters_arqType {
    ASN1choice_t choice;
    union {
#	define H223AL1MParameters_arqType_noArq_chosen 1
#	define H223AL1MParameters_arqType_typeIArq_chosen 2
	H223AnnexCArqParameters typeIArq;
#	define H223AL1MParameters_arqType_typeIIArq_chosen 3
	H223AnnexCArqParameters typeIIArq;
    } u;
} H223AL1MParameters_arqType;

typedef struct H263VideoModeCombos_h263VideoCoupledModes {
    ASN1uint32_t count;
    H263ModeComboFlags value[16];
} H263VideoModeCombos_h263VideoCoupledModes;

typedef struct H263Options_customPictureFormat {
    PH263Options_customPictureFormat next;
    CustomPictureFormat value;
} H263Options_customPictureFormat_Element;

typedef struct H263Options_customPictureClockFrequency {
    PH263Options_customPictureClockFrequency next;
    CustomPictureClockFrequency value;
} H263Options_customPictureClockFrequency_Element;

typedef struct MultipointCapability_mediaDistributionCapability {
    PMultipointCapability_mediaDistributionCapability next;
    MediaDistributionCapability value;
} MultipointCapability_mediaDistributionCapability_Element;

typedef struct TransportCapability_mediaChannelCapabilities {
    ASN1uint32_t count;
    MediaChannelCapability value[256];
} TransportCapability_mediaChannelCapabilities;

typedef struct H222Capability_vcCapability {
    PH222Capability_vcCapability next;
    VCCapability value;
} H222Capability_vcCapability_Element;

typedef struct CapabilityDescriptor_simultaneousCapabilities {
    PCapabilityDescriptor_simultaneousCapabilities next;
    AlternativeCapabilitySet value;
} CapabilityDescriptor_simultaneousCapabilities_Element;

typedef struct TerminalCapabilitySet_capabilityDescriptors {
    ASN1uint32_t count;
    CapabilityDescriptor value[256];
} TerminalCapabilitySet_capabilityDescriptors;

typedef struct NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct H223Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t transportWithI_frames;
    ASN1bool_t videoWithAL1;
    ASN1bool_t videoWithAL2;
    ASN1bool_t videoWithAL3;
    ASN1bool_t audioWithAL1;
    ASN1bool_t audioWithAL2;
    ASN1bool_t audioWithAL3;
    ASN1bool_t dataWithAL1;
    ASN1bool_t dataWithAL2;
    ASN1bool_t dataWithAL3;
    ASN1uint16_t maximumAl2SDUSize;
    ASN1uint16_t maximumAl3SDUSize;
    ASN1uint16_t maximumDelayJitter;
    H223Capability_h223MultiplexTableCapability h223MultiplexTableCapability;
#   define maxMUXPDUSizeCapability_present 0x80
    ASN1bool_t maxMUXPDUSizeCapability;
#   define nsrpSupport_present 0x40
    ASN1bool_t nsrpSupport;
#   define mobileOperationTransmitCapability_present 0x20
    H223Capability_mobileOperationTransmitCapability mobileOperationTransmitCapability;
#   define h223AnnexCCapability_present 0x10
    H223AnnexCCapability h223AnnexCCapability;
} H223Capability;

typedef struct V76Capability {
    ASN1bool_t suspendResumeCapabilitywAddress;
    ASN1bool_t suspendResumeCapabilitywoAddress;
    ASN1bool_t rejCapability;
    ASN1bool_t sREJCapability;
    ASN1bool_t mREJCapability;
    ASN1bool_t crc8bitCapability;
    ASN1bool_t crc16bitCapability;
    ASN1bool_t crc32bitCapability;
    ASN1bool_t uihCapability;
    ASN1uint16_t numOfDLCS;
    ASN1bool_t twoOctetAddressFieldCapability;
    ASN1bool_t loopBackTestCapability;
    ASN1uint16_t n401Capability;
    ASN1uint16_t maxWindowSizeCapability;
    V75Capability v75Capability;
} V76Capability;

typedef struct RSVPParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define qosMode_present 0x80
    QOSMode qosMode;
#   define tokenRate_present 0x40
    ASN1uint32_t tokenRate;
#   define bucketSize_present 0x20
    ASN1uint32_t bucketSize;
#   define peakRate_present 0x10
    ASN1uint32_t peakRate;
#   define minPoliced_present 0x8
    ASN1uint32_t minPoliced;
#   define maxPktSize_present 0x4
    ASN1uint32_t maxPktSize;
} RSVPParameters;

typedef struct QOSCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define QOSCapability_nonStandardData_present 0x80
    NonStandardParameter nonStandardData;
#   define rsvpParameters_present 0x40
    RSVPParameters rsvpParameters;
#   define atmParameters_present 0x20
    ATMParameters atmParameters;
} QOSCapability;

typedef struct TransportCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define TransportCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
#   define qOSCapabilities_present 0x40
    PTransportCapability_qOSCapabilities qOSCapabilities;
#   define mediaChannelCapabilities_present 0x20
    TransportCapability_mediaChannelCapabilities mediaChannelCapabilities;
} TransportCapability;

typedef struct RedundancyEncodingMethod {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMethod_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define rtpAudioRedundancyEncoding_chosen 2
#	define rtpH263VideoRedundancyEncoding_chosen 3
	RTPH263VideoRedundancyEncoding rtpH263VideoRedundancyEncoding;
    } u;
} RedundancyEncodingMethod;

typedef struct H263Options {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t advancedIntraCodingMode;
    ASN1bool_t deblockingFilterMode;
    ASN1bool_t improvedPBFramesMode;
    ASN1bool_t unlimitedMotionVectors;
    ASN1bool_t fullPictureFreeze;
    ASN1bool_t partialPictureFreezeAndRelease;
    ASN1bool_t resizingPartPicFreezeAndRelease;
    ASN1bool_t fullPictureSnapshot;
    ASN1bool_t partialPictureSnapshot;
    ASN1bool_t videoSegmentTagging;
    ASN1bool_t progressiveRefinement;
    ASN1bool_t dynamicPictureResizingByFour;
    ASN1bool_t dynamicPictureResizingSixteenthPel;
    ASN1bool_t dynamicWarpingHalfPel;
    ASN1bool_t dynamicWarpingSixteenthPel;
    ASN1bool_t independentSegmentDecoding;
    ASN1bool_t slicesInOrder_NonRect;
    ASN1bool_t slicesInOrder_Rect;
    ASN1bool_t slicesNoOrder_NonRect;
    ASN1bool_t slicesNoOrder_Rect;
    ASN1bool_t alternateInterVLCMode;
    ASN1bool_t modifiedQuantizationMode;
    ASN1bool_t reducedResolutionUpdate;
#   define transparencyParameters_present 0x80
    TransparencyParameters transparencyParameters;
    ASN1bool_t separateVideoBackChannel;
#   define refPictureSelection_present 0x40
    RefPictureSelection refPictureSelection;
#   define customPictureClockFrequency_present 0x20
    PH263Options_customPictureClockFrequency customPictureClockFrequency;
#   define customPictureFormat_present 0x10
    PH263Options_customPictureFormat customPictureFormat;
#   define modeCombos_present 0x8
    PH263Options_modeCombos modeCombos;
} H263Options;

typedef struct H263VideoModeCombos {
    H263ModeComboFlags h263VideoUncoupledModes;
    H263VideoModeCombos_h263VideoCoupledModes h263VideoCoupledModes;
} H263VideoModeCombos;

typedef struct AudioCapability {
    ASN1choice_t choice;
    union {
#	define AudioCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioCapability_g711Alaw64k_chosen 2
	ASN1uint16_t g711Alaw64k;
#	define AudioCapability_g711Alaw56k_chosen 3
	ASN1uint16_t g711Alaw56k;
#	define AudioCapability_g711Ulaw64k_chosen 4
	ASN1uint16_t g711Ulaw64k;
#	define AudioCapability_g711Ulaw56k_chosen 5
	ASN1uint16_t g711Ulaw56k;
#	define AudioCapability_g722_64k_chosen 6
	ASN1uint16_t g722_64k;
#	define AudioCapability_g722_56k_chosen 7
	ASN1uint16_t g722_56k;
#	define AudioCapability_g722_48k_chosen 8
	ASN1uint16_t g722_48k;
#	define AudioCapability_g7231_chosen 9
	AudioCapability_g7231 g7231;
#	define AudioCapability_g728_chosen 10
	ASN1uint16_t g728;
#	define AudioCapability_g729_chosen 11
	ASN1uint16_t g729;
#	define AudioCapability_g729AnnexA_chosen 12
	ASN1uint16_t g729AnnexA;
#	define is11172AudioCapability_chosen 13
	IS11172AudioCapability is11172AudioCapability;
#	define is13818AudioCapability_chosen 14
	IS13818AudioCapability is13818AudioCapability;
#	define AudioCapability_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioCapability_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCCapability_chosen 17
	G7231AnnexCCapability g7231AnnexCCapability;
#	define AudioCapability_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioCapability_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioCapability_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioCapability;

typedef struct CompressionType {
    ASN1choice_t choice;
    union {
#	define v42bis_chosen 1
	V42bis v42bis;
    } u;
} CompressionType;

typedef struct MediaEncryptionAlgorithm {
    ASN1choice_t choice;
    union {
#	define MediaEncryptionAlgorithm_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define algorithm_chosen 2
	ASN1objectidentifier_t algorithm;
    } u;
} MediaEncryptionAlgorithm;

typedef struct AuthenticationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define AuthenticationCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} AuthenticationCapability;

typedef struct IntegrityCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define IntegrityCapability_nonStandard_present 0x80
    NonStandardParameter nonStandard;
} IntegrityCapability;

typedef struct H223AL1MParameters {
    H223AL1MParameters_transferMode transferMode;
    H223AL1MParameters_headerFEC headerFEC;
    H223AL1MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL1MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
    ASN1bool_t alsduSplitting;
} H223AL1MParameters;

typedef struct H223AL3MParameters {
    H223AL3MParameters_headerFormat headerFormat;
    H223AL3MParameters_crcLength crcLength;
    ASN1uint16_t rcpcCodeRate;
    H223AL3MParameters_arqType arqType;
    ASN1bool_t alpduInterleaving;
} H223AL3MParameters;

typedef struct V76HDLCParameters {
    CRCLength crcLength;
    ASN1uint16_t n401;
    ASN1bool_t loopbackTestProcedure;
} V76HDLCParameters;

typedef struct UnicastAddress {
    ASN1choice_t choice;
    union {
#	define UnicastAddress_iPAddress_chosen 1
	UnicastAddress_iPAddress iPAddress;
#	define iPXAddress_chosen 2
	UnicastAddress_iPXAddress iPXAddress;
#	define UnicastAddress_iP6Address_chosen 3
	UnicastAddress_iP6Address iP6Address;
#	define netBios_chosen 4
	struct UnicastAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define iPSourceRouteAddress_chosen 5
	UnicastAddress_iPSourceRouteAddress iPSourceRouteAddress;
#	define UnicastAddress_nsap_chosen 6
	struct UnicastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define UnicastAddress_nonStandardAddress_chosen 7
	NonStandardParameter nonStandardAddress;
    } u;
} UnicastAddress;

typedef struct MulticastAddress {
    ASN1choice_t choice;
    union {
#	define MulticastAddress_iPAddress_chosen 1
	MulticastAddress_iPAddress iPAddress;
#	define MulticastAddress_iP6Address_chosen 2
	MulticastAddress_iP6Address iP6Address;
#	define MulticastAddress_nsap_chosen 3
	struct MulticastAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define MulticastAddress_nonStandardAddress_chosen 4
	NonStandardParameter nonStandardAddress;
    } u;
} MulticastAddress;

typedef struct EncryptionSync {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define EncryptionSync_nonStandard_present 0x80
    NonStandardParameter nonStandard;
    ASN1uint16_t synchFlag;
    struct EncryptionSync_h235Key_h235Key {
	ASN1uint32_t length;
	ASN1octet_t value[65535];
    } h235Key;
#   define escrowentry_present 0x40
    PEncryptionSync_escrowentry escrowentry;
} EncryptionSync;

typedef struct RequestChannelClose {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define qosCapability_present 0x80
    QOSCapability qosCapability;
#   define RequestChannelClose_reason_present 0x40
    RequestChannelClose_reason reason;
} RequestChannelClose;

typedef struct MultiplexEntryDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    MultiplexTableEntryNumber multiplexTableEntryNumber;
#   define elementList_present 0x80
    MultiplexEntryDescriptor_elementList elementList;
} MultiplexEntryDescriptor;

typedef struct MultiplexEntrySendReject {
    SequenceNumber sequenceNumber;
    MultiplexEntrySendReject_rejectionDescriptions rejectionDescriptions;
} MultiplexEntrySendReject;

typedef struct RequestMultiplexEntryReject {
    RequestMultiplexEntryReject_entryNumbers entryNumbers;
    RequestMultiplexEntryReject_rejectionDescriptions rejectionDescriptions;
} RequestMultiplexEntryReject;

typedef struct H263VideoMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    H263VideoMode_resolution resolution;
    ASN1uint16_t bitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
#   define H263VideoMode_errorCompensation_present 0x80
    ASN1bool_t errorCompensation;
#   define H263VideoMode_enhancementLayerInfo_present 0x40
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoMode_h263Options_present 0x20
    H263Options h263Options;
} H263VideoMode;

typedef struct AudioMode {
    ASN1choice_t choice;
    union {
#	define AudioMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define AudioMode_g711Alaw64k_chosen 2
#	define AudioMode_g711Alaw56k_chosen 3
#	define AudioMode_g711Ulaw64k_chosen 4
#	define AudioMode_g711Ulaw56k_chosen 5
#	define AudioMode_g722_64k_chosen 6
#	define AudioMode_g722_56k_chosen 7
#	define AudioMode_g722_48k_chosen 8
#	define AudioMode_g728_chosen 9
#	define AudioMode_g729_chosen 10
#	define AudioMode_g729AnnexA_chosen 11
#	define AudioMode_g7231_chosen 12
	AudioMode_g7231 g7231;
#	define is11172AudioMode_chosen 13
	IS11172AudioMode is11172AudioMode;
#	define is13818AudioMode_chosen 14
	IS13818AudioMode is13818AudioMode;
#	define AudioMode_g729wAnnexB_chosen 15
	ASN1uint16_t g729wAnnexB;
#	define AudioMode_g729AnnexAwAnnexB_chosen 16
	ASN1uint16_t g729AnnexAwAnnexB;
#	define g7231AnnexCMode_chosen 17
	G7231AnnexCMode g7231AnnexCMode;
#	define AudioMode_gsmFullRate_chosen 18
	GSMAudioCapability gsmFullRate;
#	define AudioMode_gsmHalfRate_chosen 19
	GSMAudioCapability gsmHalfRate;
#	define AudioMode_gsmEnhancedFullRate_chosen 20
	GSMAudioCapability gsmEnhancedFullRate;
    } u;
} AudioMode;

typedef struct EncryptionMode {
    ASN1choice_t choice;
    union {
#	define EncryptionMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h233Encryption_chosen 2
    } u;
} EncryptionMode;

typedef struct ConferenceRequest {
    ASN1choice_t choice;
    union {
#	define terminalListRequest_chosen 1
#	define makeMeChair_chosen 2
#	define cancelMakeMeChair_chosen 3
#	define dropTerminal_chosen 4
	TerminalLabel dropTerminal;
#	define requestTerminalID_chosen 5
	TerminalLabel requestTerminalID;
#	define enterH243Password_chosen 6
#	define enterH243TerminalID_chosen 7
#	define enterH243ConferenceID_chosen 8
#	define enterExtensionAddress_chosen 9
#	define requestChairTokenOwner_chosen 10
#	define requestTerminalCertificate_chosen 11
	ConferenceRequest_requestTerminalCertificate requestTerminalCertificate;
#	define ConferenceRequest_broadcastMyLogicalChannel_chosen 12
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define ConferenceRequest_makeTerminalBroadcaster_chosen 13
	TerminalLabel makeTerminalBroadcaster;
#	define ConferenceRequest_sendThisSource_chosen 14
	TerminalLabel sendThisSource;
#	define requestAllTerminalIDs_chosen 15
#	define remoteMCRequest_chosen 16
	RemoteMCRequest remoteMCRequest;
    } u;
} ConferenceRequest;

typedef struct CertSelectionCriteria {
    PCertSelectionCriteria next;
    Criteria value;
} CertSelectionCriteria_Element;

typedef struct ConferenceResponse {
    ASN1choice_t choice;
    union {
#	define mCTerminalIDResponse_chosen 1
	ConferenceResponse_mCTerminalIDResponse mCTerminalIDResponse;
#	define terminalIDResponse_chosen 2
	ConferenceResponse_terminalIDResponse terminalIDResponse;
#	define conferenceIDResponse_chosen 3
	ConferenceResponse_conferenceIDResponse conferenceIDResponse;
#	define passwordResponse_chosen 4
	ConferenceResponse_passwordResponse passwordResponse;
#	define terminalListResponse_chosen 5
	ConferenceResponse_terminalListResponse terminalListResponse;
#	define videoCommandReject_chosen 6
#	define terminalDropReject_chosen 7
#	define makeMeChairResponse_chosen 8
	ConferenceResponse_makeMeChairResponse makeMeChairResponse;
#	define extensionAddressResponse_chosen 9
	ConferenceResponse_extensionAddressResponse extensionAddressResponse;
#	define chairTokenOwnerResponse_chosen 10
	ConferenceResponse_chairTokenOwnerResponse chairTokenOwnerResponse;
#	define terminalCertificateResponse_chosen 11
	ConferenceResponse_terminalCertificateResponse terminalCertificateResponse;
#	define broadcastMyLogicalChannelResponse_chosen 12
	ConferenceResponse_broadcastMyLogicalChannelResponse broadcastMyLogicalChannelResponse;
#	define makeTerminalBroadcasterResponse_chosen 13
	ConferenceResponse_makeTerminalBroadcasterResponse makeTerminalBroadcasterResponse;
#	define sendThisSourceResponse_chosen 14
	ConferenceResponse_sendThisSourceResponse sendThisSourceResponse;
#	define requestAllTerminalIDsResponse_chosen 15
	RequestAllTerminalIDsResponse requestAllTerminalIDsResponse;
#	define remoteMCResponse_chosen 16
	RemoteMCResponse remoteMCResponse;
    } u;
} ConferenceResponse;

typedef struct EndSessionCommand {
    ASN1choice_t choice;
    union {
#	define EndSessionCommand_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define disconnect_chosen 2
#	define gstnOptions_chosen 3
	EndSessionCommand_gstnOptions gstnOptions;
#	define isdnOptions_chosen 4
	EndSessionCommand_isdnOptions isdnOptions;
    } u;
} EndSessionCommand;

typedef struct ConferenceCommand {
    ASN1choice_t choice;
    union {
#	define ConferenceCommand_broadcastMyLogicalChannel_chosen 1
	LogicalChannelNumber broadcastMyLogicalChannel;
#	define cancelBroadcastMyLogicalChannel_chosen 2
	LogicalChannelNumber cancelBroadcastMyLogicalChannel;
#	define ConferenceCommand_makeTerminalBroadcaster_chosen 3
	TerminalLabel makeTerminalBroadcaster;
#	define cancelMakeTerminalBroadcaster_chosen 4
#	define ConferenceCommand_sendThisSource_chosen 5
	TerminalLabel sendThisSource;
#	define cancelSendThisSource_chosen 6
#	define dropConference_chosen 7
#	define substituteConferenceIDCommand_chosen 8
	SubstituteConferenceIDCommand substituteConferenceIDCommand;
    } u;
} ConferenceCommand;

typedef struct UserInputIndication_userInputSupportIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_userInputSupportIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define UserInputIndication_userInputSupportIndication_basicString_chosen 2
#	define UserInputIndication_userInputSupportIndication_iA5String_chosen 3
#	define UserInputIndication_userInputSupportIndication_generalString_chosen 4
    } u;
} UserInputIndication_userInputSupportIndication;

typedef struct MiscellaneousIndication_type {
    ASN1choice_t choice;
    union {
#	define logicalChannelActive_chosen 1
#	define logicalChannelInactive_chosen 2
#	define multipointConference_chosen 3
#	define cancelMultipointConference_chosen 4
#	define multipointZeroComm_chosen 5
#	define cancelMultipointZeroComm_chosen 6
#	define multipointSecondaryStatus_chosen 7
#	define cancelMultipointSecondaryStatus_chosen 8
#	define videoIndicateReadyToActivate_chosen 9
#	define MiscellaneousIndication_type_videoTemporalSpatialTradeOff_chosen 10
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoNotDecodedMBs_chosen 11
	MiscellaneousIndication_type_videoNotDecodedMBs videoNotDecodedMBs;
#	define transportCapability_chosen 12
	TransportCapability transportCapability;
    } u;
} MiscellaneousIndication_type;

typedef struct MiscellaneousCommand_type {
    ASN1choice_t choice;
    union {
#	define equaliseDelay_chosen 1
#	define zeroDelay_chosen 2
#	define multipointModeCommand_chosen 3
#	define cancelMultipointModeCommand_chosen 4
#	define videoFreezePicture_chosen 5
#	define videoFastUpdatePicture_chosen 6
#	define videoFastUpdateGOB_chosen 7
	MiscellaneousCommand_type_videoFastUpdateGOB videoFastUpdateGOB;
#	define MiscellaneousCommand_type_videoTemporalSpatialTradeOff_chosen 8
	ASN1uint16_t videoTemporalSpatialTradeOff;
#	define videoSendSyncEveryGOB_chosen 9
#	define videoSendSyncEveryGOBCancel_chosen 10
#	define videoFastUpdateMB_chosen 11
	MiscellaneousCommand_type_videoFastUpdateMB videoFastUpdateMB;
#	define maxH223MUXPDUsize_chosen 12
	ASN1uint16_t maxH223MUXPDUsize;
#	define encryptionUpdate_chosen 13
	EncryptionSync encryptionUpdate;
#	define encryptionUpdateRequest_chosen 14
	EncryptionUpdateRequest encryptionUpdateRequest;
#	define switchReceiveMediaOff_chosen 15
#	define switchReceiveMediaOn_chosen 16
#	define progressiveRefinementStart_chosen 17
	MiscellaneousCommand_type_progressiveRefinementStart progressiveRefinementStart;
#	define progressiveRefinementAbortOne_chosen 18
#	define progressiveRefinementAbortContinuous_chosen 19
    } u;
} MiscellaneousCommand_type;

typedef struct EncryptionCommand_encryptionAlgorithmID {
    SequenceNumber h233AlgorithmIdentifier;
    NonStandardParameter associatedAlgorithm;
} EncryptionCommand_encryptionAlgorithmID;

typedef struct CommunicationModeTableEntry_nonStandard {
    PCommunicationModeTableEntry_nonStandard next;
    NonStandardParameter value;
} CommunicationModeTableEntry_nonStandard_Element;

typedef struct RedundancyEncodingMode_secondaryEncoding {
    ASN1choice_t choice;
    union {
#	define RedundancyEncodingMode_secondaryEncoding_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define RedundancyEncodingMode_secondaryEncoding_audioData_chosen 2
	AudioMode audioData;
    } u;
} RedundancyEncodingMode_secondaryEncoding;

typedef struct H223ModeParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223ModeParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223ModeParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223ModeParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223ModeParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223ModeParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223ModeParameters_adaptationLayerType_al3_chosen 6
	H223ModeParameters_adaptationLayerType_al3 al3;
#	define H223ModeParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223ModeParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223ModeParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223ModeParameters_adaptationLayerType;

typedef struct MultiplexEntrySend_multiplexEntryDescriptors {
    PMultiplexEntrySend_multiplexEntryDescriptors next;
    MultiplexEntryDescriptor value;
} MultiplexEntrySend_multiplexEntryDescriptors_Element;

typedef struct H2250LogicalChannelAckParameters_nonStandard {
    PH2250LogicalChannelAckParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelAckParameters_nonStandard_Element;

typedef struct RTPPayloadType_payloadDescriptor {
    ASN1choice_t choice;
    union {
#	define nonStandardIdentifier_chosen 1
	NonStandardParameter nonStandardIdentifier;
#	define rfc_number_chosen 2
	ASN1uint16_t rfc_number;
#	define oid_chosen 3
	ASN1objectidentifier_t oid;
    } u;
} RTPPayloadType_payloadDescriptor;

typedef struct H2250LogicalChannelParameters_nonStandard {
    PH2250LogicalChannelParameters_nonStandard next;
    NonStandardParameter value;
} H2250LogicalChannelParameters_nonStandard_Element;

typedef struct H223LogicalChannelParameters_adaptationLayerType {
    ASN1choice_t choice;
    union {
#	define H223LogicalChannelParameters_adaptationLayerType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H223LogicalChannelParameters_adaptationLayerType_al1Framed_chosen 2
#	define H223LogicalChannelParameters_adaptationLayerType_al1NotFramed_chosen 3
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithoutSequenceNumbers_chosen 4
#	define H223LogicalChannelParameters_adaptationLayerType_al2WithSequenceNumbers_chosen 5
#	define H223LogicalChannelParameters_adaptationLayerType_al3_chosen 6
	H223LogicalChannelParameters_adaptationLayerType_al3 al3;
#	define H223LogicalChannelParameters_adaptationLayerType_al1M_chosen 7
	H223AL1MParameters al1M;
#	define H223LogicalChannelParameters_adaptationLayerType_al2M_chosen 8
	H223AL2MParameters al2M;
#	define H223LogicalChannelParameters_adaptationLayerType_al3M_chosen 9
	H223AL3MParameters al3M;
    } u;
} H223LogicalChannelParameters_adaptationLayerType;

typedef struct ConferenceCapability_nonStandardData {
    PConferenceCapability_nonStandardData next;
    NonStandardParameter value;
} ConferenceCapability_nonStandardData_Element;

typedef struct UserInputCapability_nonStandard {
    ASN1uint32_t count;
    NonStandardParameter value[16];
} UserInputCapability_nonStandard;

typedef struct DataProtocolCapability_v76wCompression {
    ASN1choice_t choice;
    union {
#	define transmitCompression_chosen 1
	CompressionType transmitCompression;
#	define receiveCompression_chosen 2
	CompressionType receiveCompression;
#	define transmitAndReceiveCompression_chosen 3
	CompressionType transmitAndReceiveCompression;
    } u;
} DataProtocolCapability_v76wCompression;

typedef struct H263Options_modeCombos {
    PH263Options_modeCombos next;
    H263VideoModeCombos value;
} H263Options_modeCombos_Element;

typedef struct TransportCapability_qOSCapabilities {
    PTransportCapability_qOSCapabilities next;
    QOSCapability value;
} TransportCapability_qOSCapabilities_Element;

typedef struct NonStandardMessage {
    NonStandardParameter nonStandardData;
} NonStandardMessage;

typedef struct RedundancyEncodingCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
    CapabilityTableEntryNumber primaryEncoding;
#   define RedundancyEncodingCapability_secondaryEncoding_present 0x80
    PRedundancyEncodingCapability_secondaryEncoding secondaryEncoding;
} RedundancyEncodingCapability;

typedef struct H263VideoCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H263VideoCapability_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define H263VideoCapability_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define H263VideoCapability_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define H263VideoCapability_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define H263VideoCapability_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t advancedPrediction;
    ASN1bool_t pbFrames;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define hrd_B_present 0x4
    ASN1uint32_t hrd_B;
#   define bppMaxKb_present 0x2
    ASN1uint16_t bppMaxKb;
#   define H263VideoCapability_slowSqcifMPI_present 0x8000
    ASN1uint16_t slowSqcifMPI;
#   define H263VideoCapability_slowQcifMPI_present 0x4000
    ASN1uint16_t slowQcifMPI;
#   define H263VideoCapability_slowCifMPI_present 0x2000
    ASN1uint16_t slowCifMPI;
#   define H263VideoCapability_slowCif4MPI_present 0x1000
    ASN1uint16_t slowCif4MPI;
#   define H263VideoCapability_slowCif16MPI_present 0x800
    ASN1uint16_t slowCif16MPI;
#   define H263VideoCapability_errorCompensation_present 0x400
    ASN1bool_t errorCompensation;
#   define H263VideoCapability_enhancementLayerInfo_present 0x200
    EnhancementLayerInfo enhancementLayerInfo;
#   define H263VideoCapability_h263Options_present 0x100
    H263Options h263Options;
} H263VideoCapability;

typedef struct EnhancementOptions {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define EnhancementOptions_sqcifMPI_present 0x80
    ASN1uint16_t sqcifMPI;
#   define EnhancementOptions_qcifMPI_present 0x40
    ASN1uint16_t qcifMPI;
#   define EnhancementOptions_cifMPI_present 0x20
    ASN1uint16_t cifMPI;
#   define EnhancementOptions_cif4MPI_present 0x10
    ASN1uint16_t cif4MPI;
#   define EnhancementOptions_cif16MPI_present 0x8
    ASN1uint16_t cif16MPI;
    ASN1uint32_t maxBitRate;
    ASN1bool_t unrestrictedVector;
    ASN1bool_t arithmeticCoding;
    ASN1bool_t temporalSpatialTradeOffCapability;
#   define EnhancementOptions_slowSqcifMPI_present 0x4
    ASN1uint16_t slowSqcifMPI;
#   define EnhancementOptions_slowQcifMPI_present 0x2
    ASN1uint16_t slowQcifMPI;
#   define EnhancementOptions_slowCifMPI_present 0x1
    ASN1uint16_t slowCifMPI;
#   define EnhancementOptions_slowCif4MPI_present 0x8000
    ASN1uint16_t slowCif4MPI;
#   define EnhancementOptions_slowCif16MPI_present 0x4000
    ASN1uint16_t slowCif16MPI;
    ASN1bool_t errorCompensation;
#   define EnhancementOptions_h263Options_present 0x2000
    H263Options h263Options;
} EnhancementOptions;

typedef struct DataProtocolCapability {
    ASN1choice_t choice;
    union {
#	define DataProtocolCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define v14buffered_chosen 2
#	define v42lapm_chosen 3
#	define hdlcFrameTunnelling_chosen 4
#	define h310SeparateVCStack_chosen 5
#	define h310SingleVCStack_chosen 6
#	define transparent_chosen 7
#	define segmentationAndReassembly_chosen 8
#	define hdlcFrameTunnelingwSAR_chosen 9
#	define v120_chosen 10
#	define separateLANStack_chosen 11
#	define v76wCompression_chosen 12
	DataProtocolCapability_v76wCompression v76wCompression;
    } u;
} DataProtocolCapability;

typedef struct EncryptionAuthenticationAndIntegrity {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define encryptionCapability_present 0x80
    PEncryptionCapability encryptionCapability;
#   define authenticationCapability_present 0x40
    AuthenticationCapability authenticationCapability;
#   define integrityCapability_present 0x20
    IntegrityCapability integrityCapability;
} EncryptionAuthenticationAndIntegrity;

typedef struct EncryptionCapability {
    PEncryptionCapability next;
    MediaEncryptionAlgorithm value;
} EncryptionCapability_Element;

typedef struct UserInputCapability {
    ASN1choice_t choice;
    union {
#	define UserInputCapability_nonStandard_chosen 1
	UserInputCapability_nonStandard nonStandard;
#	define UserInputCapability_basicString_chosen 2
#	define UserInputCapability_iA5String_chosen 3
#	define UserInputCapability_generalString_chosen 4
#	define dtmf_chosen 5
#	define hookflash_chosen 6
    } u;
} UserInputCapability;

typedef struct H223LogicalChannelParameters {
    H223LogicalChannelParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223LogicalChannelParameters;

typedef struct V76LogicalChannelParameters {
    V76HDLCParameters hdlcParameters;
    V76LogicalChannelParameters_suspendResume suspendResume;
    ASN1bool_t uIH;
    V76LogicalChannelParameters_mode mode;
    V75Parameters v75Parameters;
} V76LogicalChannelParameters;

typedef struct RTPPayloadType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RTPPayloadType_payloadDescriptor payloadDescriptor;
#   define payloadType_present 0x80
    ASN1uint16_t payloadType;
} RTPPayloadType;

typedef struct H245TransportAddress {
    ASN1choice_t choice;
    union {
#	define unicastAddress_chosen 1
	UnicastAddress unicastAddress;
#	define multicastAddress_chosen 2
	MulticastAddress multicastAddress;
    } u;
} H245TransportAddress;

typedef struct H2250LogicalChannelAckParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define H2250LogicalChannelAckParameters_nonStandard_present 0x80
    PH2250LogicalChannelAckParameters_nonStandard nonStandard;
#   define sessionID_present 0x40
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelAckParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelAckParameters_mediaControlChannel_present 0x10
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelAckParameters_dynamicRTPPayloadType_present 0x8
    ASN1uint16_t dynamicRTPPayloadType;
#   define flowControlToZero_present 0x8000
    ASN1bool_t flowControlToZero;
#   define H2250LogicalChannelAckParameters_portNumber_present 0x4000
    ASN1uint16_t portNumber;
} H2250LogicalChannelAckParameters;

typedef struct H223ModeParameters {
    H223ModeParameters_adaptationLayerType adaptationLayerType;
    ASN1bool_t segmentableFlag;
} H223ModeParameters;

typedef struct RedundancyEncodingMode {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncodingMode_secondaryEncoding_present 0x80
    RedundancyEncodingMode_secondaryEncoding secondaryEncoding;
} RedundancyEncodingMode;

typedef struct VideoMode {
    ASN1choice_t choice;
    union {
#	define VideoMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoMode_chosen 2
	H261VideoMode h261VideoMode;
#	define h262VideoMode_chosen 3
	H262VideoMode h262VideoMode;
#	define h263VideoMode_chosen 4
	H263VideoMode h263VideoMode;
#	define is11172VideoMode_chosen 5
	IS11172VideoMode is11172VideoMode;
    } u;
} VideoMode;

typedef struct EncryptionCommand {
    ASN1choice_t choice;
    union {
#	define encryptionSE_chosen 1
	ASN1octetstring_t encryptionSE;
#	define encryptionIVRequest_chosen 2
#	define encryptionAlgorithmID_chosen 3
	EncryptionCommand_encryptionAlgorithmID encryptionAlgorithmID;
    } u;
} EncryptionCommand;

typedef struct MiscellaneousCommand {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousCommand_type type;
} MiscellaneousCommand;

typedef struct MiscellaneousIndication {
    LogicalChannelNumber logicalChannelNumber;
    MiscellaneousIndication_type type;
} MiscellaneousIndication;

typedef struct MCLocationIndication {
    H245TransportAddress signalAddress;
} MCLocationIndication;

typedef struct UserInputIndication {
    ASN1choice_t choice;
    union {
#	define UserInputIndication_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define alphanumeric_chosen 2
	ASN1ztcharstring_t alphanumeric;
#	define userInputSupportIndication_chosen 3
	UserInputIndication_userInputSupportIndication userInputSupportIndication;
#	define signal_chosen 4
	UserInputIndication_signal signal;
#	define signalUpdate_chosen 5
	UserInputIndication_signalUpdate signalUpdate;
    } u;
} UserInputIndication;

typedef struct DataApplicationCapability_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataApplicationCapability_application_nlpid;

typedef struct DataApplicationCapability_application_t84 {
    DataProtocolCapability t84Protocol;
    T84Profile t84Profile;
} DataApplicationCapability_application_t84;

typedef struct DataMode_application_nlpid {
    DataProtocolCapability nlpidProtocol;
    ASN1octetstring_t nlpidData;
} DataMode_application_nlpid;

typedef struct DataMode_application {
    ASN1choice_t choice;
    union {
#	define DataMode_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataMode_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataMode_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataMode_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataMode_application_t84_chosen 5
	DataProtocolCapability t84;
#	define DataMode_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataMode_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataMode_application_nlpid_chosen 8
	DataMode_application_nlpid nlpid;
#	define DataMode_application_dsvdControl_chosen 9
#	define DataMode_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataMode_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataMode_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataMode_application;

typedef struct OpenLogicalChannelAck_forwardMultiplexAckParameters {
    ASN1choice_t choice;
    union {
#	define h2250LogicalChannelAckParameters_chosen 1
	H2250LogicalChannelAckParameters h2250LogicalChannelAckParameters;
    } u;
} OpenLogicalChannelAck_forwardMultiplexAckParameters;

typedef struct H2250LogicalChannelParameters_mediaPacketization {
    ASN1choice_t choice;
    union {
#	define h261aVideoPacketization_chosen 1
#	define rtpPayloadType_chosen 2
	RTPPayloadType rtpPayloadType;
    } u;
} H2250LogicalChannelParameters_mediaPacketization;

typedef struct NetworkAccessParameters_networkAddress {
    ASN1choice_t choice;
    union {
#	define q2931Address_chosen 1
	Q2931Address q2931Address;
#	define e164Address_chosen 2
	ASN1char_t e164Address[129];
#	define localAreaAddress_chosen 3
	H245TransportAddress localAreaAddress;
    } u;
} NetworkAccessParameters_networkAddress;

typedef struct DataApplicationCapability_application {
    ASN1choice_t choice;
    union {
#	define DataApplicationCapability_application_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define DataApplicationCapability_application_t120_chosen 2
	DataProtocolCapability t120;
#	define DataApplicationCapability_application_dsm_cc_chosen 3
	DataProtocolCapability dsm_cc;
#	define DataApplicationCapability_application_userData_chosen 4
	DataProtocolCapability userData;
#	define DataApplicationCapability_application_t84_chosen 5
	DataApplicationCapability_application_t84 t84;
#	define DataApplicationCapability_application_t434_chosen 6
	DataProtocolCapability t434;
#	define DataApplicationCapability_application_h224_chosen 7
	DataProtocolCapability h224;
#	define DataApplicationCapability_application_nlpid_chosen 8
	DataApplicationCapability_application_nlpid nlpid;
#	define DataApplicationCapability_application_dsvdControl_chosen 9
#	define DataApplicationCapability_application_h222DataPartitioning_chosen 10
	DataProtocolCapability h222DataPartitioning;
#	define DataApplicationCapability_application_t30fax_chosen 11
	DataProtocolCapability t30fax;
#	define DataApplicationCapability_application_t140_chosen 12
	DataProtocolCapability t140;
    } u;
} DataApplicationCapability_application;

typedef struct EnhancementLayerInfo_spatialEnhancement {
    PEnhancementLayerInfo_spatialEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_spatialEnhancement_Element;

typedef struct EnhancementLayerInfo_snrEnhancement {
    PEnhancementLayerInfo_snrEnhancement next;
    EnhancementOptions value;
} EnhancementLayerInfo_snrEnhancement_Element;

typedef struct MediaPacketizationCapability_rtpPayloadType {
    ASN1uint32_t count;
    RTPPayloadType value[256];
} MediaPacketizationCapability_rtpPayloadType;

typedef struct H2250Capability_redundancyEncodingCapability {
    PH2250Capability_redundancyEncodingCapability next;
    RedundancyEncodingCapability value;
} H2250Capability_redundancyEncodingCapability_Element;

typedef struct CommandMessage {
    ASN1choice_t choice;
    union {
#	define CommandMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define maintenanceLoopOffCommand_chosen 2
	MaintenanceLoopOffCommand maintenanceLoopOffCommand;
#	define sendTerminalCapabilitySet_chosen 3
	SendTerminalCapabilitySet sendTerminalCapabilitySet;
#	define encryptionCommand_chosen 4
	EncryptionCommand encryptionCommand;
#	define flowControlCommand_chosen 5
	FlowControlCommand flowControlCommand;
#	define endSessionCommand_chosen 6
	EndSessionCommand endSessionCommand;
#	define miscellaneousCommand_chosen 7
	MiscellaneousCommand miscellaneousCommand;
#	define communicationModeCommand_chosen 8
	CommunicationModeCommand communicationModeCommand;
#	define conferenceCommand_chosen 9
	ConferenceCommand conferenceCommand;
#	define h223MultiplexReconfiguration_chosen 10
	H223MultiplexReconfiguration h223MultiplexReconfiguration;
    } u;
} CommandMessage;

typedef struct H235SecurityCapability {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    CapabilityTableEntryNumber mediaCapability;
} H235SecurityCapability;

typedef struct MediaPacketizationCapability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t h261aVideoPacketization;
#   define rtpPayloadType_present 0x80
    MediaPacketizationCapability_rtpPayloadType rtpPayloadType;
} MediaPacketizationCapability;

typedef struct VideoCapability {
    ASN1choice_t choice;
    union {
#	define VideoCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h261VideoCapability_chosen 2
	H261VideoCapability h261VideoCapability;
#	define h262VideoCapability_chosen 3
	H262VideoCapability h262VideoCapability;
#	define h263VideoCapability_chosen 4
	H263VideoCapability h263VideoCapability;
#	define is11172VideoCapability_chosen 5
	IS11172VideoCapability is11172VideoCapability;
    } u;
} VideoCapability;

typedef struct BEnhancementParameters {
    EnhancementOptions enhancementOptions;
    ASN1uint16_t numberOfBPictures;
} BEnhancementParameters;

typedef struct DataApplicationCapability {
    DataApplicationCapability_application application;
    ASN1uint32_t maxBitRate;
} DataApplicationCapability;

typedef struct NetworkAccessParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define distribution_present 0x80
    NetworkAccessParameters_distribution distribution;
    NetworkAccessParameters_networkAddress networkAddress;
    ASN1bool_t associateConference;
#   define externalReference_present 0x40
    struct NetworkAccessParameters_externalReference_externalReference {
	ASN1uint32_t length;
	ASN1octet_t value[255];
    } externalReference;
#   define t120SetupProcedure_present 0x8000
    NetworkAccessParameters_t120SetupProcedure t120SetupProcedure;
} NetworkAccessParameters;

typedef struct H2250ModeParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define redundancyEncodingMode_present 0x80
    RedundancyEncodingMode redundancyEncodingMode;
} H2250ModeParameters;

typedef struct DataMode {
    DataMode_application application;
    ASN1uint32_t bitRate;
} DataMode;

typedef struct CommunicationModeTableEntry_dataType {
    ASN1choice_t choice;
    union {
#	define CommunicationModeTableEntry_dataType_videoData_chosen 1
	VideoCapability videoData;
#	define CommunicationModeTableEntry_dataType_audioData_chosen 2
	AudioCapability audioData;
#	define CommunicationModeTableEntry_dataType_data_chosen 3
	DataApplicationCapability data;
    } u;
} CommunicationModeTableEntry_dataType;

typedef struct H235Mode_mediaMode {
    ASN1choice_t choice;
    union {
#	define H235Mode_mediaMode_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Mode_mediaMode_videoMode_chosen 2
	VideoMode videoMode;
#	define H235Mode_mediaMode_audioMode_chosen 3
	AudioMode audioMode;
#	define H235Mode_mediaMode_dataMode_chosen 4
	DataMode dataMode;
    } u;
} H235Mode_mediaMode;

typedef struct H235Media_mediaType {
    ASN1choice_t choice;
    union {
#	define H235Media_mediaType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define H235Media_mediaType_videoData_chosen 2
	VideoCapability videoData;
#	define H235Media_mediaType_audioData_chosen 3
	AudioCapability audioData;
#	define H235Media_mediaType_data_chosen 4
	DataApplicationCapability data;
    } u;
} H235Media_mediaType;

typedef struct EnhancementLayerInfo_bPictureEnhancement {
    PEnhancementLayerInfo_bPictureEnhancement next;
    BEnhancementParameters value;
} EnhancementLayerInfo_bPictureEnhancement_Element;

typedef struct MediaDistributionCapability_distributedData {
    PMediaDistributionCapability_distributedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_distributedData_Element;

typedef struct MediaDistributionCapability_centralizedData {
    PMediaDistributionCapability_centralizedData next;
    DataApplicationCapability value;
} MediaDistributionCapability_centralizedData_Element;

typedef struct Capability {
    ASN1choice_t choice;
    union {
#	define Capability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define receiveVideoCapability_chosen 2
	VideoCapability receiveVideoCapability;
#	define transmitVideoCapability_chosen 3
	VideoCapability transmitVideoCapability;
#	define receiveAndTransmitVideoCapability_chosen 4
	VideoCapability receiveAndTransmitVideoCapability;
#	define receiveAudioCapability_chosen 5
	AudioCapability receiveAudioCapability;
#	define transmitAudioCapability_chosen 6
	AudioCapability transmitAudioCapability;
#	define receiveAndTransmitAudioCapability_chosen 7
	AudioCapability receiveAndTransmitAudioCapability;
#	define receiveDataApplicationCapability_chosen 8
	DataApplicationCapability receiveDataApplicationCapability;
#	define transmitDataApplicationCapability_chosen 9
	DataApplicationCapability transmitDataApplicationCapability;
#	define receiveAndTransmitDataApplicationCapability_chosen 10
	DataApplicationCapability receiveAndTransmitDataApplicationCapability;
#	define h233EncryptionTransmitCapability_chosen 11
	ASN1bool_t h233EncryptionTransmitCapability;
#	define h233EncryptionReceiveCapability_chosen 12
	Capability_h233EncryptionReceiveCapability h233EncryptionReceiveCapability;
#	define conferenceCapability_chosen 13
	ConferenceCapability conferenceCapability;
#	define h235SecurityCapability_chosen 14
	H235SecurityCapability h235SecurityCapability;
#	define maxPendingReplacementFor_chosen 15
	ASN1uint16_t maxPendingReplacementFor;
#	define receiveUserInputCapability_chosen 16
	UserInputCapability receiveUserInputCapability;
#	define transmitUserInputCapability_chosen 17
	UserInputCapability transmitUserInputCapability;
#	define receiveAndTransmitUserInputCapability_chosen 18
	UserInputCapability receiveAndTransmitUserInputCapability;
    } u;
} Capability;

typedef struct H2250Capability {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t maximumAudioDelayJitter;
    MultipointCapability receiveMultipointCapability;
    MultipointCapability transmitMultipointCapability;
    MultipointCapability receiveAndTransmitMultipointCapability;
    H2250Capability_mcCapability mcCapability;
    ASN1bool_t rtcpVideoControlCapability;
    MediaPacketizationCapability mediaPacketizationCapability;
#   define H2250Capability_transportCapability_present 0x80
    TransportCapability transportCapability;
#   define redundancyEncodingCapability_present 0x40
    PH2250Capability_redundancyEncodingCapability redundancyEncodingCapability;
#   define logicalChannelSwitchingCapability_present 0x20
    ASN1bool_t logicalChannelSwitchingCapability;
#   define t120DynamicPortCapability_present 0x10
    ASN1bool_t t120DynamicPortCapability;
} H2250Capability;

typedef struct H235Media {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Media_mediaType mediaType;
} H235Media;

typedef struct H235Mode {
    EncryptionAuthenticationAndIntegrity encryptionAuthenticationAndIntegrity;
    H235Mode_mediaMode mediaMode;
} H235Mode;

typedef struct ModeElement_type {
    ASN1choice_t choice;
    union {
#	define ModeElement_type_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define ModeElement_type_videoMode_chosen 2
	VideoMode videoMode;
#	define ModeElement_type_audioMode_chosen 3
	AudioMode audioMode;
#	define ModeElement_type_dataMode_chosen 4
	DataMode dataMode;
#	define encryptionMode_chosen 5
	EncryptionMode encryptionMode;
#	define h235Mode_chosen 6
	H235Mode h235Mode;
    } u;
} ModeElement_type;

typedef struct CapabilityTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityTableEntryNumber capabilityTableEntryNumber;
#   define capability_present 0x80
    Capability capability;
} CapabilityTableEntry;

typedef struct MultiplexCapability {
    ASN1choice_t choice;
    union {
#	define MultiplexCapability_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define h222Capability_chosen 2
	H222Capability h222Capability;
#	define h223Capability_chosen 3
	H223Capability h223Capability;
#	define v76Capability_chosen 4
	V76Capability v76Capability;
#	define h2250Capability_chosen 5
	H2250Capability h2250Capability;
    } u;
} MultiplexCapability;

typedef struct DataType {
    ASN1choice_t choice;
    union {
#	define DataType_nonStandard_chosen 1
	NonStandardParameter nonStandard;
#	define nullData_chosen 2
#	define DataType_videoData_chosen 3
	VideoCapability videoData;
#	define DataType_audioData_chosen 4
	AudioCapability audioData;
#	define DataType_data_chosen 5
	DataApplicationCapability data;
#	define encryptionData_chosen 6
	EncryptionMode encryptionData;
#	define h235Control_chosen 7
	NonStandardParameter h235Control;
#	define h235Media_chosen 8
	H235Media h235Media;
    } u;
} DataType;

typedef struct RedundancyEncoding {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RedundancyEncodingMethod redundancyEncodingMethod;
#   define RedundancyEncoding_secondaryEncoding_present 0x80
    DataType secondaryEncoding;
} RedundancyEncoding;

typedef struct ModeElement {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    ModeElement_type type;
#   define h223ModeParameters_present 0x80
    H223ModeParameters h223ModeParameters;
#   define v76ModeParameters_present 0x8000
    V76ModeParameters v76ModeParameters;
#   define h2250ModeParameters_present 0x4000
    H2250ModeParameters h2250ModeParameters;
} ModeElement;

typedef struct CommunicationModeTableEntry {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define CommunicationModeTableEntry_nonStandard_present 0x80
    PCommunicationModeTableEntry_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define CommunicationModeTableEntry_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define CommunicationModeTableEntry_terminalLabel_present 0x20
    TerminalLabel terminalLabel;
    ASN1char16string_t sessionDescription;
    CommunicationModeTableEntry_dataType dataType;
#   define CommunicationModeTableEntry_mediaChannel_present 0x10
    H245TransportAddress mediaChannel;
#   define CommunicationModeTableEntry_mediaGuaranteedDelivery_present 0x8
    ASN1bool_t mediaGuaranteedDelivery;
#   define CommunicationModeTableEntry_mediaControlChannel_present 0x4
    H245TransportAddress mediaControlChannel;
#   define CommunicationModeTableEntry_mediaControlGuaranteedDelivery_present 0x2
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define CommunicationModeTableEntry_redundancyEncoding_present 0x8000
    RedundancyEncoding redundancyEncoding;
#   define sessionDependency_present 0x4000
    ASN1uint16_t sessionDependency;
#   define CommunicationModeTableEntry_destination_present 0x2000
    TerminalLabel destination;
} CommunicationModeTableEntry;

typedef struct CommunicationModeResponse_communicationModeTable {
    PCommunicationModeResponse_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeResponse_communicationModeTable_Element;

typedef struct CommunicationModeCommand_communicationModeTable {
    PCommunicationModeCommand_communicationModeTable next;
    CommunicationModeTableEntry value;
} CommunicationModeCommand_communicationModeTable_Element;

typedef struct TerminalCapabilitySet_capabilityTable {
    PTerminalCapabilitySet_capabilityTable next;
    CapabilityTableEntry value;
} TerminalCapabilitySet_capabilityTable_Element;

typedef struct TerminalCapabilitySet {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SequenceNumber sequenceNumber;
    ASN1objectidentifier_t protocolIdentifier;
#   define multiplexCapability_present 0x80
    MultiplexCapability multiplexCapability;
#   define capabilityTable_present 0x40
    PTerminalCapabilitySet_capabilityTable capabilityTable;
#   define capabilityDescriptors_present 0x20
    TerminalCapabilitySet_capabilityDescriptors capabilityDescriptors;
} TerminalCapabilitySet;

typedef struct H2250LogicalChannelParameters {
    union {
	ASN1uint32_t bit_mask;
	ASN1octet_t o[3];
    };
#   define H2250LogicalChannelParameters_nonStandard_present 0x80
    PH2250LogicalChannelParameters_nonStandard nonStandard;
    ASN1uint16_t sessionID;
#   define H2250LogicalChannelParameters_associatedSessionID_present 0x40
    ASN1uint16_t associatedSessionID;
#   define H2250LogicalChannelParameters_mediaChannel_present 0x20
    H245TransportAddress mediaChannel;
#   define H2250LogicalChannelParameters_mediaGuaranteedDelivery_present 0x10
    ASN1bool_t mediaGuaranteedDelivery;
#   define H2250LogicalChannelParameters_mediaControlChannel_present 0x8
    H245TransportAddress mediaControlChannel;
#   define H2250LogicalChannelParameters_mediaControlGuaranteedDelivery_present 0x4
    ASN1bool_t mediaControlGuaranteedDelivery;
#   define silenceSuppression_present 0x2
    ASN1bool_t silenceSuppression;
#   define H2250LogicalChannelParameters_destination_present 0x1
    TerminalLabel destination;
#   define H2250LogicalChannelParameters_dynamicRTPPayloadType_present 0x8000
    ASN1uint16_t dynamicRTPPayloadType;
#   define mediaPacketization_present 0x4000
    H2250LogicalChannelParameters_mediaPacketization mediaPacketization;
#   define H2250LogicalChannelParameters_transportCapability_present 0x800000
    TransportCapability transportCapability;
#   define H2250LogicalChannelParameters_redundancyEncoding_present 0x400000
    RedundancyEncoding redundancyEncoding;
#   define source_present 0x200000
    TerminalLabel source;
} H2250LogicalChannelParameters;

typedef struct ModeDescription {
    ASN1uint32_t count;
    ModeElement value[256];
} ModeDescription;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 2
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 3
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 4
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
#	define OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters_none_chosen 5
    } u;
} OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h223LogicalChannelParameters_chosen 1
	H223LogicalChannelParameters h223LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_v76LogicalChannelParameters_chosen 2
	V76LogicalChannelParameters v76LogicalChannelParameters;
#	define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 3
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters {
    ASN1choice_t choice;
    union {
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h222LogicalChannelParameters_chosen 1
	H222LogicalChannelParameters h222LogicalChannelParameters;
#	define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_h2250LogicalChannelParameters_chosen 2
	H2250LogicalChannelParameters h2250LogicalChannelParameters;
    } u;
} OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters;

typedef struct RequestMode_requestedModes {
    PRequestMode_requestedModes next;
    ModeDescription value;
} RequestMode_requestedModes_Element;

typedef struct OpenLogicalChannelAck_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber reverseLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters_present 0x40
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_replacementFor_present 0x8000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannelAck_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_reverseLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    DataType dataType;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define reverseLogicalChannelDependency_present 0x8000
    LogicalChannelNumber reverseLogicalChannelDependency;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_reverseLogicalChannelParameters;

typedef struct OpenLogicalChannel_forwardLogicalChannelParameters {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
#   define OpenLogicalChannel_forwardLogicalChannelParameters_portNumber_present 0x80
    ASN1uint16_t portNumber;
    DataType dataType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters multiplexParameters;
#   define forwardLogicalChannelDependency_present 0x8000
    LogicalChannelNumber forwardLogicalChannelDependency;
#   define OpenLogicalChannel_forwardLogicalChannelParameters_replacementFor_present 0x4000
    LogicalChannelNumber replacementFor;
} OpenLogicalChannel_forwardLogicalChannelParameters;

typedef struct OpenLogicalChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
    OpenLogicalChannel_forwardLogicalChannelParameters forwardLogicalChannelParameters;
#   define OpenLogicalChannel_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannel_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannel_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define OpenLogicalChannel_encryptionSync_present 0x4000
    EncryptionSync encryptionSync;
} OpenLogicalChannel;

typedef struct OpenLogicalChannelAck {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[2];
    };
    LogicalChannelNumber forwardLogicalChannelNumber;
#   define OpenLogicalChannelAck_reverseLogicalChannelParameters_present 0x80
    OpenLogicalChannelAck_reverseLogicalChannelParameters reverseLogicalChannelParameters;
#   define OpenLogicalChannelAck_separateStack_present 0x8000
    NetworkAccessParameters separateStack;
#   define forwardMultiplexAckParameters_present 0x4000
    OpenLogicalChannelAck_forwardMultiplexAckParameters forwardMultiplexAckParameters;
#   define OpenLogicalChannelAck_encryptionSync_present 0x2000
    EncryptionSync encryptionSync;
} OpenLogicalChannelAck;

typedef struct RequestMessage {
    ASN1choice_t choice;
    union {
#	define RequestMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDetermination_chosen 2
	MasterSlaveDetermination masterSlaveDetermination;
#	define terminalCapabilitySet_chosen 3
	TerminalCapabilitySet terminalCapabilitySet;
#	define openLogicalChannel_chosen 4
	OpenLogicalChannel openLogicalChannel;
#	define closeLogicalChannel_chosen 5
	CloseLogicalChannel closeLogicalChannel;
#	define requestChannelClose_chosen 6
	RequestChannelClose requestChannelClose;
#	define multiplexEntrySend_chosen 7
	MultiplexEntrySend multiplexEntrySend;
#	define requestMultiplexEntry_chosen 8
	RequestMultiplexEntry requestMultiplexEntry;
#	define requestMode_chosen 9
	RequestMode requestMode;
#	define roundTripDelayRequest_chosen 10
	RoundTripDelayRequest roundTripDelayRequest;
#	define maintenanceLoopRequest_chosen 11
	MaintenanceLoopRequest maintenanceLoopRequest;
#	define communicationModeRequest_chosen 12
	CommunicationModeRequest communicationModeRequest;
#	define conferenceRequest_chosen 13
	ConferenceRequest conferenceRequest;
    } u;
} RequestMessage;

typedef struct ResponseMessage {
    ASN1choice_t choice;
    union {
#	define ResponseMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define masterSlaveDeterminationAck_chosen 2
	MasterSlaveDeterminationAck masterSlaveDeterminationAck;
#	define masterSlaveDeterminationReject_chosen 3
	MasterSlaveDeterminationReject masterSlaveDeterminationReject;
#	define terminalCapabilitySetAck_chosen 4
	TerminalCapabilitySetAck terminalCapabilitySetAck;
#	define terminalCapabilitySetReject_chosen 5
	TerminalCapabilitySetReject terminalCapabilitySetReject;
#	define openLogicalChannelAck_chosen 6
	OpenLogicalChannelAck openLogicalChannelAck;
#	define openLogicalChannelReject_chosen 7
	OpenLogicalChannelReject openLogicalChannelReject;
#	define closeLogicalChannelAck_chosen 8
	CloseLogicalChannelAck closeLogicalChannelAck;
#	define requestChannelCloseAck_chosen 9
	RequestChannelCloseAck requestChannelCloseAck;
#	define requestChannelCloseReject_chosen 10
	RequestChannelCloseReject requestChannelCloseReject;
#	define multiplexEntrySendAck_chosen 11
	MultiplexEntrySendAck multiplexEntrySendAck;
#	define multiplexEntrySendReject_chosen 12
	MultiplexEntrySendReject multiplexEntrySendReject;
#	define requestMultiplexEntryAck_chosen 13
	RequestMultiplexEntryAck requestMultiplexEntryAck;
#	define requestMultiplexEntryReject_chosen 14
	RequestMultiplexEntryReject requestMultiplexEntryReject;
#	define requestModeAck_chosen 15
	RequestModeAck requestModeAck;
#	define requestModeReject_chosen 16
	RequestModeReject requestModeReject;
#	define roundTripDelayResponse_chosen 17
	RoundTripDelayResponse roundTripDelayResponse;
#	define maintenanceLoopAck_chosen 18
	MaintenanceLoopAck maintenanceLoopAck;
#	define maintenanceLoopReject_chosen 19
	MaintenanceLoopReject maintenanceLoopReject;
#	define communicationModeResponse_chosen 20
	CommunicationModeResponse communicationModeResponse;
#	define conferenceResponse_chosen 21
	ConferenceResponse conferenceResponse;
    } u;
} ResponseMessage;

typedef OpenLogicalChannel FastConnectOLC;
#define FastConnectOLC_PDU 0
#define SIZE_H245ASN_Module_PDU_0 sizeof(FastConnectOLC)

typedef struct FunctionNotUnderstood {
    ASN1choice_t choice;
    union {
#	define FunctionNotUnderstood_request_chosen 1
	RequestMessage request;
#	define FunctionNotUnderstood_response_chosen 2
	ResponseMessage response;
#	define FunctionNotUnderstood_command_chosen 3
	CommandMessage command;
    } u;
} FunctionNotUnderstood;

typedef struct IndicationMessage {
    ASN1choice_t choice;
    union {
#	define IndicationMessage_nonStandard_chosen 1
	NonStandardMessage nonStandard;
#	define functionNotUnderstood_chosen 2
	FunctionNotUnderstood functionNotUnderstood;
#	define masterSlaveDeterminationRelease_chosen 3
	MasterSlaveDeterminationRelease masterSlaveDeterminationRelease;
#	define terminalCapabilitySetRelease_chosen 4
	TerminalCapabilitySetRelease terminalCapabilitySetRelease;
#	define openLogicalChannelConfirm_chosen 5
	OpenLogicalChannelConfirm openLogicalChannelConfirm;
#	define requestChannelCloseRelease_chosen 6
	RequestChannelCloseRelease requestChannelCloseRelease;
#	define multiplexEntrySendRelease_chosen 7
	MultiplexEntrySendRelease multiplexEntrySendRelease;
#	define requestMultiplexEntryRelease_chosen 8
	RequestMultiplexEntryRelease requestMultiplexEntryRelease;
#	define requestModeRelease_chosen 9
	RequestModeRelease requestModeRelease;
#	define miscellaneousIndication_chosen 10
	MiscellaneousIndication miscellaneousIndication;
#	define jitterIndication_chosen 11
	JitterIndication jitterIndication;
#	define h223SkewIndication_chosen 12
	H223SkewIndication h223SkewIndication;
#	define newATMVCIndication_chosen 13
	NewATMVCIndication newATMVCIndication;
#	define userInput_chosen 14
	UserInputIndication userInput;
#	define h2250MaximumSkewIndication_chosen 15
	H2250MaximumSkewIndication h2250MaximumSkewIndication;
#	define mcLocationIndication_chosen 16
	MCLocationIndication mcLocationIndication;
#	define conferenceIndication_chosen 17
	ConferenceIndication conferenceIndication;
#	define vendorIdentification_chosen 18
	VendorIdentification vendorIdentification;
#	define IndicationMessage_functionNotSupported_chosen 19
	FunctionNotSupported functionNotSupported;
    } u;
} IndicationMessage;

typedef struct MultimediaSystemControlMessage {
    ASN1choice_t choice;
    union {
#	define MultimediaSystemControlMessage_request_chosen 1
	RequestMessage request;
#	define MultimediaSystemControlMessage_response_chosen 2
	ResponseMessage response;
#	define MultimediaSystemControlMessage_command_chosen 3
	CommandMessage command;
#	define indication_chosen 4
	IndicationMessage indication;
    } u;
} MultimediaSystemControlMessage;
#define MultimediaSystemControlMessage_PDU 1
#define SIZE_H245ASN_Module_PDU_1 sizeof(MultimediaSystemControlMessage)


extern ASN1module_t H245ASN_Module;
extern void ASN1CALL H245ASN_Module_Startup(void);
extern void ASN1CALL H245ASN_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1encoding_t enc, PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Dec_UnicastAddress_iPSourceRouteAddress_route_ElmFn(ASN1decoding_t dec, PUnicastAddress_iPSourceRouteAddress_route val);
	extern void ASN1CALL ASN1Free_UnicastAddress_iPSourceRouteAddress_route_ElmFn(PUnicastAddress_iPSourceRouteAddress_route val);
    extern int ASN1CALL ASN1Enc_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1encoding_t enc, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Dec_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(ASN1decoding_t dec, PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
	extern void ASN1CALL ASN1Free_SendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers_ElmFn(PSendTerminalCapabilitySet_specificRequest_capabilityTableEntryNumbers val);
    extern int ASN1CALL ASN1Enc_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1encoding_t enc, PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Dec_RedundancyEncodingCapability_secondaryEncoding_ElmFn(ASN1decoding_t dec, PRedundancyEncodingCapability_secondaryEncoding val);
	extern void ASN1CALL ASN1Free_RedundancyEncodingCapability_secondaryEncoding_ElmFn(PRedundancyEncodingCapability_secondaryEncoding val);
    extern int ASN1CALL ASN1Enc_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1encoding_t enc, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Dec_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(ASN1decoding_t dec, PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
	extern void ASN1CALL ASN1Free_RTPH263VideoRedundancyEncoding_frameToThreadMapping_custom_ElmFn(PRTPH263VideoRedundancyEncoding_frameToThreadMapping_custom val);
    extern int ASN1CALL ASN1Enc_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1encoding_t enc, PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Dec_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(ASN1decoding_t dec, PRequestAllTerminalIDsResponse_terminalInformation val);
	extern void ASN1CALL ASN1Free_RequestAllTerminalIDsResponse_terminalInformation_ElmFn(PRequestAllTerminalIDsResponse_terminalInformation val);
    extern int ASN1CALL ASN1Enc_EncryptionSync_escrowentry_ElmFn(ASN1encoding_t enc, PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Dec_EncryptionSync_escrowentry_ElmFn(ASN1decoding_t dec, PEncryptionSync_escrowentry val);
	extern void ASN1CALL ASN1Free_EncryptionSync_escrowentry_ElmFn(PEncryptionSync_escrowentry val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureFormat_ElmFn(ASN1encoding_t enc, PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureFormat_ElmFn(ASN1decoding_t dec, PH263Options_customPictureFormat val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureFormat_ElmFn(PH263Options_customPictureFormat val);
    extern int ASN1CALL ASN1Enc_H263Options_customPictureClockFrequency_ElmFn(ASN1encoding_t enc, PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Dec_H263Options_customPictureClockFrequency_ElmFn(ASN1decoding_t dec, PH263Options_customPictureClockFrequency val);
	extern void ASN1CALL ASN1Free_H263Options_customPictureClockFrequency_ElmFn(PH263Options_customPictureClockFrequency val);
    extern int ASN1CALL ASN1Enc_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1encoding_t enc, PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Dec_MultipointCapability_mediaDistributionCapability_ElmFn(ASN1decoding_t dec, PMultipointCapability_mediaDistributionCapability val);
	extern void ASN1CALL ASN1Free_MultipointCapability_mediaDistributionCapability_ElmFn(PMultipointCapability_mediaDistributionCapability val);
    extern int ASN1CALL ASN1Enc_H222Capability_vcCapability_ElmFn(ASN1encoding_t enc, PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Dec_H222Capability_vcCapability_ElmFn(ASN1decoding_t dec, PH222Capability_vcCapability val);
	extern void ASN1CALL ASN1Free_H222Capability_vcCapability_ElmFn(PH222Capability_vcCapability val);
    extern int ASN1CALL ASN1Enc_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1encoding_t enc, PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Dec_CapabilityDescriptor_simultaneousCapabilities_ElmFn(ASN1decoding_t dec, PCapabilityDescriptor_simultaneousCapabilities val);
	extern void ASN1CALL ASN1Free_CapabilityDescriptor_simultaneousCapabilities_ElmFn(PCapabilityDescriptor_simultaneousCapabilities val);
    extern int ASN1CALL ASN1Enc_CertSelectionCriteria_ElmFn(ASN1encoding_t enc, PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Dec_CertSelectionCriteria_ElmFn(ASN1decoding_t dec, PCertSelectionCriteria val);
	extern void ASN1CALL ASN1Free_CertSelectionCriteria_ElmFn(PCertSelectionCriteria val);
    extern int ASN1CALL ASN1Enc_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1encoding_t enc, PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Dec_CommunicationModeTableEntry_nonStandard_ElmFn(ASN1decoding_t dec, PCommunicationModeTableEntry_nonStandard val);
	extern void ASN1CALL ASN1Free_CommunicationModeTableEntry_nonStandard_ElmFn(PCommunicationModeTableEntry_nonStandard val);
    extern int ASN1CALL ASN1Enc_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1encoding_t enc, PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Dec_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(ASN1decoding_t dec, PMultiplexEntrySend_multiplexEntryDescriptors val);
	extern void ASN1CALL ASN1Free_MultiplexEntrySend_multiplexEntryDescriptors_ElmFn(PMultiplexEntrySend_multiplexEntryDescriptors val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelAckParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelAckParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelAckParameters_nonStandard_ElmFn(PH2250LogicalChannelAckParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1encoding_t enc, PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Dec_H2250LogicalChannelParameters_nonStandard_ElmFn(ASN1decoding_t dec, PH2250LogicalChannelParameters_nonStandard val);
	extern void ASN1CALL ASN1Free_H2250LogicalChannelParameters_nonStandard_ElmFn(PH2250LogicalChannelParameters_nonStandard val);
    extern int ASN1CALL ASN1Enc_ConferenceCapability_nonStandardData_ElmFn(ASN1encoding_t enc, PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Dec_ConferenceCapability_nonStandardData_ElmFn(ASN1decoding_t dec, PConferenceCapability_nonStandardData val);
	extern void ASN1CALL ASN1Free_ConferenceCapability_nonStandardData_ElmFn(PConferenceCapability_nonStandardData val);
    extern int ASN1CALL ASN1Enc_H263Options_modeCombos_ElmFn(ASN1encoding_t enc, PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Dec_H263Options_modeCombos_ElmFn(ASN1decoding_t dec, PH263Options_modeCombos val);
	extern void ASN1CALL ASN1Free_H263Options_modeCombos_ElmFn(PH263Options_modeCombos val);
    extern int ASN1CALL ASN1Enc_TransportCapability_qOSCapabilities_ElmFn(ASN1encoding_t enc, PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Dec_TransportCapability_qOSCapabilities_ElmFn(ASN1decoding_t dec, PTransportCapability_qOSCapabilities val);
	extern void ASN1CALL ASN1Free_TransportCapability_qOSCapabilities_ElmFn(PTransportCapability_qOSCapabilities val);
    extern int ASN1CALL ASN1Enc_EncryptionCapability_ElmFn(ASN1encoding_t enc, PEncryptionCapability val);
    extern int ASN1CALL ASN1Dec_EncryptionCapability_ElmFn(ASN1decoding_t dec, PEncryptionCapability val);
	extern void ASN1CALL ASN1Free_EncryptionCapability_ElmFn(PEncryptionCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_spatialEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_spatialEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_spatialEnhancement_ElmFn(PEnhancementLayerInfo_spatialEnhancement val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_snrEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_snrEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_snrEnhancement_ElmFn(PEnhancementLayerInfo_snrEnhancement val);
    extern int ASN1CALL ASN1Enc_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1encoding_t enc, PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Dec_H2250Capability_redundancyEncodingCapability_ElmFn(ASN1decoding_t dec, PH2250Capability_redundancyEncodingCapability val);
	extern void ASN1CALL ASN1Free_H2250Capability_redundancyEncodingCapability_ElmFn(PH2250Capability_redundancyEncodingCapability val);
    extern int ASN1CALL ASN1Enc_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1encoding_t enc, PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Dec_EnhancementLayerInfo_bPictureEnhancement_ElmFn(ASN1decoding_t dec, PEnhancementLayerInfo_bPictureEnhancement val);
	extern void ASN1CALL ASN1Free_EnhancementLayerInfo_bPictureEnhancement_ElmFn(PEnhancementLayerInfo_bPictureEnhancement val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_distributedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_distributedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_distributedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_distributedData_ElmFn(PMediaDistributionCapability_distributedData val);
    extern int ASN1CALL ASN1Enc_MediaDistributionCapability_centralizedData_ElmFn(ASN1encoding_t enc, PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Dec_MediaDistributionCapability_centralizedData_ElmFn(ASN1decoding_t dec, PMediaDistributionCapability_centralizedData val);
	extern void ASN1CALL ASN1Free_MediaDistributionCapability_centralizedData_ElmFn(PMediaDistributionCapability_centralizedData val);
    extern int ASN1CALL ASN1Enc_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeResponse_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeResponse_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeResponse_communicationModeTable_ElmFn(PCommunicationModeResponse_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1encoding_t enc, PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Dec_CommunicationModeCommand_communicationModeTable_ElmFn(ASN1decoding_t dec, PCommunicationModeCommand_communicationModeTable val);
	extern void ASN1CALL ASN1Free_CommunicationModeCommand_communicationModeTable_ElmFn(PCommunicationModeCommand_communicationModeTable val);
    extern int ASN1CALL ASN1Enc_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1encoding_t enc, PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Dec_TerminalCapabilitySet_capabilityTable_ElmFn(ASN1decoding_t dec, PTerminalCapabilitySet_capabilityTable val);
	extern void ASN1CALL ASN1Free_TerminalCapabilitySet_capabilityTable_ElmFn(PTerminalCapabilitySet_capabilityTable val);
    extern int ASN1CALL ASN1Enc_RequestMode_requestedModes_ElmFn(ASN1encoding_t enc, PRequestMode_requestedModes val);
    extern int ASN1CALL ASN1Dec_RequestMode_requestedModes_ElmFn(ASN1decoding_t dec, PRequestMode_requestedModes val);
	extern void ASN1CALL ASN1Free_RequestMode_requestedModes_ElmFn(PRequestMode_requestedModes val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H245ASN_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323audt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: H323audt.h
//
// Description: Definition of the CH323AudioCaptureTerminal class and 
//     CH323AudioRenderTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _H323AUDT_H_
#define _H323AUDT_H_

#include "h323term.h"

/////////////////////////////////////////////////////////////////////////////
// CH323AudioCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD AUDIO_CAPTURE_FILTER_NUMPINS = 1;

class CH323AudioCaptureTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &IID_ITBasicAudioTerminal, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &IID_ITStaticAudioTerminal, &LIBID_TAPI3Lib>, 
    public CH323BaseTerminal
{

BEGIN_COM_MAP(CH323AudioCaptureTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323AudioCaptureTerminal();

    virtual ~CH323AudioCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

// ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

// ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IAMAudioInputMixer *    m_pIAMAudioInputMixer;
};

/////////////////////////////////////////////////////////////////////////////
// CH323AudioRenderTerminal
/////////////////////////////////////////////////////////////////////////////

const DWORD AUDIO_RENDER_FILTER_NUMPINS = 1;

class CH323AudioRenderTerminal : 
    public IDispatchImpl<ITBasicAudioTerminal, &IID_ITBasicAudioTerminal, &LIBID_TAPI3Lib>,
    public IDispatchImpl<ITStaticAudioTerminal, &IID_ITStaticAudioTerminal, &LIBID_TAPI3Lib>, 
    public CH323BaseTerminal
{

BEGIN_COM_MAP(CH323AudioRenderTerminal)
    COM_INTERFACE_ENTRY(ITBasicAudioTerminal)
    COM_INTERFACE_ENTRY(ITStaticAudioTerminal)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323AudioRenderTerminal();

    virtual ~CH323AudioRenderTerminal();

    static HRESULT CreateTerminal(
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  AudioDeviceInfo *pAudioDevieInfo,
        IN  MSP_HANDLE      htAddress
        );

    STDMETHODIMP DisconnectTerminal(
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

// ITBasicAudioTerminal
    STDMETHOD(get_Balance)(OUT  long *pVal);
    STDMETHOD(put_Balance)(IN   long newVal);
    STDMETHOD(get_Volume) (OUT  long *pVal);
    STDMETHOD(put_Volume) (IN   long newVal);

// ITStaticAudioTerminal
    STDMETHOD(get_WaveId) (OUT  long * plWaveId);

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return AUDIO_RENDER_FILTER_NUMPINS;
    }

    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );
protected:
    UINT                    m_WaveID;
    GUID                    m_DSoundGuid;

    IBasicAudio *           m_pIBasicAudio;
};

#endif // _H323AUDT_H_

// eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323aud.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confaud.h

Abstract:

    Definitions for audio streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFAUD_H_
#define __CONFAUD_H_

// the volume range for the API.
const long  MIN_VOLUME    = 0;      
const long  MAX_VOLUME    = 0xFFFF;

const long  BALANCE_LEFT  = -100;
const long  BALANCE_RIGHT = 100;

const long  BOOST_FACTOR = 100;

// the volume range of the IAMInputMixer
const double MIXER_MIN_VOLUME = 0.0;
const double MIXER_MAX_VOLUME = 1.0;

const long DEFUAT_AEC_STATUS = 0;
const long DEFUAT_AGC_STATUS = 1;

class CStreamAudioRecv : 
    public CH323MSPStream,
    public ITAudioSettings
{

BEGIN_COM_MAP(CStreamAudioRecv)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamAudioRecv();
    ~CStreamAudioRecv();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController * pIAudioDuplexController
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT SetUpInternalFilters(
        IN IPin * pTerminalInputPin
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );
    
    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT InitializeH245CapabilityTable();

protected:
    IBaseFilter *           m_pDecoderFilter;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pRenderBitrateControl;
};

class CStreamAudioSend : 
    public CH323MSPStream,
    public ITAudioSettings,
    public ITAudioDeviceControl

{

BEGIN_COM_MAP(CStreamAudioSend)
    COM_INTERFACE_ENTRY(ITAudioSettings)
    COM_INTERFACE_ENTRY(ITAudioDeviceControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamAudioSend();
    ~CStreamAudioSend();

    HRESULT ShutDown();

    // this method is called by the call object at init time.
    void SetFullDuplexController(
        IN IAudioDuplexController *pIAudioDuplexController
        );

    //
    // ITAudioDeviceControl methods
    //
    STDMETHOD (GetRange) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioDeviceProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioDeviceProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITAudioSettings methods
    //
    STDMETHOD (GetRange) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   AudioSettingsProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   AudioSettingsProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pPin
        );

    HRESULT GetAudioCapturePin(
        IN   ITTerminalControl *    pTerminal,
        OUT  IPin **                ppIPin
        );

    void CleanupCachedInterface();

    HRESULT CacheAdditionalInterfaces(
        IN  IPin *                 pIPin
        );

protected:
    ISilenceControl *       m_pSilenceControl;
    IAMAudioInputMixer  *   m_pAudioInputMixer;
    IAudioDeviceControl *   m_pAudioDeviceControl;
    IAudioDuplexController *m_pIAudioDuplexController;
    IBitrateControl *       m_pCaptureBitrateControl;
    IBaseFilter *           m_pEncoder;
    long                    m_lAutomaticGainControl;
    long                    m_lAcousticEchoCancellation;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323err.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    H323err.h

Abstract:

    Error definitions for H.32X MSP

Author:
    Michael VanBuskirk (mikev) 06/25/99
--*/

#ifndef _H323ERR_H_
#define _H323ERR_H_

#include <winerror.h>



#define H323MSP_FACILITY		        0x100		// facility code for audio/video communications
#define MAKE_H323MSP_ERROR(z,e)	        MAKE_HRESULT(1,H323MSP_FACILITY,(((z)&0xF000)|(e)))
#define MAKE_H323MSP_WARNING(z,w)	    MAKE_HRESULT(0,H323MSP_FACILITY,(((z)&0xF000)|(w)))

#define H323MSP_ZONE		            0x0000		
#define H323MSP_WINSOCK_ZONE		    0x1000		
#define H323MSP_TAPI_ZONE		        0x2000		// error caused by unexpected TAPI error 
#define H323H245_ZONE		            0x3000		
#define H323ASN1_ZONE		            0x4000	

#define H323MSP_WIN32_ZONE			    0xF000		// Win32 error code

#define MAKE_WIN32_ERROR(e)		        MAKE_H323MSP_ERROR (H323MSP_WIN32_ZONE, e)
#define MAKE_WINSOCK_ERROR(e)	        MAKE_H323MSP_ERROR (H323MSP_WINSOCK_ZONE, e)
#define MAKE_ASN1_ERROR(e)	            MAKE_H323MSP_ERROR (H323ASN1_ZONE, e)
#define MAKE_H245_ERROR(e)	            MAKE_H323MSP_ERROR (H323H245_ZONE, e)


// warnings
#define W_ENUMERATION_REQUIRED          MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0001)
#define W_NO_CAPABILITY_INTERSECTION    MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0002)
#define W_NO_FASTCONNECT_CAPABILITY     MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0003)
#define W_NOINTERFACE                   MAKE_H323MSP_WARNING(H323MSP_ZONE, 0x0004)

// general MSP errors
#define H323MSP_NOMEM 	                MAKE_H323MSP_ERROR(H323MSP_ZONE, 0x0001)
#define H323MSP_E_CAP_ENUMERATION_REQUIRED      MAKE_H323MSP_ERROR(H323MSP_ZONE, 0x0002)

// H.245 session errors
#define H245_ERROR_OK                   S_OK
#define H245_INVALID_STATE              MAKE_H323MSP_ERROR(H323H245_ZONE, 0x0001)   

#endif // _H323ERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323strm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    h323Strm.h

Abstract:

    Definitions for CH323MSPStream class.

Author:

    Mu Han (muhan) 1-November-1997

--*/
#ifndef __CONFSTRM_H
#define __CONFSTRM_H


/////////////////////////////////////////////////////////////////////////////
// CH323MSPStream
/////////////////////////////////////////////////////////////////////////////

// We support at most one codec filters per stream for now.
const DWORD MAX_CODECS = 1;

#ifdef DEBUG_REFCOUNT
extern LONG g_lStreamObjects;
#endif

class CH323MSPStream :
    public ISubstreamControl,
    public ITFormatControl,
    public ITStreamQualityControl,
    public IH245SubstreamControl,
    public IInnerStreamQualityControl,
    public CMSPObjectSafetyImpl,
    public CMSPStream
{

BEGIN_COM_MAP(CH323MSPStream)
    COM_INTERFACE_ENTRY(ISubstreamControl)
    COM_INTERFACE_ENTRY(ITFormatControl)
    COM_INTERFACE_ENTRY(ITStreamQualityControl)
    COM_INTERFACE_ENTRY(IH245SubstreamControl)
    COM_INTERFACE_ENTRY(IInnerStreamQualityControl)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_CHAIN(CMSPStream)
END_COM_MAP()

public:

    //
    // ITFormatControl methods
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    STDMETHOD (ReleaseFormat) (
        IN AM_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        );

    STDMETHOD (GetStreamCaps) (
        IN DWORD dwIndex, 
        OUT AM_MEDIA_TYPE **ppMediaType, 
        OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT BOOL *pfEnabled
        );

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   StreamQualityProperty Property, 
        OUT  long *plMin, 
        OUT  long *plMax, 
        OUT  long *plSteppingDelta, 
        OUT  long *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   StreamQualityProperty Property, 
        OUT  long *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    // ISubstreamControl methods.
    //
    STDMETHOD (SC_SetFormat) ( 
        IN   AM_MEDIA_TYPE *pMediaType,
        IN   DWORD dwFormatID,
        IN   DWORD dwPayloadType  
        );
        
    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);
    
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication);
    
    STDMETHOD (SC_Pause) (VOID);

    STDMETHOD (SC_SetBitrate) ( 
        IN   DWORD dwBitsPerSecond
        );
        
    STDMETHOD (SC_RemoteTemporalSpatialTradeoff) ( 
        IN   USHORT uTSRemoteValue
        );
    
    STDMETHOD (SC_CreateSubstream) ( 
        OUT  ISubstreamControl *pSubStream
        );

    STDMETHOD (SC_SetRemoteAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pRemoteMediaAddr,
        IN   PSOCKADDR_IN pRemoteControlAddr
        );
        
    STDMETHOD (SC_SetSource) (  
        // indicates the low 8 bits of the local SSRC (if this is a send substream)  
        // or the low 8 bits of the senders SSRC (if this is a receive substream)
        IN   BYTE bSource
        );

    STDMETHOD (SC_SelectLocalAddress) ( 
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalAddress,            // local IP address (same as H.245)
        OUT  PSOCKADDR_IN pLocalMediaAddress, // NULL if opening TX channel, else we want to know the local RTP receive address
        OUT  PSOCKADDR_IN pLocalControlAddress    // We want to know the local RTCP address
        );

    STDMETHOD (SC_SetLocalReceiveAddress) (             // only called when the receive address is non-negotiable (e.g. multicast case)
        IN OUT HANDLE * phRTPSession,           // handle to the shared RTP session.
        IN   PSOCKADDR_IN pLocalMediaAddr,  // local IP address (same as H.245)
        IN   PSOCKADDR_IN pLocalControlAddress, 
        IN   PSOCKADDR_IN pRemoteControlAddress
        );
        
    STDMETHOD (SC_SendDTMF) ( 
        IN   LPWSTR pwstrDialChars
        );
        
    STDMETHOD (SC_SetDESKey52) ( 
        IN   BYTE *pKey
        );

    STDMETHOD (SC_SelectTerminal) ( 
        IN   ITTerminal *pTerminal
        );
        
    STDMETHOD (SC_UnselectTerminal) (  
        IN   ITTerminal *pTerminal
        );

    //
    // IH245SubstreamControl
    //
    STDMETHOD (H245SC_BeginControlSession) (
        IN   IH245ChannelControl *pIChannelControl
        );
    
    STDMETHOD (H245SC_EndControlSession) (VOID);   
    
    STDMETHOD (H245SC_GetNumberOfCapabilities) ( 
        OUT DWORD *pdwTemplateCount, 
        OUT DWORD *pdwFormatCount
        );

    STDMETHOD (H245SC_GetStreamCaps) ( 
        IN   DWORD dwIndex, 
        OUT  const H245MediaCapability** pph245Capability, 
        OUT  AM_MEDIA_TYPE **ppMediaType, 
        OUT  TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT  DWORD *pdwUniqueID,
        OUT  UINT *puResourceBoundArrayEntries,
        OUT  const FormatResourceBounds **ppResourceBoundArray    
        );

    STDMETHOD (H245SC_RefineStreamCap) ( 
        IN   DWORD dwUniqueID,
        IN   DWORD dwResourceBoundIndex,
        IN OUT H245MediaCapability* ph245Capability
        );
     
    STDMETHOD (H245SC_SetIDBase) ( 
        IN   UINT uNewBase
        );
    
    STDMETHOD (H245SC_FindIDByRange) ( 
        IN   AM_MEDIA_TYPE *pAMMediaType,
        OUT  DWORD *pdwUniqueID
        );     

    STDMETHOD (H245SC_FindIDByMode) ( 
        IN   H245_MODE_ELEMENT *pModeElement,
        OUT  DWORD *pdwUniqueID
        );

    STDMETHOD (H245SC_IntersectFormats) ( 
        IN   const H245MediaCapability *pLocalCapability, 
        IN   DWORD dwUniqueID,
        IN   const H245MediaCapability *pRemoteCapability, 
        OUT  const H245MediaCapability **pIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        );

	STDMETHOD (H245SC_GetLocalFormat) (
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability, 
		OUT AM_MEDIA_TYPE **ppAMMediaType
		);
		
    STDMETHOD (H245SC_ReleaseNegotiatedCapability) ( 
        IN  DWORD dwUniqueID,
        IN  const H245MediaCapability *pIntersectedCapability 
        );

    //
    // IInnerStreamQualityControl
    //
    STDMETHOD (LinkInnerCallQC) (
        IN  IInnerCallQualityControl *pIInnerCallQC
        );

    STDMETHOD (UnlinkInnerCallQC) (
        IN  BOOL fByStream
        );

    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN  InnerStreamQualityProperty property,
        IN  LONG  lValue1,
        IN  TAPIControlFlags lFlags
        );

    STDMETHOD (Get) (
        IN  InnerStreamQualityProperty property,
        OUT LONG *plValue,
        OUT TAPIControlFlags *plFlags
        );

    STDMETHOD (TryLockStream)() { return m_lock.TryLock()?S_OK:S_FALSE; }

    STDMETHOD (UnlockStream)() { m_lock.Unlock(); return S_OK; }

    STDMETHOD (IsAccessingQC)() { return m_fAccessingQC?S_OK:S_FALSE; }


public:

    CH323MSPStream();

#ifdef DEBUG_REFCOUNT
    
    ULONG InternalAddRef();
    ULONG InternalRelease();

#endif

    // CMSPStream methods.
    HRESULT ShutDown ();

     // ITStream
    STDMETHOD (get_Name) (
        OUT     BSTR *      ppName
        );

    STDMETHOD (StartStream) ();
    STDMETHOD (PauseStream) ();
    STDMETHOD (StopStream) ();

    STDMETHOD (SelectTerminal)(
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal)(
        IN      ITTerminal *            pTerminal
        );

protected:
    virtual HRESULT CheckTerminalTypeAndDirection(
        IN      ITTerminal *    pTerminal
        );

    virtual HRESULT SendStreamEvent(
        IN      MSP_CALL_EVENT          Event,
        IN      MSP_CALL_EVENT_CAUSE    Cause,
        IN      HRESULT                 hrError,
        IN      ITTerminal *            pTerminal
        );

    virtual HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        ) = 0;

    virtual HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    virtual HRESULT CleanUpFilters();
    
    HRESULT ProcessGraphEvent(
        IN  long lEventCode,
        IN  LONG_PTR lParam1,
        IN  LONG_PTR lParam2
        );

    HRESULT EnableQOS(
        IN   AM_MEDIA_TYPE *pMediaType
        );

    virtual HRESULT ProcessQOSEvent(
        IN  long lEventCode
        );

    virtual HRESULT InitializeH245CapabilityTable();
    virtual HRESULT CleanupH245CapabilityTable();
    virtual HRESULT AddCodecToTable(IPin *pIPin);

protected:
    const WCHAR *   m_szName;

    // the filter before the terminal.
    IBaseFilter *   m_pEdgeFilter;

    // the RTP filter.
    IBaseFilter *   m_pRTPFilter;

    // used to remember the shared RTP session.
    HANDLE          m_hRTPSession;

    // additional state for the stream
    BOOL            m_fTimeout;

    // Callback interface to the H.245 module.
    IH245ChannelControl * m_pChannelControl;

    // Callback interface to the quality controller.
    CStreamQualityControlRelay * m_pStreamQCRelay;
    
    // capability related members.
    DWORD               m_dwCapabilityIDBase;
    DWORD               m_dwNumCodecs;
    DWORD               m_dwNumH245Caps;
    DWORD               m_dwTotalVariations;
    IStreamConfig *     m_StreamConfigInterfaces[MAX_CODECS];
    IH245Capability *   m_H245Interfaces[MAX_CODECS];
    H245MediaCapabilityTable m_H245CapabilityTables[MAX_CODECS];

    // flag will be set when stream is accessing quality control methods
    // that will in turn lock the stream list lock inside quality control.
    BOOL                m_fAccessingQC;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323term.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    H323term.h

Abstract:

    Definitions for the CH323BaseTerminal

Author:

    Zoltan Szilagyi (zoltans) September 6,1998

--*/

#ifndef _H323TERM_H_
#define _H323TERM_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// CH323BaseTerminal                                                           
//                                                                         
//                                                                         
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if 0
// {e309dcd8-1ed6-11d3-a576-00c04f8ef6e3}
DEFINE_GUID(IID_IH323PrivateTerminal,
0xe309dcd8, 0x1ed6, 0x11d3, 0xa5, 0x76, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);

DECLARE_INTERFACE_(IH323PrivateTerminal, IUnknown)
{
    STDMETHOD (GetFilter) (THIS_
        IBaseFilter *
        ) PURE;
};
#endif 

class CH323BaseTerminal : 
    virtual public CComObjectRootEx<CComMultiThreadModelNoCS>, // we have our own CS implementation
    public IDispatchImpl<ITTerminal, &IID_ITTerminal, &LIBID_TAPI3Lib>,
    public ITTerminalControl,
    public CMSPObjectSafetyImpl
{

BEGIN_COM_MAP(CH323BaseTerminal)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITTerminal)
    COM_INTERFACE_ENTRY(ITTerminalControl)
    COM_INTERFACE_ENTRY2(IDispatch, ITTerminal)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

public:

    CH323BaseTerminal();
    HRESULT FinalConstruct();
    virtual ~CH323BaseTerminal();

public:
// ITTerminal -- COM interface for use by MSP or application
    STDMETHOD(get_TerminalClass)(OUT  BSTR *pVal);
    STDMETHOD(get_TerminalType) (OUT  TERMINAL_TYPE *pVal);
    STDMETHOD(get_State)        (OUT  TERMINAL_STATE *pVal);
    STDMETHOD(get_Name)         (OUT  BSTR *pVal);
    STDMETHOD(get_MediaType)    (OUT  long * plMediaType);
    STDMETHOD(get_Direction)    (OUT  TERMINAL_DIRECTION *pDirection);

// ITTerminalControl -- COM interface for use by MSP only

    STDMETHOD (get_AddressHandle) (
            OUT     MSP_HANDLE    * phtAddress
            );

    STDMETHOD (ConnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved,
            IN OUT  DWORD          * pdwNumPins,
            OUT     IPin          ** ppPins
            );

    STDMETHOD (CompleteConnectTerminal) (void);

    STDMETHOD (DisconnectTerminal) (
            IN      IGraphBuilder  * pGraph,
            IN      DWORD            dwReserved
            );

    STDMETHOD (RunRenderFilter) (void);

    STDMETHOD (StopRenderFilter) (void);

public:
    HRESULT Initialize(
            IN  WCHAR *             strName,
            IN  MSP_HANDLE          htAddress
            );

    HRESULT Initialize(
            IN  char *              strName,
            IN  MSP_HANDLE          htAddress
            );

protected:
    void Lock()     { EnterCriticalSection(&m_CritSec); }
    void Unlock()   { LeaveCriticalSection(&m_CritSec); }

    virtual DWORD GetNumExposedPins() const = 0;

    virtual HRESULT CreateFilter() = 0;

    virtual HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        ) = 0;

    virtual HRESULT AddFilterToGraph(
        IN  IGraphBuilder *pGraph
        );

    virtual HRESULT RemoveFilterFromGraph(
        IN  IGraphBuilder *pGraph
        );

protected:
    // The lock that protects the data members.
    CRITICAL_SECTION    m_CritSec;
    BOOL                m_fCritSecValid;

    // these five numbers need to be set by the derived class.
    GUID                m_TerminalClassID;
    TERMINAL_DIRECTION  m_TerminalDirection;
    TERMINAL_TYPE       m_TerminalType;
    TERMINAL_STATE      m_TerminalState;
    DWORD               m_dwMediaType;

    WCHAR               m_szName[MAX_PATH + 1];
    MSP_HANDLE          m_htAddress;

    // Pointer to the free threaded marshaler.
    IUnknown *          m_pFTM;

    // stores the filter graph builder (derives from IFilterGraph)
    IGraphBuilder *     m_pGraph;
    IBaseFilter *       m_pFilter;
};


#endif // _H323TERM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323util.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    MSPCall.h

Abstract:

    Definitions for MSP utililty functions. There are all related to 
    active movie filter manipulation.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/

#ifndef __MSPUTIL_H
#define __MSPUTIL_H

const DWORD PAYLOAD_G711U   = 0;
const DWORD PAYLOAD_G723    = 4;
const DWORD PAYLOAD_G711A   = 8;
const DWORD PAYLOAD_H261    = 31;
const DWORD PAYLOAD_H263    = 34;

const TCHAR gszMSPKey[]   =
   L"Software\\Microsoft\\Windows\\CurrentVersion\\H323MSP\\";

const TCHAR gszAEC[]   = L"AEC";

HRESULT
FindPin(
    IN  IBaseFilter *   pInterfaceilter, 
    OUT IPin **         ppIPin, 
    IN  PIN_DIRECTION   direction,
    IN  BOOL            bFree = TRUE
    );

HRESULT
PinSupportsMediaType(
    IN IPin *           pIPin,
    IN const GUID &     MediaType
    );

HRESULT
AddFilter(
    IN  IGraphBuilder *     pIGraph,
    IN  const CLSID &       Clsid,
    IN  LPCWSTR             pwstrName,
    OUT IBaseFilter **      ppIBaseFilter
    );

HRESULT
SetQOSOption(
    IN IBaseFilter *    pIBaseFilter,
    IN DWORD            dwPayloadType,
    IN DWORD            dwMaxBandwidth,
    IN BOOL             bReceive,
    IN BOOL             bCIF = FALSE
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pInterfaceilter1, 
    IN IBaseFilter *    pInterfaceilter2,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IPin *           pIPinOutput, 
    IN IBaseFilter *    pInterfaceilter,
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
ConnectFilters(
    IN IGraphBuilder *  pIGraph,
    IN IBaseFilter *    pInterfaceilter,
    IN IPin *           pIPinInput, 
    IN BOOL             fDirect = TRUE,
    IN AM_MEDIA_TYPE *  pmt = NULL
    );

HRESULT
EnableRTCPEvents(
    IN  IBaseFilter *pIBaseFilter,
    IN  BOOL        fDirectRTP
    );

void WINAPI H323DeleteMediaType(AM_MEDIA_TYPE *pmt);


BOOL 
GetRegValue(
    IN  LPCWSTR szName, 
    OUT DWORD   *pdwValue
    );

HRESULT SetAudioFormat(
    IN  IUnknown*   pIUnknown,
    IN  WORD        wBitPerSample,
    IN  DWORD       dwSampleRate
    );

HRESULT SetAudioBufferSize(
    IN  IUnknown*   pIUnknown,
    IN  DWORD       dwNumBuffers,
    IN  DWORD       dwBufferSize
    );

HRESULT GetFormatHelper(
    IN  IPin *pPin,
    OUT AM_MEDIA_TYPE **ppMediaType
    );

HRESULT SetFormatHelper(
    IN  IPin *pPin,
    IN AM_MEDIA_TYPE *pMediaType
    );

HRESULT GetNumberOfCapabilitiesHelper(
    IN  IPin *pPin,
    OUT DWORD *pdwCount
    );

HRESULT GetStreamCapsHelper(
    IN  IPin *pPin,
    IN DWORD dwIndex, 
    OUT AM_MEDIA_TYPE **ppMediaType, 
    OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
    OUT BOOL *pfEnabled
    );

template <class TInterface, class TEnum, class Flag>
HRESULT GetRangeHelper(
    IN  TInterface * pInterface,
    IN  TEnum Property, 
    OUT long *plMin, 
    OUT long *plMax, 
    OUT long *plSteppingDelta, 
    OUT long *plDefault, 
    OUT Flag *plFlags
    )
{
    ENTER_FUNCTION("GetRangeHelper");

    if (IsBadWritePtr(plMin, sizeof(long)) || 
        IsBadWritePtr(plMax, sizeof(long)) ||
        IsBadWritePtr(plSteppingDelta, sizeof(long)) ||
        IsBadWritePtr(plDefault, sizeof(long)) ||
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = pInterface->GetRange(
            Property,
            plMin, 
            plMax, 
            plSteppingDelta, 
            plDefault, 
            plFlags
            );

    return hr;
}

template <class T>
HRESULT CreateCComObjectInstance (
    CComObject<T> **ppObject
    )
/*++

Create a new CComObject instance. Use try/except to catch exception.

--*/
{
    HRESULT hr;

    __try
    {
        hr = CComObject<T>::CreateInstance(ppObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        *ppObject = NULL;
        return E_OUTOFMEMORY;
    }

    return hr;
}

template <class TInterface, class TEnum, class Flag>
HRESULT GetHelper(
    IN  TInterface * pInterface,
    IN  TEnum Property, 
    OUT long *plValue, 
    OUT Flag *plFlags
    )
{
    ENTER_FUNCTION("GetHelper");

    if (IsBadWritePtr(plValue, sizeof(long)) || 
        IsBadWritePtr(plFlags, sizeof(long)))
    {
        LOG((MSP_ERROR, "%s, bad pointer", __fxName));
        return E_POINTER;
    }

    HRESULT hr = pInterface->Get(
        Property,
        plValue, 
        plFlags
        );

    return hr;
}

inline DWORD FindSampleRate(AM_MEDIA_TYPE *pMediaType)
{
    _ASSERT(!IsBadReadPtr(pMediaType, sizeof(AM_MEDIA_TYPE)));

    if (pMediaType->majortype == MEDIATYPE_Audio &&
            pMediaType->formattype == FORMAT_WaveFormatEx &&
            pMediaType->pbFormat != NULL &&
            pMediaType->cbFormat != 0)
    {
        WAVEFORMATEX *pWaveFormatEx = (WAVEFORMATEX *) pMediaType->pbFormat;
        return pWaveFormatEx->nSamplesPerSec;
    }

    return 90000;      // default media clock rate, including video.
}

HRESULT ConfigureRTPFormats(
    IN  IBaseFilter *   pIRTPFilter,
    IN  IStreamConfig *   pIStreamConfig
    );

HRESULT
H323DetermineLinkSpeed(
    IN  DWORD  dwHostAddr,  
    OUT DWORD *dwInterfaceLinkSpeed
    );

class ATL_NO_VTABLE CMSPStreamClock : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public IReferenceClock
{
private:
    LONGLONG         m_lPerfFrequency;
    union {
        LONGLONG         m_lRtpRefTime;
        DWORD            m_dwRtpRefTime;
    };

public:

BEGIN_COM_MAP(CMSPStreamClock)
    COM_INTERFACE_ENTRY(IReferenceClock)
END_COM_MAP()

    void InitReferenceTime(void);

    HRESULT GetTimeOfDay(OUT REFERENCE_TIME *pTime);

    CMSPStreamClock()
    {
        InitReferenceTime();
    }

    STDMETHOD (GetTime) (
            OUT REFERENCE_TIME *pTime
        )
    {
        return(GetTimeOfDay(pTime));
    }

    STDMETHOD (AdviseTime) (
        IN REFERENCE_TIME baseTime,        // base reference time
        IN REFERENCE_TIME streamTime,      // stream offset time
        IN HEVENT hEvent,                  // advise via this event
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdviseTime is called");
        return E_NOTIMPL;
    }

    STDMETHOD (AdvisePeriodic) (
        IN REFERENCE_TIME StartTime,       // starting at this time
        IN REFERENCE_TIME PeriodTime,      // time between notifications
        IN HSEMAPHORE hSemaphore,          // advise via a semaphore
        OUT DWORD_PTR *pdwAdviseCookie          // where your cookie goes
        )
    {
        _ASSERT(!"AdvisePeriodic is called");
        return E_NOTIMPL;
    }

    STDMETHOD (Unadvise) (
        IN DWORD_PTR dwAdviseCookie
        )
    {
        _ASSERT(!"Unadvise is called");
        return E_NOTIMPL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h4503pp.h ===
#ifndef _H4503PP_Module_H_
#define _H4503PP_Module_H_

#include "msper.h"
#include "h225asn.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct TransportAddress_ipSourceRoute_route * PTransportAddress_ipSourceRoute_route;

typedef struct ExtensionSeq * PExtensionSeq;

typedef struct CpickupNotifyArg_extensionArg * PCpickupNotifyArg_extensionArg;

typedef struct CpNotifyArg_extensionArg * PCpNotifyArg_extensionArg;

typedef struct PickExeRes_extensionRes * PPickExeRes_extensionRes;

typedef struct PickExeArg_extensionArg * PPickExeArg_extensionArg;

typedef struct PickupRes_extensionRes * PPickupRes_extensionRes;

typedef struct PickupArg_extensionArg * PPickupArg_extensionArg;

typedef struct PickrequRes_extensionRes * PPickrequRes_extensionRes;

typedef struct PickrequArg_extensionArg * PPickrequArg_extensionArg;

typedef struct GroupIndicationOffRes_extensionRes * PGroupIndicationOffRes_extensionRes;

typedef struct GroupIndicationOffArg_extensionArg * PGroupIndicationOffArg_extensionArg;

typedef struct GroupIndicationOnRes_extensionRes * PGroupIndicationOnRes_extensionRes;

typedef struct GroupIndicationOnArg_extensionArg * PGroupIndicationOnArg_extensionArg;

typedef struct CpSetupRes_extensionRes * PCpSetupRes_extensionRes;

typedef struct CpSetupArg_extensionArg * PCpSetupArg_extensionArg;

typedef struct CpRequestRes_extensionRes * PCpRequestRes_extensionRes;

typedef struct CpRequestArg_extensionArg * PCpRequestArg_extensionArg;

typedef struct ServiceApdus_rosApdus * PServiceApdus_rosApdus;

typedef struct EndpointAddress_destinationAddress * PEndpointAddress_destinationAddress;
/*
typedef struct TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} TransportAddress_ipSourceRoute_route_Seq;
*/
typedef ASN1int32_t GeneralProblem;
#define GeneralProblem_unrecognizedComponent 0
#define GeneralProblem_mistypedComponent 1
#define GeneralProblem_badlyStructuredComponent 2

typedef ASN1int32_t InvokeProblem;
#define InvokeProblem_duplicateInvocation 0
#define InvokeProblem_unrecognizedOperation 1
#define InvokeProblem_mistypedArgument 2
#define InvokeProblem_resourceLimitation 3
#define InvokeProblem_releaseInProgress 4
#define InvokeProblem_unrecognizedLinkedId 5
#define InvokeProblem_linkedResponseUnexpected 6
#define InvokeProblem_unexpectedLinkedOperation 7

typedef ASN1int32_t ReturnResultProblem;
#define ReturnResultProblem_unrecognizedInvocation 0
#define ReturnResultProblem_resultResponseUnexpected 1
#define ReturnResultProblem_mistypedResult 2

typedef ASN1int32_t ReturnErrorProblem;
#define ReturnErrorProblem_unrecognizedInvocation 0
#define ReturnErrorProblem_errorResponseUnexpected 1
#define ReturnErrorProblem_unrecognizedError 2
#define ReturnErrorProblem_unexpectedError 3
#define ReturnErrorProblem_mistypedParameter 4

typedef ASN1int32_t RejectProblem;
#define RejectProblem_general_unrecognizedPDU 0
#define RejectProblem_general_mistypedPDU 1
#define RejectProblem_general_badlyStructuredPDU 2
#define RejectProblem_invoke_duplicateInvocation 10
#define RejectProblem_invoke_unrecognizedOperation 11
#define RejectProblem_invoke_mistypedArgument 12
#define RejectProblem_invoke_resourceLimitation 13
#define RejectProblem_invoke_releaseInProgress 14
#define RejectProblem_invoke_unrecognizedLinkedId 15
#define RejectProblem_invoke_linkedResponseUnexpected 16
#define RejectProblem_invoke_unexpectedLinkedOperation 17
#define RejectProblem_returnResult_unrecognizedInvocation 20
#define RejectProblem_returnResult_resultResponseUnexpected 21
#define RejectProblem_returnResult_mistypedResult 22
#define RejectProblem_returnError_unrecognizedInvocation 30
#define RejectProblem_returnError_errorResponseUnexpected 31
#define RejectProblem_returnError_unrecognizedError 32
#define RejectProblem_returnError_unexpectedError 33
#define RejectProblem_returnError_mistypedParameter 34

typedef ASN1int32_t InvokeId;

typedef ASN1bool_t PresentationAllowedIndicator;

typedef enum DiversionReason {
    unknown = 0,
    DiversionReason_cfu = 1,
    DiversionReason_cfb = 2,
    DiversionReason_cfnr = 3,
} DiversionReason;

typedef enum Procedure {
    Procedure_cfu = 0,
    Procedure_cfb = 1,
    Procedure_cfnr = 2,
} Procedure;

typedef enum SubscriptionOption {
    noNotification = 0,
    notificationWithoutDivertedToNr = 1,
    notificationWithDivertedToNr = 2,
} SubscriptionOption;

typedef enum BasicService {
    allServices = 0,
    speech = 1,
    unrestrictedDigitalInformation = 2,
    audio31KHz = 3,
    telephony = 32,
    teletex = 33,
    telefaxGroup4Class1 = 34,
    videotexSyntaxBased = 35,
    videotelephony = 36,
} BasicService;

typedef enum EndDesignation {
    primaryEnd = 0,
    secondaryEnd = 1,
} EndDesignation;

typedef enum CallStatus {
    answered = 0,
    alerting = 1,
} CallStatus;

typedef ASN1char_t CallIdentity[5];

typedef ASN1uint16_t ParkedToPosition;

typedef enum ParkCondition {
    unspecified = 0,
    parkedToUserIdle = 1,
    parkedToUserBusy = 2,
    parkedToGroup = 3,
} ParkCondition;

typedef enum H4505CallType {
    parkedCall = 0,
    alertingCall = 1,
} H4505CallType;

typedef struct NSAPSubaddress {
    ASN1uint32_t length;
    ASN1octet_t value[20];
} NSAPSubaddress;

typedef struct SubaddressInformation {
    ASN1uint32_t length;
    ASN1octet_t value[20];
} SubaddressInformation;

typedef ASN1octetstring_t H225InformationElement;

typedef ASN1uint32_t Priority;

typedef ASN1char_t NumberDigits[129];
/*
typedef struct GloballyUniqueID {
    ASN1uint32_t length;
    ASN1octet_t value[16];
} GloballyUniqueID;

typedef struct TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
#   define strict_chosen 1
#   define loose_chosen 2
} TransportAddress_ipSourceRoute_routing;

typedef struct TransportAddress_ipSourceRoute_route {
    PTransportAddress_ipSourceRoute_route next;
    TransportAddress_ipSourceRoute_route_Seq value;
} TransportAddress_ipSourceRoute_route_Element;

typedef struct TransportAddress_ip6Address {
    struct TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ip6Address;

typedef struct TransportAddress_ipxAddress {
    struct TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
} TransportAddress_ipxAddress;

typedef struct TransportAddress_ipSourceRoute {
    struct TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PTransportAddress_ipSourceRoute_route route;
    TransportAddress_ipSourceRoute_routing routing;
} TransportAddress_ipSourceRoute;

typedef struct TransportAddress_ipAddress {
    struct TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
} TransportAddress_ipAddress;
*/
typedef struct Reject_problem {
    ASN1choice_t choice;
    union {
#	define general_chosen 1
	GeneralProblem general;
#	define Reject_problem_invoke_chosen 2
	InvokeProblem invoke;
#	define Reject_problem_returnResult_chosen 3
	ReturnResultProblem returnResult;
#	define Reject_problem_returnError_chosen 4
	ReturnErrorProblem returnError;
    } u;
} Reject_problem;

typedef struct EntityType {
    ASN1choice_t choice;
#   define endpoint_chosen 1
#   define anyEntity_chosen 2
} EntityType;

typedef struct InterpretationApdu {
    ASN1choice_t choice;
#   define discardAnyUnrecognizedInvokePdu_chosen 1
#   define clearCallIfAnyInvokePduNotRecognized_chosen 2
#   define rejectAnyUnrecognizedInvokePdu_chosen 3
} InterpretationApdu;

typedef struct ServiceApdus {
    ASN1choice_t choice;
    union {
#	define rosApdus_chosen 1
	PServiceApdus_rosApdus rosApdus;
    } u;
} ServiceApdus;

typedef struct Reject {
    InvokeId invokeId;
    Reject_problem problem;
} Reject;

typedef struct EXTENSION {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define argumentType_present 0x80
    ASN1uint16_t argumentType;
    ASN1objectidentifier_t extensionID;
} EXTENSION;

typedef struct GroupIndicationOnRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GroupIndicationOnRes_extensionRes_present 0x80
    PGroupIndicationOnRes_extensionRes extensionRes;
} GroupIndicationOnRes;
#define GroupIndicationOnRes_PDU 0
#define SIZE_H4503PP_Module_PDU_0 sizeof(GroupIndicationOnRes)

typedef struct GroupIndicationOffRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define GroupIndicationOffRes_extensionRes_present 0x80
    PGroupIndicationOffRes_extensionRes extensionRes;
} GroupIndicationOffRes;
#define GroupIndicationOffRes_PDU 1
#define SIZE_H4503PP_Module_PDU_1 sizeof(GroupIndicationOffRes)

typedef struct PickupRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define PickupRes_extensionRes_present 0x80
    PPickupRes_extensionRes extensionRes;
} PickupRes;
#define PickupRes_PDU 2
#define SIZE_H4503PP_Module_PDU_2 sizeof(PickupRes)

typedef struct PickExeRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define PickExeRes_extensionRes_present 0x80
    PPickExeRes_extensionRes extensionRes;
} PickExeRes;
#define PickExeRes_PDU 3
#define SIZE_H4503PP_Module_PDU_3 sizeof(PickExeRes)

typedef struct UserSpecifiedSubaddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubaddressInformation subaddressInformation;
#   define oddCountIndicator_present 0x80
    ASN1bool_t oddCountIndicator;
} UserSpecifiedSubaddress;

typedef struct CODE {
    ASN1choice_t choice;
    union {
#	define local_chosen 1
	ASN1int32_t local;
#	define global_chosen 2
	ASN1objectidentifier_t global;
    } u;
} CODE;
/*
typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct H225NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} H225NonStandardIdentifier;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
#   define PublicTypeOfNumber_unknown_chosen 1
#   define internationalNumber_chosen 2
#   define nationalNumber_chosen 3
#   define networkSpecificNumber_chosen 4
#   define subscriberNumber_chosen 5
#   define PublicTypeOfNumber_abbreviatedNumber_chosen 6
} PublicTypeOfNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
#   define PrivateTypeOfNumber_unknown_chosen 1
#   define level2RegionalNumber_chosen 2
#   define level1RegionalNumber_chosen 3
#   define pISNSpecificNumber_chosen 4
#   define localNumber_chosen 5
#   define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
} PrivateTypeOfNumber;

typedef struct CallIdentifier {
    GloballyUniqueID guid;
} CallIdentifier;
*/
typedef struct ReturnResult_result {
    CODE opcode;
    ASN1octetstring_t result;
} ReturnResult_result;

typedef struct Invoke {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
#   define linkedId_present 0x80
    InvokeId linkedId;
    CODE opcode;
#   define argument_present 0x40
    ASN1octetstring_t argument;
} Invoke;

typedef struct ReturnResult {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
#   define result_present 0x80
    ReturnResult_result result;
} ReturnResult;

typedef struct ReturnError {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    InvokeId invokeId;
    CODE errcode;
#   define parameter_present 0x80
    ASN1octetstring_t parameter;
} ReturnError;

typedef struct ExtensionSeq {
    PExtensionSeq next;
    EXTENSION value;
} ExtensionSeq_Element;

typedef struct PickrequRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
#   define PickrequRes_extensionRes_present 0x80
    PPickrequRes_extensionRes extensionRes;
} PickrequRes;
#define PickrequRes_PDU 4
#define SIZE_H4503PP_Module_PDU_4 sizeof(PickrequRes)

typedef struct PartySubaddress {
    ASN1choice_t choice;
    union {
#	define userSpecifiedSubaddress_chosen 1
	UserSpecifiedSubaddress userSpecifiedSubaddress;
#	define nsapSubaddress_chosen 2
	NSAPSubaddress nsapSubaddress;
    } u;
} PartySubaddress;
/*
typedef struct H225NonStandardParameter {
    H225NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} H225NonStandardParameter;

typedef struct PublicPartyNumber {
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
} PublicPartyNumber;

typedef struct PrivatePartyNumber {
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
} PrivatePartyNumber;

typedef struct TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardAddress_chosen 7
	H225NonStandardParameter nonStandardAddress;
    } u;
} TransportAddress;
*/
typedef struct CTActiveArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTActiveArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTActiveArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTActiveArg_argumentExtension;

typedef struct CTCompleteArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTCompleteArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTCompleteArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTCompleteArg_argumentExtension;

typedef struct SubaddressTransferArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define SubaddressTransferArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define SubaddressTransferArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} SubaddressTransferArg_argumentExtension;

typedef struct CTUpdateArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTUpdateArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTUpdateArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTUpdateArg_argumentExtension;

typedef struct CTIdentifyRes_resultExtension {
    ASN1choice_t choice;
    union {
#	define CTIdentifyRes_resultExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTIdentifyRes_resultExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTIdentifyRes_resultExtension;

typedef struct CTSetupArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTSetupArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTSetupArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTSetupArg_argumentExtension;

typedef struct CTInitiateArg_argumentExtension {
    ASN1choice_t choice;
    union {
#	define CTInitiateArg_argumentExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CTInitiateArg_argumentExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CTInitiateArg_argumentExtension;

typedef struct IntResult_extension {
    ASN1choice_t choice;
    union {
#	define IntResult_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define IntResult_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} IntResult_extension;

typedef struct DivertingLegInformation4Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation4Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation4Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation4Argument_extension;

typedef struct DivertingLegInformation3Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation3Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation3Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation3Argument_extension;

typedef struct DivertingLegInformation2Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation2Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation2Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation2Argument_extension;

typedef struct DivertingLegInformation1Argument_extension {
    ASN1choice_t choice;
    union {
#	define DivertingLegInformation1Argument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DivertingLegInformation1Argument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DivertingLegInformation1Argument_extension;

typedef struct CallReroutingArgument_extension {
    ASN1choice_t choice;
    union {
#	define CallReroutingArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CallReroutingArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CallReroutingArgument_extension;

typedef struct CheckRestrictionArgument_extension {
    ASN1choice_t choice;
    union {
#	define CheckRestrictionArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define CheckRestrictionArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} CheckRestrictionArgument_extension;

typedef struct InterrogateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define InterrogateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define InterrogateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} InterrogateDiversionQArgument_extension;

typedef struct DeactivateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define DeactivateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DeactivateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DeactivateDiversionQArgument_extension;

typedef struct ActivateDiversionQArgument_extension {
    ASN1choice_t choice;
    union {
#	define ActivateDiversionQArgument_extension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define ActivateDiversionQArgument_extension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} ActivateDiversionQArgument_extension;

typedef struct H4503ROS {
    ASN1choice_t choice;
    union {
#	define H4503ROS_invoke_chosen 1
	Invoke invoke;
#	define H4503ROS_returnResult_chosen 2
	ReturnResult returnResult;
#	define H4503ROS_returnError_chosen 3
	ReturnError returnError;
#	define reject_chosen 4
	Reject reject;
    } u;
} H4503ROS;

typedef struct DummyArg {
    ASN1choice_t choice;
    union {
#	define DummyArg_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DummyArg_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DummyArg;
#define DummyArg_PDU 5
#define SIZE_H4503PP_Module_PDU_5 sizeof(DummyArg)

typedef struct DummyRes {
    ASN1choice_t choice;
    union {
#	define DummyRes_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define DummyRes_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} DummyRes;
#define DummyRes_PDU 6
#define SIZE_H4503PP_Module_PDU_6 sizeof(DummyRes)

typedef struct SubaddressTransferArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PartySubaddress redirectionSubaddress;
#   define SubaddressTransferArg_argumentExtension_present 0x80
    SubaddressTransferArg_argumentExtension argumentExtension;
} SubaddressTransferArg;
#define SubaddressTransferArg_PDU 7
#define SIZE_H4503PP_Module_PDU_7 sizeof(SubaddressTransferArg)

typedef struct MixedExtension {
    ASN1choice_t choice;
    union {
#	define MixedExtension_extensionSeq_chosen 1
	PExtensionSeq extensionSeq;
#	define MixedExtension_nonStandardData_chosen 2
	H225NonStandardParameter nonStandardData;
    } u;
} MixedExtension;
/*
typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
    } u;
} PartyNumber;
*/
typedef struct CpickupNotifyArg_extensionArg {
    PCpickupNotifyArg_extensionArg next;
    MixedExtension value;
} CpickupNotifyArg_extensionArg_Element;

typedef struct CpNotifyArg_extensionArg {
    PCpNotifyArg_extensionArg next;
    MixedExtension value;
} CpNotifyArg_extensionArg_Element;

typedef struct PickExeRes_extensionRes {
    PPickExeRes_extensionRes next;
    MixedExtension value;
} PickExeRes_extensionRes_Element;

typedef struct PickExeArg_extensionArg {
    PPickExeArg_extensionArg next;
    MixedExtension value;
} PickExeArg_extensionArg_Element;

typedef struct PickupRes_extensionRes {
    PPickupRes_extensionRes next;
    MixedExtension value;
} PickupRes_extensionRes_Element;

typedef struct PickupArg_extensionArg {
    PPickupArg_extensionArg next;
    MixedExtension value;
} PickupArg_extensionArg_Element;

typedef struct PickrequRes_extensionRes {
    PPickrequRes_extensionRes next;
    MixedExtension value;
} PickrequRes_extensionRes_Element;

typedef struct PickrequArg_extensionArg {
    PPickrequArg_extensionArg next;
    MixedExtension value;
} PickrequArg_extensionArg_Element;

typedef struct GroupIndicationOffRes_extensionRes {
    PGroupIndicationOffRes_extensionRes next;
    MixedExtension value;
} GroupIndicationOffRes_extensionRes_Element;

typedef struct GroupIndicationOffArg_extensionArg {
    PGroupIndicationOffArg_extensionArg next;
    MixedExtension value;
} GroupIndicationOffArg_extensionArg_Element;

typedef struct GroupIndicationOnRes_extensionRes {
    PGroupIndicationOnRes_extensionRes next;
    MixedExtension value;
} GroupIndicationOnRes_extensionRes_Element;

typedef struct GroupIndicationOnArg_extensionArg {
    PGroupIndicationOnArg_extensionArg next;
    MixedExtension value;
} GroupIndicationOnArg_extensionArg_Element;

typedef struct CpSetupRes_extensionRes {
    PCpSetupRes_extensionRes next;
    MixedExtension value;
} CpSetupRes_extensionRes_Element;

typedef struct CpSetupArg_extensionArg {
    PCpSetupArg_extensionArg next;
    MixedExtension value;
} CpSetupArg_extensionArg_Element;

typedef struct CpRequestRes_extensionRes {
    PCpRequestRes_extensionRes next;
    MixedExtension value;
} CpRequestRes_extensionRes_Element;

typedef struct CpRequestArg_extensionArg {
    PCpRequestArg_extensionArg next;
    MixedExtension value;
} CpRequestArg_extensionArg_Element;

typedef struct ServiceApdus_rosApdus {
    PServiceApdus_rosApdus next;
    H4503ROS value;
} ServiceApdus_rosApdus_Element;
/*
typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164_chosen 1
	ASN1char_t e164[129];
#	define h323_ID_chosen 2
	ASN1char16string_t h323_ID;
#	define url_ID_chosen 3
	ASN1char_t url_ID[513];
#	define transportID_chosen 4
	TransportAddress transportID;
#	define email_ID_chosen 5
	ASN1char_t email_ID[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
    } u;
} AliasAddress;
*/
typedef struct EndpointAddress_destinationAddress {
    PEndpointAddress_destinationAddress next;
    AliasAddress value;
} EndpointAddress_destinationAddress_Element;

typedef AliasAddress AddressInformation;

typedef struct EndpointAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PEndpointAddress_destinationAddress destinationAddress;
#   define remoteExtensionAddress_present 0x80
    AliasAddress remoteExtensionAddress;
} EndpointAddress;

typedef struct NetworkFacilityExtension {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityType sourceEntity;
#   define sourceEntityAddress_present 0x80
    AddressInformation sourceEntityAddress;
    EntityType destinationEntity;
#   define destinationEntityAddress_present 0x40
    AddressInformation destinationEntityAddress;
} NetworkFacilityExtension;

typedef struct ActivateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
    BasicService basicService;
    EndpointAddress divertedToAddress;
    EndpointAddress servedUserNr;
    EndpointAddress activatingUserNr;
#   define ActivateDiversionQArgument_extension_present 0x80
    ActivateDiversionQArgument_extension extension;
} ActivateDiversionQArgument;
#define ActivateDiversionQArgument_PDU 8
#define SIZE_H4503PP_Module_PDU_8 sizeof(ActivateDiversionQArgument)

typedef struct DeactivateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
    BasicService basicService;
    EndpointAddress servedUserNr;
    EndpointAddress deactivatingUserNr;
#   define DeactivateDiversionQArgument_extension_present 0x80
    DeactivateDiversionQArgument_extension extension;
} DeactivateDiversionQArgument;
#define DeactivateDiversionQArgument_PDU 9
#define SIZE_H4503PP_Module_PDU_9 sizeof(DeactivateDiversionQArgument)

typedef struct InterrogateDiversionQArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Procedure procedure;
#   define basicService_present 0x80
    BasicService basicService;
    EndpointAddress servedUserNr;
    EndpointAddress interrogatingUserNr;
#   define InterrogateDiversionQArgument_extension_present 0x40
    InterrogateDiversionQArgument_extension extension;
} InterrogateDiversionQArgument;
#define InterrogateDiversionQArgument_PDU 10
#define SIZE_H4503PP_Module_PDU_10 sizeof(InterrogateDiversionQArgument)

typedef struct CheckRestrictionArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress servedUserNr;
    BasicService basicService;
    EndpointAddress divertedToNr;
#   define CheckRestrictionArgument_extension_present 0x80
    CheckRestrictionArgument_extension extension;
} CheckRestrictionArgument;
#define CheckRestrictionArgument_PDU 11
#define SIZE_H4503PP_Module_PDU_11 sizeof(CheckRestrictionArgument)

typedef struct CallReroutingArgument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason reroutingReason;
#   define originalReroutingReason_present 0x80
    DiversionReason originalReroutingReason;
    EndpointAddress calledAddress;
    ASN1uint16_t diversionCounter;
    H225InformationElement h225InfoElement;
    EndpointAddress lastReroutingNr;
    SubscriptionOption subscriptionOption;
#   define callingPartySubaddress_present 0x40
    PartySubaddress callingPartySubaddress;
    EndpointAddress callingNumber;
#   define CallReroutingArgument_callingInfo_present 0x20
    ASN1char16string_t callingInfo;
#   define CallReroutingArgument_originalCalledNr_present 0x10
    EndpointAddress originalCalledNr;
#   define CallReroutingArgument_redirectingInfo_present 0x8
    ASN1char16string_t redirectingInfo;
#   define CallReroutingArgument_originalCalledInfo_present 0x4
    ASN1char16string_t originalCalledInfo;
#   define CallReroutingArgument_extension_present 0x2
    CallReroutingArgument_extension extension;
} CallReroutingArgument;
#define CallReroutingArgument_PDU 12
#define SIZE_H4503PP_Module_PDU_12 sizeof(CallReroutingArgument)

typedef struct DivertingLegInformation1Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason diversionReason;
    SubscriptionOption subscriptionOption;
    EndpointAddress nominatedNr;
#   define DivertingLegInformation1Argument_nominatedInfo_present 0x80
    ASN1char16string_t nominatedInfo;
#   define redirectingNr_present 0x40
    EndpointAddress redirectingNr;
#   define DivertingLegInformation1Argument_redirectingInfo_present 0x20
    ASN1char16string_t redirectingInfo;
#   define DivertingLegInformation1Argument_extension_present 0x10
    DivertingLegInformation1Argument_extension extension;
} DivertingLegInformation1Argument;
#define DivertingLegInformation1Argument_PDU 13
#define SIZE_H4503PP_Module_PDU_13 sizeof(DivertingLegInformation1Argument)

typedef struct DivertingLegInformation2Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1uint16_t diversionCounter;
    DiversionReason diversionReason;
#   define originalDiversionReason_present 0x80
    DiversionReason originalDiversionReason;
#   define divertingNr_present 0x40
    EndpointAddress divertingNr;
#   define DivertingLegInformation2Argument_originalCalledNr_present 0x20
    EndpointAddress originalCalledNr;
#   define DivertingLegInformation2Argument_redirectingInfo_present 0x10
    ASN1char16string_t redirectingInfo;
#   define DivertingLegInformation2Argument_originalCalledInfo_present 0x8
    ASN1char16string_t originalCalledInfo;
#   define DivertingLegInformation2Argument_extension_present 0x4
    DivertingLegInformation2Argument_extension extension;
} DivertingLegInformation2Argument;
#define DivertingLegInformation2Argument_PDU 14
#define SIZE_H4503PP_Module_PDU_14 sizeof(DivertingLegInformation2Argument)

typedef struct DivertingLegInformation3Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PresentationAllowedIndicator presentationAllowedIndicator;
#   define redirectionNr_present 0x80
    EndpointAddress redirectionNr;
#   define DivertingLegInformation3Argument_redirectionInfo_present 0x40
    ASN1char16string_t redirectionInfo;
#   define DivertingLegInformation3Argument_extension_present 0x20
    DivertingLegInformation3Argument_extension extension;
} DivertingLegInformation3Argument;
#define DivertingLegInformation3Argument_PDU 15
#define SIZE_H4503PP_Module_PDU_15 sizeof(DivertingLegInformation3Argument)

typedef struct DivertingLegInformation4Argument {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DiversionReason diversionReason;
    SubscriptionOption subscriptionOption;
    EndpointAddress callingNr;
#   define DivertingLegInformation4Argument_callingInfo_present 0x80
    ASN1char16string_t callingInfo;
    EndpointAddress nominatedNr;
#   define DivertingLegInformation4Argument_nominatedInfo_present 0x40
    ASN1char16string_t nominatedInfo;
#   define DivertingLegInformation4Argument_extension_present 0x20
    DivertingLegInformation4Argument_extension extension;
} DivertingLegInformation4Argument;
#define DivertingLegInformation4Argument_PDU 16
#define SIZE_H4503PP_Module_PDU_16 sizeof(DivertingLegInformation4Argument)

typedef struct IntResult {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress servedUserNr;
    BasicService basicService;
    Procedure procedure;
    EndpointAddress divertedToAddress;
#   define remoteEnabled_present 0x80
    ASN1bool_t remoteEnabled;
#   define IntResult_extension_present 0x40
    IntResult_extension extension;
} IntResult;

typedef struct CTInitiateArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
    EndpointAddress reroutingNumber;
#   define CTInitiateArg_argumentExtension_present 0x80
    CTInitiateArg_argumentExtension argumentExtension;
} CTInitiateArg;
#define CTInitiateArg_PDU 17
#define SIZE_H4503PP_Module_PDU_17 sizeof(CTInitiateArg)

typedef struct CTSetupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
#   define transferringNumber_present 0x80
    EndpointAddress transferringNumber;
#   define CTSetupArg_argumentExtension_present 0x40
    CTSetupArg_argumentExtension argumentExtension;
} CTSetupArg;
#define CTSetupArg_PDU 18
#define SIZE_H4503PP_Module_PDU_18 sizeof(CTSetupArg)

typedef struct CTIdentifyRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentity callIdentity;
    EndpointAddress reroutingNumber;
#   define resultExtension_present 0x80
    CTIdentifyRes_resultExtension resultExtension;
} CTIdentifyRes;
#define CTIdentifyRes_PDU 19
#define SIZE_H4503PP_Module_PDU_19 sizeof(CTIdentifyRes)

typedef struct CTUpdateArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress redirectionNumber;
#   define CTUpdateArg_redirectionInfo_present 0x80
    ASN1char16string_t redirectionInfo;
#   define CTUpdateArg_basicCallInfoElements_present 0x40
    H225InformationElement basicCallInfoElements;
#   define CTUpdateArg_argumentExtension_present 0x20
    CTUpdateArg_argumentExtension argumentExtension;
} CTUpdateArg;
#define CTUpdateArg_PDU 20
#define SIZE_H4503PP_Module_PDU_20 sizeof(CTUpdateArg)

typedef struct CTCompleteArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndDesignation endDesignation;
    EndpointAddress redirectionNumber;
#   define CTCompleteArg_basicCallInfoElements_present 0x80
    H225InformationElement basicCallInfoElements;
#   define CTCompleteArg_redirectionInfo_present 0x40
    ASN1char16string_t redirectionInfo;
#   define callStatus_present 0x20
    CallStatus callStatus;
#   define CTCompleteArg_argumentExtension_present 0x10
    CTCompleteArg_argumentExtension argumentExtension;
} CTCompleteArg;
#define CTCompleteArg_PDU 21
#define SIZE_H4503PP_Module_PDU_21 sizeof(CTCompleteArg)

typedef struct CTActiveArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress connectedAddress;
#   define CTActiveArg_basicCallInfoElements_present 0x80
    H225InformationElement basicCallInfoElements;
#   define connectedInfo_present 0x40
    ASN1char16string_t connectedInfo;
#   define CTActiveArg_argumentExtension_present 0x20
    CTActiveArg_argumentExtension argumentExtension;
} CTActiveArg;
#define CTActiveArg_PDU 22
#define SIZE_H4503PP_Module_PDU_22 sizeof(CTActiveArg)

typedef struct CpRequestArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkingNumber;
    EndpointAddress parkedNumber;
    EndpointAddress parkedToNumber;
#   define CpRequestArg_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
#   define CpRequestArg_extensionArg_present 0x40
    PCpRequestArg_extensionArg extensionArg;
} CpRequestArg;
#define CpRequestArg_PDU 23
#define SIZE_H4503PP_Module_PDU_23 sizeof(CpRequestArg)

typedef struct CpRequestRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkedToNumber;
#   define CpRequestRes_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
    ParkCondition parkCondition;
#   define CpRequestRes_extensionRes_present 0x40
    PCpRequestRes_extensionRes extensionRes;
} CpRequestRes;
#define CpRequestRes_PDU 24
#define SIZE_H4503PP_Module_PDU_24 sizeof(CpRequestRes)

typedef struct CpSetupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkingNumber;
    EndpointAddress parkedNumber;
    EndpointAddress parkedToNumber;
#   define CpSetupArg_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
#   define CpSetupArg_extensionArg_present 0x40
    PCpSetupArg_extensionArg extensionArg;
} CpSetupArg;
#define CpSetupArg_PDU 25
#define SIZE_H4503PP_Module_PDU_25 sizeof(CpSetupArg)

typedef struct CpSetupRes {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress parkedToNumber;
#   define CpSetupRes_parkedToPosition_present 0x80
    ParkedToPosition parkedToPosition;
    ParkCondition parkCondition;
#   define CpSetupRes_extensionRes_present 0x40
    PCpSetupRes_extensionRes extensionRes;
} CpSetupRes;
#define CpSetupRes_PDU 26
#define SIZE_H4503PP_Module_PDU_26 sizeof(CpSetupRes)

typedef struct GroupIndicationOnArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress groupMemberUserNr;
    H4505CallType retrieveCallType;
    EndpointAddress partyToRetrieve;
    EndpointAddress retrieveAddress;
#   define GroupIndicationOnArg_parkPosition_present 0x80
    ParkedToPosition parkPosition;
#   define GroupIndicationOnArg_extensionArg_present 0x40
    PGroupIndicationOnArg_extensionArg extensionArg;
} GroupIndicationOnArg;
#define GroupIndicationOnArg_PDU 27
#define SIZE_H4503PP_Module_PDU_27 sizeof(GroupIndicationOnArg)

typedef struct GroupIndicationOffArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress groupMemberUserNr;
#   define GroupIndicationOffArg_extensionArg_present 0x80
    PGroupIndicationOffArg_extensionArg extensionArg;
} GroupIndicationOffArg;
#define GroupIndicationOffArg_PDU 28
#define SIZE_H4503PP_Module_PDU_28 sizeof(GroupIndicationOffArg)

typedef struct PickrequArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EndpointAddress picking_upNumber;
#   define callPickupId_present 0x80
    CallIdentifier callPickupId;
#   define partyToRetrieve_present 0x40
    EndpointAddress partyToRetrieve;
    EndpointAddress retrieveAddress;
#   define PickrequArg_parkPosition_present 0x20
    ParkedToPosition parkPosition;
#   define PickrequArg_extensionArg_present 0x10
    PPickrequArg_extensionArg extensionArg;
} PickrequArg;
#define PickrequArg_PDU 29
#define SIZE_H4503PP_Module_PDU_29 sizeof(PickrequArg)

typedef struct PickupArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress picking_upNumber;
#   define PickupArg_extensionArg_present 0x80
    PPickupArg_extensionArg extensionArg;
} PickupArg;
#define PickupArg_PDU 30
#define SIZE_H4503PP_Module_PDU_30 sizeof(PickupArg)

typedef struct PickExeArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CallIdentifier callPickupId;
    EndpointAddress picking_upNumber;
    EndpointAddress partyToRetrieve;
#   define PickExeArg_extensionArg_present 0x80
    PPickExeArg_extensionArg extensionArg;
} PickExeArg;
#define PickExeArg_PDU 31
#define SIZE_H4503PP_Module_PDU_31 sizeof(PickExeArg)

typedef struct CpNotifyArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define parkingNumber_present 0x80
    EndpointAddress parkingNumber;
#   define CpNotifyArg_extensionArg_present 0x40
    PCpNotifyArg_extensionArg extensionArg;
} CpNotifyArg;
#define CpNotifyArg_PDU 32
#define SIZE_H4503PP_Module_PDU_32 sizeof(CpNotifyArg)

typedef struct CpickupNotifyArg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define picking_upNumber_present 0x80
    EndpointAddress picking_upNumber;
#   define CpickupNotifyArg_extensionArg_present 0x40
    PCpickupNotifyArg_extensionArg extensionArg;
} CpickupNotifyArg;
#define CpickupNotifyArg_PDU 33
#define SIZE_H4503PP_Module_PDU_33 sizeof(CpickupNotifyArg)

typedef struct H4501SupplementaryService {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define networkFacilityExtension_present 0x80
    NetworkFacilityExtension networkFacilityExtension;
#   define interpretationApdu_present 0x40
    InterpretationApdu interpretationApdu;
    ServiceApdus serviceApdu;
} H4501SupplementaryService;
#define H4501SupplementaryService_PDU 34
#define SIZE_H4503PP_Module_PDU_34 sizeof(H4501SupplementaryService)

typedef struct IntResultList {
    ASN1uint32_t count;
    IntResult value[29];
} IntResultList;
#define IntResultList_PDU 35
#define SIZE_H4503PP_Module_PDU_35 sizeof(IntResultList)

extern CallStatus CTCompleteArg_callStatus_default;
extern ASN1bool_t IntResult_remoteEnabled_default;
extern BasicService InterrogateDiversionQArgument_basicService_default;

extern ASN1module_t H4503PP_Module;
extern void ASN1CALL H4503PP_Module_Startup(void);
extern void ASN1CALL H4503PP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PTransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_TransportAddress_ipSourceRoute_route_ElmFn(PTransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_ExtensionSeq_ElmFn(ASN1encoding_t enc, PExtensionSeq val);
    extern int ASN1CALL ASN1Dec_ExtensionSeq_ElmFn(ASN1decoding_t dec, PExtensionSeq val);
	extern void ASN1CALL ASN1Free_ExtensionSeq_ElmFn(PExtensionSeq val);
    extern int ASN1CALL ASN1Enc_CpickupNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpickupNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpickupNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpickupNotifyArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpickupNotifyArg_extensionArg_ElmFn(PCpickupNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpNotifyArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpNotifyArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpNotifyArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpNotifyArg_extensionArg_ElmFn(PCpNotifyArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickExeRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickExeRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickExeRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickExeRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickExeRes_extensionRes_ElmFn(PPickExeRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickExeArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickExeArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickExeArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickExeArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickExeArg_extensionArg_ElmFn(PPickExeArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickupRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickupRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickupRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickupRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickupRes_extensionRes_ElmFn(PPickupRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickupArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickupArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickupArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickupArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickupArg_extensionArg_ElmFn(PPickupArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_PickrequRes_extensionRes_ElmFn(ASN1encoding_t enc, PPickrequRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_PickrequRes_extensionRes_ElmFn(ASN1decoding_t dec, PPickrequRes_extensionRes val);
	extern void ASN1CALL ASN1Free_PickrequRes_extensionRes_ElmFn(PPickrequRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_PickrequArg_extensionArg_ElmFn(ASN1encoding_t enc, PPickrequArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_PickrequArg_extensionArg_ElmFn(ASN1decoding_t dec, PPickrequArg_extensionArg val);
	extern void ASN1CALL ASN1Free_PickrequArg_extensionArg_ElmFn(PPickrequArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOffRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOffRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOffRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOffRes_extensionRes val);
	extern void ASN1CALL ASN1Free_GroupIndicationOffRes_extensionRes_ElmFn(PGroupIndicationOffRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOffArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOffArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOffArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOffArg_extensionArg val);
	extern void ASN1CALL ASN1Free_GroupIndicationOffArg_extensionArg_ElmFn(PGroupIndicationOffArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOnRes_extensionRes_ElmFn(ASN1encoding_t enc, PGroupIndicationOnRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOnRes_extensionRes_ElmFn(ASN1decoding_t dec, PGroupIndicationOnRes_extensionRes val);
	extern void ASN1CALL ASN1Free_GroupIndicationOnRes_extensionRes_ElmFn(PGroupIndicationOnRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_GroupIndicationOnArg_extensionArg_ElmFn(ASN1encoding_t enc, PGroupIndicationOnArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_GroupIndicationOnArg_extensionArg_ElmFn(ASN1decoding_t dec, PGroupIndicationOnArg_extensionArg val);
	extern void ASN1CALL ASN1Free_GroupIndicationOnArg_extensionArg_ElmFn(PGroupIndicationOnArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpSetupRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpSetupRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_CpSetupRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpSetupRes_extensionRes val);
	extern void ASN1CALL ASN1Free_CpSetupRes_extensionRes_ElmFn(PCpSetupRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_CpSetupArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpSetupArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpSetupArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpSetupArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpSetupArg_extensionArg_ElmFn(PCpSetupArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_CpRequestRes_extensionRes_ElmFn(ASN1encoding_t enc, PCpRequestRes_extensionRes val);
    extern int ASN1CALL ASN1Dec_CpRequestRes_extensionRes_ElmFn(ASN1decoding_t dec, PCpRequestRes_extensionRes val);
	extern void ASN1CALL ASN1Free_CpRequestRes_extensionRes_ElmFn(PCpRequestRes_extensionRes val);
    extern int ASN1CALL ASN1Enc_CpRequestArg_extensionArg_ElmFn(ASN1encoding_t enc, PCpRequestArg_extensionArg val);
    extern int ASN1CALL ASN1Dec_CpRequestArg_extensionArg_ElmFn(ASN1decoding_t dec, PCpRequestArg_extensionArg val);
	extern void ASN1CALL ASN1Free_CpRequestArg_extensionArg_ElmFn(PCpRequestArg_extensionArg val);
    extern int ASN1CALL ASN1Enc_ServiceApdus_rosApdus_ElmFn(ASN1encoding_t enc, PServiceApdus_rosApdus val);
    extern int ASN1CALL ASN1Dec_ServiceApdus_rosApdus_ElmFn(ASN1decoding_t dec, PServiceApdus_rosApdus val);
	extern void ASN1CALL ASN1Free_ServiceApdus_rosApdus_ElmFn(PServiceApdus_rosApdus val);
    extern int ASN1CALL ASN1Enc_EndpointAddress_destinationAddress_ElmFn(ASN1encoding_t enc, PEndpointAddress_destinationAddress val);
    extern int ASN1CALL ASN1Dec_EndpointAddress_destinationAddress_ElmFn(ASN1decoding_t dec, PEndpointAddress_destinationAddress val);
	extern void ASN1CALL ASN1Free_EndpointAddress_destinationAddress_ElmFn(PEndpointAddress_destinationAddress val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _H4503PP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\icounter.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Sun Apr 19 17:22:14 1998
 */
/* Compiler settings for icounter.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __icounter_h__
#define __icounter_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICounter_FWD_DEFINED__
#define __ICounter_FWD_DEFINED__
typedef interface ICounter ICounter;
#endif 	/* __ICounter_FWD_DEFINED__ */


#ifndef __IReport_FWD_DEFINED__
#define __IReport_FWD_DEFINED__
typedef interface IReport IReport;
#endif 	/* __IReport_FWD_DEFINED__ */


#ifndef __ICounterMgr_FWD_DEFINED__
#define __ICounterMgr_FWD_DEFINED__
typedef interface ICounterMgr ICounterMgr;
#endif 	/* __ICounterMgr_FWD_DEFINED__ */


#ifndef __Counter_FWD_DEFINED__
#define __Counter_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counter Counter;
#else
typedef struct Counter Counter;
#endif /* __cplusplus */

#endif 	/* __Counter_FWD_DEFINED__ */


#ifndef __Report_FWD_DEFINED__
#define __Report_FWD_DEFINED__

#ifdef __cplusplus
typedef class Report Report;
#else
typedef struct Report Report;
#endif /* __cplusplus */

#endif 	/* __Report_FWD_DEFINED__ */


#ifndef __CounterMgr_FWD_DEFINED__
#define __CounterMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterMgr CounterMgr;
#else
typedef struct CounterMgr CounterMgr;
#endif /* __cplusplus */

#endif 	/* __CounterMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "stats.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICounter_INTERFACE_DEFINED__
#define __ICounter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77801-3830-11d0-B143-00C04FC2A118")
    ICounter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitMax( 
            /* [in] */ int nMaxValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopStatistics( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadStatistics( 
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearStatistics( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            ICounter __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitMax )( 
            ICounter __RPC_FAR * This,
            /* [in] */ int nMaxValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            ICounter __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopStatistics )( 
            ICounter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReadStatistics )( 
            ICounter __RPC_FAR * This,
            /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearStatistics )( 
            ICounter __RPC_FAR * This);
        
        END_INTERFACE
    } ICounterVtbl;

    interface ICounter
    {
        CONST_VTBL struct ICounterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounter_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define ICounter_Update(This,nValue)	\
    (This)->lpVtbl -> Update(This,nValue)

#define ICounter_InitMax(This,nMaxValue)	\
    (This)->lpVtbl -> InitMax(This,nMaxValue)

#define ICounter_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#define ICounter_StartStatistics(This)	\
    (This)->lpVtbl -> StartStatistics(This)

#define ICounter_StopStatistics(This)	\
    (This)->lpVtbl -> StopStatistics(This)

#define ICounter_ReadStatistics(This,lpcs)	\
    (This)->lpVtbl -> ReadStatistics(This,lpcs)

#define ICounter_ClearStatistics(This)	\
    (This)->lpVtbl -> ClearStatistics(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounter_Initialize_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICounter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_Update_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nValue);


void __RPC_STUB ICounter_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_InitMax_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ int nMaxValue);


void __RPC_STUB ICounter_InitMax_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_GetValue_Proxy( 
    ICounter __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB ICounter_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StartStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StartStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_StopStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_StopStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ReadStatistics_Proxy( 
    ICounter __RPC_FAR * This,
    /* [out] */ COUNTERSTAT __RPC_FAR *lpcs);


void __RPC_STUB ICounter_ReadStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounter_ClearStatistics_Proxy( 
    ICounter __RPC_FAR * This);


void __RPC_STUB ICounter_ClearStatistics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounter_INTERFACE_DEFINED__ */


#ifndef __IReport_INTERFACE_DEFINED__
#define __IReport_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReport
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_IReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7BC77802-3830-11d0-B143-00C04FC2A118")
    IReport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReport __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReport __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReport __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Initialize )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Update )( 
            IReport __RPC_FAR * This,
            /* [in] */ int nValue,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEntry )( 
            IReport __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [in] */ DWORD dwIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue )( 
            IReport __RPC_FAR * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ int __RPC_FAR *pnValue);
        
        END_INTERFACE
    } IReportVtbl;

    interface IReport
    {
        CONST_VTBL struct IReportVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReport_Initialize(This,szName,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,szName,dwFlags)

#define IReport_Update(This,nValue,dwIndex)	\
    (This)->lpVtbl -> Update(This,nValue,dwIndex)

#define IReport_CreateEntry(This,szName,dwIndex)	\
    (This)->lpVtbl -> CreateEntry(This,szName,dwIndex)

#define IReport_GetValue(This,dwFlags,pnValue)	\
    (This)->lpVtbl -> GetValue(This,dwFlags,pnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReport_Initialize_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IReport_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_Update_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ int nValue,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_CreateEntry_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [in] */ DWORD dwIndex);


void __RPC_STUB IReport_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReport_GetValue_Proxy( 
    IReport __RPC_FAR * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ int __RPC_FAR *pnValue);


void __RPC_STUB IReport_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReport_INTERFACE_DEFINED__ */


#ifndef __ICounterMgr_INTERFACE_DEFINED__
#define __ICounterMgr_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICounterMgr
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][helpstring][uuid][object] */ 



EXTERN_C const IID IID_ICounterMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("9CB7FE5B-3444-11D0-B143-00C04FC2A118")
    ICounterMgr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateCounter( 
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstC( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextC( 
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReport( 
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindFirstR( 
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindNextR( 
            /* [out] */ FINDREPORT __RPC_FAR *lpfr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICounterMgr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICounterMgr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateCounter )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstC )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextC )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateReport )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindFirstR )( 
            ICounterMgr __RPC_FAR * This,
            /* [in] */ char __RPC_FAR *szName,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindNextR )( 
            ICounterMgr __RPC_FAR * This,
            /* [out] */ FINDREPORT __RPC_FAR *lpfr);
        
        END_INTERFACE
    } ICounterMgrVtbl;

    interface ICounterMgr
    {
        CONST_VTBL struct ICounterMgrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterMgr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICounterMgr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICounterMgr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICounterMgr_CreateCounter(This,lplpCounter)	\
    (This)->lpVtbl -> CreateCounter(This,lplpCounter)

#define ICounterMgr_FindFirstC(This,szName,lpfc)	\
    (This)->lpVtbl -> FindFirstC(This,szName,lpfc)

#define ICounterMgr_FindNextC(This,lpfc)	\
    (This)->lpVtbl -> FindNextC(This,lpfc)

#define ICounterMgr_CreateReport(This,lplpReport)	\
    (This)->lpVtbl -> CreateReport(This,lplpReport)

#define ICounterMgr_FindFirstR(This,szName,lpfr)	\
    (This)->lpVtbl -> FindFirstR(This,szName,lpfr)

#define ICounterMgr_FindNextR(This,lpfr)	\
    (This)->lpVtbl -> FindNextR(This,lpfr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICounterMgr_CreateCounter_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ ICounter __RPC_FAR *__RPC_FAR *lplpCounter);


void __RPC_STUB ICounterMgr_CreateCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindFirstC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextC_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDCOUNTER __RPC_FAR *lpfc);


void __RPC_STUB ICounterMgr_FindNextC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_CreateReport_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ IReport __RPC_FAR *__RPC_FAR *lplpReport);


void __RPC_STUB ICounterMgr_CreateReport_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindFirstR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [in] */ char __RPC_FAR *szName,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindFirstR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICounterMgr_FindNextR_Proxy( 
    ICounterMgr __RPC_FAR * This,
    /* [out] */ FINDREPORT __RPC_FAR *lpfr);


void __RPC_STUB ICounterMgr_FindNextR_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICounterMgr_INTERFACE_DEFINED__ */



#ifndef __Counter_LIBRARY_DEFINED__
#define __Counter_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: Counter
 * at Sun Apr 19 17:22:14 1998
 * using MIDL 3.01.75
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_Counter;

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Counter;

class DECLSPEC_UUID("9CB7FE5F-3444-11D0-B143-00C04FC2A118")
Counter;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_Report;

class DECLSPEC_UUID("9CB7FE5E-3444-11D0-B143-00C04FC2A118")
Report;
#endif

#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CounterMgr;

class DECLSPEC_UUID("65DDC229-38FE-11d0-B143-00C04FC2A118")
CounterMgr;
#endif
#endif /* __Counter_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323vidt.h ===
///////////////////////////////////////////////////////////////////////////////
//
//        Name: H323vidt.h
//
// Description: Definition of the CH323VideoCaptureTerminal class
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _H323VIDT_H_
#define _H323VIDT_H_

#include "h323term.h"

/////////////////////////////////////////////////////////////////////////////
// CH323VideoCaptureTerminal
/////////////////////////////////////////////////////////////////////////////
const DWORD VIDEO_CAPTURE_FILTER_NUMPINS = 3;

interface DECLSPEC_UUID("b44aca09-e746-4d58-ad97-8890ba2286e5") DECLSPEC_NOVTABLE
IH323VideoDummy : public IUnknown
{
};

#define IID_IH323VideoDummy __uuidof(IH323VideoDummy)

    // COM_INTERFACE_ENTRY_CHAIN is not allowed to the 1st one is a MAP
    // entry IConfVideoDummy is to make BEGIN_COM_MAP happy

class CH323VideoCaptureTerminal : 
    public IH323VideoDummy,
    public CH323BaseTerminal
{
BEGIN_COM_MAP(CH323VideoCaptureTerminal)
    COM_INTERFACE_ENTRY(IH323VideoDummy)
    COM_INTERFACE_ENTRY_CHAIN(CH323BaseTerminal)
END_COM_MAP()

public:
    CH323VideoCaptureTerminal();

    virtual ~CH323VideoCaptureTerminal();

    static HRESULT CreateTerminal(
        IN  char *          strDeviceName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress,
        OUT ITTerminal      **ppTerm
        );

    HRESULT Initialize (
        IN  char *          strName,
        IN  UINT            VideoCaptureID,
        IN  MSP_HANDLE      htAddress
        );

protected:

    HRESULT CreateFilter();
    DWORD GetNumExposedPins() const 
    {
        return VIDEO_CAPTURE_FILTER_NUMPINS;
    }
    
    HRESULT GetExposedPins(
        IN  IPin ** ppPins, 
        IN  DWORD dwNumPins
        );

protected:
    UINT    m_VideoCaptureID;
};


#endif // _H323VIDT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\h323vid.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    Confvid.h

Abstract:

    Definitions for video streams

Author:

    Mu Han (muhan) 15-September-1998

--*/
#ifndef __CONFVID_H_
#define __CONFVID_H_

const DWORD LAYERID = 0;

const int IFRAMEINTERVAL = 15;  // in seconds.
const int MINIFRAMEINTERVAL = 1; // in seconds

typedef enum _PERIODICIFRAMEMODE
{
    PIF_ON,
    PIF_HOLD,
    PIF_OFF
} PERIODICIFRAMEMODE;

// assert IFrame related variable being in valid state
#define AssertPeriodicIFrameMode _ASSERT (\
    /* enabled and running */ \
    (PIF_ON == m_PeriodicIFrameMode && \
     NULL != m_hTimerQueue && \
     NULL != m_hIFrameTimer && \
     MINIFRAMEINTERVAL <= m_dwIFrameInterval && \
     (STRM_RUNNING & m_dwState)) || \
    /* enabled but not running */ \
    (PIF_HOLD == m_PeriodicIFrameMode && \
     NULL != m_hTimerQueue && \
     NULL == m_hIFrameTimer && \
     MINIFRAMEINTERVAL <= m_dwIFrameInterval && \
     (STRM_RUNNING & m_dwState)) || \
    /* diabled */ \
    (PIF_OFF == m_PeriodicIFrameMode && \
     NULL == m_hTimerQueue && \
     NULL == m_hIFrameTimer))


class CStreamVideoRecv : 
    public CH323MSPStream,
    public IKeyFrameControl
{
BEGIN_COM_MAP(CStreamVideoRecv)
    COM_INTERFACE_ENTRY(IKeyFrameControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamVideoRecv();
    ~CStreamVideoRecv();

    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);
    STDMETHOD (SC_Pause) ();
    STDMETHOD (SC_Stop) (BOOL fRequestedByApplication);

    HRESULT ShutDown();

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    // IKeyFrameControl methods
    //
    STDMETHOD (UpdatePicture)();

    STDMETHOD (PeriodicUpdatePicture) (
        IN BOOL fEnable, 
        IN DWORD dwInterval
        );

    //
    // ITStreamQualityControl methods
    //
    STDMETHOD (Set) (
        IN   StreamQualityProperty Property, 
        IN   long lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

protected:
    HRESULT SetUpInternalFilters(
        IN IPin * pVideoInputPin,
        IN BOOL fDirectRTP
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT InitializeH245CapabilityTable();

    HRESULT ReCreateIFrameTimer(
        IN PERIODICIFRAMEMODE mode,
        IN DWORD dwInterval
        );

    static VOID CALLBACK TimerCallback(
        IN PVOID lpContext,
        IN BOOLEAN TimerOrWaitFired
        );

    static DWORD CALLBACK IFrameCallback(
        IN PVOID lpContext
        );

protected:
    IBaseFilter *       m_pDecoderFilter;
    IBitrateControl *   m_pRenderBitrateControl;
    IFrameRateControl * m_pRenderFrameRateControl;

    // members for IKeyFrameControl interface.
    PERIODICIFRAMEMODE  m_PeriodicIFrameMode;
    DWORD               m_dwIFrameInterval;
    DWORD               m_dwLastIFrameRequestedTime;
    DWORD               m_dwIFramePending;

    HANDLE              m_hTimerQueue;
    HANDLE              m_hIFrameTimer;
};


class ATL_NO_VTABLE CSubStreamVideoPreview;

class CStreamVideoSend : 
    public CH323MSPStream,
    public IVidEncChannelControl,
    public IDispatchImpl<ITSubStreamControl, &IID_ITSubStreamControl, &LIBID_TAPI3Lib>
{

BEGIN_COM_MAP(CStreamVideoSend)
    COM_INTERFACE_ENTRY(ITSubStreamControl)
    COM_INTERFACE_ENTRY(IVidEncChannelControl)
    COM_INTERFACE_ENTRY_CHAIN(CH323MSPStream)
END_COM_MAP()

public:
    CStreamVideoSend();
    ~CStreamVideoSend();

    HRESULT ShutDown ();

    STDMETHOD (SC_Start) (BOOL fRequestedByApplication);

    //
    // ITSubStreamControl methods
    //
    STDMETHOD (CreateSubStream) (
        IN OUT  ITSubStream **         ppSubStream
        );

    STDMETHOD (RemoveSubStream) (
        IN      ITSubStream *          pSubStream
        );

    STDMETHOD (EnumerateSubStreams) (
        OUT     IEnumSubStream **      ppEnumSubStream
        );

    STDMETHOD (get_SubStreams) (
        OUT     VARIANT *              pSubStreams
        );
    
    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    //
    //IInnerStreamQualityControl methods
    //
    STDMETHOD (GetRange) (
        IN   InnerStreamQualityProperty property, 
        OUT  LONG *plMin, 
        OUT  LONG *plMax, 
        OUT  LONG *plSteppingDelta, 
        OUT  LONG *plDefault, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Get) (
        IN   InnerStreamQualityProperty property,
        OUT  LONG *plValue, 
        OUT  TAPIControlFlags *plFlags
        );

    STDMETHOD (Set) (
        IN   InnerStreamQualityProperty property,
        IN   LONG lValue, 
        IN   TAPIControlFlags lFlags
        );

    //
    //IVidEncChannelControl methods
    //
	STDMETHOD (VideoFastUpdatePicture)(VOID);

	STDMETHOD (VideoFastUpdateGOB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwNumberOfGOBs
		);

	STDMETHOD (VideoFastUpdateMB)(
		IN  DWORD dwFirstGOB, 
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs
		);

	STDMETHOD (VideoSendSyncEveryGOB)(
		IN  BOOL fEnable
		);

	STDMETHOD (VideoNotDecodedMBs)(
		IN  DWORD dwFirstMB, 
		IN  DWORD dwNumberOfMBs, 
		IN  DWORD dwTemporalReference
		);

	STDMETHOD (VideoEncTemporalSpatialTradeoff)(
		IN  USHORT uTSValue
		);
public:
    HRESULT GetPreviewTerminal(
        OUT ITTerminal ** ppTerminal
        );

    HRESULT GetPreviewPin(
        OUT IPin ** ppPin
        );

protected:
    HRESULT CheckTerminalTypeAndDirection(
        IN  ITTerminal *            pTerminal
        );

    HRESULT GetVideoCapturePins(
        IN  ITTerminalControl*  pTerminal,
        OUT BOOL *pfDirectRTP
        );

    HRESULT ConnectCaptureTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectPreviewTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT ConnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT DisconnectTerminal(
        IN  ITTerminal *   pITTerminal
        );

    HRESULT CreateSendFilters(
        IN    IPin          *pCapturePin,
        IN   IPin          *pRTPPin,
        IN   BOOL           fDirectRTP
        );

    HRESULT ConnectRTPFilter(
        IN  IGraphBuilder *pIGraphBuilder,
        IN  IPin          *pCapturePin,
        IN  IPin          *pRTPPin,
        IN  IBaseFilter   *pRTPFilter
        );

    HRESULT ConnectPreview(
        IN    IPin          *pPreviewInputPin
        );

    HRESULT FindPreviewInputPin(
        IN  ITTerminalControl*  pTerminal,
        OUT IPin **             ppIpin
        );

    HRESULT GetPreviewSubStream(
        OUT ITSubStream ** ppITSubStream
        );

    void CleanupCachedInterface();

protected:

    ITSubStream *       m_pPreviewSubStream;
                        
    ITTerminal *        m_pCaptureTerminal;
    ITTerminal *        m_pPreviewTerminal;
    BOOL                m_fPreviewConnected;

    IBaseFilter *       m_pCaptureFilter;

    IPin *              m_pCapturePin;
    IFrameRateControl * m_pCaptureFrameRateControl;
    IBitrateControl *   m_pCaptureBitrateControl;

    IPin *              m_pPreviewPin;
    IFrameRateControl * m_pPreviewFrameRateControl;

    IPin *              m_pRTPPin;

    // this filter is used to answer the H245 questions when the terminal
    // can't answer them. This is a hack to support legacy terminals. The
    // app needs to select the right format to make it work.
    IBaseFilter *       m_pEncoder;
};

class ATL_NO_VTABLE CSubStreamVideoPreview : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public ITFormatControl,
    public IDispatchImpl<ITSubStream, &IID_ITSubStream, &LIBID_TAPI3Lib>
{
public:

BEGIN_COM_MAP(CSubStreamVideoPreview)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITSubStream)
    COM_INTERFACE_ENTRY(ITFormatControl)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pFTM)
END_COM_MAP()

DECLARE_GET_CONTROLLING_UNKNOWN()

    CSubStreamVideoPreview(); 

// methods of the CComObject
    void FinalRelease();

// ITSubStream methods, called by the app.
    STDMETHOD (SelectTerminal) (
        IN      ITTerminal *            pTerminal
        );

    STDMETHOD (UnselectTerminal) (
        IN     ITTerminal *             pTerminal
        );

    STDMETHOD (EnumerateTerminals) (
        OUT     IEnumTerminal **        ppEnumTerminal
        );

    STDMETHOD (get_Terminals) (
        OUT     VARIANT *               pTerminals
        );

    STDMETHOD (get_Stream) (
        OUT     ITStream **             ppITStream
        );

    STDMETHOD (StartSubStream) ();

    STDMETHOD (PauseSubStream) ();

    STDMETHOD (StopSubStream) ();

    //
    // ITFormatControl
    //
    STDMETHOD (GetCurrentFormat) (
        OUT AM_MEDIA_TYPE **ppMediaType
        );

    STDMETHOD (ReleaseFormat) (
        IN AM_MEDIA_TYPE *pMediaType
        );

    STDMETHOD (GetNumberOfCapabilities) (
        OUT DWORD *pdwCount
        );

    STDMETHOD (GetStreamCaps) (
        IN DWORD dwIndex, 
        OUT AM_MEDIA_TYPE **ppMediaType, 
        OUT TAPI_STREAM_CONFIG_CAPS *pStreamConfigCaps, 
        OUT BOOL *pfEnabled
        );

    STDMETHOD (ReOrderCapabilities) (
        IN DWORD *pdwIndices, 
        IN BOOL *pfEnabled, 
        IN BOOL *pfPublicize, 
        IN DWORD dwNumIndices
        );

// methods called by the stream object.
    virtual HRESULT Init(
        IN  CStreamVideoSend *  pStream
        );

protected:
    // Pointer to the free threaded marshaler.
    IUnknown *                  m_pFTM;

    CStreamVideoSend *          m_pStream;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\mspdebug.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    common.h

Abstract:

    commonly used headers.

Author:
    
    Mu Han (muhan) 1-November-1997

--*/
#ifndef __COMMON_H_
#define __COMMON_H_

#include "msplog.h"


#ifdef MSPLOG
#define ENTER_FUNCTION(s) \
    static const CHAR * const __fxName = s
#else
#define ENTER_FUNCTION(s)
#endif // MSPLOG

#ifdef DEBUG
//  DEBUG **********************************
int WINAPI MSPDbgPrintf ( LPTSTR lpszFormat, ... );
// fake GETMASK
#define GETMASK(m) 0

// extern HDBGZONE  ghDbgZoneMsp;  // MSP debug zone control registration
// fake registration temporarily
#define ghDbgZoneMsp 0

#define ZONE_INIT       (GETMASK(ghDbgZoneMSP) & 0x0001)
#define ZONE_TERMINAL   (GETMASK(ghDbgZoneMSP) & 0x0002)
#define ZONE_STREAM     (GETMASK(ghDbgZoneMSP) & 0x0004)
#define ZONE_H245       (GETMASK(ghDbgZoneMSP) & 0x0008)
#define ZONE_MCCOMMANDS (GETMASK(ghDbgZoneMSP) & 0x0010)
#define ZONE_TSPCOMM    (GETMASK(ghDbgZoneMSP) & 0x0020)
#define ZONE_CHANNEL    (GETMASK(ghDbgZoneMSP) & 0x0040)
#define ZONE_REFCOUNT   (GETMASK(ghDbgZoneMSP) & 0x0080)
#define ZONE_U4         (GETMASK(ghDbgZoneMSP) & 0x0100)
#define ZONE_PROFILE    (GETMASK(ghDbgZoneMSP) & 0x0200)

//extern HDBGZONE  ghDbgZoneStream;   // stream debug zone control registration
// fake registration temporarily
#define ghDbgZoneStream 0

#define ZONE_S1 (GETMASK(ghDbgZoneStream) & 0x0001)
#define ZONE_S2 (GETMASK(ghDbgZoneStream) & 0x0002)

#ifndef DEBUGMSG 
//    #define DEBUGMSG(z,s)	( (z) ? (MSPDbgPrintf s ) : 0)
//    #define DEBUGMSG(z,s)	( (z) ? (LOG(s)) : 0)
// ignore the zone temporarily
    #define DEBUGMSG(z,s)	LOG(s)

#endif // DEBUGMSG

#ifndef FX_ENTRY 
    #define FX_ENTRY(s)	static TCHAR _this_fx_ [] = (s);
    #define _fx_		((LPTSTR) _this_fx_)
#endif // FX_ENTRY

// #define ERRORMESSAGE(m) (MSPDbgPrintf m)
 #define ERRORMESSAGE(m) LOG(m)
 
#else // not DEBUG *******************************

#ifndef FX_ENTRY 
    #define FX_ENTRY(s)	
#endif // FX_ENTRY

#ifndef DEBUGMSG 
    #define DEBUGMSG(z,s)
    #define ERRORMESSAGE(m)
#endif  // DEBUGMSG

#define _fx_		
#define ERRORMESSAGE(m)

#endif // not DEBUG ***********************

#endif // __COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\address.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    address.cpp

Abstract:

    TAPI Service Provider functions related to manipulating addresses.

        TSPI_lineGetAddressCaps
        TSPI_lineGetAddressStatus

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 
//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include "line.h"


//                                                                           
// TSPI procedures                                                           
//                                                                           

LONG
TSPIAPI
TSPI_lineGetAddressCaps(
    DWORD             dwDeviceID,
    DWORD             dwAddressID,
    DWORD             dwTSPIVersion,
    DWORD             dwExtVersion,
    LPLINEADDRESSCAPS pAddressCaps
    )
    
/*++

Routine Description:

    This function queries the specified address on the specified line device 
    to determine its telephony capabilities.

    The line device IDs supported by a particular driver are numbered 
    sequentially starting at a value set by the TAPI DLL using the 
    TSPI_lineSetDeviceIDBase function.

    The version number supplied has been negotiated by the TAPI DLL using 
    TSPI_lineNegotiateTSPIVersion.

Arguments:

    dwDeviceID - Specifies the line device containing the address to be 
        queried.

    dwAddressID - Specifies the address on the given line device whose 
        capabilities are to be queried.

    dwTSPIVersion - Specifies the version number of the Telephony SPI to be 
        used. The high order word contains the major version number; the low 
        order word contains the minor version number.

    dwExtVersion - Specifies the version number of the service 
        provider-specific extensions to be used. This number can be left 
        zero if no device specific extensions are to be used. Otherwise, 
        the high order word contains the major version number; the low 
        order word contain the minor version number.

    pAddressCaps - Specifies a far pointer to a variable sized structure 
        of type LINEADDRESSCAPS. Upon successful completion of the request, 
        this structure is filled with address capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of the range 
            of line devices IDs supported by this driver.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_INCOMPATIBLEVERSION - The specified TSPI and/or extension 
            version number is not supported by the Service Provider for the 
            specified line device.

        LINEERR_INVALEXTVERSION - The app requested an invalid extension 
            version number.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

{
    LONG retVal;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressCaps - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // make sure this is a version we support    
    if (!H323ValidateExtVersion(dwExtVersion))
    {
        // do not support extensions 
        retVal = LINEERR_INVALEXTVERSION;
        goto exit;

    }

    // make sure address id is supported
    if( g_pH323Line -> IsValidAddressID(dwAddressID) == FALSE )
    {
        // invalid address id
        retVal = LINEERR_INVALADDRESSID;
        goto exit;
    }
    
    retVal = g_pH323Line -> CopyLineInfo( dwDeviceID, pAddressCaps );
exit:
    return retVal;
}

/*++

Routine Description:

    This operation allows the TAPI DLL to query the specified address for its 
    current status.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        containing the address to be queried.

    dwAddressID - Specifies an address on the given open line device. 
        This is the address to be queried.

    pAddressStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEADDRESSSTATUS.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.

        LINEERR_INVALADDRESSID - The specified address ID is out of range.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/

LONG
TSPIAPI
TSPI_lineGetAddressStatus(
    HDRVLINE            hdLine,
    DWORD               dwAddressID,
    LPLINEADDRESSSTATUS pAddressStatus
    )
{
    LONG retVal = NOERROR;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressStatus - Entered." ));
    
    // make sure address id is supported
    if( g_pH323Line -> IsValidAddressID(dwAddressID) == FALSE )
    {
        // invalid address id
        return LINEERR_INVALADDRESSID;
    }

    //lock the line device
    g_pH323Line -> Lock();

    // calculate the number of bytes required
    pAddressStatus->dwNeededSize = sizeof(LINEADDRESSSTATUS);

    // see if lineaddressstatus structure is of correct size
    if (pAddressStatus->dwTotalSize < pAddressStatus->dwNeededSize) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "lineaddressstatus structure too small."
            ));

        //unlock the line device
        g_pH323Line -> Unlock();
        
        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    // record amount of memory used
    pAddressStatus->dwUsedSize = pAddressStatus->dwNeededSize;

    // transfer number of active calls from line device structure
    pAddressStatus->dwNumActiveCalls = g_pH323Line -> GetNoOfCalls();
    
    // specify that outbound call is possible on the address
    pAddressStatus->dwAddressFeatures = H323_ADDR_ADDRFEATURES;

    if( g_pH323Line->GetCallForwardParams() &&
        (g_pH323Line->GetCallForwardParams()->fForwardingEnabled) )
    {
        pAddressStatus->dwNumRingsNoAnswer = g_pH323Line->m_dwNumRingsNoAnswer;
        pAddressStatus->dwForwardOffset = pAddressStatus->dwUsedSize;
        retVal = g_pH323Line->CopyAddressForwardInfo( pAddressStatus );
    }

    //unlock the line device
    g_pH323Line -> Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressStatus - Exited." ));
    
    // success
    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\stats.h ===
//  STATS.H
//
//      Headers for STATS.DLL: a library to accumulate high performance
//      statistics and allow them to be tabulated in a different
//      process.
//
//  Created 24-Oct-96 [JonT]

#ifndef _STATS_H
#define _STATS_H

#ifdef __cplusplus
extern "C" {
#endif

//#if defined(_BUILD_STATS_) || defined(__midl)
#ifdef _BUILD_STATS_
#define STATSAPI
#else
#define STATSAPI __declspec(dllimport)
#endif

// Equates
#define MAX_COUNTER_NAME    64
#define STATS_COUNTER_ADDDEL_EVENT  "StatsNewCounter"
#define COUNTER_FLAG_NO_STATISTICS  1   // Flag to CreateCounter. No statistics accumulated
                                        // for this counter even if StartStatistics called.
                                        // (StartStatistics fails)
#define COUNTER_FLAG_ACCUMULATE     2   // UpdateCounter adds to the counter value rather
                                        // than replacing it.
#define COUNTER_CLEAR               1   // Flag to GetCounter. Specifies the counter should
                                        // be cleared after being read

// Types

#ifdef __midl
typedef DWORD HCOUNTER;
#else
typedef HANDLE HCOUNTER;
#endif

typedef struct _FINDCOUNTER
{
    DWORD dwSize;
    char szName[MAX_COUNTER_NAME];      // Human-readable counter name
    HCOUNTER hcounter;                  // Handle to use with all stats functions
    int nValue;                         // Current value of counter
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDCOUNTER;

typedef struct _COUNTERSTAT
{
    DWORD dwSize;                       // Size of structure. Allows for future growth...
    int nValue;
    int nLow;                           // Lowest value seen since clear
    int nHigh;                          // Highest value seen since clear
    int nAverage;                       // Average value seen since clear
    DWORD dwNumSamples;                 // Number of samples accumulated
    DWORD dwmsAtClear;                  // GetTickCount at last Clear/StartStatistics call
} COUNTERSTAT;

typedef HCOUNTER HREPORT;
#define MAX_REPORT_NAME    64

typedef struct _FINDREPORT
{
    DWORD dwSize;
    char szName[MAX_REPORT_NAME];       // Human-readable report name
    HREPORT hreport;                    // Handle to use with all functions
    WORD wFlags;                        // COUNTER_FLAG_* values
    WORD wRefCount;                     // Number of times StartStatistics has been called.
    DWORD dwReserved;                   // Must be preserved: used for FindNextCounter
} FINDREPORT;

// Nothing further needed by MIDL
#ifndef __midl

// Functions

    // Called by updater of counter to make new counter
    // Sets the event named in the equate STATS_NEW_COUNTER_EVENT
    STATSAPI HCOUNTER WINAPI    CreateCounter(char* szName, WORD wFlags);

    // Called by updater of counter when counter is going away
    STATSAPI BOOL WINAPI DeleteCounter(HCOUNTER hc);

    // Used by reader app to locate specific named counters or walk entire list.
    // Pass NULL in for name to walk entire list. Pass NULL to FINDCOUNTER if
    // just an HCOUNTER is desired. FindNext returns FALSE when there are no more.
    STATSAPI HCOUNTER WINAPI    FindFirstCounter(char* szName, FINDCOUNTER* pfc);
    STATSAPI BOOL WINAPI        FindNextCounter(FINDCOUNTER* pfc);

    // Called by updater of counter. Makes the value current in the counter.
    STATSAPI void WINAPI        UpdateCounter(HCOUNTER hcounter, int value);

    // Called by user of counter and just returns value with no statistics
    STATSAPI int WINAPI         GetCounter(HCOUNTER hcounter, DWORD dwFlags);

    // Begins collecting statistics on a counter
    STATSAPI BOOL WINAPI        StartStatistics(HCOUNTER hcounter);

    // Done collecting statistics on a counter
    STATSAPI void WINAPI        StopStatistics(HCOUNTER hcounter);

    // Get statistics on a counter
    STATSAPI BOOL WINAPI        ReadStatistics(HCOUNTER hcounter, COUNTERSTAT* pcs);

    // Clear statistics on a counter
    STATSAPI void WINAPI        ClearStatistics(HCOUNTER hcounter);

#endif // #ifndef __midl

#ifdef __cplusplus
}
#endif

#endif // #ifndef _STATS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\inc\tspmspif.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    tspmspif.h

Abstract:

    Message interface between H.32X MSP and TSP

Author:
    Michael Vanbuskirk (mikev) 05/12/99

--*/

#ifndef __TSPMSPIF_H_
#define __TSPMSPIF_H_


#include <winsock2.h>

typedef enum tag_TspMspMessageType
{
	SP_MSG_InitiateCall,
	SP_MSG_AnswerCall,	
	SP_MSG_PrepareToAnswer,	
	SP_MSG_ProceedWithAnswer,	
	SP_MSG_ReadyToInitiate,	
	SP_MSG_ReadyToAnswer,	
	SP_MSG_FastConnectResponse,
	SP_MSG_StartH245,	
	SP_MSG_ConnectComplete,	
	SP_MSG_H245PDU,	
	SP_MSG_MCLocationIdentify,	
	SP_MSG_Hold,	
	SP_MSG_H245Hold,	
	SP_MSG_ConferenceList,	
	SP_MSG_SendDTMFDigits,	
	SP_MSG_ReleaseCall,	
	SP_MSG_CallShutdown,
	SP_MSG_H245Terminated,	
	SP_MSG_LegacyDefaultAlias,
	SP_MSG_RASRegistration,	
	SP_MSG_RASRegistrationEvent,	
	SP_MSG_RASLocationRequest,	
	SP_MSG_RASLocationConfirm,	
	SP_MSG_RASBandwidthRequest,	
	SP_MSG_RASBandwidthConfirm	
}TspMspMessageType;


/* 
InitiateCall
    - Handle of TSP's replacement call (if applicable)
    - Handle of conference call (if applicable)
*/
typedef struct 
{
	HANDLE hTSPReplacementCall;		/* replacement call handle of the 
									entity sending the message (MSP's or TSP's handle) */
	HANDLE hTSPConferenceCall;
	SOCKADDR_IN saLocalQ931Addr;
} TSPMSP_InitiateCallMessage;


// AnswerCall (TSP to MSP).  // no parameters

/*
PrepareToAnswer (TSP to MSP).
    - Received fastConnect parameters
    - Received h245Tunneling capability
    - WaitForConnect flag
    - Q.931 setup parameters 
    - Handle of replacement call (if applicable)

*/

typedef struct 
{
	HANDLE hReplacementCall;		/* replacement call handle of the 
									entity sending the message (either the MSP TSP) */
	SOCKADDR_IN saLocalQ931Addr;
} TSPMSP_PrepareToAnswerMessage;

/*
ProceedWithAnswer (MSP to TSP)
    - Address of MC to deflect the call to
*/
typedef struct 
{
	BOOL fMCAddressPresent;		// true if AddrMC contains the MC address
	                            // FALSE if simply proceeding
	SOCKADDR_IN	saAddrMC;		// address of MC to route call to
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ProceedWithAnswerMessage;


/*
ReadyToInitiate 
    - Additional callee addresses, callee alias(es) 
    - FastConnect proposal
    - WaitForConnect flag
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)

*/

typedef struct 
{
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ReadyToInitiateMessage;


/*
ReadyToAnswer (MSP to TSP)	
    - Fast Connect response 	
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)
*/

typedef struct 
{
	HANDLE hMSPReplacementCall;		/* MSP's replacement call handle (if applicable) */
} TSPMSP_ReadyToAnswerMessage;

/*
FastConnectResponse (TSP to MSP)	
    - Fast Connect response 	
    - Security profile ID(s)
    - Security token(s)
    - Handle of MSP's replacement call (if applicable)
*/

typedef struct 
{
	HANDLE hTSPReplacementCall;		/* MSP's replacement call handle */
	BOOL    fH245TunnelCapability;
	SOCKADDR_IN saH245Addr;
} TSPMSP_FastConnectResponseMessage;


/*
StartH245 (TSP->MSP)
    - Call handle of call to replace (used in the "call transfer" case only)
    - Handle of TSP's replacement call (if applicable)
    - H.245 address
    - Received h245Tunneling capability
    - Conference call identifier (local MC case only)
    
optional (ASN.1):
    - Security token(s) received via Q.931
    - Security profile identifier(s) received via Q.931
    - Received fastConnect response (outgoing call case)
   
*/
typedef struct 
{
	HANDLE hMSPReplaceCall;		    /* handle of MSP's call being replaced */
	HANDLE hTSPReplacementCall;		/* TSP's replacement call handle */
    BYTE    ConferenceID[16];
	BOOL    fH245TunnelCapability;
	BOOL    fH245AddressPresent;
	SOCKADDR_IN saH245Addr;
	SOCKADDR_IN saQ931Addr;	    // always present
} TSPMSP_StartH245Message;


/*
ConnectComplete (TSP->MSP)	// no parameters
*/

/*
H245PDU (MSP->TSP, TSP->MSP)	// tunneled, encoded, pure ASN.1
*/

typedef struct 
{
} TSPMSP_H245PDUMessage;

/*
MCLocationIdentify (MSP->TSP)
*/

typedef struct 
{
	BOOL fMCIsLocal;		// true if the MC is  on the local machine
	SOCKADDR_IN	AddrMC;		// address of MC to route call to
} TSPMSP_MCLocationIdentifyMessage;

/*
Hold (TSP->MSP)
*/

typedef struct 
{
	BOOL fHold;			
} TSPMSP_HoldMessage;


/*
H245Hold (MSP->TSP) 
*/
typedef struct 
{
	BOOL fHold;			
} TSPMSP_H245HoldMessage;

/*
ConferenceList(MSP->TSP, TSP->MSP)
*/
typedef struct 
{
	HANDLE hTSPReplacementCall;		/* MSP's replacement call handle */
} TSPMSP_ConferenceListMessage;


/*
SendDTMFDigits (TSP->MSP) 
*/

typedef struct 
{
	WORD 	wNumDigits;  // number of  characters in TspMspMessage.u.WideChars
} TSPMSP_SendDTMFDigitsMessage;

/*
ReleaseCall(MSP->TSP)	// no parameters
*/

/*
CallShutdown (TSP->MSP)	// no parameters
*/

/*
H245Terminated (MSP->TSP)	// no parameters
*/

typedef struct 
{
	WORD 	wNumChars;  // number of  characters in TspMspMessage.u.WideChars
} TSPMSP_LegacyDefaultAliasMessage;

/*
RASRegistration (MSP->TSP)
    - The list of aliases to register or unregister
*/
typedef struct 
{
    SOCKADDR_IN saGateKeeperAddr; 
} TSPMSP_RegistrationRequestMessage;


/*
RASRegistrationEvent (TSP->MSP)	// in encoded ASN.1 form
    - The event (URQ, DRQ, UCF, RCF)
    - The list of aliases that are affected by the event

*/

typedef struct 
{
} TSPMSP_RASEventMessage;


/*
RASLocationRequest (MSP->TSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_LocationRequestMessage;

/*
RASLocationConfirm (TSP->MSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_LocationConfirmMessage;

/*
RASBandwidthRequest (MSP->TSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_BandwidthRequestMessage;

/*
RASBandwidthConfirm (TSP->MSP)	// in encoded ASN.1 form
*/
typedef struct 
{
} TSPMSP_BandwidthConfirmMessage;


typedef struct tag_TspMspMessage
{
	TspMspMessageType MessageType;
	DWORD dwMessageSize;            // total size of the block, including this 
	                                // structure
	union
	{
		TSPMSP_InitiateCallMessage          InitiateCallMessage;
		TSPMSP_PrepareToAnswerMessage       PrepareToAnswerMessage;		
		TSPMSP_ProceedWithAnswerMessage     ProceedWithAnswerMessage;
		TSPMSP_ReadyToInitiateMessage       ReadyToInitiateMessage;
		TSPMSP_ReadyToAnswerMessage         ReadyToAnswerMessage;
        TSPMSP_FastConnectResponseMessage   FastConnectResponseMessage;
		TSPMSP_StartH245Message             StartH245Message;
		TSPMSP_H245PDUMessage               H245PDUMessage;
		TSPMSP_MCLocationIdentifyMessage    MCLocationIdentifyMessage;
		TSPMSP_HoldMessage                  HoldMessage;
		TSPMSP_H245HoldMessage              H245HoldMessage;
		TSPMSP_ConferenceListMessage        ConferenceListMessage;
		TSPMSP_SendDTMFDigitsMessage        SendDTMFDigitsMessage;
		TSPMSP_LegacyDefaultAliasMessage    LegacyDefaultAliasMessage;
		TSPMSP_RegistrationRequestMessage   RegistrationRequestMessage;
		TSPMSP_RASEventMessage              RASEventMessage; 
		TSPMSP_LocationRequestMessage       LocationRequestMessage;
		TSPMSP_LocationConfirmMessage       LocationConfirmMessage;
		TSPMSP_BandwidthRequestMessage      BandwidthRequestMessage;
		TSPMSP_BandwidthConfirmMessage      BandwidthConfirmMessage;
		
	}MsgBody;
	
	DWORD 	dwEncodedASNSize;
	union
	{
        BYTE	EncodedASN[1];	
        WORD    WideChars[1];
	}u;
	#define pEncodedASNBuf u.EncodedASN
	#define pWideChars u.WideChars
}TspMspMessage, *PTspMspMessage;

// The true total size of the message is: 
//  sizeof(TspMspMessage) + (the size of variable parts, e.g. #of encoded ASN.1 bytes)
//  - 1 byte.  

 #endif //__TSPMSPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\call.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    call.h

Abstract:

    Definitions for H.323 TAPI Service Provider call objects.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _INC_CALL
#define _INC_CALL
 

//                                                                           
// Header files                                                              
//                                                                           

#include "q931pdu.h"
#include "q931obj.h"


#define H323_CALL_FEATURES  (LINECALLFEATURE_DROP               | \
                            LINECALLFEATURE_SETUPTRANSFER       | \
                            LINECALLFEATURE_COMPLETETRANSF      | \
                            LINECALLFEATURE_DIAL                | \
                            LINECALLFEATURE_HOLD                | \
                            LINECALLFEATURE_ANSWER              | \
                            LINECALLFEATURE_REDIRECT            | \
                            LINECALLFEATURE_RELEASEUSERUSERINFO | \
                            LINECALLFEATURE_SENDUSERUSER        | \
                            LINECALLFEATURE_UNHOLD              | \
                            LINECALLFEATURE_GENERATEDIGITS      | \
                            LINECALLFEATURE_MONITORDIGITS)


#define IsValidDTMFDigit(wDigit)   (                                            \
                                    ((wDigit >= L'0') && (wDigit <= L'9')) ||   \
                                    ((wDigit >= L'A') && (wDigit <= L'D')) ||   \
                                    (wDigit == L'*') ||                         \
                                    (wDigit == L'#') ||                         \
                                    (wDigit == L'!') ||                         \
                                    (wDigit == L',')                            \
                                   )


//                                                                           
// Type definitions                                                          
//                                                                           
struct  EXPIRE_CONTEXT;

#define CHECKRESTRICTION_EXPIRE_TIME    15000
#define CALLREROUTING_EXPIRE_TIME       10000
#define CTIDENTIFY_SENT_TIMEOUT         30000
#define CTIDENTIFYRR_SENT_TIMEOUT       45000
#define CTINITIATE_SENT_TIMEOUT         60000


enum U2U_DIRECTION
{
    U2U_OUTBOUND                    = 0x00000001,
    U2U_INBOUND                     = 0x00000002,

};


enum CALLOBJECT_STATE
{
    CALLOBJECT_INITIALIZED          = 0x00000001,
    CALLOBJECT_SHUTDOWN             = 0x00000002,
    H245_START_MSG_SENT             = 0x00000004,
    TSPI_CALL_LOCAL_HOLD            = 0x00000008,

};


enum FAST_START_STATE
{

    FAST_START_UNDECIDED            = 0x00000001,
    FAST_START_NOTAVAIL             = 0x00000002,
    FAST_START_AVAIL                = 0x00000004,
    FAST_START_SELF_AVAIL           = 0x00000008,
    FAST_START_PEER_AVAIL           = 0x000000010,

};


enum RASCALL_STATE
{

    RASCALL_STATE_IDLE              = 0x00000001,
    RASCALL_STATE_ARQSENT           = 0x00000002,
    RASCALL_STATE_ARQEXPIRED        = 0x00000004,
    RASCALL_STATE_DRQSENT           = 0x00000008,
    RASCALL_STATE_DRQEXPIRED        = 0x000000010,
    RASCALL_STATE_REGISTERED        = 0x000000020,
    RASCALL_STATE_UNREGISTERED      = 0x000000040,
    RASCALL_STATE_ARJRECVD          = 0x000000080,

};


enum H323_CALLTYPE
{
    CALLTYPE_NORMAL                 = 0x00000000,

    CALLTYPE_FORWARDCONSULT         = 0x00000001,
    CALLTYPE_DIVERTEDDEST           = 0x00000002,
    CALLTYPE_DIVERTEDSRC            = 0x00000004,    
    CALLTYPE_DIVERTEDSRC_NOROUTING  = 0x00000008,
    CALLTYPE_DIVERTED_SERVED        = 0x00000010,

    CALLTYPE_TRANSFEREDSRC          = 0x00000020,
    CALLTYPE_TRANSFERING_PRIMARY    = 0x00000040,
    CALLTYPE_TRANSFERING_CONSULT    = 0x00000080,
    CALLTYPE_TRANSFEREDDEST         = 0x00000100,
    CALLTYPE_TRANSFERED_PRIMARY     = 0x00000200,
    CALLTYPE_TRANSFERED2_CONSULT    = 0x00000400,
    CALLTYPE_DIVERTEDTRANSFERED     = 0x00000800,

};


enum SUPP_CALLSTATE
{
    H4503_CALLSTATE_IDLE            = 0x00000000,
    H4503_CHECKRESTRICTION_SENT     = 0x00000001,
    H4503_DIVERSIONLEG1_SENT        = 0x00000002,
    H4503_DIVERSIONLEG2_SENT        = 0x00000004,
    H4503_DIVERSIONLEG3_SENT        = 0x00000008,
    H4503_DIVERSIONLEG1_RECVD       = 0x00000010,
    H4503_DIVERSIONLEG2_RECVD       = 0x00000020,
    H4503_DIVERSIONLEG3_RECVD       = 0x00000040,
    H4503_CALLREROUTING_SENT        = 0x00000080,
    H4503_CALLREROUTING_RECVD       = 0x00000100,
    H4503_CHECKRESTRICTION_RECV     = 0x00000200,
    H4503_CHECKRESTRICTION_SUCC     = 0x00000400,
    H4503_CALLREROUTING_RRSUCC      = 0x00000800,
    H4502_CTINITIATE_SENT           = 0x00001000,
    H4502_CTINITIATE_RECV           = 0x00002000,
    H4502_CTSETUP_SENT              = 0x00004000,
    H4502_CTSETUP_RECV              = 0x00008000,
    H4502_CTIDENTIFY_SENT           = 0x00010000,
    H4502_CTIDENTIFY_RECV           = 0x00020000,
    H4502_CIIDENTIFY_RRSUCC         = 0x00040000,
    H4502_CONSULTCALL_INITIATED     = 0x00080000,

};


// CH323Call::m_dwQ931Flags
enum Q931_STATE
{
    Q931_CALL_CONNECTING        = 0x00010000,   //connect has been issued on the socket
    Q931_CALL_CONNECTED         = 0x00100000,   //FD_CONNECT received
    Q931_CALL_DISCONNECTED      = 0x01000000,   //FD_CLOSE received from peer

};


enum TunnelingCap
{
    REMOTE_H245_TUNNELING   =0x01,
    LOCAL_H245_TUNNELING    =0x10,
};


// CH323Call::m_dwStateMachine
//Q931 state machine
enum Q931_CALL_STATE
{
    Q931_CALL_STATE_NONE = 0,

    //outbound
    Q931_ORIGINATE_ADMISSION_PENDING,
    Q931_SETUP_SENT,
    Q931_ALERT_RECVD,
    Q931_PROCEED_RECVD,
    Q931_CONNECT_RECVD,
    Q931_RELEASE_RECVD,

    //inbound
    Q931_ANSWER_ADMISSION_PENDING,
    Q931_SETUP_RECVD,
    Q931_ALERT_SENT,
    Q931_PROCEED_SENT,
    Q931_CONNECT_SENT,
    Q931_RELEASE_SENT

};


typedef struct _TAPI_CALLREQUEST_DATA
{
    DWORD EventID;
    PH323_CALL pCall;
    union
    {
        PVOID           pCallforwardParams;
        PBUFFERDESCR    pBuf;
    };

}TAPI_CALLREQUEST_DATA;


typedef struct _SUPP_REQUEST_DATA
{
    DWORD EventID;
    HDRVCALL hdCall;
    union{
    PH323_ALIASNAMES pAliasNames;
    HDRVCALL hdReplacementCall;
    CTIdentifyRes* pCTIdentifyRes;
    ULONG_PTR dwParam1;
    };

} SUPP_REQUEST_DATA;


typedef struct _MSPMessageData
{
    HDRVCALL            hdCall;
    TspMspMessageType   messageType;
    BYTE*               pbEncodedBuf;
    WORD                wLength;
    HDRVCALL            hReplacementCall;

}MSPMessageData;


enum
{
    TSPI_NO_EVENT = 0,

    TSPI_MAKE_CALL,
    TSPI_ANSWER_CALL,
    TSPI_DROP_CALL,
    TSPI_CLOSE_CALL,
    TSPI_RELEASE_U2U,
    TSPI_SEND_U2U,
    TSPI_COMPLETE_TRANSFER,
    TSPI_LINEFORWARD_SPECIFIC,
    TSPI_LINEFORWARD_NOSPECIFIC,
    TSPI_DIAL_TRNASFEREDCALL,
    TSPI_CALL_UNHOLD,
    TSPI_CALL_HOLD,

    TSPI_DELETE_CALL,
    
    TSPI_CALL_DIVERT,
    H450_PLACE_DIVERTEDCALL,
    SWAP_REPLACEMENT_CALL,
    DROP_PRIMARY_CALL,
    STOP_CTIDENTIFYRR_TIMER,
    SEND_CTINITIATE_MESSAGE,

};


BOOL
AddAliasItem( PH323_ALIASNAMES pAliasNames, BYTE* pbAliasName,
    DWORD dwAliasSize, WORD wType );

static __inline BOOL AddAliasItem (
    IN  H323_ALIASNAMES *       AliasNames,
    IN  LPWSTR                  AliasValue,
    IN  WORD                    Type)
{
    return AddAliasItem(
        AliasNames, 
        (LPBYTE) AliasValue, 
        (wcslen (AliasValue) + 1) * sizeof (TCHAR), 
        Type );
}


typedef struct _UserToUserLE
{
    LIST_ENTRY Link;
    DWORD dwU2USize;
    PBYTE pU2U;

} UserToUserLE, *PUserToUserLE;


typedef enum _FORWARDING_TYPE
{
    CALLFORWARD_UNCOND = 1,
    CALLFORWARD_BUSY,
    CALLFORWARD_NA
} FORWARDING_TYPE;



typedef struct _ForwardAddress
{
    DWORD           dwForwardType;
    H323_ALIASITEM  callerAlias;
    SOCKADDR_IN     saCallerAddr;    
    H323_ALIASITEM  divertedToAlias;
    //SOCKADDR_IN     saDivertedToAddr;
    struct _ForwardAddress* next;

} FORWARDADDRESS, *LPFORWARDADDRESS;


typedef struct _CallForwardParams
{
    BOOLEAN         fForwardingEnabled;
    //specifeis if forwarding is enabled for all calls irrespective of their origin
    BOOLEAN         fForwardForAllOrigins;
    DWORD           dwForwardTypeForAllOrigins;
    //address to which all the calls are diverted
    H323_ALIASITEM  divertedToAlias;
    //SOCKADDR_IN     saDivertedToAddr;

    //this filed is NULL if fForwardForAllOrigins is TRUE
    //list of addresses forwarded selectively
    LPFORWARDADDRESS  pForwardedAddresses;

}CALLFORWARDPARAMS, *PCALLFORWARDPARAMS;


struct  CALLREROUTINGINFO
{
    int                 diversionCounter;
    DiversionReason     diversionReason;
    DiversionReason     originalDiversionReason;

    PH323_ALIASNAMES    divertingNrAlias;
    PH323_ALIASNAMES    originalCalledNr;
    PH323_ALIASNAMES    divertedToNrAlias;
    PH323_ALIASNAMES    diversionNrAlias;
    
    BOOLEAN             fPresentAllow;

};


typedef struct tag_TspMspMessageWithEncodedBuf
{
    TspMspMessage   message;
    BYTE            pEncodedASN[4095];
} TspMspMessageEx;


static __inline int MakeCallIndex (
    IN  HDRVCALL    DriverHandleCall)
{
    return (int) LOWORD (HandleToUlong (DriverHandleCall));
}





//                                                                           
// Call capabilites                                                          
//                                                                           


#define H323_CALL_INBOUNDSTATES        (LINECALLSTATE_ACCEPTED      | \
                                        LINECALLSTATE_CONNECTED     | \
                                        LINECALLSTATE_DISCONNECTED  | \
                                        LINECALLSTATE_IDLE          | \
                                        LINECALLSTATE_OFFERING      | \
                                        LINECALLSTATE_RINGBACK      | \
                                        LINECALLSTATE_ONHOLD )

#define H323_CALL_OUTBOUNDSTATES       (LINECALLSTATE_CONNECTED     | \
                                        LINECALLSTATE_DIALING       | \
                                        LINECALLSTATE_DISCONNECTED  | \
                                        LINECALLSTATE_IDLE          | \
                                        LINECALLSTATE_RINGBACK      | \
                                        LINECALLSTATE_ONHOLD )

//
// CH323Call class.
//

class CH323Call
{

private:

    HDRVCALL                m_hdCall;           // tspi call handle
    DWORD                   m_dwFlags;
    CRITICAL_SECTION        m_CriticalSection;
    H323_CONFERENCE*        m_hdConf;           // conf handle

    DWORD                   m_dwCallState;      // tspi call state
    DWORD                   m_dwCallStateMode;  // tspi call state mode

    DWORD                   m_dwOrigin;         // inbound or outbound
    H323_OCTETSTRING        m_CallData;         // call data stored by the app for this call.
    DWORD                   m_dwAddressType;    // type of dst address
    DWORD                   m_dwAppSpecific;
    DWORD                   m_dwIncomingModes;  // available media modes
    DWORD                   m_dwOutgoingModes;  // available media modes
    DWORD                   m_dwRequestedModes; // requested media modes
    HDRVMSPLINE             m_hdMSPLine;
    HTAPIMSPLINE            m_htMSPLine;

    LIST_ENTRY              m_IncomingU2U;      // incoming user user messages
    LIST_ENTRY              m_OutgoingU2U;      // outgoing user user messages
    GUID                    m_callIdentifier;

    H323_ADDR               m_CalleeAddr;        // src address
    H323_ADDR               m_CallerAddr;        // dst address
    SOCKADDR_IN             m_LocalAddr;         // THIS END of the Q.931 connection
    PH323_ALIASNAMES        m_pCalleeAliasNames; // src alias
    PH323_ALIASNAMES        m_pCallerAliasNames; // dst alias
    H323NonStandardData     m_NonStandardData;
    GUID                    m_ConferenceID;
    PWSTR                   m_pwszDisplay;
    BOOLEAN                 m_fReadyToAnswer;
    BOOLEAN                 m_fCallAccepted;

    //peer information
    H323_ADDR               m_peerH245Addr;
    H323_ADDR               m_selfH245Addr;
    PWSTR                   m_pPeerDisplay;
    H323NonStandardData     m_peerNonStandardData;
    PH323_ALIASNAMES        m_pPeerExtraAliasNames;
    H323_VENDORINFO         m_peerVendorInfo;
    H323_ENDPOINTTYPE       m_peerEndPointType;
    PH323_FASTSTART         m_pFastStart;
    PH323_FASTSTART         m_pPeerFastStart;
    FAST_START_STATE        m_dwFastStart;

    //CQ931Call data objects
    HANDLE                  m_hTransport;//event signalled by winsock for
                            //CONNECT| CLOSE event for incoming connections and
                            //CLOSE event for outgoing connections
    SOCKET                  m_callSocket;
    HANDLE                  m_hTransportWait;//the event to unregister from thread pool
    BOOLEAN                 m_bStartOfPDU;
    HANDLE                  m_hSetupSentTimer;
    Q931_CALL_STATE         m_dwStateMachine;
    DWORD                   m_dwQ931Flags;
    BOOLEAN                 m_fActiveMC;
    ASN1_CODER_INFO         m_ASNCoderInfo;
    WORD                    m_wCallReference;
    WORD                    m_wQ931CallRef;
    LIST_ENTRY              m_sendBufList;
    DWORD                   m_IoRefCount;
    HANDLE                  m_hCallEstablishmentTimer;
    BOOLEAN                 m_fh245Tunneling;

    //RAS call data 
    RASCALL_STATE           m_dwRASCallState;
    WORD                    m_wARQSeqNum;
    WORD                    m_wDRQSeqNum;
    HANDLE                  m_hARQTimer;
    HANDLE                  m_hDRQTimer;
    DWORD                   m_dwDRQRetryCount;
    DWORD                   m_dwARQRetryCount;    
    BUFFERDESCR             m_prepareToAnswerMsgData;
    EXPIRE_CONTEXT*         m_pARQExpireContext;
    EXPIRE_CONTEXT*         m_pDRQExpireContext;

    //data related to supplementary services
    DWORD                   m_dwCallType;
    SUPP_CALLSTATE          m_dwCallDiversionState;
    ASN1_CODER_INFO         m_H450ASNCoderInfo;
    DWORD                   m_dwInvokeID;
    BOOLEAN                 m_fCallInTrnasition;

    //data related to call forwarding
    CALLREROUTINGINFO*      m_pCallReroutingInfo;
    HANDLE                  m_hCheckRestrictionTimer;
    HANDLE                  m_hCallReroutingTimer;
    HANDLE                  m_hCallDivertOnNATimer;

    //forwardconsult params
    CALLFORWARDPARAMS*      m_pCallForwardParams;
    LPFORWARDADDRESS        m_pForwardAddress;

    //data related to call transfer
    HANDLE                  m_hCTIdentifyTimer;
    HANDLE                  m_hCTIdentifyRRTimer;
    HANDLE                  m_hCTInitiateTimer;
    BYTE                    m_pCTCallIdentity[5];
    PH323_ALIASNAMES        m_pTransferedToAlias;
    HDRVCALL                m_hdRelatedCall;

    //data related to call Hold/Unhold
    BOOLEAN                 m_fRemoteHoldInitiated;
    BOOLEAN                 m_fRemoteRetrieveInitiated;



    //Call Object functionality
    BOOL SendProceeding(void);
    void CopyU2UAsNonStandard( DWORD dwDirection );
    BOOL AddU2UNoAlloc( IN DWORD dwDirection, IN DWORD dwDataSize,
        IN PBYTE pData );
    BOOL RemoveU2U( DWORD dwDirection, PUserToUserLE * ppU2ULE );
    BOOL FreeU2U( DWORD dwDirection );
    BOOL ResolveCallerAddress();
    BOOL ResolveE164Address( LPCWSTR pwszDialableAddr );
    BOOL ResolveIPAddress( LPSTR pszDialableAddr );
    BOOL ResolveEmailAddress( LPCWSTR pwszDialableAddr,
        PSTR pszUser, LPSTR pszDomain);
    BOOL PlaceCall();
    BOOL HandleConnectMessage( Q931_CONNECT_ASN *pConnectASN );
    void HandleAlertingMessage( Q931_ALERTING_ASN * pAlertingASN );
    void HandleProceedingMessage( Q931_ALERTING_ASN * pProceedingAS );
    BOOL HandleReleaseMessage( Q931_RELEASE_COMPLETE_ASN *pReleaseASN );
    BOOL InitializeIncomingCall( IN Q931_SETUP_ASN* pSetupASN,
        IN DWORD dwCallType, IN WORD wCallRef );
    BOOL SetupCall();
    void SetNonStandardData( H323_UserInformation & UserInfo );
    BOOL SendQ931Message( DWORD dwInvokeID, ULONG_PTR dwParam1,
        ULONG_PTR dwParam2, DWORD dwMessageType, DWORD APDUType );
    BOOL OnReceiveAlerting( Q931MESSAGE* pMessage );
    BOOL OnReceiveProceeding( Q931MESSAGE* pMessage );
    BOOL OnReceiveFacility( Q931MESSAGE* pMessage );
    BOOL OnReceiveRelease( Q931MESSAGE* pMessage );
    BOOL OnReceiveConnect( Q931MESSAGE* pMessage );
    BOOL OnReceiveSetup( Q931MESSAGE* pMessage );
    BOOL EncodeConnectMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf,
        WORD *pdwEncodedLength, DWORD dwAPDUType );
    BOOL EncodeReleaseCompleteMessage( DWORD dwInvokeID, BYTE *pbReason,
        BYTE **ppEncodedBuf, WORD *pdwEncodedLength, DWORD dwAPDUType );
    BOOL EncodeProceedingMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf,
        WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeAlertMessage( DWORD dwInvokeID, BYTE **ppEncodedBuf, 
        WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeFacilityMessage( IN DWORD dwInvokeID, IN BYTE  bReason,
        IN ASN1octetstring_t* pH245PDU, OUT BYTE **ppEncodedBuf,
        OUT WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeSetupMessage( DWORD dwInvokeID, WORD wGoal, WORD wCallType,
        BYTE **ppEncodedBuf, WORD *pdwEncodedLength, IN DWORD dwAPDUType );
    BOOL EncodeMessage( PQ931MESSAGE pMessage, BYTE **pbCodedBuffer,
        DWORD *pdwCodedBufferLength, DWORD dwMessageLength);
    void WriteQ931Fields( PBUFFERDESCR pBuf, PQ931MESSAGE pMessage, 
        DWORD * pdwPDULength );
    BOOL EncodeH450APDU( DWORD dwInvokeID, IN DWORD dwAPDUType,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    void RecvBuffer( BOOL *fDelete );
    void ReadEvent( DWORD cbTransfer );
    BOOL ProcessQ931PDU( CALL_RECV_CONTEXT* pRecvBuf );
    void OnConnectComplete();
    BOOL SendBuffer( BYTE* pbBuffer, DWORD dwLength );
    BOOL AcceptH323Call();
    BOOL GetPeerAddress( H323_ADDR *pAddr);
    BOOL GetHostAddress( H323_ADDR *pAddr );
    BOOL EncodePDU( BINARY_STRING *pUserUserData, BYTE ** ppbCodedBuffer,
        DWORD * pdwCodedBufferLength, DWORD dwMessageType, 
        WCHAR* pszCalledPartyNumber );
    int EncodeASN( void *pStruct, int nPDU, 
        BYTE **ppEncoded, WORD *pcbEncodedSize );
    int EncodeH450ASN( void *pStruct, int nPDU, 
        BYTE **ppEncoded, WORD *pcbEncodedSize );
    BOOL ParseSetupASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_SETUP_ASN *pSetupASN,
        OUT DWORD* pdwH450APDUType );
    BOOL ParseReleaseCompleteASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_RELEASE_COMPLETE_ASN *pReleaseASN,
        DWORD* pdwH450APDUType );
    BOOL ParseConnectASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_CONNECT_ASN *pConnectASN,
        DWORD* pdwH450APDUType );
    BOOL ParseAlertingASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_ALERTING_ASN *pAlertingASN,
        DWORD* pdwH450APDUType );
    BOOL ParseProceedingASN( BYTE *pEncodedBuf, DWORD dwEncodedLength,
        Q931_CALL_PROCEEDING_ASN *pProceedingASN,
        DWORD* pdwH450APDUType );
    BOOL ParseFacilityASN( IN BYTE * pEncodedBuf, IN DWORD dwEncodedLength,
        OUT Q931_FACILITY_ASN * pFacilityASN );
    int DecodeASN( void **ppStruct, int nPDU, 
        BYTE *pEncoded, DWORD cbEncodedSize );
    int InitASNCoder(); 
    int TermASNCoder();
    int InitH450ASNCoder(); 
    int TermH450ASNCoder();
    BOOL SendSetupMessage();
    HRESULT Q931ParseMessage( BYTE *CodedBufferPtr, DWORD CodedBufferLength,
        PQ931MESSAGE Message );
    BOOL HandleSetupMessage( IN Q931MESSAGE* pMessage );


    //GK RAS functions
    BOOL SendDCF( WORD seqNumber );
    BOOL SendARQ( long seqNumber );
    BOOL SendDRQ( IN USHORT usDisengageReason, long seqNumber, 
        BOOL fResendOnExpire );

    
    //supplementary services functions
    void FreeCallForwardData();
    void HandleFacilityMessage( IN DWORD dwInvokeID,
        IN Q931_FACILITY_ASN * pFacilityASN );
    void FreeCallReroutingInfo(void);
    BOOL InitiateCallDiversion( IN PH323_ALIASITEM pwszDivertedToAlias,
        IN DiversionReason  eDiversionMode );
    BOOL EncodeDivertingLeg3APDU(
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCallReroutingAPDU( 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeDivertingLeg2APDU(
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCheckRestrictionAPDU( 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeDummyReturnResultAPDU( IN DWORD dwInvokeID, IN DWORD dwOpCode,
        IN H4501SupplementaryService *pH450APDU, OUT BYTE**  ppEncodedAPDU,
        OUT DWORD* pdwAPDULen );
    BOOL EncodeReturnErrorAPDU( IN DWORD dwInvokeID,
        IN DWORD dwErrorCode,IN H4501SupplementaryService *pH450APDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeRejectAPDU( IN H4501SupplementaryService* SupplementaryServiceAPDU,
        IN DWORD dwInvokeID, OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL HandleCallRerouting( IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo3( 
        IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo2(IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleDiversionLegInfo1(IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen );
    BOOL HandleCheckRestriction( IN BYTE * pEncodeArg,IN DWORD dwEncodedArgLen,
        IN Q931_SETUP_ASN* pSetupASN );
    BOOL HandleReturnResultDummyType( 
        H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleReject( IN H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleReturnError( IN H4501SupplementaryService * pH450APDUStruct );
    BOOL HandleH450APDU( IN PH323_UU_PDU_h4501SupplementaryService pH450APDU,
        IN DWORD* pdwH450APDUType, DWORD* pdwInvokeID, 
        IN Q931_SETUP_ASN* pSetupASN );
    int DecodeH450ASN( OUT void ** ppStruct, IN int nPDU, 
        IN BYTE * pEncoded, IN DWORD cbEncodedSize );
    BOOL ResolveToIPAddress( IN WCHAR* pwszAddr, IN SOCKADDR_IN* psaAddr );
    void DropSupplementaryServicesCalls();
    BOOL IsValidInvokeID( DWORD dwInvokeId );
    void OnCallReroutingReceive( IN DWORD dwInvokeID );
    BOOL StartTimerForCallDiversionOnNA( IN PH323_ALIASITEM pwszDivertedToAlias );
    BOOL HandleCTIdentifyReturnResult( IN BYTE * pEncodeArg, 
        IN DWORD dwEncodedArgLen );
    BOOL HandleCTInitiate( IN BYTE * pEncodeArg, IN DWORD dwEncodedArgLen );
    BOOL HandleCTSetup( IN BYTE * pEncodeArg, IN DWORD dwEncodedArgLen );
    BOOL EncodeH450APDUNoArgument( IN  DWORD   dwOpcode, 
        OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD*  pdwAPDULen );
    BOOL EncodeCTInitiateAPDU( OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCTSetupAPDU( OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
        OUT BYTE**  ppEncodedAPDU, OUT DWORD* pdwAPDULen );
    BOOL EncodeCTIdentifyReturnResult( ServiceApdus_rosApdus *pROSAPDU );
    BOOL HandleCTIdentify( IN DWORD dwInvokeID );
    BOOL EncodeFastStartProposal( PH323_FASTSTART pFastStart,
        BYTE** ppEncodedBuf, WORD* pwEncodedLength );
    BOOL EnableCallForwarding();
    BOOL EncodeDummyResult( OUT ServiceApdus_rosApdus *pROSAPDU );
    void FreeCallReroutingArg( CallReroutingArgument* pCallReroutingArg );
    BOOL HandleCallDiversionFacility( PH323_ADDR pAlternateAddress );
    BOOL HandleCallDiversionFacility( PH323_ALIASNAMES pAliasList );
    BOOL HandleTransferFacility( PH323_ADDR pAlternateAddress );
    BOOL HandleTransferFacility( PH323_ALIASNAMES pAliasList );


public:

    BOOLEAN                 m_fMonitoringDigits;   // listening for dtmf flag    
    HTAPICALL               m_htCall;              // tapi call handle
    CALL_RECV_CONTEXT       m_RecvBuf;

    BOOL IsEqualConferenceID( 
                        GUID* pConferenceID 
                        )
    {
        return IsEqualGUID (m_ConferenceID, *pConferenceID);
    }

    INT GetCallIndex (void) const { return MakeCallIndex (m_hdCall); }

    void SetAppSpecific( 
            DWORD dwAppSpecific
            )
    {
        m_dwAppSpecific = dwAppSpecific;
        PostLineEvent( LINE_CALLINFO, LINECALLINFOSTATE_APPSPECIFIC, 0, 0 );
    }

    BOOL SetCallData( LPVOID lpCallData, DWORD dwSize );

    void SetCallDiversionState(     
        IN  SUPP_CALLSTATE dwCallDiversionState
        )
    {
        m_dwCallDiversionState = dwCallDiversionState;
    }

    SUPP_CALLSTATE GetCallDiversionState(void)
    {
        return m_dwCallDiversionState;
    }

    void SetAddressType( DWORD dwAddressType )
    {
        m_dwAddressType = dwAddressType;
    }
    
    inline BOOL IsCallOnHold()
    {
        return ( m_dwCallState == LINECALLSTATE_ONHOLD );
    }

    inline BOOL IsCallOnLocalHold()
    {
        return ((m_dwCallState == LINECALLSTATE_ONHOLD) && 
                (m_dwFlags & TSPI_CALL_LOCAL_HOLD) );
    }

    void SetCallState( DWORD dwCallState )
    {
        m_dwCallState = dwCallState;
    }

    void Lock()
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p waiting on lock.", this ));
        EnterCriticalSection( &m_CriticalSection );
                
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p locked.", this ));
    }

    PWSTR GetDialableAddress()
    {
        _ASSERTE( m_dwOrigin == LINECALLORIGIN_OUTBOUND );
        _ASSERTE( m_pCalleeAliasNames );
        return m_pCalleeAliasNames->pItems[0].pData;
    }

    PH323_ADDR GetPeerH245Addr()
    {
        return &m_peerH245Addr;
    }

    PH323_FASTSTART GetPeerFastStart()
    {
        return m_pPeerFastStart;
    }

    WCHAR* GetTransferedToAddress()
    {
        return m_pTransferedToAlias->pItems[0].pData;
    }
    void Unlock()
    {
        LeaveCriticalSection(&m_CriticalSection );
                
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 call:%p unlocked.", this ));
    }
    
    //!!must be always called in a lock
    BOOL IsCallShutdown()
    {
        return (m_dwFlags & CALLOBJECT_SHUTDOWN);
    }

    HDRVCALL GetCallHandle()
    {
        return m_hdCall;
    }

    WORD GetARQSeqNumber()
    {
        return m_wARQSeqNum;
    }

    WORD GetDRQSeqNumber()
    {
        return m_wDRQSeqNum;
    }

    WORD GetCallRef()
    {
        return m_wCallReference;
    }

    DWORD GetCallState()
    {
        return m_dwCallState;
    }

    DWORD GetStateMachine()
    {
        return m_dwStateMachine;
    }

    //!!must be always called in a lock
    void SetCallType( DWORD dwCallType )
    {
        m_dwCallType |= dwCallType;
    }

    //!!must be always called in a lock
    BOOL SetCalleeAlias(
                        IN WCHAR* pwszDialableAddr,
                        IN WORD wType
                       )
    {
        return AddAliasItem( m_pCalleeAliasNames, pwszDialableAddr, wType );
    }

    BOOL SetCallerAlias(
                        IN WCHAR* pwszDialableAddr,
                        IN WORD wType
                       )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        BOOL    retVal = AddAliasItem( m_pCallerAliasNames, pwszDialableAddr, wType );

        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        return retVal;
    }

    void InitializeRecvBuf();
    CH323Call();
    ~CH323Call();

    BOOL HandleProceedWithAnswer( IN PTspMspMessage  pMessage );
    void CompleteTransfer( PH323_CALL pConsultCall );
    BOOL AddU2U( DWORD dwDirection, DWORD dwDataSize, PBYTE pData );
    LONG SetDivertedToAlias( WCHAR* pwszDivertedToAddr, WORD wAliasType );
    BOOL ResolveAddress( LPCWSTR    pwszDialableAddr );
    PH323_CONFERENCE CreateConference( GUID* pConferenceId );
    BOOL DropCall( DWORD dwDisconnectMode );
    LONG CopyCallInfo( LPLINECALLINFO  pCallInfo );
    void CopyCallStatus( LPLINECALLSTATUS pCallStatus );
    BOOL ChangeCallState( DWORD dwCallState, DWORD dwCallStateMode );
    void AcceptCall();
    BOOL HandleMSPMessage( PTspMspMessage  pMessage, HDRVMSPLINE hdMSPLine, 
        HTAPIMSPLINE htMSPLine );
    void SendMSPMessage( IN TspMspMessageType messageType, IN BYTE* pbEncodedBuf,
        IN DWORD dwLength, IN HDRVCALL hReplacementCall );
    void SendMSPStartH245( PH323_ADDR pPeerH245Addr, 
        PH323_FASTSTART pPeerFastStart );
    BOOL HandleReadyToInitiate( PTspMspMessage  pMessage );
    void WriteComplete( BOOL* fDelete );
    BOOL HandleReadyToAnswer( PTspMspMessage  pMessage );
    void ReleaseU2U();
    void SendU2U( BYTE*  pUserUserInfo, DWORD  dwSize );
    void OnRequestInProgress( IN RequestInProgress* RIP );
    BOOL QueueTAPICallRequest( IN DWORD EventID, IN PVOID pBuf );
    void SetNewCallInfo( HANDLE hConnWait, HANDLE hWSAEvent, DWORD dwState );
    void SetQ931CallState( DWORD dwState );
    BOOL InitializeQ931( SOCKET callSocket );
    void HandleTransportEvent();
    void SetupSentTimerExpired();
    BOOL PostReadBuffer();
    void CloseCall( IN DWORD dwDisconnectMOde );
    BOOL ValidateCallParams( LPLINECALLPARAMS pCallParams,
        LPCWSTR pwszDialableAddr, PDWORD pdwStatus );
    BOOL Initialize( HTAPICALL htCall, DWORD dwOrigin, DWORD dwCallType );
    void Shutdown( BOOL* fDelete );
    
    static void NTAPI SetupSentTimerCallback( PVOID dwParam1, BOOLEAN bTimer );

    //GK RAS functions
    void OnDisengageReject(IN DisengageReject* DRJ);
    void OnDisengageConfirm(IN DisengageConfirm* DCF);
    void OnAdmissionConfirm( IN AdmissionConfirm * ACF );
    void OnAdmissionReject( IN AdmissionReject *ARJ );
    static void NTAPI DRQExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI ARQExpiredCallback( PVOID dwParam1, BOOLEAN bTimer );
    static void NTAPI CallEstablishmentExpiredCallback( PVOID dwParam1, 
        BOOLEAN bTimer );
    void ARQExpired( WORD seqNumber );
    void DRQExpired( WORD seqNumber );
    void OnDisengageRequest( DisengageRequest * DRQ );
   

    //supplementary services functions
    void Forward( DWORD event, PVOID dwParam1 );
    LONG ValidateForwardParams( IN  LPLINEFORWARDLIST lpLineForwardList,
         OUT PVOID* ppForwardParams, OUT DWORD* pEvent );

    static void NTAPI CheckRestrictionTimerCallback( IN PVOID dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CallReroutingTimerCallback( IN PVOID dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CTIdentifyExpiredCallback( IN PVOID   dwParam1,
        IN BOOLEAN bTimer );
    static void NTAPI CTInitiateExpiredCallback( IN PVOID   dwParam1,
        IN BOOLEAN bTimer );
    
    void SetDivertedCallInfo( 
        HDRVCALL            hdCall,
        CALLREROUTINGINFO*  pCallReroutingInfo,
        SUPP_CALLSTATE      dwCallDiversionState,
        HDRVMSPLINE         hdMSPLine,
        PH323_ALIASNAMES    pCallerAliasNames,
        HTAPIMSPLINE        htMSPLine,
        PH323_FASTSTART     pFastStart,
        HDRVCALL            hdRelatedCall,
        DWORD               dwCallType,
        DWORD               dwAppSpecific,
        PH323_OCTETSTRING   pCallData
    );


    PH323_CALL CreateNewDivertedCall( IN PH323_ALIASNAMES pwszCalleeAddr );
    void TransferInfoToDivertedCall( IN PH323_CALL pDivertedCall );
    BOOL TransferInfoToTransferedCall( IN PH323_CALL pTransferedCall );
    BOOL SetTransferedCallInfo( HDRVCALL hdCall, 
        PH323_ALIASNAMES pCallerAliasNames, BYTE * pCTCallIdentity );
    void TransferInfoToReplacementCall( PH323_CALL pReplacementCall );
    void DialCall();
    void MakeCall();
    void DropUserInitiated( IN DWORD dwDisconnectMode );

    void CallDivertOnNoAnswer();
    static void NTAPI CallDivertOnNACallback( IN PVOID   dwParam1, 
        IN BOOLEAN bTimer );

    void SetReplacementCallInfo(
        HDRVCALL hdCall,
        HDRVMSPLINE hdMSPLine,
        HTAPICALL htCall,
        HTAPIMSPLINE htMSPLine,
        DWORD dwAppSpecific,
        PH323_OCTETSTRING pCallData
        );

    BOOL SendCTInitiateMessagee( IN CTIdentifyRes * pCTIdentifyRes );
    LONG InitiateBlindTransfer( IN LPCWSTR lpszDestAddress );
    void CTIdentifyExpired();
    void CTIdentifyRRExpired();
    static void NTAPI CTIdentifyRRExpiredCallback( IN PVOID   dwParam1, 
        IN BOOLEAN bTimer );
    void CTInitiateExpired();
    BOOL InitiateCallReplacement( PH323_FASTSTART pFastStart, 
        PH323_ADDR pH245Addr );
    void Hold();
    void UnHold();
    HRESULT GetCallInfo( OUT GUID* ReturnCallID, OUT GUID *ReturnConferenceID );

    void DecrementIoRefCount( BOOL * pfDelete );
    void StopCTIdentifyRRTimer( HDRVCALL hdRelatedCall );
    void PostLineEvent( IN DWORD MessageID, IN DWORD_PTR Parameter1,
        IN DWORD_PTR Parameter2, IN DWORD_PTR Parameter3 );

    void OnReadComplete( IN DWORD dwStatus, 
        IN CALL_RECV_CONTEXT *pRecvContext );
    void OnWriteComplete( IN DWORD dwStatus,
        IN CALL_SEND_CONTEXT * pSendContext );
    static void  NTAPI IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  OVERLAPPED *    pOverlapped
    );


};

class H323_CONFERENCE
{
private:
    ULONG_PTR   m_hdConference;    
    PH323_CALL m_pCall;

public:

    H323_CONFERENCE( PH323_CALL pCall )
    {
        m_hdConference = (ULONG_PTR) this;
        m_pCall = pCall;
    }
};



void FreeCallForwardParams( IN PCALLFORWARDPARAMS pCallForwardParams );
void FreeForwardAddress( IN LPFORWARDADDRESS pForwardAddress );

typedef TSPTable<PH323_CALL>   H323_CALL_TABLE;
typedef CTSPArray<H323_CONFERENCE*>   H323_CONF_TABLE;

#define IsTransferredCall( dwCallType )  ( (dwCallType & CALLTYPE_TRANSFEREDSRC) || (dwCallType & CALLTYPE_TRANSFERED_PRIMARY) )

//                                                                           
// TSPI procedures                                                           
//                                                                           


LONG
TSPIAPI
TSPI_lineAnswer(
    DRV_REQUESTID     dwRequestID,  
    HDRVCALL          hdCall,
    LPCSTR            pUserUserInfo,
    DWORD             dwSize
    );
LONG
TSPIAPI
TSPI_lineCloseCall(
    HDRVCALL hdCall
    );
LONG
TSPIAPI
TSPI_lineDrop(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    LPCSTR        pUserUserInfo,
    DWORD         dwSize
    );
LONG
TSPIAPI
TSPI_lineGetCallAddressID(
    HDRVCALL hdCall,
    LPDWORD  pdwAddressID
    );

LONG
TSPIAPI
TSPI_lineGetCallInfo(
    HDRVCALL        hdCall,
    LPLINECALLINFO  pCallInfo
    );

LONG
TSPIAPI
TSPI_lineGetCallStatus(
    HDRVCALL         hdCall,
    LPLINECALLSTATUS pCallStatus
    );

LONG
TSPIAPI
TSPI_lineMakeCall(
    DRV_REQUESTID       dwRequestID,
    HDRVLINE            hdLine,
    HTAPICALL           htCall,
    LPHDRVCALL          phdCall,
    LPCWSTR             pwszDialableAddr,
    DWORD               dwCountryCode,
    LPLINECALLPARAMS    const pCallParams
    );
LONG
TSPIAPI
TSPI_lineReleaseUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall
    );

LONG
TSPIAPI
TSPI_lineSendUserUserInfo(
    DRV_REQUESTID       dwRequestID,
    HDRVCALL            hdCall,
    LPCSTR              pUserUserInfo,
    DWORD               dwSize
    );
LONG
TSPIAPI
TSPI_lineMonitorDigits(
    HDRVCALL hdCall,
    DWORD    dwDigitModes
    );

LONG
TSPIAPI
TSPI_lineGenerateDigits(
    HDRVCALL hdCall,
    DWORD    dwEndToEndID,
    DWORD    dwDigitMode,
    LPCWSTR  pwszDigits,
    DWORD    dwDuration
    );

BOOL IsPhoneNumber( char * szAddr );

// called by Q.931 listener when a new connection is received
void    CallProcessIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress);


void NTAPI Q931TransportEventHandler (
    IN  PVOID   Parameter,
    IN  BOOLEAN TimerFired);

BOOL
IsValidE164String( 
                  IN WCHAR* wszDigits
                 );

DWORD
ValidateE164Address(
                   LPCWSTR pwszDialableAddr,
                   WCHAR*  wszAddr
                   );

BOOL
QueueSuppServiceWorkItem(
    IN  DWORD   EventID,
    IN  HDRVCALL    hdCall,
    IN  ULONG_PTR   dwParam1
    );
#if 0
BOOL
CH323Call::QueueTAPICallRequest(
    IN  DWORD   EventID,
    IN  PVOID   pBuf );
#endif

DWORD
ProcessSuppServiceWorkItemFre(
	IN PVOID ContextParameter
    );

DWORD
SendMSPMessageOnRelatedCallFre(
    IN PVOID ContextParameter
    );

DWORD 
ProcessTAPICallRequestFre(
    IN  PVOID   ContextParameter
    );

#endif // _INC_CALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\confcall.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    confcall.cpp

Abstract:

    TAPI Service Provider functions related to conference calls.

        TSPI_lineAddToConference        
        TSPI_lineCompleteTransfer
        TSPI_linePrepareAddToConference
        TSPI_lineRemoveFromConference
        TSPI_lineSetupConference
        TSPI_lineSetupTransfer
        TSPI_lineDial
        TSPI_lineCompleteTransfer
        TSPI_lineForward
        TSPI_lineSetStatusMessage
        TSPI_lineRedirect
        TSPI_lineHold
        TSPI_lineUnhold

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "q931obj.h"
#include "ras.h"
#include "call.h"

#define CALL_DIVERTNA_NUM_RINGS 8000
extern DWORD g_dwTSPIVersion;


//Queues a supplementary service work item to the thread pool
BOOL
QueueSuppServiceWorkItem(
	IN	DWORD	EventID,
	IN	HDRVCALL	hdCall,
	IN	ULONG_PTR	dwParam1
    )
{
	SUPP_REQUEST_DATA *	pCallRequestData = new SUPP_REQUEST_DATA;
	BOOL fResult = TRUE;

    if( pCallRequestData != NULL )
    {
        pCallRequestData -> EventID = EventID;
        pCallRequestData -> hdCall = hdCall;
        pCallRequestData -> dwParam1 = dwParam1;

        if( !QueueUserWorkItem( ProcessSuppServiceWorkItem,
                pCallRequestData, WT_EXECUTEDEFAULT) )
        {
	        delete pCallRequestData;
	        fResult = FALSE;
        }
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


#if   DBG

DWORD
ProcessSuppServiceWorkItem(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessSuppServiceWorkItemFre( ContextParameter );
    }
    __except( 1 )
    {
        SUPP_REQUEST_DATA*  pRequestData = (SUPP_REQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p.", 
            EventIDToString(pRequestData -> EventID),
            pRequestData -> hdCall,
            pRequestData -> dwParam1 ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif


DWORD
ProcessSuppServiceWorkItemFre(
	IN PVOID ContextParameter
    )
{
    _ASSERTE( ContextParameter );

    PH323_CALL          pCall = NULL;
    SUPP_REQUEST_DATA*  pRequestData = (SUPP_REQUEST_DATA*)ContextParameter;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.",
        EventIDToString(pRequestData -> EventID) ));
    
    switch( pRequestData -> EventID )
    {
    case H450_PLACE_DIVERTEDCALL:

        g_pH323Line -> PlaceDivertedCall( pRequestData->hdCall, 
            pRequestData->pAliasNames );
        
        break;

    case TSPI_DIAL_TRNASFEREDCALL:
        
        g_pH323Line -> PlaceTransferedCall( pRequestData->hdCall,
            pRequestData->pAliasNames );
        
        break;

    case SWAP_REPLACEMENT_CALL:
        
        g_pH323Line -> SwapReplacementCall( pRequestData->hdCall,
            pRequestData->hdReplacementCall, TRUE );
        break;

    case DROP_PRIMARY_CALL:

        g_pH323Line -> SwapReplacementCall( pRequestData->hdCall,
            pRequestData->hdReplacementCall, FALSE );
        break;
    
    case STOP_CTIDENTIFYRR_TIMER:

        pCall=g_pH323Line -> FindH323CallAndLock( pRequestData->hdCall );
        if( pCall != NULL )
        {
            pCall -> StopCTIdentifyRRTimer( pRequestData->hdReplacementCall );
            pCall -> Unlock();
        }
        else
        {
            //set the m_hdRelatedCall of dwParam1 to NULL
        }
        break;

    case SEND_CTINITIATE_MESSAGE:

        pCall=g_pH323Line -> FindH323CallAndLock(pRequestData->hdCall);
        if( pCall != NULL )
        {
            pCall -> SendCTInitiateMessagee( pRequestData->pCTIdentifyRes );
            pCall -> Unlock();
        }
        break;
    }

    delete ContextParameter;

    return EXIT_SUCCESS;
}


//!!must be always called in a lock
void
CH323Call::TransferInfoToDivertedCall(
    IN PH323_CALL pDivertedCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToDivertedCall entered." ));
        
    pDivertedCall -> SetDivertedCallInfo(
        m_hdCall, 
        m_pCallReroutingInfo,
        m_dwCallDiversionState, 
        m_hdMSPLine, 
        m_pCallerAliasNames, 
        m_htMSPLine, 
        m_pFastStart, 
        m_hdRelatedCall, 
        m_dwCallType,
        m_dwAppSpecific,
        &m_CallData );

    //reset the reference to this struct
    m_pCallReroutingInfo = NULL;
    m_pCallerAliasNames = NULL;
    m_dwCallDiversionState = H4503_CALLSTATE_IDLE;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwCallState = LINECALLSTATE_IDLE;
    m_pFastStart = NULL;

    ZeroMemory( (PVOID)&m_CallData, sizeof(H323_OCTETSTRING) );
    
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToDivertedCall exited." ));
}


//!!always called in a lock
BOOL
CH323Call::TransferInfoToTransferedCall(
    IN PH323_CALL pTransferedCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToTransferedCall entered." ));

    if( !pTransferedCall -> SetTransferedCallInfo( 
        m_hdCall, m_pCallerAliasNames, m_pCTCallIdentity ) )
    {
        pTransferedCall -> Unlock();
        return FALSE;
    }

    m_hdRelatedCall = pTransferedCall -> GetCallHandle();

    H323DBG(( DEBUG_LEVEL_TRACE, "TransferInfoToTransferedCall exited." ));
    return TRUE;
}


void
CH323Call::SetDivertedCallInfo( 
    HDRVCALL            hdCall,
    CALLREROUTINGINFO*  pCallReroutingInfo,
    SUPP_CALLSTATE      dwCallDiversionState,
    HDRVMSPLINE         hdMSPLine,
    PH323_ALIASNAMES    pCallerAliasNames,
    HTAPIMSPLINE        htMSPLine,
    PH323_FASTSTART     pFastStart,
    HDRVCALL            hdRelatedCall,
    DWORD               dwCallType,
    DWORD               dwAppSpecific,
    PH323_OCTETSTRING   pCallData
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetDivertedCallInfo entered:%p.", this ));
    Lock();

    m_hdCall = hdCall;
    m_pCallReroutingInfo = pCallReroutingInfo;
    m_dwCallDiversionState = dwCallDiversionState;
    m_hdMSPLine = hdMSPLine;
    m_htMSPLine = htMSPLine;
    
    FreeAliasNames( m_pCallerAliasNames );
    
    m_pCallerAliasNames = pCallerAliasNames;

    H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    m_dwCallState =  LINECALLSTATE_DIALING;
    m_pFastStart = pFastStart;
    m_CallData = *pCallData;
    m_dwAppSpecific = dwAppSpecific;

    //If the original call had any call type apart from being a diverted call
    //copy it.
    if( (dwCallType & CALLTYPE_TRANSFEREDSRC) ||
        (dwCallType & CALLTYPE_DIVERTEDTRANSFERED) )
    {
        m_dwCallType |= CALLTYPE_DIVERTEDTRANSFERED;
        m_hdRelatedCall = hdRelatedCall;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SetDivertedCallInfo exited:%p.", this ));
}


//!!must be always called in a lock
BOOL
CH323Call::SetTransferedCallInfo(
                               HDRVCALL hdCall,
                               PH323_ALIASNAMES pCallerAliasNames,
                               BYTE * pCTCallIdentity
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetTransferedCallInfo entered:%p.", this ));

    m_hdRelatedCall = hdCall;

    m_pCallerAliasNames = NULL;

    if( (pCallerAliasNames != NULL) && (pCallerAliasNames->wCount != 0) )
    {
        m_pCallerAliasNames = new H323_ALIASNAMES;
        if( m_pCallerAliasNames == NULL )
        {
            return FALSE;
        }
        ZeroMemory( (PVOID)m_pCallerAliasNames, sizeof(H323_ALIASNAMES) );

        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        if( !AddAliasItem( m_pCallerAliasNames,
            pCallerAliasNames->pItems[0].pData,
            pCallerAliasNames->pItems[0].wType ) )
        {
            return FALSE;
        }
        
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    CopyMemory( (PVOID)m_pCTCallIdentity, pCTCallIdentity, 
        sizeof(m_pCTCallIdentity) );
    
    m_dwCallState =  LINECALLSTATE_DIALING;   
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SetTransferedCallInfo exited:%p.", this ));
    return TRUE;
}


void
CH323Line::PlaceDivertedCall( 
    IN HDRVCALL hdCall,
    IN PH323_ALIASNAMES divertedToAlias
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceDivertedCall entered:%p.", this ));

    int         iIndex = MakeCallIndex( hdCall );
    int         iDivertedCallIndex;
    PH323_CALL  pCall;
    BOOL        fDelete = FALSE;
    PH323_CALL  pDivertedCall = NULL;

    Lock();

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( (pCall=m_H323CallTable[iIndex]) != NULL )
    {
        pCall -> Lock();

        if( pCall->GetCallHandle() == hdCall )
        {
                
            pDivertedCall = pCall-> CreateNewDivertedCall( divertedToAlias );
        
            if( pDivertedCall == NULL )
            {
                pCall -> Unlock();
                UnlockCallTable();
                pCall->CloseCall( 0 );
                Unlock();
                return;
            }

            //remove the diverted call from the table
            iDivertedCallIndex = pDivertedCall -> GetCallIndex();

            m_H323CallTable[iDivertedCallIndex] = NULL;

            //transfer the required information to the diverted call.
            //put the original call in IDLE mode
            pCall -> TransferInfoToDivertedCall( pDivertedCall );

            //This DropCall is supposed to send only the DRQ if required
            pCall->DropCall( 0 );

            //close the original call
            pCall -> Shutdown( &fDelete );

            H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", pCall ));
            pCall -> Unlock();

            //release the original call object
            if( fDelete == TRUE )
            {
                H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", pCall ));
                delete pCall;
            }

            //place the diverted call in the place of the original call
            m_H323CallTable[iIndex] = pDivertedCall;
        }
        else
        {
            pCall -> Unlock();
        }
    }
    
    UnlockCallTable();

    //dial the diverted call
    if( pDivertedCall )
    {
        pDivertedCall -> DialCall();
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceDivertedCall exited:%p.", this ));
}


//!!always called in a lock
PH323_CALL
CH323Call::CreateNewDivertedCall(
    IN PH323_ALIASNAMES pwszCalleeAlias
    )
{
    PH323_CONFERENCE pConf = NULL;
    BOOL fDelete = FALSE;
    PH323_CALL pCall = new CH323Call();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewDivertedCall entered:%p.", this ));

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate diverted call." ));

        return NULL;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize( m_htCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_DIVERTEDSRC ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        goto cleanup;
    }

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        goto cleanup;
    }

    if( pwszCalleeAlias->pItems[0].wType == e164_chosen )
    {
        pCall->SetAddressType( e164_chosen );
    }

    if (!RasIsRegistered())
    {
        if( !pCall->ResolveAddress( pwszCalleeAlias->pItems[0].pData ) )
        {
            goto cleanup;
        }
    }

    if( !pCall->SetCalleeAlias( pwszCalleeAlias->pItems[0].pData, 
        pwszCalleeAlias->pItems[0].wType ) )
    {
        goto cleanup;
    }
    
    //send the informarion to the user that call has been diverted
    PostLineEvent(
        LINE_CALLINFO,
        LINECALLINFOSTATE_REDIRECTIONID,
        0, 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "diverted call created:%p.", pCall ));
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewDivertedCall exited.\n:%p", this ));
    return pCall;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        delete pCall;
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
    }

    return NULL;
}


//!!always called in a lock
void
CH323Call::Hold()
{
    //1.Send MSP call hold message 
    //2.Send hold H450 APDU
    if( m_dwCallState == LINECALLSTATE_ONHOLD )
    {
        return;
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        HOLDNOTIFIC_OPCODE | H450_INVOKE ) )
    {
        CloseCall( 0 );
        return;
    }
        
    SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
    
    //Call put on hold by local endpoint
    m_dwFlags |= TSPI_CALL_LOCAL_HOLD;
    
    ChangeCallState( LINECALLSTATE_ONHOLD, 0 );
    return;
}


//!!always called in a lock
void
CH323Call::UnHold()
{
    //1.Send MSP call unhold message 
    //2.Send unhold H450 APDU
    if( (m_dwCallState == LINECALLSTATE_ONHOLD) &&
        (m_dwFlags & TSPI_CALL_LOCAL_HOLD) )
    {
        if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
            RETRIEVENOTIFIC_OPCODE | H450_INVOKE ) )
        {
            CloseCall( 0 );
            return;
        }
    
        SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
        m_dwFlags &= (~TSPI_CALL_LOCAL_HOLD);
        ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    }

    return;
}


//!!always called in a lock
void
CH323Call::OnCallReroutingReceive(
                                    IN DWORD dwInvokeID
                                 )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnCallReroutingReceive entered:%p.", this ));

    if( (m_dwOrigin != LINECALLORIGIN_OUTBOUND) ||
        ( (m_dwStateMachine != Q931_SETUP_SENT) &&
          (m_dwStateMachine != Q931_PROCEED_RECVD) &&
          (m_dwStateMachine != Q931_ALERT_RECVD)
        )
      )
    {
        goto error;
    }
    
    //If setupsent timer is still alive stop it.
    if( m_hSetupSentTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
        m_hSetupSentTimer = NULL;
    }

    if( dwInvokeID != NO_INVOKEID )
    {
        if(!SendQ931Message( dwInvokeID,
                                 0,
                                 0,
                                 FACILITYMESSAGETYPE,
                                 CALLREROUTING_OPCODE | H450_RETURNRESULT ))
        {
            //goto error;
        }
    }
    
    m_fCallInTrnasition = TRUE;
    if( !SendQ931Message( NO_INVOKEID,
                         0,
                         0,
                         RELEASECOMPLMESSAGETYPE,
                         NO_H450_APDU) )
    {
        //goto error;
    }

    if( !QueueSuppServiceWorkItem( H450_PLACE_DIVERTEDCALL, m_hdCall,
        (ULONG_PTR)m_pCallReroutingInfo->divertedToNrAlias ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post place diverted event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "OnCallReroutingReceive exited:%p.", this ));
    return;

error:
    CloseCall( 0 );
}


//!!always called in a lock
BOOL
CH323Call::IsValidInvokeID(
    IN DWORD dwInvokeId
    )
{
    if( m_dwCallType != CALLTYPE_NORMAL )
    {
        if( m_dwInvokeID == dwInvokeId )
        {
            return TRUE;
        }
        
        H323DBG(( DEBUG_LEVEL_ERROR, "invoke id not matched:%d:%d.", 
            m_dwInvokeID, dwInvokeId ));
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "IsValidinvokeID called on wrong call." ));
    return FALSE;
}


BOOL
CH323Call::StartTimerForCallDiversionOnNA(
    IN PH323_ALIASITEM pwszDivertedToAlias
    )
{
    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        
        if( m_pCallReroutingInfo == NULL )
        {
            goto cleanup;
        }
        
        ZeroMemory( m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
    
    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        goto cleanup;
    }

    ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, 
        sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
        (BYTE*)pwszDivertedToAlias->pData, 
        sizeof(WCHAR) * (wcslen(pwszDivertedToAlias->pData) +1),
        pwszDivertedToAlias->wType ) )
    {
        goto cleanup;
    }

    if( !CreateTimerQueueTimer(
		    &m_hCallDivertOnNATimer,
		    H323TimerQueue,
		    CH323Call::CallDivertOnNACallback,
		    (PVOID)m_hdCall,
		    (g_pH323Line->m_dwNumRingsNoAnswer * 1000), 0,
		    WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }

    return TRUE;

cleanup:

    FreeCallReroutingInfo();
    return FALSE;
}


LONG 
CH323Call::SetDivertedToAlias( 
    WCHAR* pwszDivertedToAddr,
    WORD   wAliasType
    )
{
    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        
        if( m_pCallReroutingInfo == NULL )
        {
            return LINEERR_NOMEM;
        }
        
        ZeroMemory( m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
    
    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        delete m_pCallReroutingInfo;
        
        m_pCallReroutingInfo = NULL;
        return LINEERR_NOMEM;
    }
    
    ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
        (BYTE*)pwszDivertedToAddr, 
        sizeof(WCHAR) * (wcslen(pwszDivertedToAddr) +1),
        wAliasType ) )
    {
        delete m_pCallReroutingInfo->divertedToNrAlias;
        delete m_pCallReroutingInfo;
        m_pCallReroutingInfo = NULL;
    
        return LINEERR_NOMEM;
    }

    return NOERROR;
}


//!!always called in a lock
//this function is called to replace a TRANSFERD_PRIMARY call with a connected
//TRANSFEREDSRC call or to preplace a TRANSFERED2_PRIMARY call with a connected
//TRANSFEREDDEST call
BOOL
CH323Call::InitiateCallReplacement(
    PH323_FASTSTART  pFastStart,
    PH323_ADDR       pH245Addr
    )
{
    H323DBG(( DEBUG_LEVEL_ERROR, "InitiateCallReplacement entered:%p.",this ));

    SendMSPStartH245( pH245Addr, pFastStart );
    SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, m_hdRelatedCall );

    m_fCallInTrnasition = TRUE;

    if( (m_dwRASCallState == RASCALL_STATE_REGISTERED ) ||
        (m_dwRASCallState == RASCALL_STATE_ARQSENT ) )
    {
        //disengage from the GK
        SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, FALSE );
    }

    if( !SendQ931Message( m_dwInvokeID,
         0,
         0,
         RELEASECOMPLMESSAGETYPE,
         CTINITIATE_OPCODE | H450_RETURNRESULT) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "InitiateCallReplacement exited:%p.",this ));
    return TRUE;

cleanup:
    CloseCall( 0 );
    return FALSE;
}


//this function is called to replace a TRANSFERD_PRIMARY call with TRANSFEREDSRC
//call or to replace a TRANSFERD2_CONSULT call with a TRANSFEREDDEST call
void
CH323Line::SwapReplacementCall(
    HDRVCALL hdReplacementCall,
    HDRVCALL hdPrimaryCall,
    BOOL     fChangeCallSate
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SwapReplacementCall entered:%p.", this ));

    int         iReplacementCallIndex = (int)LOWORD(hdReplacementCall);
    int         iPrimaryCallIndex = (int)LOWORD(hdPrimaryCall);
    PH323_CALL  pReplacementCall;
    BOOL        fDelete = FALSE;
    PH323_CALL  pPrimaryCall;

    Lock();
    LockCallTable();
    
    //lock the replacement call before primary call to avoid deadlock
    if( (pReplacementCall=m_H323CallTable[iReplacementCallIndex]) != NULL )
    {
        pReplacementCall -> Lock();

        if( pReplacementCall -> GetCallHandle() == hdReplacementCall )
        {
            if( (pPrimaryCall=m_H323CallTable[iPrimaryCallIndex]) != NULL )
            {
                pPrimaryCall -> Lock();

                if( pPrimaryCall -> GetCallHandle() == hdPrimaryCall )
                {
                    pPrimaryCall -> InitiateCallReplacement(
                        pReplacementCall->GetPeerFastStart(),
                        pReplacementCall->GetPeerH245Addr() );

                    //remove the replacement call from the table
                    m_H323CallTable[iReplacementCallIndex] = NULL;

                    //Transfer the required information to the replacement call.
                    //put the primary call in IDLE mode
                    pPrimaryCall -> TransferInfoToReplacementCall( pReplacementCall );

                    //close the original call
                    pPrimaryCall -> Shutdown( &fDelete );

                    H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", 
                        pPrimaryCall ));
                    pPrimaryCall -> Unlock();

                    //release the primary call object
                    if( fDelete == TRUE )
                    {
                        H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", 
                            pPrimaryCall ));
                        delete pPrimaryCall;
                    }

                    //Place the replacement call in the place of primary call.
                    m_H323CallTable[iPrimaryCallIndex] = pReplacementCall;
                }
                else
                {
                    pPrimaryCall -> Unlock();
                }
            }
            else
            {
                pReplacementCall-> CloseCall( 0 );
            }

            //inform TAPI that the transfered call is in connected state
            if( fChangeCallSate == TRUE )
            {
                pReplacementCall->ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
            }
        }
        
        pReplacementCall -> Unlock();
    }
    
    UnlockCallTable();
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "SwapReplacementCall exited:%p.", this ));
}


//!!both the calls are locked when this function is called
void
CH323Call::TransferInfoToReplacementCall( 
    PH323_CALL pReplacementCall
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "TransferInfoToReplacementCall entered:%p.", this ));
    
    m_dwCallDiversionState = H4503_CALLSTATE_IDLE;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwCallState = LINECALLSTATE_IDLE;
    
    pReplacementCall->SetReplacementCallInfo(
        m_hdCall,
        m_hdMSPLine, 
        m_htCall, 
        m_htMSPLine, 
        m_dwAppSpecific, 
        &m_CallData );

    //don't release this octet string while releasing tis call.
    ZeroMemory( (PVOID)&m_CallData, sizeof(H323_OCTETSTRING) );

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "TransferInfoToReplacementCall exited:%p.", this ));
}


//!!always called in a lock
void
CH323Call::SetReplacementCallInfo(
    HDRVCALL hdCall,
    HDRVMSPLINE hdMSPLine,
    HTAPICALL htCall,
    HTAPIMSPLINE htMSPLine,
    DWORD dwAppSpecific,
    PH323_OCTETSTRING pCallData
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, 
        "SetReplacementCallInfo entered:%p.", this ));

    m_hdCall = hdCall;
    m_hdMSPLine = hdMSPLine;
    m_htMSPLine = htMSPLine;
    m_htCall = htCall;
    m_hdRelatedCall = NULL;
    m_dwCallType = CALLTYPE_NORMAL;
    m_dwAppSpecific = dwAppSpecific; 
    m_CallData = *pCallData;

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "SetReplacementCallInfo exited:%p.", this ));
}



//!!always called in a lock
void
CH323Call::CompleteTransfer(
                            PH323_CALL pCall
                           )
{
    BOOL retVal;

    //set the call type of both the calls
    pCall -> SetCallType( CALLTYPE_TRANSFERING_PRIMARY );
    m_dwCallType |= CALLTYPE_TRANSFERING_CONSULT;
    m_hdRelatedCall = pCall -> GetCallHandle();

    //send CallTransferIdentify message to the transferredTo endpoint over the
    //consultation call
    retVal = SendQ931Message( NO_INVOKEID, 0, 0/*undefinedReason*/,
        FACILITYMESSAGETYPE, CTIDENTIFY_OPCODE | H450_INVOKE );

    m_dwCallDiversionState = H4502_CTIDENTIFY_SENT;

    //start the timer for CTIdenity message
    if( retVal )
    {
        retVal = CreateTimerQueueTimer(
	        &m_hCTIdentifyTimer,
	        H323TimerQueue,
	        CH323Call::CTIdentifyExpiredCallback,
	        (PVOID)m_hdCall,
	        CTIDENTIFY_SENT_TIMEOUT, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
    }

    if( retVal == FALSE )
    {
        CloseCall( 0 );
    }
}


void
CH323Line::PlaceTransferedCall( 
                   IN HDRVCALL hdCall,
                   IN PH323_ALIASNAMES pTransferedToAlias
                  )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceTransferedCall entered:%p.", this ));

    PH323_CALL  pCall = NULL;
    PH323_CALL  pTransferedCall = NULL;
    BOOL        fDelete = FALSE;

    Lock();
    
    LockCallTable();

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);

    if( pCall == NULL )
    {
        goto cleanup;
    }

    pTransferedCall = CreateNewTransferedCall( pTransferedToAlias );

    if( pTransferedCall == NULL )
    {
        goto cleanup;
    }

    //transfer the required information to the transfered call
    if( !pCall -> TransferInfoToTransferedCall( pTransferedCall ) )
    {
        goto cleanup;
    }

    pCall -> SetCallState( LINECALLSTATE_ONHOLD );
    pCall -> SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
    
    pCall -> Unlock();
    
    //dial the transfered call
    pTransferedCall -> DialCall();
        
    UnlockCallTable();
    Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "PlaceTransferedCall exited:%p.", this ));
    
    return;

cleanup:

    if( pCall != NULL )
    {
        //close the primary call
        QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            hdCall, 
            NULL,
            LINEDISCONNECTMODE_NORMAL,
            NULL);

        pCall -> Unlock();
    }

    if( pTransferedCall )
    {
        pTransferedCall -> Shutdown( &fDelete );
        delete pTransferedCall;
    }
    
    UnlockCallTable();
    
    Unlock();
}


//!!always called in a lock
PH323_CALL
CH323Line::CreateNewTransferedCall(
                         IN PH323_ALIASNAMES pwszCalleeAlias
                       )
{
    PH323_CONFERENCE pConf = NULL;
    BOOL fDelete = FALSE;
    PH323_CALL pCall = new CH323Call();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewTransferedCall entered:%p.", this ));

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate Transfered call." ));

        return NULL;
    }

    // no tapi handle for this call
    if( !pCall -> Initialize( NULL, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_TRANSFEREDSRC ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not allocate outgoing call." ));

        goto cleanup;
    }

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        goto cleanup;
    }

    if( pwszCalleeAlias->pItems[0].wType == e164_chosen )
    {
        pCall->SetAddressType( e164_chosen );
    }
    
    if (!RasIsRegistered())
    {
        if( !pCall->ResolveAddress( pwszCalleeAlias->pItems[0].pData ) )
        {
            goto cleanup;
        }
    }

    if( !pCall->SetCalleeAlias( pwszCalleeAlias->pItems[0].pData, 
        pwszCalleeAlias->pItems[0].wType ) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "Transfered call created:%p.", pCall ));
    H323DBG(( DEBUG_LEVEL_TRACE, "CreateNewTransferedCall exited:%p.", this ));
    return pCall;

cleanup:
    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        delete pCall;
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
    }

    return NULL;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           



LONG
TSPIAPI
TSPI_lineAddToConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdConfCall,
    HDRVCALL      hdConsultCall
    )
    
/*++

Routine Description:

    This function adds the call specified by hdConsultCall to the conference 
    call specified by hdConfCall.

    Note that the call handle of the added party remains valid after adding 
    the call to a conference; its state will typically change to conferenced 
    while the state of the conference call will typically become connected.  
    The handle to an individual participating call can be used later to remove 
    that party from the conference call using TSPI_lineRemoveFromConference. 

    The call states of the calls participating in a conference are not 
    independent. For example, when dropping a conference call, all 
    participating calls may automatically become idle. The TAPI DLL may consult
    the line's device capabilities to determine what form of conference removal 
    is available. The TAPI DLL or its client applications should track the 
    LINE_CALLSTATE messages to determine what really happened to the calls 
    involved.
    
    The conference call is established either via TSPI_lineSetupConference or 
    TSPI_lineCompleteTransfer. The call added to a conference will typically be
    established using TSPI_lineSetupConference or 
    TSPI_linePrepareAddToConference. Some switches may allow adding of an 
    arbitrary calls to conference, and such a call may have been set up using 
    TSPI_lineMakeCall and be on (hard) hold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to the 
        conference call.  Valid call states: onHoldPendingConference, onHold.

    hdAddCall - Specifies the Service Provider's opaque handle to the call to 
        be added to the conference call.  Valid call states: connected, onHold.        

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are: 
    
        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid or is not a handle for a conference 
            call.

        LINEERR_INVALCALLHANDLE - The specified call handle for the added 
            call is invalid.

        LINEERR_INVALCALLSTATE - One or both of the specified calls are not 
            in a valid state for the requested operation.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG 
TSPIAPI 
TSPI_lineBlindTransfer(
    DRV_REQUESTID dwRequestID,
    HDRVCALL hdCall,
    LPCWSTR lpszDestAddress,
    DWORD dwCountryCode
    )
{
    PH323_CALL  pCall = NULL;
    LONG        retVal = ERROR_SUCCESS;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineBlindTransfer - Entered." ));

    if( lpszDestAddress == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    // retrieve call pointer from handle
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    retVal = pCall -> InitiateBlindTransfer( lpszDestAddress );
    pCall -> Unlock();

    if( retVal == ERROR_SUCCESS )
    {
        // complete the async accept operation now
		H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

        retVal = dwRequestID;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineBlindTransfer - Exited." ));
    return retVal;
}



//!!always called in a lock
LONG
CH323Call::InitiateBlindTransfer(
    IN LPCWSTR lpszDestAddress
    )
{
    WORD    wAliasType = h323_ID_chosen;
    DWORD   dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD   dwAddrLen;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateBlindTransfer - Entered." ));
    
    if( m_dwCallState != LINECALLSTATE_CONNECTED )
    {
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }

    dwAddrLen = wcslen( lpszDestAddress );
    
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) ) 
    {
        return LINEERR_INVALPARAM;
    }
    
    if( m_pTransferedToAlias )
    {
        FreeAliasNames( m_pTransferedToAlias );
        m_pTransferedToAlias = NULL;
    }

    m_pTransferedToAlias = new H323_ALIASNAMES;
    
    if( m_pTransferedToAlias == NULL )
    {
        return LINEERR_OPERATIONFAILED;
    }

    ZeroMemory( (PVOID)m_pTransferedToAlias, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pTransferedToAlias,
        (BYTE*)lpszDestAddress,
        sizeof(WCHAR) * (wcslen(lpszDestAddress) +1),
        wAliasType ) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        CTINITIATE_OPCODE | H450_INVOKE ) )
    {
        return LINEERR_OPERATIONFAILED;
    }

    m_dwCallDiversionState = H4502_CTINITIATE_SENT;
    m_dwCallType |= CALLTYPE_TRANSFERING_PRIMARY;

    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateBlindTransfer - Exited." ));
    return ERROR_SUCCESS;
}


/*++

Routine Description:

    This function completes the transfer of the specified call to the party 
    connected in the consultation call.
    
    This operation completes the transfer of the original call, hdCall, to 
    the party currently connected via hdConsultCall. The consultation call 
    will typically have been dialed on the consultation call allocated as 
    part of TSPI_lineSetupTransfer, but it may be any call to which the 
    switch is capable of transferring hdCall.

    The transfer request can be resolved either as a transfer or as a 
    three-way conference call. When resolved as a transfer, the parties 
    connected via hdCall and hdConsultCall will be connected to each other, 
    and both hdCall and hdConsultCall will typically be removed from the line 
    they were on and both will transition to the idle state. Note that the 
    Service Provider's opaque handles for these calls must remain valid after 
    the transfer has completed.  The TAPI DLL causes these handles to be 
    invalidated when it is no longer interested in them using 
    TSPI_lineCloseCall.

    When resolved as a conference, all three parties will enter in a 
    conference call. Both existing call handles remain valid, but will 
    transition to the conferenced state. A conference call handle will created
    and returned, and it will transition to the connected state.
    
    It may also be possible to perform a blind transfer of a call using 
    TSPI_lineBlindTransfer.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call to be 
        transferred.  Valid call states: onHoldPendingTransfer.

    hdConsultCall - Specifies a handle to the call that represents a connection
        with the destination of the transfer.  Valid call states: connected, 
        ringback, busy.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new call.  If 
        dwTransferMode is specified as LINETRANSFERMODE_CONFERENCE then the 
        Service Provider must save this and use it in all subsequent calls to 
        the LINEEVENT procedure reporting events on the call.  Otherwise this 
        parameter is ignored.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the call.   If dwTransferMode is 
        specified as LINETRANSFERMODE_CONFERENCE then the Service Provider must
        fill this location with its opaque handle for the new conference call 
        before this procedure returns, whether it decides to execute the 
        request sychronously or asynchronously.  This handle is invalid if the
        function results in an error (either synchronously or asynchronously).  
        If dwTransferMode is some other value this parameter is ignored.

    dwTransferMode - Specifies how the initiated transfer request is to be 
        resolved, of type LINETRANSFERMODE. Values are:

        LINETRANSFERMODE_TRANSFER - Resolve the initiated transfer by 
            transferring the initial call to the consultation call.

        LINETRANSFERMODE_CONFERENCE - Resolve the initiated transfer by 
            conferencing all three parties into a three-way conference call. 
            A conference call is created and returned to the TAPI DLL.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred.  Possible error returns are:
    
        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALCONSULTCALLHANDLE - The specified consultation call 
            handle is invalid.

        LINEERR_INVALCALLSTATE - One or both calls are not in a valid state 
            for the requested operation.

        LINEERR_INVALTRANSFERMODE - The specified transfer mode parameter is 
            invalid.

        LINEERR_INVALPOINTER - The specified pointer parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

LONG
TSPIAPI
TSPI_lineCompleteTransfer(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall,
    HDRVCALL      hdConsultCall,
    HTAPICALL     htConfCall,
    LPHDRVCALL    lphdConfCall,
    DWORD         dwTransferMode
    )
{
    LONG        retVal = (DWORD)dwRequestID;
    PH323_CALL  pCall = NULL;
    PH323_CALL  pConsultCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCompleteTransfer - Entered." ));

    if( dwTransferMode != LINETRANSFERMODE_TRANSFER )
    {
        return LINEERR_INVALTRANSFERMODE; // CODEWORK...    
    }

    // retrieve call pointer from handle
    pCall=g_pH323Line -> Find2H323CallsAndLock( 
        hdCall, hdConsultCall, &pConsultCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( (pCall -> GetCallState() != LINECALLSTATE_CONNECTED) &&
        !pCall -> IsCallOnHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        goto cleanup;
    }
    
    if( (pConsultCall -> GetCallState() != LINECALLSTATE_CONNECTED) &&
        !pConsultCall -> IsCallOnHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        goto cleanup;
    }

    if( !QueueTAPILineRequest( 
            TSPI_COMPLETE_TRANSFER, 
            hdCall, 
            hdConsultCall,
            0,
            NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        retVal = LINEERR_OPERATIONFAILED;
        goto cleanup;
    }

    // complete the async accept operation now
	H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCompleteTransfer - Exited." ));

cleanup:
    if( pCall != NULL )
    {
        pCall -> Unlock();
    }
    
    if( pConsultCall )
    {
        pConsultCall -> Unlock();
    }

    return retVal;
}


    
/*++

Parameters:

    dwRequestID - The identifier of the asynchronous request.

    hdCall - The handle to the call to be transferred. The call state of hdCall
        can be connected.

    htConsultCall - The TAPI handle to the new, temporary consultation call.
        The service provider must save this and use it in all subsequent calls
        to the LINEEVENT procedure reporting events on the new consultation call.

    lphdConsultCall - A pointer to an HDRVCALL representing the service 
        provider's identifier for the new consultation call. The service 
        provider must fill this location with its handle for the new 
        consultation call before this procedure returns. This handle is ignored
        by TAPI if the function results in an error. The call state of 
        hdConsultCall is not applicable.
        
        When setting a call up for transfer, another call (a consultation call)
        is automatically allocated to enable the application (through TAPI) to 
        dial the address (using TSPI_lineDial) of the party to where the call
        is to be transferred. The originating party can carry on a conversation
        over this consultation call prior to completing the transfer. 

        This transfer procedure may not be valid for some line devices. Instead
        of calling this procedure, TAPI may need to unhold an existing held
        call (using TSPI_lineUnhold) to identify the destination of the transfer.
        On switches that support cross-address call transfer, the consultation
        call can exist on a different address than the call to be transferred.
        It may also be necessary to set up the consultation call as an entirely
        new call using TSPI_lineMakeCall, to the destination of the transfer.

        The transferHeld and transferMake flags in the LINEADDRESSCAPS data 
        structure report what model the service provider uses.

    lpCallParams - A pointer to call parameters to be used when establishing
        the consultation call. This parameter can be set to NULL if no special
        call setup parameters are desired (the service provider uses defaults).

Return Values:

    Returns dwRequestID, or an error number if an error occurs. The lResult
    actual parameter of the corresponding ASYNC_COMPLETION is zero if the
    function succeeds, or an error number if an error occurs. Possible return
    values are as follows:

        LINEERR_INVALCALLHANDLE, 
        LINEERR_INVALBEARERMODE, 
        LINEERR_INVALCALLSTATE, 
        LINEERR_INVALRATE, 
        LINEERR_CALLUNAVAIL, 
        LINEERR_INVALCALLPARAMS, 
        LINEERR_NOMEM, 
        LINEERR_INVALLINESTATE, 
        LINEERR_OPERATIONUNAVAIL, 
        LINEERR_INVALMEDIAMODE, 
        LINEERR_OPERATIONFAILED, 
        LINEERR_INUSE, 
        LINEERR_RESOURCEUNAVAIL, 
        LINEERR_NOMEM, 
        LINEERR_BEARERMODEUNAVAIL, 
        LINEERR_RATEUNAVAIL, 
        LINEERR_INVALADDRESSMODE, 
        LINEERR_USERUSERINFOTOOBIG. 

--*/

LONG
TSPIAPI
TSPI_lineSetupTransfer(
    DRV_REQUESTID dwRequestID,           
    HDRVCALL hdCall,                     
    HTAPICALL htConsultCall,             
    LPHDRVCALL phdConsultCall,          
    LPLINECALLPARAMS const lpCallParams  
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    PH323_CALL          pConsultCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwCallState;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetupTransfer - Entered." ));

    // Acquire the call table lock.
    g_pH323Line -> LockCallTable();

    pCall = g_pH323Line -> FindH323CallAndLock( hdCall );
    if( pCall == NULL )
    {
        retVal = LINEERR_INVALCALLHANDLE;
        goto cleanup;
    }

    dwCallState = pCall -> GetCallState();

    if( (dwCallState != LINECALLSTATE_CONNECTED) &&
        !pCall -> IsCallOnLocalHold() )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not connected.", pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        
        goto cleanup;
    }
    
    dwCallState = pCall -> GetCallDiversionState();
    if( dwCallState == H4502_CONSULTCALL_INITIATED )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx already is consulting.",
            pCall ));
        retVal = LINEERR_INVALCALLSTATE;
        
        goto cleanup;
    }

    // allocate outgoing call
    pConsultCall = new CH323Call();

    if( pConsultCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        retVal = LINEERR_NOMEM;
        
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pConsultCall -> Initialize( htConsultCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_TRANSFERING_CONSULT ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        retVal = LINEERR_NOMEM;
        goto cleanup;
    }

    // transfer handle
    *phdConsultCall = pConsultCall -> GetCallHandle();

    // bind outgoing call
    pConf = pConsultCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        // no memory available
        retVal = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        retVal = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    // complete the async accept operation now
	H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pConsultCall -> ChangeCallState( LINECALLSTATE_DIALTONE, 0 );

    // Put the primary call on hold
    pCall-> Hold();

    pCall -> SetCallDiversionState( H4502_CONSULTCALL_INITIATED );

    pCall -> Unlock();

    // Release the call table lock
    g_pH323Line -> UnlockCallTable();

    // Create a new call. put it in DIALTONE mode and return its handle
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetupTransfer - Exited." ));
    return retVal;

cleanup:

    if( pCall != NULL )
    {
        pCall -> Unlock();
    }

    if( pConf != NULL )
    {
        g_pH323Line -> GetH323ConfTable() -> Remove( pConf );
        delete pConf;
        pConf = NULL;
    }

    if( pConsultCall != NULL )
    {
        pConsultCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pConsultCall;
        pCall = NULL;
    }
        
    // Release the call table lock
    g_pH323Line -> UnlockCallTable();
    return retVal;
}


/*
 
Parameters:
    dwRequestID - The identifier of the asynchronous request. 
    
    hdCall - The service provider's handle to the call to be dialed. The call
        state of hdCall can be any state except idle and disconnected. 
    
    lpszDestAddress - The destination to be dialed using the standard dialable
        number format. 

    dwCountryCode - The country code of the destination. This is used by the
        implementation to select the call progress protocols for the destination
        address. If a value of 0 is specified, a default call-progress protocol
        defined by the service provider is used. This parameter is not validated
        by TAPI when this function is called. 

    Return Values - 
        Returns dwRequestID or an error number if an error occurs. The lResult
        actual parameter of the corresponding ASYNC_COMPLETION is zero if the
        function succeeds or an error number if an error occurs. Possible return
        values are as follows: 

        LINEERR_INVALCALLHANDLE, 
        LINEERR_OPERATIONFAILED, 
        LINEERR_INVALADDRESS, 
        LINEERR_RESOURCEUNAVAIL, 
        LINEERR_INVALCOUNTRYCODE, 
        LINEERR_DIALBILLING, 
        LINEERR_INVALCALLSTATE, 
        LINEERR_DIALQUIET, 
        LINEERR_ADDRESSBLOCKED, 
        LINEERR_DIALDIALTONE, 
        LINEERR_NOMEM, 
        LINEERR_DIALPROMPT, 
        LINEERR_OPERATIONUNAVAIL. 

    Remarks -
        The service provider returns LINEERR_INVALCALLSTATE if the current state
        of the call does not allow dialing.
        The service provider carries out no dialing if it returns 
        LINEERR_INVALADDRESS.
        If the service provider returns LINEERR_DIALBILLING, LINEERR_DIALQUIET,
        LINEERR_DIALDIALTONE, or LINEERR_DIALPROMPT, it should perform none of
        the actions otherwise performed by TSPI_lineDial (for example, no 
        partial dialing, and no going offhook). This is because the service 
        provider should pre-scan the number for unsupported characters first.
        TSPI_lineDial is used for dialing on an existing call appearance; for 
        example, call handles returned from TSPI_lineMakeCall with NULL as the
        lpszDestAddress or ending in ';', call handles returned from 
        TSPI_lineSetupTransfer or TSPI_lineSetupConference. TSPI_lineDial can 
        be invoked multiple times in the course of dialing in the case of 
        multistage dialing, if the line's device capabilities permit it.
        If the string pointed to by the lpszDestAddress parameter in the 
        previous call to the TSPI_lineMakeCall or TSPI_lineDial function is 
        terminated with a semicolon, an empty string in the current call to 
        TSPI_lineDial indicates that dialing is complete.
        Multiple addresses can be provided in a single dial string separated by
        CRLF. Service providers that provide inverse multiplexing can establish
        individual physical calls with each of the addresses, and return a 
        single call handle to the aggregate of all calls to the application. 
        All addresses would use the same country code.
        Dialing is considered complete after the address has been accepted by
        the service provider, not after the call is finally connected. Service
        providers that provide inverse multiplexing may allow multiple addresses
        to be provided at once. The service provider must send LINE_CALLSTATE
        messages to TAPI to inform it about the progress of the call.

*/

LONG 
TSPIAPI 
TSPI_lineDial(
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall,          
    LPCWSTR lpszDestAddress,  
    DWORD dwCountryCode       
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwCallState;
    WCHAR*              wszMachineName;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDial - Entered." ));

    if( lpszDestAddress == NULL ) 
    {
        return LINEERR_INVALPARAM;
    }

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    
    {
        return LINEERR_INVALCALLHANDLE;
    }

    dwCallState = pCall -> GetCallState();

    if( dwCallState == LINECALLSTATE_CONNECTED )
    {
        //no need to dial the call. Inform TAPI3 about it once again.
        pCall -> ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
        goto func_exit;
    }
    
    if( dwCallState != LINECALLSTATE_DIALTONE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx no dialtone.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
    }

    pCall->SetAddressType( wAliasType );

    if( !pCall->SetCalleeAlias( (WCHAR*)lpszDestAddress, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set callee alias." ));
        pCall -> Unlock();
        // invalid destination addr
        return LINEERR_NOMEM;
    }
    
    //set the caller alias name
    if( RasIsRegistered() )
    {
        //ARQ message must have a caller alias
        PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();

        wszMachineName = pAliasList -> pItems[0].pData;
        wAliasType = pAliasList -> pItems[0].wType;
    }
    else
    {
        wszMachineName = g_pH323Line->GetMachineName();
        wAliasType = h323_ID_chosen;
    }

    //set the value for m_pCallerAliasNames
    if( !pCall->SetCallerAlias( wszMachineName, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set caller alias." ));
        pCall -> Unlock();
        
        // invalid destination addr
        return LINEERR_NOMEM;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_MAKE_CALL, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }

func_exit:

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    //create a new call. put it in DIALTONE mode and return its handle
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineDial - Exited." ));
    
    pCall -> Unlock();
    return retVal;
}


LONG
TSPIAPI
TSPI_linePrepareAddToConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function prepares an existing conference call for the addition of 
    another party.  It creates a new, temporary consultation call.  The new 
    consulatation call can be subsequently added to the conference call.

    A conference call handle can be obtained via TSPI_lineSetupConference or 
    via TSPI_lineCompleteTransfer that is resolved as a three-way conference 
    call. The function TSPI_linePrepareAddToConference typically places the 
    existing conference call in the onHoldPendingConference state and creates 
    a consultation call that can be added later to the existing conference 
    call via TSPI_lineAddToConference. 
    
    The consultation call can be canceled using TSPI_lineDrop. It may also 
    be possible for the TAPI DLL to swap between the consultation call and 
    the held conference call via TSPI_lineSwapHold.
    
    The Service Provider initially does media monitoring on the new call for
    at least the set of media modes that were monitored for on the line.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdConfCall - Specifies the Service Provider's opaque handle to a 
        conference call.  Valid call states: connected.

    htAddCall - Specifies the TAPI DLL's opaque handle to the new, temporary 
        consultation call.  The Service Provider must save this and use it in 
        all subsequent calls to the LINEEVENT procedure reporting events on 
        the new call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the new, temporary consultation 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCONFCALLHANDLE - The specified call handle for the 
            conference call is invalid.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.

        LINEERR_INVALCALLSTATE - The conference call is not in a valid state 
            for the requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The maximum number of parties for a 
            conference has been reached.

        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineSetupConference(
    DRV_REQUESTID    dwRequestID,
    HDRVCALL         hdCall,
    HDRVLINE         hdLine,
    HTAPICALL        htConfCall,
    LPHDRVCALL       lphdConfCall,
    HTAPICALL        htConsultCall,
    LPHDRVCALL       lphdConsultCall,
    DWORD            dwNumParties,
    LPLINECALLPARAMS const lpCallParams
    )
    
/*++

Routine Description:

    This function sets up a conference call for the addition of the third 
    party. 

    TSPI_lineSetupConference provides two ways for establishing a new 
    conference call, depending on whether a normal two-party call is required 
    to pre-exist or not. When setting up a conference call from an existing 
    two-party call, the hdCall parameter is a valid call handle that is 
    initially added to the conference call by the TSPI_lineSetupConference 
    request and hdLine is ignored. On switches where conference call setup 
    does not start with an existing call, hdCall must be NULL and hdLine 
    must be specified to identify the line device on which to initiate the 
    conference call.  In either case, a consultation call is allocated for 
    connecting to the party that is to be added to the call. The TAPI DLL 
    can use TSPI_lineDial to dial the address of the other party.
    
    The conference call will typically transition into the 
    onHoldPendingConference state, the consultation call dialtone state and 
    the initial call (if one) into the conferenced state.
    
    A conference call can also be set up via a TSPI_lineCompleteTransfer that 
    is resolved into a three-way conference.
    
    The TAPI DLL may be able to toggle between the consultation call and the 
    conference call by using TSPI_lineSwapHold.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the initial 
        call that identifies the first party of a conference call. In some 
        environments, a call must exist in order to start a conference call. 
        In other telephony environments, no call initially exists and hdCall 
        is left NULL.  Valid call states: connected.

    hdLine - Specifies the Service Provider's opaque handle to the line device 
        on which to originate the conference call if hdCall is NULL.  The 
        hdLine parameter is ignored if hdCall is non-NULL.  The Service 
        Provider reports which model it supports through the setupConfNull 
        flag of the LINEADDRESSCAPS data structure.

    htConfCall - Specifies the TAPI DLL's opaque handle to the new conference 
        call.  The Service Provider must save this and use it in all subsequent 
        calls to the LINEEVENT procedure reporting events on the new call.

    lphdConfCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for the newly created conference 
        call.  The Service Provider must fill this location with its opaque 
        handle for the new call before this procedure returns, whether it 
        decides to execute the request sychronously or asynchronously.  This 
        handle is invalid if the function results in an error (either 
        synchronously or asynchronously).

    htAddCall - Specifies the TAPI DLL's opaque handle to a new call.  When 
        setting up a call for the addition of a new party, a new temporary call
        (consultation call) is automatically allocated.  The Service Provider 
        must save the htAddCall and use it in all subsequent calls to the 
        LINEEVENT procedure reporting events on the new consultation call.

    lphdAddCall - Specifies a far pointer to an opaque HDRVCALL representing 
        the Service Provider's identifier for a call.  When setting up a call 
        for the addition of a new party, a new temporary call (consultation 
        call) is automatically allocated. The Service Provider must fill this 
        location with its opaque handle for the new consultation call before 
        this procedure returns, whether it decides to execute the request 
        sychronously or asynchronously.  This handle is invalid if the 
        function results in an error (either synchronously or asynchronously).

    dwNumParties - Specifies the expected number of parties in the conference 
        call.  The service provider is free to do with this number as it 
        pleases; ignore it, use it a hint to allocate the right size 
        conference bridge inside the switch, etc.

    lpCallParams - Specifies a far pointer to call parameters to be used when 
        establishing the consultation call. This parameter may be set to NULL 
        if no special call setup parameters are desired.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle for the conference 
            call is invalid.  This error may also indicate that the telephony 
            environment requires an initial call to set up a conference but a 
            NULL call handle was supplied.

        LINEERR_INVALLINEHANDLE - The specified line handle for the line 
            containing the conference call is invalid.  This error may also 
            indicate that the telephony environment requires an initial line 
            to set up a conference but a non-NULL call handle was supplied 
            instead.

        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.

        LINEERR_CALLUNAVAIL - All call appearances on the specified address 
            are currently allocated.

        LINEERR_CONFERENCEFULL - The requested number of parties cannot be 
            satisfied.

        LINEERR_INVALPOINTER - One or more of the specified pointer 
            parameters are invalid.
    
        LINEERR_INVALCALLPARAMS - The specified call parameters are invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reason.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}


LONG
TSPIAPI
TSPI_lineRemoveFromConference(
    DRV_REQUESTID dwRequestID,
    HDRVCALL      hdCall
    )
    
/*++

Routine Description:

    This function removes the specified call from the conference call to 
    which it currently belongs. The remaining calls in the conference 
    call are unaffected.

    This operation removes a party that currently belongs to a conference 
    call. After the call has been successfully removed, it may be possible 
    to further manipulate it using its handle. The availability of this 
    operation and its result are likely to be limited in many 
    implementations. For example, in many implementations, only the most 
    recently added party may be removed from a conference, and the removed 
    call may be automatically dropped (becomes idle). Consult the line's 
    device capabilities to determine the available effects of removing a 
    call from a conference.

Arguments:

    dwRequestID - Specifies the identifier of the asynchronous request.  
        The Service Provider returns this value if the function completes 
        asynchronously.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be removed from the conference.  Valid call states: conferenced.

Return Values:

    Returns zero if the function is successful, the (positive) dwRequestID 
    value if the function will be completed asynchronously, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.
        
        LINEERR_INVALCALLSTATE - The call is not in a valid state for the 
            requested operation.
    
        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}

/* 
Parameters:
    dwRequestID - The identifier of the asynchronous request. 
    hdLine - The service provider's handle to the line to be forwarded. 

    bAllAddresses - Specifies whether all originating addresses on the line or
        just the one specified is to be forwarded. If TRUE, all addresses on 
        the line are forwarded and dwAddressID is ignored; if FALSE, only the
        address specified as dwAddressID is forwarded. This parameter is not
        validated by TAPI when this function is called. 

    dwAddressID - The address on the specified line whose incoming calls are to
        be forwarded. This parameter is ignored if bAllAddresses is TRUE. This 
        parameter is not validated by TAPI when this function is called. 

    lpForwardList - A pointer to a variably sized data structure of type 
        LINEFORWARDLIST that describes the specific forwarding instructions.

    dwNumRingsNoAnswer - Specifies the number of rings before an incoming call
        is considered a "no answer." If dwNumRingsNoAnswer is out of range, the
        actual value is set to the nearest value in the allowable range. This 
        parameter is not validated by TAPI when this function is called. 

    htConsultCall - The TAPI handle to a new call, if such a call must be created
        by the service provider. In some telephony environments, forwarding a
        call has the side effect of creating a consultation call used to consult
        the party that is being forwarded to. In such an environment, the service
        provider creates the new consutation call and must save this value and
        use it in all subsequent calls to the LINEEVENT procedure reporting
        events on the call. If no consultation call is created, this value can
        be ignored by the service provider. 

    lphdConsultCall - A pointer to an HDRVCALL representing the service 
        provider's identifier for the call. In telephony environments where 
        forwarding a call has the side effect of creating a consultation call
        used to consult the party that is being forwarded to, the service 
        provider must fill this location with its handle for the call before 
        this procedure returns. The service provider is permitted to do callbacks
        regarding the new call before it returns from this procedure. If no 
        consultation call is created, the HDRVCALL must be left NULL. 

    lpCallParams - A pointer to a structure of type LINECALLPARAMS. This pointer
        is ignored by the service provider unless lineForward requires the 
        establishment of a call to the forwarding destination (and 
        lphdConsultCall is returned, in which case lpCallParams is optional). 
        If NULL, default call parameters are used. Otherwise, the specified call
        parameters are used for establishing htConsultCall. 

Return Values:
        Returns dwRequestID or an error number if an error occurs. The lResult 
        actual parameter of the corresponding ASYNC_COMPLETION is zero if the 
        function succeeds or an error number if an error occurs. Possible return
        values are as follows: 

                LINEERR_INVALLINEHANDLE, 
                LINEERR_NOMEM, 
                LINEERR_INVALADDRESS, 
                LINEERR_OPERATIONUNAVAIL, 
                LINEERR_INVALADDRESSID, 
                LINEERR_OPERATIONFAILED, 
                LINEERR_INVALCOUNTRYCODE,
                LINEERR_RESOURCEUNAVAIL, 
                LINEERR_INVALPARAM, 
                LINEERR_STRUCTURETOOSMALL. 

Remarks
*/

LONG 
TSPIAPI TSPI_lineForward(
    DRV_REQUESTID dwRequestID,           
    HDRVLINE hdLine,                     
    DWORD bAllAddresses,                 
    DWORD dwAddressID,                   
    LPLINEFORWARDLIST const lpForwardList,  
    DWORD dwNumRingsNoAnswer,            
    HTAPICALL htConsultCall,             
    LPHDRVCALL lphdConsultCall,          
    LPLINECALLPARAMS const lpCallParams  
    )
{
    DWORD               dwStatus = dwRequestID;
    PH323_CALL         pCall = NULL;
    H323_CONFERENCE *   pConf = NULL;
    BOOL                fDelete = FALSE;
    DWORD               dwState;
    PVOID               pForwardParams = NULL;
    DWORD               event = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineForward - Entered." ));
    
    //lock the line device    
    g_pH323Line -> Lock();

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        g_pH323Line ->Unlock();
        return LINEERR_RESOURCEUNAVAIL;
    }

    // validate line state
    dwState = g_pH323Line -> GetState();
    if( ( dwState != H323_LINESTATE_OPENED) &&
        ( dwState != H323_LINESTATE_LISTENING) ) 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "H323 line is not currently opened:%d.",
            dwState ));

        // release line device
        g_pH323Line ->Unlock();

        // line needs to be opened
        return LINEERR_INVALLINESTATE;
    }
    
    if( lpForwardList == NULL )
    {
        //forwarding is disabled
        g_pH323Line -> DisableCallForwarding();
        g_pH323Line ->Unlock();

        *lphdConsultCall = NULL;

        //inform the user about change in line forward state
        (*g_pfnLineEventProc)(
                g_pH323Line->m_htLine,
                (HTAPICALL)NULL,
                (DWORD)LINE_ADDRESSSTATE,
                (DWORD)LINEADDRESSSTATE_FORWARD,
                (DWORD)LINEADDRESSSTATE_FORWARD,
                (DWORD)0
                );


        // complete the async accept operation now
        H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

        return dwRequestID;
    }

    // allocate outgoing call
    pCall = new CH323Call();

    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    // save tapi handle and specify outgoing call direction
    if( !pCall -> Initialize( htConsultCall, LINECALLORIGIN_OUTBOUND,
        CALLTYPE_FORWARDCONSULT ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate outgoing call." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;
        goto cleanup;
    }

    dwStatus = pCall -> ValidateForwardParams(
        lpForwardList, &pForwardParams, &event );
    if( dwStatus != ERROR_SUCCESS )
    {
        // failure
        goto cleanup;
    }

    _ASSERTE( event );

    // transfer handle
    *lphdConsultCall = (HDRVCALL)NULL /*pCall -> GetCallHandle()*/;

    // bind outgoing call
    pConf = pCall -> CreateConference(NULL);
    if( pConf == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not create conference." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    if( !g_pH323Line -> GetH323ConfTable() -> Add(pConf) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not add conf to conf table." ));

        // no memory available
        dwStatus = LINEERR_NOMEM;

        // failure
        goto cleanup;
    }

    pCall -> Lock();

    // post line forward request to callback thread
    if( !pCall->QueueTAPICallRequest( event, (PVOID)pForwardParams ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post forward message." ));

        // could not complete operation
        dwStatus = LINEERR_OPERATIONFAILED;

        pCall-> Unlock();

        // failure
        goto cleanup;
    }
    
    g_pH323Line -> m_fForwardConsultInProgress = TRUE;
    
    if( (dwNumRingsNoAnswer >= H323_NUMRINGS_LO) &&
        (dwNumRingsNoAnswer <= H323_NUMRINGS_HI) )
    {
        g_pH323Line -> m_dwNumRingsNoAnswer = dwNumRingsNoAnswer;
    }

    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    //unlock the call object.
    pCall-> Unlock();

    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineForward - Exited." ));
    
    // success
    return dwRequestID;

cleanup:
    if( pCall != NULL )
    {
        pCall -> Shutdown( &fDelete );
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
        pCall = NULL;
    }

    *lphdConsultCall = NULL;

    if( pForwardParams != NULL )
    {
        delete pForwardParams;
        pForwardParams = NULL;
    }

    // release line device
    g_pH323Line -> Unlock();

    // failure
    return dwStatus;
}


LONG 
TSPIAPI TSPI_lineRedirect(
    DRV_REQUESTID dwRequestID,
    HDRVCALL hdCall,
    LPCWSTR lpszDestAddress,
    DWORD dwCountryCode
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;
    CALLREROUTINGINFO*  pCallReroutingInfo = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD               dwAddrLen;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRedirect - Entered." ));

    if( lpszDestAddress == NULL ) 
        return LINEERR_INVALPARAM;

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( pCall -> GetCallState() != LINECALLSTATE_OFFERING )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( (*lpszDestAddress==L'T') &&
        IsValidE164String((WCHAR*)lpszDestAddress+1) )
    {
        wAliasType = e164_chosen;
        //strip off the leading 'T'
        lpszDestAddress++;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }
    else if( IsValidE164String( (WCHAR*)lpszDestAddress) )
    {
        wAliasType = e164_chosen;
        dwMaxAddrSize = MAX_E164_ADDR_LEN;
    }

    dwAddrLen = wcslen(lpszDestAddress);
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) )
    {
        return LINEERR_INVALPARAM;
    }

    retVal = pCall -> SetDivertedToAlias( (WCHAR*)lpszDestAddress, wAliasType );
    if(  retVal != NOERROR )
    {
        pCall->Unlock();
        return retVal;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_DIVERT, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post call divert event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRedirect - Exited." ));
    return dwRequestID;
}



LONG TSPIAPI TSPI_lineUnhold (
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall             
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineUnHold - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( pCall -> IsCallOnHold() == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_UNHOLD, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineUnHold - Exited." ));
    return dwRequestID;
}


LONG TSPIAPI TSPI_lineHold(
    DRV_REQUESTID dwRequestID,  
    HDRVCALL hdCall             
    )
{
    LONG                retVal = (DWORD)dwRequestID;
    PH323_CALL          pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineHold - Entered." ));

    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        return LINEERR_INVALCALLHANDLE;
    }

    if( (pCall -> GetCallState() != LINECALLSTATE_CONNECTED) ||
        (pCall -> IsCallOnHold()) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "call 0x%08lx not ringback.", pCall ));
        pCall -> Unlock();
        return LINEERR_INVALCALLSTATE;
    }

    if( !pCall -> QueueTAPICallRequest( TSPI_CALL_HOLD, NULL ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post transfer complete event." ));
        pCall -> Unlock();
        return LINEERR_OPERATIONFAILED;
    }
    
    // complete the async accept operation now
    H323CompleteRequest (dwRequestID, ERROR_SUCCESS);

    pCall -> Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineHold - Exited." ));
    return retVal;
}


BOOL
CH323Call::ResolveToIPAddress( 
                    IN WCHAR* pwszAddr,
                    IN SOCKADDR_IN* psaAddr
                  )
{
    CHAR szDelimiters[] = "@ \t\n";
    CHAR szAddr[H323_MAXDESTNAMELEN+1];
    LPSTR pszUser = NULL;
    LPSTR pszDomain = NULL;
    DWORD           dwIPAddr;
    struct hostent* pHost;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "ResolveToIPAddress entered:%p.",this ));

    ZeroMemory( psaAddr, sizeof(SOCKADDR) );

    // validate pointerr
    if (pwszAddr == NULL)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "null destination address." ));

        // failure
        return FALSE;
    }


    // convert address from unicode
    if (WideCharToMultiByte(
            CP_ACP,
            0,
            pwszAddr,
            -1,
            szAddr,
            sizeof(szAddr),
            NULL,
            NULL
            ) == 0)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not convert address from unicode." ));

        // failure
        return FALSE;
    }

    // check whether phone number has been specified
    if( IsPhoneNumber( szAddr ) )
    {
        // need to direct call to pstn gateway
        
        if ((g_RegistrySettings.fIsGatewayEnabled == FALSE) ||
        (g_RegistrySettings.gatewayAddr.nAddrType == 0))
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "pstn gateway not specified." ));

            // failure
            return FALSE;
        }

        psaAddr->sin_family = AF_INET;
        psaAddr->sin_addr.S_un.S_addr =
            htonl( g_RegistrySettings.gatewayAddr.Addr.IP_Binary.dwAddr );
        psaAddr->sin_port = g_RegistrySettings.gatewayAddr.Addr.IP_Binary.wPort;
        return TRUE;
    }

    // parse user name
    pszUser = strtok(szAddr, szDelimiters);

    // parse domain name
    pszDomain = strtok(NULL, szDelimiters);

    // validate pointer
    if (pszUser == NULL)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not parse destination address." ));

        // failure
        return FALSE;
    }

    // validate pointer
    if (pszDomain == NULL)
    {
        // switch pointers
        pszDomain = pszUser;

        // re-initialize
        pszUser = NULL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE,
        "resolving user %s domain %s.",
        pszUser, pszDomain ));
    
    // attempt to convert ip address
    dwIPAddr = inet_addr(szAddr);

    // see if address converted
    if( dwIPAddr == INADDR_NONE )
    {
        // attempt to lookup hostname
        pHost = gethostbyname(szAddr);

        // validate pointer
        if( pHost != NULL )
        {
            // retrieve host address from structure
            dwIPAddr = *(unsigned long *)pHost->h_addr;
        }
    }

    // see if address converted
    if( dwIPAddr == INADDR_NONE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
                  "error 0x%08lx resolving IP address.",
                  WSAGetLastError() ));

        // make sure proxy has been specified
        if ((g_RegistrySettings.fIsProxyEnabled == FALSE) ||
            (g_RegistrySettings.proxyAddr.nAddrType == 0))
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "proxy not specified." ));

            // failure
            return FALSE;
        }

        psaAddr->sin_family = AF_INET;
        psaAddr->sin_addr.S_un.S_addr = 
            htonl( g_RegistrySettings.proxyAddr.Addr.IP_Binary.dwAddr );
        psaAddr->sin_port = g_RegistrySettings.proxyAddr.Addr.IP_Binary.wPort;

        return TRUE;
    }

    // save converted address
    psaAddr->sin_family = AF_INET;
    psaAddr->sin_addr.S_un.S_addr = dwIPAddr;

    H323DBG(( DEBUG_LEVEL_TRACE,
        "callee address resolved to %s:%d.",
        H323AddrToString(dwIPAddr),
        m_CalleeAddr.Addr.IP_Binary.wPort ));

    return TRUE;
}


//!!always called in a lock
LONG
CH323Line::CopyAddressForwardInfo(
                                  IN LPLINEADDRESSSTATUS lpAddressStatus
                                 )
{
    LINEFORWARD * lineForwardStructArray;
    LPFORWARDADDRESS pForwardedAddress;

    if( m_pCallForwardParams-> fForwardForAllOrigins == TRUE )
    {
        lpAddressStatus->dwForwardNumEntries = 1;
        lpAddressStatus->dwForwardSize = sizeof(LINEFORWARD) + 
            sizeof(WCHAR) * (m_pCallForwardParams->divertedToAlias.wDataLength+1);
    }
    else
    {
        lpAddressStatus->dwForwardNumEntries = 0;

        pForwardedAddress = m_pCallForwardParams->pForwardedAddresses;

        while( pForwardedAddress )
        {
            lpAddressStatus->dwForwardNumEntries++;
            lpAddressStatus->dwForwardSize += sizeof(LINEFORWARD) + 
                sizeof(WCHAR) * (pForwardedAddress->callerAlias.wDataLength+1) +
                sizeof(WCHAR) * (pForwardedAddress->divertedToAlias.wDataLength+1);

            pForwardedAddress = pForwardedAddress->next;
        }
    }

    lpAddressStatus->dwNeededSize += lpAddressStatus->dwForwardSize;
    if( lpAddressStatus->dwTotalSize < lpAddressStatus->dwNeededSize )
    {
        return LINEERR_STRUCTURETOOSMALL;
    }

    lineForwardStructArray = (LINEFORWARD*)
        ((BYTE*)lpAddressStatus + lpAddressStatus->dwUsedSize);
    
    lpAddressStatus->dwUsedSize += lpAddressStatus->dwForwardNumEntries * 
        sizeof(LINEFORWARD);

    if( m_pCallForwardParams-> fForwardForAllOrigins == TRUE )
    {
        //copy the first structure
        lineForwardStructArray[0].dwForwardMode = 
            m_pCallForwardParams->dwForwardTypeForAllOrigins;

        //copy dest address alias
        lineForwardStructArray[0].dwDestAddressOffset =
            lpAddressStatus->dwUsedSize;

        lineForwardStructArray[0].dwDestAddressSize =
            sizeof(WCHAR)* (m_pCallForwardParams->divertedToAlias.wDataLength + 1);
        
        CopyMemory(
            (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
            m_pCallForwardParams->divertedToAlias.pData,
            lineForwardStructArray[0].dwDestAddressSize );

        lpAddressStatus->dwUsedSize +=
            lineForwardStructArray[0].dwDestAddressSize;

        lineForwardStructArray[0].dwDestCountryCode = 0;
    }
    else
    {
        pForwardedAddress = m_pCallForwardParams->pForwardedAddresses;

        for( DWORD indexI = 0; indexI < lpAddressStatus->dwForwardNumEntries; indexI++ )
        {
            _ASSERTE( pForwardedAddress );

            lineForwardStructArray[indexI].dwForwardMode =
                pForwardedAddress->dwForwardType;

            //copy caller address alias
            lineForwardStructArray[indexI].dwCallerAddressOffset = 
                lpAddressStatus->dwUsedSize;

            lineForwardStructArray[indexI].dwCallerAddressSize = 
                sizeof(WCHAR)* (pForwardedAddress->callerAlias.wDataLength + 1);
        
            CopyMemory( 
                (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
                (PVOID)pForwardedAddress->callerAlias.pData,
                lineForwardStructArray[indexI].dwCallerAddressSize );

            lpAddressStatus->dwUsedSize +=
                lineForwardStructArray[indexI].dwCallerAddressSize;
        
            //copy dest address alias
            lineForwardStructArray[indexI].dwDestAddressOffset = 
                lpAddressStatus->dwUsedSize;

            lineForwardStructArray[indexI].dwDestAddressSize = 
                sizeof(WCHAR)* (pForwardedAddress->divertedToAlias.wDataLength + 1);
        
            CopyMemory( 
                (PVOID)((BYTE*)lpAddressStatus+lpAddressStatus->dwUsedSize),
                pForwardedAddress->divertedToAlias.pData,
                lineForwardStructArray[indexI].dwDestAddressSize);

            lpAddressStatus->dwUsedSize +=
                lineForwardStructArray[indexI].dwDestAddressSize;

            lineForwardStructArray[indexI].dwDestCountryCode = 0;

            pForwardedAddress = pForwardedAddress->next;
        }
    }

    _ASSERTE( lpAddressStatus->dwUsedSize == lpAddressStatus->dwNeededSize);
    return NOERROR;
}


//!!always called in a lock
LONG
CH323Call::ValidateForwardParams(
    IN  LPLINEFORWARDLIST lpLineForwardList,
    OUT PVOID*            ppForwardParams,
    OUT DWORD*            pEvent
    )
{
    LPLINEFORWARD       pLineForwardStruct;
    LPWSTR              pwszDestAddr = NULL;
    LPWSTR              pAllocAddrBuffer = NULL;
    DWORD               dwStatus = ERROR_SUCCESS;
    CALLFORWARDPARAMS * pCallForwardParams = NULL;
    FORWARDADDRESS *    pForwardAddress = NULL;
    WORD                wAliasType = h323_ID_chosen;
    DWORD               dwMaxAddrSize = MAX_H323_ADDR_LEN;
    DWORD               dwAddrLen;

    *pEvent = 0;

    if( (lpLineForwardList->dwNumEntries == 0) || 
        (lpLineForwardList->dwTotalSize == 0) )
    {
        return LINEERR_INVALPARAM;
    }

    pLineForwardStruct = &(lpLineForwardList->ForwardList[0]);

	if( pLineForwardStruct->dwDestAddressSize == 0 )
	{
		return LINEERR_INVALPARAM;
	}

    //resolve the diverted-to address
    pAllocAddrBuffer = pwszDestAddr =
        (WCHAR*)new BYTE[pLineForwardStruct->dwDestAddressSize];

    if( pwszDestAddr == NULL )
    {
        return LINEERR_NOMEM;
    }

    CopyMemory( pwszDestAddr, 
        (BYTE*)lpLineForwardList + pLineForwardStruct->dwDestAddressOffset,
        pLineForwardStruct->dwDestAddressSize );
                            
    //If negotiated version is 3.1 get the alias type
    if( g_dwTSPIVersion >= 0x00030001 )
    {
        switch( pLineForwardStruct->dwDestAddressType )
        {
        case LINEADDRESSTYPE_PHONENUMBER:

            wAliasType = e164_chosen;
            if( *pwszDestAddr == L'T' )
            {
                //strip off the leading 'T'
                pwszDestAddr++;
            }
            
            if( IsValidE164String( (WCHAR*)pwszDestAddr) == FALSE )
            {
                delete pAllocAddrBuffer;
                return LINEERR_INVALPARAM;
            }
                            
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
            break;

        case LINEADDRESSTYPE_DOMAINNAME: 
        case LINEADDRESSTYPE_IPADDRESS:
            wAliasType = h323_ID_chosen;
            break;

        default:
            H323DBG(( DEBUG_LEVEL_VERBOSE, "Wrong address type:.",
                 pLineForwardStruct->dwDestAddressType ));

            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }
    }
    else
    {
        if( (*pwszDestAddr==L'T') &&
            IsValidE164String((WCHAR*)pwszDestAddr+1) )
        {
            wAliasType = e164_chosen;
            //strip off the leading 'T'
            pwszDestAddr++;
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
        }
        else if( IsValidE164String( (WCHAR*)pwszDestAddr) )
        {
            wAliasType = e164_chosen;
            dwMaxAddrSize = MAX_E164_ADDR_LEN;
        }
    }

    dwAddrLen = wcslen( pwszDestAddr );
    if( (dwAddrLen > dwMaxAddrSize) || (dwAddrLen == 0) )
    {
        delete pAllocAddrBuffer;       
        return LINEERR_INVALPARAM;
    }

    m_dwAddressType = wAliasType;
    
    //don't resolve the address if GK enabled
    if( !ResolveAddress( pwszDestAddr ) )
    {
        if( !RasIsRegistered())
        {
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }
    }
    else if(m_CallerAddr.Addr.IP_Binary.dwAddr == HOST_LOCAL_IP_ADDR_INTERFACE )
    {
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;
    }

    if( !SetCalleeAlias( (WCHAR*)pwszDestAddr, wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not set callee alias." ));
        delete pAllocAddrBuffer;
        return LINEERR_NOMEM;
    }

    switch( pLineForwardStruct->dwForwardMode )
    {
    case LINEFORWARDMODE_UNCOND:
    case LINEFORWARDMODE_BUSY:
    case LINEFORWARDMODE_NOANSW:
    case LINEFORWARDMODE_BUSYNA:

        pCallForwardParams = new CALLFORWARDPARAMS;
        if( pCallForwardParams == NULL )
        {
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
        }

        ZeroMemory( pCallForwardParams, sizeof(CALLFORWARDPARAMS) );

        //Forward all calls unconditionally, irrespective of their origin.
        pCallForwardParams->fForwardForAllOrigins = TRUE;
        pCallForwardParams->dwForwardTypeForAllOrigins =
            pLineForwardStruct->dwForwardMode;

        //set the diverted-to alias
        pCallForwardParams->divertedToAlias.wType = wAliasType;
        pCallForwardParams->divertedToAlias.wPrefixLength = 0;
        pCallForwardParams->divertedToAlias.pPrefix = NULL;
        pCallForwardParams->divertedToAlias.wDataLength = 
            (WORD)wcslen(pwszDestAddr);// UNICODE character count
        pCallForwardParams->divertedToAlias.pData =  pwszDestAddr;

        //enable forwarding
        pCallForwardParams->fForwardingEnabled = TRUE;

        *ppForwardParams = (PVOID)pCallForwardParams;
        *pEvent = TSPI_LINEFORWARD_NOSPECIFIC;
        
        break;

    case LINEFORWARDMODE_BUSYNASPECIFIC:
    case LINEFORWARDMODE_UNCONDSPECIFIC:
    case LINEFORWARDMODE_BUSYSPECIFIC:
    case LINEFORWARDMODE_NOANSWSPECIFIC:

        if( pLineForwardStruct-> dwCallerAddressSize == 0 )
        {
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }

        /*if( g_pH323Line->ForwardEnabledForAllOrigins() )
        {
            //specific forward can't be enabled when non-specific forward for
            //all caller addresses is enabled
            delete pAllocAddrBuffer;
            return LINEERR_INVALPARAM;
        }*/

        pForwardAddress = new FORWARDADDRESS;
        if( pForwardAddress == NULL )
        {
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
        }

        ZeroMemory( pForwardAddress, sizeof(FORWARDADDRESS) );
        pForwardAddress->dwForwardType = pLineForwardStruct->dwForwardMode;

        //set the caller alias(alias to be forward).
        pForwardAddress->callerAlias.wType = h323_ID_chosen;
        
		pForwardAddress->callerAlias.pData = 
			(WCHAR*)new BYTE[pLineForwardStruct-> dwCallerAddressSize];
		if( pForwardAddress->callerAlias.pData == NULL )
		{
			delete pForwardAddress;
            delete pAllocAddrBuffer;
            return LINEERR_NOMEM;
		}

        CopyMemory( pForwardAddress->callerAlias.pData,
            (BYTE*)lpLineForwardList + pLineForwardStruct->dwCallerAddressOffset,
            pLineForwardStruct-> dwCallerAddressSize );

        pForwardAddress->callerAlias.wDataLength = 
            (WORD)wcslen( pForwardAddress->callerAlias.pData );

        //set the diverted-to alias.
        pForwardAddress->divertedToAlias.wType = wAliasType;
        pForwardAddress->divertedToAlias.wDataLength = 
            (WORD)wcslen( pwszDestAddr );
        pForwardAddress->divertedToAlias.pData =  pwszDestAddr;

        //set the diverted-to address
        /*pForwardAddress->saDivertedToAddr.sin_family = AF_INET;
        pForwardAddress->saDivertedToAddr.sin_addr.S_un.S_addr
            = htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );
        pForwardAddress->saDivertedToAddr.sin_port = 
            htons( m_CalleeAddr.Addr.IP_Binary.wPort );*/

        //here we could have a for loop and process multiple pLineForwardStructs
        
        //post the event for line forward
        *ppForwardParams = (PVOID)pForwardAddress;
        *pEvent = TSPI_LINEFORWARD_SPECIFIC;

        break;

    case LINEFORWARDMODE_UNCONDINTERNAL:
    case LINEFORWARDMODE_UNCONDEXTERNAL:
    case LINEFORWARDMODE_BUSYINTERNAL:
    case LINEFORWARDMODE_BUSYEXTERNAL:
    case LINEFORWARDMODE_NOANSWINTERNAL:
    case LINEFORWARDMODE_NOANSWEXTERNAL:
    case LINEFORWARDMODE_BUSYNAINTERNAL:
    case LINEFORWARDMODE_BUSYNAEXTERNAL:
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;

    default:
        delete pAllocAddrBuffer;
        return LINEERR_INVALPARAM;
    }

    return ERROR_SUCCESS;
}


void
CH323Call::Forward( 
    DWORD    event, 
    PVOID    pForwardInfo
    )
{
    WCHAR * pwszDialableAddr;
    WCHAR * wszMachineName;
    WORD    wAliasType = h323_ID_chosen;

    if( event == TSPI_LINEFORWARD_SPECIFIC )
    {
        m_pForwardAddress = (LPFORWARDADDRESS)pForwardInfo;
        pwszDialableAddr = m_pForwardAddress->divertedToAlias.pData;
        wAliasType = m_pForwardAddress->divertedToAlias.wType;
    }
    else if( event == TSPI_LINEFORWARD_NOSPECIFIC )
    {
        m_pCallForwardParams = (CALLFORWARDPARAMS*)pForwardInfo;
        pwszDialableAddr = m_pCallForwardParams->divertedToAlias.pData;
        wAliasType = m_pCallForwardParams->divertedToAlias.wType;
    }
    else
    {
        // Wrong event, shouldn't get
        // here at all...
        return;
    }

    _ASSERTE( pwszDialableAddr );
    //set the values for m_pCalleeAliasNames
    if( !AddAliasItem( m_pCalleeAliasNames,
            (BYTE*)(pwszDialableAddr),
            sizeof(WCHAR) * (wcslen(pwszDialableAddr) + 1 ),
            wAliasType ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate callee name." ));

        DropCall( 0 );
    }
        
    if( RasIsRegistered() )
    {
        PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();
    
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        if( !AddAliasItem( m_pCallerAliasNames,
            pAliasList->pItems[0].pData,
            pAliasList->pItems[0].wType ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));

            DropCall( 0 );
        }
        //set the value of m_pCalleeAddr
        else if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
        {
            // drop call using disconnect mode
            DropCall( 0 );
        }
            
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }
    else
    {
        wszMachineName = g_pH323Line->GetMachineName();
    
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        //set the value for m_pCallerAliasNames
        if( !AddAliasItem( m_pCallerAliasNames,
            (BYTE*)(wszMachineName),
            sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
            h323_ID_chosen ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));

            DropCall( 0 );
        }
        else if( !PlaceCall() )
        {
            // drop call using disconnect mode
            DropCall( LINEDISCONNECTMODE_UNREACHABLE );
        }
            
        H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }
}


//returns the alias of the divertedTo endpoint
PH323_ALIASITEM
CH323Line::CallToBeDiverted(
    IN WCHAR* pwszCallerName,
    IN DWORD  dwCallerNameSize,
    IN DWORD dwForwardMode
    )
{
    LPFORWARDADDRESS    pForwardAddress;
    DWORD               dwForwardCallerLength;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallToBeDiverted entered:%p.", this ));
    
    if( (m_pCallForwardParams == NULL) || 
        (!m_pCallForwardParams->fForwardingEnabled) )
    {
        return NULL;
    }

    if( m_pCallForwardParams->fForwardForAllOrigins == TRUE )
    {
        if( m_pCallForwardParams->dwForwardTypeForAllOrigins & dwForwardMode )
        {
            return &(m_pCallForwardParams->divertedToAlias);
        }
        
        if( m_pCallForwardParams->dwForwardTypeForAllOrigins == 
            LINEFORWARDMODE_BUSYNA )
        {
            if( (dwForwardMode == LINEFORWARDMODE_BUSY) ||
                (dwForwardMode == LINEFORWARDMODE_NOANSW) )
            {
                return &(m_pCallForwardParams->divertedToAlias);
            }
        }
    }

    if( pwszCallerName == NULL )
    {
        return NULL;
    }

    pForwardAddress = m_pCallForwardParams->pForwardedAddresses;

    while( pForwardAddress )
    {
        dwForwardCallerLength = (pForwardAddress->callerAlias.wDataLength +1)*sizeof(WCHAR);

        if( (dwForwardCallerLength == dwCallerNameSize) && 
            (memcmp( pwszCallerName, (PVOID)(pForwardAddress->callerAlias.pData), 
                dwCallerNameSize) == 0 ) )
        {
            if( pForwardAddress->dwForwardType & dwForwardMode )
                return &(pForwardAddress->divertedToAlias);

            if( pForwardAddress->dwForwardType == LINEFORWARDMODE_BUSYNA )
            {
                if( (dwForwardMode == LINEFORWARDMODE_BUSY) ||
                    (dwForwardMode == LINEFORWARDMODE_NOANSW) )
                {
                    return &(pForwardAddress->divertedToAlias);
                }
            }

            return NULL;
        }

        pForwardAddress = pForwardAddress->next;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallToBeDiverted exited:%p.", this ));
    return NULL;
}

LONG 
TSPIAPI 
TSPI_lineSetStatusMessages(
                            HDRVLINE hdLine,    
                            DWORD dwLineStates,
                            DWORD dwAddressStates  
                          )
{

    return NOERROR;
}


#if   DBG

DWORD
SendMSPMessageOnRelatedCall(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return SendMSPMessageOnRelatedCallFre( ContextParameter );
    }
    __except( 1 )
    {
        MSPMessageData* pMSPMessageData = (MSPMessageData*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "TSPI event threw exception: %p, %d, %p, %d, %p.",
            pMSPMessageData -> hdCall,
            pMSPMessageData -> messageType,
            pMSPMessageData -> pbEncodedBuf,
            pMSPMessageData -> wLength,
            pMSPMessageData -> hReplacementCall ));
        
        _ASSERTE( FALSE );
                
        return 0;
    }
}

#endif


DWORD
SendMSPMessageOnRelatedCallFre(
    IN PVOID ContextParameter
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SendMSPMessageOnRelatedCall entered." ));

    _ASSERTE( ContextParameter );
    MSPMessageData* pMSPMessageData = (MSPMessageData*)ContextParameter;

    PH323_CALL pCall = NULL;

    pCall = g_pH323Line->FindH323CallAndLock(pMSPMessageData -> hdCall);
    if( pCall != NULL )
    {
        pCall -> SendMSPMessage( pMSPMessageData->messageType, 
            pMSPMessageData->pbEncodedBuf, pMSPMessageData->wLength,
            pMSPMessageData->hReplacementCall );

        pCall -> Unlock();
    }

    if( pMSPMessageData->pbEncodedBuf != NULL )
    {
        delete pMSPMessageData->pbEncodedBuf;
    }
    
    delete pMSPMessageData;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SendMSPMessageOnRelatedCall exited." ));
    return EXIT_SUCCESS;
}

        
// static
void
NTAPI CH323Call::CTIdentifyExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentity expired event recvd." ));
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);
    if( pCall != NULL )
    {
        pCall -> CTIdentifyExpired();           
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyExpiredCallback exited." ));
}


// static
void
NTAPI CH323Call::CTIdentifyRRExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyRRExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentity expired event recvd." ));
    
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);
    
    if( pCall != NULL )
    {
        pCall -> CTIdentifyRRExpired();           
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTIdentifyRRExpiredCallback exited." ));
}


// static
void
NTAPI CH323Call::CTInitiateExpiredCallback(
    IN PVOID	DriverCallHandle,		// HDRVCALL
    IN BOOLEAN bTimer
    )
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiateExpiredCallback entered." ));
    
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiate expired event recvd." ));
    
    if( !QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL)DriverCallHandle,
            NULL,
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "could not post close call event." ));
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CTInitiateExpiredCallback exited." ));
}


void
CH323Call::CTIdentifyExpired()
{
    if( m_hCTIdentifyTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
        m_hCTIdentifyTimer = NULL;
    }

    if( m_dwCallDiversionState !=  H4502_CIIDENTIFY_RRSUCC )
    {
        CloseCall( 0 );
    }
}


void
CH323Call::CTIdentifyRRExpired()
{
    if( m_hCTIdentifyRRTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
        m_hCTIdentifyRRTimer = NULL;
    }

    if( m_dwCallDiversionState !=  H4502_CTSETUP_RECV )
    {
        CloseCall( 0 );
    }
}


void
NTAPI CH323Call::CallDivertOnNACallback(
                                        IN PVOID   Parameter1,
                                        IN BOOLEAN bTimer
                                       )
{
    PH323_CALL pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallDivertOnNACallback entered." ));

    //if the timer expired
    _ASSERTE( bTimer );

    pCall=g_pH323Line -> FindH323CallAndLock( (HDRVCALL)Parameter1 );
    
    if( pCall != NULL )
    {
        pCall -> CallDivertOnNoAnswer();
        pCall -> Unlock();
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "CallDivertOnNACallback exited." ));
}


//!!always called in a lock
void
CH323Call::CallDivertOnNoAnswer()
{
    //stop the timer that caused this event
    if( m_hCallDivertOnNATimer != NULL )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hCallDivertOnNATimer, NULL);
        m_hCallDivertOnNATimer = NULL;
    }

    //Make sure that the call is still alerting, it has not ben accepted and
    //it has not been transfered in the mean time
    if( (m_dwCallState != LINECALLSTATE_OFFERING) ||
        (m_fCallAccepted == TRUE) ||
        (m_dwCallType & CALLTYPE_TRANSFERED2_CONSULT)
      )
    {
        return;
    }

    //divert the call. divertedToAlias is already set, so pass NULL
    if( !InitiateCallDiversion( NULL, DiversionReason_cfnr) )
    {
        //shutdown the Q931 call
        CloseCall( 0 );
    }
}


BOOL
CH323Call::SendCTInitiateMessagee(
    IN CTIdentifyRes * pCTIdentifyRes
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SendCTInitiateMessagee entered:%p.", this ));
    
    //get the cookie for transferred call
    CopyMemory( (PVOID)m_pCTCallIdentity, (PVOID)pCTIdentifyRes->callIdentity,
        sizeof(pCTIdentifyRes->callIdentity) );

    if( m_pTransferedToAlias != NULL )
    {
        FreeAliasNames( m_pTransferedToAlias );
        m_pTransferedToAlias = NULL;
    }

    //argument.reroutingNr
    if( !AliasAddrToAliasNames( &m_pTransferedToAlias,
        (PSetup_UUIE_sourceAddress)
        (pCTIdentifyRes->reroutingNumber.destinationAddress) ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "couldn't allocate for T-2 alias:%p.", this ));
        return FALSE;
    }

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTIdentifyRes,
        CTIdentifyRes_PDU );

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
            CTINITIATE_OPCODE | H450_INVOKE ) )
    {
        return FALSE;
    }

    m_dwCallDiversionState = H4502_CTINITIATE_SENT;
        
    //start the timer for CTIdenity message
    if( !CreateTimerQueueTimer(
	        &m_hCTInitiateTimer,
	        H323TimerQueue,
	        CH323Call::CTInitiateExpiredCallback,
	        (PVOID)m_hdCall,
	        CTINITIATE_SENT_TIMEOUT, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        CloseCall( 0 );
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "SendCTInitiateMessagee exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::InitiateCallDiversion(
    IN PH323_ALIASITEM pwszDivertedToAlias,
    IN DiversionReason eDiversionMode
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateCallDiversion entered:%p.", this ));
    
    m_dwCallType |= CALLTYPE_DIVERTED_SERVED;

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        if( m_pCallReroutingInfo == NULL )
        {
            return FALSE;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    m_pCallReroutingInfo ->diversionReason = eDiversionMode;
    
    m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;
    if( m_pCallReroutingInfo->divertingNrAlias == NULL )
    {
        goto cleanup;
    }
    
    ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
        sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias, 
        (BYTE*)m_pCalleeAliasNames->pItems[0].pData, 
        sizeof(WCHAR) * (m_pCalleeAliasNames->pItems[0].wDataLength+1),
        m_pCalleeAliasNames->pItems[0].wType ) )
    {
        goto cleanup;
    }
    
    if( m_pCallReroutingInfo->originalCalledNr == NULL )
    {
        m_pCallReroutingInfo->originalCalledNr = new H323_ALIASNAMES;
        if( m_pCallReroutingInfo->originalCalledNr == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo->originalCalledNr, 
            sizeof(H323_ALIASNAMES) );

        if( !AddAliasItem( 
                m_pCallReroutingInfo->originalCalledNr, 
                (BYTE*)m_pCalleeAliasNames->pItems[0].pData, 
                sizeof(WCHAR) * (m_pCalleeAliasNames->pItems[0].wDataLength+1),
                m_pCalleeAliasNames->pItems[0].wType )
          )
        {
            goto cleanup;
        }
    }

    if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
    {
        _ASSERTE( pwszDivertedToAlias );

        m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
        
        if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo->divertedToNrAlias, 
            sizeof(H323_ALIASNAMES) );

        if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias, 
            (BYTE*)pwszDivertedToAlias->pData, 
            sizeof(WCHAR) * (wcslen(pwszDivertedToAlias->pData) +1),
            pwszDivertedToAlias->wType
            ) )
        {
            goto cleanup;
        }
    }

    if( !SendQ931Message( NO_INVOKEID, 0, 0, FACILITYMESSAGETYPE,
        CALLREROUTING_OPCODE | H450_INVOKE ) )
    {
        goto cleanup;
    }

    m_dwCallDiversionState = H4503_CALLREROUTING_SENT;

    if( !CreateTimerQueueTimer(
	        &m_hCallReroutingTimer,
	        H323TimerQueue,
            CH323Call::CallReroutingTimerCallback,
	        (PVOID)m_hdCall,
	        CALLREROUTING_EXPIRE_TIME, 0,
	        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE) )
    {
        goto cleanup;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "InitiateCallDiversion exited:%p.", this ));
    return TRUE;

cleanup:
    
    FreeCallReroutingInfo();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\config.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    TAPI Service Provider functions related to tsp config.

        TSPI_providerConfig

        TUISPI_providerConfig

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "config.h"
#include "ras.h"
#include "q931obj.h"

extern RAS_CLIENT           g_RasClient;
extern Q931_LISTENER		Q931Listener;

TUISPIDLLCALLBACK    g_pfnUIDLLCallback = NULL;

typedef struct _H323_DIALOG_DATA
{
    DWORD   dwRegState;
    WORD    wListenPort;

} H323_DIALOG_DATA, *PH323_DIALOG_DATA;

//                                                                           
// Public procedures                                                         
//                                                                           


INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HKEY hKey;
    LONG lStatus;
    DWORD dwValue;
    DWORD dwValueSize;
    DWORD dwValueType;
    DWORD dwGKEnabled;
    LPTSTR pszValue;
    TCHAR szAddr[H323_MAXPATHNAMELEN+1];
    char  szValue[H323_MAXPATHNAMELEN+1];
    TCHAR szErrorMsg[H323_MAXPATHNAMELEN];
    H323_DIALOG_DATA DialogData;
    DWORD dwTimeoutValue;
    DWORD dwPortValue;

   static const DWORD IDD_GATEWAY_HelpIDs[]=
   {
        IDC_GATEWAY_GROUP,      IDH_H323SP_USE_GATEWAY,                         // group
        IDC_USEGATEWAY,         IDH_H323SP_USE_GATEWAY,                         // checkbox
        IDC_H323_GATEWAY,       IDH_H323SP_USE_GATEWAY_COMPUTER,    // edit box
        IDC_PROXY_GROUP,        IDH_H323SP_USE_PROXY,                           // group
        IDC_USEPROXY,           IDH_H323SP_USE_PROXY,                           // checkbox
        IDC_H323_PROXY,         IDH_H323SP_USE_PROXY_COMPUTER,      // edit box

        IDC_GK_GROUP,           IDH_H323SP_GK_GROUP,           

        IDC_H323_GK,            IDH_H323SP_GK,            
        IDC_H323_GK_PHONE,      IDH_H323SP_GK_PHONE,      
        IDC_H323_GK_ACCT,       IDH_H323SP_GK_ACCT,       

        IDC_USEGK,              IDH_H323SP_USEGK,              
        IDC_USEGK_PHONE,        IDH_H323SP_USEGK_PHONE,        
        IDC_USEGK_ACCT,         IDH_H323SP_USEGK_ACCT,         
        IDC_REGSTATE,           IDH_H323SP_REGSTATE,           
        IDUPDATE,               IDH_H323SP_UPDATE_REGISTRATION_STATE,             

        IDC_CC_GROUP,           IDH_H323SP_CC_GROUP,           
        IDC_H323_CALL_TIMEOUT,  IDH_H323SP_CALL_TIMEOUT,  
        IDC_STATIC1,            IDH_H323SP_CALL_TIMEOUT,  
        IDC_H323_CALL_PORT,     IDH_H323SP_CALL_PORT,     
        IDC_STATIC2,            IDH_H323SP_CALL_PORT,     
        IDC_LISTENPORT,         IDH_H323SP_CURRENT_LISTENPORT,         
        IDC_STATIC3,            IDH_H323SP_CURRENT_LISTENPORT,         
        IDUPDATE_PORT,          IDH_H323SP_UPDATE_PORT,        

        IDC_STATIC,             IDH_NOHELP,                                                     // graphic(s)
        0,                      0
    };

    // decode
    switch (uMsg)
    {
    case WM_HELP:

        // F1 key or the "?" button is pressed
        (void) WinHelp(
                    (HWND)(((LPHELPINFO) lParam)->hItemHandle),
                    H323SP_HELP_FILE,
                    HELP_WM_HELP,
                    (DWORD_PTR) (LPVOID)IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_CONTEXTMENU:

        // Right-mouse click on a dialog control
        (void) WinHelp(
                    (HWND) wParam,
                    H323SP_HELP_FILE,
                    HELP_CONTEXTMENU,
                    (DWORD_PTR) (LPVOID) IDD_GATEWAY_HelpIDs
                    );

        break;

    case WM_INITDIALOG:

        lStatus = (*g_pfnUIDLLCallback)(
            g_dwPermanentProviderID,
            TUISPIDLL_OBJECT_PROVIDERID,
            (LPVOID)&DialogData,
            sizeof(DialogData) );

        // validate status
        if( lStatus == NOERROR )
        {
            if( DialogData.dwRegState == RAS_REGISTER_STATE_REGISTERED )
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            else if( DialogData.dwRegState == RAS_REGISTER_STATE_RRQSENT )
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_REGISTRATION_INPROGRESS,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            else
            {
                // load status string
                LoadString(g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
        
            if( DialogData.wListenPort != 0 )
            {
                SetDlgItemInt( hDlg, IDC_LISTENPORT,  DialogData.wListenPort,
                    FALSE );
            }
            else
            {
                // load status string
                LoadString( g_hInstance,
                            IDS_NONE,
                            szErrorMsg,
                            H323_MAXPATHNAMELEN
                          );

                SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );

            }
        }
        else
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "error 0x%08lx reading dialog data.\n", lStatus ));

            // load status string
            LoadString( g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

            SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            
            // load status string
            LoadString( g_hInstance,
                        IDS_NONE,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

            SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );
        }

        // open registry subkey
        lStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    H323_REGKEY_ROOT,
                    0,
                    KEY_READ,
                    &hKey
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            H323DBG(( DEBUG_LEVEL_WARNING,
                "error 0x%08lx opening tsp registry key.", lStatus ));

            // load error string
            LoadString(g_hInstance,
                        IDS_REGOPENKEY,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

            // pop up error dialog
            MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

            // stop dialog
            EndDialog(hDlg, 0);

            break;
        }

        // initialize value name
        pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            if( (dwValue >= 30000) && (dwValue <= CALL_ALERTING_TIMEOUT) )
            {
                SetDlgItemInt( hDlg, IDC_H323_CALL_TIMEOUT, dwValue, FALSE );
            }
        }
        else
        {
            SetDlgItemInt( hDlg, IDC_H323_CALL_TIMEOUT, CALL_ALERTING_TIMEOUT,
                FALSE );
        }

        // initialize value name
        pszValue = H323_REGVAL_Q931LISTENPORT;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            if( (dwValue >= 1000) && (dwValue <= 32000) )
            {
                SetDlgItemInt( hDlg, IDC_H323_CALL_PORT, dwValue, FALSE );
            }
        }
        else
        {
            SetDlgItemInt( hDlg, IDC_H323_CALL_PORT, Q931_CALL_PORT, FALSE );
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if( lStatus == ERROR_SUCCESS )
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GATEWAYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGATEWAY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), (dwValue != 0) );

        // initialize value name
        pszValue = H323_REGVAL_PROXYADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_PROXY,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_PROXYENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEPROXY,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_PROXY),
            (dwValue != 0) );


        /////////////////////////////////////////////////////////////////////
                //GK log on phone number
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONE;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK_PHONE,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize );

        // validate return code
        if( lStatus != ERROR_SUCCESS )
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK_PHONE,
            BM_SETCHECK,
            (dwValue != 0),
            0 );

        // display string
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), (dwValue != 0) );

        /////////////////////////////////////////////////////////////////////
                //GK log on account name
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK_ACCT,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK_ACCT,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string
        EnableWindow(
            GetDlgItem(hDlg,IDC_H323_GK_ACCT),
            (dwValue != 0)
            );

        /////////////////////////////////////////////////////////////////////
                //GK address
        /////////////////////////////////////////////////////////////////////

        // initialize value name
        pszValue = H323_REGVAL_GKADDR;

        // initialize type
        dwValueType = REG_SZ;
        dwValueSize = sizeof(szAddr);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)szAddr,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus == ERROR_SUCCESS)
        {
            // display gateway address
            SetDlgItemText(hDlg,IDC_H323_GK,szAddr);
        }

        // initialize value name
        pszValue = H323_REGVAL_GKENABLED;

        // initialize type
        dwValueType = REG_DWORD;
        dwValueSize = sizeof(DWORD);

        // query for registry value
        lStatus = RegQueryValueEx(
                    hKey,
                    pszValue,
                    NULL,
                    &dwValueType,
                    (LPBYTE)&dwValue,
                    &dwValueSize
                    );

        // validate return code
        if (lStatus != ERROR_SUCCESS)
        {
            // default
            dwValue = 0;
        }

        // enable check box
        SendDlgItemMessage(
            hDlg,
            IDC_USEGK,
            BM_SETCHECK,
            (dwValue != 0),
            0
            );

        // display string if check box enabled
        EnableWindow(GetDlgItem(hDlg,IDC_H323_GK), (dwValue != 0) );

        // display log on info
        EnableWindow( GetDlgItem(hDlg,IDC_GK_LOGONGROUP), (dwValue != 0) );
                    
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), 
            (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGK_PHONE,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );
        
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_ACCT), 
            (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGK_ACCT,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        EnableWindow( GetDlgItem(hDlg,IDC_USEGK_PHONE), (dwValue != 0) );
        
        EnableWindow( GetDlgItem(hDlg,IDC_USEGK_ACCT), (dwValue != 0) );

        //disable the GW if GK enabled and vice versa
        EnableWindow( GetDlgItem(hDlg,IDC_PROXY_GROUP), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_USEPROXY), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_H323_PROXY),
            (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEPROXY,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        //disable the proxy if GK enabled and vice versa
        EnableWindow( GetDlgItem(hDlg,IDC_GATEWAY_GROUP), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_USEGATEWAY), (dwValue == 0) );
        EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), 
            (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                IDC_USEGATEWAY,
                                                BM_GETCHECK,
                                                (WPARAM)0,
                                                (LPARAM)0 ) );

        // close registry
        RegCloseKey(hKey);

        break;

    case WM_COMMAND:

        // decode command
        switch (LOWORD(wParam))
        {
        case IDAPPLY:
        case IDOK:

            //if GK is enabled at least one of the log on options should be enabled
            dwGKEnabled = !!SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0 );

            if( dwGKEnabled != 0 )
            {
                if(
                    !SendDlgItemMessage(hDlg, IDC_USEGK_PHONE, BM_GETCHECK, (WPARAM)0, (LPARAM)0 ) &&
                    !SendDlgItemMessage(hDlg, IDC_USEGK_ACCT, BM_GETCHECK, (WPARAM)0, (LPARAM)0 )
                  )
                {
                    //load error string
                    LoadString(g_hInstance,
                               IDS_GKLOGON_ERROR,
                               szErrorMsg,
                               H323_MAXPATHNAMELEN );

                    MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                    //return failure
                    return TRUE;
                }
            }
            
            dwTimeoutValue = GetDlgItemInt( hDlg,
                IDC_H323_CALL_TIMEOUT,
                NULL,
                FALSE );

            if( (dwTimeoutValue < 30000) || (dwTimeoutValue > CALL_ALERTING_TIMEOUT) )
            {
                //load error string
                LoadString(g_hInstance,
                           IDS_ALERTTIMEOUT_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            
            dwPortValue = GetDlgItemInt( hDlg,
                IDC_H323_CALL_PORT,
                NULL,
                FALSE );

            if( (dwPortValue < 1000) || (dwPortValue > 32000) )
            {
                //load error string
                LoadString(g_hInstance,
                           IDS_LISTENPORT_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            
            // open registry subkey
            lStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        H323_REGKEY_ROOT,
                        0,
                        KEY_WRITE,
                        &hKey
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_WARNING,
                    "error 0x%08lx opening tsp registry key.",
                    lStatus ));

                // load error string
                LoadString(g_hInstance,
                           IDS_REGOPENKEY,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                // pop up error dialog
                MessageBox(hDlg,szErrorMsg,NULL,MB_OK);

                // stop dialog
                EndDialog(hDlg, 0);

                break;
            }

            // initialize value name
            pszValue = H323_REGVAL_Q931ALERTINGTIMEOUT;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);
            
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwTimeoutValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing alerting timeout.",
                    lStatus ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_Q931LISTENPORT;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);
            
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwPortValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing alerting timeout.",
                    lStatus ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_GATEWAYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GATEWAY,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway address.",
                    lStatus
                    ));
            }
            
            // initialize value name
            pszValue = H323_REGVAL_GATEWAYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGATEWAY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            if( (dwValue!=0) && (wcslen(szAddr)==0) && 
                !SendDlgItemMessage(hDlg,IDC_USEGK,BM_GETCHECK,0,0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GWALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gateway flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_PROXY,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy address.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_PROXYENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEPROXY,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            if( (dwValue!=0) && (wcslen(szAddr)==0) &&
                !SendDlgItemMessage(hDlg,IDC_USEGK,BM_GETCHECK,0,0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_PROXYALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing proxy flag.",
                    lStatus
                    ));
            }

            /////////////////////////////////////////////////////////////////////
                    //GK address
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKADDR;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK,szAddr, H323_MAXDESTNAMELEN);

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            if( dwGKEnabled && (wcslen(szAddr)==0) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwGKEnabled,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

                        /////////////////////////////////////////////////////////////////////
                    //GK log on phone
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_PHONEENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGK_PHONE,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_PHONE;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK_PHONE,szAddr, H323_MAXDESTNAMELEN);

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            //check if logon-phone option is enabled and logon-phone alias is empty
            if( dwGKEnabled && dwValue && (dwValueSize == sizeof(WCHAR)) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKLOGON_PHONEALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            //validate e164
            if( IsValidE164String(szAddr) == FALSE )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_PHONEALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }
            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {

                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }


            /////////////////////////////////////////////////////////////////////
                    //GK log on account
            /////////////////////////////////////////////////////////////////////

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_ACCOUNTENABLED;

            // initialize type
            dwValueType = REG_DWORD;
            dwValueSize = sizeof(DWORD);

            // examine check box
            dwValue = SendDlgItemMessage(
                        hDlg,
                        IDC_USEGK_ACCT,
                        BM_GETCHECK,
                        0,
                        0
                        ) ? 1 : 0;

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)&dwValue,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper flag.",
                    lStatus
                    ));
            }

            // initialize value name
            pszValue = H323_REGVAL_GKLOGON_ACCOUNT;

            // retrieve gateway address from dialog
            GetDlgItemText(hDlg,IDC_H323_GK_ACCT,szAddr, H323_MAXDESTNAMELEN );

            // initialize type
            dwValueType = REG_SZ;
            dwValueSize = (wcslen(szAddr) + 1) * sizeof(WCHAR);

            //check if logon-acct option is enabled and logon-acct alias in empty
            if( dwGKEnabled && dwValue && (dwValueSize==sizeof(WCHAR)) )
            {
                // load error string
                LoadString(g_hInstance,
                           IDS_GKLOGON_ACCTALIAS_ERROR,
                           szErrorMsg,
                           H323_MAXPATHNAMELEN
                           );

                MessageBox( hDlg, szErrorMsg, NULL, MB_OK );

                //return failure
                return TRUE;
            }

            // query for registry value
            lStatus = RegSetValueEx(
                        hKey,
                        pszValue,
                        0,
                        dwValueType,
                        (LPBYTE)szAddr,
                        dwValueSize
                        );

            // validate return code
            if (lStatus != ERROR_SUCCESS)
            {
                H323DBG((
                    DEBUG_LEVEL_ERROR,
                    "error 0x%08lx writing gatekeeper address.",
                    lStatus
                    ));
            }

            // close registry
            RegCloseKey(hKey);

            if( LOWORD(wParam) == IDOK )
            {
                // close dialog
                EndDialog(hDlg, 0);
            }
            break;

        case IDCANCEL:

            // close dialog
            EndDialog(hDlg, 0);
            break;

        case IDUPDATE:

            lStatus = (*g_pfnUIDLLCallback)(
                g_dwPermanentProviderID,
                TUISPIDLL_OBJECT_PROVIDERID,
                (LPVOID)&DialogData,
                sizeof(DialogData) );

            // validate status
            if( lStatus == NOERROR )
            {
                if( DialogData.dwRegState == RAS_REGISTER_STATE_REGISTERED )
                {
                    LoadString( g_hInstance,
                        IDS_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                        );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
                else if( DialogData.dwRegState == RAS_REGISTER_STATE_RRQSENT )
                {
                    LoadString( g_hInstance,
                        IDS_REGISTRATION_INPROGRESS,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
                else
                {
                    LoadString( g_hInstance,
                        IDS_NOT_REGISTERED,
                        szErrorMsg,
                        H323_MAXPATHNAMELEN
                      );

                    SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
                }
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_ERROR,
                    "error 0x%08lx reading dialog data.\n", lStatus ));

                LoadString( g_hInstance,
                    IDS_NOT_REGISTERED,
                    szErrorMsg,
                    H323_MAXPATHNAMELEN
                  );

                SetDlgItemText( hDlg, IDC_REGSTATE, szErrorMsg );
            }
            break;

        case IDUPDATE_PORT:
            
            lStatus = (*g_pfnUIDLLCallback)(
                g_dwPermanentProviderID,
                TUISPIDLL_OBJECT_PROVIDERID,
                (LPVOID)&DialogData,
                sizeof(DialogData) );

            // validate status
            if( (lStatus == NOERROR) && (DialogData.wListenPort != 0) )
            {
                SetDlgItemInt( hDlg, IDC_LISTENPORT,  DialogData.wListenPort,
                    FALSE );
            }
            else
            {
                H323DBG(( DEBUG_LEVEL_FORCE,
                    "error 0x%08lx reading dialog data.\n", lStatus ));

                LoadString( g_hInstance,
                     IDS_NONE,
                     szErrorMsg,
                     H323_MAXPATHNAMELEN
                   );

                SetDlgItemText( hDlg, IDC_LISTENPORT, szErrorMsg );
            }

            break;

        case IDC_USEGATEWAY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GATEWAY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGATEWAY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEPROXY:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_PROXY),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEPROXY,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEGK:

            dwValue= !!SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0 );

            // display string if check box enabled
            EnableWindow( GetDlgItem( hDlg, IDC_H323_GK ), (dwValue != 0) );

            // display log on info
            EnableWindow( GetDlgItem(hDlg,IDC_GK_LOGONGROUP), (dwValue != 0) );
                        
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_PHONE), 
                (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGK_PHONE,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );
            
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GK_ACCT), 
                (dwValue != 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGK_ACCT,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            EnableWindow( GetDlgItem(hDlg,IDC_USEGK_PHONE), (dwValue != 0) );
            
            EnableWindow( GetDlgItem(hDlg,IDC_USEGK_ACCT), (dwValue != 0) );

            //disable the GW if GK enabled and vice versa
            EnableWindow( GetDlgItem(hDlg,IDC_PROXY_GROUP), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_USEPROXY), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_H323_PROXY),
                (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEPROXY,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            //disable the proxy if GK enabled and vice versa
            EnableWindow( GetDlgItem(hDlg,IDC_GATEWAY_GROUP), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_USEGATEWAY), (dwValue == 0) );
            EnableWindow( GetDlgItem(hDlg,IDC_H323_GATEWAY), 
                (dwValue == 0) && SendDlgItemMessage(hDlg,
                                                    IDC_USEGATEWAY,
                                                    BM_GETCHECK,
                                                    (WPARAM)0,
                                                    (LPARAM)0 ) );

            break;

        case IDC_USEGK_PHONE:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GK_PHONE),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK_PHONE,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;

        case IDC_USEGK_ACCT:

            // display string if check box enabled
            EnableWindow(GetDlgItem(hDlg,IDC_H323_GK_ACCT),
                         (BOOL)SendDlgItemMessage(
                             hDlg,
                             IDC_USEGK_ACCT,
                             BM_GETCHECK,
                             (WPARAM)0,
                             (LPARAM)0
                             ));
            break;
        }

        break;
    }

    // success
    return FALSE;
}



//                                                                           //
// TSPI procedures                                                           //
//                                                                           //


LONG
TSPIAPI
TSPI_providerConfig(
    HWND  hwndOwner,
    DWORD dwPermanentProviderID
    )

/*++

Routine Description:

    The original TSPI UI-generating functions (TSPI_lineConfigDialog,
    TSPI_lineConfigDialogEdit, TSPI_phoneConfigDialog, TSPI_providerConfig,
    TSPI_providerInstall, and TSPI_providerRemove) are obsolete and will
    never be called by TAPISRV.EXE.  However, if the service provider desires
    to be listed as one that can be added by the Telephony control panel,
    it must export TSPI_providerInstall; if it wants to have the Remove
    button enabled in the Telephony CPL when it is selected, it must export
    TSPI_providerRemove, and it if wants the Setup button to be enabled
    in the Telephony CPL when it is selected, it must export
    TSPI_providerConfig.

    The Telephony CPL checks for the presence of these functions in the
    service provider TSP file in order to adjust its user interface to
    reflect which operations can be performed.

    See TUISPI_lineConfigDialog for dialog code.

Arguments:

    hwndOwner - Specifies the handle of the parent window in which the function
        may create any dialog windows required during the configuration.

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        configured.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

{
    UNREFERENCED_PARAMETER(hwndOwner);              // no dialog here
    UNREFERENCED_PARAMETER(dwPermanentProviderID);  // not needed anymore

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineProviderConfig - Entered." ));
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineProviderConfig - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TUISPI_providerConfig(
    TUISPIDLLCALLBACK pfnUIDLLCallback,
    HWND              hwndOwner,
    DWORD             dwPermanentProviderID
    )
{
    INT_PTR nResult;

    g_pfnUIDLLCallback = pfnUIDLLCallback;
    g_dwPermanentProviderID = dwPermanentProviderID;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerConfig - Entered." ));
    
    // invoke dialog box
    nResult = DialogBoxW(
                g_hInstance,
                MAKEINTRESOURCE(IDD_TSPCONFIG),
                hwndOwner,
                ProviderConfigDlgProc
                );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerConfig - Exited." ));

    // status based on whether dialog executed properly
    return ((DWORD)nResult == 0) ? NOERROR : LINEERR_OPERATIONFAILED;
}



/*++

Routine Description:
    
    The TSPI_providerGenericDialogData function delivers to the service
    provider data that was sent from the UI DLL running in an application
    context through the TUISPIDLLCALLBACK function. The contents of the
    memory block pointed to by lpParams is defined by the service provider
    and UI DLL. The service provider can modify the contents of the
    parameter block; when this function returns, TAPI copies the modified
    data back into the original UI DLL parameter block.

    Implementation is mandatory if the UI DLL associated with the service
    provider calls TUISPIDLLCALLBACK.

Arguments:

    dwObjectID - An object identifer of the type specified by dwObjectType

    dwObjectType - One of the TUISPIDLL_OBJECT_ constants, specifying the
    type of object identified by dwObjectID

        TUISPIDLL_OBJECT_LINEID - dwObjectID is a line device identifier
        (dwDeviceID).

        TUISPIDLL_OBJECT_PHONEID - dwObjectID is a phone device identifier
        (dwDeviceID)

        TUISPIDLL_OBJECT_PROVIDERID - dwObjectID is a permament provider
        identifier.

        TUISPIDLL_OBJECT_DIALOGINSTANCE - dwObjectID is an HDRVDIALOGINSTANCE,
        as returned to the service provider when it sent a
        LINE_CREATEDIALOGINSTANCE message.

    lpParams - Pointer to a memory area used to hold a parameter block. The
    contents of this parameter block are specific to the service provider
    and its associated UI DLL.

    dwSize - The size in bytes of the parameter block.

Return Values:

    Returns zero if successful, or one of these negative error values:

        LINEERR_INVALPARAM, LINEERR_NOMEM, LINEERR_OPERATIONFAILED

--*/

LONG
TSPIAPI
TSPI_providerGenericDialogData(
    DWORD_PTR  dwObjectID,
    DWORD      dwObjectType,
    LPVOID     lpParams,
    DWORD      dwSize
    )
{
    PH323_DIALOG_DATA pDialogData = (PH323_DIALOG_DATA)lpParams;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerGenericDialogData Entered" ));

    if( (dwObjectType != TUISPIDLL_OBJECT_PROVIDERID) ||
        (dwSize != sizeof(H323_DIALOG_DATA))
      )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "Invalid message from dwObjectID 0x%08lx\n", dwObjectID ));

        // failure
        return LINEERR_INVALPARAM;
    }

    //
    // NOTE: if we want to make sure this message is from our UI DLL
    // then we cannot rely on the provider ID since this function may
    // be called before TSPI_providerInit.
    //

    // process command
    pDialogData->dwRegState = g_RasClient.GetRegState();
    pDialogData->wListenPort = Q931Listener.GetListenPort();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_providerGenericDialogData Exited: reg state:%d, listen port:%d",
        pDialogData->dwRegState, 
        pDialogData->wListenPort ));

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\call.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    call.cpp

Abstract:

    TAPI Service Provider functions related to manipulating calls.

        TSPI_lineAnswer
        TSPI_lineCloseCall
        TSPI_lineDrop
        TSPI_lineGetCallAddressID
        TSPI_lineGetCallInfo
        TSPI_lineGetCallStatus
        TSPI_lineMakeCall
        TSPI_lineMonitorDigits
        TSPI_lineSendUserUserInfo
        TSPI_lineReleaseUserUserInfo


Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 
//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include "line.h"
#include "q931pdu.h"
#include "q931obj.h"
#include "ras.h"
#include "config.h"

#define SETUP_SENT_TIMEOUT      8000
#define H450_ENCODED_ARG_LEN    0x4000
#define MAX_DIVERSION_COUNTER   14

static  LONG    g_H323CallID;
static  LONG    g_lNumberOfcalls;
        LONG    g_lCallReference;

//
// Public functions
//


//
//The function that handles a network event(CONNECT|CLOSE) on any of the
//Q931 calls. This function needs to find out the exact event 
// that took place and the socket on which it took place
//
        
void NTAPI Q931TransportEventHandler ( 
    IN  PVOID   Parameter,
    IN  BOOLEAN TimerFired)
{
    PH323_CALL      pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 transport event recvd." ));

    pCall = g_pH323Line -> FindH323CallAndLock ((HDRVCALL) Parameter);

    if( pCall != NULL )
    {
        pCall  -> HandleTransportEvent();
        pCall -> Unlock();
    }
}


//
// returns S_OK if socket was consumed
// returns E_FAIL if socket should be destroyed by caller
//

static HRESULT CallCreateIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress)
{
    PH323_CALL  pCall;
    HANDLE      SelectEvent;
    HANDLE      SelectWaitHandle;
    BOOL        fSuccess = TRUE;
    BOOL        DeleteCall = FALSE;
    TCHAR       ptstrEventName[100]; 
    BOOL        retVal;

    pCall = new CH323Call;
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "failed to allocate memory for CH323Call." ));
        
        return E_OUTOFMEMORY;
    }

    _stprintf( ptstrEventName, _T("%s-%p"),
        _T( "H323TSP_Incoming_TransportHandlerEvent" ), pCall );

    // create the wait event
    SelectEvent = H323CreateEvent (NULL, FALSE,
        FALSE, ptstrEventName );

    if( SelectEvent == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "CALL: failed to create select event." ));
        delete pCall;
        return GetLastResult();
    }

    retVal = pCall -> Initialize(   NULL, 
                                    LINECALLORIGIN_INBOUND, 
                                    CALLTYPE_NORMAL );

    if( retVal == FALSE )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "failed to initialize CH323Call."));
        CloseHandle (SelectEvent);
        delete pCall;
        return E_FAIL;
    }

    //add it to the call context array
    if (!pCall -> InitializeQ931 (Socket))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Failed to initialize incoming call Q.931 state." ));

        DeleteCall = FALSE;
        pCall -> Shutdown (&DeleteCall);
        delete pCall;

        if (SelectEvent)
        {
            CloseHandle (SelectEvent);
        }

        return E_FAIL;
    }

    pCall -> SetQ931CallState (Q931_CALL_CONNECTED);

    pCall -> Lock();

    if (!RegisterWaitForSingleObject(
        &SelectWaitHandle,              // pointer to the returned handle.
        SelectEvent,                    // the event handle to wait for.
        Q931TransportEventHandler,      // the callback function.
        (PVOID)pCall -> GetCallHandle(),// the context for the callback.
        INFINITE,                       // wait forever.
        WT_EXECUTEDEFAULT))             // use the wait thread to call the callback.
    {
        goto cleanup;
    }

    _ASSERTE( SelectWaitHandle );
    if( SelectWaitHandle == NULL )
    {
        goto cleanup;
    }

    //store this in the call context 
    pCall -> SetNewCallInfo (SelectWaitHandle, SelectEvent, 
        Q931_CALL_CONNECTED);
    SelectEvent = NULL;

    pCall -> InitializeRecvBuf();

    //post a buffer to winsock to accept messages from the peer
    if(!pCall -> PostReadBuffer())
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "failed to post read buffer on call." ));
        goto cleanup;
    }

    pCall -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "successfully created incoming Q.931 call." ));

    //success
    return S_OK;

cleanup:

    if (pCall)
    {
        pCall -> Unlock();
        pCall -> Shutdown (&DeleteCall);
        delete pCall;
    }

    if (SelectEvent)
    {
        CloseHandle (SelectEvent);
    }

    return E_OUTOFMEMORY;
}


void CallProcessIncomingCall (
    IN  SOCKET          Socket,
    IN  SOCKADDR_IN *   LocalAddress,
    IN  SOCKADDR_IN *   RemoteAddress)
{
    HRESULT     hr;

    hr = CallCreateIncomingCall (Socket, LocalAddress, RemoteAddress);

    if (hr != S_OK)
    {
        closesocket (Socket);
    }
}

#if DBG

DWORD
ProcessTAPICallRequest(
    IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessTAPICallRequestFre( ContextParameter );
    }
    __except( 1 )
    {
        TAPI_CALLREQUEST_DATA*  pRequestData = 
            (TAPI_CALLREQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p.", 
            EventIDToString(pRequestData -> EventID),
            pRequestData -> pCall,
            pRequestData -> pCallforwardParams ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif


DWORD 
ProcessTAPICallRequestFre(
    IN  PVOID   ContextParameter)
{
    _ASSERTE( ContextParameter );

    TAPI_CALLREQUEST_DATA*  pCallRequestData = (TAPI_CALLREQUEST_DATA*)ContextParameter;
    PH323_CALL              pCall = pCallRequestData->pCall;
    BOOL                    fDelete = FALSE;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.", 
        EventIDToString(pCallRequestData -> EventID) ));

    pCall -> Lock();

    if( pCallRequestData -> EventID == TSPI_DELETE_CALL )
    {
        pCall -> Unlock();
                
        delete pCallRequestData;        
        delete pCall;
        return EXIT_SUCCESS;
    }

    if( pCall -> IsCallShutdown() == FALSE )
    {
        switch( pCallRequestData -> EventID )
        {
        case TSPI_MAKE_CALL:

            pCall -> MakeCall();
            break;

        case TSPI_ANSWER_CALL:
            
            pCall -> AcceptCall();
            break;
    
        case TSPI_DROP_CALL:
            
            pCall -> DropUserInitiated( 0 );
            //pCall -> DropCall(0);
            break;

        case TSPI_RELEASE_U2U:
            
            pCall -> ReleaseU2U();
            break;

        case TSPI_CALL_HOLD:
            
            pCall -> Hold();
            break;

        case TSPI_CALL_UNHOLD:
            
            pCall -> UnHold();
            break;

        case TSPI_CALL_DIVERT:
            
            pCall -> CallDivertOnNoAnswer();
            break;

        case TSPI_LINEFORWARD_NOSPECIFIC:
        case TSPI_LINEFORWARD_SPECIFIC:

            pCall -> Forward( pCallRequestData -> EventID,
                pCallRequestData -> pCallforwardParams );

            break;

        case TSPI_SEND_U2U:

            pCall -> SendU2U( pCallRequestData -> pBuf->pbBuffer,
                pCallRequestData->pBuf->dwLength );

            delete pCallRequestData -> pBuf;
            
            break;

        default:
            _ASSERTE(0);
            break;
        }
    }
    
    pCall -> DecrementIoRefCount( &fDelete );
    pCall -> Unlock();
    delete pCallRequestData;
    
    if( fDelete == TRUE )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
        delete pCall;
    }

    return EXIT_SUCCESS;
}


//
// CH323Call Methods
//


CH323Call::CH323Call(void)
{
    ZeroMemory( (PVOID)this, sizeof(CH323Call) );

    /*m_dwFlags = 0;
    m_pwszDisplay = NULL;
    m_fMonitoringDigits = FALSE;
    m_hdCall = NULL;
    m_htCall = NULL;
    m_dwCallState = NULL;
    m_dwOrigin = NULL;
    m_dwAddressType = NULL;
    m_dwIncomingModes = NULL;     
    m_dwOutgoingModes = NULL;
    m_dwRequestedModes = NULL;    // requested media modes
    m_hdMSPLine = NULL;
    m_htMSPLine = NULL;
    //m_fGateKeeperPresent = FALSE;
    m_fReadyToAnswer = FALSE;
    m_fCallAccepted = FALSE;

    // reset addresses
    memset((PVOID)&m_CalleeAddr,0,sizeof(H323_ADDR));
    memset((PVOID)&m_CallerAddr,0,sizeof(H323_ADDR));

    // reset addresses
    m_pCalleeAliasNames = NULL;
    m_pCallerAliasNames = NULL;
    
    //reset non standard data
    memset( (PVOID)&m_NonStandardData, 0, sizeof(H323NonStandardData ) );

    //reset the conference ID
    ZeroMemory (&m_ConferenceID, sizeof m_ConferenceID);
   
    pFastStart = NULL;

    //redet the peer information
    memset( (PVOID)&m_peerH245Addr, 0, sizeof(H323_ADDR) );
    memset( (PVOID)&m_selfH245Addr, 0, sizeof(H323_ADDR) );
    memset( (PVOID)&m_peerNonStandardData, 0, sizeof(H323NonStandardData ) );
    memset( (PVOID)&m_peerVendorInfo, 0, sizeof(H323_VENDORINFO) );
    memset( (PVOID)&m_peerEndPointType, 0, sizeof(H323_ENDPOINTTYPE) );
    m_pPeerFastStart = NULL;
    m_pPeerExtraAliasNames = NULL;
    m_pPeerDisplay = NULL;

    m_hCallEstablishmentTimer = NULL;
    m_hCallDivertOnNATimer = NULL;

    //Q931call data
    m_hTransport = NULL;  
    
    m_hTransportWait = NULL; 
    
    pRecvBuf = NULL;      
    m_hSetupSentTimer = NULL;
    m_dwStateMachine = 0;   
    m_dwQ931Flags = 0;
    //

    fActiveMC = FALSE;  
    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));
    m_wCallReference = NULL;
    m_wQ931CallRef = NULL;
    m_IoRefCount = 0;
    
    //RAS call data
    wARQSeqNum = 0;
    m_wDRQSeqNum = 0;

    m_pARQExpireContext = NULL;
    m_pDRQExpireContext= NULL;
    m_hARQTimer = NULL;
    m_hDRQTimer = NULL;
    m_dwDRQRetryCount = 0;
    m_dwARQRetryCount = 0;
    m_fCallInTrnasition = FALSE
    m_dwAppSpecific = 0;*/


    m_dwFastStart = FAST_START_UNDECIDED;
    m_callSocket = INVALID_SOCKET;
    m_bStartOfPDU = TRUE;

    H323DBG(( DEBUG_LEVEL_TRACE,
        "Initialize:m_IoRefCount:%d:%p.", m_IoRefCount, this ));
    m_dwRASCallState = RASCALL_STATE_IDLE;

    if( InterlockedIncrement( &g_lNumberOfcalls ) == 1 )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "pCall no goes from 0 to 1:g_hCanUnloadDll set.", this ));

        ResetEvent( g_hCanUnloadDll );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "New pCall object created:%p.", this ));

}


CH323Call::~CH323Call()
{
    CALL_SEND_CONTEXT*  pSendBuf;
    PLIST_ENTRY         pLE;

    H323DBG(( DEBUG_LEVEL_ERROR, "pCall object deleted:%p.", this ));

    if( m_dwFlags & CALLOBJECT_INITIALIZED )
    {
        while( IsListEmpty( &m_sendBufList ) == FALSE )
        {
            pLE = RemoveHeadList( &m_sendBufList );
            pSendBuf = CONTAINING_RECORD( pLE, CALL_SEND_CONTEXT, ListEntry);
            delete pSendBuf->WSABuf.buf;
            delete pSendBuf;
        }

        if( m_hTransportWait != NULL )
        {
            if( UnregisterWaitEx( m_hTransportWait, NULL ) == FALSE )
            {
                GetLastError();
            }

            m_hTransportWait = NULL;
        }

        if( m_hTransport != NULL )
        {
            if(!CloseHandle(m_hTransport))
            {
                WSAGetLastError();
            }

            m_hTransport = NULL;
        }
            
        if( m_callSocket != INVALID_SOCKET )
        {
            closesocket( m_callSocket );
            m_callSocket = INVALID_SOCKET;
        }

        TermASNCoder();

        DeleteCriticalSection( &m_CriticalSection );
    }

    if( InterlockedDecrement( &g_lNumberOfcalls ) == 0 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Unload dll event set.%p.", this ));
        SetEvent( g_hCanUnloadDll );
    }
}

    
//!!no need to lock
BOOL
CH323Call::Initialize( 
    IN HTAPICALL    htCall,
    IN DWORD        dwOrigin,
    IN DWORD        dwCallType
    )
{
    int     index;
    int     rc;

    H323DBG(( DEBUG_LEVEL_ERROR, "call init entered:%p.",this ));

    m_pCallerAliasNames = new H323_ALIASNAMES;

    if( m_pCallerAliasNames == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
        return FALSE;
    }
    memset( (PVOID)m_pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );
    //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    m_pCalleeAliasNames = new H323_ALIASNAMES;

    if( m_pCalleeAliasNames == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate callee name." ));
        goto error1;
    }
    memset( (PVOID)m_pCalleeAliasNames, 0, sizeof(H323_ALIASNAMES) );

            
    __try
    {
        if( !InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 
                                                    0x80000000 ) )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "couldn't alloc critsec for call." ));
            goto error2;
        }
    }
    __except( 1 )
    {
        goto error2;        
    }

    if( dwOrigin == LINECALLORIGIN_OUTBOUND )
    {
        int iresult = UuidCreate( &m_callIdentifier );

        if( (iresult != RPC_S_OK) && (iresult !=RPC_S_UUID_LOCAL_ONLY) )
        {
            goto error3;
        }
    }

    rc = InitASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "Q931_InitCoder() returned: %d ", rc));
        goto error3;
    }

    rc = InitH450ASNCoder();

    if( rc != ASN1_SUCCESS )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "Q931_InitCoder() returned: %d ", rc));
        goto error4;
    }

    //Create the CRV for this call.
    do 
    {
        m_wCallReference = ((WORD)InterlockedIncrement( &g_lCallReference ))
            & 0x7fff;

    } while( (m_wCallReference == 0) ||
        g_pH323Line->CallReferenceDuped( m_wCallReference ) );

    //add the call to the call table
    index = g_pH323Line -> AddCallToTable((PH323_CALL)this);
    if( index == -1 )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not add call to call table." ));
        goto error5;
    }
    
    //By incrementing the g_H323CallID and taking lower 16 bits we get 65536
    //unique values and then same values are repeated. Thus we can have only
    //65535 simultaneous calls. By using the call table index we make sure that
    //no two existing calls have same call handle.
    do
    {
        m_hdCall = (HDRVCALL)( ((BYTE*)NULL) + 
            MAKELONG( LOWORD((DWORD)index),
            (WORD)InterlockedIncrement(&g_H323CallID) ));

    } while ( m_hdCall == NULL );
    
    ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

    m_dwFlags |= CALLOBJECT_INITIALIZED;
    m_htCall = htCall;
    m_dwCallState = LINECALLSTATE_IDLE;
    m_dwOrigin = dwOrigin;
    m_hdConf = NULL;
    
    m_wQ931CallRef = m_wCallReference;
    m_dwCallType = dwCallType;

    // initialize user user information
    InitializeListHead( &m_IncomingU2U );
    InitializeListHead( &m_OutgoingU2U );
    InitializeListHead( &m_sendBufList );

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "m_hdCall:%lx m_htCall:%lx m_wCallReference:%lx : %p .", 
        m_hdCall, m_htCall, m_wCallReference, this ));

    H323DBG(( DEBUG_LEVEL_TRACE, "call init exited:%p.",this ));
    return TRUE;

error5:
    TermH450ASNCoder();
error4:
    TermASNCoder();
error3:
    DeleteCriticalSection( &m_CriticalSection );
error2:
    delete m_pCalleeAliasNames;
    m_pCalleeAliasNames = NULL;
error1:
    delete m_pCallerAliasNames;
    m_pCallerAliasNames = NULL;
    return FALSE;
}


//
//!!must be always called in a lock
//Queues a request made by TAPI to the thread pool
//

BOOL
CH323Call::QueueTAPICallRequest(
    IN  DWORD   EventID,
    IN  PVOID   pBuf
    )
{
    TAPI_CALLREQUEST_DATA * pCallRequestData = new TAPI_CALLREQUEST_DATA;
    BOOL fResult = TRUE;

    if( pCallRequestData != NULL )
    {
        pCallRequestData -> EventID = EventID;
        pCallRequestData -> pCall = this;
        pCallRequestData -> pBuf = (PBUFFERDESCR)pBuf;
        
        if( !QueueUserWorkItem( ProcessTAPICallRequest, pCallRequestData,
            WT_EXECUTEDEFAULT ) )
        {
            delete pCallRequestData;
            fResult = FALSE;
        }
        
        m_IoRefCount++;
        H323DBG(( DEBUG_LEVEL_TRACE, "TAPICallRequest:m_IoRefCount:%d:%p.",
            m_IoRefCount, this ));
    }
    else
    {
        fResult = FALSE;
    }

    return fResult;
}


//always called in lock
void
CH323Call::CopyCallStatus( 
                           IN LPLINECALLSTATUS pCallStatus 
                         )
{
    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallStatus entered:%p.",this ));
    
    // transer call state information    
    pCallStatus->dwCallState     = m_dwCallState;
    pCallStatus->dwCallStateMode = m_dwCallStateMode;

    // determine call feature based on state
    pCallStatus->dwCallFeatures = ( m_dwCallState != LINECALLSTATE_IDLE)?
        (H323_CALL_FEATURES) : 0;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallStatus exited:%p.",this ));
}


//always called in lock
LONG
CH323Call::CopyCallInfo( 
    IN LPLINECALLINFO  pCallInfo
    )
{
    DWORD dwCalleeNameSize = 0;
    DWORD dwCallerNameSize = 0;
    DWORD dwCallerAddressSize = 0;
    WCHAR wszIPAddress[20];
    DWORD dwNextOffset = sizeof(LINECALLINFO);
    DWORD dwU2USize = 0;
    PBYTE pU2U = NULL;
    LONG  retVal = NOERROR;
    DWORD dwDivertingNameSize = 0;
    DWORD dwDiversionNameSize = 0;
    DWORD dwDivertedToNameSize = 0;
    DWORD dwCallDataSize = 0;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallInfo entered:%p.",this ));

    // see if user user info available
    if( IsListEmpty( &m_IncomingU2U) == FALSE )
    {
        PLIST_ENTRY pLE;
        PUserToUserLE pU2ULE;

        // get first list entry
        pLE = m_IncomingU2U.Flink;

        // convert to user user structure
        pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

        // transfer info
        dwU2USize = pU2ULE->dwU2USize;
        pU2U = pU2ULE->pU2U;
    }

    // initialize caller and callee id flags now
    pCallInfo->dwCalledIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwCallerIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
    pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;


    // calculate memory necessary for strings
    if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount !=0 )
    {
        dwCalleeNameSize = 
            H323SizeOfWSZ( m_pCalleeAliasNames -> pItems[0].pData );
    }
    
    if( m_pCallerAliasNames && (m_pCallerAliasNames->wCount) )
    {
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

        dwCallerNameSize =
            sizeof(WCHAR) * (m_pCallerAliasNames->pItems[0].wDataLength + 1);
    }

    if( m_CallerAddr.Addr.IP_Binary.dwAddr != 0 )
    {
        wsprintfW(wszIPAddress, L"%d.%d.%d.%d", 
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 24) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 16) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr >> 8) & 0xff,
            (m_CallerAddr.Addr.IP_Binary.dwAddr) & 0xff
            );

        dwCallerAddressSize = (wcslen(wszIPAddress) + 1) * sizeof(WCHAR);
            
    }
    
    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {    
        if( m_pCallReroutingInfo->divertingNrAlias && 
            (m_pCallReroutingInfo->divertingNrAlias->wCount !=0) )
        {
            dwDivertingNameSize = H323SizeOfWSZ( 
                m_pCallReroutingInfo->divertingNrAlias-> pItems[0].pData );
        }
    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }
    }

    if( m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING )
    {    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }
    }

    if( m_dwCallType & CALLTYPE_DIVERTEDSRC)
    {    
        if( m_pCallReroutingInfo->divertedToNrAlias && 
            (m_pCallReroutingInfo->divertedToNrAlias->wCount != 0) )
        {
            dwDivertedToNameSize = sizeof(WCHAR) * 
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].wDataLength;
        }

        if( m_pCallReroutingInfo->divertingNrAlias && 
            (m_pCallReroutingInfo->divertingNrAlias->wCount !=0) )
        {
            dwDivertingNameSize = H323SizeOfWSZ( 
                m_pCallReroutingInfo->divertingNrAlias-> pItems[0].pData );
        }

    }
    
    if( m_CallData.wOctetStringLength != 0 )
    {
        dwCallDataSize = m_CallData.wOctetStringLength;
    }

    // determine number of bytes needed
    pCallInfo->dwNeededSize = sizeof(LINECALLINFO) +
                              dwCalleeNameSize +
                              dwCallerNameSize +
                              dwCallerAddressSize +
                              dwDivertingNameSize +
                              dwDiversionNameSize +
                              dwDivertedToNameSize +
                              dwU2USize +
                              dwCallDataSize
                              ;

    // see if structure size is large enough
    if (pCallInfo->dwTotalSize >= pCallInfo->dwNeededSize)
    {
        // record number of bytes used
        pCallInfo->dwUsedSize = pCallInfo->dwNeededSize;

        // validate string size
        if (dwCalleeNameSize > 0)
        {
            if( m_pCalleeAliasNames -> pItems[0].wType == e164_chosen )
            {
                // callee number was specified
                pCallInfo->dwCalledIDFlags = LINECALLPARTYID_ADDRESS;

                // determine size and offset for callee number
                pCallInfo->dwCalledIDSize = dwCalleeNameSize;
                pCallInfo->dwCalledIDOffset = dwNextOffset;

                // copy call info after fixed portion
                CopyMemory( 
                    (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCalledIDOffset),
                    (LPBYTE)m_pCalleeAliasNames -> pItems[0].pData,
                    pCallInfo->dwCalledIDSize );
            }
            else
            {
                // callee name was specified
                pCallInfo->dwCalledIDFlags = LINECALLPARTYID_NAME;

                // determine size and offset for callee name
                pCallInfo->dwCalledIDNameSize = dwCalleeNameSize;
                pCallInfo->dwCalledIDNameOffset = dwNextOffset;

                // copy call info after fixed portion
                CopyMemory( 
                    (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCalledIDNameOffset),
                    (LPBYTE)m_pCalleeAliasNames -> pItems[0].pData,
                    pCallInfo->dwCalledIDNameSize );
            }

            // adjust offset to include string
            dwNextOffset += dwCalleeNameSize;
            
            H323DBG(( DEBUG_LEVEL_TRACE,
                "callee name: %S.", m_pCalleeAliasNames -> pItems[0].pData ));
        }

        // validate string size
        if (dwCallerNameSize > 0)
        {
            // caller name was specified
            pCallInfo->dwCallerIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwCallerIDNameSize = dwCallerNameSize;
            pCallInfo->dwCallerIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCallerIDNameOffset),
                (LPBYTE)m_pCallerAliasNames -> pItems[0].pData,
                pCallInfo->dwCallerIDNameSize );

            //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
            // adjust offset to include string
            dwNextOffset += dwCallerNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE,
                "caller name: %S.", m_pCallerAliasNames -> pItems[0].pData ));
        }

        if( dwCallerAddressSize > 0 )
        {
            // caller number was specified
            pCallInfo->dwCallerIDFlags |= LINECALLPARTYID_ADDRESS;

            // determine size and offset for caller number
            pCallInfo->dwCallerIDSize = dwCallerAddressSize;
            pCallInfo->dwCallerIDOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwCallerIDOffset),
                (LPBYTE)wszIPAddress,
                pCallInfo->dwCallerIDSize );
            
            // adjust offset to include string
            dwNextOffset += dwCallerAddressSize;
        }

        // validate buffer
        if (dwU2USize > 0)
        {
            // determine size and offset of info
            pCallInfo->dwUserUserInfoSize = dwU2USize;
            pCallInfo->dwUserUserInfoOffset = dwNextOffset;

            // copy user user info after fixed portion
            CopyMemory(
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwUserUserInfoOffset),
                (LPBYTE)pU2U,
                pCallInfo->dwUserUserInfoSize );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwUserUserInfoSize;
        }

        if( dwDivertingNameSize > 0 )
        {
            // caller name was specified
            pCallInfo->dwRedirectingIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectingIDNameSize = dwDivertingNameSize;
            pCallInfo->dwRedirectingIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectingIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->divertingNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectingIDNameSize );

            // adjust offset to include string
            dwNextOffset += dwDivertingNameSize;
            
            H323DBG(( DEBUG_LEVEL_TRACE, "diverting name: %S.",
                m_pCallReroutingInfo->divertingNrAlias->pItems[0].pData ));
        }

        if( dwDiversionNameSize > 0 )
        {
            // caller name was specified
            pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectionIDNameSize = dwDiversionNameSize;
            pCallInfo->dwRedirectionIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectionIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->diversionNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectionIDNameSize );

            // adjust offset to include string
            dwNextOffset += dwDiversionNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE, "redirection name: %S.",
                m_pCallReroutingInfo->diversionNrAlias->pItems[0].pData ));
        }
        
        if( dwDivertedToNameSize > 0 )
        {
            pCallInfo->dwRedirectionIDFlags = LINECALLPARTYID_NAME;

            // determine size and offset for caller name
            pCallInfo->dwRedirectionIDNameSize = dwDivertedToNameSize;
            pCallInfo->dwRedirectionIDNameOffset = dwNextOffset;

            // copy call info after fixed portion
            CopyMemory(
                (PVOID)((LPBYTE)pCallInfo + pCallInfo->dwRedirectionIDNameOffset),
                (LPBYTE)(m_pCallReroutingInfo->divertedToNrAlias->pItems[0].pData),
                pCallInfo->dwRedirectionIDNameSize );

            // adjust offset to include string
            dwNextOffset += pCallInfo->dwRedirectionIDNameSize;
            
            // adjust offset to include string
            dwNextOffset += dwDivertedToNameSize;

            H323DBG(( DEBUG_LEVEL_TRACE, "redirection name: %S.",
                m_pCallReroutingInfo->divertedToNrAlias->pItems[0].pData ));

        }

        //pass on the call data
        if( dwCallDataSize > 0 )
        {
            pCallInfo -> dwCallDataSize = dwCallDataSize;
            pCallInfo -> dwCallDataOffset = dwNextOffset;

            CopyMemory( 
                (PVOID)((LPBYTE)pCallInfo + pCallInfo -> dwCallDataOffset),
                (LPBYTE)m_CallData.pOctetString,
                pCallInfo -> dwCallDataSize );

            dwNextOffset += dwCallDataSize;
        }

    }
    else if (pCallInfo->dwTotalSize >= sizeof(LINECALLINFO))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "linecallinfo structure too small for strings." ));

        // structure only contains fixed portion
        pCallInfo->dwUsedSize = sizeof(LINECALLINFO);

    }
    else 
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "linecallinfo structure too small." ));

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    // initialize call line device and address info
    pCallInfo->dwLineDeviceID = g_pH323Line->GetDeviceID();
    pCallInfo->dwAddressID    = 0;

    // initialize variable call parameters
    pCallInfo->dwOrigin     = m_dwOrigin;
    pCallInfo->dwMediaMode  = m_dwIncomingModes | m_dwOutgoingModes;

    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {
        if(m_pCallReroutingInfo->diversionReason==DiversionReason_cfu)
        {
            pCallInfo->dwReason = LINECALLREASON_FWDUNCOND;
        }
        else if(m_pCallReroutingInfo->diversionReason==DiversionReason_cfnr)
        {
            pCallInfo->dwReason = LINECALLREASON_FWDNOANSWER;
        }
        else
        {
            pCallInfo->dwReason = LINECALLREASON_FWDBUSY;
        }
    }
    if( m_dwCallType & CALLTYPE_TRANSFEREDDEST )
    {
        pCallInfo->dwReason = LINECALLREASON_TRANSFER;
    }
    else
    {
        pCallInfo->dwReason = LINECALLREASON_DIRECT;
    }

    pCallInfo->dwCallStates = (m_dwOrigin==LINECALLORIGIN_INBOUND)
                                ? H323_CALL_INBOUNDSTATES
                                : H323_CALL_OUTBOUNDSTATES
                                ;

    // initialize constant call parameters
    pCallInfo->dwBearerMode = H323_LINE_BEARERMODES;
    pCallInfo->dwRate       = H323_LINE_MAXRATE;

    // initialize unsupported call capabilities
    pCallInfo->dwConnectedIDFlags = LINECALLPARTYID_UNAVAIL;
    
    //pass on the dwAppSpecific info
    pCallInfo -> dwAppSpecific = m_dwAppSpecific;

    H323DBG(( DEBUG_LEVEL_ERROR, "CopyCallInfo exited:%p.",this ));
    
    return retVal;
}


//!!always called in lock
BOOL
CH323Call::HandleReadyToInitiate(
    IN PTspMspMessage  pMessage
    )
{
    Q931_SETUP_ASN  setupASN;
    WORD            wCount;
    DWORD           dwAPDUType = 0;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToInitiate entered:%p.", this ));

    //set the additional callee addresses and callee aliases
    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseSetupASN( pMessage ->pEncodedASNBuf,
                            pMessage->dwEncodedASNSize, 
                            &setupASN,
                            &dwAPDUType ))
        {
            goto cleanup;
        }

        if( setupASN.fFastStartPresent )
        {
            _ASSERTE( !m_pFastStart );
            m_pFastStart = setupASN.pFastStart;
            setupASN.pFastStart = NULL;
            m_dwFastStart = FAST_START_SELF_AVAIL;
        }
        else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }

        if( setupASN.pCallerAliasList && !RasIsRegistered() )
        {
            //_ASSERTE(0);

            if( m_pCallerAliasNames == NULL )
            {
                m_pCallerAliasNames = setupASN.pCallerAliasList;

                //dont release this alias list
                setupASN.pCallerAliasList = NULL;
            }
            else
            {
                wCount = m_pCallerAliasNames->wCount +
                    setupASN.pCallerAliasList->wCount;
                
                PH323_ALIASITEM tempPtr = NULL;

                tempPtr = (PH323_ALIASITEM)realloc( 
                    (PVOID)setupASN.pCallerAliasList->pItems, 
                    wCount * sizeof(H323_ALIASITEM) );

                if( tempPtr == NULL )
                {
                    //restore the old pointer in case enough memory was not
                    //available to expand the memory block
                }
                else
                {
                    setupASN.pCallerAliasList->pItems = tempPtr;

                    CopyMemory(
                        (PVOID)&(setupASN.pCallerAliasList->pItems[setupASN.pCallerAliasList->wCount]),
                        (PVOID)m_pCallerAliasNames->pItems,
                        m_pCallerAliasNames->wCount * sizeof(H323_ALIASITEM) );
                
                    setupASN.pCallerAliasList->wCount = wCount;

                    delete m_pCallerAliasNames->pItems;
                    delete m_pCallerAliasNames;
                    m_pCallerAliasNames = setupASN.pCallerAliasList;
                    setupASN.pCallerAliasList = NULL;
                }
            }
        }

        //add the callee aliases sent by the MSP
        if( setupASN.pCalleeAliasList != NULL )
        {
            //_ASSERTE(0);
            
            if( m_pCalleeAliasNames == NULL )
            {
                m_pCalleeAliasNames = setupASN.pCalleeAliasList;

                //dont release this alias list
                setupASN.pCalleeAliasList = NULL;
            }
            else
            {
                wCount = m_pCalleeAliasNames->wCount +
                    setupASN.pCalleeAliasList->wCount;
				
				PH323_ALIASITEM tempPtr = NULL;
                
                tempPtr = (PH323_ALIASITEM)realloc( 
                    (PVOID)m_pCalleeAliasNames->pItems, 
                    wCount * sizeof(H323_ALIASITEM) );

                if( tempPtr == NULL )
                {
                    //restore the old pointer in case enough memory was not
                    //available to expand the memory block
                    goto cleanup;
                }

                m_pCalleeAliasNames->pItems = tempPtr;
                
                CopyMemory( 
                    (PVOID)&(m_pCalleeAliasNames->pItems[m_pCalleeAliasNames->wCount]),
                    (PVOID)setupASN.pCalleeAliasList->pItems,
                    setupASN.pCalleeAliasList->wCount * sizeof(H323_ALIASITEM) );

                m_pCalleeAliasNames->wCount = wCount;

                delete setupASN.pCalleeAliasList->pItems;
                delete setupASN.pCalleeAliasList;
                setupASN.pCalleeAliasList = NULL;
            }
        }

        FreeSetupASN( &setupASN );
    }
    else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }
            
    //send the setup message
    if( !SendSetupMessage() )
    {
        DropCall( 0 );
    }
    
  
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToInitiate exited:%p.", this ));
    return TRUE;    

cleanup:

    CloseCall( 0 );        
    FreeSetupASN( &setupASN );
    return FALSE;
}


//!!always called in lock
BOOL
CH323Call::HandleProceedWithAnswer(
    IN PTspMspMessage  pMessage
    )
{
    Q931_CALL_PROCEEDING_ASN    proceedingASN;
    DWORD                       dwAPDUType = 0;
    PH323_ALIASITEM             pwszDivertedToAlias = NULL;
    WCHAR                       *pwszAliasName = NULL;
    WORD                        wAliasLength = 0;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedWithAnswer entered:%p.", this ));

    if( m_dwCallType & CALLTYPE_DIVERTED_SERVED )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, 
            "Call already diverted. ignore the message:%p.", this ));
        return TRUE;
    }
        
    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseProceedingASN(pMessage ->pEncodedASNBuf,
                pMessage->dwEncodedASNSize, 
                &proceedingASN,
                &dwAPDUType ) )
        {
            goto cleanup;
        }

        if( proceedingASN.fH245AddrPresent )
        {
            m_selfH245Addr = proceedingASN.h245Addr;
        }

        if( proceedingASN.fFastStartPresent && 
            (m_dwFastStart!=FAST_START_NOTAVAIL) )
        {
            _ASSERTE( m_pFastStart == NULL );
            
            m_pFastStart = proceedingASN.pFastStart;
            m_dwFastStart = FAST_START_AVAIL;

            //we keep a reference to the fast start list so don't release it 
            proceedingASN.pFastStart = NULL;
            proceedingASN.fFastStartPresent = FALSE;
        }
        /*else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }*/
        
        FreeProceedingASN( &proceedingASN );
    }
    /*else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }*/
    
    //send proceeding message to the peer
    if(!SendProceeding() )
    {
        goto cleanup;
    }

    //send alerting message to the peer
    if( !SendQ931Message(NO_INVOKEID, 0, 0, ALERTINGMESSAGETYPE, NO_H450_APDU) )
    {
        goto cleanup;
    }

    m_dwStateMachine = Q931_ALERT_SENT;

    //for TRANSFEREDDEST call directly accept the call wihtout the user 
    //answering the call
    if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
    {
        AcceptCall();
    }

    if( m_pCallerAliasNames && (m_pCallerAliasNames -> wCount > 0) )
    {
        pwszAliasName = m_pCallerAliasNames->pItems[0].pData;
        wAliasLength = (m_pCallerAliasNames->pItems[0].wDataLength+1) 
            * sizeof(WCHAR);
                
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    pwszDivertedToAlias = g_pH323Line->CallToBeDiverted( 
            pwszAliasName, 
            wAliasLength,
            LINEFORWARDMODE_NOANSW | LINEFORWARDMODE_NOANSWSPECIFIC |
            LINEFORWARDMODE_BUSYNA | LINEFORWARDMODE_BUSYNASPECIFIC );

    //if call is to be diverted for no answer, start the timer
    if( pwszDivertedToAlias != NULL )
    {
        if( !StartTimerForCallDiversionOnNA( pwszDivertedToAlias ) )
        {
            goto cleanup;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedWithAnswer exited:%p.",this ));
    return TRUE;

cleanup:

    CloseCall( 0 );
    return FALSE;
}


//!!always called in lock
BOOL
CH323Call::HandleReadyToAnswer(
    IN PTspMspMessage  pMessage
    )
{
    Q931_CALL_PROCEEDING_ASN    proceedingASN;
    DWORD                       dwAPDUType = 0;
    PH323_CALL                  pConsultCall = NULL;
    
    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToAnswer entered:%p.",this ));

    m_fReadyToAnswer = TRUE;

    //see if there is a fast-connect proposal
    if( pMessage->dwEncodedASNSize != 0 )
    {
        if( !ParseProceedingASN(pMessage ->pEncodedASNBuf,
                                pMessage->dwEncodedASNSize, 
                                &proceedingASN,
                                &dwAPDUType) )
        {
            goto cleanup;
        }

        if( proceedingASN.fH245AddrPresent )
        {
            m_selfH245Addr =  proceedingASN.h245Addr;
        }

        if( proceedingASN.fFastStartPresent && 
            (m_dwFastStart!=FAST_START_NOTAVAIL) )
        {
            _ASSERTE( m_pFastStart == NULL );
            
            m_pFastStart = proceedingASN.pFastStart;
            m_dwFastStart = FAST_START_AVAIL;

            //we keep a reference to the fast start list so don't release it 
            proceedingASN.pFastStart = NULL;
            proceedingASN.fFastStartPresent = FALSE;
        }
        else
        {
            m_dwFastStart = FAST_START_NOTAVAIL;
        }
        
        FreeProceedingASN( &proceedingASN );
    }
    else
    {
        m_dwFastStart = FAST_START_NOTAVAIL;
    }

    if( m_fCallAccepted )
    {
        // validate status
        if( !AcceptH323Call() )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "error answering call 0x%08lx.", this ));

            // failure
            goto cleanup;
        }

        //lock the primary call after replacement call to avoid deadlock
        if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
        {
            QueueSuppServiceWorkItem( SWAP_REPLACEMENT_CALL, 
                m_hdCall, (ULONG_PTR)m_hdRelatedCall );
        }
        else
        {
            //send MSP start H245
            SendMSPStartH245( NULL, NULL );

            //tell MSP about connect state
            SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );
        }

        //change call state to accepted from offering
        ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "HandleReadyToAnswer exited:%p.",this ));
    return TRUE;

cleanup:

    CloseCall( 0 );
    return FALSE;

}


//!!This function must be always called in a lock. The calling function should
//not unlock the call object as this function itself unlocks the call object
BOOL
CH323Call::HandleMSPMessage(
    IN PTspMspMessage  pMessage,
    IN HDRVMSPLINE     hdMSPLine,
    IN HTAPIMSPLINE    htMSPLine
    )
{
    BOOL                fResult = TRUE;
    PH323_CALL          pCall = NULL;
    ASN1octetstring_t   pH245PDU;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleMSPMessage entered:%p.",this ));
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP message:%s recvd.", 
        H323TSPMessageToString(pMessage->MessageType) ));

    switch( pMessage -> MessageType )
    {
    case SP_MSG_ReadyToInitiate:

        // The Q.931 connection should be in the connected state by now
        if( pMessage -> MsgBody.ReadyToInitiateMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall == NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return TRUE;
            }

            fResult = pCall -> HandleReadyToInitiate( pMessage );
            pCall -> Unlock();
        }
        else
        {
            m_hdMSPLine = hdMSPLine;
            m_htMSPLine = htMSPLine;
            fResult = HandleReadyToInitiate( pMessage );
            Unlock();
        }
        
        break;

    case SP_MSG_ProceedWithAnswer:
    
        if( pMessage -> MsgBody.ProceedWithAnswerMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall == NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return FALSE;
            }

            fResult = pCall -> HandleProceedWithAnswer( pMessage );
            pCall -> Unlock();
        }
        else
        {
            m_hdMSPLine = hdMSPLine;
            m_htMSPLine = htMSPLine;
            fResult = HandleProceedWithAnswer( pMessage );
            Unlock();
        }
        
        break;

    case SP_MSG_ReadyToAnswer:

        if( pMessage -> MsgBody.ReadyToAnswerMessage.hMSPReplacementCall != NULL )
        {
            //unlock the primary call before locking the related call
            Unlock();

            pCall=g_pH323Line -> FindH323CallAndLock(m_hdRelatedCall);
            if( pCall== NULL )
            {
                //transfered call is not around so close the primary call
                CloseCall( 0 );
                return FALSE;
            }

            fResult = pCall -> HandleReadyToAnswer( pMessage );
            pCall -> Unlock();
        }
        else
        {
            //decode call_proceding message and extract local fast
            //start inforamtion and local H245 address
            fResult = HandleReadyToAnswer( pMessage );
            Unlock();
        }

        break;
    
    case SP_MSG_ReleaseCall:
        
        //shutdown the H323 call
        CloseCall( LINEDISCONNECTMODE_CANCELLED );
        
        Unlock();
        break;
        
    case SP_MSG_H245Terminated:
        
        //shutdown the H323 call
        CloseCall( LINEDISCONNECTMODE_NORMAL );
        
        Unlock();
        break;
        
    case SP_MSG_SendDTMFDigits:

        if( m_fMonitoringDigits == TRUE )
        {
            WCHAR * pwch = pMessage->pWideChars;

            H323DBG(( DEBUG_LEVEL_VERBOSE, "dtmf digits recvd:%S.", pwch));

            // process each digit
            WORD indexI=0; 
            while( indexI < pMessage->MsgBody.SendDTMFDigitsMessage.wNumDigits )
            {
                // signal incoming
                PostLineEvent(
                    LINE_MONITORDIGITS,
                    (DWORD_PTR)*pwch,
                    LINEDIGITMODE_DTMF,
                    GetTickCount()
                    );

                ++pwch;
                indexI++;
            }
        }
        Unlock();
        break;

    case SP_MSG_LegacyDefaultAlias:

        if( pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars > 0 )
        {
            if( !RasIsRegistered() )
            {
                _ASSERTE( m_pwszDisplay == NULL );
                
                m_pwszDisplay = new WCHAR[
                    pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars ];
            
                if( m_pwszDisplay != NULL )
                {
                    CopyMemory( 
                        (PVOID)m_pwszDisplay,
                        pMessage->pWideChars,
                        sizeof(WCHAR) * pMessage -> MsgBody.LegacyDefaultAliasMessage.wNumChars
                        );
                }
            }
        }

        Unlock();
        break;

    case SP_MSG_H245PDU:

        if( (pMessage ->pEncodedASNBuf) && (pMessage->dwEncodedASNSize != 0) )
        {
            pH245PDU.value = pMessage ->pEncodedASNBuf;
            pH245PDU.length = pMessage->dwEncodedASNSize;
            fResult = SendQ931Message( NO_INVOKEID, 0, (ULONG_PTR)&pH245PDU,
                FACILITYMESSAGETYPE, NO_H450_APDU );
        }
        Unlock();
        break;

    case SP_MSG_RASRegistrationEvent:   
    default:

        _ASSERTE(0);
        Unlock();
        break;
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "HandleMSPMessage exited:%p.",this ));
    return fResult;
}


//!!always called in a lock
void
CH323Call::SendMSPMessage(
                          IN TspMspMessageType messageType,
                          IN BYTE* pbEncodedBuf,
                          IN DWORD dwLength,
                          IN HDRVCALL hReplacementCall
                         )
{
    TspMspMessageEx messageEx;
    HTAPIMSPLINE    hMSP = MSP_HANDLE_UNKNOWN;
    int             iError = 0;
    int             iLen = sizeof(SOCKADDR_IN);
    SOCKADDR_IN*    psaLocalQ931Addr = NULL;

    H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPMessage:%s entered:%p.",
        H323TSPMessageToString(messageType), this ));

    messageEx.message.MessageType = messageType;

    switch( messageType )
    {
    case SP_MSG_InitiateCall:

        messageEx.message.MsgBody.InitiateCallMessage.hTSPReplacementCall = 
            (HANDLE)hReplacementCall;
        messageEx.message.MsgBody.InitiateCallMessage.hTSPConferenceCall = 
            m_hdConf;

        psaLocalQ931Addr = 
            &messageEx.message.MsgBody.InitiateCallMessage.saLocalQ931Addr;
        ZeroMemory( (PVOID)psaLocalQ931Addr, sizeof(SOCKADDR_IN) );

        *psaLocalQ931Addr = m_LocalAddr;
        psaLocalQ931Addr->sin_family = AF_INET;

        break;

    case SP_MSG_PrepareToAnswer:

        if( (dwLength<=0) || (dwLength > sizeof(messageEx.pEncodedASN)) || 
            (!pbEncodedBuf) )
        {
            CloseCall( 0 );
            return;
        }

        messageEx.message.MsgBody.PrepareToAnswerMessage.hReplacementCall = 
            (HANDLE)hReplacementCall;
        
        psaLocalQ931Addr = 
            &messageEx.message.MsgBody.PrepareToAnswerMessage.saLocalQ931Addr;
        ZeroMemory( (PVOID)psaLocalQ931Addr, sizeof(SOCKADDR_IN) );

        *psaLocalQ931Addr = m_LocalAddr;
        psaLocalQ931Addr->sin_family = AF_INET;
        
        //send the received Setup message. This should have the information
        //about m_pPeerFastStart param as wel
        CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
                (PVOID)pbEncodedBuf, dwLength );
        break;

    case SP_MSG_SendDTMFDigits:

        if( (dwLength<=0) || (dwLength > sizeof(messageEx.pEncodedASN)) || 
            (!pbEncodedBuf) )
        {
            CloseCall( 0 );
			return;
		}

		hMSP = m_htMSPLine;
		messageEx.message.MsgBody.SendDTMFDigitsMessage.wNumDigits = 
			(WORD)dwLength;

		dwLength = (dwLength+1) * sizeof(WCHAR);
		CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
			(PVOID)pbEncodedBuf, dwLength );

		break;

	case SP_MSG_ConnectComplete:
	case SP_MSG_CallShutdown:

		//dont set anything
		hMSP = m_htMSPLine;
		break;

	case SP_MSG_H245PDU:
	case SP_MSG_AnswerCall:

		hMSP = m_htMSPLine;
		break;

	case SP_MSG_Hold:

		hMSP = m_htMSPLine;
		messageEx.message.MsgBody.HoldMessage.fHold = (BOOL)dwLength;
		dwLength = 0;
		break;
	}

	messageEx.message.dwMessageSize = sizeof(TspMspMessage) + dwLength
							- ((dwLength)?sizeof(WORD):0);
		
	if( messageType == SP_MSG_SendDTMFDigits )
	{
		messageEx.message.dwEncodedASNSize = 0;
	}
	else
	{
		messageEx.message.dwEncodedASNSize = dwLength;
	}
	
	//send msp message
	PostLineEvent (
		LINE_SENDMSPDATA,
		(DWORD_PTR)hMSP, //This handle should be NULL when htCall param is a valid value
		(DWORD_PTR)&(messageEx.message),
		messageEx.message.dwMessageSize);

	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPMessage exited:%p.",this ));
	return;
}


//always called in lock
void
CH323Call::SendMSPStartH245(
	PH323_ADDR pPeerH245Addr,
	PH323_FASTSTART pPeerFastStart
	)
{
	TspMspMessageEx messageEx;
	WORD			wEncodedLength;
	BYTE*			pEncodedASNBuffer;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPStartH245 entered:%p.", this ));

	wEncodedLength = 0;

	messageEx.message.MessageType = SP_MSG_StartH245;
	messageEx.message.MsgBody.StartH245Message.hMSPReplaceCall = NULL;
	messageEx.message.MsgBody.StartH245Message.hTSPReplacementCall = 
		(HANDLE)pPeerH245Addr;
	ZeroMemory( messageEx.message.MsgBody.StartH245Message.ConferenceID,
		sizeof(GUID) );

	messageEx.message.MsgBody.StartH245Message.fH245TunnelCapability = FALSE;
	messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = FALSE;

	memset( (PVOID)&messageEx.message.MsgBody.StartH245Message.saH245Addr,
			0, sizeof(SOCKADDR_IN) );

	//for outgoing call send the fast start proposal.
	if( (m_dwOrigin==LINECALLORIGIN_OUTBOUND) || pPeerH245Addr )
	{
		if( pPeerH245Addr == NULL )
		{
			pPeerFastStart = m_pPeerFastStart;
		}

		if( pPeerFastStart != NULL )
		{
			if( !EncodeFastStartProposal( pPeerFastStart, &pEncodedASNBuffer,
				&wEncodedLength ) )
			{
				CloseCall( 0 );
				return;
			}

			CopyMemory( (PVOID)messageEx.message.pEncodedASNBuf,
				(PVOID)pEncodedASNBuffer, wEncodedLength );
			
			ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedASNBuffer );
		}
	}

	//If outgoing call send peer's H245 address
	if( (m_dwOrigin == LINECALLORIGIN_OUTBOUND) || pPeerH245Addr )
	{
		if( pPeerH245Addr == NULL )
		{
			pPeerH245Addr = &m_peerH245Addr;
		}

		messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = FALSE;
		if( pPeerH245Addr->Addr.IP_Binary.dwAddr != 0 )
		{
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_family = AF_INET;
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_port = 
				htons(pPeerH245Addr->Addr.IP_Binary.wPort);
			messageEx.message.MsgBody.StartH245Message.saH245Addr.sin_addr.s_addr = 
				htonl(pPeerH245Addr->Addr.IP_Binary.dwAddr);

			messageEx.message.MsgBody.StartH245Message.fH245AddressPresent = TRUE;
		}
	}

	//set the Q931 address
	ZeroMemory( (PVOID)&messageEx.message.MsgBody.StartH245Message.saQ931Addr, 
			sizeof(SOCKADDR_IN) );

	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_family = AF_INET;
	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_port = 
		htons( m_CalleeAddr.Addr.IP_Binary.wPort );
	messageEx.message.MsgBody.StartH245Message.saQ931Addr.sin_addr.s_addr = 
		htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );

	messageEx.message.MsgBody.StartH245Message.fH245TunnelCapability = 
		(m_fh245Tunneling & REMOTE_H245_TUNNELING) &&
		(m_fh245Tunneling & LOCAL_H245_TUNNELING);

	messageEx.message.dwMessageSize = sizeof(messageEx.message) + 
		wEncodedLength - ((wEncodedLength)?1:0);

	messageEx.message.dwEncodedASNSize = wEncodedLength; 

	// send msp message
	PostLineEvent (
		LINE_SENDMSPDATA,
		//this handle should be NULL when htCall is a valid handle.
		(DWORD_PTR)NULL, 
		(DWORD_PTR)&(messageEx.message),
		messageEx.message.dwMessageSize);
		
	m_dwFlags |= H245_START_MSG_SENT;

	H323DBG(( DEBUG_LEVEL_ERROR, "SendMSPStartH245 exited:%p.",this ));
	return;
}


//always called in lock
BOOL
CH323Call::AddU2U(
					IN DWORD dwDirection,
					IN DWORD dwDataSize,
					IN PBYTE pData
				 )
		
/*++

Routine Description:

	Create user user structure and adds to list.

Arguments:

	pLftHead - Pointer to list in which to add user user info.

	dwDataSize - Size of buffer pointed to by pData.

	pData - Pointer to user user info.

Return Values:

	Returns true if successful.
	
--*/

{
    PLIST_ENTRY     pListHead = NULL;
    PUserToUserLE   pU2ULE;
        
    H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U entered:%p.",this ));

    if( dwDirection == U2U_OUTBOUND )
    {
        pListHead = &m_OutgoingU2U;
    }
    else
    {
        pListHead = &m_IncomingU2U;
    }

    // validate data buffer pointer and size
    if( (pData != NULL) && (dwDataSize > 0) )
    {
        // allocate memory for user user info
        pU2ULE = new UserToUserLE;

        // validate pointer
        if (pU2ULE == NULL)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "could not allocate user user info." ));

            // failure
            return FALSE;
        }

        // aim pointer at the end of the buffer by default
        pU2ULE->pU2U = new BYTE[ dwDataSize ];

        // validate pointer
        if (pU2ULE->pU2U == NULL)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "could not allocate user user info." ));

            delete pU2ULE; 

            // failure
            return FALSE;
        }

        pU2ULE->dwU2USize = dwDataSize;

        // transfer user user info into list entry
        CopyMemory( (PVOID)pU2ULE->pU2U, (PVOID)pData, pU2ULE->dwU2USize);

        // add list entry to back of list
        InsertTailList(pListHead, &pU2ULE->Link);

        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "added user user info 0x%08lx (%d bytes).",
            pU2ULE->pU2U,
            pU2ULE->dwU2USize
            ));
    }

    H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U exited:%p.",this ));
    // success
    return TRUE;
}


		
/*++

Routine Description:

	Create user user structure and adds to list.
	!!always called in lock.

Arguments:

	pLftHead - Pointer to list in which to add user user info.

	dwDataSize - Size of buffer pointed to by pData.

	pData - Pointer to user user info.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::AddU2UNoAlloc(
	IN DWORD dwDirection,
	IN DWORD dwDataSize,
	IN PBYTE pData
	)
{
	PLIST_ENTRY 	pListHead = NULL;
	PUserToUserLE	pU2ULE;
		
	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
	{
		pListHead = &m_OutgoingU2U;
	}
	else
	{
		pListHead = &m_IncomingU2U;
	}

	// validate data buffer pointer and size
	if( (pData != NULL) && (dwDataSize > 0) )
	{
		// allocate memory for user user info
		pU2ULE = new UserToUserLE;

		// validate pointer
		if (pU2ULE == NULL)
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate user user info." ));

			// failure
			return FALSE;
		}

		// aim pointer at the end of the buffer by default
		pU2ULE->pU2U = pData;
		pU2ULE->dwU2USize = dwDataSize;

		
		// add list entry to back of list
		InsertTailList(pListHead, &pU2ULE->Link);

		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"added user user info 0x%08lx (%d bytes).",
			pU2ULE->pU2U,
			pU2ULE->dwU2USize
			));
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "AddU2U exited:%p.",this ));
	// success
	return TRUE;
}


//!!must be always called in a lock.
BOOL
CH323Call::RemoveU2U(
					IN DWORD dwDirection,
					IN PUserToUserLE * ppU2ULE
					)
		
/*++

Routine Description:

	Removes user user info structure from list.

Arguments:

	pListHead - Pointer to list in which to remove user user info.

	ppU2ULE - Pointer to pointer to list entry.

Return Values:

	Returns true if successful.
	
--*/

{
	PLIST_ENTRY pListHead = NULL;
	PLIST_ENTRY pLE;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "RemoveU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
	{
		pListHead = &m_OutgoingU2U;
	}
	else
	{
		pListHead = &m_IncomingU2U;
	}

	// process list until empty
	if( IsListEmpty(pListHead) == FALSE )
	{
		// retrieve first entry
		pLE = RemoveHeadList(pListHead);

		// convert list entry to structure pointer
		*ppU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"removed user user info 0x%08lx (%d bytes).",
			(*ppU2ULE)->pU2U, (*ppU2ULE)->dwU2USize ));
	
		H323DBG(( DEBUG_LEVEL_ERROR, "RemoveU2U exited:%p.",this ));
		// success
		return TRUE;
	}
			
	// failure
	return FALSE;
}


BOOL
CH323Call::FreeU2U(
					IN DWORD dwDirection
				  )
		
/*++

Routine Description:

	Releases memory for user user list.
	!!must be always called in a lock.

Arguments

	pListHead - Pointer to list in which to free user user info.

Return Values:

	Returns true if successful.
	
--*/

{
	PLIST_ENTRY 	pLE;
	PUserToUserLE	pU2ULE;
	PLIST_ENTRY 	pListHead = NULL;
		
	H323DBG(( DEBUG_LEVEL_ERROR, "FreeU2U entered:%p.",this ));

	if( dwDirection == U2U_OUTBOUND )
    {
        pListHead = &m_OutgoingU2U;
    }
	else
    {
		pListHead = &m_IncomingU2U;
    }

	// process list until empty
	while( IsListEmpty(pListHead) == FALSE ) 
	{
		// retrieve first entry
		pLE = RemoveHeadList(pListHead);

		// convert list entry to structure pointer
		pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		//	release memory
		if( pU2ULE )
		{
			delete pU2ULE;
			pU2ULE = NULL;
		}
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "FreeU2U exited:%p.",this ));
	// success
	return TRUE;
}


/*++

Routine Description:

	Resets call object to original state for re-use.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

void
CH323Call::Shutdown(
					OUT BOOL * fDelete
				   )
{	 
	H323DBG(( DEBUG_LEVEL_ERROR, "Shutdown entered:%p.",this ));

	if( !(m_dwFlags & CALLOBJECT_INITIALIZED) )
	{
		return;
	}

	//acquire the lock on call table before acquiring the lock on call object
	g_pH323Line -> LockCallTable();
	Lock();

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		Unlock();
		g_pH323Line -> UnlockCallTable();

		return;
	}

	// reset tapi info
	m_dwCallState		= LINECALLSTATE_UNKNOWN;
	m_dwCallStateMode	= 0;
	m_dwOrigin			= LINECALLORIGIN_UNKNOWN;
	m_dwAddressType 	= 0;
	m_dwIncomingModes	= 0;
	m_dwOutgoingModes	= 0;
	m_dwRequestedModes	= 0;
	m_fMonitoringDigits = FALSE;

	// reset tapi handles
	m_htCall	= (HTAPICALL)NULL;

	// reset addresses
	memset( (PVOID)&m_CalleeAddr,0,sizeof(H323_ADDR));
	memset( (PVOID)&m_CallerAddr,0,sizeof(H323_ADDR));

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting calleealias:%p.",this ));
	FreeAliasNames( m_pCalleeAliasNames );
	m_pCalleeAliasNames = NULL;

	if( m_pCallerAliasNames != NULL )
	{
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	
		FreeAliasNames( m_pCallerAliasNames );
		m_pCallerAliasNames = NULL;
	}

	//reset non standard data
	memset( (PVOID)&m_NonStandardData, 0, sizeof(H323NonStandardData) );

	// release user user information
	FreeU2U( U2U_OUTBOUND );
	FreeU2U( U2U_INBOUND );

	//shutdown the Q931 call if not shutdown yet
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( m_hCallEstablishmentTimer )
	{
		DeleteTimerQueueTimer(H323TimerQueue, m_hCallEstablishmentTimer, NULL);
		m_hCallEstablishmentTimer = NULL;
	}
	
	if( m_hCallDivertOnNATimer )
	{
		DeleteTimerQueueTimer(H323TimerQueue, m_hCallDivertOnNATimer, NULL);
		m_hCallDivertOnNATimer = NULL;
	}
	
	*fDelete = FALSE;
	if( m_IoRefCount == 0 )
	{
		*fDelete = TRUE;
	}

	m_dwStateMachine = Q931_CALL_STATE_NONE;
	if( m_callSocket != INVALID_SOCKET )
	{
		if(shutdown( m_callSocket, SD_BOTH ) == SOCKET_ERROR)
		{
			H323DBG((DEBUG_LEVEL_TRACE, "couldn't shutdown the socket:%d, %p.",
				WSAGetLastError(), this ));
		}

		closesocket( m_callSocket );
		m_callSocket = INVALID_SOCKET;
	}

	m_pwszDisplay = NULL;

	FreeVendorInfo( &m_peerVendorInfo );

	if( m_peerNonStandardData.sData.pOctetString )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "deleting nonstd:%p.",this ));
		delete m_peerNonStandardData.sData.pOctetString;
		m_peerNonStandardData.sData.pOctetString = NULL;
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting xtraalias:%p.",this ));
	FreeAliasNames( m_pPeerExtraAliasNames );
	m_pPeerExtraAliasNames = NULL;

		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting display:%p.",this ));
	if( m_pPeerDisplay )
	{
		delete m_pPeerDisplay;
		m_pPeerDisplay = NULL;
	}

	if( m_CallData.pOctetString != NULL )
	{
		delete m_CallData.pOctetString;
	}
		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting hdconf:%p.",this ));
	// delete conference 
	if( m_hdConf != NULL )
	{
		g_pH323Line -> GetH323ConfTable() -> Remove( m_hdConf );
		delete m_hdConf;
		m_hdConf = NULL;
	}

	H323DBG(( DEBUG_LEVEL_ERROR, "deleting preparetoans:%p.",this ));
	if( m_prepareToAnswerMsgData.pbBuffer )
    {
		delete m_prepareToAnswerMsgData.pbBuffer;
    }

	ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting drq timer:%p.",this ));
	//ras related data structures
	if( m_hDRQTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hDRQTimer, NULL );
		m_hDRQTimer = NULL;
	}
		
	H323DBG(( DEBUG_LEVEL_ERROR, "deleting arq timer:%p.",this ));
	if( m_hARQTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hARQTimer, NULL );
		m_hARQTimer = NULL;
	}

	if( m_pPeerFastStart != NULL )
	{
		FreeFastStart( m_pPeerFastStart );
		m_pPeerFastStart = NULL;
	}

	if( m_pFastStart != NULL )
	{
		FreeFastStart( m_pFastStart );
		m_pFastStart = NULL;
	}

	if( m_pARQExpireContext != NULL )
	{
		delete m_pARQExpireContext;
		m_pARQExpireContext = NULL;
	}

	if( m_pDRQExpireContext != NULL )
	{
		delete m_pDRQExpireContext;
		m_pDRQExpireContext = NULL;
	}

	FreeCallForwardData();

	g_pH323Line -> RemoveCallFromTable (m_hdCall);

	m_dwFlags |= CALLOBJECT_SHUTDOWN;

	Unlock();
	g_pH323Line -> UnlockCallTable();
		
	H323DBG(( DEBUG_LEVEL_ERROR, "Shutdown exited:%p.",this ));
	return;
}


void
CH323Call::FreeCallForwardData()
{
	if( m_pCallReroutingInfo )
	{
		FreeCallReroutingInfo();
	}

	if( m_hCheckRestrictionTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCheckRestrictionTimer, 
			NULL );
		m_hCheckRestrictionTimer = NULL;
	}

	if( m_hCallReroutingTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCallReroutingTimer, NULL );
		m_hCallReroutingTimer = NULL;
	}

	if( m_hCTIdentifyTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
		m_hCTIdentifyTimer = NULL;
	}

	if( m_hCTIdentifyRRTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
		m_hCTIdentifyRRTimer = NULL;
	}

	if( m_hCTInitiateTimer )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hCTInitiateTimer, NULL );
		m_hCTInitiateTimer = NULL;
	}

	if( m_pTransferedToAlias )
	{
		FreeAliasNames( m_pTransferedToAlias );
		m_pTransferedToAlias = NULL;
	}

	if( m_dwCallType & CALLTYPE_TRANSFERED2_CONSULT )
	{
		g_pH323Line -> RemoveFromCTCallIdentityTable( m_hdCall );
	}

	if( m_H450ASNCoderInfo.pEncInfo )
	{
		TermH450ASNCoder();
	}

	if( m_pCallForwardParams )
	{
		FreeCallForwardParams( m_pCallForwardParams );
		m_pCallForwardParams = NULL;
	}

	if( m_pForwardAddress )
	{
		FreeForwardAddress( m_pForwardAddress );
		m_pForwardAddress = NULL;
	}
}


BOOL
CH323Call::ResolveCallerAddress(void)
		
/*++

Routine Description:

	Resolves caller address from callee address.
	!!must be always called in a lock.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

{
	INT 	 nStatus;
	SOCKET	 hCtrlSocket = INVALID_SOCKET;
	SOCKADDR CalleeSockAddr;
	SOCKADDR CallerSockAddr;
	DWORD	 dwNumBytesReturned = 0;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveCallerAddress entered:%p.",this ));

	// allocate control socket
	hCtrlSocket = WSASocket(
					AF_INET,			// af
					SOCK_DGRAM, 		// type
					IPPROTO_IP, 		// protocol
					NULL,				// lpProtocolInfo
					0,					// g
					WSA_FLAG_OVERLAPPED // dwFlags
					);

	// validate control socket
	if (hCtrlSocket == INVALID_SOCKET)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error %d creating control socket.", WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// initialize ioctl parameters
	memset( (PVOID)&CalleeSockAddr,0,sizeof(SOCKADDR));
	memset( (PVOID)&CallerSockAddr,0,sizeof(SOCKADDR));

	// initialize address family
	CalleeSockAddr.sa_family = AF_INET;

	// transfer callee information
	((SOCKADDR_IN*)&CalleeSockAddr)->sin_addr.s_addr =
		htonl(m_CalleeAddr.Addr.IP_Binary.dwAddr);

	// query stack
	nStatus = WSAIoctl(
				hCtrlSocket,
				SIO_ROUTING_INTERFACE_QUERY,
				&CalleeSockAddr,
				sizeof(SOCKADDR),
				&CallerSockAddr,
				sizeof(SOCKADDR),
				&dwNumBytesReturned,
				NULL,
				NULL
				);

	// release handle
	closesocket(hCtrlSocket);

	// validate return code
	if (nStatus == SOCKET_ERROR)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling SIO_ROUTING_INTERFACE_QUERY.",
			WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// save interface address of best route
	m_CallerAddr.nAddrType = H323_IP_BINARY;
	m_CallerAddr.Addr.IP_Binary.dwAddr =
		ntohl(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr);
	m_CallerAddr.Addr.IP_Binary.wPort =
		LOWORD(g_RegistrySettings.dwQ931ListenPort);
	m_CallerAddr.bMulticast =
		IN_MULTICAST(m_CallerAddr.Addr.IP_Binary.dwAddr);

	H323DBG(( DEBUG_LEVEL_TRACE,
		"caller address resolved to %s.",
		H323AddrToString(((SOCKADDR_IN*)&CallerSockAddr)->sin_addr.s_addr) ));

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveCallerAddress exited:%p.",this ));
	// success
	return TRUE;
}


BOOL
CH323Call::ResolveE164Address(
								IN LPCWSTR pwszDialableAddr
							 )
		
/*++

Routine Description:

	Resolves E.164 address ("4259367111").
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

{
	WCHAR wszAddr[H323_MAXDESTNAMELEN+1];
	DWORD dwE164AddrSize;
   
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveE164Address entered:%p.",this ));

	// make sure pstn gateway has been specified
	if ((g_RegistrySettings.fIsGatewayEnabled == FALSE) ||
		(g_RegistrySettings.gatewayAddr.nAddrType == 0))
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"pstn gateway not specified."
			));

		// failure
		return FALSE;
	}

	// save gateway address as callee address
	m_CalleeAddr = g_RegistrySettings.gatewayAddr;

	dwE164AddrSize = ValidateE164Address( pwszDialableAddr, wszAddr );
	if( dwE164AddrSize == 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"invlid e164 callee alias ."));

		return FALSE;
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE,
			"callee alias resolved to E.164 number." ));

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveE164Address exited:%p.",this ));
	
	//determine caller address
	return ResolveCallerAddress();
}


DWORD
ValidateE164Address(
				   LPCWSTR pwszDialableAddr,
				   WCHAR*  wszAddr
				   )
{
	DWORD dwE164AddrSize = 0;
	WCHAR * pwszValidE164Chars;
	WCHAR wszValidE164Chars[] = { H323_ALIAS_H323_PHONE_CHARS L"\0" };

	// process until termination char
	while (*pwszDialableAddr != L'\0')
	{
		// reset pointer to valid characters
		pwszValidE164Chars = wszValidE164Chars;

		// process until termination char
		while (*pwszValidE164Chars != L'\0')
		{
			// see if valid E.164 character specified
			if (*pwszDialableAddr == *pwszValidE164Chars)
			{
				// save valid character in temp buffer
				wszAddr[dwE164AddrSize++] = *pwszDialableAddr;

				break;
			}

			// next valid char
			++pwszValidE164Chars;
		}

		// next input char
		++pwszDialableAddr;
	}

	// terminate string
	wszAddr[dwE164AddrSize++] = L'\0';

	// validate string
	if (dwE164AddrSize == 0)
	{
		H323DBG(( DEBUG_LEVEL_TRACE,
			"no valid E.164 characters in string." ));
	}

	return dwE164AddrSize;
}


		
/*++

Routine Description:

	Resolves IP address ("172.31.255.231") or DNS entry ("NIKHILB1").
	!!must be always called in a lock.

Arguments:

	pszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::ResolveIPAddress(
	IN LPSTR pszDialableAddr
	)
{
	DWORD			dwIPAddr;
	struct hostent* pHost;

	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveIPAddress entered:%p.",this ));
	
	// attempt to convert ip address
	dwIPAddr = inet_addr(pszDialableAddr);

	// see if address converted
	if( dwIPAddr == INADDR_NONE )
	{
		// attempt to lookup hostname
		pHost = gethostbyname(pszDialableAddr);

		// validate pointer
		if( pHost != NULL )
		{
			// retrieve host address from structure
			dwIPAddr = *(unsigned long *)pHost->h_addr;
		}
	}

	// see if address converted
	if( dwIPAddr == INADDR_NONE )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
				  "error 0x%08lx resolving IP address.",
				  WSAGetLastError() ));

		// failure
		return FALSE;
	}

	// save converted address
	m_CalleeAddr.nAddrType = H323_IP_BINARY;
	m_CalleeAddr.Addr.IP_Binary.dwAddr = ntohl(dwIPAddr);
	m_CalleeAddr.Addr.IP_Binary.wPort =
		LOWORD(g_RegistrySettings.dwQ931ListenPort);
	m_CalleeAddr.bMulticast =
		IN_MULTICAST(m_CalleeAddr.Addr.IP_Binary.dwAddr);

	H323DBG(( DEBUG_LEVEL_TRACE,
		"callee address resolved to %s:%d.",
		H323AddrToString(dwIPAddr),
		m_CalleeAddr.Addr.IP_Binary.wPort ));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveIPAddress exited:%p.",this ));

	// determine caller address
	return ResolveCallerAddress();
}


BOOL
CH323Call::ResolveEmailAddress(
	IN LPCWSTR	  pwszDialableAddr,
	IN LPSTR	  pszUser,
	IN LPSTR	  pszDomain
	)
		
/*++

Routine Description:

	Resolves e-mail address ("nikhilb@microsoft.com").
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

	pszUser - Specifies a pointer to the user component of e-mail name.

	pszDomain - Specified a pointer to the domain component of e-mail name.

Return Values:

	Returns true if successful.
	
--*/

{
	DWORD dwAddrSize;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveEmailAddress entered:%p.",this ));

	// size destination address string
	dwAddrSize = wcslen(pwszDialableAddr) + 1;

	// attempt to resolve domain locally
	if( ResolveIPAddress( pszDomain) ) 
	{
		// success
		return TRUE;
	}

	// make sure proxy has been specified
	if( (g_RegistrySettings.fIsProxyEnabled == FALSE) ||
		(g_RegistrySettings.proxyAddr.nAddrType == 0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "proxy not specified." ));

		// failure
		return FALSE;
	}

	// save proxy address as callee address
	m_CalleeAddr = g_RegistrySettings.proxyAddr;

	H323DBG(( DEBUG_LEVEL_TRACE,
		"callee alias resolved to H.323 alias."));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveEmailAddress exited:%p.",this ));

	// determine caller address
	return ResolveCallerAddress();
}


		
/*++

Routine Description:

	Resolves remote address and determines the correct local address
	to use in order to reach remote address.
	!!must be always called in a lock.

Arguments:

	pwszDialableAddr - Specifies a pointer to the dialable address specified
		by the TAPI application.

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::ResolveAddress(
	IN LPCWSTR pwszDialableAddr
	)
{
	CHAR szDelimiters[] = "@ \t\n";
	CHAR szAddr[H323_MAXDESTNAMELEN+1];
	LPSTR pszUser = NULL;
	LPSTR pszDomain = NULL;
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveAddress entered:%p.",this ));

	// validate pointerr
	if (pwszDialableAddr == NULL)
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "null destination address." ));

		// failure
		return FALSE;
	}

	H323DBG(( DEBUG_LEVEL_TRACE,
		"resolving %s %S.",
		H323AddressTypeToString( m_dwAddressType),
		pwszDialableAddr ));

	// check whether phone number has been specified
	if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
	{
		// need to direct call to pstn gateway
		return ResolveE164Address( pwszDialableAddr);
	}

	// convert address from unicode
	if (WideCharToMultiByte(
			CP_ACP,
			0,
			pwszDialableAddr,
			-1,
			szAddr,
			sizeof(szAddr),
			NULL,
			NULL
			) == 0)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could not convert address from unicode." ));

		// failure
		return FALSE;
	}

	// parse user name
	pszUser = strtok(szAddr, szDelimiters);

	// parse domain name
	pszDomain = strtok(NULL, szDelimiters);

	// validate pointer
	if (pszUser == NULL)
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "could not parse destination address." ));

		// failure
		return FALSE;
	}

	// validate pointer
	if (pszDomain == NULL)
	{
		// switch pointers
		pszDomain = pszUser;

		// re-initialize
		pszUser = NULL;
	}

	H323DBG(( DEBUG_LEVEL_VERBOSE,
		"resolving user %s domain %s.",
		pszUser,
		pszDomain
		));
	
	H323DBG(( DEBUG_LEVEL_ERROR, "ResolveAddress exited:%p.",this ));

	// process e-mail and domain names
	return ResolveEmailAddress(
				pwszDialableAddr,
				pszUser,
				pszDomain
				);
}


BOOL
/*++

Routine Description:

	Validate optional call parameters specified by user.
	
	!!no need to call in a lock because not added to the call table yet
	
Arguments:

	pCallParams - Pointer to specified call parameters to be
		validated.

	pwszDialableAddr - Pointer to the dialable address specified
		by the TAPI application.

	pdwStatus - Pointer to DWORD containing error code if this
		routine fails for any reason.

Return Values:

	Returns true if successful.
	
--*/

CH323Call::ValidateCallParams(
	IN LPLINECALLPARAMS pCallParams,
	IN LPCWSTR			pwszDialableAddr,
	IN PDWORD			pdwStatus
	)
{
	DWORD dwMediaModes = H323_LINE_DEFMEDIAMODES;
	DWORD dwAddrSize;
	WCHAR wszAddr[H323_MAXDESTNAMELEN+1];

	PH323_ALIASNAMES pAliasList;
	WCHAR* wszMachineName;

	H323DBG(( DEBUG_LEVEL_TRACE, "ValidateCallParams entered:%p.", this ));

	H323DBG(( DEBUG_LEVEL_VERBOSE, "clearing unknown media mode." ));
	
	// validate pointer
	if( (pCallParams == NULL) || (pwszDialableAddr == NULL) )
    {
		return FALSE;
    }

	// retrieve media modes specified
	dwMediaModes = pCallParams->dwMediaMode;

	// retrieve address type specified
	m_dwAddressType = pCallParams->dwAddressType;

	// see if we support call parameters
	if( pCallParams->dwCallParamFlags != 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support call parameters 0x%08lx.",
			pCallParams->dwCallParamFlags ));

		// do not support param flags
		*pdwStatus = LINEERR_INVALCALLPARAMS;
		
		// failure
		return FALSE;
	}

	// see if unknown bit is specified
	if( dwMediaModes & LINEMEDIAMODE_UNKNOWN )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"clearing unknown media mode." ));

		// clear unknown bit from modes
		dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
	}

	// see if both audio bits are specified 
	if( (dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
		(dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE) )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"clearing automated voice media mode." ));

		// clear extra audio bit from modes
		dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
	}

	// see if we support media modes specified
	if( dwMediaModes & ~H323_LINE_MEDIAMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support media modes 0x%08lx.", 
			pCallParams->dwMediaMode ));

		// do not support media mode
		*pdwStatus = LINEERR_INVALMEDIAMODE;

		// failure
		return FALSE;
	}

	// see if we support bearer modes
	if( pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support bearer mode 0x%08lx.",
			pCallParams->dwBearerMode ));

		// do not support bearer mode
		*pdwStatus = LINEERR_INVALBEARERMODE;

		// failure
		return FALSE;
	}

	// see if we support address modes
	if( pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"do not support address mode 0x%08lx.",
			pCallParams->dwAddressMode ));

		// do not support address mode
		*pdwStatus = LINEERR_INVALADDRESSMODE;

		// failure
		return FALSE;
	}

	// validate address id specified
	if (pCallParams->dwAddressID != 0 )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "address id 0x%08lx invalid.",
			pCallParams->dwAddressID ));

		// invalid address id
		*pdwStatus = LINEERR_INVALADDRESSID;
		
		// failure
		return FALSE;
	}

	// validate destination address type specified
	if( m_dwAddressType & ~H323_LINE_ADDRESSTYPES )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "address type 0x%08lx invalid.",
			pCallParams->dwAddressType ));

		// invalid address type
		*pdwStatus = LINEERR_INVALADDRESSTYPE;

		//failure
		return FALSE;
	}

	if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
	{
		dwAddrSize = ValidateE164Address( pwszDialableAddr, wszAddr );

		//add the callee alias
		if( dwAddrSize==0 )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"invlid e164 callee alias ."));

			return FALSE;
		}
		
		if( (dwAddrSize > MAX_E164_ADDR_LEN) || (dwAddrSize == 0) )
			return FALSE;
		
		if(!AddAliasItem( m_pCalleeAliasNames,
			  (BYTE*)wszAddr,
			  dwAddrSize * sizeof(WCHAR),
			  e164_chosen ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate for callee alias ."));
			// invalid destination addr
			*pdwStatus = LINEERR_INVALADDRESS;

			return FALSE;
		}
		
		H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", wszAddr ));
	}
	else
	{
		dwAddrSize = (wcslen(pwszDialableAddr)+1);

		if( (dwAddrSize > MAX_H323_ADDR_LEN) || (dwAddrSize == 0) )
			return FALSE;
		
		if(!AddAliasItem( m_pCalleeAliasNames,
			  (BYTE*)pwszDialableAddr,
			  dwAddrSize * sizeof(WCHAR),
			  h323_ID_chosen ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"could not allocate for callee alias ."));
			// invalid destination addr
			*pdwStatus = LINEERR_INVALADDRESS;

			return FALSE;
		}

		H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", pwszDialableAddr ));
	}

	// see if callee alias specified
	if( pCallParams->dwCalledPartySize > 0 ) 
	{
		//avoid duplicate aliases
		dwAddrSize *= sizeof(WCHAR);

		if( ( (m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER) ||
			  (memcmp(
					(PVOID)((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset),
					wszAddr,
					pCallParams->dwCalledPartySize ) != 0 ) 
			) &&
			( memcmp(
				(PVOID)((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset),
				pwszDialableAddr,
				pCallParams->dwCalledPartySize ) != 0 
			)
		  )
		{
			// allocate memory for callee string
			if( !AddAliasItem( m_pCalleeAliasNames,
				  (BYTE*)pCallParams + pCallParams->dwCalledPartyOffset,
				  pCallParams->dwCalledPartySize,
				  (m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER)?
				  h323_ID_chosen : e164_chosen) )
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
						"could not allocate caller name." ));

				// invalid address id
				*pdwStatus = LINEERR_NOMEM;

				// failure
				return FALSE;
			}

			H323DBG(( DEBUG_LEVEL_ERROR, "callee alias added:%S.", 
				((BYTE*)pCallParams + pCallParams->dwCalledPartyOffset) ));
		}
	}

	// see if caller name specified
	if( pCallParams->dwCallingPartyIDSize > 0 )
	{
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		// allocate memory for callee string
		if(!AddAliasItem( m_pCallerAliasNames,
			(BYTE*)pCallParams + pCallParams->dwCallingPartyIDOffset,
			pCallParams->dwCallingPartyIDSize,
			h323_ID_chosen ) )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
					"could not allocate caller name." ));

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
			
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}
	else if( RasIsRegistered() )
	{
		//ARQ message must have a caller alias
		pAliasList = RASGetRegisteredAliasList();
		wszMachineName = pAliasList -> pItems[0].pData;
		
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		
		//set the value for m_pCallerAliasNames
		if( !AddAliasItem( m_pCallerAliasNames,
			(BYTE*)(wszMachineName),
			sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
			pAliasList -> pItems[0].wType ) )
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
					"could not allocate caller name." ));

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
		
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}
		
	// check for user user information
	if( pCallParams->dwUserUserInfoSize > 0 )
	{
		// save user user info
		if (AddU2U( U2U_OUTBOUND, pCallParams->dwUserUserInfoSize,
			(LPBYTE)pCallParams + pCallParams->dwUserUserInfoOffset ) == FALSE )
		{
			//no need to free above aloocated memory for m_CalleeAlias and
			//m_CallerAlias

			// invalid address id
			*pdwStatus = LINEERR_NOMEM;

			// failure
			return FALSE;
		}
	}

	// save call data buffer.
	if( SetCallData( (LPBYTE)pCallParams + pCallParams->dwCallDataOffset,
			pCallParams->dwCallDataSize ) == FALSE )
	{
		//no need to free above aloocated memory for m_CalleeAlias and
		//m_CallerAlias

		// invalid address id
		*pdwStatus = LINEERR_NOMEM;

		// failure
		return FALSE;
	}
		
	// clear incoming modes
	m_dwIncomingModes = 0;
	
	// outgoing modes will be finalized after H.245 stage
	m_dwOutgoingModes = dwMediaModes | LINEMEDIAMODE_UNKNOWN;
	
	// save media modes specified
	m_dwRequestedModes = dwMediaModes;

	H323DBG(( DEBUG_LEVEL_TRACE, "ValidateCallParams exited:%p.", this ));
	// success
	return TRUE;
}

		
/*++

Routine Description:

	Associates call object with the specified conference id.

Arguments:

Return Values:

	Returns true if successful.
	
--*/

PH323_CONFERENCE
CH323Call::CreateConference (
	IN GUID* pConferenceId	OPTIONAL)

{
	int iresult;
	
	H323DBG(( DEBUG_LEVEL_TRACE, "CreateConference entered:%p.", this ));

	Lock();

	_ASSERTE( m_hdConf == NULL );

	// create conference 
	m_hdConf = new H323_CONFERENCE( this );
		
	// validate 
	if ( m_hdConf == NULL )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could no allocate the conference object."));

		Unlock();
		return NULL;
	}

	if (pConferenceId)
	{
		m_ConferenceID = *pConferenceId;
	}
	else
	{
		iresult = UuidCreate (&m_ConferenceID);
  
		if ((iresult == RPC_S_OK) || (iresult ==RPC_S_UUID_LOCAL_ONLY))
		{
			H323DBG ((DEBUG_LEVEL_INFO, "generated new conference id (GUID)."));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR, 
				"failed to generate GUID for conference id: %d.", iresult ));
			ZeroMemory (&m_ConferenceID, sizeof m_ConferenceID);
		}
	}
	
	Unlock();

	H323DBG(( DEBUG_LEVEL_TRACE, "CreateConference exited:%p.", this ));
	return m_hdConf;
}


/*++

Routine Description:

	Initiates outbound call to specified destination.
	!!always called in a lock

Arguments:

	none

Return Values:

	Returns true if successful.
	
--*/

BOOL
CH323Call::PlaceCall(void)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "PlaceCall entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return FALSE;
	}

	// see if user user information specified
	CopyU2UAsNonStandard( U2U_OUTBOUND );

	if( m_pwszDisplay == NULL )
	{
		// see if caller alias specified
		if( m_pCallerAliasNames && m_pCallerAliasNames -> wCount )
		{
			 if((m_pCallerAliasNames ->pItems[0].wType == h323_ID_chosen) ||
				(m_pCallerAliasNames ->pItems[0].wType == e164_chosen) )
			 {
				// send caller name as display
				m_pwszDisplay = m_pCallerAliasNames -> pItems[0].pData;
	
				//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
			 }
			
			 //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
		}
	}

	// validate
	if( !SetupCall() )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE, "Q931 call: failed." ));
		return FALSE;
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "PlaceCall exited:%p.", this ));

	// return status
	return TRUE;
}


void
CH323Call::DropUserInitiated(
	IN DWORD dwDisconnectMode
	)
{
	//since this is a user initiated drop, the transfered call should also
	//be dropped for a primary call and vice versa
	if( IsTransferredCall( m_dwCallType ) && m_hdRelatedCall )
	{
		QueueTAPILineRequest( 
			TSPI_CLOSE_CALL, 
			m_hdRelatedCall, 
			NULL, 
			dwDisconnectMode,
			m_wCallReference );
	}

	DropCall(dwDisconnectMode);
}


//always called in lock
BOOL
/*++

Routine Description:

	Hangs up call (if necessary) and changes state to idle.

Arguments:

	dwDisconnectMode - Status code for disconnect.

Return Values:

	Returns true if successful.
	
--*/

CH323Call::DropCall(
					IN DWORD dwDisconnectMode
				   )
{
	PUserToUserLE pU2ULE = NULL;

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return FALSE;
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "DropCall entered:%p.", this ));

	if( (m_dwRASCallState == RASCALL_STATE_REGISTERED ) ||
		(m_dwRASCallState == RASCALL_STATE_ARQSENT ) )
	{
		//disengage from the GK
		SendDRQ( forcedDrop_chosen, NOT_RESEND_SEQ_NUM, TRUE );
	}

	// determine call state
	switch (m_dwCallState)
	{
	case LINECALLSTATE_CONNECTED:

		// hangup call (this will invoke async indication)
		// validate
		//encode ASN.1 and send Q931release message to the peer
		if(!SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			 //post a message to the callback thread to shutdown the H323 call
			 H323DBG(( DEBUG_LEVEL_ERROR,
				"error hanging up call 0x%08lx.", this ));
		}
		else
		{
			m_dwStateMachine = Q931_RELEASE_SENT;
	
			H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx hung up.", this ));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_OFFERING:

		// see if user user information specified
		CopyU2UAsNonStandard( U2U_OUTBOUND );

		// reject call
		//encode ASN.1 and send Q931Setup message to the peer
		if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			m_dwStateMachine = Q931_RELEASE_SENT;
			H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx rejected.", this ));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR, "error reject call 0x%08lx.",this));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_RINGBACK:
	case LINECALLSTATE_ACCEPTED:

		// cancel outbound call
		if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"error cancelling call 0x%08lx.", this ));
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_ERROR,
				"error reject call 0x%08lx.", this ));
		}

		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);

		break;

	case LINECALLSTATE_DIALING:
		
		// change call state to disconnected
		ChangeCallState(LINECALLSTATE_DISCONNECTED, dwDisconnectMode);
		
		break;

	case LINECALLSTATE_DISCONNECTED:

		//
		// disconnected but still need to clean up
		//
		break;

	case LINECALLSTATE_IDLE:

		//
		// call object already idle
		//

		if( (m_dwCallType == CALLTYPE_NORMAL) &&
			(m_dwStateMachine == Q931_SETUP_RECVD) )
		{
			if( SendQ931Message( NO_INVOKEID,
							 0,
							 0,
							 RELEASECOMPLMESSAGETYPE,
							 NO_H450_APDU ))
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
					"error cancelling call 0x%08lx.", this ));
			}
			else
			{
				H323DBG(( DEBUG_LEVEL_ERROR,
					"error reject call 0x%08lx.", this ));
			}
		}

		DropSupplementaryServicesCalls();

		return TRUE;
	}

	if( ( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall ) ||
		( (m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall ) )
	{
		m_dwCallState = LINECALLSTATE_IDLE;
	}
	else
	{
		// Tell the MSP to stop streaming.
		SendMSPMessage( SP_MSG_CallShutdown, 0, 0, NULL );

		// change call state to idle
		ChangeCallState( LINECALLSTATE_IDLE, 0 );
	}

	if( (m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall )
	{
		//drop the primary call
		if( !QueueTAPILineRequest( 
			TSPI_CLOSE_CALL,
			m_hdRelatedCall,
			NULL,
			LINEDISCONNECTMODE_NORMAL,
			NULL ) )
		{
			H323DBG((DEBUG_LEVEL_ERROR, "could not post H323 close event"));
		}		 
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "DropCall exited:%p.", this ));	
	// success
	return TRUE;
}


void
CH323Call::DropSupplementaryServicesCalls()
{
	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT) ||
		(m_dwCallType & CALLTYPE_DIVERTED_SERVED) ||
		(m_dwCallType & CALLTYPE_DIVERTEDSRC) ||
		(m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING) )
	{
		if( m_dwQ931Flags & Q931_CALL_CONNECTED )
		{
			if( SendQ931Message( NO_INVOKEID,
						 0,
						 0,
						 RELEASECOMPLMESSAGETYPE,
						 NO_H450_APDU ))
			{
				m_dwStateMachine = Q931_RELEASE_SENT;
				H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx rejected.", this ));
			}
		}

		g_pH323Line->m_fForwardConsultInProgress = FALSE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT) &&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//inform the user about failure of line forward operation
		if( m_dwCallDiversionState != H4503_CHECKRESTRICTION_SUCC )
		{
			(*g_pfnLineEventProc)(
				g_pH323Line->m_htLine,
				(HTAPICALL)NULL,
				(DWORD)LINE_ADDRESSSTATE,
				(DWORD)LINEADDRESSSTATE_FORWARD,
				(DWORD)LINEADDRESSSTATE_FORWARD,
				(DWORD)0
				);
		}
	}

	if( m_dwCallType & CALLTYPE_DIVERTEDSRC )
	{
		ChangeCallState( LINECALLSTATE_IDLE, 0 );
	}
}


//!!always called in a lock
BOOL
CH323Call::HandleConnectMessage(
							   IN Q931_CONNECT_ASN *pConnectASN
							   )
{
	PH323_CALL	pPrimaryCall = NULL;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleConnectMessage entered:%p.", this ));

	if( pConnectASN->fNonStandardDataPresent )
	{
		//add user user info
		if( AddU2UNoAlloc( U2U_INBOUND,
				pConnectASN->nonStandardData.sData.wOctetStringLength,
				pConnectASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in CONNECT PDU." ));
					
			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				// signal incoming
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0 );
			}

			//don't release the data buffer
			pConnectASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );

			goto cleanup;
		}
	}

	//get the vendor info
	if( pConnectASN->EndpointType.pVendorInfo )
	{
		FreeVendorInfo( &m_peerVendorInfo );

		m_peerVendorInfo = pConnectASN->VendorInfo;
		pConnectASN->EndpointType.pVendorInfo = NULL;
	}

	if( pConnectASN->h245AddrPresent )
	{
		m_peerH245Addr = pConnectASN->h245Addr;
	}

	//copy the fast start proposal
	if( pConnectASN->fFastStartPresent &&
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pConnectASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it 
		pConnectASN->pFastStart = NULL;
	}
	else
	{
		m_dwFastStart = FAST_START_NOTAVAIL;
	}

	if( ( (m_dwCallType & CALLTYPE_TRANSFEREDSRC)|| 
		  (m_dwCallType & CALLTYPE_DIVERTEDTRANSFERED) ) && m_hdRelatedCall )
	{
		QueueSuppServiceWorkItem( SWAP_REPLACEMENT_CALL,
			m_hdCall, (ULONG_PTR)m_hdRelatedCall );
	}
	else
	{
		//start H245
		SendMSPStartH245( NULL, NULL );

		SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );
	}
	
	//If we join MCU we get the conference ID of the conference we
	//joined and not the one that we sent in Setup message.
	if( IsEqualConferenceID( &pConnectASN->ConferenceID ) == FALSE )
	{
		H323DBG ((DEBUG_LEVEL_ERROR,
			"OnReceiveConnect: We received different conference id." ));

		m_ConferenceID = pConnectASN->ConferenceID;
	}

	//tell TAPI about state change
	ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
	
	FreeConnectASN( pConnectASN );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleConnectMessage exited:%p.", this ));
	return TRUE;

cleanup:

	FreeConnectASN( pConnectASN );
	return FALSE;
}


//!!always called in a lock
void 
CH323Call::HandleAlertingMessage(
								IN Q931_ALERTING_ASN * pAlertingASN
								)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleAlertingMessage entered:%p.", this ));

	if( pAlertingASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
			pAlertingASN->nonStandardData.sData.wOctetStringLength,
			pAlertingASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in ALERT PDU." ));
					// signal incoming

			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				PostLineEvent (
					LINE_CALLINFO,
					LINECALLINFOSTATE_USERUSERINFO, 0, 0 );
			}
			
			//don't release the data buffer
			pAlertingASN->fNonStandardDataPresent = FALSE;
		}
		else
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );
			return;
		}
	}

	if( pAlertingASN->fH245AddrPresent )
	{
		m_peerH245Addr = pAlertingASN->h245Addr;
	}

	if( pAlertingASN->fFastStartPresent && 
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pAlertingASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it 
		pAlertingASN->pFastStart = NULL;
		pAlertingASN->fFastStartPresent = FALSE;
	}

	//for DIVERTEDSRC, call its ok to tell TAPI about this state
	ChangeCallState( LINECALLSTATE_RINGBACK, 0 );

	/*if( pAlertingASN->fH245AddrPresent && !(m_dwFlags & H245_START_MSG_SENT) )
	{
		//start early H245
		SendMSPStartH245( NULL, NULL);
	}*/

	FreeAlertingASN( pAlertingASN );
		
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleAlertingMessage exited:%p.", this ));
	return;
}


//!!must be always called in a lock
BOOL
CH323Call::HandleSetupMessage( 
	IN Q931MESSAGE* pMessage
	)
{
	PH323_ALIASITEM pwszDivertedToAlias = NULL;
	WCHAR * 		pwszAliasName = NULL;
	WORD			wAliasLength = 0;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleSetupMessage entered:%p.", this ));

	if( m_pCallerAliasNames && (m_pCallerAliasNames -> wCount > 0) )
	{
		pwszAliasName = m_pCallerAliasNames->pItems[0].pData;
		wAliasLength = (m_pCallerAliasNames->pItems[0].wDataLength+1) 
			* sizeof(WCHAR);
	
		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}

	pwszDivertedToAlias = g_pH323Line->CallToBeDiverted( 
		pwszAliasName,
		wAliasLength,
		LINEFORWARDMODE_UNCOND | LINEFORWARDMODE_UNCONDSPECIFIC );

	if( pwszDivertedToAlias )
	{
		if( !InitiateCallDiversion( pwszDivertedToAlias, DiversionReason_cfu ) )
		{
			return FALSE;
		}
		return TRUE;
	}
	
	//send the proceeding message to the peer if not already sent by the GK
	//SendProceeding();
	
	if(RasIsRegistered())
	{
		if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
		{
			return FALSE;
		}

		//copy the data to be sent in preparetoanswer message
		if( m_prepareToAnswerMsgData.pbBuffer )
			delete m_prepareToAnswerMsgData.pbBuffer;
		ZeroMemory( (PVOID)&m_prepareToAnswerMsgData, sizeof(BUFFERDESCR) );

			
		m_prepareToAnswerMsgData.pbBuffer = 
			(BYTE*)new char[pMessage->UserToUser.wUserInfoLen];
		if( m_prepareToAnswerMsgData.pbBuffer == NULL )
		{
			return FALSE;
		}

		CopyMemory( (PVOID)m_prepareToAnswerMsgData.pbBuffer, 
					(PVOID)pMessage->UserToUser.pbUserInfo,
					pMessage->UserToUser.wUserInfoLen );

		m_prepareToAnswerMsgData.dwLength = pMessage->UserToUser.wUserInfoLen;
	}
	else
	{
		if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
		{
			MSPMessageData* pMSPMessageData = new MSPMessageData;
			if( pMSPMessageData == NULL )
			{
				return FALSE;
			}

			pMSPMessageData->hdCall = m_hdRelatedCall;
			pMSPMessageData->messageType = SP_MSG_PrepareToAnswer;
			
			pMSPMessageData->pbEncodedBuf = 
				new BYTE[pMessage->UserToUser.wUserInfoLen];
			if( pMSPMessageData->pbEncodedBuf == NULL )
			{
				delete pMSPMessageData;
				return FALSE;
			}

			CopyMemory( pMSPMessageData->pbEncodedBuf, 
				(PVOID)pMessage->UserToUser.pbUserInfo,
				pMessage->UserToUser.wUserInfoLen );

			pMSPMessageData->wLength = pMessage->UserToUser.wUserInfoLen;
			pMSPMessageData->hReplacementCall = m_hdCall;

			if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, 
				pMSPMessageData, WT_EXECUTEDEFAULT ) )
			{
				delete pMSPMessageData->pbEncodedBuf;
				delete pMSPMessageData;
				return FALSE;
			}
		}
		else
		{
			// signal incoming call
			_ASSERTE(!m_htCall);

			PostLineEvent (
				LINE_NEWCALL,
				(DWORD_PTR)m_hdCall,
				(DWORD_PTR)&m_htCall, 0);

			_ASSERTE( m_htCall );
			if( m_htCall == NULL )
				return FALSE;

			if( IsListEmpty(&m_IncomingU2U) == FALSE )
			{
				// signal incoming
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0);
			}
		
			ChangeCallState( LINECALLSTATE_OFFERING, 0 );
			
			//Send the new call message to the unspecified MSP
			SendMSPMessage( SP_MSG_PrepareToAnswer,
				pMessage->UserToUser.pbUserInfo,
				pMessage->UserToUser.wUserInfoLen, NULL );
		}
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleSetupMessage exited:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleCallDiversionFacility( 
	PH323_ADDR pAlternateAddress )
{
	PSTR pszAlias;
	WCHAR pwszAliasName[H323_MAXDESTNAMELEN];
	in_addr addr;

	if( m_pCallReroutingInfo == NULL )
	{
		m_pCallReroutingInfo = new CALLREROUTINGINFO;
		if( m_pCallReroutingInfo == NULL )
		{
			return FALSE;
		}

		ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
	}

	m_pCallReroutingInfo->diversionCounter = 1;
	m_pCallReroutingInfo->diversionReason = DiversionReason_cfu;

	//free any previous divertedTo alias
	if( m_pCallReroutingInfo->divertedToNrAlias )
	{
		FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
	}

	addr.S_un.S_addr = htonl( pAlternateAddress->Addr.IP_Binary.dwAddr );
	pszAlias = inet_ntoa( addr );
	if( pszAlias == NULL )
		return FALSE;

	m_pCallReroutingInfo->divertedToNrAlias = new H323_ALIASNAMES;
	if( m_pCallReroutingInfo->divertedToNrAlias == NULL )
	{
		return FALSE;
	}
	ZeroMemory( m_pCallReroutingInfo->divertedToNrAlias, 
		sizeof(H323_ALIASNAMES) );

	MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			pszAlias,
			strlen(pszAlias)+1,
			pwszAliasName,
			H323_MAXDESTNAMELEN
		   );

	if( !AddAliasItem( m_pCallReroutingInfo->divertedToNrAlias,
		pwszAliasName, h323_ID_chosen ) )
	{
		delete m_pCallReroutingInfo->divertedToNrAlias;
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
		return FALSE;
	}

	m_CalleeAddr = *pAlternateAddress;
 
	if( m_pCalleeAliasNames && m_pCalleeAliasNames->wCount )
	{
		m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;

		if( m_pCallReroutingInfo->divertingNrAlias != NULL )
		{
			ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
				sizeof(H323_ALIASNAMES) );

			if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias,
					m_pCalleeAliasNames->pItems[0].pData,
					m_pCalleeAliasNames->pItems[0].wType ) )
			{
				delete m_pCallReroutingInfo->divertingNrAlias;
				m_pCallReroutingInfo->divertingNrAlias = NULL;
			}
		}
	}
	
	m_dwCallType |= CALLTYPE_DIVERTEDSRC;
	m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallDiversionFacility exited:%p.", 
		this ));
	return TRUE;
}


BOOL
CH323Call::HandleCallDiversionFacility( 
	PH323_ALIASNAMES pAliasList )
{
	if( !m_pCallReroutingInfo )
	{
		m_pCallReroutingInfo = new CALLREROUTINGINFO;
		if( m_pCallReroutingInfo  == NULL )
		{
			return FALSE;
		}

		ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
	}

	m_pCallReroutingInfo->diversionCounter = 1;
	m_pCallReroutingInfo->diversionReason = DiversionReason_cfu;

	if( m_pCallReroutingInfo->divertedToNrAlias )
	{
		FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
		m_pCallReroutingInfo->divertedToNrAlias = NULL;
	}

	m_pCallReroutingInfo->divertedToNrAlias = pAliasList;
 
	if( m_pCalleeAliasNames && m_pCalleeAliasNames->wCount )
	{
		m_pCallReroutingInfo->divertingNrAlias = new H323_ALIASNAMES;

		if( m_pCallReroutingInfo->divertingNrAlias != NULL )
		{
			ZeroMemory( (PVOID)m_pCallReroutingInfo->divertingNrAlias, 
				sizeof(H323_ALIASNAMES) );

			if( !AddAliasItem( m_pCallReroutingInfo->divertingNrAlias,
					m_pCalleeAliasNames->pItems[0].pData,
					m_pCalleeAliasNames->pItems[0].wType ) )
			{
				delete m_pCallReroutingInfo->divertingNrAlias;
				m_pCallReroutingInfo->divertingNrAlias = NULL;
			}
		}
	}

	m_dwCallType |= CALLTYPE_DIVERTEDSRC;
	m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallDiversionFacility exited:%p.", 
        this ));
	return TRUE;
}


BOOL
CH323Call::HandleTransferFacility( 
	PH323_ALIASNAMES pAliasList )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));

	//argument.callIdentity
	ZeroMemory( (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

	//argument.reroutingNumber
	FreeAliasNames( m_pTransferedToAlias );
	m_pTransferedToAlias = pAliasList;

	m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
	m_dwCallDiversionState = H4502_CTINITIATE_RECV;

	//queue an event for creating a new call
	if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
		(ULONG_PTR)m_pTransferedToAlias ))
	{
		H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleTransferFacility( 
	PH323_ADDR pAlternateAddress )
{
	PSTR pszAlias;
	WCHAR pwszAliasName[H323_MAXDESTNAMELEN];
	in_addr addr;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));

	//argument.callIdentity
	ZeroMemory( (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

	//argument.reroutingNumber
	//free any previous divertedTo alias
	FreeAliasNames( m_pTransferedToAlias );

	addr.S_un.S_addr = htonl( pAlternateAddress->Addr.IP_Binary.dwAddr );
	pszAlias = inet_ntoa( addr );
	
    if( pszAlias == NULL )
    {
		return FALSE;
    }

	m_pTransferedToAlias = new H323_ALIASNAMES;
	if( m_pTransferedToAlias == NULL )
	{
		return FALSE;
	}
	ZeroMemory( m_pTransferedToAlias, sizeof(H323_ALIASNAMES) );

	MultiByteToWideChar(
			GetACP(),
			MB_PRECOMPOSED,
			pszAlias,
			strlen(pszAlias)+1,
			pwszAliasName,
			H323_MAXDESTNAMELEN
		   );

	if( !AddAliasItem( m_pTransferedToAlias, pwszAliasName, h323_ID_chosen ) )
	{
		delete m_pTransferedToAlias;
		m_pTransferedToAlias = NULL;
		return FALSE;
	}

	m_CalleeAddr = *pAlternateAddress;

	m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
	m_dwCallDiversionState = H4502_CTINITIATE_RECV;

	//queue an event for creating a new call
	if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
		(ULONG_PTR)m_pTransferedToAlias ))
	{
		H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
	}

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransferFacility entered:%p.", this ));
	return TRUE;
}


//!!always called in a lock
void 
CH323Call::HandleFacilityMessage( 
    IN DWORD dwInvokeID,
    IN Q931_FACILITY_ASN * pFacilityASN
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleFacilityMessage entered:%p.", this ));

    if( pFacilityASN->fNonStandardDataPresent )
    {
        // add user user info
        if( AddU2UNoAlloc( U2U_INBOUND,
            pFacilityASN->nonStandardData.sData.wOctetStringLength,
            pFacilityASN->nonStandardData.sData.pOctetString ) == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_VERBOSE,
                "user user info available in ALERT PDU." ));
                    // signal incoming

            if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
            {
                PostLineEvent (
                       LINE_CALLINFO,
                       LINECALLINFOSTATE_USERUSERINFO, 0, 0);
            }
            
            //don't release the data buffer
            pFacilityASN->fNonStandardDataPresent = FALSE;
        }
        else 
        {
            H323DBG(( DEBUG_LEVEL_WARNING,
                "could not save incoming user user info." ));

            //memory failure : shutdown the H323 call
            CloseCall( 0 );
            return;
        }
    }

    if( (pFacilityASN->bReason == callForwarded_chosen) ||
        (pFacilityASN->bReason == FacilityReason_routeCallToGatekeeper_chosen) ||
        (pFacilityASN->bReason == routeCallToMC_chosen) )
    {
        if( pFacilityASN->pAlternativeAliasList != NULL )
        {
            if( m_dwCallState == LINECALLSTATE_CONNECTED )
            {
                HandleTransferFacility( pFacilityASN->pAlternativeAliasList );
                
                //don't free the alias list
                pFacilityASN->pAlternativeAliasList = NULL;
            }
            else if( m_dwCallState != LINECALLSTATE_DISCONNECTED )
            {
                //redirect the call if not yet connected
                if( HandleCallDiversionFacility( 
                    pFacilityASN->pAlternativeAliasList ) )
                {
                    OnCallReroutingReceive( NO_INVOKEID );
                    
                    //don't free the alias list
                    pFacilityASN->pAlternativeAliasList = NULL;
                }
            }
        }
        else if( pFacilityASN->fAlternativeAddressPresent )
        {
            if( m_dwCallState == LINECALLSTATE_CONNECTED )
            {
                HandleTransferFacility( &pFacilityASN->AlternativeAddr );
            }
            else if( m_dwCallState != LINECALLSTATE_DISCONNECTED )
            {
                //redirect the call if not yet connected
                if( HandleCallDiversionFacility( &pFacilityASN->AlternativeAddr ) )
                {
                    OnCallReroutingReceive( NO_INVOKEID );
                }
            }
        }
    }

    //Handle H.450 APDU
    if( pFacilityASN->dwH450APDUType == DIVERTINGLEGINFO1_OPCODE )
    {
       if( m_dwOrigin != LINECALLORIGIN_OUTBOUND )
       {
           return;
       }

       if( m_pCallReroutingInfo && m_pCallReroutingInfo->fPresentAllow )
       {
           PostLineEvent (
               LINE_CALLINFO,
               LINECALLINFOSTATE_REDIRECTINGID, 0, 0);
       }
    }
    else if( pFacilityASN->dwH450APDUType == CALLREROUTING_OPCODE )
    {
        OnCallReroutingReceive( dwInvokeID );
    }
    else if( pFacilityASN->dwH450APDUType == REMOTEHOLD_OPCODE )
    {
        if( m_fRemoteHoldInitiated )
        {
            //Hold();
            m_fRemoteHoldInitiated = FALSE;
        }
    }
    else if( pFacilityASN->dwH450APDUType == REMOTERETRIEVE_OPCODE )
    {
        if( m_fRemoteRetrieveInitiated )
        {
            //UnHold();
            m_fRemoteRetrieveInitiated = FALSE;
        }
    }
    else if( pFacilityASN->fH245AddrPresent )
    {
        m_peerH245Addr = pFacilityASN->h245Addr;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "H245 address received in facility." ));
        
        //If Q931 call already connected then send another StartH245.
        if( m_dwCallState == LINECALLSTATE_CONNECTED )
        {
            SendMSPStartH245( NULL, NULL );
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleFacilityMessage exited:%p.", this ));
    return;
}


void 
CH323Call::SetNewCallInfo(
				HANDLE hConnWait, 
				HANDLE hWSAEvent, 
				DWORD dwState
			  )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SetNewCallInfo entered." ));
	
	Lock();
	
	m_hTransportWait = hConnWait;
	m_hTransport = hWSAEvent;
	SetQ931CallState( dwState );

	Unlock();
		
	H323DBG(( DEBUG_LEVEL_TRACE, "SetNewCallInfo exited." ));
}


//!!no need to call in a lock
void 
CH323Call::SetQ931CallState( DWORD dwState )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SetQ931CallState entered." ));
	
	//turn off the current state
	m_dwQ931Flags &= ~(Q931_CALL_CONNECTING | 
				   Q931_CALL_CONNECTED	|
				   Q931_CALL_DISCONNECTED );

	//set the new state
	m_dwQ931Flags |= dwState;
		
	H323DBG(( DEBUG_LEVEL_TRACE, "SetQ931CallState exited." ));
}


void
CH323Call::DialCall()
{
	H323DBG(( DEBUG_LEVEL_TRACE, "DialCall entered:%p.", this ));
	Lock();

	ChangeCallState( LINECALLSTATE_DIALING, 0);

	if( RasIsRegistered() )
	{
		if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
		{
			//If a forward consult call then enable theforwarding anyway.
			if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
				(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
			{
				//Success of forwarding
				EnableCallForwarding();
			}

			CloseCall( 0 );
		}
	}
	else
	{
		if( !PlaceCall() )
		{
			//If a forward consult call then enable theforwarding anyway.
			if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
				(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
			{
				//Success of forwarding
				EnableCallForwarding();
			}		  

			CloseCall( LINEDISCONNECTMODE_UNREACHABLE );
		}
	}
		
	Unlock();
	H323DBG(( DEBUG_LEVEL_TRACE, "DialCall exited:%p.", this ));
}


//!!always called in a lock
void
CH323Call::MakeCall()
{
	H323DBG(( DEBUG_LEVEL_TRACE, "MakeCall entered:%p.", this ));

	ChangeCallState( LINECALLSTATE_DIALING, 0 );
	
	// resolve dialable into local and remote address
	if( !RasIsRegistered() && 
		!ResolveAddress( GetDialableAddress() ) )
	{
		CloseCall( LINEDISCONNECTMODE_BADADDRESS );
	}
	else
	{
		if( RasIsRegistered() )
		{
			if( !SendARQ( NOT_RESEND_SEQ_NUM ) )
			{
				//If a forward consult call then enable theforwarding anyway.
				if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
					(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
				{
					//Success of forwarding
					EnableCallForwarding();
				}

				CloseCall( 0 );
			}
		}
		else
		{
			if( !PlaceCall() )
			{
				//If a forward consult call then enable theforwarding anyway.
				if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
					(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
				{
					//Success of forwarding
					EnableCallForwarding();
				}		  

				CloseCall( LINEDISCONNECTMODE_UNREACHABLE );
			}
		}
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "MakeCall exited:%p.", this ));
}


//!!always called in a lock
void 
CH323Call::HandleProceedingMessage( 
									IN Q931_ALERTING_ASN * pProceedingASN
								  )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedingMessage entered:%p.", this ));

	if( pProceedingASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
				pProceedingASN->nonStandardData.sData.wOctetStringLength,
				pProceedingASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in ALERT PDU." ));
					// signal incoming
			if( !(m_dwCallType & CALLTYPE_TRANSFEREDSRC) )
			{
				PostLineEvent (
				   LINE_CALLINFO,
				   LINECALLINFOSTATE_USERUSERINFO, 0, 0);
			}
			
			//don't release the data buffer
			pProceedingASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));

			//memory failure : shutdown the H323 call
			CloseCall( 0 );
			return;
		}
	}

	if( pProceedingASN->fH245AddrPresent )
	{
		m_peerH245Addr = pProceedingASN->h245Addr;
	}

	if( pProceedingASN->fFastStartPresent && 
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		if( m_pPeerFastStart )
		{
			//we had received fast start params in previous proceeding
			//or alerting message
			FreeFastStart( m_pPeerFastStart );
		}

		m_pPeerFastStart = pProceedingASN->pFastStart;
		m_dwFastStart = FAST_START_AVAIL;

		//we are keeping a reference to the fast start list so don't release it
		pProceedingASN->pFastStart = NULL;
		pProceedingASN->fFastStartPresent = FALSE;
	}

	/*
	if( pProceedingASN->fH245AddrPresent && !(m_dwFlags & H245_START_MSG_SENT) )
	{
		//start early H245
		SendMSPStartH245( NULL, NULL );
	}*/
	FreeProceedingASN( pProceedingASN );
		
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleProceedingMessage exited:%p.", this ));
	return;
}


//!!always called in a lock
BOOL 
CH323Call::HandleReleaseMessage( 
	IN Q931_RELEASE_COMPLETE_ASN *pReleaseASN
	)
{
	DWORD dwDisconnectMode = LINEDISCONNECTMODE_NORMAL;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleReleaseMessage entered:%p.", this ));

	if( (m_dwCallType & CALLTYPE_TRANSFERED_PRIMARY) &&
		(m_hdRelatedCall != NULL) )
	{
		return QueueSuppServiceWorkItem( DROP_PRIMARY_CALL,
				m_hdRelatedCall, (ULONG_PTR)m_hdCall );
	}
		
	//change the state to disconnected before callong drop call.
	//This will ensure that release message is not sent to the peer
	ChangeCallState( LINECALLSTATE_DISCONNECTED, 0 );
	
	//release non standard data
	if( pReleaseASN->fNonStandardDataPresent )
	{
		delete pReleaseASN->nonStandardData.sData.pOctetString;
		pReleaseASN->nonStandardData.sData.pOctetString = NULL;
	}

	//Should we drop the primary call if the transfered call in rejected?
	if( (m_dwCallType == CALLTYPE_TRANSFEREDSRC) && m_hdRelatedCall )
	{
		if( !QueueTAPILineRequest( 
			TSPI_CLOSE_CALL, 
			m_hdRelatedCall, 
			NULL,
			LINEDISCONNECTMODE_NORMAL,
			NULL ) )
		{
			H323DBG((DEBUG_LEVEL_ERROR, "could not post H323 close event"));
		}
	}

	//close call
	if( m_dwCallState != LINECALLSTATE_CONNECTED )
	{
		dwDisconnectMode = LINEDISCONNECTMODE_REJECT;
	}
	
	CloseCall( dwDisconnectMode );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleReleaseMessage exited:%p.", this ));
	return TRUE;
}


//never call in lock
BOOL
CH323Call::InitializeIncomingCall( 
	IN Q931_SETUP_ASN* pSetupASN,
	IN DWORD dwCallType,
	IN WORD wCallRef
	)
{
	PH323_CONFERENCE	pConf;
	WCHAR*				wszMachineName;

	H323DBG((DEBUG_LEVEL_TRACE, "InitializeIncomingCall entered:%p.",this));

	//bind outgoing call
	pConf = CreateConference( &(pSetupASN->ConferenceID) );
	if( pConf == NULL )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "could not create conference." ));
		
		goto cleanup;
	}
	
	if( !g_pH323Line -> GetH323ConfTable() -> Add( pConf ) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"could not add conf to conf table." ));

		// failure
		goto cleanup;
	}

	// save caller transport address
	if( !GetPeerAddress(&m_CallerAddr) )
    {
		goto cleanup;
    }

	if( !GetHostAddress(&m_CalleeAddr) )
    {
		goto cleanup;
    }

	//get endpoint info
	m_peerEndPointType = pSetupASN->EndpointType;

	//get the vendor info
	if( pSetupASN->EndpointType.pVendorInfo )
	{
		m_peerVendorInfo = pSetupASN->VendorInfo;
		
		//we have copied the vendor info pointers. So dont release 
		//the pointers in the ASN's vendor info struct
		pSetupASN->EndpointType.pVendorInfo = NULL;
	}

	if( pSetupASN -> fCallIdentifierPresent )
	{
		m_callIdentifier = pSetupASN->callIdentifier;
	}
	else
	{
		int iresult = UuidCreate( &m_callIdentifier );
		if( (iresult != RPC_S_OK) && (iresult !=RPC_S_UUID_LOCAL_ONLY) )
        {
			goto cleanup;
        }
	}

	_ASSERTE( !m_pPeerFastStart );
	if( pSetupASN->fFastStartPresent &&
		(m_dwFastStart!=FAST_START_NOTAVAIL) )
	{
		m_pPeerFastStart = pSetupASN->pFastStart;

		m_dwFastStart = FAST_START_PEER_AVAIL;
		
		//we are keeping a reference to the fast start list so don't release it 
		pSetupASN->pFastStart = NULL;
		pSetupASN->fFastStartPresent = FALSE;
	}
	else
	{
		m_dwFastStart = FAST_START_NOTAVAIL;
	}
	
	//get the alias names
	if( pSetupASN->pCalleeAliasList )
	{
		_ASSERTE( m_pCalleeAliasNames );
		delete m_pCalleeAliasNames;

		m_pCalleeAliasNames = pSetupASN->pCalleeAliasList;
		pSetupASN->pCalleeAliasList = NULL;
	}
	else
	{
		if( RasIsRegistered() )
		{
			PH323_ALIASNAMES pAliasList = RASGetRegisteredAliasList();

			AddAliasItem( m_pCalleeAliasNames,
				pAliasList->pItems[0].pData,
				pAliasList->pItems[0].wType );
		}
		else
		{
			wszMachineName = g_pH323Line->GetMachineName();
		
			//set the value for m_pCalleeAliasNames
			AddAliasItem( m_pCalleeAliasNames,
				(BYTE*)(wszMachineName),
				sizeof(WCHAR) * (wcslen(wszMachineName) + 1 ),
				h323_ID_chosen );
		}
	}

	_ASSERTE( m_pCallerAliasNames );
	delete m_pCallerAliasNames;
	m_pCallerAliasNames = NULL;

	if( pSetupASN->pCallerAliasList )
	{
		m_pCallerAliasNames = pSetupASN->pCallerAliasList;
		pSetupASN->pCallerAliasList = NULL;

		//H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
	}

	if( pSetupASN->pExtraAliasList )
	{
		m_pPeerExtraAliasNames = pSetupASN->pExtraAliasList;
		pSetupASN->pExtraAliasList = NULL;
	}
	
	//non -standard info
	if( pSetupASN->fNonStandardDataPresent )
	{
		// add user user info
		if( AddU2UNoAlloc( U2U_INBOUND, 	
				pSetupASN->nonStandardData.sData.wOctetStringLength,
				pSetupASN->nonStandardData.sData.pOctetString ) == TRUE )
		{
			H323DBG(( DEBUG_LEVEL_VERBOSE,
				"user user info available in Setup PDU." ));
			
			//don't release the data buffer
			pSetupASN->fNonStandardDataPresent = FALSE;
		}
		else 
		{
			H323DBG(( DEBUG_LEVEL_WARNING,
				"could not save incoming user user info." ));
			goto cleanup;
		}
	}

	if( pSetupASN->fSourceAddrPresent )
	{
		m_CallerAddr = pSetupASN->sourceAddr;
	}

	m_dwCallType = dwCallType;
	if( wCallRef )
	{
		m_wQ931CallRef = (wCallRef | 0x8000);
	}

	//clear incoming modes
	m_dwIncomingModes = 0;

	//outgoing modes will be finalized during H.245 phase
	m_dwOutgoingModes = g_pH323Line->GetMediaModes() | LINEMEDIAMODE_UNKNOWN;

	//save media modes specified
	m_dwRequestedModes = g_pH323Line->GetMediaModes();

	H323DBG(( DEBUG_LEVEL_TRACE, "InitializeIncomingCall exited:%p.", this ));
	return TRUE;

cleanup:
	return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::ChangeCallState(
							IN DWORD	dwCallState,
							IN DWORD	dwCallStateMode
						  )
		
/*++

Routine Description:

	Reports call state of specified call object.

Arguments:

	dwCallState - Specifies new state of call object.
	
	dwCallStateMode - Specifies new state mode of call object.

Return Values:

	Returns true if successful.
	
--*/

{	
	H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx %s. state mode: 0x%08lx.",
		this, H323CallStateToString(dwCallState), dwCallStateMode ));	 
	
	// save new call state
	m_dwCallState = dwCallState;
	m_dwCallStateMode = dwCallStateMode;
	
	if( 
		((m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall ) ||
		((m_dwCallType & CALLTYPE_TRANSFEREDSRC ) && m_hdRelatedCall ) ||
		(m_dwCallType & CALLTYPE_FORWARDCONSULT )
	  )
	{
		return TRUE;
	}

	// report call status
	PostLineEvent (
		LINE_CALLSTATE,
		m_dwCallState,
		m_dwCallStateMode,
		m_dwIncomingModes | m_dwOutgoingModes);

	// success
	return TRUE;
}


//always called in a lock
void
CH323Call::CopyU2UAsNonStandard( 
                                IN DWORD dwDirection
                               )
{
    PUserToUserLE pU2ULE = NULL;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyU2UAsNonStandard entered:%p.", this ));
    
    if( RemoveU2U( dwDirection, &pU2ULE ) )
    {
        // transfer header information
        m_NonStandardData.bCountryCode      = H221_COUNTRY_CODE_USA;
        m_NonStandardData.bExtension        = H221_COUNTRY_EXT_USA;
        m_NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

        // initialize octet string containing data
        m_NonStandardData.sData.wOctetStringLength = LOWORD(pU2ULE->dwU2USize);

        if( m_NonStandardData.sData.pOctetString )
        {
            delete m_NonStandardData.sData.pOctetString;
            m_NonStandardData.sData.pOctetString = NULL;
        }

        //We are assigning here part of the structure and then may be the structure is deleted or not??
        m_NonStandardData.sData.pOctetString = pU2ULE->pU2U;
        delete  pU2ULE;
    }
    else
    {
        //reset non standard data
        memset( (PVOID)&m_NonStandardData,0,sizeof(H323NonStandardData ));
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyU2UAsNonStandard exited:%p.", this ));
}


void
CH323Call::AcceptCall(void)
		
/*++

Routine Description:

	Accepts incoming call.
	!!always called in lock

Arguments:

Return Values:

	Returns true if successful.
	
--*/

{
	PH323_CALL		pCall = NULL;

	H323DBG(( DEBUG_LEVEL_TRACE, "AcceptCall entered:%p.", this ));
	
	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// see if user user information specified
	CopyU2UAsNonStandard( U2U_OUTBOUND );

	if( m_pwszDisplay == NULL )
	{
		// see if callee alias specified
		if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount )
		{
			 if((m_pCalleeAliasNames->pItems[0].wType == h323_ID_chosen) ||
				(m_pCalleeAliasNames ->pItems[0].wType == e164_chosen) )
			 {
				// send callee name as display
				m_pwszDisplay = m_pCalleeAliasNames -> pItems[0].pData;
			 }
		}
	}

	//send answer call message to the MSP instance

	if( (m_dwCallType & CALLTYPE_TRANSFEREDDEST) && m_hdRelatedCall )
	{
		MSPMessageData* pMSPMessageData = new MSPMessageData;
		if( pMSPMessageData == NULL )
		{
			CloseCall( 0 );
			return;
		}

		pMSPMessageData->hdCall = m_hdRelatedCall;
		pMSPMessageData->messageType = SP_MSG_AnswerCall;
		pMSPMessageData->pbEncodedBuf = NULL;
		pMSPMessageData->wLength = 0;
		pMSPMessageData->hReplacementCall = m_hdCall;

		if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, pMSPMessageData, 
			WT_EXECUTEDEFAULT ) )
		{
			delete pMSPMessageData;
			CloseCall( 0 );
			return;
		}
	}
	else
	{
		SendMSPMessage( SP_MSG_AnswerCall, 0, 0, NULL );
	}

	m_fCallAccepted = TRUE;

	if( m_fReadyToAnswer )
	{
		// validate status
		if( !AcceptH323Call() )
		{
			H323DBG(( DEBUG_LEVEL_ERROR, "error answering call 0x%08lx.", 
				this ));

			// drop call using disconnect mode
			DropCall( LINEDISCONNECTMODE_TEMPFAILURE );

			// failure
			return;
		}

		if( !(m_dwFlags & H245_START_MSG_SENT) )
		{
			//start H245
			SendMSPStartH245( NULL, NULL );
		}

		//tell MSP about connect state
		SendMSPMessage( SP_MSG_ConnectComplete, 0, 0, NULL );

		//change call state to accepted from offering
		ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "AcceptCall exited:%p.", this ));
	// success
	return;
}


//always called in lock
void
CH323Call::ReleaseU2U(void)
{
	PUserToUserLE pU2ULE = NULL;
	PLIST_ENTRY pLE;
	
	H323DBG(( DEBUG_LEVEL_TRACE, "ReleaseU2U entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// see if list is empty
	if( IsListEmpty( &m_IncomingU2U ) == FALSE )
	{
		// remove first entry from list
		pLE = RemoveHeadList( &m_IncomingU2U );

		// convert to user user structure
		pU2ULE = CONTAINING_RECORD(pLE, UserToUserLE, Link);

		// release memory
		if(pU2ULE)
		{
			delete pU2ULE;
			pU2ULE = NULL;
		}
	}

	// see if list contains pending data
	if( IsListEmpty( &m_IncomingU2U ) == FALSE )
	{
		H323DBG(( DEBUG_LEVEL_VERBOSE,
			"more user user info available." ));

		// signal incoming
		PostLineEvent (
			LINE_CALLINFO,
			LINECALLINFOSTATE_USERUSERINFO, 0, 0);
	}
		
	H323DBG(( DEBUG_LEVEL_TRACE, "ReleaseU2U exited:%p.", this ));
}


//always called in lock
void
CH323Call::SendU2U(
	IN BYTE*  pUserUserInfo,
	IN DWORD  dwSize
	)
{
	H323DBG(( DEBUG_LEVEL_TRACE, "SendU2U entered:%p.", this ));

	if( m_dwFlags & CALLOBJECT_SHUTDOWN )
	{
		return;
	}

	// check for user user info
	if( pUserUserInfo != NULL )
	{
		// transfer header information
		m_NonStandardData.bCountryCode		= H221_COUNTRY_CODE_USA;
		m_NonStandardData.bExtension		= H221_COUNTRY_EXT_USA;
		m_NonStandardData.wManufacturerCode = H221_MFG_CODE_MICROSOFT;

		// initialize octet string containing data
		m_NonStandardData.sData.wOctetStringLength = (WORD)dwSize;

		if( m_NonStandardData.sData.pOctetString != NULL )
		{
			delete m_NonStandardData.sData.pOctetString;
			m_NonStandardData.sData.pOctetString = NULL;
		}

		m_NonStandardData.sData.pOctetString = pUserUserInfo;
	}

	// send user user data
	if( !SendQ931Message( 0, 0, 0, FACILITYMESSAGETYPE, NO_H450_APDU ) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error sending non-standard message."));
	}
	
	H323DBG(( DEBUG_LEVEL_TRACE, "SendU2U exited:%p.", this ));
	return;
}


BOOL
CH323Call::InitializeQ931(
							IN SOCKET callSocket
						 )
{
	BOOL	fSuccess;

	H323DBG((DEBUG_LEVEL_ERROR, "q931 call initialize entered:%p.", this ));

	if( !BindIoCompletionCallback(
		(HANDLE)callSocket,
		CH323Call::IoCompletionCallback, 
		0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, 
			"couldn't bind i/o completion callabck:%d:%p.", 
			GetLastError(), this ));

		return FALSE;
	}

	//initilize the member variables
	m_callSocket = callSocket;
		
	H323DBG((DEBUG_LEVEL_ERROR, "q931 call initialize exited:%lx, %p.", 
		m_callSocket, this ));
	return TRUE;
}

//no need to lock
BOOL
CH323Call::GetPeerAddress(
	IN H323_ADDR *pAddr
	)
{
	SOCKADDR_IN sockaddr;
	int len = sizeof(sockaddr);

	H323DBG((DEBUG_LEVEL_ERROR, "GetPeerAddress entered:%p.", this ));
	
	if( getpeername( m_callSocket, (SOCKADDR*)&sockaddr, &len) 
		== SOCKET_ERROR )
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling getpeername.", WSAGetLastError() ));

		return FALSE;
	}

	pAddr->nAddrType = H323_IP_BINARY;
	pAddr->bMulticast = FALSE;
	pAddr->Addr.IP_Binary.wPort = ntohs(sockaddr.sin_port);
	pAddr->Addr.IP_Binary.dwAddr = ntohl(sockaddr.sin_addr.S_un.S_addr);

	H323DBG(( DEBUG_LEVEL_ERROR, "GetPeerAddress exited:%p.", this ));
	return TRUE;
}


//no need to lock
BOOL CH323Call::GetHostAddress( 
	IN H323_ADDR *pAddr
	)
{
	int len = sizeof(m_LocalAddr);
	
	H323DBG((DEBUG_LEVEL_ERROR, "GetHostAddress entered:%p.", this ));
	
	if( getsockname( m_callSocket, (SOCKADDR *)&m_LocalAddr, &len) == 
			SOCKET_ERROR)
	{
		H323DBG(( DEBUG_LEVEL_ERROR,
			"error 0x%08lx calling getockname.", WSAGetLastError() ));
		
		return FALSE;
	}

	pAddr->nAddrType = H323_IP_BINARY;
	pAddr->bMulticast = FALSE;
	pAddr->Addr.IP_Binary.wPort = ntohs(m_LocalAddr.sin_port);
	pAddr->Addr.IP_Binary.dwAddr = ntohl(m_LocalAddr.sin_addr.S_un.S_addr);

	H323DBG((DEBUG_LEVEL_ERROR, "GetHostAddress exited:%p.", this ));
	return TRUE;
}

//!!always called in a lock
BOOL 
CH323Call::OnReceiveFacility(
							IN Q931MESSAGE* pMessage
							)
{
	Q931_FACILITY_ASN	facilityASN;
	
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveFacility entered: %p.", this ));

	//decode the U2U information
	if( !pMessage ->UserToUser.fPresent ||
		pMessage ->UserToUser.wUserInfoLen == 0 )
	{
		//Ignore this message. Don't shutdown the call.
		return FALSE;
	}

	if( !ParseFacilityASN( pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen, &facilityASN ))
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	if( (facilityASN.pH245PDU.length != 0) && facilityASN.pH245PDU.value )
	{
		SendMSPMessage( SP_MSG_H245PDU, facilityASN.pH245PDU.value, 
			facilityASN.pH245PDU.length, NULL );
		delete facilityASN.pH245PDU.value;
	}

	HandleFacilityMessage( facilityASN.dwInvokeID, &facilityASN );

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveFacility exited: %p.", this ));
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveProceeding(
								IN Q931MESSAGE* pMessage
							  )
{
	Q931_CALL_PROCEEDING_ASN proceedingASN;
	DWORD dwAPDUType = 0;
			
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveProceeding entered: %p.", this ));
	
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( (m_dwOrigin!=LINECALLORIGIN_OUTBOUND) ||
		( (m_dwStateMachine != Q931_SETUP_SENT) &&
		  (m_dwStateMachine != Q931_PROCEED_RECVD) )
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( !ParseProceedingASN(
			pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen,
			&proceedingASN,
			&dwAPDUType ))
	{
		//Ignore the wrong proceeding message.
		H323DBG(( DEBUG_LEVEL_ERROR, "wrong proceeding PDU:%p.", this ));
		H323DUMPBUFFER( pMessage->UserToUser.pbUserInfo, 
			(DWORD)pMessage->UserToUser.wUserInfoLen );

		return TRUE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//success of forwarding
		EnableCallForwarding();

		CloseCall( 0 );
		return TRUE;
	}

	HandleProceedingMessage( &proceedingASN );

	//reset the timeout for setup sent
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveProceeding exited: %p.", this ));
	m_dwStateMachine = Q931_PROCEED_RECVD;
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveAlerting(
							IN Q931MESSAGE* pMessage
							)
{
	Q931_ALERTING_ASN alertingASN;
	DWORD dwAPDUType = 0;

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveAlerting entered: %p.", this ));
	
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if(  (m_dwOrigin!=LINECALLORIGIN_OUTBOUND) ||
		!( (m_dwStateMachine==Q931_SETUP_SENT) || 
		   (m_dwStateMachine==Q931_PROCEED_RECVD)
		 ) 
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( !ParseAlertingASN( pMessage->UserToUser.pbUserInfo,
							  pMessage->UserToUser.wUserInfoLen,
							  &alertingASN,
							  &dwAPDUType ))
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
		(m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
	{
		//success of forwarding
		EnableCallForwarding();

		CloseCall( 0 );
		return FALSE;
	}

	//reset the timeout for setup sent
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( !CreateTimerQueueTimer(
			&m_hCallEstablishmentTimer,
			H323TimerQueue,
			CH323Call::CallEstablishmentExpiredCallback,
			(PVOID)m_hdCall,
			g_RegistrySettings.dwQ931AlertingTimeout, 0,
			WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE ))
	{
		CloseCall( 0 );
		return FALSE;
	}
			
	HandleAlertingMessage( &alertingASN );
	m_dwStateMachine = Q931_ALERT_RECVD;
		
	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveAlerting exited: %p.", this ));
	return TRUE;
}


//!!always called in lock
void
CH323Call::SetupSentTimerExpired(void)
{
	DWORD dwState;

	H323DBG((DEBUG_LEVEL_TRACE, "SetupSentTimerExpired entered."));
	
	dwState = m_dwStateMachine;
	
	if( m_hSetupSentTimer != NULL )
	{
		DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
		m_hSetupSentTimer = NULL;
	}

	if( (dwState!= Q931_CONNECT_RECVD) &&
		(dwState != Q931_ALERT_RECVD) &&
		(dwState != Q931_PROCEED_RECVD) &&
		(dwState != Q931_RELEASE_RECVD)
	  )
	{
		//time out has occured
		CloseCall( 0 );
	}
		
	H323DBG((DEBUG_LEVEL_TRACE, "SetupSentTimerExpired exited." ));
}


//!!always called in a lock
BOOL
CH323Call::OnReceiveRelease(
	IN Q931MESSAGE* pMessage
	)
{
	DWORD dwAPDUType = 0;
	Q931_RELEASE_COMPLETE_ASN releaseASN;
		
	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		H323DBG(( DEBUG_LEVEL_ERROR, "ReleaseComplete PDU did not contain "
				  "user-to-user information, ignoring message." ));

		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( !ParseReleaseCompleteASN( 
			pMessage->UserToUser.pbUserInfo,
			pMessage->UserToUser.wUserInfoLen,
			&releaseASN,
			&dwAPDUType ))
	{
		H323DBG(( DEBUG_LEVEL_ERROR, 
            "ReleaseComplete PDU could not be parsed, terminating call." ));

		//memory failure : shutdown the H323 call
		CloseCall( 0 );

		return FALSE;
	}

	H323DBG ((DEBUG_LEVEL_INFO, "Received ReleaseComplete PDU."));

	HandleReleaseMessage( &releaseASN );
	m_dwStateMachine = Q931_RELEASE_RECVD;
	
	return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::OnReceiveConnect( 
	IN Q931MESSAGE* pMessage
	)
{
	Q931_CONNECT_ASN connectASN;
	DWORD dwH450APDUType = 0;

	H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveConnect entered: %p.", this ));

	//decode the U2U information
	if( (pMessage ->UserToUser.fPresent == FALSE) || 
		(pMessage ->UserToUser.wUserInfoLen == 0) )
	{
		//ignore this message. don't shutdown the call.
		return FALSE;
	}

	if( m_dwOrigin!=LINECALLORIGIN_OUTBOUND )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( (m_dwStateMachine != Q931_SETUP_SENT) &&
		(m_dwStateMachine != Q931_ALERT_RECVD) &&
		(m_dwStateMachine != Q931_PROCEED_RECVD)
	  )
	{
		//ignore this message. don't shutdown the Q931 call.
		return FALSE;
	}

	if( ParseConnectASN( pMessage->UserToUser.pbUserInfo,
				   pMessage->UserToUser.wUserInfoLen,
				   &connectASN,
				   &dwH450APDUType) == FALSE )
	{
		//memory failure : shutdown the H323 call
		CloseCall( 0 );
		return FALSE;
	}

	if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
	{
		FreeConnectASN( &connectASN );

		if( dwH450APDUType == H4503_DUMMYTYPERETURNRESULT_APDU)
		{
			//assuming this return result is for check restriction operation
			return TRUE;
		}
		else
		{
			//success of forwarding
			EnableCallForwarding();

			CloseCall( 0 );
			return FALSE;
		}
	}

    if( !HandleConnectMessage( &connectASN ) )
    {
        return FALSE;
    }
    
    //reset the timeout for setup sent
    if( m_hSetupSentTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hSetupSentTimer, NULL );
        m_hSetupSentTimer = NULL;
    }

    if( m_hCallEstablishmentTimer )
    {
        DeleteTimerQueueTimer(H323TimerQueue, m_hCallEstablishmentTimer, NULL);
        m_hCallEstablishmentTimer = NULL;
    }

    m_dwStateMachine = Q931_CONNECT_RECVD;
        
    H323DBG((DEBUG_LEVEL_TRACE, "OnReceiveConnect exited: %p.", this ));
    return TRUE;
}

//!!always called in a lock
BOOL 
CH323Call::OnReceiveSetup( 
                           IN Q931MESSAGE* pMessage
                         )
{
    Q931_SETUP_ASN      setupASN;
    DWORD               dwH450APDUType = 0;
    PH323_CALL          pCall = NULL;
    WCHAR               pwszCallingPartyNr[H323_MAXPATHNAMELEN];
    WCHAR               pwszCalledPartyNr[H323_MAXPATHNAMELEN];
    BYTE*               pstrTemp;

    //decode the U2U information
    if( (pMessage ->UserToUser.fPresent == FALSE) || 
        (pMessage ->UserToUser.wUserInfoLen == 0) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Setup message did not contain H.323 UUIE, ignoring."));

        //ignore this message. don't shutdown the call.
        return FALSE;
    }

    if( m_dwOrigin != LINECALLORIGIN_INBOUND )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Received Setup message on outbound call, ignoring."));

        //ignore this message. don't shutdown the call.
        return FALSE;
    }

    if( m_dwStateMachine != Q931_CALL_STATE_NONE )
    {
        H323DBG( (DEBUG_LEVEL_ERROR, 
            "Received Setup message on a call that is already in progress." ));

        //This Q931 call has already received a setup!!!!
        CloseCall( 0 );
        
        return FALSE;
    }

    if( !ParseSetupASN( pMessage->UserToUser.pbUserInfo,
                        pMessage->UserToUser.wUserInfoLen, 
                        &setupASN,
                        &dwH450APDUType ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Failed to parse Setup UUIE, closing call." ));

        //shutdown the Q931 call
        CloseCall( 0 );
        return FALSE;
    }

    if( dwH450APDUType )
    {
        if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
        {
            return TRUE;
        }
    }

    if( (pMessage->CallingPartyNumber.fPresent == TRUE) && 
        (pMessage->CallingPartyNumber.dwLength > 1) &&
        (setupASN.pCallerAliasList == NULL ) )
    {
        // Always skip 1st byte in the contents.
        // Skip the 2nd byte if its not an e.164 char (could be the screening indicator byte)

        pstrTemp = pMessage->CallingPartyNumber.pbContents + 
                ((pMessage->CallingPartyNumber.pbContents[1] & 0x80)? 2 : 1);

        MultiByteToWideChar( CP_ACP, 
            0,
            (const char *)(pstrTemp),
            -1,
            pwszCallingPartyNr,
            sizeof(pwszCallingPartyNr)/sizeof(WCHAR));
         
        setupASN.pCallerAliasList = new H323_ALIASNAMES;
        
        if( setupASN.pCallerAliasList != NULL )
        {
            ZeroMemory( setupASN.pCallerAliasList, sizeof(H323_ALIASNAMES) );
            
            AddAliasItem( setupASN.pCallerAliasList,
                pwszCallingPartyNr,
                e164_chosen );
        }
    }

    if( (pMessage->CalledPartyNumber.fPresent == TRUE) && 
        (pMessage->CalledPartyNumber.PartyNumberLength > 0) &&
        (setupASN.pCalleeAliasList == NULL ) )
    {
        // Always skip 1st byte in the contents.
        // Skip the 2nd byte if its not an e.164 char (could be the screening indicator byte)

        MultiByteToWideChar(CP_ACP, 
            0, 
            (const char *)(pMessage->CalledPartyNumber.PartyNumbers), 
            -1,
            pwszCalledPartyNr,
            sizeof(pwszCalledPartyNr) / sizeof(WCHAR) );
                 
        setupASN.pCalleeAliasList = new H323_ALIASNAMES;
        
        if( setupASN.pCalleeAliasList != NULL )
        {
            ZeroMemory( setupASN.pCalleeAliasList, sizeof(H323_ALIASNAMES) );
            
            AddAliasItem( setupASN.pCalleeAliasList,
                pwszCalledPartyNr,
                e164_chosen );
        }
    }
        
    //don't change the call type here
    if( !InitializeIncomingCall( &setupASN, m_dwCallType, pMessage->wCallRef ) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Failed to initialize incoming call, closing call."));

        //shutdown the Q931 call
        FreeSetupASN( &setupASN );        
        CloseCall( 0 );
        return FALSE;
    }
    
    FreeSetupASN( &setupASN );
    m_dwStateMachine = Q931_SETUP_RECVD;

    if( !HandleSetupMessage( pMessage ) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Failed to process Setup message, closing call."));

        CloseCall( 0 );
        return FALSE;
    }

    return TRUE;
}


//!!always called in a lock
void
CH323Call::CloseCall( 
    IN DWORD dwDisconnectMode )
{
    H323DBG((DEBUG_LEVEL_INFO, "[%08XH] Terminating call.", this ));

    if (!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            m_hdCall, 
            NULL,
            dwDisconnectMode,
            m_wCallReference ))
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }
}


//!!always called in a lock
void
CH323Call::ReadEvent(
    IN DWORD cbTransfer
    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "ReadEvent entered: %p.", this ));
    H323DBG((DEBUG_LEVEL_TRACE, "bytes received: %d.", cbTransfer));

    m_RecvBuf.dwBytesCopied += cbTransfer;

    //update the recv buffer
    if( m_bStartOfPDU )
    {
        if( m_RecvBuf.dwBytesCopied < sizeof(TPKT_HEADER_SIZE) )
        {
            //set the buffer to get the remainig TPKT_HEADER
            m_RecvBuf.WSABuf.buf = 
                m_RecvBuf.arBuf + m_RecvBuf.dwBytesCopied;

            m_RecvBuf.WSABuf.len =
                TPKT_HEADER_SIZE - m_RecvBuf.dwBytesCopied;
        }
        else
        {
            m_RecvBuf.dwPDULen = GetTpktLength( m_RecvBuf.arBuf );

            if( (m_RecvBuf.dwPDULen < TPKT_HEADER_SIZE) ||
                (m_RecvBuf.dwPDULen  > Q931_RECV_BUFFER_LENGTH) )
            {
                //messed up peer. close the call.
                H323DBG(( DEBUG_LEVEL_ERROR, "error:PDULen:%d.", 
                    m_RecvBuf.dwPDULen ));

                //close the call
                CloseCall( 0 );
                return;
            }
            else if( m_RecvBuf.dwPDULen == TPKT_HEADER_SIZE )
            {
                InitializeRecvBuf();
            }
            else
            {
                //set the buffer to get the remaining PDU
                m_bStartOfPDU = FALSE;
                m_RecvBuf.WSABuf.buf = m_RecvBuf.arBuf + 
                    m_RecvBuf.dwBytesCopied;
                m_RecvBuf.WSABuf.len = m_RecvBuf.dwPDULen - 
                    m_RecvBuf.dwBytesCopied;
            }
        }
    }
    else
    {
        _ASSERTE( m_RecvBuf.dwBytesCopied <= m_RecvBuf.dwPDULen );

        if( m_RecvBuf.dwBytesCopied == m_RecvBuf.dwPDULen )
        {
            //we got the whole PDU
            if( !ProcessQ931PDU( &m_RecvBuf ) )
            {
                H323DBG(( DEBUG_LEVEL_ERROR, 
                    "error in processing PDU:%p.", this ));

                H323DUMPBUFFER( (BYTE*)m_RecvBuf.arBuf, m_RecvBuf.dwPDULen );
            }

            //if the call has been already shutdown due to
            //a fatal error while processing the PDU or because of receiveing
            //release complete message then dont post any more read buffers
            if( (m_dwFlags & CALLOBJECT_SHUTDOWN) || 
                (m_dwQ931Flags & Q931_CALL_DISCONNECTED) )
            {
                return;
            }

            InitializeRecvBuf();
        }
        else
        {
            //set the buffer to get the remainig PDU
            m_RecvBuf.WSABuf. buf = 
                m_RecvBuf.arBuf + m_RecvBuf.dwBytesCopied;
            m_RecvBuf.WSABuf. len = 
                m_RecvBuf.dwPDULen - m_RecvBuf.dwBytesCopied;
        }
    }

    //post a read for the remaining PDU
    if(!PostReadBuffer())
    {
        //post a message to the callback thread to shutdown the H323 call
        CloseCall( 0 );
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "ReadEvent exited: %p.", this ));
}


/*
	Parse a generic Q931 message and place the fields of the buffer
	into the appropriate structure fields.

	Parameters:
		pBuf  Pointer to buffer descriptor of an
                       input packet containing the 931 message.
		pMessage           Pointer to space for parsed output information.
*/

//!!always called in a lock
HRESULT
CH323Call::Q931ParseMessage(
    IN BYTE *          pbCodedBuffer,
    IN DWORD           dwCodedBufferLength,
    OUT PQ931MESSAGE    pMessage
    )
{
    HRESULT hr;
    BUFFERDESCR pBuf;

    pBuf.dwLength = dwCodedBufferLength;
    pBuf.pbBuffer = pbCodedBuffer;
    
    H323DBG((DEBUG_LEVEL_TRACE, "Q931ParseMessage entered: %p.", this ));
    
    memset( (PVOID)pMessage, 0, sizeof(Q931MESSAGE));

    hr = ParseProtocolDiscriminator(&pBuf, &pMessage->ProtocolDiscriminator);

    if( hr != S_OK )
    {
        return hr;
    }

    hr = ParseCallReference( &pBuf, &pMessage->wCallRef);
    if( hr != S_OK )
    {
        return hr;
    }

    hr = ParseMessageType( &pBuf, &pMessage->MessageType );
    if( hr != S_OK )
    {
        return hr;
    }

    while (pBuf.dwLength)
    {
        hr = ParseQ931Field(&pBuf, pMessage);
        if (hr != S_OK)
        {
            return hr;
        }
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "Q931ParseMessage exited: %p.", this ));
    return S_OK;
}


//decode the PDU and release the buffer
//!!always called in a lock
BOOL 
CH323Call::ProcessQ931PDU( 
    IN CALL_RECV_CONTEXT* pRecvBuf
    )
{
    PQ931MESSAGE    pMessage;
    BOOL            retVal;
    HRESULT         hr;
        
    H323DBG((DEBUG_LEVEL_TRACE, "ProcessQ931PDU entered: %p.", this ));
    
    pMessage = new Q931MESSAGE;
    if( pMessage  == NULL )
    {
        return FALSE;
    }

    hr = Q931ParseMessage( (BYTE*)(pRecvBuf->arBuf + sizeof(TPKT_HEADER_SIZE)),
                           pRecvBuf->dwPDULen - 4, 
                           pMessage );

    if( !SUCCEEDED( hr) )
    {
        delete pMessage;
        return FALSE;
    }

    if( (m_dwCallType & CALLTYPE_TRANSFERED_PRIMARY )      &&
        (m_dwCallDiversionState == H4502_CTINITIATE_RECV)   &&
        (pMessage->MessageType != RELEASECOMPLMESSAGETYPE) )
    {
        // If this endpoint has already been transferred then
        // ignore any further messages on the primary call.
        delete pMessage;
        return FALSE;
    }

    switch( pMessage->MessageType )
    {
    case ALERTINGMESSAGETYPE:
        
        retVal = OnReceiveAlerting( pMessage );
        break;

    case PROCEEDINGMESSAGETYPE:
        
        retVal = OnReceiveProceeding( pMessage );
        break;

    case CONNECTMESSAGETYPE:

        retVal = OnReceiveConnect( pMessage );
        break;

    case RELEASECOMPLMESSAGETYPE:
        
        retVal = OnReceiveRelease( pMessage );
        break;

    case SETUPMESSAGETYPE:

        retVal = OnReceiveSetup( pMessage );
        break;

    case FACILITYMESSAGETYPE:

        retVal = OnReceiveFacility( pMessage );
        break;

    default:

        H323DBG(( DEBUG_LEVEL_TRACE, "unrecognised PDU recvd:%d,%p.",
            pMessage->MessageType, this ));
        retVal = FALSE;
    }

    delete pMessage;

    H323DBG((DEBUG_LEVEL_TRACE, "ProcessQ931PDU exited: %p.", this ));
    return retVal;
}



//!!always called in a lock
void 
CH323Call::OnConnectComplete(void)
{
    BOOL        fSuccess = TRUE;
    PH323_CALL  pCall = NULL;
    
    H323DBG((DEBUG_LEVEL_TRACE, "OnConnectComplete entered: %p.", this ));
    
    _ASSERTE( m_dwOrigin==LINECALLORIGIN_OUTBOUND );

    if( !GetHostAddress( &m_CallerAddr) )
    {
        //memory failure : shutdown the H323 call
        CloseCall( 0 );
        return;
    }

    InitializeRecvBuf();

    //post a buffer to winsock to accept messages from the peer
    if( !PostReadBuffer() )
    {
        //memory failure : shutdown the H323 call
        CloseCall( 0 );
        return;
    }

    //set the state to connected
    SetQ931CallState( Q931_CALL_CONNECTED );

    if( (m_dwCallType == CALLTYPE_NORMAL) || 
        (m_dwCallType & CALLTYPE_TRANSFERING_CONSULT) )
    {
        SendMSPMessage( SP_MSG_InitiateCall, 0, 0, NULL );
    }
    else if( m_dwCallType & CALLTYPE_TRANSFEREDSRC )
    {
        _ASSERTE( m_hdRelatedCall );
        MSPMessageData* pMSPMessageData = new MSPMessageData;
        if( pMSPMessageData == NULL )
        {
            CloseCall( 0 );
            return;
        }

        pMSPMessageData->hdCall = m_hdRelatedCall;
        pMSPMessageData->messageType = SP_MSG_InitiateCall;
        pMSPMessageData->pbEncodedBuf = NULL;
        pMSPMessageData->wLength = 0;
        pMSPMessageData->hReplacementCall = m_hdCall;

        if( !QueueUserWorkItem( SendMSPMessageOnRelatedCall, pMSPMessageData,
            WT_EXECUTEDEFAULT ) )
        {
            delete pMSPMessageData;
            CloseCall( 0 );
            return;
        }
    }
    else
    {
        //send the setup message
        if( !SendSetupMessage() )
        {
            DropCall( 0 );
        }
    }
    
    H323DBG((DEBUG_LEVEL_TRACE, "OnConnectComplete exited: %p.", this ));
}


//!!aleways called in a lock
BOOL
CH323Call::SendSetupMessage(void)
{
    BOOL retVal = TRUE;
    DWORD dwAPDUType = NO_H450_APDU;

    H323DBG((DEBUG_LEVEL_TRACE, "SendSetupMessage entered: %p.", this ));

    //encode ASN.1 and send Q931Setup message to the peer
    if( m_dwCallType & CALLTYPE_FORWARDCONSULT )
    {
        //send the callRerouitng.invoke APDU  if this is a forwardconsult call
        retVal = SendQ931Message( NO_INVOKEID,
                         (DWORD)create_chosen, 
                         (DWORD)pointToPoint_chosen,
                         SETUPMESSAGETYPE,
                         CHECKRESTRICTION_OPCODE| H450_INVOKE );

        if( retVal )
        {
            m_dwStateMachine = Q931_SETUP_SENT;
            m_dwCallDiversionState = H4503_CHECKRESTRICTION_SENT;

            retVal = CreateTimerQueueTimer(
                        &m_hCheckRestrictionTimer,
                        H323TimerQueue,
                        CH323Call::CheckRestrictionTimerCallback,
                        (PVOID)m_hdCall,
                        CHECKRESTRICTION_EXPIRE_TIME, 0,
                        WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
        }
    }
    else
    {
        if( ( m_dwCallType & CALLTYPE_DIVERTEDSRC ) ||
            ( m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING ) )
        {
            dwAPDUType = DIVERTINGLEGINFO2_OPCODE | H450_INVOKE;
        }
        else if( m_dwCallType & CALLTYPE_TRANSFEREDSRC )
        {
            dwAPDUType = CTSETUP_OPCODE | H450_INVOKE;
        }
        
        retVal = SendQ931Message( NO_INVOKEID,
                         (DWORD)create_chosen,
                         (DWORD)pointToPoint_chosen,
                         SETUPMESSAGETYPE,
                         dwAPDUType );
        
        if( retVal )
        {
            m_dwStateMachine = Q931_SETUP_SENT;
            
            retVal = CreateTimerQueueTimer(
                &m_hSetupSentTimer,
                H323TimerQueue,
                CH323Call::SetupSentTimerCallback,
                (PVOID)m_hdCall,
                SETUP_SENT_TIMEOUT, 0,
                WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
        }
    }
    
    if( retVal == FALSE )
    {
        CloseCall( 0 );
        return FALSE;
    }

    H323DBG((DEBUG_LEVEL_TRACE, "SendSetupMessage exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL
CH323Call::SendProceeding(void)
{
    H323DBG((DEBUG_LEVEL_TRACE, "SendProceeding entered: %p.", this ));
    
    _ASSERTE( m_dwOrigin == LINECALLORIGIN_INBOUND );

    //encode ASN.1 and send Q931Setup message to the peer
    if(!SendQ931Message( NO_INVOKEID, 0, 0, PROCEEDINGMESSAGETYPE, NO_H450_APDU ))
    {
        return FALSE;
    }

    m_dwStateMachine = Q931_PROCEED_SENT;
        
    H323DBG((DEBUG_LEVEL_TRACE, "SendProceeding exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::PostReadBuffer(void)
{
    int     iError;
    DWORD   dwByteReceived = 0;
    BOOL    fDelete = FALSE;

    H323DBG((DEBUG_LEVEL_TRACE, "PostReadBuffer entered: %p.", this ));
    
    m_RecvBuf.Type = OVERLAPPED_TYPE_RECV;
    m_RecvBuf.pCall = this;
    m_RecvBuf.dwFlags = 0;
    m_RecvBuf.BytesTransferred = 0;
    ZeroMemory( (PVOID)&m_RecvBuf.Overlapped, sizeof(OVERLAPPED) );

    //register with winsock for overlappped I/O
    if( WSARecv( m_callSocket,
             &(m_RecvBuf.WSABuf),
             1,
             &(m_RecvBuf.BytesTransferred),
             &(m_RecvBuf.dwFlags),
             &(m_RecvBuf.Overlapped),
             NULL ) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();

        if( iError != WSA_IO_PENDING )
        {
            //take care of error conditions here
            H323DBG((DEBUG_LEVEL_ERROR, "error while recving buf: %d.",
                iError ));
            return FALSE;
        }
    }
    else
    {
        //There is some data to read!!!!!
        H323DBG(( DEBUG_LEVEL_TRACE, "bytes received immediately: %d.",
            m_RecvBuf.BytesTransferred ));
    }

    m_IoRefCount++;
    H323DBG((DEBUG_LEVEL_TRACE, 
        "PostReadBuffer:m_IoRefCount: %d:%p.", m_IoRefCount, this ));
    
    H323DBG((DEBUG_LEVEL_TRACE, "PostReadBuffer exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::SendBuffer( 
                     IN BYTE* pbBuffer,
                     IN DWORD dwLength
                     )
{
    int                 iError;
    CALL_SEND_CONTEXT*  pSendBuf = NULL;
    DWORD               cbTransfer;
    BOOL                fDelete = FALSE;

    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer entered: %p.", this ));
    
    if( !(m_dwQ931Flags & Q931_CALL_CONNECTED) )
    {
        goto cleanup;    
    }
    
    pSendBuf = new CALL_SEND_CONTEXT;
    if( pSendBuf == NULL )
    {
        goto cleanup;
    }
    
    ZeroMemory( (PVOID)pSendBuf, sizeof(CALL_SEND_CONTEXT) );
    pSendBuf->WSABuf.buf = (char*)pbBuffer;
    pSendBuf->WSABuf.len = dwLength;
    pSendBuf->BytesTransferred = 0;
    pSendBuf->pCall = this;
    pSendBuf->Type = OVERLAPPED_TYPE_SEND;
    
    InsertTailList( &m_sendBufList, &(pSendBuf ->ListEntry) );

    if( WSASend(m_callSocket,
                &(pSendBuf->WSABuf),
                1,
                &(pSendBuf->BytesTransferred),
                0,
                &(pSendBuf->Overlapped),
                NULL) == SOCKET_ERROR )
    {
        iError = WSAGetLastError();
        
        if( iError != WSA_IO_PENDING )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "error sending the buf: %lx.", iError));

            RemoveEntryList( &pSendBuf->ListEntry );
            goto cleanup;
        }
    }
    else
    {
        //data was sent immediately!!!
        H323DBG((DEBUG_LEVEL_TRACE, "data sent immediately!!." ));
    }

    m_IoRefCount++;
    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer:m_IoRefCount11: %d:%p.", 
        m_IoRefCount, this ));

    H323DBG((DEBUG_LEVEL_TRACE, "SendBuffer exited: %p.", this ));
    return TRUE;

cleanup:
    if(pSendBuf)
    {
        delete pSendBuf;
    }

    delete pbBuffer;
    return FALSE;
}


//!!aleways called in a lock
BOOL
CH323Call::SetupCall(void)
{
    SOCKET              Q931CallSocket = INVALID_SOCKET;
    SOCKADDR_IN         sin;
    HANDLE              hWSAEvent;
    HANDLE              hConnWait;
    BOOL                fSuccess = TRUE;
    int                 iError;
    BOOL                fDelete;
    DWORD               dwEnable = 1;
    TCHAR               ptstrEventName[100];

    H323DBG((DEBUG_LEVEL_TRACE, "SetupCall entered."));

    //create a socket
    Q931CallSocket = WSASocket(
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_IP, 
                    NULL,
                    NULL,
                    WSA_FLAG_OVERLAPPED );
    
    if( Q931CallSocket == INVALID_SOCKET )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "error while creating socket: %lx.",
            WSAGetLastError() ));
        goto error1;
    }

    //create a new Q931 call object
    if( InitializeQ931(Q931CallSocket) == NULL )
    {
        goto error2;
    }

    _stprintf( ptstrEventName, _T("%s-%p") , 
        _T( "H323TSP_OutgoingCall_TransportHandlerEvent" ), this );

    //create the wait event
    hWSAEvent = H323CreateEvent( NULL, FALSE, 
        FALSE, ptstrEventName );

    if( hWSAEvent == NULL )
    {
        H323DBG((DEBUG_LEVEL_ERROR, "couldn't create wsaevent" ));
        goto error3;
    }

    //register with thread pool the event handle and handler proc
    fSuccess = RegisterWaitForSingleObject(
        &hConnWait,             // pointer to the returned handle
        hWSAEvent,              // the event handle to wait for.
        Q931TransportEventHandler,      // the callback function.
        (PVOID)m_hdCall,        // the context for the callback.
        INFINITE,               // wait forever.
                                // probably don't need this flag set        
        WT_EXECUTEDEFAULT   // use the wait thread to call the callback.
        );

    if ( ( !fSuccess ) || (hConnWait== NULL) )
    {
        GetLastError();
        if( !CloseHandle( hWSAEvent ) )
        {
            H323DBG((DEBUG_LEVEL_ERROR, "couldn't close wsaevent" ));
        }

        goto error3;
    }
        
    //store this in the call context 
    SetNewCallInfo( hConnWait, hWSAEvent, Q931_CALL_CONNECTING );

    //register with Winsock the event handle and the events 
    if( WSAEventSelect( Q931CallSocket,
                        hWSAEvent,
                        FD_CONNECT | FD_CLOSE
                        ) == SOCKET_ERROR )
    {
        H323DBG((DEBUG_LEVEL_ERROR, 
            "error selecting event outgoing call: %lx.", WSAGetLastError()));
        goto error3;
    }

    if( setsockopt( Q931CallSocket,
        IPPROTO_TCP, 
        TCP_NODELAY, 
        (char*)&dwEnable, 
        sizeof(DWORD) 
        ) == SOCKET_ERROR )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Couldn't set NODELAY option on outgoing call socket:%d, %p",
            WSAGetLastError(), this ));
    }

    //set the address structure
    memset( (PVOID)&sin, 0, sizeof(SOCKADDR_IN) );
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl( m_CalleeAddr.Addr.IP_Binary.dwAddr );
    sin.sin_port = htons( m_CalleeAddr.Addr.IP_Binary.wPort );

    //make the winsock connection
    if( WSAConnect( Q931CallSocket,
                    (sockaddr*)&sin,
                    sizeof(SOCKADDR_IN),
                    NULL, NULL, NULL, NULL
                  )
                  == SOCKET_ERROR )
    {
        iError = WSAGetLastError();

        if(iError != WSAEWOULDBLOCK )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "error while connecting socket: %lx.", iError ));

            goto error3;
        }
    }
    else
    {   //connection went through immediately!!!
        OnConnectComplete();    
    }

    //success
    H323DBG((DEBUG_LEVEL_TRACE, "SetupCall exited."));
    return TRUE;

error3:
    Unlock();
    Shutdown( &fDelete );    
    Lock();
error2:
    closesocket( Q931CallSocket );
error1:
    return FALSE;
}


//!!aleways called in a lock
BOOL 
CH323Call::AcceptH323Call(void)
{
    DWORD dwAPDUType = NO_H450_APDU;
    DWORD dwInvokeID = NO_INVOKEID;

    H323DBG((DEBUG_LEVEL_TRACE, "AcceptH323Call entered: %p.", this ));
    
    if( m_dwCallType & CALLTYPE_DIVERTEDDEST )
    {
        dwAPDUType = (DIVERTINGLEGINFO3_OPCODE | H450_INVOKE);
    }
    else if( m_dwCallType & CALLTYPE_TRANSFEREDDEST )
    {
        dwAPDUType = (CTSETUP_OPCODE | H450_RETURNRESULT);
        dwInvokeID = m_dwInvokeID;
    }

    ChangeCallState( LINECALLSTATE_ACCEPTED, 0 );
    
    //if pCall Divert On No Answer is enabled, then stop the timer    
    if( m_hCallDivertOnNATimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCallDivertOnNATimer, NULL );
        m_hCallDivertOnNATimer = NULL;
    }

        //encode and send Q931Connect message to the peer
    if( !SendQ931Message( dwInvokeID, 0, 0, CONNECTMESSAGETYPE, dwAPDUType ) )
    {
        //post a message to the callback thread to shutdown the H323 call
        CloseCall( 0 );
        return FALSE;
    }

    m_dwStateMachine = Q931_CONNECT_SENT;

    H323DBG((DEBUG_LEVEL_TRACE, "AcceptH323Call exited: %p.", this ));    
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::SendQ931Message( 
    IN DWORD dwInvokeID,
    IN ULONG_PTR dwParam1,
    IN ULONG_PTR dwParam2,
    IN DWORD dwMessageType,
    IN DWORD dwAPDUType
    )
{
    BINARY_STRING userUserData;
    DWORD dwCodedLengthPDU;
    BYTE *pbCodedPDU;
    BOOL retVal = FALSE;
    WCHAR * pwszCalledPartyNumber = NULL;

    H323DBG((DEBUG_LEVEL_TRACE, "SendQ931Message entered: %p.", this ));

    //check if socket is connected
    if( !(m_dwQ931Flags & Q931_CALL_CONNECTED) )
    {
        return FALSE;
    }
    
    switch ( dwMessageType )
    {
    //encode the UU message
    case SETUPMESSAGETYPE:
        retVal = EncodeSetupMessage( dwInvokeID, (WORD)dwParam1, //dwGoal
                                    (WORD)dwParam2, //dwCalType
                                    &userUserData.pbBuffer,
                                    &userUserData.length,
                                    dwAPDUType );
        break;

    case ALERTINGMESSAGETYPE:
        retVal = EncodeAlertMessage( dwInvokeID,
                                     &userUserData.pbBuffer,
                                     &userUserData.length,
                                     dwAPDUType );
        break;

    case PROCEEDINGMESSAGETYPE:
        retVal = EncodeProceedingMessage(   dwInvokeID,
                                            &userUserData.pbBuffer,
                                            &userUserData.length,
                                            dwAPDUType );
        break;
    
    case RELEASECOMPLMESSAGETYPE:
        retVal = EncodeReleaseCompleteMessage(  dwInvokeID,
                                                (BYTE*)dwParam1, //pbReason
                                                &userUserData.pbBuffer,
                                                &userUserData.length,
                                                dwAPDUType );
        break;

    case CONNECTMESSAGETYPE:
        retVal = EncodeConnectMessage(  dwInvokeID,
                                        &userUserData.pbBuffer,
                                        &userUserData.length,
                                        dwAPDUType );
        break;

    case FACILITYMESSAGETYPE:
        retVal = EncodeFacilityMessage( dwInvokeID,
                                        (BYTE)dwParam1,
                                        (ASN1octetstring_t*)dwParam2,
                                        &userUserData.pbBuffer,
                                        &userUserData.length,
                                        dwAPDUType );
        break;
    }

    if( retVal == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not encode message:%d.", dwMessageType));
        
        if( userUserData.pbBuffer )
        {
            ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, userUserData.pbBuffer );
        }

        return FALSE;
    }


    if (m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER)
    {
        _ASSERTE( m_pCalleeAliasNames->pItems[0].wType == e164_chosen );
        pwszCalledPartyNumber = m_pCalleeAliasNames ->pItems[0].pData;
    }

    //encode the PDU
    retVal = EncodePDU( &userUserData,
                &pbCodedPDU,
                &dwCodedLengthPDU,
                dwMessageType,
                pwszCalledPartyNumber );
                    
    if( retVal == FALSE )
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "could not encode PDU: %d.", dwMessageType ));
    }
    else if(!SendBuffer( pbCodedPDU, dwCodedLengthPDU ))
    {
        retVal = FALSE;
    }

    if( userUserData.pbBuffer )
    {
        ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, userUserData.pbBuffer );
    }

    H323DBG((DEBUG_LEVEL_TRACE, "SendQ931Message exited: %p.", this ));
    
    return retVal;
}


//!!always called in a lock
BOOL
CH323Call::EncodeFastStartProposal(
    PH323_FASTSTART pFastStart,
    BYTE**      ppEncodedBuf,
    WORD*       pwEncodedLength
    )
{
    int rc;
    H323_UserInformation UserInfo;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFastStartProposal entered: %p.", this ));
    
    CallProceeding_UUIE & proceedingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding;

    *ppEncodedBuf = NULL;
    *pwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;


    //copy the call identifier
    proceedingMessage.bit_mask |= CallProceeding_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&proceedingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    proceedingMessage.callIdentifier.guid.length = sizeof(GUID);

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);
    UserInfo.h323_uu_pdu.bit_mask = 0;

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;
    proceedingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    
    proceedingMessage.bit_mask |= CallProceeding_UUIE_fastStart_present;
    proceedingMessage.fastStart = (PCallProceeding_UUIE_fastStart)pFastStart;

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pwEncodedLength == 0) )
    {
        return FALSE;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFastStartProposal exited: %p.", this ));
    //success
    return TRUE;                
}

                     
//!!always called in a lock
BOOL
CH323Call::EncodeFacilityMessage(
    IN DWORD dwInvokeID,
    IN BYTE  bReason,
    IN ASN1octetstring_t* pH245PDU,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int                     rc;
    H323_UserInformation    UserInfo;
    DWORD                   dwAPDULen = 0;
    BYTE*                   pEncodedAPDU = NULL;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFacilityMessage entered: %p.", this ));
    
    Facility_UUIE & facilityMessage = 
        UserInfo.h323_uu_pdu.h323_message_body.u.facility;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU(dwInvokeID, dwAPDUType, 
                            &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = facility_chosen;

    facilityMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    facilityMessage.bit_mask = 0;

    TransportAddress& transportAddress = facilityMessage.alternativeAddress;
    
    if( IsGuidSet( &m_ConferenceID ) )
    {
        CopyConferenceID(&facilityMessage.conferenceID, &m_ConferenceID);
        facilityMessage.bit_mask |= Facility_UUIE_conferenceID_present;
    }

    switch (bReason)
    {
    case H323_REJECT_ROUTE_TO_GATEKEEPER:
        facilityMessage.reason.choice = 
            FacilityReason_routeCallToGatekeeper_chosen;
        break;

    case H323_REJECT_CALL_FORWARDED:
        facilityMessage.reason.choice = callForwarded_chosen;
        break;
    
    case H323_REJECT_ROUTE_TO_MC:
        facilityMessage.reason.choice = routeCallToMC_chosen;
        break;
    
    default:
        facilityMessage.reason.choice = FacilityReason_undefinedReason_chosen;
    }

    facilityMessage.bit_mask |= Facility_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&facilityMessage.callIdentifier.guid.value,
            (PVOID)"abcdabcdabcdabcdabcd",
            sizeof(GUID) );
    facilityMessage.callIdentifier.guid.length = sizeof(GUID);

    if( pH245PDU && (pH245PDU->value != NULL) )
    {
        //h245 PDU to be sent
        UserInfo.h323_uu_pdu.h245Control->next = NULL;
        UserInfo.h323_uu_pdu.h245Control->value.length = pH245PDU->length;
        UserInfo.h323_uu_pdu.h245Control->value.value = pH245PDU->value;
    }

    rc = EncodeASN((void *) &UserInfo,
                 H323_UserInformation_PDU,
                 ppEncodedBuf,
                 pdwEncodedLength);

    if( ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }
        return FALSE;
    }

    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeFacilityMessage exited: %p.", this ));    
    //success
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::EncodeAlertMessage(
                                IN DWORD dwInvokeID,
                                OUT BYTE **ppEncodedBuf,
                                OUT WORD *pdwEncodedLength,
                                IN DWORD dwAPDUType
                             )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*                pEncodedAPDU = NULL;

    
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeAlertMessage entered: %p.", this ));

    Alerting_UUIE & alertingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.alerting;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;
    
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;

        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = alerting_chosen;

    alertingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;
    alertingMessage.destinationInfo.bit_mask = 0;
    
    //copy the vendor info
    alertingMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &alertingMessage.destinationInfo.vendor );

    //its a terminal
    alertingMessage.destinationInfo.bit_mask = terminal_present;
    alertingMessage.destinationInfo.terminal.bit_mask = 0;
    
    //not na MC
    alertingMessage.destinationInfo.mc = 0;
    alertingMessage.destinationInfo.undefinedNode = 0;
        
    TransportAddress& transportAddress = alertingMessage.h245Address;

    //send H245 address only if the caller hasn't proposed FasrStart
    //or the fast start proposal has been accepeted
    if( (m_pPeerFastStart == NULL) || m_pFastStart )
    {
        if( m_selfH245Addr.Addr.IP_Binary.dwAddr != 0 )
        {
            CopyTransportAddress( transportAddress, &m_selfH245Addr );
            alertingMessage.bit_mask |= (Alerting_UUIE_h245Address_present);
        }
        else
        {
            alertingMessage.bit_mask &= (~Alerting_UUIE_h245Address_present);
        }
    }

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        alertingMessage.bit_mask |= Alerting_UUIE_fastStart_present;
        alertingMessage.fastStart = (PAlerting_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        alertingMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    alertingMessage.bit_mask |= Alerting_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&alertingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    alertingMessage.callIdentifier.guid.length = sizeof(GUID);


    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }
        return FALSE;
    }

    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeAlertMessage exited: %p.", this ));    
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL
CH323Call::EncodeProceedingMessage(
                                    IN DWORD dwInvokeID,
                                    OUT BYTE **ppEncodedBuf,
                                    OUT WORD *pdwEncodedLength,
                                    IN DWORD dwAPDUType
                                  )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeProceedingMessage entered: %p.", this ));
    
    CallProceeding_UUIE & proceedingMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.callProceeding;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;

        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = callProceeding_chosen;
    proceedingMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    TransportAddress& transportAddress = proceedingMessage.h245Address;
    
    //send H245 address only if the caller hasn't proposed FasrStart
    //or the fast start proposal has been accepeted
    if( (m_pPeerFastStart == NULL) || m_pFastStart )
    {
        if( m_selfH245Addr.Addr.IP_Binary.dwAddr != 0 )
        {
            CopyTransportAddress( transportAddress, &m_selfH245Addr );
            proceedingMessage.bit_mask |= CallProceeding_UUIE_h245Address_present;
        }
        else
        {
            proceedingMessage.bit_mask &= ~CallProceeding_UUIE_h245Address_present;
        }
    }

    proceedingMessage.destinationInfo.bit_mask = 0;

    //copy the vendor info
    proceedingMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &proceedingMessage.destinationInfo.vendor );

    proceedingMessage.destinationInfo.mc = 0;
    proceedingMessage.destinationInfo.undefinedNode = 0;

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        proceedingMessage.bit_mask |= Alerting_UUIE_fastStart_present;
        proceedingMessage.fastStart = 
            (PCallProceeding_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        proceedingMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    proceedingMessage.bit_mask |= CallProceeding_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&proceedingMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    proceedingMessage.callIdentifier.guid.length = sizeof(GUID);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        return FALSE;
    }
        
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeProceedingMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL 
CH323Call::EncodeReleaseCompleteMessage(
    IN DWORD dwInvokeID,
    IN BYTE *pbReason,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeReleaseCompleteMessage entered: %p.", this ));
    
    ReleaseComplete_UUIE & releaseMessage = 
    UserInfo.h323_uu_pdu.h323_message_body.u.releaseComplete;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    SetNonStandardData( UserInfo );
    
    UserInfo.h323_uu_pdu.h323_message_body.choice = releaseComplete_chosen;

    releaseMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    if( pbReason )
    {
        releaseMessage.reason.choice = 0;
        releaseMessage.bit_mask |= (ReleaseComplete_UUIE_reason_present);

        switch (*pbReason)
        {
        case H323_REJECT_NO_BANDWIDTH:
            releaseMessage.reason.choice = noBandwidth_chosen;
            break;

        case H323_REJECT_GATEKEEPER_RESOURCES:
            releaseMessage.reason.choice = gatekeeperResources_chosen;
            break;
        
        case H323_REJECT_UNREACHABLE_DESTINATION:
            releaseMessage.reason.choice = unreachableDestination_chosen;
            break;
        
        case H323_REJECT_DESTINATION_REJECTION:
            releaseMessage.reason.choice = destinationRejection_chosen;
            break;
        
        case H323_REJECT_INVALID_REVISION:
            releaseMessage.reason.choice 
                = ReleaseCompleteReason_invalidRevision_chosen;
            break;
        
        case H323_REJECT_NO_PERMISSION:
            releaseMessage.reason.choice = noPermission_chosen;
            break;
        
        case H323_REJECT_UNREACHABLE_GATEKEEPER:
            releaseMessage.reason.choice = unreachableGatekeeper_chosen;
            break;
        
        case H323_REJECT_GATEWAY_RESOURCES:
            releaseMessage.reason.choice = gatewayResources_chosen;
            break;
        
        case H323_REJECT_BAD_FORMAT_ADDRESS:
            releaseMessage.reason.choice = badFormatAddress_chosen;
            break;
        
        case H323_REJECT_ADAPTIVE_BUSY:
            releaseMessage.reason.choice = adaptiveBusy_chosen;
            break;
        
        case H323_REJECT_IN_CONF:
            releaseMessage.reason.choice = inConf_chosen;
            break;
        
        case H323_REJECT_CALL_DEFLECTION:
            releaseMessage.reason.choice = 
                ReleaseCompleteReason_undefinedReason_chosen ;
            break;
        
        case H323_REJECT_UNDEFINED_REASON:
            releaseMessage.reason.choice = ReleaseCompleteReason_undefinedReason_chosen ;
            break;
        
        case H323_REJECT_USER_BUSY:
            releaseMessage.reason.choice = inConf_chosen;
            break;
        
        default:
            //log

            if( pEncodedAPDU != NULL )
            {
                ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
            }        
            return FALSE;
        }
    }

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        
        return FALSE;
    }
    
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeReleaseCompleteMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
BOOL 
CH323Call::EncodeConnectMessage( 
    IN DWORD dwInvokeID,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    int rc;
    H323_UserInformation UserInfo;
    DWORD                dwAPDULen = 0;
    BYTE*               pEncodedAPDU = NULL;


    H323DBG((DEBUG_LEVEL_TRACE, "EncodeConnectMessage entered: %p.", this ));
    
    Connect_UUIE & connectMessage = 
        UserInfo.h323_uu_pdu.h323_message_body.u.connect;

    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;
    
    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));
    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, 
                &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = connect_chosen;

    connectMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    TransportAddress& transportAddress = connectMessage.h245Address;
    CopyTransportAddress( transportAddress, &m_selfH245Addr );
    connectMessage.bit_mask |= (Connect_UUIE_h245Address_present);

    connectMessage.destinationInfo.bit_mask = 0;

    //copy the vendor info
    connectMessage.destinationInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &connectMessage.destinationInfo.vendor );

    //terminal is present
    connectMessage.destinationInfo.bit_mask |= terminal_present;
    connectMessage.destinationInfo.terminal.bit_mask = 0;

    connectMessage.destinationInfo.mc = 0;
    connectMessage.destinationInfo.undefinedNode = 0;

    //copy the 16 byte conference ID
    CopyConferenceID (&connectMessage.conferenceID, &m_ConferenceID);

    if( m_pFastStart != NULL )
    {
        _ASSERTE( m_pPeerFastStart );
        connectMessage.bit_mask |= Connect_UUIE_fastStart_present;
        connectMessage.fastStart = (PConnect_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        connectMessage.bit_mask &= ~Alerting_UUIE_fastStart_present;
    }

    //copy the call identifier
    connectMessage.bit_mask |= Connect_UUIE_callIdentifier_present;
    CopyMemory( (PVOID)&connectMessage.callIdentifier.guid.value,
            (PVOID)&m_callIdentifier,
            sizeof(GUID) );
    connectMessage.callIdentifier.guid.length = sizeof(GUID);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if (ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {
        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        return FALSE;
    }
        
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeConnectMessage exited: %p.", this ));
    //success
    return TRUE;                
}


//!!always called in a lock
void CH323Call::SetNonStandardData(
    OUT H323_UserInformation & UserInfo 
    )
{
    if( m_NonStandardData.sData.pOctetString )
    {
          H221NonStandard & nonStd =
              UserInfo.h323_uu_pdu.nonStandardData.nonStandardIdentifier.u.h221NonStandard;

        UserInfo.h323_uu_pdu.bit_mask |= H323_UU_PDU_nonStandardData_present;
    
        UserInfo.h323_uu_pdu.nonStandardData.nonStandardIdentifier.choice
            = H225NonStandardIdentifier_h221NonStandard_chosen;
        
        nonStd.t35CountryCode = m_NonStandardData.bCountryCode;
        nonStd.t35Extension = m_NonStandardData.bExtension;
        nonStd.manufacturerCode = m_NonStandardData.wManufacturerCode;
        
        UserInfo.h323_uu_pdu.nonStandardData.data.length =
            m_NonStandardData.sData.wOctetStringLength;
        
        UserInfo.h323_uu_pdu.nonStandardData.data.value =
            m_NonStandardData.sData.pOctetString;

        // Maintain only one reference to the buffer.
        m_NonStandardData.sData.pOctetString = NULL;
    }
    else
    {
        UserInfo.h323_uu_pdu.bit_mask &= (~H323_UU_PDU_nonStandardData_present);
    }
}


//!!always called in a lock
BOOL
CH323Call::EncodeSetupMessage( 
    IN DWORD dwInvokeID,
    IN WORD wGoal,
    IN WORD wCallType,
    OUT BYTE **ppEncodedBuf,
    OUT WORD *pdwEncodedLength,
    IN DWORD dwAPDUType
    )
{
    H323_UU_PDU_h4501SupplementaryService h4501APDU;
    H323_UserInformation UserInfo;
    int                 rc = 0;
    BOOL                retVal = TRUE;
    DWORD               dwAPDULen = 0;
    BYTE*              pEncodedAPDU = NULL;
        
    *ppEncodedBuf = NULL;
    *pdwEncodedLength = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeSetupMessage entered: %p.", this ));

    Setup_UUIE & setupMessage = UserInfo.h323_uu_pdu.h323_message_body.u.setup;
    TransportAddress& calleeAddr = setupMessage.destCallSignalAddress;
    TransportAddress& callerAddr = setupMessage.sourceCallSignalAddress;

    memset( (PVOID)&UserInfo, 0, sizeof(H323_UserInformation));

    UserInfo.bit_mask = 0;

    // make sure the user_data_present flag is turned off.
    UserInfo.bit_mask &= (~user_data_present);

    UserInfo.h323_uu_pdu.bit_mask = 0;

    //send the appropriate ADPDUS
    if( dwAPDUType != NO_H450_APDU )
    {
        if( !EncodeH450APDU( dwInvokeID, dwAPDUType, &pEncodedAPDU, &dwAPDULen ) )
        {
            return FALSE;
        }
    
        UserInfo.h323_uu_pdu.h4501SupplementaryService = &h4501APDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> next = NULL;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.value = pEncodedAPDU;
        UserInfo.h323_uu_pdu.h4501SupplementaryService -> value.length = dwAPDULen;
        UserInfo.h323_uu_pdu.bit_mask |= h4501SupplementaryService_present;
    }

    UserInfo.h323_uu_pdu.h245Tunneling = FALSE;//(m_fh245Tunneling & LOCAL_H245_TUNNELING);
    UserInfo.h323_uu_pdu.bit_mask |= h245Tunneling_present;

    SetNonStandardData( UserInfo );

    UserInfo.h323_uu_pdu.h323_message_body.choice = setup_chosen;
    setupMessage.bit_mask = 0;

    setupMessage.protocolIdentifier = OID_H225ProtocolIdentifierV2;

    if( m_pCallerAliasNames && m_pCallerAliasNames -> wCount )
    {
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
        
        setupMessage.sourceAddress = SetMsgAddressAlias(m_pCallerAliasNames);

        if( setupMessage.sourceAddress != NULL )
        {
            setupMessage.bit_mask |= (sourceAddress_present);
        }
        else
        {
            setupMessage.bit_mask &= (~sourceAddress_present);
        }
    }
    else
    {
        setupMessage.bit_mask &= (~sourceAddress_present);
    }

    setupMessage.sourceInfo.bit_mask = 0;

    //pass the vendor info
    setupMessage.sourceInfo.bit_mask |= vendor_present;
    CopyVendorInfo( &setupMessage.sourceInfo.vendor );

    //terminal is present
    setupMessage.sourceInfo.bit_mask |= terminal_present;
    setupMessage.sourceInfo.terminal.bit_mask = 0;

    //not an MC
    setupMessage.sourceInfo.mc = FALSE;
    setupMessage.sourceInfo.undefinedNode = 0;

    if( m_pCalleeAliasNames && m_pCalleeAliasNames -> wCount )
    {
        setupMessage.destinationAddress = (PSetup_UUIE_destinationAddress)
            SetMsgAddressAlias( m_pCalleeAliasNames );

        if( setupMessage.destinationAddress != NULL )
        {
            setupMessage.bit_mask |= (destinationAddress_present);
        }
        else
        {
            setupMessage.bit_mask &= (~destinationAddress_present);
        }
    }
    else
    {
        setupMessage.bit_mask &= (~destinationAddress_present);
    }

    //extra alias not present
    setupMessage.bit_mask &= (~Setup_UUIE_destExtraCallInfo_present );

    //If talking to gateway then don't pass on destn call signal address
    if( m_dwAddressType != LINEADDRESSTYPE_PHONENUMBER )
    {
        CopyTransportAddress( calleeAddr, &m_CalleeAddr );
        setupMessage.bit_mask |= Setup_UUIE_destCallSignalAddress_present;
    }

    //not an MC
    setupMessage.activeMC = m_fActiveMC;

    //copy the 16 byte conference ID
    CopyConferenceID (&setupMessage.conferenceID, &m_ConferenceID);

    //copy the call identifier
    setupMessage.bit_mask |= Setup_UUIE_callIdentifier_present;
    CopyConferenceID (&setupMessage.callIdentifier.guid, &m_callIdentifier);

    //fast start params
    if( m_pFastStart != NULL )
    {
        setupMessage.bit_mask |= Setup_UUIE_fastStart_present;
        setupMessage.fastStart = (PSetup_UUIE_fastStart)m_pFastStart;
    }
    else
    {
        setupMessage.bit_mask &= ~Setup_UUIE_fastStart_present;
    }

    //copy media wait for connect
    setupMessage.mediaWaitForConnect = FALSE;

    setupMessage.conferenceGoal.choice = (BYTE)wGoal;
    setupMessage.callType.choice = (BYTE)wCallType;

    CopyTransportAddress( callerAddr, &m_CallerAddr );
    setupMessage.bit_mask |= sourceCallSignalAddress_present;

    //no extension alias
    setupMessage.bit_mask &= (~Setup_UUIE_remoteExtensionAddress_present);

    rc = EncodeASN( (void *) &UserInfo,
                    H323_UserInformation_PDU,
                    ppEncodedBuf,
                    pdwEncodedLength);

    if( ASN1_FAILED(rc) || (*ppEncodedBuf == NULL) || (pdwEncodedLength == 0) )
    {

        if( pEncodedAPDU != NULL )
        {
            ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
        }        

        retVal = FALSE;
    }

    // Free the alias name structures from the UserInfo area.
    if( setupMessage.bit_mask & sourceAddress_present )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            setupMessage.sourceAddress );
    }
    
    if( setupMessage.bit_mask & destinationAddress_present )
    {
        FreeAddressAliases( setupMessage.destinationAddress );
    }
    
    if( pEncodedAPDU != NULL )
    {
        ASN1_FreeEncoded(m_H450ASNCoderInfo.pEncInfo, pEncodedAPDU );
    }        

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeSetupMessage exited: %p.", this ));    
    //success/failure
    return retVal;                
}


//!!always called in a lock
BOOL
CH323Call::EncodeH450APDU(
    IN DWORD dwInvokeID,
    IN DWORD dwAPDUType,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    H4501SupplementaryService SupplementaryServiceAPDU;
    ServiceApdus_rosApdus rosAPDU;
    DWORD dwErrorCode = 0;
    DWORD dwOperationType = (dwAPDUType & 0x0000FF00);
    dwAPDUType &= 0x000000FF;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450APDU entered: %p.", this ));

    ZeroMemory( (PVOID)&SupplementaryServiceAPDU, 
        sizeof(H4501SupplementaryService) );

    //interpretationAPDU
    SupplementaryServiceAPDU.interpretationApdu.choice =
        rejectAnyUnrecognizedInvokePdu_chosen;
    SupplementaryServiceAPDU.bit_mask |= interpretationApdu_present;
    
    //NFE
    SupplementaryServiceAPDU.networkFacilityExtension.bit_mask = 0;
    SupplementaryServiceAPDU.networkFacilityExtension.destinationEntity.choice
        = endpoint_chosen;
    SupplementaryServiceAPDU.networkFacilityExtension.sourceEntity.choice
        = endpoint_chosen;
    SupplementaryServiceAPDU.bit_mask |= networkFacilityExtension_present;

    //serviceAPDUS
    SupplementaryServiceAPDU.serviceApdu.choice = rosApdus_chosen;
    SupplementaryServiceAPDU.serviceApdu.u.rosApdus = &rosAPDU;
    SupplementaryServiceAPDU.serviceApdu.u.rosApdus->next = NULL;

    if( dwOperationType == H450_REJECT )
    {
        if( !EncodeRejectAPDU( &SupplementaryServiceAPDU, dwInvokeID,
            ppEncodedAPDU, pdwAPDULen ) )
        {
            return FALSE;
        }
    }
    else if( dwOperationType == H450_RETURNERROR )
    {
        EncodeReturnErrorAPDU( dwInvokeID, dwErrorCode, 
            &SupplementaryServiceAPDU, ppEncodedAPDU, pdwAPDULen );
    }
    else if( dwOperationType == H450_RETURNRESULT )
    {
        if( !EncodeDummyReturnResultAPDU( dwInvokeID,
            dwAPDUType, &SupplementaryServiceAPDU,
            ppEncodedAPDU, pdwAPDULen ) )
        {
            return FALSE;
        }
    }
    else //H450_INVOKE
    {
        switch( dwAPDUType )
        {
        case CHECKRESTRICTION_OPCODE:
    
            if( !EncodeCheckRestrictionAPDU( &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
           
            break;
        
        case CALLREROUTING_OPCODE:

            if( !EncodeCallReroutingAPDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
    
            break;

        case DIVERTINGLEGINFO2_OPCODE:

            if( !EncodeDivertingLeg2APDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
        
            break;

        case DIVERTINGLEGINFO3_OPCODE:

            if( !EncodeDivertingLeg3APDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;

        case HOLDNOTIFIC_OPCODE:
        case REMOTEHOLD_OPCODE:
        case RETRIEVENOTIFIC_OPCODE:
        case REMOTERETRIEVE_OPCODE:
        case CTIDENTIFY_OPCODE:

            if( !EncodeH450APDUNoArgument( dwAPDUType, &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }
            break;

        case CTSETUP_OPCODE:

            if( !EncodeCTSetupAPDU( &SupplementaryServiceAPDU, 
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;
   
        case CTINITIATE_OPCODE:

            if( !EncodeCTInitiateAPDU( &SupplementaryServiceAPDU,
                ppEncodedAPDU, pdwAPDULen ) )
            {
                return FALSE;
            }

            break;

        default:
            _ASSERTE( 0 );
            return FALSE;
        }
    }

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450APDU exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
BOOL 
CH323Call::EncodePDU(
    IN BINARY_STRING *pUserUserData,
    OUT BYTE ** ppbCodedBuffer,
    OUT DWORD * pdwCodedBufferLength,
    IN DWORD dwMessageType,
    WCHAR * pwszCalledPartyNumber
    )
{
    PQ931MESSAGE    pMessage;
    BYTE            bBandwidth;
    char            pszDisplay[131] = "";
    DWORD           dwMessageLength = 0;
    BYTE            indexI;
    BOOL            retVal;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodePDU entered: %p.", this ));

    pMessage = new Q931MESSAGE;
    if( pMessage == NULL )
    {
        return FALSE;
    }

    // fill in the required fields for the Q931 message.
    memset( (PVOID)pMessage, 0, sizeof(Q931MESSAGE));
    pMessage->ProtocolDiscriminator = Q931PDVALUE;
    pMessage->wCallRef = m_wQ931CallRef;
    pMessage->MessageType = (BYTE)dwMessageType;

    dwMessageLength += 
        ( 1 + sizeof(PDTYPE) + sizeof(CRTYPE) + sizeof(MESSAGEIDTYPE) );

    if( (dwMessageType == SETUPMESSAGETYPE) || 
        (dwMessageType == CONNECTMESSAGETYPE) )
    {
        if( m_pwszDisplay && 
            WideCharToMultiByte(CP_ACP, 
                                0, 
                                m_pwszDisplay, 
                                -1, 
                                pszDisplay,
                                sizeof(pszDisplay), 
                                NULL, 
                                NULL) == 0)
        {
            delete pMessage;
            return FALSE;
        }

        if( *pszDisplay )
        {
            pMessage->Display.fPresent = TRUE;
            pMessage->Display.dwLength = (BYTE)(strlen(pszDisplay) + 1);
            strcpy((char *)pMessage->Display.pbContents, pszDisplay);
            dwMessageLength += (2 + pMessage->Display.dwLength);
        }

        pMessage->BearerCapability.fPresent = TRUE;
        pMessage->BearerCapability.dwLength = 3;
        pMessage->BearerCapability.pbContents[0] =
            (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
        pMessage->BearerCapability.pbContents[1] =
            (BYTE)(BEAR_EXT_BIT | 0x17);  //64kbps
        pMessage->BearerCapability.pbContents[2] = (BYTE)
            (BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | BEAR_LAYER1_H221_H242);

        dwMessageLength += (2+pMessage->BearerCapability.dwLength);
    }

    //if talking to gateway encode the called party number
    if( m_dwAddressType == LINEADDRESSTYPE_PHONENUMBER )
    {
        BYTE bLen = (BYTE)(wcslen(pwszCalledPartyNumber)+1);
        pMessage->CalledPartyNumber.fPresent = TRUE;

        pMessage->CalledPartyNumber.NumberType =
            (BYTE)(CALLED_PARTY_EXT_BIT | CALLED_PARTY_TYPE_UNKNOWN);
        pMessage->CalledPartyNumber.NumberingPlan =
            (BYTE)(CALLED_PARTY_PLAN_E164);
        pMessage->CalledPartyNumber.PartyNumberLength = bLen;

        for( indexI =0; indexI < bLen; indexI++ )
        {
            pMessage->CalledPartyNumber.PartyNumbers[indexI] = 
                (BYTE)pwszCalledPartyNumber[indexI];
        }

        dwMessageLength += (2 + pMessage->CalledPartyNumber.PartyNumberLength);
    }

    if( dwMessageType == FACILITYMESSAGETYPE )
    {
        // The facility ie is encoded as present, but empty...
        pMessage->Facility.fPresent = TRUE;
        pMessage->Facility.dwLength = 0;
        pMessage->Facility.pbContents[0] = 0;

        dwMessageLength += (2 + pMessage->Facility.dwLength);
    }

    if (pUserUserData && pUserUserData->pbBuffer)
    {
        if (pUserUserData->length > sizeof(pMessage->UserToUser.pbUserInfo))
        {
            delete pMessage;
            return FALSE;
        }
        pMessage->UserToUser.fPresent = TRUE;
        pMessage->UserToUser.wUserInfoLen = pUserUserData->length;
        
        //This CopyMemory should be avoided
        //may be we should do:pMessage->UserToUser.pbUserInfo = pUserUserData->pbBuffer;
        //change the definition of pMessage->UserToUser.pbUserInfo to BYTE* from BYTE[0x1000]
        CopyMemory( (PVOID)pMessage->UserToUser.pbUserInfo,
            (PVOID)pUserUserData->pbBuffer, pUserUserData->length );

        dwMessageLength += (4+pMessage->UserToUser.wUserInfoLen);
    }

    _ASSERTE( dwMessageLength );

    retVal = EncodeMessage( pMessage, ppbCodedBuffer, 
                          pdwCodedBufferLength, dwMessageLength );

    delete pMessage;

    return retVal;
}


//!!always called in a lock
BOOL 
CH323Call::EncodeMessage(
                        IN PQ931MESSAGE pMessage,
                        OUT BYTE **ppbCodedMessage,
                        OUT DWORD *pdwCodedMessageLength,
                        IN DWORD dwMessageLength
                        )
{
    BUFFERDESCR pBuf;
    DWORD dwPDULen = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "EncodeMessage entered: %p.", this ));
    
    *ppbCodedMessage = (BYTE *)new char[ dwMessageLength + 100 ];
    
    if( *ppbCodedMessage == NULL )
    {
        return FALSE;
    }

    pBuf.dwLength = dwMessageLength + 100;

    pBuf.pbBuffer = *ppbCodedMessage + TPKT_HEADER_SIZE;

    WriteQ931Fields(&pBuf, pMessage, &dwPDULen );

    _ASSERTE( dwPDULen == dwMessageLength );

    SetupTPKTHeader( *ppbCodedMessage , dwPDULen );

    *pdwCodedMessageLength = dwPDULen + 4;
    
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeMessage exited: %p.", this ));
    return TRUE;
}


//!!always called in a lock
void
CH323Call::WriteQ931Fields(
                            IN PBUFFERDESCR pBuf,
                            IN PQ931MESSAGE pMessage,
                            OUT DWORD * pdwPDULen
                          )
{
    H323DBG((DEBUG_LEVEL_TRACE, "WriteQ931Fields entered: %p.", this ));

    // write the required information elements...
    WriteProtocolDiscriminator( pBuf, pdwPDULen );

    WriteCallReference( pBuf, &pMessage->wCallRef,
        pdwPDULen );

    WriteMessageType(pBuf, &pMessage->MessageType,
        pdwPDULen);

    // try to write all other information elements...
    // don't write this message.
    if (pMessage->Facility.fPresent)
    {
        WriteVariableOctet(pBuf, IDENT_FACILITY,
            pMessage->Facility.dwLength,
            pMessage->Facility.pbContents,
            pdwPDULen);
    }

    if( pMessage->BearerCapability.fPresent 
        && pMessage->BearerCapability.dwLength )
    {
        WriteVariableOctet(pBuf, IDENT_BEARERCAP,
            pMessage->BearerCapability.dwLength,
            pMessage->BearerCapability.pbContents,
            pdwPDULen);
    }

    if (pMessage->Display.fPresent && pMessage->Display.dwLength)
    {
        WriteVariableOctet(pBuf, IDENT_DISPLAY,
            pMessage->Display.dwLength,
            pMessage->Display.pbContents,
            pdwPDULen);
    }
        
    if( pMessage->CalledPartyNumber.fPresent )
    {
        WritePartyNumber(pBuf,
            IDENT_CALLEDNUMBER,
            pMessage->CalledPartyNumber.NumberType,
            pMessage->CalledPartyNumber.NumberingPlan,
            pMessage->CalledPartyNumber.PartyNumberLength,
            pMessage->CalledPartyNumber.PartyNumbers,
            pdwPDULen);
    }

    if( pMessage->UserToUser.fPresent && 
        pMessage->UserToUser.wUserInfoLen )
    {
        WriteUserInformation(pBuf,
            IDENT_USERUSER,
            pMessage->UserToUser.wUserInfoLen,
            pMessage->UserToUser.pbUserInfo,
            pdwPDULen);
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "WriteQ931Fields exited: %p.", this ));
}


//!!always calld in a lock
void 
CH323Call::HandleTransportEvent(void)
{
    WSANETWORKEVENTS networkEvents;
    int iError;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleTransportEvent entered: %p.", this ));
    
    if( (m_callSocket == INVALID_SOCKET) && 
        (m_dwCallType == CALLTYPE_DIVERTEDSRC) )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "The diverted call is not initialized yet."
            "This is probably an event for the primary call. Ignore it %p.", 
            this ));
        
        return;
    }

    //find out the event that took place
    if(WSAEnumNetworkEvents(m_callSocket,
                            m_hTransport,
                            &networkEvents ) == SOCKET_ERROR )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "WSAEnumNetworkEvents error:%d, %lx, %p.",
            WSAGetLastError(), m_callSocket, this ));
        return;
    }
                            
    if( networkEvents.lNetworkEvents & FD_CLOSE )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "socket close event: %p.", this ));


        //if the call is in transition then don't close the call when the
        //old socket gets closed
        if( m_fCallInTrnasition == TRUE ) 
        {
            //the call is noot in transition mode anymore
            m_fCallInTrnasition = FALSE;
            return;
        }
        //convey the Q931 close status to the TAPI call object
        //and the tapisrv
        iError = networkEvents.iErrorCode[FD_CLOSE_BIT];
        
        SetQ931CallState( Q931_CALL_DISCONNECTED );
        
        //clean up the Q931 call
        CloseCall( 0 );
        return;
    }
    
    //This can occur only for outbound calls
    if( (networkEvents.lNetworkEvents) & FD_CONNECT )
    {
        H323DBG((DEBUG_LEVEL_TRACE, "socket connect event: %p.", this ));

        //FD_CONNECT event received
        //This func is called by the callback thread when m_hEventQ931Conn is
        //signalled. This function takes care of the outgoing Q931 calls only
        //call the member function
        iError = networkEvents.iErrorCode[FD_CONNECT_BIT];
        if(iError != ERROR_SUCCESS)
        {
            if( (m_dwCallType & CALLTYPE_FORWARDCONSULT )&&
                (m_dwOrigin == LINECALLORIGIN_OUTBOUND ) )
            {
                //Success of forwarding
                EnableCallForwarding();
            }
            
            H323DBG((DEBUG_LEVEL_ERROR, "FD_CONNECT returned error: %d.", 
                iError ));

            CloseCall( 0 );         
            return;
        }
        OnConnectComplete();
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "HandleTransportEvent exited: %p.", this ));
}


//!!always called in a lock
int 
CH323Call::InitASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder entered: %p.", this ));

    memset((PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    if( H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H225ASN_Module,         // ptr to mdule
                &(m_ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        _ASSERTE(m_ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitASNCoder exited: %p.", this ));
    return rc;
}

//!!always called in a lock
int 
CH323Call::TermASNCoder(void)
{
    if( H225ASN_Module == NULL )
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    return ASN1_SUCCESS;
}


//!!always called in a lock
int 
CH323Call::EncodeASN(
                    IN void *  pStruct, 
                    IN int     nPDU, 
                    OUT BYTE ** ppEncoded, 
                    OUT WORD *  pcbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeASN entered: %p.", this ));

    ASN1encoding_t pEncInfo = m_ASNCoderInfo.pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while encoding ASN:%d.", rc ));
        }
        *pcbEncodedSize = (WORD)pEncInfo->len;  // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while encoding ASN:%d.", rc ));
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::DecodeASN(
                      OUT void **   ppStruct, 
                      IN int       nPDU, 
                      IN BYTE *    pEncoded, 
                      IN DWORD     cbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeASN entered: %p.", this ));
    ASN1decoding_t pDecInfo = m_ASNCoderInfo.pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided

    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while deciding ASN:%d.", rc ));
        }
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while deciding ASN:%d.", rc ));
        H323DUMPBUFFER( (BYTE*)pEncoded, cbEncodedSize);
        *ppStruct = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::InitH450ASNCoder(void)
{
    int rc;
    H323DBG((DEBUG_LEVEL_TRACE, "InitH450ASNCoder entered: %p.", this ));

    memset((PVOID)&m_H450ASNCoderInfo, 0, sizeof(m_H450ASNCoderInfo));

    if( H4503PP_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H4503PP_Module,         // ptr to mdule
                &(m_H450ASNCoderInfo.pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        _ASSERTE(m_H450ASNCoderInfo.pEncInfo );

        rc = ASN1_CreateDecoder(
                H4503PP_Module,         // ptr to mdule
                &(m_H450ASNCoderInfo.pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL );                  // parent ptr
        _ASSERTE( m_H450ASNCoderInfo.pDecInfo );
    }

    if (rc != ASN1_SUCCESS)
    {
        TermH450ASNCoder();
    }

    H323DBG((DEBUG_LEVEL_TRACE, "InitH450ASNCoder exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::TermH450ASNCoder(void)
{
    if( H4503PP_Module == NULL )
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(m_H450ASNCoderInfo.pEncInfo);
    ASN1_CloseDecoder(m_H450ASNCoderInfo.pDecInfo);

    memset( (PVOID)&m_H450ASNCoderInfo, 0, sizeof(m_ASNCoderInfo));

    return ASN1_SUCCESS;
}


//!!always called in a lock
int 
CH323Call::EncodeH450ASN(
                    IN void *  pStruct, 
                    IN int     nPDU, 
                    OUT BYTE ** ppEncoded, 
                    OUT WORD *  pcbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450ASN entered: %p.", this ));

    ASN1encoding_t pEncInfo = m_H450ASNCoderInfo.pEncInfo;
    int rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    ASN1ENCODE_ALLOCATEBUFFER,  // flags
                    NULL,                       // do not provide buffer
                    0);                         // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while encoding ASN:%d.", rc ));
        }
        *pcbEncodedSize = (WORD)pEncInfo->len;  // len of encoded data in buffer
        *ppEncoded = pEncInfo->buf;             // buffer to encode into
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while encoding ASN:%d.", rc ));
        *pcbEncodedSize = 0;
        *ppEncoded = NULL;
    }
        
    H323DBG((DEBUG_LEVEL_TRACE, "EncodeH450ASN exited: %p.", this ));
    return rc;
}


//!!always called in a lock
int 
CH323Call::DecodeH450ASN(
                      OUT void **   ppStruct, 
                      IN int       nPDU, 
                      IN BYTE *    pEncoded, 
                      IN DWORD     cbEncodedSize
                    )
{
    H323DBG((DEBUG_LEVEL_TRACE, "h323call DecodeH450ASN entered: %p.", this ));
    ASN1decoding_t pDecInfo = m_H450ASNCoderInfo.pDecInfo;
    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided

    if( ASN1_SUCCEEDED(rc) )
    {
        if( rc != ASN1_SUCCESS )
        {
            H323DBG((DEBUG_LEVEL_TRACE, "warning while deciding ASN:%d.", rc ));
        }
    }
    else
    {
        H323DBG((DEBUG_LEVEL_TRACE, "error while deciding ASN:%d.", rc ));
        H323DUMPBUFFER( (BYTE*)pEncoded, cbEncodedSize);
        *ppStruct = NULL;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "h323call DecodeH450ASN exited: %p.", this ));
    return rc;
}


//------------------------------------------------------------------------
//------------------------------------------------------------------------
//!!always called in a lock
BOOL 
CH323Call::ParseReleaseCompleteASN(
                                    IN BYTE *pEncodedBuf,
                                    IN DWORD dwEncodedLength,
                                    OUT Q931_RELEASE_COMPLETE_ASN *pReleaseASN,
                                    OUT DWORD* pdwH450APDUType
                                  )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseReleaseCompleteASN entered: %p.", this ));

    memset( (PVOID)pReleaseASN, 0, sizeof(Q931_RELEASE_COMPLETE_ASN));

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Release Complete information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != releaseComplete_chosen )
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pReleaseASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pReleaseASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pReleaseASN->fNonStandardDataPresent = TRUE;
    }

    if (pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.bit_mask &
        ReleaseComplete_UUIE_reason_present)
    {
        switch( pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice )
        {
        case noBandwidth_chosen:
            pReleaseASN->bReason = H323_REJECT_NO_BANDWIDTH;
            break;
        
        case gatekeeperResources_chosen:
            pReleaseASN->bReason = H323_REJECT_GATEKEEPER_RESOURCES;
            break;
        
        case unreachableDestination_chosen:
            pReleaseASN->bReason = H323_REJECT_UNREACHABLE_DESTINATION;
            break;
        
        case destinationRejection_chosen:
            pReleaseASN->bReason = H323_REJECT_DESTINATION_REJECTION;
            break;
        
        case ReleaseCompleteReason_invalidRevision_chosen:
            pReleaseASN->bReason = H323_REJECT_INVALID_REVISION;
            break;
        
        case noPermission_chosen:
            pReleaseASN->bReason = H323_REJECT_NO_PERMISSION;
            break;
        
        case unreachableGatekeeper_chosen:
            pReleaseASN->bReason = H323_REJECT_UNREACHABLE_GATEKEEPER;
            break;
        
        case gatewayResources_chosen:
            pReleaseASN->bReason = H323_REJECT_GATEWAY_RESOURCES;
            break;
        
        case badFormatAddress_chosen:
            pReleaseASN->bReason = H323_REJECT_BAD_FORMAT_ADDRESS;
            break;
        
        case adaptiveBusy_chosen:
            pReleaseASN->bReason = H323_REJECT_ADAPTIVE_BUSY;
            break;
        
        case inConf_chosen:
            pReleaseASN->bReason = H323_REJECT_IN_CONF;
            break;
        
        case facilityCallDeflection_chosen:
            pReleaseASN->bReason = H323_REJECT_CALL_DEFLECTION;
            break;
        
        default:
            pReleaseASN->bReason = H323_REJECT_UNDEFINED_REASON;
        } // switch
    }
    else
    {
        pReleaseASN->bReason = H323_REJECT_UNDEFINED_REASON;
    }

    H323DBG(( DEBUG_LEVEL_TRACE,
        "ParseReleaseCompleteASN error:%d, q931 error:%d, exit:%p.",
        pReleaseASN->bReason,
        pUserInfo->h323_uu_pdu.h323_message_body.u.releaseComplete.reason.choice,
        this ));

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
        
    return TRUE;

cleanup:

    if( pReleaseASN->fNonStandardDataPresent )
    {
        delete pReleaseASN -> nonStandardData.sData.pOctetString;
        pReleaseASN -> nonStandardData.sData.pOctetString = NULL;
        pReleaseASN->fNonStandardDataPresent = FALSE;
    }

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
    return FALSE;
}


//------------------------------------------------------------------------
//------------------------------------------------------------------------
//!!always called in a lock
BOOL 
CH323Call::ParseConnectASN(
                            IN BYTE *pEncodedBuf,
                            IN DWORD dwEncodedLength,
                            OUT Q931_CONNECT_ASN *pConnectASN,
                            OUT DWORD* pdwH450APDUType
                          )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "ParseConnectASN entered: %p.", this ));
    
    memset( (PVOID) pConnectASN, 0, sizeof(Q931_CONNECT_ASN) );

    iResult = DecodeASN((void **) &pUserInfo ,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Connect_UUIE & connectMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.connect;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Connect information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != connect_chosen)
    {
        goto cleanup;
    }

    // make sure that the conference id is formed correctly.
    if (connectMessage.conferenceID.length >
            sizeof(connectMessage.conferenceID.value))
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pConnectASN->h245Addr.bMulticast = FALSE;

    pConnectASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pConnectASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pConnectASN->fNonStandardDataPresent = TRUE;
    }

    pConnectASN->h245AddrPresent = FALSE;
    if( connectMessage.bit_mask & Connect_UUIE_h245Address_present )
    {
        if( connectMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pConnectASN->h245Addr.nAddrType = H323_IP_BINARY;
        pConnectASN->h245Addr.Addr.IP_Binary.wPort = 
            connectMessage.h245Address.u.ipAddress.port;

        pConnectASN->h245Addr.Addr.IP_Binary.dwAddr = 
            ntohl( *((DWORD*)connectMessage.h245Address.u.ipAddress.ip.value) );

        pConnectASN->h245AddrPresent = TRUE;
    }

    // no validation of destinationInfo needed.
    pConnectASN->EndpointType.pVendorInfo = NULL;
    if( connectMessage.destinationInfo.bit_mask & (vendor_present))
    {
        if( !ParseVendorInfo( &pConnectASN->VendorInfo, 
            &connectMessage.destinationInfo.vendor) )
        {
            goto cleanup;
        }
                
        pConnectASN->EndpointType.pVendorInfo = &(pConnectASN->VendorInfo);
    }

    pConnectASN->EndpointType.bIsTerminal = FALSE;
    if (connectMessage.destinationInfo.bit_mask & (terminal_present))
    {
        pConnectASN->EndpointType.bIsTerminal = TRUE;
    }

    pConnectASN->EndpointType.bIsGateway = FALSE;
    if (connectMessage.destinationInfo.bit_mask & (gateway_present))
    {
        pConnectASN->EndpointType.bIsGateway = TRUE;
    }

    pConnectASN -> fFastStartPresent = FALSE;
    if( (connectMessage.bit_mask & Connect_UUIE_fastStart_present) &&
        connectMessage.fastStart )
    {
        pConnectASN->pFastStart = CopyFastStart( 
            (PSetup_UUIE_fastStart)connectMessage.fastStart );

        if( pConnectASN->pFastStart != NULL )
        {
            pConnectASN -> fFastStartPresent = TRUE;
        }
    }

    CopyConferenceID( &pConnectASN -> ConferenceID, 
        &connectMessage.conferenceID );

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        //the remote endpoint has sent a tunneling proposal
        m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseConnectASN exited: %p.", this ));
    return TRUE;
cleanup:

    FreeConnectASN( pConnectASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!always called in a lock
BOOL 
CH323Call::ParseAlertingASN(
                            IN BYTE *pEncodedBuf,
                            IN DWORD dwEncodedLength,
                            OUT Q931_ALERTING_ASN *pAlertingASN,
                            OUT DWORD* pdwH450APDUType 
                           )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    DWORD dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseAlertingASN entered: %p.", this ));

    memset( (PVOID) pAlertingASN, 0, sizeof(Q931_ALERTING_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Alerting_UUIE & alertingMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.alerting;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
        {
            goto cleanup;
        }
    }
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present ) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Alerting information.
    if (pUserInfo->h323_uu_pdu.h323_message_body.choice != alerting_chosen)
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.
    pAlertingASN->h245Addr.bMulticast = FALSE;

    pAlertingASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pAlertingASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pAlertingASN->fNonStandardDataPresent = TRUE;
    }

    if( alertingMessage.bit_mask & Alerting_UUIE_h245Address_present )
    {
        if( alertingMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pAlertingASN->h245Addr.nAddrType = H323_IP_BINARY;
        pAlertingASN->h245Addr.Addr.IP_Binary.wPort = 
            alertingMessage.h245Address.u.ipAddress.port;

        AddressReverseAndCopy( 
            &(pAlertingASN->h245Addr.Addr.IP_Binary.dwAddr),
            alertingMessage.h245Address.u.ipAddress.ip.value );
    }

    pAlertingASN -> fFastStartPresent = FALSE;
    if( (alertingMessage.bit_mask & Alerting_UUIE_fastStart_present) &&
        alertingMessage.fastStart )
    {
        pAlertingASN->pFastStart = CopyFastStart(
            (PSetup_UUIE_fastStart)alertingMessage.fastStart);

        if( pAlertingASN->pFastStart != NULL )
            pAlertingASN-> fFastStartPresent = TRUE;
    }

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }
    
    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseAlertingASN exited: %p.", this ));
    return TRUE;
cleanup:

    FreeAlertingASN( pAlertingASN );

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!aleways called in a lock
BOOL 
CH323Call::ParseProceedingASN(
    IN BYTE *pEncodedBuf,
    IN DWORD dwEncodedLength,
    OUT Q931_CALL_PROCEEDING_ASN *pProceedingASN,
    OUT DWORD* pdwH450APDUType 
    )
{
    H323_UserInformation *  pUserInfo;
    int                     iResult;
    DWORD                   dwInvokeID = 0;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseProceedingASN entered: %p.", this ));

    memset( (PVOID) pProceedingASN, 0, sizeof(Q931_CALL_PROCEEDING_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    CallProceeding_UUIE & proceedingMessage = 
        pUserInfo->h323_uu_pdu.h323_message_body.u.callProceeding;

    *pdwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, NULL ) )
            goto cleanup;
    }

    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        goto cleanup;
    }

    // validate that the PDU is H323 Proceeding information.
    // validate that the PDU is H323 pCall Proceeding information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != callProceeding_chosen )
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.

    pProceedingASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pProceedingASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pProceedingASN->fNonStandardDataPresent = TRUE;
    }

    //copy the H245 address information
    pProceedingASN->fH245AddrPresent = FALSE;
    if( proceedingMessage.bit_mask & CallProceeding_UUIE_h245Address_present )
    {
        if( proceedingMessage.h245Address.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pProceedingASN->h245Addr.nAddrType = H323_IP_BINARY;
        pProceedingASN->h245Addr.Addr.IP_Binary.wPort = 
            proceedingMessage.h245Address.u.ipAddress.port;

        AddressReverseAndCopy( 
            &(pProceedingASN->h245Addr.Addr.IP_Binary.dwAddr),
            proceedingMessage.h245Address.u.ipAddress.ip.value );

        pProceedingASN->h245Addr.bMulticast = FALSE;
        pProceedingASN->fH245AddrPresent = TRUE;
    }


    pProceedingASN -> fFastStartPresent = FALSE;
    if( (proceedingMessage.bit_mask & CallProceeding_UUIE_fastStart_present) &&
        proceedingMessage.fastStart )
    {
        pProceedingASN->pFastStart = CopyFastStart(
            (PSetup_UUIE_fastStart)proceedingMessage.fastStart);

        if( pProceedingASN->pFastStart != NULL )
            pProceedingASN-> fFastStartPresent = TRUE;
    }

    //ignore the destinationInfo field.

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        if( m_dwOrigin == LINECALLORIGIN_INBOUND )
        {
            //the msp has enabled tunneling in ProceedWithAnswer messsage
            m_fh245Tunneling |= LOCAL_H245_TUNNELING;
        }
        else
            //the remote endpoint has sent a tunneling proposal
            m_fh245Tunneling |= REMOTE_H245_TUNNELING;
    }

    // Free the PDU data.
    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );

    H323DBG((DEBUG_LEVEL_TRACE, "ParseProceedingASN exited: %p.", this ));
    return TRUE;

cleanup:

    FreeProceedingASN( pProceedingASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );

    return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::ParseFacilityASN(
    IN BYTE *               pEncodedBuf,
    IN DWORD                dwEncodedLength,
    OUT Q931_FACILITY_ASN * pFacilityASN
    )
{
    H323_UserInformation *pUserInfo;
    int iResult;
    
    H323DBG((DEBUG_LEVEL_TRACE, "ParseFacilityASN entered: %p.", this ));

    ZeroMemory( (PVOID) pFacilityASN, sizeof(Q931_FACILITY_ASN) );

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if( ASN1_FAILED(iResult) || (pUserInfo == NULL) )
    {
        return FALSE;
    }

    // validate that the PDU is H323 facility information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice == facility_chosen )
    {
        Facility_UUIE & facilityMessage =
            pUserInfo->h323_uu_pdu.h323_message_body.u.facility;

        // validate that the PDU user-data uses ASN encoding.
        if( (pUserInfo->bit_mask & user_data_present) &&
            (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
        {
            goto cleanup;
        }

        // make sure that the conference id is formed correctly.
        if( facilityMessage.conferenceID.length >
            sizeof(facilityMessage.conferenceID.value) )
        {
            //goto cleanup;
        }

        // parse the message contained in pUserInfo.
        pFacilityASN->fNonStandardDataPresent = FALSE;
        if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
        {
            if( !ParseNonStandardData( &pFacilityASN -> nonStandardData,
                &pUserInfo->h323_uu_pdu.nonStandardData ) )
            {
                goto cleanup;
            }

            pFacilityASN->fNonStandardDataPresent = TRUE;
        }

        pFacilityASN->fAlternativeAddressPresent = FALSE;
        if( facilityMessage.bit_mask & alternativeAddress_present )
        {
            if( facilityMessage.alternativeAddress.choice == ipAddress_chosen )
            {
                pFacilityASN->AlternativeAddr.nAddrType = H323_IP_BINARY;
                pFacilityASN->AlternativeAddr.Addr.IP_Binary.wPort = 
                    facilityMessage.alternativeAddress.u.ipAddress.port;
        
                AddressReverseAndCopy( 
                    &(pFacilityASN->AlternativeAddr.Addr.IP_Binary.dwAddr),
                    facilityMessage.alternativeAddress.u.ipAddress.ip.value );

                pFacilityASN->fAlternativeAddressPresent = TRUE;
            }
        }

        if( facilityMessage.bit_mask & alternativeAliasAddress_present )
        {
            if( !AliasAddrToAliasNames( &(pFacilityASN->pAlternativeAliasList),
                (PSetup_UUIE_sourceAddress)
                &(facilityMessage.alternativeAliasAddress) ) )
            {
                pFacilityASN -> pAlternativeAliasList = NULL;
                //goto cleanup;
            }
        }

        if( facilityMessage.bit_mask & Facility_UUIE_conferenceID_present )
        {
            CopyConferenceID( &pFacilityASN -> ConferenceID, 
                &facilityMessage.conferenceID );
            pFacilityASN -> ConferenceIDPresent = TRUE;
        }

        pFacilityASN->bReason = facilityMessage.reason.choice;
        
        pFacilityASN->fH245AddrPresent = FALSE;
        
        if( facilityMessage.bit_mask & Facility_UUIE_h245Address_present )
        {
            if( facilityMessage.h245Address.choice == ipAddress_chosen )
            {
                pFacilityASN->h245Addr.nAddrType = H323_IP_BINARY;
                pFacilityASN->h245Addr.Addr.IP_Binary.wPort = 
                     facilityMessage.h245Address.u.ipAddress.port;

                pFacilityASN->h245Addr.Addr.IP_Binary.dwAddr = 
                    ntohl( *((DWORD*)facilityMessage.h245Address.u.ipAddress.ip.value) );

                pFacilityASN->fH245AddrPresent = TRUE;
            }
        }
    }

    pFacilityASN->dwH450APDUType = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        pFacilityASN->dwInvokeID = 0;

        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            &pFacilityASN->dwH450APDUType, &pFacilityASN->dwInvokeID, NULL  ) )
        {
            goto cleanup;
        }
    }
    
    if( pUserInfo->h323_uu_pdu.bit_mask & h245Control_present )
    {
        if( pUserInfo->h323_uu_pdu.h245Control != NULL )
        {
            pFacilityASN->pH245PDU.value = 
                new BYTE[pUserInfo->h323_uu_pdu.h245Control->value.length];

            if( pFacilityASN->pH245PDU.value != NULL )
            {
                CopyMemory( (PVOID)pFacilityASN->pH245PDU.value,
                    (PVOID)pUserInfo->h323_uu_pdu.h245Control->value.value,
                    pUserInfo->h323_uu_pdu.h245Control->value.length );
            }

            pFacilityASN->pH245PDU.length =
                pUserInfo->h323_uu_pdu.h245Control->value.length;
        }
    }

    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo,
        H323_UserInformation_PDU );
        
    H323DBG((DEBUG_LEVEL_TRACE, "ParseFacilityASN exited: %p.", this ));
    return TRUE;

cleanup:

    if( pFacilityASN -> pAlternativeAliasList != NULL )
    {
        FreeAliasNames( pFacilityASN -> pAlternativeAliasList );
        pFacilityASN -> pAlternativeAliasList = NULL;
    }

    if( pFacilityASN->fNonStandardDataPresent != NULL )
    {
        delete pFacilityASN->nonStandardData.sData.pOctetString;
        pFacilityASN->nonStandardData.sData.pOctetString = NULL;
        pFacilityASN->fNonStandardDataPresent = NULL;
    }

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU );
    return FALSE;
}


//!!aleways called in a lock
BOOL
CH323Call::ParseSetupASN(
    IN BYTE *pEncodedBuf,
    IN DWORD dwEncodedLength,
    OUT Q931_SETUP_ASN *pSetupASN,
    OUT DWORD* pdwH450APDUType
    )
{
    H323_UserInformation *pUserInfo;
    HRESULT hr;
    int     iResult;
    DWORD dwInvokeID = 0;

    H323DBG((DEBUG_LEVEL_TRACE, "ParseSetupASN entered: %p.", this ));

    memset( (PVOID)pSetupASN, 0, sizeof(Q931_SETUP_ASN));

    iResult = DecodeASN((void **) &pUserInfo,
                         H323_UserInformation_PDU,
                         pEncodedBuf,
                         dwEncodedLength);

    if (ASN1_FAILED(iResult) || (pUserInfo == NULL))
    {
        return FALSE;
    }

    Setup_UUIE & setupMessage = pUserInfo->h323_uu_pdu.h323_message_body.u.setup;
    
    // validate that the PDU user-data uses ASN encoding.
    if( (pUserInfo->bit_mask & user_data_present) &&
        (pUserInfo->user_data.protocol_discriminator != USE_ASN1_ENCODING) )
    {
        //log
        goto cleanup;
    }

    // validate that the PDU is H323 Setup information.
    if( pUserInfo->h323_uu_pdu.h323_message_body.choice != setup_chosen )
    {
        //log
        goto cleanup;
    }

    // make sure that the conference id is formed correctly.
    if (setupMessage.conferenceID.length >
            sizeof(setupMessage.conferenceID.value))
    {
        goto cleanup;
    }

    // parse the message contained in pUserInfo.
    pSetupASN->sourceAddr.bMulticast = FALSE;
    pSetupASN->callerAddr.bMulticast = FALSE;
    pSetupASN->calleeDestAddr.bMulticast = FALSE;
    pSetupASN->calleeAddr.bMulticast = FALSE;

    // no validation of sourceInfo needed.

    //copy thevendor info
    pSetupASN->EndpointType.pVendorInfo = NULL;
    if( setupMessage.sourceInfo.bit_mask & vendor_present )
    {
        if( !ParseVendorInfo( &pSetupASN->VendorInfo, 
            &setupMessage.sourceInfo.vendor) )
        {
            goto cleanup;
        }
                
        pSetupASN->EndpointType.pVendorInfo = &(pSetupASN->VendorInfo);
    }

    pSetupASN->EndpointType.bIsTerminal = FALSE;
    if( setupMessage.sourceInfo.bit_mask & terminal_present )
    {
        pSetupASN->EndpointType.bIsTerminal = TRUE;
    }

    pSetupASN->EndpointType.bIsGateway = FALSE;
    if( setupMessage.sourceInfo.bit_mask & gateway_present )
    {
        pSetupASN->EndpointType.bIsGateway = TRUE;
    }

    pSetupASN->fNonStandardDataPresent = FALSE;
    if( pUserInfo->h323_uu_pdu.bit_mask & H323_UU_PDU_nonStandardData_present )
    {
        if( !ParseNonStandardData( &pSetupASN -> nonStandardData,
            &pUserInfo->h323_uu_pdu.nonStandardData ) )
        {
            goto cleanup;
        }

        pSetupASN->fNonStandardDataPresent = TRUE;
    }

    // parse the sourceAddress aliases here...
    if( setupMessage.bit_mask & sourceAddress_present )
    {
        if( !AliasAddrToAliasNames( &(pSetupASN->pCallerAliasList),
            setupMessage.sourceAddress ) )
        {
            pSetupASN->pCallerAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the destinationAddress aliases here...
    if( (setupMessage.bit_mask & destinationAddress_present) && 
        setupMessage.destinationAddress )
    {
        if( !AliasAddrToAliasNames( &(pSetupASN->pCalleeAliasList),
            (PSetup_UUIE_sourceAddress)setupMessage.destinationAddress) )
        {
            pSetupASN->pCalleeAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the destExtraCallInfo aliases here...
    if( (setupMessage.bit_mask & Setup_UUIE_destExtraCallInfo_present) &&
        setupMessage.destExtraCallInfo )
    {
        if( !AliasAddrToAliasNames(&(pSetupASN->pExtraAliasList),
            (PSetup_UUIE_sourceAddress)setupMessage.destExtraCallInfo) )
        {
            pSetupASN->pExtraAliasList = NULL;
            //goto cleanup;
        }
    }

    // parse the remoteExtensionAddress aliases here...
    if( setupMessage.bit_mask & Setup_UUIE_remoteExtensionAddress_present )
    {
        pSetupASN->pExtensionAliasItem = new H323_ALIASITEM;

        if( pSetupASN->pExtensionAliasItem == NULL )
        {
            goto cleanup;
        }

        hr = AliasAddrToAliasItem(pSetupASN->pExtensionAliasItem,
            &(setupMessage.remoteExtensionAddress));

        if( hr == E_OUTOFMEMORY )
        {
            goto cleanup;
        }
    }

    pSetupASN -> fCalleeDestAddrPresent = FALSE;
    if( setupMessage.bit_mask & Setup_UUIE_destCallSignalAddress_present )
    {
        if( setupMessage.destCallSignalAddress.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pSetupASN->calleeDestAddr.nAddrType = H323_IP_BINARY;
        pSetupASN->calleeDestAddr.Addr.IP_Binary.wPort = 
            setupMessage.destCallSignalAddress.u.ipAddress.port;
        
        AddressReverseAndCopy( 
            &(pSetupASN->calleeDestAddr.Addr.IP_Binary.dwAddr),
            setupMessage.destCallSignalAddress.u.ipAddress.ip.value );
        
        pSetupASN -> fCalleeDestAddrPresent = TRUE;
    }

    pSetupASN->fSourceAddrPresent = FALSE;
    if( setupMessage.bit_mask & sourceCallSignalAddress_present )
    {
        if( setupMessage.sourceCallSignalAddress.choice != ipAddress_chosen )
        {
            goto cleanup;
        }

        pSetupASN->sourceAddr.nAddrType = H323_IP_BINARY;
        pSetupASN->sourceAddr.Addr.IP_Binary.wPort = 
            setupMessage.sourceCallSignalAddress.u.ipAddress.port;

        pSetupASN->sourceAddr.Addr.IP_Binary.dwAddr = ntohl( *((DWORD*)
            setupMessage.sourceCallSignalAddress.u.ipAddress.ip.value) );

        pSetupASN->fSourceAddrPresent = TRUE;
    }

    pSetupASN->bCallerIsMC = setupMessage.activeMC;

    pSetupASN -> fFastStartPresent = FALSE;
    if( (setupMessage.bit_mask & Setup_UUIE_fastStart_present) &&
        setupMessage.fastStart )
    {
        pSetupASN->pFastStart = CopyFastStart( setupMessage.fastStart );

        if( pSetupASN->pFastStart != NULL )
        {
            pSetupASN -> fFastStartPresent = TRUE;
        }
    }

    CopyConferenceID (&pSetupASN -> ConferenceID, &setupMessage.conferenceID);

    //copy the call identifier
    pSetupASN -> fCallIdentifierPresent = FALSE;
    if( setupMessage.bit_mask & Setup_UUIE_callIdentifier_present )
    {
       pSetupASN -> fCallIdentifierPresent = TRUE;
       CopyMemory( (PVOID)&(pSetupASN->callIdentifier),
                   setupMessage.callIdentifier.guid.value,
                   sizeof(GUID) );
    }

    if( pUserInfo->h323_uu_pdu.h245Tunneling )
    {
        if( m_dwOrigin == LINECALLORIGIN_INBOUND )
        {
            //the remote endpoint has sent a tunneling proposal
            m_fh245Tunneling |= REMOTE_H245_TUNNELING;
        }
        else
        {
            //the msp has enabled tunneling in ReadyToInitiate messsage
            m_fh245Tunneling |= LOCAL_H245_TUNNELING;
        }
    }

    pSetupASN->wGoal = (WORD)setupMessage.conferenceGoal.choice;
    pSetupASN->wCallType = setupMessage.callType.choice;

    *pdwH450APDUType  = 0;
    if( (pUserInfo->h323_uu_pdu.bit_mask & h4501SupplementaryService_present) &&
        pUserInfo->h323_uu_pdu.h4501SupplementaryService )
    {
        if( !HandleH450APDU( pUserInfo->h323_uu_pdu.h4501SupplementaryService,
            pdwH450APDUType, &dwInvokeID, pSetupASN ) )
        {
            goto cleanup;
        }
    }

    // Free the PDU data.
    ASN1_FreeDecoded( m_ASNCoderInfo.pDecInfo, pUserInfo, 
                      H323_UserInformation_PDU );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "ParseSetupASN exited: %p.", this ));
    return TRUE;

cleanup:
    FreeSetupASN( pSetupASN );

    ASN1_FreeDecoded(m_ASNCoderInfo.pDecInfo, pUserInfo, 
        H323_UserInformation_PDU);

    return FALSE;
}


//-----------------------------------------------------------------------------
        //GLOBAL CALLBACK FUNCTIONS CALLED BY THREAD POOL
//-----------------------------------------------------------------------------

// static

void 
NTAPI CH323Call::IoCompletionCallback(
    IN  DWORD           dwStatus,
    IN  DWORD           dwBytesTransferred,
    IN  OVERLAPPED *    pOverlapped
    )
{
    CALL_OVERLAPPED *pCallOverlapped;
    CH323Call*      pCall;

    H323DBG(( DEBUG_LEVEL_TRACE, "CH323Call-IoCompletionCallback entered." ));

    _ASSERTE (pOverlapped);
    pCallOverlapped = CONTAINING_RECORD( pOverlapped, CALL_OVERLAPPED, 
        Overlapped );

    pCall = pCallOverlapped -> pCall;

    switch (pCallOverlapped -> Type)
    {
    case OVERLAPPED_TYPE_SEND:
        
        pCall -> OnWriteComplete( dwStatus,
            static_cast<CALL_SEND_CONTEXT *>(pCallOverlapped) );
        break;

    case OVERLAPPED_TYPE_RECV:

        pCallOverlapped -> BytesTransferred = dwBytesTransferred;
        pCall -> OnReadComplete( dwStatus, 
            static_cast<CALL_RECV_CONTEXT *>(pCallOverlapped) );
        break;

    default:
        _ASSERTE(FALSE);
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CH323Call-IoCompletionCallback exited." ));
}


void 
CH323Call::OnWriteComplete(
    IN DWORD dwStatus,
    IN CALL_SEND_CONTEXT * pSendContext
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnWriteComplete entered:%p.",this ));

    Lock();
    
    _ASSERTE( m_IoRefCount != 0 );            
    m_IoRefCount--;
    H323DBG((DEBUG_LEVEL_TRACE, "WriteComplete:m_IoRefCount: %d:%p.",
            m_IoRefCount, this ));
     
    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        if( m_IoRefCount == 0 )
        {
            QueueTAPICallRequest( TSPI_DELETE_CALL, NULL );
            H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", this ));
        }
    }
    else if( dwStatus == ERROR_SUCCESS )
    {
        if( IsInList( &m_sendBufList, &pSendContext->ListEntry ) )
        {
            RemoveEntryList( &pSendContext->ListEntry );
            delete pSendContext->WSABuf.buf;
            delete pSendContext;
        }
    }
    
    Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "OnWriteComplete exited:%p.",this ));
}


void
CH323Call::OnReadComplete(
    IN  DWORD dwStatus,
    IN  CALL_RECV_CONTEXT * pRecvContext )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "OnReadComplete entered:%p.",this ));

    Lock();

    _ASSERTE( m_IoRefCount != 0 );
    m_IoRefCount --;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "RecvBuffer:m_IoRefCount:%d:%p.",
        m_IoRefCount, this ));
    
    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        if( m_IoRefCount == 0 )
        {
            QueueTAPICallRequest( TSPI_DELETE_CALL, NULL );
            H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", this ));
        }
    }
    else
    {
        if( dwStatus == ERROR_SUCCESS )
        {
            _ASSERTE( m_pRecvBuffer == pRecvContext );
    
            if( pRecvContext->BytesTransferred == 0 )
            {
                CloseCall( 0 );
                H323DBG((DEBUG_LEVEL_TRACE, "0 bytes recvd:%p.", this ));
            }
            else
            {
                ReadEvent( pRecvContext->BytesTransferred );
            }
        }
    }
    
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "OnReadComplete exited:%p.",this ));
}


// static
void
NTAPI CH323Call::SetupSentTimerCallback( 
    IN PVOID Parameter1, 
    IN BOOLEAN bTimer 
    )
{
    PH323_CALL pCall = NULL;

    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 setup expired event recvd." ));

    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) Parameter1);
    if( pCall != NULL )
    {
        pCall -> SetupSentTimerExpired();
        pCall -> Unlock();
    }
}


// static
void
NTAPI CH323Call::CheckRestrictionTimerCallback( 
                                                IN PVOID Parameter1,
                                                IN BOOLEAN bTimer 
                                              )
{
    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CheckRestrictionTimerCallback entered." ));
    if(!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL) Parameter1, 
            NULL,
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }
            
    H323DBG(( DEBUG_LEVEL_TRACE, "CheckRestrictionTimerCallback exited." ));
}

// static
void
NTAPI CH323Call::CallReroutingTimerCallback( 
    IN PVOID Parameter1, 
    IN BOOLEAN bTimer 
    )
{
    //If the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReroutingTimerCallback entered." ));

    if(!QueueTAPILineRequest( 
            TSPI_CLOSE_CALL, 
            (HDRVCALL) Parameter1, 
            NULL, 
            LINEDISCONNECTMODE_NOANSWER,
            NULL) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "could not post H323 close event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReroutingTimerCallback exited." ));
}



//-----------------------------------------------------------------------------
        //CALL DIVERSION (H450.3) ENCODE/DECODE ROUTINES
//-----------------------------------------------------------------------------

BOOL
CH323Call::HandleH450APDU(
    IN PH323_UU_PDU_h4501SupplementaryService pH450APDU,
    IN DWORD* pdwH450APDUType,
    OUT DWORD* pdwInvokeID,
    IN Q931_SETUP_ASN* pSetupASN
    )
{
    BOOL retVal = TRUE;
    H4501SupplementaryService * pH450APDUStruct = NULL;
    ServiceApdus_rosApdus * pROSApdu = NULL;
    int iResult;
    BYTE pEncodedArg[H450_ENCODED_ARG_LEN];
    DWORD  dwEncodedArgLen;
    DWORD  dwOpcode;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleH450APDU entered:%p.", this ));

    //right now assuming that only one APDU is passed at a time
    iResult = DecodeH450ASN( (void **) &pH450APDUStruct,
                         H4501SupplementaryService_PDU,
                         pH450APDU->value.value,
                         pH450APDU->value.length );

    if( ASN1_FAILED(iResult) || (pH450APDUStruct == NULL) )
    {
        return FALSE;
    }

    if( pH450APDUStruct->serviceApdu.choice != rosApdus_chosen )
    {
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        return FALSE;
    }

    pROSApdu = pH450APDUStruct->serviceApdu.u.rosApdus;

    switch( pROSApdu->value.choice )
    {
    case H4503ROS_invoke_chosen:

        if( (pROSApdu->value.u.invoke.opcode.choice != local_chosen) ||
            (pROSApdu->value.u.invoke.argument.length > H450_ENCODED_ARG_LEN) )
        {
            ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
                H4501SupplementaryService_PDU );
            return FALSE;
        }

        *pdwInvokeID = pROSApdu->value.u.invoke.invokeId;
        dwEncodedArgLen = pROSApdu->value.u.invoke.argument.length;
        
        CopyMemory( (PVOID)pEncodedArg, 
            (PVOID)pROSApdu->value.u.invoke.argument.value,
            dwEncodedArgLen );
        dwOpcode = pROSApdu->value.u.invoke.opcode.u.local;

        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
                H4501SupplementaryService_PDU );

        *pdwH450APDUType = dwOpcode;
        switch( dwOpcode )
        {
        case CALLREROUTING_OPCODE:

            retVal = HandleCallRerouting( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO1_OPCODE:
            
            retVal = HandleDiversionLegInfo1( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO2_OPCODE:

            retVal = HandleDiversionLegInfo2( pEncodedArg, dwEncodedArgLen );
            break;

        case DIVERTINGLEGINFO3_OPCODE:
            
            //Don't bail out even if this function fails.
            HandleDiversionLegInfo3( pEncodedArg, dwEncodedArgLen );
            break;

        case CHECKRESTRICTION_OPCODE:

            if( pSetupASN == NULL )
            {
                retVal = FALSE;
            }
            else
            {
                retVal = HandleCheckRestriction( pEncodedArg, dwEncodedArgLen,
                    pSetupASN );
            }

            if( retVal )
            {
                retVal = SendQ931Message( *pdwInvokeID, 0, 0, 
                    CONNECTMESSAGETYPE,
                    H450_RETURNRESULT|CHECKRESTRICTION_OPCODE );
            }
            break;

        case CTIDENTIFY_OPCODE:

            retVal = HandleCTIdentify( *pdwInvokeID );            
            m_dwInvokeID = *pdwInvokeID;
            break;

        case CTINITIATE_OPCODE:

            retVal = HandleCTInitiate( pEncodedArg, dwEncodedArgLen );
            m_dwInvokeID = *pdwInvokeID;
            break;

        case CTSETUP_OPCODE:

            retVal = HandleCTSetup( pEncodedArg, dwEncodedArgLen );
            m_dwInvokeID = *pdwInvokeID;
            break;

        case HOLDNOTIFIC_OPCODE:

            //local hold request from the remote endpoint
            if( m_dwCallState != LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
                ChangeCallState( LINECALLSTATE_ONHOLD, 0 );
            }
            break;

        case RETRIEVENOTIFIC_OPCODE:

            //local retrieve request from the remote endpoint
            if( (m_dwCallState == LINECALLSTATE_ONHOLD) &&
                !(m_dwFlags & TSPI_CALL_LOCAL_HOLD) )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
                ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
            }
            break;

        case REMOTEHOLD_OPCODE:

            //remote hold request from remote endpoint
            if( m_dwCallState != LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 1, NULL );
                ChangeCallState( LINECALLSTATE_ONHOLD, 0 );

                retVal = SendQ931Message( *pdwInvokeID, 0, 0,
                    FACILITYMESSAGETYPE,
                    REMOTEHOLD_OPCODE| H450_RETURNRESULT );
            }
            break;

        case REMOTERETRIEVE_OPCODE:

            //remote retrieve request from remote endpoint
            if( m_dwCallState == LINECALLSTATE_ONHOLD )
            {
                SendMSPMessage( SP_MSG_Hold, 0, 0, NULL );
                ChangeCallState( LINECALLSTATE_CONNECTED, 0 );
    
                retVal = SendQ931Message( *pdwInvokeID, 0, 0, 
                    FACILITYMESSAGETYPE,
                    REMOTERETRIEVE_OPCODE| H450_RETURNRESULT );
            }
            break;

        default:
            _ASSERTE( 0 );
            return FALSE;
        }

        break;
    
    case H4503ROS_returnResult_chosen:
        
        *pdwH450APDUType = H4503_DUMMYTYPERETURNRESULT_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnResult.invokeId;
        retVal = HandleReturnResultDummyType( pH450APDUStruct );

        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        break;

    case H4503ROS_returnError_chosen:
        
        *pdwH450APDUType = H4503_RETURNERROR_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnError.invokeId;
        retVal = HandleReturnError( pH450APDUStruct );
        
        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );

        break;

    case reject_chosen:
        
        *pdwH450APDUType = H4503_REJECT_APDU;
        *pdwInvokeID = 
            pH450APDUStruct->serviceApdu.u.rosApdus->value.u.reject.invokeId;
        retVal = HandleReject( pH450APDUStruct );
        
        // Free the PDU data.
        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );
        break;

    default:
        _ASSERTE( 0 );

        ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pH450APDUStruct,
            H4501SupplementaryService_PDU );
        return FALSE;
        break;
    }

    if( retVal == FALSE )
    {
        SendQ931Message( *pdwInvokeID,
                         0,
                         0,
                         RELEASECOMPLMESSAGETYPE,
                         H450_REJECT );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleH450APDU exited:%p.", this ));

    return retVal;
}


BOOL 
CH323Call::HandleReturnError(
                             IN H4501SupplementaryService * pH450APDUStruct
                            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnError entered:%p.", this ));

    ReturnError * pReturnError = 
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnError);

    if( IsValidInvokeID( pReturnError->invokeId ) == FALSE )
    {
        //ignore APDU
        return TRUE;
    }

    CloseCall( 0 );
        
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnError exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleReject( 
                        IN H4501SupplementaryService * pH450APDUStruct 
                       )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReject entered:%p.", this ));

    Reject * pReject = 
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.reject);
    
    if( IsValidInvokeID( pReject->invokeId ) == FALSE )
    {
        //ignore the APDU
        return TRUE;
    }
    
    CloseCall( 0 );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReject exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleReturnResultDummyType( 
    IN H4501SupplementaryService * pH450APDUStruct
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnResultDummyType entered:%p.",
        this ));

    ReturnResult* dummyResult =
        &(pH450APDUStruct->serviceApdu.u.rosApdus->value.u.returnResult);

    if( dummyResult->bit_mask & result_present )
    {
        if( dummyResult->result.opcode.choice != local_chosen )
        {
            return FALSE;
        }

        switch( dummyResult->result.opcode.u.local )
        {
        case CHECKRESTRICTION_OPCODE:
        
            //forwarding has been enabled. inform the user
            if( !EnableCallForwarding() )
            {
                return FALSE;
            }

            //close the call
            CloseCall( 0 );

            break;

        case CALLREROUTING_OPCODE:

            //call has been rerouted. log the info or inform the user
            m_dwCallDiversionState = H4503_CALLREROUTING_RRSUCC;
            _ASSERTE( m_hCallReroutingTimer );
            if( m_hCallReroutingTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, 
                    m_hCallReroutingTimer, NULL );
                
                m_hCallReroutingTimer = NULL;
            }

            break;

        case CTIDENTIFY_OPCODE:

            //call tranfer has been accepted by transfered-to endpoint
            m_dwCallDiversionState = H4502_CIIDENTIFY_RRSUCC;
        
            _ASSERTE( m_hCTIdentifyTimer );
            if( m_hCTIdentifyTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyTimer, NULL );
                m_hCTIdentifyTimer = NULL;
            }

            return HandleCTIdentifyReturnResult( dummyResult->result.result.value,
                dummyResult->result.result.length );

            break;

        case CTINITIATE_OPCODE:

            _ASSERTE( m_hCTInitiateTimer );
            if( m_hCTInitiateTimer != NULL )
            {
                DeleteTimerQueueTimer( H323TimerQueue, m_hCTInitiateTimer, NULL );
                m_hCTInitiateTimer = NULL;
            }
            break;

        case CTSETUP_OPCODE:
        case REMOTEHOLD_OPCODE:
        case REMOTERETRIEVE_OPCODE:
            //no processing required
            break;

        default:
            
            H323DBG(( DEBUG_LEVEL_ERROR, "wrong opcode.",
                dummyResult->result.opcode.u.local ));
            break;
        }
    }
    else if( IsValidInvokeID( dummyResult->invokeId ) == FALSE )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleReturnResultDummyType exited:%p.",
        this ));

    return TRUE;
}


BOOL
CH323Call::EnableCallForwarding()
{
    m_dwCallDiversionState = H4503_CHECKRESTRICTION_SUCC;

    if( m_pCallForwardParams != NULL )
    {
        g_pH323Line->SetCallForwardParams( m_pCallForwardParams );
        m_pCallForwardParams = NULL;
    }
    else if( m_pForwardAddress != NULL )
    {
        if( !g_pH323Line->SetCallForwardParams( m_pForwardAddress ) )
        {
            return FALSE;
        }

        m_pForwardAddress = NULL;
    }

    //_ASSERTE( m_hCheckRestrictionTimer );

    //stop the timer
    if( m_hCheckRestrictionTimer )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCheckRestrictionTimer, 
            NULL );
        m_hCheckRestrictionTimer = NULL;
    }

    //inform the user about change in line forward state
    (*g_pfnLineEventProc)(
        g_pH323Line->m_htLine,
        (HTAPICALL)NULL,
        (DWORD)LINE_ADDRESSSTATE,
        (DWORD)LINEADDRESSSTATE_FORWARD,
        (DWORD)LINEADDRESSSTATE_FORWARD,
        (DWORD)0
        );

    return TRUE;
}


BOOL
CH323Call::HandleCTIdentifyReturnResult(
                                 IN BYTE * pEncodeArg,
                                 IN DWORD dwEncodedArgLen
                                 )
{
    PH323_CALL  pCall = NULL;
    CTIdentifyRes * pCTIdentifyRes;
    int iResult;

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentifyReturnResult entered:%p.", this ));

    if( (pEncodeArg == NULL) || (dwEncodedArgLen==0) )
    {
        return FALSE;
    }

    iResult = DecodeH450ASN( (void **) &pCTIdentifyRes,
        CTIdentifyRes_PDU, pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCTIdentifyRes == NULL) )
    {
        return FALSE;
    }

    //send a CTInitiate message on the primary call
    if( !QueueSuppServiceWorkItem( SEND_CTINITIATE_MESSAGE, m_hdRelatedCall,
        (ULONG_PTR)pCTIdentifyRes ))
    {
        //close the consultation call.
        CloseCall( 0 );
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentifyReturnResult exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::HandleCTIdentify( 
                            IN DWORD dwInvokeID 
                           )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentify entered:%p.", this ));
    
    BOOL retVal = TRUE;

    //send the return result for CTIdentify
    retVal = SendQ931Message( dwInvokeID, 0, 0, FACILITYMESSAGETYPE, 
            H450_RETURNRESULT|CTIDENTIFY_OPCODE );
    
    m_dwCallType |= CALLTYPE_TRANSFERED2_CONSULT;
        
    //start the timer for CTIdenity message
    if( retVal )
    {
        retVal = CreateTimerQueueTimer(
            &m_hCTIdentifyRRTimer,
            H323TimerQueue,
            CH323Call::CTIdentifyRRExpiredCallback,
            (PVOID)m_hdCall,
            CTIDENTIFYRR_SENT_TIMEOUT, 0,
            WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE );
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTIdentify exited:%p.", this ));
    return retVal;
}


BOOL
CH323Call::HandleCTInitiate(
                             IN BYTE * pEncodeArg,
                             IN DWORD dwEncodedArgLen
                           )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTInitiate entered:%p.", this ));

    CTInitiateArg * pCTInitiateArg;
    
    int iResult = DecodeH450ASN( (void **) &pCTInitiateArg,
                         CTInitiateArg_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCTInitiateArg == NULL) )
    {
        return FALSE;
    }

    //argument.callIdentity
    CopyMemory( (PVOID)m_pCTCallIdentity, pCTInitiateArg->callIdentity,
        sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    if( !AliasAddrToAliasNames( &m_pTransferedToAlias,
        (PSetup_UUIE_sourceAddress)
        pCTInitiateArg->reroutingNumber.destinationAddress ) )
    {
        goto cleanup;
    }

    m_dwCallType |= CALLTYPE_TRANSFERED_PRIMARY;
    m_dwCallDiversionState = H4502_CTINITIATE_RECV;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTInitiateArg,
        CTInitiateArg_PDU );

    //queue an event for creating a new call
    if( !QueueSuppServiceWorkItem( TSPI_DIAL_TRNASFEREDCALL, m_hdCall,
        (ULONG_PTR)m_pTransferedToAlias ))
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "could not post dial transfer event." ));
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTInitiate exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTInitiateArg,
        CTInitiateArg_PDU );

    return FALSE;
}


//!!always called in a lock
BOOL
CH323Call::HandleCTSetup(
    IN BYTE * pEncodeArg,
	IN DWORD dwEncodedArgLen
	)
{
	PH323_CALL	pCall = NULL;
	WORD		wRelatedCallRef = 0;
	int 		iCTCallID;

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTSetup entered:%p.", this ));

	CTSetupArg * pCTSetupArg;
	
	int iResult = DecodeH450ASN( (void **) &pCTSetupArg,
		CTSetupArg_PDU, pEncodeArg, dwEncodedArgLen );

	if( ASN1_FAILED(iResult) || (pCTSetupArg == NULL) )
	{
		return FALSE;
	}

	m_dwCallType |= CALLTYPE_TRANSFEREDDEST;
	m_dwCallDiversionState = H4502_CTSETUP_RECV;

	iCTCallID = atoi( pCTSetupArg->callIdentity );

	if( iCTCallID != 0 )
	{
		m_hdRelatedCall = g_pH323Line -> GetCallFromCTCallIdentity( iCTCallID );

		if( m_hdRelatedCall )
		{
			if( !QueueSuppServiceWorkItem( STOP_CTIDENTIFYRR_TIMER, 
				m_hdRelatedCall, (ULONG_PTR)m_hdCall ))
			{
				m_hdRelatedCall = NULL;
			}
		}
	}
	
	ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCTSetupArg,
		CTSetupArg_PDU );

	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCTSEtup exited:%p.", this ));
	return TRUE;
}


BOOL
CH323Call::HandleCheckRestriction(
								 IN BYTE * pEncodeArg,
								 IN DWORD dwEncodedArgLen,
								 IN Q931_SETUP_ASN* pSetupASN
								 )
{
	H323DBG(( DEBUG_LEVEL_TRACE, "HandleCheckRestriction entered:%p.", this ));

	CheckRestrictionArgument * pCheckRestriction;
	
	int iResult = DecodeH450ASN( (void **) &pCheckRestriction,
						 CheckRestrictionArgument_PDU,
						 pEncodeArg, dwEncodedArgLen );

	if( ASN1_FAILED(iResult) || (pCheckRestriction == NULL) )
	{
		return FALSE;
	}

	if( pSetupASN->pCalleeAliasList != NULL )
	{
		FreeAliasNames( pSetupASN->pCalleeAliasList );
		pSetupASN->pCalleeAliasList = NULL;
	}

	if( !AliasAddrToAliasNames( &(pSetupASN->pCalleeAliasList),
		(PSetup_UUIE_sourceAddress)pCheckRestriction->divertedToNr.destinationAddress ) )
	{
		pSetupASN->pCalleeAliasList = NULL;
		goto cleanup;
	}

	if( pSetupASN->pCallerAliasList != NULL )
	{
		FreeAliasNames( pSetupASN->pCallerAliasList );
		pSetupASN->pCallerAliasList = NULL;
	}

	if( !AliasAddrToAliasNames( &(pSetupASN->pCallerAliasList),
		(PSetup_UUIE_sourceAddress)
		pCheckRestriction->servedUserNr.destinationAddress ) )
	{
		pSetupASN->pCallerAliasList = NULL;
		goto cleanup;
	}

	m_dwCallType |= CALLTYPE_FORWARDCONSULT;

	if( !InitializeIncomingCall( pSetupASN, CALLTYPE_FORWARDCONSULT, 0 ) )
	{
		goto cleanup;
	}

	FreeSetupASN( pSetupASN );
	m_dwStateMachine = Q931_SETUP_RECVD;
	m_dwCallDiversionState = H4503_CHECKRESTRICTION_RECV;

	ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCheckRestriction,
        CheckRestrictionArgument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCheckRestriction exited:%p.", this ));
        return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCheckRestriction,
        CheckRestrictionArgument_PDU );

    return FALSE;
}


BOOL
CH323Call::HandleDiversionLegInfo1(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo1 entered:%p.", this ));

    DivertingLegInformation1Argument * plegInfo1Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo1Invoke,
                         DivertingLegInformation1Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo1Invoke == NULL) )
    {
        return FALSE;
    }

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;

        if( m_pCallReroutingInfo == NULL )
        {
            return FALSE;
        }

        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }
    
    m_pCallReroutingInfo->diversionReason = plegInfo1Invoke->diversionReason;

    m_pCallReroutingInfo->fPresentAllow = plegInfo1Invoke->subscriptionOption;
    
    //argument.divertedToNr
    if( m_pCallReroutingInfo->divertedToNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        m_pCallReroutingInfo->divertedToNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertedToNrAlias),
        (PSetup_UUIE_sourceAddress)
        (plegInfo1Invoke->nominatedNr.destinationAddress) ) )
    {
        goto cleanup;
    }

    m_dwCallType |= CALLTYPE_DIVERTEDSRC_NOROUTING;
    m_dwCallDiversionState = H4503_DIVERSIONLEG1_RECVD;
        
    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo1Invoke,
        DivertingLegInformation1Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo1 exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo1Invoke,
        DivertingLegInformation1Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
}


BOOL
CH323Call::HandleDiversionLegInfo2(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo2 entered:%p.", this ));

    DivertingLegInformation2Argument * plegInfo2Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo2Invoke,
                         DivertingLegInformation2Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo2Invoke == NULL) )
    {
        return FALSE;
    }

    _ASSERTE(!m_pCallReroutingInfo);

    m_pCallReroutingInfo = new CALLREROUTINGINFO;
    if( m_pCallReroutingInfo == NULL )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "memory failure." ));
        goto cleanup;
    }
    ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    
    //argument.diversionCounter
    m_pCallReroutingInfo->diversionCounter = 
        plegInfo2Invoke->diversionCounter;
    
    //argument.diversionReason
    m_pCallReroutingInfo->diversionReason = plegInfo2Invoke->diversionReason;

    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias );
            m_pCallReroutingInfo->divertingNrAlias = NULL;
    }

    if( (plegInfo2Invoke->bit_mask & divertingNr_present ) &&
        plegInfo2Invoke->divertingNr.destinationAddress )
    {
        //argument.divertingNr
        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertingNrAlias),
            (PSetup_UUIE_sourceAddress)
            (plegInfo2Invoke->divertingNr.destinationAddress) ) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "no divertingnr alias." ));
            //goto cleanup;
        }
    }

    //argument.originalCalledNr
    if( (plegInfo2Invoke->bit_mask & 
        DivertingLegInformation2Argument_originalCalledNr_present ) &&
        plegInfo2Invoke->originalCalledNr.destinationAddress )
    {
        if( m_pCallReroutingInfo->originalCalledNr != NULL )
        {
            FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
            m_pCallReroutingInfo->originalCalledNr = NULL;
        }

        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->originalCalledNr),
            (PSetup_UUIE_sourceAddress)
            (plegInfo2Invoke->originalCalledNr.destinationAddress)) )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "no originalcalled alias." ));
            //goto cleanup;
        }
    }

    m_dwCallType |= CALLTYPE_DIVERTEDDEST;
    m_dwCallDiversionState = H4503_DIVERSIONLEG2_RECVD;
        
    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo2Invoke,
        DivertingLegInformation2Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo2 exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo2Invoke,
        DivertingLegInformation2Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;

}


void 
CH323Call::FreeCallReroutingInfo(void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeCallReroutingInfo entered:%p.", this ));
    
    if( m_pCallReroutingInfo != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias ); 
        FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        FreeAliasNames( m_pCallReroutingInfo->diversionNrAlias );

        delete m_pCallReroutingInfo;
        m_pCallReroutingInfo = NULL;
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeCallReroutingInfo exited:%p.", this ));
}
                                

BOOL
CH323Call::HandleDiversionLegInfo3(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo3 entered:%p.", this ));

    DivertingLegInformation3Argument * plegInfo3Invoke;
    
    int iResult = DecodeH450ASN( (void **) &plegInfo3Invoke,
                         DivertingLegInformation3Argument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (plegInfo3Invoke == NULL) )
    {
        return FALSE;
    }

    _ASSERTE(m_pCallReroutingInfo);

    m_pCallReroutingInfo-> fPresentAllow = 
        plegInfo3Invoke->presentationAllowedIndicator;

    if( m_pCallReroutingInfo->diversionNrAlias )
    {
        FreeAliasNames( m_pCallReroutingInfo->diversionNrAlias );
        m_pCallReroutingInfo->diversionNrAlias = NULL;
    }

    //argument.redirectionNr
    if( (plegInfo3Invoke->bit_mask & redirectionNr_present ) &&
        plegInfo3Invoke->redirectionNr.destinationAddress )
    {
        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->diversionNrAlias),
            (PSetup_UUIE_sourceAddress)
            (plegInfo3Invoke->redirectionNr.destinationAddress) ) )
        {
            //goto cleanup;
        }
    }

    _ASSERTE( (m_dwCallType & CALLTYPE_DIVERTEDSRC ) ||
              (m_dwCallType & CALLTYPE_DIVERTEDSRC_NOROUTING ) );
    m_dwCallDiversionState = H4503_DIVERSIONLEG3_RECVD;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo3Invoke,
        DivertingLegInformation3Argument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleDiversionLegInfo3 exited:%p.", this ));
    return TRUE;

/*cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, plegInfo3Invoke,
        DivertingLegInformation3Argument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
*/
}


BOOL
CH323Call::HandleCallRerouting(
                                IN BYTE * pEncodeArg,
                                IN DWORD dwEncodedArgLen
                              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallRerouting entered:%p.", this ));

    CallReroutingArgument* pCallReroutingInv;
    
    int iResult = DecodeH450ASN( (void **) &pCallReroutingInv,
                         CallReroutingArgument_PDU,
                         pEncodeArg, dwEncodedArgLen );

    if( ASN1_FAILED(iResult) || (pCallReroutingInv == NULL) )
    {
        return FALSE;
    }

    if( m_pCallReroutingInfo == NULL )
    {
        m_pCallReroutingInfo = new CALLREROUTINGINFO;
        if( m_pCallReroutingInfo == NULL )
        {
            goto cleanup;
        }
        ZeroMemory( (PVOID)m_pCallReroutingInfo, sizeof(CALLREROUTINGINFO) );
    }

    if( pCallReroutingInv->diversionCounter > MAX_DIVERSION_COUNTER )
        return FALSE;

    m_pCallReroutingInfo->diversionCounter = 
        pCallReroutingInv->diversionCounter;

    m_pCallReroutingInfo->diversionReason = pCallReroutingInv->reroutingReason;

    if( pCallReroutingInv->bit_mask & originalReroutingReason_present )
    {
        m_pCallReroutingInfo->originalDiversionReason = 
            pCallReroutingInv->originalReroutingReason;
    }
    else
    {
        m_pCallReroutingInfo->originalDiversionReason =
            pCallReroutingInv->reroutingReason;
    }

    if( ( pCallReroutingInv->bit_mask &
        CallReroutingArgument_originalCalledNr_present ) &&
        pCallReroutingInv->originalCalledNr.destinationAddress )
    {
            
        if( m_pCallReroutingInfo->originalCalledNr != NULL )
        {
            FreeAliasNames( m_pCallReroutingInfo->originalCalledNr );
            m_pCallReroutingInfo->originalCalledNr = NULL;
        }

        if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->originalCalledNr),
            (PSetup_UUIE_sourceAddress)
            (pCallReroutingInv->originalCalledNr.destinationAddress) ) )
        {
            //goto cleanup;
        }
    }
    
    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertingNrAlias );
        m_pCallReroutingInfo->divertingNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertingNrAlias),
        (PSetup_UUIE_sourceAddress)
        (pCallReroutingInv->lastReroutingNr.destinationAddress) ) )
    {
        goto cleanup;
    }
 
    if( m_pCallReroutingInfo->divertedToNrAlias != NULL )
    {
        FreeAliasNames( m_pCallReroutingInfo->divertedToNrAlias );
        m_pCallReroutingInfo->divertedToNrAlias = NULL;
    }

    if( !AliasAddrToAliasNames( &(m_pCallReroutingInfo->divertedToNrAlias),
        (PSetup_UUIE_sourceAddress)
        (pCallReroutingInv->calledAddress.destinationAddress) ) )
    {
        goto cleanup;
    }
 
    m_dwCallType |= CALLTYPE_DIVERTEDSRC;
    m_dwCallDiversionState = H4503_CALLREROUTING_RECVD;

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCallReroutingInv,
                CallReroutingArgument_PDU );

    H323DBG(( DEBUG_LEVEL_TRACE, "HandleCallRerouting exited:%p.", this ));
    return TRUE;

cleanup:

    ASN1_FreeDecoded( m_H450ASNCoderInfo.pDecInfo, pCallReroutingInv,
                CallReroutingArgument_PDU );

    FreeCallReroutingInfo();
    return FALSE;
}


BOOL
CH323Call::EncodeRejectAPDU( 
                 IN H4501SupplementaryService * pSupplementaryServiceAPDU,
                 IN DWORD dwInvokeID,
                 OUT BYTE**  ppEncodedAPDU,
                 OUT DWORD* pdwAPDULen
                )
{
    WORD wAPDULen;
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeRejectAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU->value.choice = reject_chosen;
    pROSAPDU->value.u.reject.invokeId = (WORD)dwInvokeID;
    pROSAPDU->value.u.reject.problem.choice = H4503ROS_invoke_chosen;
    pROSAPDU->value.u.reject.problem.u.invoke = InvokeProblem_mistypedArgument;
    
    //call ASN.1 encoding functions
    int rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wAPDULen );
    
    *pdwAPDULen = wAPDULen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeRejectAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeReturnErrorAPDU(
                      IN DWORD dwInvokeID,
                      IN DWORD dwErrorCode,
                      IN H4501SupplementaryService *pH450APDU,
                      OUT BYTE**  ppEncodedAPDU,
                      OUT DWORD* pdwAPDULen
                     )
{
    WORD wAPDULen;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeReturnErrorAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = pH450APDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU ->value.choice = H4503ROS_returnError_chosen;
    pROSAPDU ->value.u.returnError.invokeId = (WORD)dwInvokeID;

    pROSAPDU ->value.u.returnError.errcode.choice = local_chosen;
    pROSAPDU ->value.u.returnError.errcode.u.local = dwErrorCode;
    
    //call ASN.1 encoding functions
    int rc = EncodeH450ASN( (void *) pH450APDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wAPDULen );
    
    *pdwAPDULen = wAPDULen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeReturnErrorAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeDummyReturnResultAPDU(
    IN DWORD dwInvokeID,
    IN DWORD dwOpCode,
    IN H4501SupplementaryService *pH450APDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    WORD    wEncodedLen = 0;
    int     rc;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyReturnResultAPDU entered:%p.",
        this ));

    ServiceApdus_rosApdus *pROSAPDU = pH450APDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU ->value.choice = H4503ROS_returnResult_chosen;
    
    pROSAPDU ->value.u.returnResult.invokeId = (WORD)dwInvokeID;
    pROSAPDU ->value.u.returnResult.bit_mask = result_present;

    pROSAPDU ->value.u.returnResult.result.opcode.choice = local_chosen;
    pROSAPDU ->value.u.returnResult.result.opcode.u.local = dwOpCode;

    //dummy result not present
    pROSAPDU ->value.u.returnResult.result.result.length = 0;
    pROSAPDU ->value.u.returnResult.result.result.value = NULL;
    
    switch( dwOpCode )
    {
    case CTIDENTIFY_OPCODE:

        pROSAPDU ->value.u.returnResult.result.result.value = pBufEncodedArg;
        
        if( !EncodeCTIdentifyReturnResult( pROSAPDU ) )
        {
            return FALSE;
        }
        
        break;

    default:

        pROSAPDU ->value.u.returnResult.result.result.value = pBufEncodedArg;
        
        if( !EncodeDummyResult( pROSAPDU ) )
        {
            return FALSE;
        }

        break;
    }

    //call ASN.1 encoding functions
    rc = EncodeH450ASN( (void *) pH450APDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyReturnResultAPDU exited:%p.",
        this ));
    return TRUE;
}


BOOL
CH323Call::EncodeDummyResult(
    OUT ServiceApdus_rosApdus *pROSAPDU
    )
{
    DummyRes    dummyRes;
    BYTE        *pEncodedArg = NULL;
    WORD        wEncodedLen = 0;
    int         rc;
    UCHAR       sData[3] = "MS";

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyResult entered:%p.", this ));

    ZeroMemory( (PVOID)&dummyRes, sizeof(DummyRes) );
    
    dummyRes.choice = DummyRes_nonStandardData_chosen;
    dummyRes.u.nonStandardData.nonStandardIdentifier.choice
        = H225NonStandardIdentifier_h221NonStandard_chosen;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode
        = H221_COUNTRY_CODE_USA;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension
        = H221_COUNTRY_EXT_USA;
    dummyRes.u.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode
        = H221_MFG_CODE_MICROSOFT;
        
    dummyRes.u.nonStandardData.data.length = 2;
    dummyRes.u.nonStandardData.data.value = sData;
        
    //encode the return result argument.
    rc = EncodeH450ASN( (void*) &dummyRes,
            DummyRes_PDU,
            &pEncodedArg,
            &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        return FALSE;
    }

    pROSAPDU ->value.u.returnResult.result.result.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU ->value.u.returnResult.result.result.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDummyResult exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCTIdentifyReturnResult(
    OUT ServiceApdus_rosApdus *pROSAPDU
    )
{
    CTIdentifyRes cTIdentifyRes;
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    int     iCallID;
    int     rc;

    ZeroMemory( (PVOID)&cTIdentifyRes, sizeof(CTIdentifyRes) );
    
    iCallID = g_pH323Line -> GetCTCallIdentity(m_hdCall );

    if( iCallID == 0 )
    {
        return FALSE;
    }

    //argument.callIdentity
    _itoa( iCallID, (char*)m_pCTCallIdentity, 10 );

    CopyMemory( (PVOID)cTIdentifyRes.callIdentity, (PVOID)m_pCTCallIdentity,
        sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    cTIdentifyRes.reroutingNumber.bit_mask = 0;

    cTIdentifyRes.reroutingNumber.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );
    
    if( cTIdentifyRes.reroutingNumber.destinationAddress == NULL )
    {
        return FALSE;
    }

    //encode the return result argument.
    rc = EncodeH450ASN( (void *) &cTIdentifyRes,
                CTIdentifyRes_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            cTIdentifyRes.reroutingNumber.destinationAddress );
        return FALSE;
    }

    pROSAPDU ->value.u.returnResult.result.result.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU ->value.u.returnResult.result.result.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)
        cTIdentifyRes.reroutingNumber.destinationAddress );

    return TRUE;
}


//supplemantary services functions
BOOL
CH323Call::EncodeCheckRestrictionAPDU( 
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
   )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;
    TCHAR   szMsg[20];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCheckRestrictionAPDU entered:%p.",
        this ));

    ServiceApdus_rosApdus *pROSAPDU =
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CHECKRESTRICTION_OPCODE;

    //argument
    CheckRestrictionArgument checkRestrictionArgument;
    ZeroMemory( (PVOID)&checkRestrictionArgument, 
        sizeof(CheckRestrictionArgument) );
    
    //argument.divertedToNR
    checkRestrictionArgument.divertedToNr.bit_mask = 0;
    checkRestrictionArgument.divertedToNr.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );
    if( checkRestrictionArgument.divertedToNr.destinationAddress == NULL )
    {
        goto cleanup;
    }


    if( m_pCallerAliasNames == NULL )
    {
        m_pCallerAliasNames = new H323_ALIASNAMES;

        if( m_pCallerAliasNames == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
            goto cleanup;
        }
        memset( (PVOID)m_pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );

        LoadString( g_hInstance,
            IDS_UNKNOWN,
            szMsg,
            20
          );

        if( !AddAliasItem( m_pCallerAliasNames,
                szMsg,
                h323_ID_chosen ) )
        {
                goto cleanup;
        }
        
        //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));
    }

    //argument.servedUserNR
    checkRestrictionArgument.servedUserNr.bit_mask = 0;
    
    checkRestrictionArgument.servedUserNr.destinationAddress = 
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCallerAliasNames );

    //H323DBG(( DEBUG_LEVEL_ERROR, "Caller alias count:%d : %p", m_pCallerAliasNames->wCount, this ));

    if( checkRestrictionArgument.servedUserNr.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argument.basicservice
    checkRestrictionArgument.basicService = allServices;

    //encode the checkrestriction argument.
    rc = EncodeH450ASN( (void *) &checkRestrictionArgument,
                CheckRestrictionArgument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding functions
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCheckRestrictionAPDU exited:%p.", 
        this ));
    retVal = TRUE;

cleanup:
    
    if( checkRestrictionArgument.servedUserNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            checkRestrictionArgument.servedUserNr.destinationAddress );
    }

    if( checkRestrictionArgument.divertedToNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            checkRestrictionArgument.divertedToNr.destinationAddress );
    }

    return retVal;
}


BOOL
CH323Call::EncodeDivertingLeg2APDU(
                    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
                    OUT BYTE**  ppEncodedAPDU,
                    OUT DWORD* pdwAPDULen
                    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg2APDU entered:%p.", this ));

    pSupplementaryServiceAPDU->interpretationApdu.choice =
        discardAnyUnrecognizedInvokePdu_chosen;
    
    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = DIVERTINGLEGINFO2_OPCODE;

    //argument
    DivertingLegInformation2Argument divertLegInfo2Arg;

    ZeroMemory( (PVOID)&divertLegInfo2Arg, 
        sizeof(DivertingLegInformation2Argument) );

    //argument.diversionCounter
    divertLegInfo2Arg.diversionCounter
        = (WORD)m_pCallReroutingInfo->diversionCounter;
    
    //argument.diversionreason
    divertLegInfo2Arg.diversionReason = m_pCallReroutingInfo->diversionReason;

    //argument.originalDiversionReason
    if( m_pCallReroutingInfo->originalDiversionReason != 0 )
    {
        divertLegInfo2Arg.originalDiversionReason = 
            m_pCallReroutingInfo->originalDiversionReason;

        divertLegInfo2Arg.bit_mask |= originalDiversionReason_present;
    }

    //argument.divertingNr
    if( m_pCallReroutingInfo->divertingNrAlias != NULL )
    {
        divertLegInfo2Arg.bit_mask |= divertingNr_present;

        divertLegInfo2Arg.divertingNr.bit_mask = 0;
        divertLegInfo2Arg.divertingNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->divertingNrAlias );

        if( divertLegInfo2Arg.divertingNr.destinationAddress == NULL )
        {
            return FALSE;
        }
    }

    //argument.originalCalledNr
    if( m_pCallReroutingInfo->originalCalledNr != NULL )
    {
        divertLegInfo2Arg.bit_mask |=
            DivertingLegInformation2Argument_originalCalledNr_present;

        divertLegInfo2Arg.originalCalledNr.bit_mask = 0;
        divertLegInfo2Arg.originalCalledNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->originalCalledNr );

        if( divertLegInfo2Arg.originalCalledNr.destinationAddress == NULL )
        {
            goto cleanup;
        }
    }

    //encode the divertingleg2 argument.
    rc = EncodeH450ASN( (void *) &divertLegInfo2Arg,
                DivertingLegInformation2Argument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg2APDU exited:%p.", this ));
    retVal= TRUE;

cleanup:
    
    if( divertLegInfo2Arg.divertingNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo2Arg.divertingNr.destinationAddress );
    }
        
    if( divertLegInfo2Arg.originalCalledNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo2Arg.originalCalledNr.destinationAddress );
    }

    return retVal;
}


BOOL
CH323Call::EncodeDivertingLeg3APDU(
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg3APDU entered:%p.", this ));

    pSupplementaryServiceAPDU->interpretationApdu.choice =
        discardAnyUnrecognizedInvokePdu_chosen;
    
    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = DIVERTINGLEGINFO3_OPCODE;

    //argument
    DivertingLegInformation3Argument divertLegInfo3Arg;
    ZeroMemory( (PVOID)&divertLegInfo3Arg, 
        sizeof(DivertingLegInformation3Argument) );

    //argument.presentationallowed
    divertLegInfo3Arg.presentationAllowedIndicator = TRUE;

    //argument.redirectionNr
    divertLegInfo3Arg.redirectionNr.bit_mask = 0;

    divertLegInfo3Arg.redirectionNr.destinationAddress =
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pCalleeAliasNames );

    if( divertLegInfo3Arg.redirectionNr.destinationAddress )
    {
        divertLegInfo3Arg.bit_mask |=  redirectionNr_present;
    }

    //encode the divertingleg3 argument.
    int rc = EncodeH450ASN( (void *) &divertLegInfo3Arg,
                DivertingLegInformation3Argument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        if( divertLegInfo3Arg.redirectionNr.destinationAddress )
        {
            FreeAddressAliases( (PSetup_UUIE_destinationAddress)
                divertLegInfo3Arg.redirectionNr.destinationAddress );
        }
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    if( divertLegInfo3Arg.redirectionNr.destinationAddress )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            divertLegInfo3Arg.redirectionNr.destinationAddress );
    }
        
    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeDivertingLeg3APDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCallReroutingAPDU(
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD* pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    BOOL    retVal = FALSE;
    int     rc = 0;
    UCHAR   bearerCap[5];
    TCHAR   szMsg[20];

    PH323_ALIASNAMES pCallerAliasNames = m_pCallerAliasNames;


    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCallReroutingAPDU entered:%p.", this ));

    _ASSERTE( m_pCallReroutingInfo );

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;
    
    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CALLREROUTING_OPCODE;

    //argument
    CallReroutingArgument callReroutingArg;
    ZeroMemory( (PVOID)&callReroutingArg, sizeof(CallReroutingArgument) );
    
    //argument.reroutingReason
    callReroutingArg.reroutingReason = m_pCallReroutingInfo->diversionReason;

    //argument.originalReroutingReason
    if( m_pCallReroutingInfo->originalDiversionReason != 0 )
    {
        callReroutingArg.originalReroutingReason 
            = m_pCallReroutingInfo->originalDiversionReason;
    }
    else
    {
        callReroutingArg.originalReroutingReason 
        = m_pCallReroutingInfo->diversionReason;
    }

    //argument.diversionCounter
    callReroutingArg.diversionCounter = 
        ++(m_pCallReroutingInfo->diversionCounter);

    //argument.calledAddress
    callReroutingArg.calledAddress.bit_mask = 0;
    callReroutingArg.calledAddress.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(m_pCallReroutingInfo->divertedToNrAlias);

    if( callReroutingArg.calledAddress.destinationAddress == NULL )
    {
        goto cleanup;
    }
    
    //argument.lastReroutingNr
    callReroutingArg.lastReroutingNr.bit_mask = 0;
        callReroutingArg.lastReroutingNr.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(m_pCalleeAliasNames);
     
    if( callReroutingArg.lastReroutingNr.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argument.subscriptionoption
    callReroutingArg.subscriptionOption = notificationWithDivertedToNr;

    //argument.callingNumber
    callReroutingArg.callingNumber.bit_mask = 0;

    if( pCallerAliasNames == NULL )
    {
        pCallerAliasNames = new H323_ALIASNAMES;

        if( pCallerAliasNames == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, "could not allocate caller name." ));
            goto cleanup;
        }
        memset( (PVOID)pCallerAliasNames, 0, sizeof(H323_ALIASNAMES) );

        LoadString( g_hInstance,
            IDS_UNKNOWN,
            szMsg,
            20
          );

        if( !AddAliasItem( pCallerAliasNames,
                szMsg,
                h323_ID_chosen ) )
        {
                goto cleanup;
        }
    }

    callReroutingArg.callingNumber.destinationAddress
        = (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias(pCallerAliasNames);

    if( callReroutingArg.callingNumber.destinationAddress == NULL )
    {
        goto cleanup;
    }

    //argumnt.h225infoelement
    callReroutingArg.h225InfoElement.length = 5;
    callReroutingArg.h225InfoElement.value = bearerCap;
    
    bearerCap[0]= IDENT_BEARERCAP; 
    bearerCap[1]= 0x03; //length of the bearer capability
    bearerCap[2]= (BYTE)(BEAR_EXT_BIT | BEAR_CCITT | BEAR_UNRESTRICTED_DIGITAL);
    
    bearerCap[3]= BEAR_EXT_BIT | 0x17;
    bearerCap[4]= (BYTE)(BEAR_EXT_BIT | BEAR_LAYER1_INDICATOR | 
        BEAR_LAYER1_H221_H242);

    
    //argument.callingNumber
    if( m_pCallReroutingInfo->originalCalledNr != NULL )
    {
        callReroutingArg.originalCalledNr.bit_mask = 0;

        callReroutingArg.originalCalledNr.destinationAddress
            = (PEndpointAddress_destinationAddress)
            SetMsgAddressAlias( m_pCallReroutingInfo->originalCalledNr );

        if( callReroutingArg.originalCalledNr.destinationAddress != NULL )
        {
            callReroutingArg.bit_mask |= 
                CallReroutingArgument_originalCalledNr_present;
        }
    }

    //encode the callrerouting argument.
    rc = EncodeH450ASN( (void *) &callReroutingArg,
                CallReroutingArgument_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        goto cleanup;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        goto cleanup;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCallReroutingAPDU exited:%p.", this ));
    retVal = TRUE;

cleanup:
    if( pCallerAliasNames != m_pCallerAliasNames )
    {
        FreeAliasNames( pCallerAliasNames );
    }

    FreeCallReroutingArg( &callReroutingArg );    
    return retVal;
}


//No need to call in a lock!!
void
CH323Call::FreeCallReroutingArg( 
    CallReroutingArgument* pCallReroutingArg
    )
{
    //free all the aliases
    if( pCallReroutingArg->calledAddress.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->calledAddress.destinationAddress );
    }

    if( pCallReroutingArg->lastReroutingNr.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->lastReroutingNr.destinationAddress );
    }

    if( pCallReroutingArg->callingNumber.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->callingNumber.destinationAddress );
    }    
    
    if( pCallReroutingArg->originalCalledNr.destinationAddress != NULL )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            pCallReroutingArg->originalCalledNr.destinationAddress );
    }
}


// static
void
NTAPI CH323Call::CallEstablishmentExpiredCallback(
    IN PVOID   DriverCallHandle,        // HDRVCALL
    IN BOOLEAN bTimer)
{
    PH323_CALL  pCall = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallEstablishmentExpiredCallback entered." ));

    //if the timer expired
    _ASSERTE( bTimer );

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931 setup expired event recvd." ));
    pCall=g_pH323Line -> FindH323CallAndLock((HDRVCALL) DriverCallHandle);

    if( pCall != NULL )
    {
        if( pCall -> GetStateMachine() != Q931_CONNECT_RECVD )
        {
            //time out has occured
            pCall -> CloseCall( LINEDISCONNECTMODE_NOANSWER );
        }
        
        pCall -> Unlock();
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallEstablishmentExpiredCallback exited." ));
}


//-----------------------------------------------------------------------------
        //CALL TRANSFER (H450.2) ENCODE/DECODE ROUTINES
//-----------------------------------------------------------------------------



BOOL
CH323Call::EncodeH450APDUNoArgument( 
    IN  DWORD   dwOpcode,
    OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
    OUT BYTE**  ppEncodedAPDU,
    OUT DWORD*  pdwAPDULen
    )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    int     rc; 

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeH450APDUNoArgument entered:%p.", 
        this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;
    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = 0;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = dwOpcode;

    //no argument passed
    
    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeH450APDUNoArgument exited:%p.", 
        this ));
    return TRUE;
}

BOOL
CH323Call::EncodeCTInitiateAPDU( 
            OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
            OUT BYTE**  ppEncodedAPDU,
            OUT DWORD* pdwAPDULen
            )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];
    int     rc = 0;

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTInitiateAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CTINITIATE_OPCODE;

    //argument
    CTInitiateArg cTInitiateArg;
    ZeroMemory( (PVOID)&cTInitiateArg, sizeof(CTInitiateArg) );

    //argument.callIdentity
    CopyMemory( (PVOID)cTInitiateArg.callIdentity,
        (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

    //argument.reroutingNumber
    cTInitiateArg.reroutingNumber.bit_mask = 0;
    cTInitiateArg.reroutingNumber.destinationAddress =
        (PEndpointAddress_destinationAddress)
        SetMsgAddressAlias( m_pTransferedToAlias );

    if( cTInitiateArg.reroutingNumber.destinationAddress == NULL )
    {
        return FALSE;
    }

    //encode the CTSetup argument.
    rc = EncodeH450ASN( (void *) &cTInitiateArg,
                CTInitiateArg_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        FreeAddressAliases( (PSetup_UUIE_destinationAddress)
            cTInitiateArg.reroutingNumber.destinationAddress );
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)
        cTInitiateArg.reroutingNumber.destinationAddress );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTInitiateAPDU exited:%p.", this ));
    return TRUE;
}


BOOL
CH323Call::EncodeCTSetupAPDU(
            OUT H4501SupplementaryService *pSupplementaryServiceAPDU,
            OUT BYTE**  ppEncodedAPDU,
            OUT DWORD* pdwAPDULen
            )
{
    BYTE   *pEncodedArg = NULL;
    WORD    wEncodedLen = 0;
    BYTE    pBufEncodedArg[H450_ENCODED_ARG_LEN];

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTSetupAPDU entered:%p.", this ));

    ServiceApdus_rosApdus *pROSAPDU = 
        pSupplementaryServiceAPDU->serviceApdu.u.rosApdus;

    pROSAPDU->next = NULL;

    pROSAPDU->value.choice = H4503ROS_invoke_chosen;

    pROSAPDU->value.u.invoke.bit_mask = argument_present;

    //invoke ID
    pROSAPDU->value.u.invoke.invokeId = g_pH323Line->GetNextInvokeID();
    m_dwInvokeID = pROSAPDU->value.u.invoke.invokeId;

    //opcode
    pROSAPDU->value.u.invoke.opcode.choice = local_chosen;
    pROSAPDU->value.u.invoke.opcode.u.local = CTSETUP_OPCODE;

    //argument
    CTSetupArg cTSetupArg;
    ZeroMemory( (PVOID)&cTSetupArg, sizeof(CTSetupArg) );

    //argument.callIdentity
    CopyMemory( (PVOID)cTSetupArg.callIdentity, 
        (PVOID)m_pCTCallIdentity, sizeof(m_pCTCallIdentity) );

    //no argument.transferingNumber
 
    //encode the CTSetup argument.
    int rc = EncodeH450ASN( (void *) &cTSetupArg,
                CTSetupArg_PDU,
                &pEncodedArg,
                &wEncodedLen );

    if( ASN1_FAILED(rc) || (pEncodedArg == NULL) || (wEncodedLen == 0) )
    {
        return FALSE;
    }

    pROSAPDU->value.u.invoke.argument.value = pBufEncodedArg;
    pROSAPDU->value.u.invoke.argument.length = wEncodedLen;

    CopyMemory( (PVOID)pROSAPDU->value.u.invoke.argument.value,
        pEncodedArg, wEncodedLen );

    //free the previous asn buffer before encoding new one
    ASN1_FreeEncoded(m_ASNCoderInfo.pEncInfo, pEncodedArg );

    //call ASN.1 encoding function for APDU
    rc = EncodeH450ASN( (void *) pSupplementaryServiceAPDU,
                    H4501SupplementaryService_PDU,
                    ppEncodedAPDU,
                    &wEncodedLen );
    
    *pdwAPDULen = wEncodedLen;

    if( ASN1_FAILED(rc) || (*ppEncodedAPDU == NULL) || (pdwAPDULen == 0) )
    {
        return FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "EncodeCTSetupAPDU exited:%p.", this ));
    return TRUE;
}


void CH323Call::PostLineEvent (
    IN  DWORD       MessageID,
    IN  DWORD_PTR   Parameter1,
    IN  DWORD_PTR   Parameter2,
    IN  DWORD_PTR   Parameter3)
{
    (*g_pfnLineEventProc) (
        g_pH323Line -> m_htLine,
        m_htCall,
        MessageID,
        Parameter1,
        Parameter2,
        Parameter3);
}


//!!must be always called in a lock
void
CH323Call::DecrementIoRefCount(
    OUT BOOL * pfDelete
    )
{
    _ASSERTE( m_IoRefCount != 0 );
    m_IoRefCount--;
    
    H323DBG((DEBUG_LEVEL_TRACE, "DecrementIoRefCount:m_IoRefCount:%d:%p.",
        m_IoRefCount, this ));
    
    *pfDelete = FALSE;

    if( m_dwFlags & CALLOBJECT_SHUTDOWN )
    {
        *pfDelete = (m_IoRefCount==0) ? TRUE : FALSE;
    }
}


//!!must be always called in a lock
void 
CH323Call::StopCTIdentifyRRTimer( 
    HDRVCALL hdRelatedCall
    )
{
    if( m_hCTIdentifyRRTimer != NULL )
    {
        DeleteTimerQueueTimer( H323TimerQueue, m_hCTIdentifyRRTimer, NULL );
        m_hCTIdentifyRRTimer = NULL;
    }

    m_hdRelatedCall = hdRelatedCall;
}


void 
CH323Call::InitializeRecvBuf()
{
    m_RecvBuf.WSABuf.len = sizeof(TPKT_HEADER_SIZE);
    m_RecvBuf.WSABuf.buf = m_RecvBuf.arBuf;
    m_RecvBuf.dwPDULen = m_RecvBuf.dwBytesCopied = 0;
    m_bStartOfPDU = TRUE;
}


BOOL 
CH323Call::SetCallData( 
    LPVOID lpCallData, 
    DWORD dwSize )
{
    if( m_CallData.pOctetString != NULL )
    {
        delete m_CallData.pOctetString;
    }
    
    m_CallData.pOctetString = new BYTE[dwSize];
    
    if( m_CallData.pOctetString == NULL )
    {
        m_CallData.wOctetStringLength = 0;
        return FALSE;
    }

    CopyMemory( (PVOID)m_CallData.pOctetString, lpCallData, dwSize );

    m_CallData.wOctetStringLength = (WORD)dwSize;
    
    return TRUE;
}


// Global Functions

BOOL
IsPhoneNumber( 
              char * szAddr 
             )
{
    while( *szAddr )
    {
        if( !isdigit(*szAddr) && 
            ('#' != *szAddr) &&
            ('*' != *szAddr) &&
            ('+' != *szAddr)
          )
            return FALSE;
        szAddr++;
    }

    return TRUE;
}


BOOL
IsValidE164String( 
                  IN WCHAR* wszDigits
                 )
{
    for( ; (*wszDigits) != L'\0'; wszDigits++ )
    {
        if(!(                                            
            ((*wszDigits >= L'0') && (*wszDigits <= L'9')) ||   
            (*wszDigits == L'*') ||                         
            (*wszDigits == L'#') ||                         
            (*wszDigits == L'!') ||                         
            (*wszDigits == L',')                            
        ))
        {
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\config.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    config.h

Abstract:

    Definitions for H.323 TAPI Service Provider UI.


Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _INC_CONFIG
#define _INC_CONFIG


//                                                                           
// Function prototype                                                        
//                                                                           


INT_PTR
CALLBACK
ProviderConfigDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );


//                                                                           
// String definitions                                                        
//                                                                           


#define IDC_STATIC              (-1)

#define IDS_LINENAME            1
#define IDS_PROVIDERNAME        2
#define IDS_REGOPENKEY          3

#define IDS_GKLOGON_PHONEALIAS_ERROR    4
#define IDS_GKLOGON_ACCTALIAS_ERROR     5
#define IDS_GKLOGON_ERROR               6
#define IDS_PHONEALIAS_ERROR            7
#define IDS_GKALIAS_ERROR               8
#define IDS_PROXYALIAS_ERROR            9
#define IDS_GWALIAS_ERROR               20
#define IDS_ALERTTIMEOUT_ERROR          30
#define IDS_LISTENPORT_ERROR            40
#define IDS_REGISTERED                  50
#define IDS_NOT_REGISTERED              51
#define IDS_NONE                        52
#define IDS_REGISTRATION_INPROGRESS     53
#define IDS_UNKNOWN                     54


#define IDD_TSPCONFIG           10
#define IDC_GATEWAY_GROUP       11
#define IDI_PHONE               12
#define IDC_USEGATEWAY          13
#define IDC_H323_GATEWAY        14

#define IDC_PROXY_GROUP         15
#define IDI_PROXY               16
#define IDC_USEPROXY            17
#define IDC_H323_PROXY          18
#define IDI_GATEKEEPER          19

#define IDUPDATE                        1005
#define IDC_REGSTATE                    1006

#define IDUPDATE_PORT                   1010
#define IDC_LISTENPORT                  1011
#define IDC_STATIC3                     1012

#define IDAPPLY                         6
//GK related resource ids
#define IDC_H323_GK_ACCT        25


#define IDC_H323_GK_PHONE2              23

#define IDC_H323_CALL_TIMEOUT           23
#define IDC_CC_GROUP                    1007
#define IDC_STATIC1                     1008

#define IDC_H323_CALL_PORT              24
#define IDI_ICON2                       102
#define IDC_STATIC2                     1009



//                                                                           
// Help Support                                                              
//                                                                           


#define H323SP_HELP_FILE                    TEXT("tapi.hlp")

#define IDH_NOHELP                          ((DWORD) -1)
#define IDH_H323SP_USE_GATEWAY              10001
#define IDH_H323SP_USE_PROXY                10002
#define IDH_H323SP_USE_GATEWAY_COMPUTER     10003
#define IDH_H323SP_USE_PROXY_COMPUTER       10004
#define IDH_H323SP_GK_GROUP                 10035   //Set of options that control the use of Gatekeeper by this H.323 endpoint.

#define IDH_H323SP_GK                       10036   //Provides a space for you to type the IP address or the computer name of the H.323 Gatekeeper this endpoint will use.
#define IDH_H323SP_GK_PHONE                 10037   //Provides a space for you to type the phone number to be registered with the H.323 Gatekeeper.
#define IDH_H323SP_GK_ACCT                  10038   //Provides a space for you to type the account name to be registered with the H.323 Gatekeeper.

#define IDH_H323SP_USEGK                    10039   //Specifies that all the outgoing calls go through the specified Gatekeeper. If a Gatekeeper is enabled, all the H.323 Gateway and H.323 Proxy setting will be ignored.
#define IDH_H323SP_USEGK_PHONE              10040   //Specifies that a phone number should be registered with the H.323 Gatekkeper for the incoming calls.
#define IDH_H323SP_USEGK_ACCT                 10041   //Specifies that an account name should be registered with the H.323 Gatekkeper for the incoming calls.
#define IDH_H323SP_REGSTATE                   10042   //Specifies the H.323 Gatekeeper registration state of this endpoint. The possible values are: 'Registered', 'Unregisterd' and 'Registration In Progress'
#define IDH_H323SP_UPDATE_REGISTRATION_STATE  10043   //Updates the H.323 Gatekeeper registration state of this endpoint.

#define IDH_H323SP_CC_GROUP                   10044   //Set of options that control the incoming call setup behaviour for this endpoint.
#define IDH_H323SP_CALL_TIMEOUT               10045   //Provides a space for you to type the value in milliseconds for which an incoming call will ring before it is dropped.
#define IDH_H323SP_CALL_PORT                  10046   //Provides a space for you to type the port number on which the endpoint will listen for incoming calls.
#define IDH_H323SP_CURRENT_LISTENPORT         10047   //Specifies the port on which this endpoint is listening for incoming H.323 calls.
#define IDH_H323SP_UPDATE_PORT                10048   //Updates the port on which this endpoint is listening for incoming H.323 calls.


#define IDC_GK_GROUP                    12
#define IDC_H323_GK                     20
#define IDC_H323_GK_PHONE               22
#define IDC_H323_GK_ACCT                25
#define IDC_USEGK                       1000
#define IDC_USEGK_PHONE                 1001
#define IDC_GK_LOGONGROUP               1002
#define IDC_USEGK_ACCT                  1003
#define IDC_USEGK_MACHINE               1004


#endif // _INC_CONFIG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\globals.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    Global definitions for H.323 TAPI Service Provider.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


// build control defines
#define	STRICT
#define	UNICODE
#define	_UNICODE
#define	VC_EXTRALEAN
#define	H323_USE_PRIVATE_IO_THREAD	1

//                                                                           
// Include files:SDK
//                                                                           

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <mswsock.h>
#include <tapi3.h>
#include <tspi.h>
#include <crtdbg.h>
#include <stdio.h>
#include <tchar.h>
#include <rtutils.h>


// Project
#include <h225asn.h>
#include <tspmspif.h>


typedef class CH323Call*  PH323_CALL;
typedef class H323_CONFERENCE*  PH323_CONFERENCE; 

#define CALL_ALERTING_TIMEOUT  180000
#define Q931_CALL_PORT		1720 // Endpoint TCP Call Signalling Port

//                                                                           
// String definitions                                                        
//                                                                           
#define H323_MAXCALLSPERLINE    32768 //limited by 15 bit CRV sent to the Gatekeeper


#define H323_MAXLINENAMELEN     16
#define H323_MAXPORTNAMELEN     16
#define H323_MAXADDRNAMELEN     (H323_MAXLINENAMELEN + H323_MAXPORTNAMELEN)
#define H323_MAXPATHNAMELEN     256
#define H323_MAXDESTNAMELEN     256
#define MAX_E164_ADDR_LEN       127
#define MAX_H323_ADDR_LEN       255

#define H323_UIDLL              _T("H323.TSP")
#define H323_TSPDLL             _T("H323.TSP")
#define H323_WINSOCKVERSION     MAKEWORD(2,0)

#define H221_COUNTRY_CODE_USA   0xB5
#define H221_COUNTRY_EXT_USA    0x00
#define H221_MFG_CODE_MICROSOFT 0x534C

#define H323_PRODUCT_ID         "Microsoft TAPI\0"
#define H323_PRODUCT_VERSION    "Version 3.1\0"

#define MSP_HANDLE_UNKNOWN      0



//                                                                           
// Registry key definitions                                                  
//                                                                           

#define	REGSTR_PATH_WINDOWS_CURRENTVERSION		TEXT("Software\\Microsoft\\Windows\\CurrentVersion")
#define TAPI_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\Telephony")
#define TAPI_REGKEY_PROVIDERS					TAPI_REGKEY_ROOT TEXT("\\Providers")
#define TAPI_REGVAL_NUMPROVIDERS				TEXT("NumProviders")

#define H323_SUBKEY								TEXT("H323TSP")
#define H323_REGKEY_ROOT						REGSTR_PATH_WINDOWS_CURRENTVERSION TEXT("\\") H323_SUBKEY

#define H323_REGVAL_Q931ALERTINGTIMEOUT			TEXT("Q931AlertingTimeout")
#define H323_REGVAL_Q931LISTENPORT              TEXT("Q931ListenPort")

#define H323_REGVAL_GATEWAYENABLED				TEXT("H323GatewayEnabled")
#define H323_REGVAL_GATEWAYADDR					TEXT("H323GatewayAddress")

#define H323_REGVAL_PROXYENABLED				TEXT("H323ProxyEnabled")
#define H323_REGVAL_PROXYADDR					TEXT("H323ProxyAddress")

#define H323_REGVAL_GKENABLED					TEXT("H323GatekeeperEnabled")
#define H323_REGVAL_GKLOGON_PHONEENABLED		TEXT("H323GKLogOnPhoneNumberEnabled")
#define H323_REGVAL_GKLOGON_ACCOUNTENABLED		TEXT("H323GKLogOnAccountNameEnabled")
#define H323_REGVAL_GKADDR						TEXT("H323GatekeeperAddress")
#define H323_REGVAL_GKLOGON_PHONE				TEXT("H323GatekeeperLogOnPhoneNumber")
#define H323_REGVAL_GKLOGON_ACCOUNT				TEXT("H323GatekeeperLogOnAccountName")


#define H323_REGVAL_DEBUGLEVEL					TEXT("DebugLevel")


//                                                                           
// Global Definitions                                                        
//                                                                           

// CCRC_CALL_REJECTED reason codes (includes cause values)
#define H323_REJECT_NO_BANDWIDTH              1
#define H323_REJECT_GATEKEEPER_RESOURCES      2
#define H323_REJECT_UNREACHABLE_DESTINATION   3
#define H323_REJECT_DESTINATION_REJECTION     4
#define H323_REJECT_INVALID_REVISION          5
#define H323_REJECT_NO_PERMISSION             6
#define H323_REJECT_UNREACHABLE_GATEKEEPER    7
#define H323_REJECT_GATEWAY_RESOURCES         8
#define H323_REJECT_BAD_FORMAT_ADDRESS        9
#define H323_REJECT_ADAPTIVE_BUSY             10
#define H323_REJECT_IN_CONF                   11
#define H323_REJECT_ROUTE_TO_GATEKEEPER       12
#define H323_REJECT_CALL_FORWARDED            13
#define H323_REJECT_ROUTE_TO_MC               14
#define H323_REJECT_UNDEFINED_REASON          15
#define H323_REJECT_INTERNAL_ERROR            16    // Internal error occured in peer CS stack.
#define H323_REJECT_NORMAL_CALL_CLEARING      17    // Normal call hangup
#define H323_REJECT_USER_BUSY                 18    // User is busy with another call
#define H323_REJECT_NO_ANSWER                 19    // Callee does not answer
#define H323_REJECT_NOT_IMPLEMENTED           20    // Service has not been implemented
#define H323_REJECT_MANDATORY_IE_MISSING      21    // Pdu missing mandatory ie
#define H323_REJECT_INVALID_IE_CONTENTS       22    // Pdu ie was incorrect
#define H323_REJECT_TIMER_EXPIRED             23    // Own timer expired
#define H323_REJECT_CALL_DEFLECTION           24    // You deflected the call, so lets quit.
#define H323_REJECT_GATEKEEPER_TERMINATED     25    // Gatekeeper terminated call


// unicode character mask contants
#define H323_ALIAS_H323_PHONE_CHARS           L"0123456789#*,"
#define H323_ODOTTO_CHARS                     L".0123456789"

//
//H450 Operation types
//

enum H450_OPERATION_TYPE
{
    H450_INVOKE         = 0x00000100,
    H450_RETURNRESULT   = 0x00000200,
    H450_RETURNERROR    = 0x00000400,
    H450_REJECT         = 0x00000800,

};


//
//H450 APDU types
//

enum H450_OPCODE
{
    NO_H450_APDU                        = 0,

    H4503_DUMMYTYPERETURNRESULT_APDU    = 50,
    H4503_RETURNERROR_APDU              = 51,
    H4503_REJECT_APDU                   = 52,

    CHECKRESTRICTION_OPCODE             = 18,
    CALLREROUTING_OPCODE                = 19,
    DIVERTINGLEGINFO1_OPCODE            = 20,
    DIVERTINGLEGINFO2_OPCODE            = 21,
    DIVERTINGLEGINFO3_OPCODE            = 22,

    CTIDENTIFY_OPCODE                   = 7,
    CTINITIATE_OPCODE                   = 9,
    CTSETUP_OPCODE                      = 10,

    HOLDNOTIFIC_OPCODE                  = 101,
    RETRIEVENOTIFIC_OPCODE              = 102,
    REMOTEHOLD_OPCODE                   = 103,
    REMOTERETRIEVE_OPCODE               = 104,

    CPREQUEST_OPCODE                    = 106,
    CPSETUP_OPCODE                      = 107,
    GROUPINDON_OPCODE                   = 108,
    GROUPINDOFF_OPCODE                  = 109,
    PICKREQU_OPCODE                     = 110,
    PICKUP_OPCODE                       = 111,
    PICKEXE_OPCODE                      = 112,
    CPNOTIFY_OPCODE                     = 113,
    CPICKUPNOTIFY_OPCODE                = 114,

};


#define NO_INVOKEID                     0x00000000



//                                                                           
// Global Data Structures                                                    
//                                                                           

// IP address in conventional 'dot' notation
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    WCHAR        cAddr[16];      // UNICODE zstring
} H323_IP_Dot_t;

// IP address in binary format
typedef struct 
{
    WORD         wPort;          // UDP or TCP port (host byte order)
    DWORD        dwAddr;         // binary address (host byte order)
} H323_IP_Binary_t;

typedef enum
{
    H323_ADDR_NOT_DEFINED = 0,
    H323_IP_DOMAIN_NAME ,
    H323_IP_DOT ,
    H323_IP_BINARY 
} H323_ADDRTYPE;

typedef struct _ADDR
{
    H323_ADDRTYPE nAddrType;
    BOOL        bMulticast;
    union 
    {
        H323_IP_Dot_t          IP_Dot;
        H323_IP_Binary_t       IP_Binary;
    } Addr;
} H323_ADDR, *PH323_ADDR;

typedef struct
{
    BYTE *pOctetString;
    WORD wOctetStringLength;

} H323_OCTETSTRING, *PH323_OCTETSTRING;


typedef struct ENDPOINT_ID
{
    ASN1uint32_t length;
    ASN1char16_t value[H323_MAXPATHNAMELEN+ 1];

} ENDPOINT_ID;


typedef struct
{
    H323_OCTETSTRING        sData;            // pointer to Octet data.
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
} H323NonStandardData;

#define H323_MAX_PRODUCT_LENGTH 256
#define H323_MAX_VERSION_LENGTH 256
#define H323_MAX_DISPLAY_LENGTH 82

typedef struct
{
    BYTE                    bCountryCode;
    BYTE                    bExtension;
    WORD                    wManufacturerCode;
    PH323_OCTETSTRING       pProductNumber;
    PH323_OCTETSTRING       pVersionNumber;
} H323_VENDORINFO, *PH323_VENDORINFO;

typedef struct
{
    PH323_VENDORINFO        pVendorInfo;
    BOOL                    bIsTerminal;
    BOOL                    bIsGateway;    // for now, the H323 capability will be hard-coded.
} H323_ENDPOINTTYPE, *PH323_ENDPOINTTYPE;


typedef struct
{
    WORD    wType;
    WORD    wPrefixLength;
    LPWSTR  pPrefix;
    WORD    wDataLength;   // UNICODE character count
    LPWSTR  pData;         // UNICODE data.
} H323_ALIASITEM, *PH323_ALIASITEM;


typedef struct
{
    WORD            wCount;
    PH323_ALIASITEM pItems;

} H323_ALIASNAMES, *PH323_ALIASNAMES;

typedef struct _H323_FASTSTART
{
    struct _H323_FASTSTART* next;
    DWORD                   length;
    BYTE*                   value;

} H323_FASTSTART, *PH323_FASTSTART;


struct	H323_REGISTRY_SETTINGS
{
    DWORD       dwQ931AlertingTimeout;          // q931 alerting timeout
    DWORD       dwQ931ListenPort;       // port to listen for incoming calls

    BOOL        fIsGatewayEnabled;              // if true, gateway enabled
    BOOL        fIsProxyEnabled;                // if true, proxy enabled
    BOOL        fIsGKEnabled;                   // if true, GK enabled

    H323_ADDR   gatewayAddr;                    // H.323 gateway address
    H323_ADDR   proxyAddr;                      // H.323 proxy address

    SOCKADDR_IN saGKAddr;                       // H.323 gatekeeper address
    WCHAR       wszGKLogOnPhone[H323_MAXDESTNAMELEN+1];   // phone number to register with the gatekeeper
    WCHAR       wszGKLogOnAccount[H323_MAXDESTNAMELEN+1]; // account name to register with the gatekeeper
    BOOL        fIsGKLogOnPhoneEnabled;         // if true, gateway enabled
    BOOL        fIsGKLogOnAccountEnabled;      // if true, proxy enabled
    

    DWORD       dwLogLevel;               // debug log level
    //TCHAR       szLogFile[MAX_PATH+1];
};


//                                                                           
// Global Variables                                                          
//                                                                           
extern	WCHAR 				g_pwszProviderInfo[];
extern	WCHAR 				g_pwszLineName[];
extern	LINEEVENT			g_pfnLineEventProc;
extern	HINSTANCE			g_hInstance;
extern	HANDLE				g_hCanUnloadDll;
extern  HANDLE              g_hEventLogSource;
extern	DWORD				g_dwLineDeviceIDBase;
extern	DWORD				g_dwPermanentProviderID;
extern	H323_REGISTRY_SETTINGS	g_RegistrySettings;

#define	H323TimerQueue		NULL		// use default process timer queue


//
// I/O callback threaddeclarations.
//


#if	H323_USE_PRIVATE_IO_THREAD

BOOL	H323BindIoCompletionCallback (
	IN	HANDLE	ObjectHandle,
	IN	LPOVERLAPPED_COMPLETION_ROUTINE	CompletionRoutine,
	IN	ULONG	Flags);

HRESULT H323IoThreadStart(void);
void H323IoThreadStop(void);

#else

#define	H323BindIoCompletionCallback 	BindIoCompletionCallback

#endif

enum
{
	DEBUG_LEVEL_FORCE   = 0x00000000,	// always emit, no matter what
	DEBUG_LEVEL_ERROR   = 0x00020000,	// significant errors only
	DEBUG_LEVEL_INFO    = 0x00040000,	// general information, but not too detailed
	DEBUG_LEVEL_TRACE   = 0x00080000,   // lotsa lotsa trace output
};

#define	DEBUG_LEVEL_WARNING		DEBUG_LEVEL_INFO
#define	DEBUG_LEVEL_FATAL		DEBUG_LEVEL_FORCE	// big, bad errors, always output
#define	DEBUG_LEVEL_VERBOSE		DEBUG_LEVEL_INFO

PSTR EventIDToString( DWORD eventID );
PSTR H323CallStateToString( DWORD dwCallState );
PSTR H323AddressTypeToString( DWORD dwAddressType );
PSTR H323TSPMessageToString( DWORD dwMessageType );

#define	SOCKADDR_IN_PRINTF(SocketAddress) \
	ntohl ((SocketAddress) -> sin_addr.s_addr), \
	ntohs ((SocketAddress) -> sin_port)

//
//Debug Output declarations
//


#if	DBG

#define H323DBG(_x_)            H323DbgPrint _x_
void H323DUMPBUFFER( IN BYTE * pEncoded, IN DWORD cbEncodedSize );

//                                                                           
// Public prototypes                                                         
//                                                                           

VOID H323DbgPrint( DWORD dwLevel, LPSTR szFormat, ... );
void DumpError( IN DWORD ErrorCode );
BOOL TRACELogRegister(LPCTSTR szName);
void TRACELogDeRegister();


static __inline void DumpLastError (void) {
	DumpError (GetLastError());
}

static DWORD
ProcessTAPICallRequest(
        IN  PVOID   ContextParameter
        );

static DWORD
ProcessSuppServiceWorkItem(
    IN PVOID ContextParameter
    );

DWORD
SendMSPMessageOnRelatedCall(
    IN PVOID ContextParameter
    );


static DWORD
ProcessTAPILineRequest(
    IN PVOID ContextParam
    );


#else

// retail build

#define	DumpError(ErrorCode)		0
#define	DumpLastError()				0

#define H323DBG(_x_)    if( 0 != g_RegistrySettings.dwLogLevel ) H323DbgPrintFre _x_
#define H323DUMPBUFFER( x, y)

VOID OpenLogFile();
VOID CloseLogFile();
VOID H323DbgPrintFre(DWORD dwLevel, LPSTR szFormat, ... );

#define ProcessTAPICallRequest          ProcessTAPICallRequestFre
#define ProcessSuppServiceWorkItem      ProcessSuppServiceWorkItemFre
#define ProcessTAPILineRequest          ProcessTAPILineRequestFre
#define SendMSPMessageOnRelatedCall     SendMSPMessageOnRelatedCallFre

#endif	// DBG



//                                                                           
// Global Function Declarations                                              
//                                                                           

void ReportTSPEvent( LPCTSTR wszErrorMessage );
#define H323TSP_EVENT_SOURCE_NAME _T("Microsoft H.323 Telephony Service Provider")

static __inline BOOL IsGuidSet (
	IN	const GUID *	Guid)
{
	return Guid -> Data1 || Guid -> Data2 || Guid -> Data3 || Guid -> Data4;
}

static __inline void CopyConferenceID (
	OUT	GloballyUniqueID *	Target,
	IN	const GUID *		Value)
{
    CopyMemory (Target -> value, Value, sizeof (GUID));
    Target -> length = sizeof (GUID);
}

static __inline void CopyConferenceID (
	OUT	GUID *		Target,
	IN	const GloballyUniqueID *	Value)
{
    if (Value -> length == sizeof (GUID))
	    CopyMemory (Target, Value -> value, sizeof (GUID));
    else
    {
	    H323DBG ((DEBUG_LEVEL_ERROR, "GloballyUniqueID was wrong length (%d)\n",
		    Value -> length));

	    ZeroMemory (Target, sizeof (GUID));
    }
}


extern ASYNC_COMPLETION	g_pfnCompletionProc;
#define H323CompleteRequest (*g_pfnCompletionProc)


// notify TAPI of a line event.
void	H323PostLineEvent (
	IN	HTAPILINE	TapiLine,
	IN	HTAPICALL	TapiCall,
	IN	DWORD		MessageID,
	IN	ULONG_PTR	Parameter1,
	IN	ULONG_PTR	Parameter2,
	IN	ULONG_PTR	Parameter3);


static __inline HRESULT GetLastResult (void) { return HRESULT_FROM_WIN32 (GetLastError()); }

BOOL H323ValidateTSPIVersion( IN	DWORD dwTSPIVersion );
BOOL H323ValidateExtVersion ( IN	DWORD dwExtVersion);

HRESULT	RegistryStart	(void);
void	RegistryStop	(void);


HANDLE 
H323CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName                           // object name
);

//                                                                           
// Macros                                                                    
//                                                                           

#define H323AddrToString(_dwAddr_) \
    (inet_ntoa(H323AddrToAddrIn(_dwAddr_)))

#define H323AddrToAddrIn(_dwAddr_) \
    (*((struct in_addr *)&(_dwAddr_)))

#define H323SizeOfWSZ(wsz) \
    (((wsz) == NULL) ? 0 : ((wcslen(wsz) + 1) * sizeof(WCHAR)))



//                                                                           
// Table Class                                                               
//                                                                           

template <class T, DWORD INITIAL = 8, DWORD DELTA = 8>
class TSPTable
{
protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;
    CRITICAL_SECTION m_CriticalSection;

public:

    // Construction/destruction
    TSPTable() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    {
            
        // No need to check the result of this one since this object is
        // always allocated on static memory, right when the DLL is loaded.

		InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );
	}

    ~TSPTable()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }

        DeleteCriticalSection(&m_CriticalSection);
    }
    void Lock()
    {
        EnterCriticalSection( &m_CriticalSection );
    }
    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
    }
    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    int GetAllocSize()
    {
        return m_nAllocSize;
    }
    int Add(T& t)
    {
        Lock();
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return -1;
            SetAtIndex(m_nSize, t);
            m_nSize++;
            Unlock();
            return m_nSize - 1;
        }
        else
        {
            for(int i=0; i<m_nAllocSize; i++)
                if(m_aT[i] == NULL )
                    break;
            SetAtIndex(i, t);
            m_nSize++;
            Unlock();
            return i;
        }
    }
    void RemoveAt(int nIndex)
    {
        Lock();
        _ASSERTE( m_aT[nIndex] );
        m_aT[nIndex] = NULL;
        m_nSize--;
        Unlock();
    }
    T& operator[] (int nIndex) const
    {
        static T t1 = (T)NULL;
        _ASSERTE( (nIndex >= 0) && (nIndex < m_nAllocSize) );
        if( (nIndex >= 0) && (nIndex < m_nAllocSize) )
            return m_aT[nIndex];
        return t1;
    }        

// Implementation
private:
    void SetAtIndex(int nIndex, T& t)
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nAllocSize);
        if( (nIndex >= 0) && (nIndex < m_nAllocSize) )
            m_aT[nIndex] = t;
    }
    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? INITIAL : (m_nSize + DELTA);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        ZeroMemory( (PVOID)&aT[m_nAllocSize], sizeof(T)*(nNewAllocSize-m_nAllocSize));
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;

        return TRUE;
    }
};




/*++

CTSPArray template Description:

    This array should only be used to store simple types. It doesn't call the
    constructor nor the destructor for each element in the array.

--*/

template <class T, DWORD INITIAL_SIZE = 8, DWORD DELTA_SIZE = 8>
class CTSPArray
{

protected:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;

public:

    // Construction/destruction
    CTSPArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }

    ~CTSPArray()
    {
        RemoveAll();
    }


    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Grow()
    {
        T* aT;
        int nNewAllocSize = 
            (m_nAllocSize == 0) ? INITIAL_SIZE : (m_nSize + DELTA_SIZE);

        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
        if(aT == NULL)
            return FALSE;
        m_nAllocSize = nNewAllocSize;
        m_aT = aT;
        return TRUE;
    }

    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            if (!Grow()) return FALSE;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {
        if(nIndex != (m_nSize - 1))
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], 
                (m_nSize - (nIndex + 1)) * sizeof(T));
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_nAllocSize > 0)
        {
            free(m_aT);
            m_aT = NULL;
            m_nSize = 0;
            m_nAllocSize = 0;
        }
    }
    T& operator[] (int nIndex) const
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }

    
    // Implementation
    void SetAtIndex(int nIndex, T& t)
    {
        _ASSERTE(nIndex >= 0 && nIndex < m_nSize);
        m_aT[nIndex] = t;
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
};


//
//Asynchronous I/O definitions.
//

class RAS_CLIENT;
class CH323Call;

#define  IO_BUFFER_SIZE                     0x2000

enum OVERLAPPED_TYPE
{
	OVERLAPPED_TYPE_SEND = 0,
	OVERLAPPED_TYPE_RECV,
};

typedef struct O_OVERLAPPED
{
    LIST_ENTRY			ListEntry;
	OVERLAPPED			Overlapped;
	OVERLAPPED_TYPE	    Type;
    union {
	RAS_CLIENT*		    RasClient;
    CH323Call*          pCall;
    };
	DWORD				BytesTransferred;
	SOCKADDR_IN			Address;

} RAS_OVERLAPPED, CALL_OVERLAPPED;

struct CALL_SEND_CONTEXT :
public CALL_OVERLAPPED
{
    WSABUF  WSABuf;
};

struct RAS_SEND_CONTEXT :
public RAS_OVERLAPPED
{
    UCHAR arBuf[IO_BUFFER_SIZE];
};


struct	RAS_RECV_CONTEXT :
public	RAS_OVERLAPPED
{
    UCHAR   arBuf[IO_BUFFER_SIZE];
	DWORD   Flags;
    BOOL    IsPending;
    INT     AddressLength;
};
 
struct CALL_RECV_CONTEXT :
public	CALL_OVERLAPPED
{
    char    arBuf[IO_BUFFER_SIZE];
    WSABUF  WSABuf;
    DWORD   dwBytesCopied;
    DWORD   dwPDULen;
    DWORD   dwFlags;
};



//                                                                           
// Component Includes                                                        
//                                                                           

#include "h4503pp.h"
#include "q931pdu.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\io.cpp ===
#include "globals.h"

#if H323_USE_PRIVATE_IO_THREAD
#define FINITE_WAIT_TIME    3000

static  HANDLE      H323IoCompletionPort = NULL;
static  HANDLE      H323IoThread = NULL;
static  DWORD       H323IoThreadID = 0;

static DWORD WINAPI H323IoThreadProc (
    IN  PVOID   ThreadParameter)
{
    LPOVERLAPPED    Overlapped;
    ULONG_PTR       CompletionKey;
    DWORD           Status;
    DWORD           BytesTransferred;

    for (;;)
    {
        if( GetQueuedCompletionStatus( H323IoCompletionPort, 
            &BytesTransferred, 
            &CompletionKey, 
            &Overlapped, 
            INFINITE) == TRUE ) 
        {
            Status = ERROR_SUCCESS;
        }
        else 
        {
            if( Overlapped )
            {
                Status = GetLastError();
            }
            else 
            {
                H323DBG((DEBUG_LEVEL_ERROR, "failed to dequeue i/o completion "
                         "packet: %d, quitting...", GetLastError() ));

                ExitThread (GetLastError());
            }
        }

        _ASSERTE( CompletionKey);

        ((LPOVERLAPPED_COMPLETION_ROUTINE) CompletionKey)(  Status, 
                                                            BytesTransferred,
                                                            Overlapped );
    }

    // never reached
    return EXIT_SUCCESS;
}

static void CALLBACK H323IoThreadExitCallback (
    IN  DWORD   Status,
    IN  DWORD   BytesTransferred,
    IN  LPOVERLAPPED    Overlapped)
{
    H323DBG ((DEBUG_LEVEL_TRACE, "i/o completion thread is stopping"));
    ExitThread (EXIT_SUCCESS);
}

HRESULT H323IoThreadStart (void)
{
    if( H323IoCompletionPort == NULL )
    {
        H323IoCompletionPort = 
            CreateIoCompletionPort(  INVALID_HANDLE_VALUE, 
                                     NULL, 
                                     0, 
                                     0 );
        if( H323IoCompletionPort == NULL )
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "failed to create i/o completion port: %d", GetLastError() ));

            return GetLastResult();
        }
    }


    H323IoThread = CreateThread(NULL, 
                                0, 
                                H323IoThreadProc, 
                                NULL, 
                                0, 
                                &H323IoThreadID );

    if( H323IoThread == NULL )
    {
        H323DBG((   DEBUG_LEVEL_ERROR, 
                    "failed to create i/o completion worker thread: %d",
                    GetLastError() ));

        CloseHandle (H323IoCompletionPort);
        H323IoCompletionPort = NULL;

        return GetLastResult();
    }

    return S_OK;
}

void H323IoThreadStop (void)
{
    DWORD dwWaitTime = INFINITE;
    H323DBG ((DEBUG_LEVEL_WARNING, "H323IoThreadStop entered."));

    if( H323IoThread != NULL )
    {
        _ASSERTE( H323IoCompletionPort != NULL );

        if( !PostQueuedCompletionStatus( H323IoCompletionPort, 0,
            (ULONG_PTR) H323IoThreadExitCallback, (LPOVERLAPPED) -1) )
        {
            H323DBG(( DEBUG_LEVEL_WARNING, "PostQueuedCompletionStatus failed" ));
            dwWaitTime = FINITE_WAIT_TIME;
        }

        H323DBG(( DEBUG_LEVEL_WARNING, 
            "waiting for i/o completion port thread to finish..." ));

        WaitForSingleObject( H323IoThread, dwWaitTime );

        H323DBG(( DEBUG_LEVEL_WARNING, 
            "i/o completion port thread is finished." ));

        CloseHandle (H323IoThread);
        H323IoThread = NULL;
    }

    if( H323IoCompletionPort != NULL )
    {
        CloseHandle( H323IoCompletionPort );
        
        H323IoCompletionPort = NULL;
    }

    H323DBG ((DEBUG_LEVEL_WARNING, "H323IoThreadStop exited"));
}

BOOL H323BindIoCompletionCallback (
    IN  HANDLE  ObjectHandle,
    IN  LPOVERLAPPED_COMPLETION_ROUTINE CompletionRoutine,
    IN  ULONG   Flags)
{
    if( H323IoCompletionPort != NULL )
    {
        if (!CompletionRoutine) 
        {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        return CreateIoCompletionPort(  ObjectHandle, 
                                        H323IoCompletionPort,
                                        (ULONG_PTR) CompletionRoutine, 
                                        0 ) != NULL;
    }
    else
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "i/o completion port is not yet created" ));

        SetLastError( ERROR_GEN_FAILURE );
        return FALSE;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\line.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    line.cpp

Abstract:

    TAPI Service Provider functions related to manipulating lines.

        TSPI_lineClose
        TSPI_lineGetDevCaps         
        TSPI_lineGetLineDevStatus
        TSPI_lineGetNumAddressIDs
        TSPI_lineOpen
        
Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "call.h"
#include "q931obj.h"
#include "ras.h"



static  LONG    g_CTCallIdentity;

CH323Line g_H323Line;

H323_OCTETSTRING g_ProductID =
{
    (BYTE*)H323_PRODUCT_ID,
    sizeof(H323_PRODUCT_ID)
};


H323_OCTETSTRING g_ProductVersion =
{
    (BYTE*)H323_PRODUCT_VERSION,
    sizeof(H323_PRODUCT_VERSION)
};


//Queues a request made by TAPI to the thread pool
BOOL
QueueTAPILineRequest(
    IN  DWORD       EventID,
    IN  HDRVCALL    hdCall1,
    IN  HDRVCALL    hdCall2,
    IN  DWORD       dwDisconnectMode,
    IN  WORD        wCallReference)
{
    BOOL fResult = TRUE;
    TAPI_LINEREQUEST_DATA * pLineRequestData = new TAPI_LINEREQUEST_DATA;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "QueueTAPILineRequest entered." ));

    if( pLineRequestData != NULL )
    {
        pLineRequestData -> EventID = EventID;
        pLineRequestData -> hdCall1 = hdCall1;

        if( hdCall2 != NULL )
        {
            pLineRequestData -> hdCall2 = hdCall2;
        }
        else
        {
            pLineRequestData -> dwDisconnectMode = dwDisconnectMode;
        }
                
        pLineRequestData -> wCallReference = wCallReference;
        
        if( !QueueUserWorkItem( ProcessTAPILineRequest, pLineRequestData,
                WT_EXECUTEDEFAULT) )
        {
            delete pLineRequestData;
            fResult = FALSE;
        }
    }
    else
    {
        fResult = FALSE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "QueueTAPILineRequest exited." ));
    return fResult;
}


#if    DBG

DWORD
ProcessTAPILineRequest(
	IN PVOID ContextParameter
    )
{
    __try
    {
        return ProcessTAPILineRequestFre( ContextParameter );
    }
    __except( 1 )
    {
        TAPI_LINEREQUEST_DATA*  pRequestData = (TAPI_LINEREQUEST_DATA*)ContextParameter;
        
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event threw exception: %p, %p, %d.",
            EventIDToString(pRequestData -> EventID),
            pRequestData -> hdCall1,
            pRequestData -> hdCall2,
            pRequestData -> wCallReference ));
        
        _ASSERTE( FALSE );

        return 0;
    }
}

#endif

DWORD
ProcessTAPILineRequestFre(
    IN  PVOID   ContextParam
    )
{
    _ASSERTE( ContextParam );

    PH323_CALL              pCall = NULL;
    PH323_CALL              pConsultCall = NULL;
    TAPI_LINEREQUEST_DATA*  pLineRequestData = (TAPI_LINEREQUEST_DATA*)ContextParam;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI %s event recvd.",
        EventIDToString(pLineRequestData -> EventID) ));

    switch( pLineRequestData -> EventID )
    {
    case TSPI_CLOSE_CALL:

        g_pH323Line -> H323ReleaseCall( 
            pLineRequestData->hdCall1, 
            pLineRequestData->dwDisconnectMode,
            pLineRequestData->wCallReference );
        break;

    case TSPI_COMPLETE_TRANSFER:

        pConsultCall = g_pH323Line -> Find2H323CallsAndLock( 
            pLineRequestData->hdCall2, pLineRequestData->hdCall1, &pCall );
        
        if( pConsultCall != NULL )
        {
            pConsultCall -> CompleteTransfer( pCall );

            pCall -> Unlock();
            pConsultCall -> Unlock();
        }
        break;
    }

    delete pLineRequestData;
    return EXIT_SUCCESS;
}



//                                                                           
// Private procedures                                                        
//                                                                           

CH323Line::CH323Line()
{
    m_nState = H323_LINESTATE_NONE;
    m_hdLine = NULL;
    m_htLine = NULL;
    m_dwDeviceID = -1;
    m_dwTSPIVersion = NULL;
    m_dwMediaModes = NULL;
    m_hdNextMSPHandle = NULL;
    m_wszAddr[0] = UNICODE_NULL;
    m_dwInitState = NULL;

    m_VendorInfo.bCountryCode = H221_COUNTRY_CODE_USA;
    m_VendorInfo.bExtension = H221_COUNTRY_EXT_USA;
    m_VendorInfo.wManufacturerCode = H221_MFG_CODE_MICROSOFT;
    m_VendorInfo.pProductNumber = &(g_ProductID);
    m_VendorInfo.pVersionNumber = &(g_ProductVersion); 

    m_pCallForwardParams = NULL;
    m_dwInvokeID = 256;
    m_fForwardConsultInProgress = FALSE;

}


PH323_CALL 
CH323Line::Find2H323CallsAndLock (
    IN  HDRVCALL hdCall1,
    IN  HDRVCALL hdCall2,
    OUT PH323_CALL * ppCall2
    )
{
    int iIndex1 = MakeCallIndex (hdCall1);
    int iIndex2 = MakeCallIndex (hdCall2);
    PH323_CALL  pCall1 = NULL, pCall2 = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "Find2H323CallsAndLock entered:%lx:%lx.",
        hdCall1, hdCall2 ));

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    pCall1 = m_H323CallTable[iIndex1];
    if( pCall1 != NULL )
    {
        pCall1 -> Lock();
        if( pCall1->GetCallHandle() != hdCall1 )
        {
            pCall1 -> Unlock();
            pCall1 = NULL;
        }
        else 
        {
            if( pCall2=m_H323CallTable[iIndex2] )
            {
                pCall2 -> Lock();
                if( pCall2->GetCallHandle() != hdCall2 )
                {
                    pCall2 -> Unlock();
                    pCall2 = NULL;
                    pCall1 -> Unlock();
                    pCall1 = NULL;
                }
            }
            else
            {
                pCall1 -> Unlock();
                pCall1 = NULL;
            }
        }
    }

    UnlockCallTable();

    *ppCall2 = pCall2;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "Find2H323CallsAndLock exited:%lx:%lx.",
        hdCall1, hdCall2 ));
    return pCall1;
}


PH323_CALL 
CH323Line::FindH323CallAndLock (
    IN  HDRVCALL hdCall)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FindH323CallAndLock entered:%lx.", hdCall ));

    int iIndex = MakeCallIndex (hdCall);
    PH323_CALL  pCall = NULL;

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( pCall=m_H323CallTable[iIndex] )
    {
        pCall -> Lock();
        if( pCall->GetCallHandle() != hdCall )
        {
            pCall -> Unlock();
            pCall = NULL;
        }
    }

    UnlockCallTable();

    H323DBG(( DEBUG_LEVEL_TRACE, "FindH323CallAndLock exited:%p.", pCall ));
    return pCall;
}


PH323_CALL 
CH323Line::FindCallByARQSeqNumAndLock( 
    WORD seqNumber
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByARQSeqNumAndLock entered:%d.", 
        seqNumber ));
    
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetARQSeqNumber() == seqNumber )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByARQSeqNumAndLock exited." ));
    return pCall;
}


//the code is replicated for the purpose of effeciency
PH323_CALL 
CH323Line::FindCallByDRQSeqNumAndLock(
    WORD seqNumber
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByDRQSeqNumAndLock entered:%d.",
        seqNumber ));
    
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetDRQSeqNumber() == seqNumber )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByDRQSeqNumAndLock exited:%d.",
        seqNumber ));
    return pCall;
}


//the code is replicated for the purpose of effeciency
PH323_CALL 
CH323Line::FindCallByCallRefAndLock( 
    WORD wCallRef
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByCallRefAndLock entered:%d.",
        wCallRef ));
    
    wCallRef &= 0x7fff;
    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetCallRef() == wCallRef )
            {
                pCall -> Lock();
                break;
            }
            pCall = NULL;
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "FindCallByCallRefAndLock exited:%d.",
        wCallRef ));
    
    return pCall;
}


void 
CH323Line::RemoveFromCTCallIdentityTable( 
    HDRVCALL hdCall )
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "RemoveFromCTCallIdentityTable entered:%lx.",
        hdCall ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            if( pCTCallIDContext -> hdCall == hdCall)
            {
                m_CTCallIDTable.RemoveAt(iIndex);
            }
        }
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "RemoveFromCTCallIdentityTable exited:%lx.",
        hdCall ));
}


void 
CH323Line::ShutdownCTCallIDTable()
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "ShutdownCTCallIDTable entered." ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            delete pCTCallIDContext;
            m_CTCallIDTable[iIndex] = NULL;
        }
    }

    m_CTCallIDTable.Unlock();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "ShutdownCTCallIDTable exited." ));
}


BOOL
CH323Line::CallReferenceDuped(
    WORD wCallRef
    )
{
    PH323_CALL  pCall = NULL;
    int         iIndex;

    H323DBG(( DEBUG_LEVEL_TRACE, "CallReferenceDuped entered:%d.", wCallRef ));
    
    wCallRef &= 0x7FFF;
    LockCallTable();

    for( iIndex=0; iIndex <  m_H323CallTable.GetAllocSize(); iIndex++ )
    {
        if( pCall=m_H323CallTable[iIndex] )
        {
            if( pCall->GetCallRef() == wCallRef )
            {
                UnlockCallTable();
                return TRUE;
            }
        }
    }

    UnlockCallTable();
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CallReferenceDuped exited:%d.", wCallRef ));
    return FALSE;
}


HDRVCALL
CH323Line::GetCallFromCTCallIdentity( 
    int iCTCallID
    )
{
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "GetCallFromCTCallIdentity entered:%d.", 
        iCTCallID ));
    
    m_CTCallIDTable.Lock();

    for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
    {
        pCTCallIDContext = m_CTCallIDTable[iIndex];

        if( pCTCallIDContext != NULL )
        {
            if( pCTCallIDContext -> iCTCallIdentity == iCTCallID )
            {
                m_CTCallIDTable.Unlock();
                return (HDRVCALL)(pCTCallIDContext -> hdCall);
            }
        }
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCallFromCTCallIdentity exited:%d.",
        iCTCallID ));
    
    return NULL;
}


int
CH323Line::GetCTCallIdentity(
    IN  HDRVCALL    hdCall)
{
    int CTCallID = 0;
    int iIndex;
    PCTCALLID_CONTEXT pCTCallIDContext = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCTCallIdentity entered:%lx.",  hdCall ));

    m_CTCallIDTable.Lock();

    do
    {
        g_CTCallIdentity++;
        if( g_CTCallIdentity == 10000 )
        {
            g_CTCallIdentity = 1;
        }
    
        //lock the call so that nobody else would be able to delete the call
        for( iIndex=0; iIndex <  m_CTCallIDTable.GetAllocSize(); iIndex++ )
        {
            pCTCallIDContext = m_CTCallIDTable[iIndex] ;

            if( pCTCallIDContext != NULL )
            {
                if( pCTCallIDContext -> iCTCallIdentity == g_CTCallIdentity )
                {
                    break;
                }
            }
        }

        if( iIndex == m_CTCallIDTable.GetAllocSize() )
        {
            CTCallID = g_CTCallIdentity;
        }

    }while( CTCallID == 0 );

    pCTCallIDContext = new CTCALLID_CONTEXT;

    if( pCTCallIDContext == NULL )
    {
        m_CTCallIDTable.Unlock();
        return 0;
    }

    pCTCallIDContext->iCTCallIdentity = CTCallID;
    pCTCallIDContext->hdCall = hdCall;

    if( m_CTCallIDTable.Add(pCTCallIDContext) == -1 )
    {
        m_CTCallIDTable.Unlock();
        delete pCTCallIDContext;
        return 0;
    }

    m_CTCallIDTable.Unlock();
        
    H323DBG(( DEBUG_LEVEL_TRACE, "GetCTCallIdentity exited:%lx.",  hdCall ));
    
    return CTCallID;
}


void
CH323Line::SetCallForwardParams( 
    IN CALLFORWARDPARAMS* pCallForwardParams )
{
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams entered." ));
    
    if( m_pCallForwardParams != NULL )
    {
        FreeCallForwardParams( m_pCallForwardParams );
        m_pCallForwardParams = NULL;
    }
    m_pCallForwardParams = pCallForwardParams;

    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams exited." ));
}


BOOL
CH323Line::SetCallForwardParams(
    IN LPFORWARDADDRESS pForwardAddress
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams entered." ));
    
    if( m_pCallForwardParams != NULL )
    {
        pForwardAddress->next = m_pCallForwardParams->pForwardedAddresses;
        m_pCallForwardParams->pForwardedAddresses = pForwardAddress;
    }
    else
    {
        m_pCallForwardParams = new CALLFORWARDPARAMS;
        
        if( m_pCallForwardParams == NULL )
        {
            return FALSE;
        }

        ZeroMemory( m_pCallForwardParams, sizeof(CALLFORWARDPARAMS) );
        m_pCallForwardParams->fForwardingEnabled = TRUE;

        m_pCallForwardParams->pForwardedAddresses = pForwardAddress;
        pForwardAddress -> next = NULL;
    }


    //set unconditional forwarding
    m_pCallForwardParams->fForwardForAllOrigins = FALSE;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "SetCallForwardParams exited." ));
    
    return TRUE;
}



CH323Line::~CH323Line()
{
    if( m_dwInitState & LINEOBJECT_INITIALIZED )
    {
        DeleteCriticalSection (&m_CriticalSection);
    }
}


/*++

Routine Description:

    Hangs up call (if necessary) and closes call object.  

Arguments:

    Handle of the call.
Return Values:

    none.
    
--*/

void
CH323Line::H323ReleaseCall(
    IN HDRVCALL hdCall,
    IN DWORD dwDisconnectMode,
    IN WORD wCallReference
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "H323ReleaseCall entered:%lx.", hdCall ));

    int         iIndex = MakeCallIndex (hdCall);
    PH323_CALL  pCall;
    BOOL        fDelete = FALSE;

    LockCallTable();
    
    //lock the call so that nobody else would be able to delete the call
    if( (pCall=m_H323CallTable[iIndex]) && (hdCall==pCall->GetCallHandle()) )
    {
        pCall -> Lock();
        
        if( (wCallReference != 0) && 
            (wCallReference != pCall->GetCallRef()) )
        {
            //This message is for some other call. Ignore the message.
            H323DBG(( DEBUG_LEVEL_VERBOSE, "TSPI_CLOSE_CALL message ignored."));
        }
        else
        {
            // drop call using normal disconnect code
            pCall -> DropCall( dwDisconnectMode );
            pCall -> Shutdown( &fDelete );

            H323DBG(( DEBUG_LEVEL_VERBOSE, "call 0x%08lx closed.", pCall ));
        }

        pCall -> Unlock();

        //release the H323 call object
        if( fDelete == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_VERBOSE, "call delete:0x%08lx.", pCall ));
            delete pCall;
        }
    }
    
    UnlockCallTable();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323ReleaseCall exited: %p.", pCall ));
}


BOOL 
CH323Line::Initialize ( 
    IN  DWORD   dwLineDeviceIDBase)
{
    DWORD dwSize;
    H323DBG((DEBUG_LEVEL_TRACE, "line Initialize entered."));

    if( m_dwInitState & LINEOBJECT_INITIALIZED )
    {
        return TRUE;
    }

    __try
    {
        if( !InitializeCriticalSectionAndSpinCount( &m_CriticalSection,
            0x80000000 ) )
        {
            return FALSE;
        }
    }
    __except( 1 )
    {
        return FALSE;
    }

    m_dwDeviceID = dwLineDeviceIDBase;
    m_dwInitState = LINEOBJECT_INITIALIZED;
    //m_dwMediaModes = H323_LINE_MEDIAMODES;
    m_hdLine = (HDRVLINE__ *)this;
    m_dwNumRingsNoAnswer = H323_NUMRINGS_NOANSWER;

    dwSize = sizeof( m_wszAddr );

    //create displayable address
    GetComputerNameW( m_wszAddr, &dwSize );

    H323DBG(( DEBUG_LEVEL_TRACE, "line %d initialized (addr=%S)(hdLine=%d).",
        m_dwDeviceID, m_wszAddr, m_hdLine));

    // change line device state to closed
    m_nState = H323_LINESTATE_NONE;

    //init the mSP handles list
    m_MSPHandleList = NULL;

    H323DBG(( DEBUG_LEVEL_TRACE, "line Initialize exited." ));
    // success
    return TRUE;
}


BOOL
CH323Line::AddMSPInstance( 
    HTAPIMSPLINE htMSPLine,
    HDRVMSPLINE  hdMSPLine )
{
    MSPHANDLEENTRY* pMSPHandleEntry;

    H323DBG(( DEBUG_LEVEL_TRACE, "AddMSPInstance entered." ));
    Lock();

    pMSPHandleEntry = new MSPHANDLEENTRY;

    if( pMSPHandleEntry == NULL )
    {
        Unlock();
        return FALSE;
    }

    pMSPHandleEntry->htMSPLine = htMSPLine;
    pMSPHandleEntry->hdMSPLine = hdMSPLine;
    pMSPHandleEntry->next = m_MSPHandleList;
    m_MSPHandleList = pMSPHandleEntry;

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "AddMSPInstance exited." ));
    return TRUE;
}


BOOL
CH323Line::IsValidMSPHandle( 
    HDRVMSPLINE hdMSPLine,
    HTAPIMSPLINE* phtMSPLine )
{
    Lock();

    MSPHANDLEENTRY* pMSPHandle = m_MSPHandleList;
    while( pMSPHandle )
    {
        if( pMSPHandle->hdMSPLine == hdMSPLine )
        {
            *phtMSPLine = pMSPHandle->htMSPLine;
            Unlock();
            return TRUE;
        }
        pMSPHandle = pMSPHandle->next;
    }

    Unlock();
    return FALSE;
}


BOOL
CH323Line::DeleteMSPInstance( 
    HTAPIMSPLINE*   phtMSPLine,
    HDRVMSPLINE     hdMSPLine )
{
    MSPHANDLEENTRY* pMSPHandle;
    MSPHANDLEENTRY* pMSPHandleDel;
    BOOL            fRetVal = TRUE;

    H323DBG(( DEBUG_LEVEL_TRACE, "DeleteMSPInstance entered." ));
    Lock();

    if( m_MSPHandleList == NULL )
    {
        fRetVal = FALSE;
        goto func_exit;
    }

    if( m_MSPHandleList->hdMSPLine == hdMSPLine )
    {
        *phtMSPLine = m_MSPHandleList->htMSPLine;
        
        pMSPHandleDel = m_MSPHandleList;
        m_MSPHandleList = m_MSPHandleList->next;

        delete pMSPHandleDel;
        fRetVal = TRUE;
        goto func_exit;
    }

    for( pMSPHandle=m_MSPHandleList; pMSPHandle->next; pMSPHandle=pMSPHandle->next )
    {
        if( pMSPHandle->next->hdMSPLine == hdMSPLine )
        {
            *phtMSPLine = pMSPHandle->next->htMSPLine;
            
            pMSPHandleDel = pMSPHandle->next;
            pMSPHandle->next = pMSPHandle->next->next;
        
            delete pMSPHandleDel;
            fRetVal = TRUE;
            goto func_exit;
        }
    }

func_exit:
    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "DeleteMSPInstance exited." ));
    return fRetVal;
}


//!!always called in a lock
void 
CH323Line::ShutdownAllCalls(void)
{

    PH323_CALL pCall;
    H323_CONFERENCE* pConf;
    DWORD indexI;
    DWORD dwSize;
    BOOL fDelete = FALSE;

    if( !(m_dwInitState & LINEOBJECT_INITIALIZED) )
        return;

    H323DBG((DEBUG_LEVEL_TRACE, "ShutdownAllCalls entered."));
    
    if( m_dwInitState & LINEOBJECT_SHUTDOWN )
    {
        return;
    }

    //shutdown all calls, delete all calls
    LockCallTable();
    dwSize = m_H323CallTable.GetAllocSize();
    for( indexI=0; indexI <  dwSize; indexI++ )
    {
        pCall = m_H323CallTable[indexI];
        if( pCall != NULL )
        {
            pCall -> DropCall( 0 );
            pCall -> Shutdown(&fDelete);

            if(fDelete)
            {
                H323DBG((DEBUG_LEVEL_TRACE, "call delete:%p.", pCall ));
                delete pCall;
            }
        }

    }
    UnlockCallTable();

    dwSize = m_H323ConfTable.GetSize();
    for( indexI=0; indexI < dwSize; indexI++ )
    {
        pConf = m_H323ConfTable[indexI];
        //m_H323ConfTable.RemoveAt( indexI );
        if( pConf != NULL )
        {
            delete pConf;
            m_H323ConfTable[indexI] = NULL;
        }
    }

    H323DBG((DEBUG_LEVEL_TRACE, "ShutdownAllCalls exited."));
}


void
CH323Line::Shutdown(void)
{
    BOOL            fDelete = FALSE;
    MSPHANDLEENTRY* pMSPHandle;

    if( !(m_dwInitState & LINEOBJECT_INITIALIZED) )
    {
        return;
    }

    H323DBG((DEBUG_LEVEL_TRACE, "line Shutdown entered."));
    
    Lock();
    if( m_dwInitState & LINEOBJECT_SHUTDOWN )
    {
        Unlock();
        return;
    }

    FreeCallForwardParams( m_pCallForwardParams );
    m_pCallForwardParams = NULL;

    Close();

    m_dwMediaModes = NULL;
    //m_hdLine = NULL;
    m_hdNextMSPHandle = NULL;
    m_htLine = NULL;

    //Free the MSP handles list
    while( m_MSPHandleList )
    {
        pMSPHandle = m_MSPHandleList;
        m_MSPHandleList = m_MSPHandleList->next;
        delete pMSPHandle;
    }

    m_dwInitState |= LINEOBJECT_SHUTDOWN;

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "line Shutdown exited." ));
}


LONG
CH323Line::CopyLineInfo(
    IN DWORD dwDeviceID,
    OUT LPLINEADDRESSCAPS pAddressCaps
    )
{
    DWORD dwAddressSize;
        
    H323DBG((DEBUG_LEVEL_TRACE, "line CopyLineInfo entered."));
    
    // determine size of address name
    dwAddressSize = H323SizeOfWSZ( m_wszAddr );

    // calculate number of bytes needed
    pAddressCaps->dwNeededSize = sizeof(LINEADDRESSCAPS) + 
                                 dwAddressSize
                                 ;

    // validate buffer allocated is large enough
    if (pAddressCaps->dwTotalSize >= pAddressCaps->dwNeededSize)
    {
        // record amount of memory used
        pAddressCaps->dwUsedSize = pAddressCaps->dwNeededSize;

        // position address name after fixed portion
        pAddressCaps->dwAddressSize = dwAddressSize;
        pAddressCaps->dwAddressOffset = sizeof(LINEADDRESSCAPS);
    
        // copy address name after fixed portion
        CopyMemory((LPBYTE)pAddressCaps + pAddressCaps->dwAddressOffset,
            (LPBYTE)m_wszAddr,
            pAddressCaps->dwAddressSize );
    }
    else if (pAddressCaps->dwTotalSize >= sizeof(LINEADDRESSCAPS))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "lineaddresscaps structure too small for strings." ));

        // record amount of memory used
        pAddressCaps->dwUsedSize = sizeof(LINEADDRESSCAPS);

    } 
    else 
    {
        H323DBG((DEBUG_LEVEL_ERROR, "lineaddresscaps structure too small."));

        // allocated structure too small 
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "addr 0 capabilities requested." ));
    
    // transfer associated device id 
    pAddressCaps->dwLineDeviceID = dwDeviceID;

    // initialize number of calls allowed per address 
    pAddressCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERADDR;

    // initialize supported address capabilities
    pAddressCaps->dwAddressSharing     = H323_ADDR_ADDRESSSHARING;
    pAddressCaps->dwCallInfoStates     = H323_ADDR_CALLINFOSTATES;
    pAddressCaps->dwCallStates         = H323_ADDR_CALLSTATES;
    pAddressCaps->dwDisconnectModes    = H323_ADDR_DISCONNECTMODES;
    pAddressCaps->dwAddrCapFlags       = H323_ADDR_CAPFLAGS;
    pAddressCaps->dwCallFeatures       = H323_ADDR_CALLFEATURES;
    pAddressCaps->dwAddressFeatures    = H323_ADDR_ADDRFEATURES;
    pAddressCaps->dwCallerIDFlags      = H323_ADDR_CALLPARTYIDFLAGS;
    pAddressCaps->dwCalledIDFlags      = H323_ADDR_CALLPARTYIDFLAGS;

    // initialize unsupported address capabilities
    pAddressCaps->dwConnectedIDFlags   = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectionIDFlags = LINECALLPARTYID_UNAVAIL;
    pAddressCaps->dwRedirectingIDFlags = LINECALLPARTYID_UNAVAIL;
        
    H323DBG((DEBUG_LEVEL_TRACE, "line CopyLineInfo exited."));
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetAddressCaps - Exited." ));
    // success
    return NOERROR;
}

        
/*++

Routine Description:

    Initiate activities on line device and allocate resources.

Arguments:

    htLine - TAPI's handle describing line device to open.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

Return Values:

    Returns true if successful.
    
--*/

LONG CH323Line::Open(
    IN  DWORD       DeviceID,
    IN  HTAPILINE   TapiLine,
    IN  DWORD       TspiVersion,
    IN  HDRVLINE *  ReturnDriverLine)
{
    HRESULT     hr;
    LONG        dwStatus = ERROR_SUCCESS;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line open entered." ));

    if (GetDeviceID() != DeviceID)
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support    
    if (!H323ValidateTSPIVersion (TspiVersion))
    {
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    Lock();

    switch (m_nState)
    {

    case H323_LINESTATE_OPENED:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line is already open (H323_LINESTATE_OPENED), cannot reopen"));
        dwStatus = LINEERR_INUSE;
        break;

    case H323_LINESTATE_LISTENING:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line is already open (H323_LINESTATE_LISTENING), cannot reopen"));
        dwStatus = LINEERR_INUSE;
        break;

    case H323_LINESTATE_CLOSING:
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "H323 line cannot be opened (H323_LINESTATE_CLOSING)"));
        dwStatus = LINEERR_INVALLINESTATE;
        break;

    case H323_LINESTATE_OPENING:
        H323DBG ((DEBUG_LEVEL_ERROR,
            "H323 line cannot be opened (H323_LINESTATE_OPENING)"));
        dwStatus = LINEERR_INVALLINESTATE;
        break;

    case H323_LINESTATE_NONE:
        // attempt to open line device

        H323DBG ((DEBUG_LEVEL_TRACE, "H323 line is opening"));

        // start listen if necessary
        if (IsMediaDetectionEnabled())
        {
            hr = Q931AcceptStart();
            if (hr == S_OK)
            {
                dwStatus = ERROR_SUCCESS;
                RasStart();
            }
            else
            {
                H323DBG ((DEBUG_LEVEL_ERROR, "failed to listen on Q.931"));
                dwStatus = LINEERR_OPERATIONFAILED;
            }
        }

        if (dwStatus == ERROR_SUCCESS)
        {
            H323DBG ((DEBUG_LEVEL_TRACE, "H323 line successfully opened"));

            // save line variables now
            m_nState = IsMediaDetectionEnabled()?
                H323_LINESTATE_LISTENING:H323_LINESTATE_OPENED;
            m_htLine = TapiLine;
            m_dwTSPIVersion = TspiVersion;
            *ReturnDriverLine = (HDRVLINE) this;
        }
        else
        {
            Q931AcceptStop();
        }
        break;

    default:
        _ASSERTE( FALSE );
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line open exited." ));
    return dwStatus;
}


/*++
Routine Description:

    Terminate activities on line device.

Arguments:

Return Values:

    Returns true if successful.

--*/
LONG
CH323Line::Close(void)
{
    LONG    dwStatus;

    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line close entered." ));

    Lock();

    switch (m_nState)
    {
    case H323_LINESTATE_OPENED:
    case H323_LINESTATE_LISTENING: 

        if( m_fForwardConsultInProgress == TRUE )
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "H323 line closed while forward is in progress." ));
            //Unlock();
            //return NOERROR;
        }

        // change line device state to closing
        m_nState = H323_LINESTATE_CLOSING;

        //shutdown all the calls
        ShutdownAllCalls();

        RasStop();

        if (IsMediaDetectionEnabled())
        {
            Q931AcceptStop();
        }
            
        ShutdownCTCallIDTable();

        // reset variables
        m_htLine = (HTAPILINE) NULL;
        m_dwTSPIVersion = 0;

        // change line device state to closed
        m_nState = H323_LINESTATE_NONE;
        dwStatus = ERROR_SUCCESS;
        break;

    default:
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "H323: lineclose called in bogus state:%d", m_nState ));
        dwStatus = LINEERR_OPERATIONFAILED;
        break;
    }

    Unlock();
    H323DBG(( DEBUG_LEVEL_TRACE, "H323 line close exited." ));
    return dwStatus;
}


//                                                                           
// TSPI procedures                                                           
//                                                                           

        
/*++
Routine Description:

    This function closes the specified open line device after completing or 
    aborting all outstanding calls and asynchronous operations on the device.

    The Service Provider has the responsibility to (eventually) report 
    completion for every operation it decides to execute asynchronously.  
    If this procedure is called for a line on which there are outstanding 
    asynchronous operations, the operations should be reported complete with an
    appropriate result or error code before this procedure returns.  Generally
    the TAPI DLL would wait for these to complete in an orderly fashion.  
    However, the Service Provider should be prepared to handle an early call to
    TSPI_lineClose in "abort" or "emergency shutdown" situtations.

    A similar requirement exists for active calls on the line.  Such calls must 
    be dropped, with outstanding operations reported complete with appropriate 
    result or error codes.
    
    After this procedure returns the Service Provider must report no further 
    events on the line or calls that were on the line.  The Service Provider's 
    opaque handles for the line and calls on the line become "invalid".

    The Service Provider must relinquish non-sharable resources it reserves 
    while the line is open.  For example, closing a line accessed through a 
    comm port and modem should result in closing the comm port, making it once 
    available for use by other applications.

    This function is presumed to complete successfully and synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to be
        closed.  After the line has been successfully closed, this handle is 
        no longer valid.

Return Values:

    Returns zero if the function is successful, or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified device handle is invalid.
        
        LINEERR_OPERATIONFAILED - The specified operation failed for unknown 
            reasons.

--*/
LONG
TSPIAPI
TSPI_lineClose (
    IN  HDRVLINE    DriverLine)
{
    _ASSERTE(DriverLine);
    _ASSERTE(DriverLine == (HDRVLINE) &g_H323Line);

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineClose - Entered." ));
    return ((CH323Line *) DriverLine) -> Close();
}


/*++
Routine Description:

    This function queries a specified line device to determine its telephony 
    capabilities. The returned information is valid for all addresses on the 
    line device.

    Line device ID numbering for a Service Provider is sequential from the 
    value set by the function TSPI_lineSetDeviceIDBase.

    The dwExtVersion field of pLineDevCaps has already been filled in to 
    indicate the version number of the Extension information requested.  If 
    it is zero, no Extension information is requested.  If it is non-zero it 
    holds a value that has already been negotiated for this device with the 
    function TSPI_lineNegotiateExtVersion.  The Service Provider should fill 
    in Extension information according to the Extension version specified.

    One of the fields in the LINEDEVCAPS structure returned by this function 
    contains the number of addresses assigned to the specified line device. 
    The actual address IDs used to reference individual addresses vary from 
    zero to one less than the returned number. The capabilities of each 
    address may be different. Use TSPI_lineGetAddressCaps for each available 
    <dwDeviceID, dwAddressID> combination to determine the exact capabilities 
    of each address.

Arguments:

    dwDeviceID - Specifies the line device to be queried.

    dwTSPIVersion - Specifies the negotiated TSPI version number.  This value 
        has already been negotiated for this device through the 
        TSPI_lineNegotiateTSPIVersion function.

    pLineDevCaps - Specifies a far pointer to a variable sized structure of 
        type LINEDEVCAPS. Upon successful completion of the request, this 
        structure is filled with line device capabilities information.

Return Values:

    Returns zero if the function is successful or a negative error
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API 
            version or version range that is either incompatible or cannot 
            be supported by the Telephony API implementation and/or 
            corresponding service provider. 

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure 
            does not specify enough memory to contain the fixed portion of 
            the structure. The dwNeededSize field has been set to the amount 
            required.

--*/
LONG
TSPIAPI
TSPI_lineGetDevCaps(
    DWORD         dwDeviceID,
    DWORD         dwTSPIVersion,
    DWORD         dwExtVersion,
    LPLINEDEVCAPS pLineDevCaps
    )
{
    DWORD dwLineNameSize;
    DWORD dwProviderInfoSize;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevCaps - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // make sure this is a version we support
    if (!H323ValidateTSPIVersion(dwTSPIVersion))
    {
        // do not support tspi version
        return LINEERR_INCOMPATIBLEAPIVERSION;
    }

    // determine string lengths    
    dwProviderInfoSize  = H323SizeOfWSZ(g_pwszProviderInfo);
    dwLineNameSize      = H323SizeOfWSZ(g_pwszLineName);

    // calculate number of bytes required 
    pLineDevCaps->dwNeededSize = sizeof(LINEDEVCAPS) +
                                 dwProviderInfoSize  +
                                 dwLineNameSize     
                                 ;

    // make sure buffer is large enough for variable length data
    if (pLineDevCaps->dwTotalSize >= pLineDevCaps->dwNeededSize)
    {
        // record amount of memory used
        pLineDevCaps->dwUsedSize = pLineDevCaps->dwNeededSize;

        // position provider info after fixed portion
        pLineDevCaps->dwProviderInfoSize = dwProviderInfoSize;
        pLineDevCaps->dwProviderInfoOffset = sizeof(LINEDEVCAPS);

        // position line name after device class
        pLineDevCaps->dwLineNameSize = dwLineNameSize;
        pLineDevCaps->dwLineNameOffset = 
            pLineDevCaps->dwProviderInfoOffset +
            pLineDevCaps->dwProviderInfoSize
            ;

        // copy provider info after fixed portion
        CopyMemory((LPBYTE)pLineDevCaps + pLineDevCaps->dwProviderInfoOffset,
               (LPBYTE)g_pwszProviderInfo,
               pLineDevCaps->dwProviderInfoSize
               );
                
        // copy line name after device class
        CopyMemory((LPBYTE)pLineDevCaps + pLineDevCaps->dwLineNameOffset,
               (LPBYTE)g_pwszLineName,
               pLineDevCaps->dwLineNameSize
               );

    } 
    else if (pLineDevCaps->dwTotalSize >= sizeof(LINEDEVCAPS))
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "linedevcaps structure too small for strings." ));

        // structure only contains fixed portion
        pLineDevCaps->dwUsedSize = sizeof(LINEDEVCAPS);

    } 
    else 
    {
        H323DBG(( DEBUG_LEVEL_WARNING, "linedevcaps structure too small." ));

        // structure is too small
        return LINEERR_STRUCTURETOOSMALL;
    }

    H323DBG(( DEBUG_LEVEL_VERBOSE, "line capabilities requested."));
    
    // construct permanent line identifier
    pLineDevCaps->dwPermanentLineID = (DWORD)MAKELONG(
        dwDeviceID - g_dwLineDeviceIDBase,
        g_dwPermanentProviderID
        );

    // notify tapi that strings returned are in unicode
    pLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;

    // initialize line device capabilities
    pLineDevCaps->dwNumAddresses      = H323_MAXADDRSPERLINE;
    pLineDevCaps->dwMaxNumActiveCalls = H323_MAXCALLSPERLINE;
    pLineDevCaps->dwAddressModes      = H323_LINE_ADDRESSMODES;
    pLineDevCaps->dwBearerModes       = H323_LINE_BEARERMODES;
    pLineDevCaps->dwDevCapFlags       = H323_LINE_DEVCAPFLAGS;
    pLineDevCaps->dwLineFeatures      = H323_LINE_LINEFEATURES;
    pLineDevCaps->dwMaxRate           = H323_LINE_MAXRATE;
    pLineDevCaps->dwMediaModes        = H323_LINE_MEDIAMODES;
    pLineDevCaps->dwRingModes         = 0;

    // initialize address types to include phone numbers
    pLineDevCaps->dwAddressTypes = H323_LINE_ADDRESSTYPES;

    // line guid
    pLineDevCaps->PermanentLineGuid = LINE_H323;

    // modify GUID to be unique for each line
    pLineDevCaps->PermanentLineGuid.Data1 +=
        dwDeviceID - g_dwLineDeviceIDBase;

    // protocol guid
    pLineDevCaps->ProtocolGuid = TAPIPROTOCOL_H323;

    // add dtmf support via H.245 user input messages
    pLineDevCaps->dwGenerateDigitModes = LINEDIGITMODE_DTMF;
    pLineDevCaps->dwMonitorDigitModes  = LINEDIGITMODE_DTMF;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevCaps - Exited." ));
    // success
    return NOERROR;
}

    
/*++
Routine Description:

    This operation enables the TAPI DLL to query the specified open line 
    device for its current status.

    The TAPI DLL uses TSPI_lineGetLineDevStatus to query the line device 
    for its current line status. This status information applies globally 
    to all addresses on the line device. Use TSPI_lineGetAddressStatus to 
    determine status information about a specific address on a line.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    pLineDevStatus - Specifies a far pointer to a variable sized data 
        structure of type LINEDEVSTATUS. Upon successful completion of 
        the request, this structure is filled with the line's device status.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.

--*/
LONG
TSPIAPI
TSPI_lineGetLineDevStatus(
    HDRVLINE        hdLine,
    LPLINEDEVSTATUS pLineDevStatus
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevStatus - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    // determine number of bytes needed
    pLineDevStatus->dwNeededSize = sizeof(LINEDEVSTATUS);
    
    // see if allocated structure is large enough
    if (pLineDevStatus->dwTotalSize < pLineDevStatus->dwNeededSize)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "linedevstatus structure too small." ));

        // structure too small
        return LINEERR_STRUCTURETOOSMALL;
    }
    
    // record number of bytes used
    pLineDevStatus->dwUsedSize = pLineDevStatus->dwNeededSize;
    
    // initialize supported line device status fields
    pLineDevStatus->dwLineFeatures   = H323_LINE_LINEFEATURES;
    pLineDevStatus->dwDevStatusFlags = H323_LINE_DEVSTATUSFLAGS;

    // determine number of active calls on the line device
    pLineDevStatus -> dwNumActiveCalls = g_pH323Line -> GetNoOfCalls();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetDevStatus - Exited." ));
    // success
    return NOERROR;
}


/*++
Routine Description:

    Retrieves the number of address IDs supported on the indicated line.

    This function is called by TAPI.DLL in response to an application calling
    lineSetNumRings, lineGetNumRings, or lineGetNewCalls. TAPI.DLL uses the 
    retrieved value to determine if the specified address ID is within the 
    range supported by the service provider.

Arguments:

    hdLine - Specifies the handle to the line for which the number of address 
        IDs is to be retrieved.

    pdwNumAddressIDs - Specifies a far pointer to a DWORD. The location is 
        filled with the number of address IDs supported on the indicated line. 
        The value should be one or larger.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_INVALLINEHANDLE - The specified line device handle is invalid.

--*/
LONG
TSPIAPI
TSPI_lineGetNumAddressIDs(
    HDRVLINE hdLine,
    LPDWORD  pdwNumAddressIDs
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - bad linehandle:%lx, %lx.",
            hdLine, g_pH323Line -> GetHDLine() ));
        return LINEERR_INVALLINEHANDLE ;
    }

    // transfer number of addresses
    *pdwNumAddressIDs = H323_MAXADDRSPERLINE;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetNumAddressIDs - Exited." ));
    // success
    return NOERROR;
}

    
/*++

Routine Description:

    This function opens the line device whose device ID is given, returning 
    the Service Provider's opaque handle for the device and retaining the TAPI
    DLL's opaque handle for the device for use in subsequent calls to the 
    LINEEVENT procedure.

    Opening a line entitles the TAPI DLL to make further requests on the line.
    The line becomes "active" in the sense that the TAPI DLL can initiate 
    outbound calls and the Service Provider can report inbound calls.  The 
    Service Provider reserves whatever non-sharable resources are required to 
    manage the line.  For example, opening a line accessed through a comm port 
    and modem should result in opening the comm port, making it no longer 
    available for use by other applications.
    
    If the function is successful, both the TAPI DLL and the Service Provider 
    become committed to operating under the specified interface version number 
    for this open device.  Subsquent operations and events identified using 
    the exchanged opaque line handles conform to that interface version.  This 
    commitment and the validity of the handles remain in effect until the TAPI
    DLL closes the line using the TSPI_lineClose operation or the Service 
    Provider reports the LINE_CLOSE event.  If the function is not successful,
    no such commitment is made and the handles are not valid.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    htLine - Specifies the TAPI DLL's opaque handle for the line device to be 
        used in subsequent calls to the LINEEVENT callback procedure to 
        identify the device.

    phdLine - A far pointer to a HDRVLINE where the Service Provider fills in
        its opaque handle for the line device to be used by the TAPI DLL in 
        subsequent calls to identify the device.

    dwTSPIVersion - The TSPI version negotiated through 
        TSPI_lineNegotiateTSPIVersion under which the Service Provider is 
        willing to operate.

    pfnEventProc - A far pointer to the LINEEVENT callback procedure supplied
        by the TAPI DLL that the Service Provider will call to report 
        subsequent events on the line.

Return Values:

    Returns zero if the function is successful, or a negative error number 
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The passed TSPI version or version 
            range did not match an interface version definition supported by 
            the service provider.

        LINEERR_INUSE - The line device is in use and cannot currently be 
            configured, allow a party to be added, allow a call to be 
            answered, or allow a call to be placed. 

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/
LONG
TSPIAPI
TSPI_lineOpen (
    IN  DWORD       DeviceID,
    IN  HTAPILINE   TapiLine,
    IN  LPHDRVLINE  ReturnDriverLine,
    IN  DWORD       TspiVersion,
    IN  LINEEVENT   pfnEventProc)
{
    return g_H323Line.Open (DeviceID, TapiLine, TspiVersion, ReturnDriverLine);
}


LONG
TSPIAPI
TSPI_lineCreateMSPInstance(
    HDRVLINE        hdLine,
    DWORD           dwAddressID,
    HTAPIMSPLINE    htMSPLine,
    LPHDRVMSPLINE   phdMSPLine
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCreateMSPInstance - Entered." ));

    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    // We are not keeping the msp handles. Just fake a handle here.
    *phdMSPLine = g_pH323Line->GetNextMSPHandle();

    if( !g_pH323Line->AddMSPInstance( htMSPLine , *phdMSPLine ) )
    {
        return LINEERR_NOMEM;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP instance created. hdMSP:%lx, htMSP:%lx.",
        *phdMSPLine, htMSPLine ));

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCreateMSPInstance - Exited." ));
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineCloseMSPInstance(
    HDRVMSPLINE hdMSPLine
    )
{
    HTAPIMSPLINE    htMSPLine;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseMSPInstance - Entered." ));

    if( !g_pH323Line->DeleteMSPInstance( &htMSPLine , hdMSPLine ) )
    {
        return LINEERR_INVALPOINTER;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "MSP instance deleted. hdMSP:%lx, htMSP:%lx.",
        hdMSPLine, htMSPLine ));

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCloseMSPInstance - Exited." ));

    // success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\line.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    line.h

Abstract:

    Definitions for H.323 TAPI Service Provider line device.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _LINE_H_
#define _LINE_H_
 

//                                                                           
// Header files                                                              
//                                                                           


#include "call.h"

extern H323_OCTETSTRING g_ProductID;
extern H323_OCTETSTRING g_ProductVersion;


enum LINEOBJECT_STATE
{
    LINEOBJECT_INITIALIZED  = 0x00000001,
    LINEOBJECT_SHUTDOWN     = 0x00000002,

};


//                                                                           
// Line device GUID                                                          
//                                                                           


DEFINE_GUID(LINE_H323,
0xe41e1898, 0x7292, 0x11d2, 0xba, 0xd6, 0x00, 0xc0, 0x4f, 0x8e, 0xf6, 0xe3);



//                                                                           
// Line capabilities                                                         
//                                                                           
#define H323_MAXADDRSPERLINE        1
#define H323_MAXCALLSPERADDR        32768        
                                
#define H323_LINE_ADDRESSMODES      LINEADDRESSMODE_ADDRESSID
#define H323_LINE_ADDRESSTYPES     (LINEADDRESSTYPE_DOMAINNAME  | \
                                    LINEADDRESSTYPE_IPADDRESS   | \
                                    LINEADDRESSTYPE_PHONENUMBER | \
                                    LINEADDRESSTYPE_EMAILNAME)
#define H323_LINE_BEARERMODES      (LINEBEARERMODE_DATA | \
                                    LINEBEARERMODE_VOICE)
#define H323_LINE_DEFMEDIAMODES     LINEMEDIAMODE_AUTOMATEDVOICE
#define H323_LINE_DEVCAPFLAGS      (LINEDEVCAPFLAGS_CLOSEDROP   | \
                                    LINEDEVCAPFLAGS_MSP         | \
                                    LINEDEVCAPFLAGS_LOCAL )
#define H323_LINE_DEVSTATUSFLAGS   (LINEDEVSTATUSFLAGS_CONNECTED | \
                                    LINEDEVSTATUSFLAGS_INSERVICE)
#define H323_LINE_MAXRATE           1048576 //1 mbps
#define H323_LINE_MEDIAMODES       (H323_LINE_DEFMEDIAMODES | \
                                    LINEMEDIAMODE_INTERACTIVEVOICE | \
                                    LINEMEDIAMODE_VIDEO)
#define H323_LINE_LINEFEATURES     (LINEFEATURE_MAKECALL    | \
                                    LINEFEATURE_FORWARD     | \
                                    LINEFEATURE_FORWARDFWD )    

//
// Type definitions                                                    
//                                                          


typedef enum _H323_LINESTATE 
{
    H323_LINESTATE_NONE = 0, //before call to LineOPen
    H323_LINESTATE_OPENED,        //after call to lineOpen
    H323_LINESTATE_OPENING,
    H323_LINESTATE_CLOSING,
    H323_LINESTATE_LISTENING

} H323_LINESTATE, *PH323_LINESTATE;


typedef struct _TAPI_LINEREQUEST_DATA
{
    DWORD EventID;
    HDRVCALL hdCall1;
    union {
    HDRVCALL hdCall2;
    DWORD    dwDisconnectMode;
    };
    WORD     wCallReference;

} TAPI_LINEREQUEST_DATA;


typedef struct _CTCALLID_CONTEXT
{
    int         iCTCallIdentity;
    HDRVCALL	hdCall;

}CTCALLID_CONTEXT, *PCTCALLID_CONTEXT;


typedef struct _MSPHANDLEENTRY
{

    struct _MSPHANDLEENTRY* next;
    HTAPIMSPLINE            htMSPLine;
    HDRVMSPLINE             hdMSPLine;

} MSPHANDLEENTRY;


typedef TSPTable<PCTCALLID_CONTEXT>   CTCALLID_TABLE;


class CH323Line
{

    CRITICAL_SECTION    m_CriticalSection;                   // synchronization object
    H323_LINESTATE      m_nState;                // state of line object
    DWORD               m_dwTSPIVersion;        // tapi selected version
    DWORD               m_dwMediaModes;         // tapi selected media modes
    H323_CALL_TABLE     m_H323CallTable;        // table of allocated calls
    H323_VENDORINFO     m_VendorInfo;
    DWORD               m_dwDeviceID;           // tapi line device id
    WCHAR               m_wszAddr[H323_MAXADDRNAMELEN+1]; // line address
    HDRVLINE            m_hdLine;               // tspi line handle
    DWORD               m_dwInitState;
    HDRVMSPLINE         m_hdNextMSPHandle;      // bogus msp handle count
    H323_CONF_TABLE     m_H323ConfTable;        // table of allocated calls
    CALLFORWARDPARAMS*  m_pCallForwardParams;
    DWORD               m_dwInvokeID;
    CTCALLID_TABLE      m_CTCallIDTable;
    MSPHANDLEENTRY*     m_MSPHandleList;
    
    void ShutdownAllCalls(void);
    void ShutdownCTCallIDTable();
    PH323_CALL CreateNewTransferedCall( IN PH323_ALIASNAMES pwszCalleeAddr );

public:

    
    
    //public data members
    BOOLEAN             m_fForwardConsultInProgress;
    DWORD               m_dwNumRingsNoAnswer;
    HTAPILINE           m_htLine;   // tapi line handle
    
    //public functions

    CH323Line();
    BOOL Initialize( DWORD dwLineDeviceIDBase );
    ~CH323Line();
    void Shutdown(void);
    
    void RemoveFromCTCallIdentityTable( HDRVCALL hdCall );
    HDRVCALL GetCallFromCTCallIdentity( int iCTCallID );
    int GetCTCallIdentity( IN HDRVCALL hdCall );
    void SetCallForwardParams( IN CALLFORWARDPARAMS* pCallForwardParams );
    BOOL SetCallForwardParams( IN LPFORWARDADDRESS pForwardAddress );
    PH323_CALL FindH323CallAndLock( IN	HDRVCALL hdCall );
    PH323_CALL FindCallByARQSeqNumAndLock( WORD seqNumber );
    PH323_CALL FindCallByDRQSeqNumAndLock( WORD seqNumber );
    PH323_CALL FindCallByCallRefAndLock( WORD wCallRef );
    PH323_CALL Find2H323CallsAndLock( IN	HDRVCALL hdCall1,
        IN HDRVCALL hdCall2, OUT PH323_CALL * ppCall2 );
    BOOL AddMSPInstance( HTAPIMSPLINE htMSPLine, HDRVMSPLINE  hdMSPLine );
    BOOL IsValidMSPHandle( HDRVMSPLINE hdMSPLine, HTAPIMSPLINE* phtMSPLine );
    BOOL DeleteMSPInstance( HTAPIMSPLINE*   phtMSPLine,
        HDRVMSPLINE hdMSPLine );
    LONG Close();
    LONG CopyLineInfo(DWORD dwDeviceID, LPLINEADDRESSCAPS pAddressCaps );
    void H323ReleaseCall( HDRVCALL hdCall, IN DWORD dwDisconnectMode, 
        IN WORD wCallReference );
    BOOL CallReferenceDuped(WORD wCallReference);


    //supplementary services functionality
    LONG CopyAddressForwardInfo( IN LPLINEADDRESSSTATUS lpAddressStatus );
    PH323_ALIASITEM CallToBeDiverted( IN WCHAR* pwszCallerName,
        IN DWORD  dwCallerNameSize, IN DWORD dwForwardMode );
    void PlaceDivertedCall( IN HDRVCALL hdCall, 
        IN PH323_ALIASNAMES pDivertedToAlias );
    void PlaceTransferedCall(IN HDRVCALL hdCall, 
        IN PH323_ALIASNAMES pTransferedToAlias);
    void SwapReplacementCall(
		HDRVCALL hdReplacementCall, 
        HDRVCALL hdPrimaryCall,
        BOOL fChangeCallState );

    
    H323_CONF_TABLE* GetH323ConfTable()
    {
        return &m_H323ConfTable;
    }

    HDRVMSPLINE GetNextMSPHandle()
    {
        return ++m_hdNextMSPHandle;
    }

    HDRVLINE GetHDLine()
    {
        return m_hdLine;
    }
    
    DWORD GetDeviceID()
    {
        return m_dwDeviceID;
    }

    PH323_CALL 
    GetCallAtIndex( int iIndex ) 
    {
        return m_H323CallTable[iIndex];
    }
    
    CALLFORWARDPARAMS* GetCallForwardParams()
    {
        return m_pCallForwardParams;
    }
    
    BOOL ForwardEnabledForAllOrigins(void)
    {
        return
            (
                m_pCallForwardParams &&
                (m_pCallForwardParams ->fForwardForAllOrigins == TRUE) &&
                (m_pCallForwardParams ->fForwardingEnabled = TRUE)
            );
    }

    H323_VENDORINFO *GetVendorInfo()
    {
        return &m_VendorInfo;
    }

    WCHAR * GetMachineName()
    {
        return m_wszAddr;
    }

    //!!must be always called in a lock
    WORD GetNextInvokeID()
    {
        return (WORD)InterlockedIncrement( (LONG*)&m_dwInvokeID );
    }

    BOOL IsValidAddressID( DWORD dwID )
    {
        return (dwID == 0);
    }
    
    void Lock()
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line waiting on lock." ));
        EnterCriticalSection( &m_CriticalSection );
        
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line locked." ));
    }

    void Unlock()
    {
        LeaveCriticalSection( &m_CriticalSection );
        
        H323DBG(( DEBUG_LEVEL_VERBOSE, "H323 line unlocked." ));
    }

    int GetNoOfCalls()
    {
        DWORD dwNumCalls;

        LockCallTable();
        dwNumCalls = m_H323CallTable.GetSize();
        UnlockCallTable();
        return dwNumCalls;
    }

    //!!must be always called after locking the call table.
    int GetCallTableSize()
    {
        return m_H323CallTable.GetAllocSize();
    }

    //!This function should not be called while holding a lock on a call object
    //!When called from shutdown the calltable object is locked before the call object, so its OK.
    void RemoveCallFromTable(
                               HDRVCALL hdCall
                            )
    {
        m_H323CallTable.RemoveAt( LOWORD(hdCall) );
    }

    //!This function should not be called while holding a lock on a call object
    int AddCallToTable( 
                        PH323_CALL pCall
                       )
    {
        return m_H323CallTable.Add( pCall );
    }
 
    void DisableCallForwarding()
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "DisableCallForwarding -Entered" ));

        if( m_pCallForwardParams != NULL )
        {
            FreeCallForwardParams( m_pCallForwardParams );
            m_pCallForwardParams = NULL;
        }

        H323DBG(( DEBUG_LEVEL_TRACE, "DisableCallForwarding -Exited" ));
    }

    //!This function should not be called while holding a lock on a call object
    void LockCallTable()
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "Waiting on call table lock - %p.",
            m_H323CallTable ));
        
        m_H323CallTable.Lock();

        H323DBG(( DEBUG_LEVEL_TRACE, "Call table locked - %p.",
            m_H323CallTable ));
    }

    void UnlockCallTable()
    {
        m_H323CallTable.Unlock();
        
        H323DBG(( DEBUG_LEVEL_TRACE, "Call table lock released - %p.",
            m_H323CallTable ));
    }

    H323_LINESTATE  GetState()
    {
        return m_nState;
    }

    void SetState( H323_LINESTATE  nState )
    {
        m_nState = nState;
    }

    DWORD GetMediaModes()
    {
        return m_dwMediaModes;
    }

    void SetMediaModes( 
                        DWORD dwMediaModes
                       )
    {
        m_dwMediaModes = dwMediaModes;
    }

    BOOL IsMediaDetectionEnabled() 
    {
        return  (m_dwMediaModes != 0) && 
                (m_dwMediaModes != LINEMEDIAMODE_UNKNOWN);
    }

    LONG	Open	(
		IN	DWORD		DeviceID,
		IN	HTAPILINE	TapiLine,
		IN	DWORD		TspiVersion,
		OUT	HDRVLINE *	ReturnDriverLine);

};




//                                                                           
// Address capabilities                                                      
//                                                                           


#define H323_NUMRINGS_LO           4
#define H323_NUMRINGS_NOANSWER      8
#define H323_NUMRINGS_HI           12

#define H323_ADDR_ADDRESSSHARING    LINEADDRESSSHARING_PRIVATE
#define H323_ADDR_ADDRFEATURES      (LINEADDRFEATURE_MAKECALL | LINEADDRFEATURE_FORWARD)
#define H323_ADDR_CALLFEATURES     (LINECALLFEATURE_ACCEPT | \
                                    LINECALLFEATURE_ANSWER | \
                                    LINECALLFEATURE_DROP | \
                                    LINECALLFEATURE_RELEASEUSERUSERINFO | \
				    LINECALLFEATURE_SENDUSERUSER | \
				    LINECALLFEATURE_MONITORDIGITS | \
				    LINECALLFEATURE_GENERATEDIGITS)
#define H323_ADDR_CALLINFOSTATES    LINECALLINFOSTATE_MEDIAMODE
#define H323_ADDR_CALLPARTYIDFLAGS  LINECALLPARTYID_NAME
#define H323_ADDR_CALLSTATES       (H323_CALL_INBOUNDSTATES | \
                                    H323_CALL_OUTBOUNDSTATES)
#define H323_ADDR_CAPFLAGS         (LINEADDRCAPFLAGS_DIALED | \
                                    LINEADDRCAPFLAGS_ORIGOFFHOOK)
/*LINEADDRCAPFLAGS_FWDCONSULT )*/
                
#define H323_ADDR_DISCONNECTMODES  (LINEDISCONNECTMODE_BADADDRESS | \
                                    LINEDISCONNECTMODE_BUSY | \
                                    LINEDISCONNECTMODE_NOANSWER | \
                                    LINEDISCONNECTMODE_NORMAL | \
                                    LINEDISCONNECTMODE_REJECT | \
                                    LINEDISCONNECTMODE_UNAVAIL)


extern	CH323Line	g_H323Line;
#define	g_pH323Line		(&g_H323Line)

BOOL
QueueTAPILineRequest(
    IN DWORD    EventID,
    IN HDRVCALL	hdCall1,
    IN HDRVCALL	hdCall2,
    IN DWORD    dwDisconnectMode,
    IN WORD     wCallReference);


static DWORD
ProcessTAPILineRequestFre(
    IN PVOID ContextParam
    );

#endif // _LINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\debug.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.cpp

Abstract:

    Routines for displaying debug messages.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"

#define DEBUG_FORMAT_HEADER     "H323 "
#define DEBUG_FORMAT_TIMESTAMP  "[%02u:%02u:%02u.%03u"
#define DEBUG_FORMAT_THREADID   ",tid=%x] "
#define DEBUG_FORMAT_END        "\r\n"


HANDLE 
H323CreateEvent(
    LPSECURITY_ATTRIBUTES lpEventAttributes, // SD
    BOOL bManualReset,                       // reset type
    BOOL bInitialState,                      // initial state
    LPCTSTR lpName                           // object name
)
{

#if DBG
    return CreateEvent( lpEventAttributes, bManualReset, bInitialState, lpName );
#else
    return CreateEvent( lpEventAttributes, bManualReset, bInitialState, NULL );
#endif

}

#if DBG

DWORD           g_dwTraceID = INVALID_TRACEID;
static TCHAR    g_szTraceName[100];   // saves name of dll

//                                                                           
// Private definitions                                                       
//                                                                           



#define MAX_DEBUG_STRLEN        800

#define STATUS_MASK_ERROR       0x0000FFFF
#define STATUS_MASK_FACILITY    0x0FFF0000


void H323DUMPBUFFER( IN BYTE * pEncoded, IN DWORD cbEncodedSize )
{
    DWORD indexI, indexJ=0;
    char ch;
    char szDebugMessage[MAX_DEBUG_STRLEN];
    szDebugMessage[0] = '\0';

    H323DBG(( DEBUG_LEVEL_ERROR, "ASN buffer start." ));
    
    for( indexI=0; indexI<cbEncodedSize; indexI++ )
    {
        ch = (pEncoded[indexI]>>4);
        if( (ch>=0)&&(ch<=9) )
        {
            ch+='0';
        }
        else
        {
            ch=ch+'A'-10;
        }
        
        szDebugMessage[indexJ++]=ch;

        ch = (pEncoded[indexI]& 0x0F);
        if( (ch>=0)&&(ch<=9) )
        {
            ch+='0';
        }
        else
        {
            ch= ch+'A'-10;
        }
        
        szDebugMessage[indexJ++]=ch;

        if( indexJ >= 700 )
        {
            szDebugMessage[indexJ]= '\0';
            H323DBG((DEBUG_LEVEL_ERROR, szDebugMessage ));
            indexJ = 0;
        }
    }

    szDebugMessage[indexJ]= '\0';
    H323DBG((DEBUG_LEVEL_ERROR, szDebugMessage ));

    H323DBG(( DEBUG_LEVEL_ERROR, "ASN buffer end." ));
    return;
}


//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:

    Debug output routine for service provider.

Arguments:

    Same as printf.

Return Values:

    None.   
    
--*/
VOID
H323DbgPrint(
    DWORD dwLevel,
    LPSTR szFormat,
    ...
    )
{
    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[MAX_DEBUG_STRLEN+1];
    int nLengthRemaining;
    int nLength = 0;

    // point at first argument
    va_start(Args, szFormat);

    // see if level enabled
    if( dwLevel <= g_RegistrySettings.dwLogLevel )
    {    
        // always emit messages at DEBUG_LEVEL_FORCE

        // retrieve local time
        GetLocalTime(&SystemTime);    

        // add component header to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_HEADER
                           );

        // add timestamp to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_TIMESTAMP,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond,
                           SystemTime.wMilliseconds
                           ); 

        // add thread id to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_THREADID,
                           GetCurrentThreadId()
                           );

        // determine number of bytes left in buffer
        nLengthRemaining = sizeof(szDebugMessage) - nLength -
            strlen(DEBUG_FORMAT_END);

        // add user specified debug message
        nLength += _vsnprintf(&szDebugMessage[nLength], 
                   nLengthRemaining, 
                   szFormat, 
                   Args
                   );
    
        nLength += sprintf(&szDebugMessage[nLength], DEBUG_FORMAT_END );

        // output message to specified sink
        OutputDebugStringA(szDebugMessage);
        
    }

    TraceVprintfExA( g_dwTraceID, (dwLevel | TRACE_USE_MASK), szFormat, Args );

    // release pointer
    va_end(Args);
}



void DumpError(
    IN DWORD ErrorCode )
{
    CHAR    ErrorText   [0x100];
    DWORD   Length;

    Length = FormatMessageA( FORMAT_MESSAGE_FROM_SYSTEM, NULL, 
        ErrorCode, LANG_NEUTRAL, ErrorText, 0x100, NULL );

    if( Length == 0 )
    {
        _snprintf( ErrorText, 0x100, "<unknown error %08XH %d>",
            ErrorCode, ErrorCode);
    }

    H323DBG ((DEBUG_LEVEL_ERROR, "\t%s", ErrorText));
}


BOOL TRACELogRegister(LPCTSTR szName)
{
#ifdef UNICODE
    wsprintf(g_szTraceName, _T("%ls"), szName);
#else
    wsprintfA(g_szTraceName, "%s", szName);
#endif

    g_dwTraceID = TraceRegister(g_szTraceName);

    return( g_dwTraceID != INVALID_TRACEID );
}


void TRACELogDeRegister()
{
    if( g_dwTraceID != INVALID_TRACEID )
    {
        TraceDeregister(g_dwTraceID);
        g_dwTraceID = INVALID_TRACEID;
    }
}


#else

HANDLE g_hLogFile;

VOID
OpenLogFile()
{
    g_hLogFile = INVALID_HANDLE_VALUE;

    g_hLogFile = CreateFile( _T("h323log.txt"), 
        GENERIC_READ|GENERIC_WRITE, 
        FILE_SHARE_READ, 
        NULL, 
        OPEN_ALWAYS, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL ); 
}

VOID
CloseLogFile()
{
    if( g_hLogFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle(g_hLogFile);
    }
}

VOID
H323DbgPrintFre(
    DWORD dwLevel,
    LPSTR szFormat,
    ...
    )
{
    va_list Args;
    SYSTEMTIME SystemTime;
    char szDebugMessage[800];
    DWORD NumberOfBytesWritten=0;
    int nLengthRemaining;
    int nLength = 0;

    // see if level enabled
    if( dwLevel <= g_RegistrySettings.dwLogLevel )
    {    
        // point at first argument
        va_start(Args, szFormat);

        // always emit messages at DEBUG_LEVEL_FORCE

        // retrieve local time
        GetLocalTime(&SystemTime);    

        // add component header to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_HEADER
                           );

        // add timestamp to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_TIMESTAMP,
                           SystemTime.wHour,
                           SystemTime.wMinute,
                           SystemTime.wSecond,
                           SystemTime.wMilliseconds
                           ); 

        // add thread id to the debug message
        nLength += sprintf(&szDebugMessage[nLength], 
                           DEBUG_FORMAT_THREADID,
                           GetCurrentThreadId()
                           );

        // determine number of bytes left in buffer
        nLengthRemaining = sizeof(szDebugMessage) - nLength -
            strlen(DEBUG_FORMAT_END);

        // add user specified debug message
        nLength += _vsnprintf(&szDebugMessage[nLength], 
                   nLengthRemaining, 
                   szFormat, 
                   Args
                   );
    
        nLength += sprintf(&szDebugMessage[nLength], DEBUG_FORMAT_END );

        // output message to specified sink
        //OutputDebugStringA(szDebugMessage);
        if( g_hLogFile != INVALID_HANDLE_VALUE )
        {
            WriteFile(  g_hLogFile, 
                        szDebugMessage, 
                        nLength,
                        &NumberOfBytesWritten, 
                        NULL ); 
        }

        // release pointer
        va_end(Args);
    }
}



#endif // DBG

PSTR
EventIDToString(
    DWORD eventID
    )
{
    static PSTR apszEventNameStrings[] = {
        "TSPI_NO_EVENT",
        "TSPI_MAKE_CALL",
        "TSPI_ANSWER_CALL",
        "TSPI_DROP_CALL",
        "TSPI_CLOSE_CALL",
        "TSPI_RELEASE_U2U",
        "TSPI_SEND_U2U",
        "TSPI_COMPLETE_TRANSFER",
        "TSPI_LINEFORWARD_SPECIFIC",
        "TSPI_LINEFORWARD_NOSPECIFIC",
        "TSPI_DIAL_TRNASFEREDCALL",
        "TSPI_CALL_UNHOLD",
        "TSPI_CALL_HOLD",
        "TSPI_DELETE_CALL",
        "TSPI_CALL_DIVERT",
        "H450_PLACE_DIVERTEDCALL",
        "SWAP_REPLACEMENT_CALL",
        "DELETE_PRIMARY_CALL",
        "STOP_CTIDENTIFYRR_TIMER",
        "SEND_CTINITIATE_MESSAGE"

        };

    // return corresponding string
    return apszEventNameStrings[eventID];
}


PSTR
H323TSPMessageToString(
    DWORD dwMessageType
    )
{

    static PSTR msgstrings[] =
    {
        "SP_MSG_InitiateCall",
        "SP_MSG_AnswerCall",    
        "SP_MSG_PrepareToAnswer",   
        "SP_MSG_ProceedWithAnswer", 
        "SP_MSG_ReadyToInitiate",   
        "SP_MSG_ReadyToAnswer", 
        "SP_MSG_FastConnectResponse",
        "SP_MSG_StartH245", 
        "SP_MSG_ConnectComplete",   
        "SP_MSG_H245PDU",   
        "SP_MSG_MCLocationIdentify",    
        "SP_MSG_Hold",  
        "SP_MSG_H245Hold",  
        "SP_MSG_ConferenceList",    
        "SP_MSG_SendDTMFDigits",    
        "SP_MSG_ReleaseCall",   
        "SP_MSG_CallShutdown",
        "SP_MSG_H245Terminated",    
        "SP_MSG_RASRegistration",   
        "SP_MSG_RASRegistrationEvent",  
        "SP_MSG_RASLocationRequest",    
        "SP_MSG_RASLocationConfirm",    
        "SP_MSG_RASBandwidthRequest",   
        "SP_MSG_RASBandwidthConfirm"
    };

    return msgstrings[dwMessageType];
}


/*++

Routine Description:

    Converts tapi call state to string.

Arguments:

    dwCallState - Specifies value to convert.

Return Values:

    Returns string describing value.
    
--*/
PSTR
H323CallStateToString(
    DWORD dwCallState
    )
{
    DWORD i;
    DWORD dwBitMask;

    static PSTR apszCallStateStrings[] = {
                    "IDLE",
                    "OFFERING",
                    "ACCEPTED",
                    "DIALTONE",
                    "DIALING",
                    "RINGBACK",
                    "BUSY",
                    "SPECIALINFO",
                    "CONNECTED",
                    "PROCEEDING",
                    "ONHOLD",
                    "CONFERENCED",
                    "ONHOLDPENDCONF",
                    "ONHOLDPENDTRANSFER",
                    "DISCONNECTED",
                    "UNKNOWN"
                    };

    // keep shifting bit until the call state matchs the one specified
    for(i = 0, dwBitMask = 1; dwCallState != dwBitMask; i++, dwBitMask <<= 1)
        ;

    // return corresponding string
    return apszCallStateStrings[i];
}



PSTR
H323AddressTypeToString(
    DWORD dwAddressType
    )

/*++

Routine Description:

    Converts TAPI address type to string.

Arguments:

    dwAddressType - TAPI address type.

Return Values:

    Returns string describing value.
    
--*/

{
    switch (dwAddressType) {

    case LINEADDRESSTYPE_PHONENUMBER:
        return "PHONENUMBER";
    case LINEADDRESSTYPE_SDP:
        return "SDP";
    case LINEADDRESSTYPE_EMAILNAME:
        return "EMAILNAME";
    case LINEADDRESSTYPE_DOMAINNAME:
        return "DOMAINNAME";
    case LINEADDRESSTYPE_IPADDRESS:
        return "IPADDRESS";
    default:
        return "unknown";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\main.cpp ===
#include "globals.h"
#include "line.h"
#include "config.h"


#define H323_VERSION_LO     0x00000000
#define H323_VERSION_HI     0x00000000

#define TSPI_VERSION_LO     0x00030000
#define TSPI_VERSION_HI     TAPI_CURRENT_VERSION


//                                                                           
// Global variables                                                          
//                                                                           


HINSTANCE       g_hInstance;
WCHAR           g_pwszProviderInfo[64];
WCHAR           g_pwszLineName[16];
DWORD           g_dwTSPIVersion;

//                                                                           
// Private procedures                                                        
//                                                                           


/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

Return Values:

    Returns true if successful.

--*/

BOOL
H323NegotiateTSPIVersion(
                        IN DWORD  dwLowVersion,
                        IN DWORD  dwHighVersion,
                        OUT PDWORD pdwTSPIVersion
                        )
{
    // validate extension version range
    if ((TSPI_VERSION_HI <= dwHighVersion) &&
        (TSPI_VERSION_HI >= dwLowVersion))
    {
        // save negotiated version
        *pdwTSPIVersion = TSPI_VERSION_HI;

        // success
        return TRUE;
    }
    else if( (dwHighVersion <= TSPI_VERSION_HI) &&
             (dwHighVersion >= TSPI_VERSION_LO) )
    {
        // save negotiated version
        *pdwTSPIVersion = dwHighVersion;

        // success
        return TRUE;
    }

    H323DBG(( DEBUG_LEVEL_FORCE, "TSPI version (%08XH:%08XH) rejected.",
		dwHighVersion, dwLowVersion ));

    // failure
    return FALSE;
}



//                                                                           
// Public procedures                                                         
//                                                                           


/*++

Routine Description:

    This function determines whether or not specified TSPI version is
    supported by the service provider.

Arguments:

    dwTSPIVersion - Specifies the TSPI version to validate.

Return Values:

    Returns true if successful.

--*/

BOOL
H323ValidateTSPIVersion(
                        IN DWORD dwTSPIVersion
                       )
{
    // see if specified version is supported
    if ((dwTSPIVersion >= TSPI_VERSION_LO) &&
        (dwTSPIVersion <= TSPI_VERSION_HI)) {

        // success
        return TRUE;
    }

    H323DBG((DEBUG_LEVEL_FORCE, "do not support TSPI version %08XH.",
		dwTSPIVersion));

    // failure
    return FALSE;
}


/*++

Routine Description:

    This function determines whether or not specified extension version is
    supported by the service provider.

Arguments:

    dwExtVersion - Specifies the extension version to validate.

Return Values:

    Returns true if successful.

--*/

BOOL
H323ValidateExtVersion(
                        IN DWORD dwExtVersion
                      )
{
    //  no device specific extension
    if (dwExtVersion == H323_VERSION_HI) {

        // success
        return TRUE;
    }

    H323DBG((
        DEBUG_LEVEL_ERROR,
        "do not support extension version %d.%d.",
        HIWORD(dwExtVersion),
        LOWORD(dwExtVersion)
        ));

    // failure
    return FALSE;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:

    This function returns the highest SPI version the Service Provider is
    willing to operate under for this device given the range of possible
    SPI versions.

    The TAPI DLL typically calls this function early in the initialization
    sequence for each line device.  In addition, it calls this with the
    value INITIALIZE_NEGOTIATION for dwDeviceID to negotiate an interface
    version for calling early initialization functions.

    Note that when dwDeviceID is INITIALIZE_NEGOTIATION, this function must
    not return LINEERR_OPERATIONUNAVAIL, since this function (with that value)
    is mandatory for negotiating the overall interface version even if the
    service provider supports no line devices.

    Negotiation of an Extension version is done through the separate
    procedure TSPI_lineNegotiateExtVersion.

Arguments:

    dwDeviceID - Identifies the line device for which interface version
        negotiation is to be performed.  In addition to device IDs within
        the range the Service Provider supports, this may be the value:

        INITIALIZE_NEGOTIATION - This value is used to signify that an overall
            interface version is to be negotiated.  Such an interface version
            is required for functions that can be called early in the
            initialization sequence, i.e., before the device ID range has
            been set.

    dwLowVersion - Specifies the lowest TSPI version number under which the
        TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    dwHighVersion - Specifies the highest TSPI version number under which
        the TAPI DLL is willing to operate.  The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number.

    pdwTSPIVersion - Specifies a far pointer to a DWORD. The service
        provider fills this location with the highest TSPI version number,
        within the range requested by the caller, under which the service
        provider is willing to operate. The most-significant WORD is the
        major version number and the least-significant WORD is the minor
        version number. If the requested range does not overlap the range
        supported by the service provider, the function returns
        LINEERR_INCOMPATIBLEAPIVERSION.

Return Values:

    Returns zero if the function is successful, or a negative error number
    if an error has occurred. Possible return values are as follows:

        LINEERR_BADDEVICEID - The specified device identifier or line device
            identifier (such as in a dwDeviceID parameter) is invalid or
            out of range.

        LINEERR_INCOMPATIBLEAPIVERSION - The application requested an API
            version or version range that is either incompatible or cannot
            be supported by the Telephony API implementation and/or
            corresponding service provider.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified
            or unknown reason.

--*/

LONG
TSPIAPI
TSPI_lineNegotiateTSPIVersion(
    DWORD  dwDeviceID,
    DWORD  dwLowVersion,
    DWORD  dwHighVersion,
    PDWORD pdwTSPIVersion
    )
{
    DWORD dwTSPIVersion;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - Entered." ));

    // see if this is a init line device
    if ((DWORD_PTR)dwDeviceID == INITIALIZE_NEGOTIATION)
    {

        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "tapisrv supports tspi version %d.%d through %d.%d.",
            HIWORD(dwLowVersion),
            LOWORD(dwLowVersion),
            HIWORD(dwHighVersion),
            LOWORD(dwHighVersion)
            ));

        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion)) 
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - bad version." ));
            
            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }

    // see if this is a valid line device
    }
    else if( g_pH323Line -> GetDeviceID() == (DWORD)dwDeviceID )
    {
        // perform version negotiation
        if (!H323NegotiateTSPIVersion(
                dwLowVersion,
                dwHighVersion,
                &dwTSPIVersion))
        {
            H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - incompat ver." ));

            // negotiated version not agreed upon
            return LINEERR_INCOMPATIBLEAPIVERSION;
        }
    }
    else 
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - bad device id:%d:%d.", 
            g_pH323Line -> GetDeviceID(), dwDeviceID));
        
        // do not recognize device
        return LINEERR_BADDEVICEID;
    }

    // return negotiated version
    *pdwTSPIVersion = dwTSPIVersion;
    g_dwTSPIVersion = dwTSPIVersion;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineNegotiateTSPIVer - Exited." ));
    
    // success
    return NOERROR;
}


/*++

Routine Description:

    Loads strings from resource table.

Arguments:

    None.

Return Values:

    Returns true if successful. 

--*/

BOOL
H323LoadStrings(
    )
{
    DWORD dwNumBytes;
    DWORD dwNumChars;
    WCHAR wszBuffer[256];

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_LINENAME,
                    g_pwszLineName,
                    sizeof(g_pwszLineName)/sizeof(WCHAR)
                    );

    if( dwNumChars == 0 )
        return FALSE;

    // load string into buffer
    dwNumChars = LoadStringW(
                    g_hInstance,
                    IDS_PROVIDERNAME,
                    g_pwszProviderInfo,
                    sizeof(g_pwszProviderInfo)/sizeof(WCHAR)
                    );
    
    if( dwNumChars == 0 )
        return FALSE;

    // success
    return TRUE;
}



//                                                                           
// Public Procedures                                                         
//                                                                           


/*++

Routine Description:

    Dll entry point.

Arguments:

    Same as DllMain.

Return Values:

    Returns true if successful. 

--*/

BOOL
WINAPI
DllMain(
    PVOID  DllHandle,
    ULONG  Reason,
    LPVOID lpReserved 
    )
{
    BOOL fOk = TRUE;

    // check if new process attaching
    if (Reason == DLL_PROCESS_ATTACH)
    {
		g_RegistrySettings.dwLogLevel = DEBUG_LEVEL_FORCE;

		H323DBG ((DEBUG_LEVEL_FORCE, "DLL_PROCESS_ATTACH"));

        // store the handle into a global variable so that
        // the UI code can use it.
        g_hInstance = (HINSTANCE)DllHandle;

        // turn off thread attach messages
        DisableThreadLibraryCalls( g_hInstance );

        // start h323 tsp
        fOk = H323LoadStrings();

    // check if new process detaching
    }
    else if (Reason == DLL_PROCESS_DETACH)
    {
		H323DBG ((DEBUG_LEVEL_FORCE, "DLL_PROCESS_DETACH"));

#if DBG
        TRACELogDeRegister();
#else
        CloseLogFile();
#endif
        fOk = TRUE;
    }

    return fOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\q931pdu.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    q931pdu.cpp

Abstract:

    Encode/decode/transport routines for Q931/H450 messages.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "ras.h"

//PARSE ROUTINES

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//     Value      Pointer to space for field value
//------------------------------------------------------------------------------
HRESULT 
ParseSingleOctetType1(
                        PBUFFERDESCR    pBuf,
                        BYTE *          bIdent,
                        BYTE *          Value
                     )
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (((LONG)(pBuf->dwLength)) < 1)
    {
        return E_INVALIDARG;
    }

    // low bits (0, 1, 2, 3) of the byte are the value
    *Value = (BYTE)(*pBuf->pbBuffer & TYPE1VALUEMASK);

    // higher bits (4, 5, 6) are the identifier.  bit 7 is always 1,
    // and is not returned as part of the id.
    *bIdent = (BYTE)((*pBuf->pbBuffer & 0x70) >> 4);

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a single octet encoded value, See Q931 section 4.5.1.
// This octet has no value, only an identifier.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer containing the
//                length and a pointer to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//------------------------------------------------------------------------------
HRESULT
ParseSingleOctetType2(
                        PBUFFERDESCR    pBuf,
                        BYTE *          bIdent
                     )
{
    // There has to be at least 1 byte in the stream to be
    // able to parse the single octet value
    if (((LONG)(pBuf->dwLength)) < 1)
    {
        return E_INVALIDARG;
    }

    // low 7 bits of the byte are the identifier
    *bIdent = (BYTE)(*pBuf->pbBuffer & 0x7f);

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//
// Parameters :
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     bIdent      Pointer to space for field identifier
//     dwLength     Pointer to space for the length
//     pbContents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
HRESULT 
ParseVariableOctet(
                    PBUFFERDESCR    pBuf,
                    BYTE *          dwLength,
                    BYTE *          pbContents
                  )
{
    // There has to be at least 2 bytes in order just to get 
    // the length and the identifier
    // able to parse the single octet value
    if (((LONG)(pBuf->dwLength)) < 2)
    {
        return E_INVALIDARG;
    }

    //Increment the ident byte
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // The next byte is the length
    *dwLength = *pBuf->pbBuffer;
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    if (((LONG)(pBuf->dwLength)) < *dwLength)
    {
        return E_INVALIDARG;
    }

    if (*dwLength >= MAXVARFIELDLEN)
    {
        return E_INVALIDARG;
    }

    CopyMemory( pbContents, pBuf->pbBuffer, *dwLength );
    pBuf->pbBuffer += *dwLength;
    pBuf->dwLength -= *dwLength;

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 field see Q931 section 4.5.1.
//------------------------------------------------------------------------------
HRESULT 
ParseVariableASN(
                    PBUFFERDESCR pBuf,
                    BYTE *bIdent,
                    BYTE *ProtocolDiscriminator,
                    PUSERUSERIE pUserUserIE
                )
{
    pUserUserIE -> wUserInfoLen = 0;

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    if (((LONG)(pBuf->dwLength)) < 4)
    {
        return E_INVALIDARG;
    }

    // low 7 bits of the first byte are the identifier
    *bIdent= (BYTE)(*pBuf->pbBuffer & 0x7f);
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // The next 2 bytes are the length
    pUserUserIE -> wUserInfoLen = *(pBuf->pbBuffer);
    pBuf->pbBuffer++;
    pUserUserIE -> wUserInfoLen = 
        (WORD)(((pUserUserIE -> wUserInfoLen) << 8) + *pBuf->pbBuffer);
    pBuf->pbBuffer++;
    pBuf->dwLength -= 2;

    // The next byte is the protocol discriminator.
    *ProtocolDiscriminator = *pBuf->pbBuffer;
    pBuf->pbBuffer++;
    pBuf->dwLength--;

    if( pUserUserIE -> wUserInfoLen > 0 )
    {
        pUserUserIE -> wUserInfoLen--;
    }

    if (((LONG)(pBuf->dwLength)) < pUserUserIE -> wUserInfoLen )
    {
        return E_INVALIDARG;
    }

    if (pUserUserIE->wUserInfoLen >= MAX_USER_TO_USER_INFO_LEN)
    {
        return E_INVALIDARG;
    }

    CopyMemory( pUserUserIE -> pbUserInfo, 
            pBuf->pbBuffer, 
            pUserUserIE -> wUserInfoLen );

    pBuf->pbBuffer += pUserUserIE -> wUserInfoLen;
    pBuf->dwLength -= pUserUserIE -> wUserInfoLen;

    return S_OK;
}

//------------------------------------------------------------------------------
// Get the identifier of the next field from the buffer and
// return it.  The buffer pointer is not incremented, To
// parse the field and extract its values, the above functions
// should be used.  See Q931 table 4-3 for the encodings of the 
// identifiers.
//
// Parameters:
//      pbBuffer        Pointer to the buffer space
//------------------------------------------------------------------------------
 BYTE
GetNextIdent(
            void *pbBuffer
            )
{
    FIELDIDENTTYPE bIdent;

    // Extract the first byte from the buffer
    bIdent= (*(FIELDIDENTTYPE *)pbBuffer);

    // This value can be returned as the identifier as long
    // as it is not a single Octet - Type 1 element.
    // Those items must have the value removed from them
    // before they can be returned.
    if ((bIdent & 0x80) && ((bIdent & TYPE1IDENTMASK) != 0xA0))
    {
        return (BYTE)(bIdent & TYPE1IDENTMASK);
    }

    return bIdent;
}

//------------------------------------------------------------------------------
// Parse and return a protocol discriminator. See Q931 section 4.2.
// The octet pointed to by **pbBuffer is the protocol Discriminator.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     Discrim    Pointer to space for discriminator
//------------------------------------------------------------------------------
HRESULT
ParseProtocolDiscriminator(
    PBUFFERDESCR pBuf,
    PDTYPE *Discrim)
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (((LONG)(pBuf->dwLength)) < sizeof(PDTYPE))
    {
        return E_INVALIDARG;
    }

    *Discrim = *(PDTYPE *)pBuf->pbBuffer;
    if (*Discrim != Q931PDVALUE)
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer += sizeof(PDTYPE);
    pBuf->dwLength -= sizeof(PDTYPE);
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a variable length Q931 call reference see 
// Q931 section 4.3.
//
// Parameters:
//     pbBuffer  Pointer to a descriptor of the buffer
//                containing the length and a pointer
//                to the raw bytes of the input stream.
//     dwLength     Pointer to space for the length
//     pbContents   Pointer to space for the bytes of the field
//------------------------------------------------------------------------------
HRESULT
ParseCallReference(
                    PBUFFERDESCR    pBuf,
                    CRTYPE *        wCallRef
                  )
{
    register int indexI;
    BYTE dwLength;

    // There has to be at least enough bytes left in the 
    // string for the length byte
    if( ((LONG)(pBuf->dwLength)) < 1 )
    {
        return E_INVALIDARG;
    }

    // low 4 bits of the first byte are the length.
    // the rest of the bits are zeroes.
    dwLength = (BYTE)(*pBuf->pbBuffer & 0x0f);
    if( dwLength != sizeof(WORD) )
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer++;
    pBuf->dwLength--;

    // There has to be at least enough bytes left in the 
    // string for the operation
    if (((LONG)(pBuf->dwLength)) < dwLength)
    {
        return E_INVALIDARG;
    }

    *wCallRef = 0;     // length can be 0, so initialize here first...
    for (indexI = 0; indexI < dwLength; indexI++)
    {
        if (indexI < sizeof(CRTYPE))
        {
            // Copy the bytes out of the rest of the buffer
            *wCallRef = (WORD)((*wCallRef << 8) +
                *pBuf->pbBuffer);
        }
        pBuf->pbBuffer++;
        pBuf->dwLength--;
    }

    // note:  the high order bit of the value represents callee relationship.

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse and return a message type.  See Q931 section 4.4.
// The octet pointed to by **pbBuffer is the message type.
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     MessageType  Pointer to space for message type
//------------------------------------------------------------------------------
HRESULT
ParseMessageType(
                PBUFFERDESCR    pBuf,
                MESSAGEIDTYPE * MessageType
                )
{
    // There has to be at least enough bytes left in the 
    // string for the operation
    if (((LONG)(pBuf->dwLength)) < sizeof(MESSAGEIDTYPE))
    {
        return E_INVALIDARG;
    }

    *MessageType = (BYTE)(*((MESSAGEIDTYPE *)pBuf->pbBuffer) & MESSAGETYPEMASK);

    if( ISVALIDQ931MESSAGE(*MessageType) == FALSE )
    {
        return E_INVALIDARG;
    }

    pBuf->pbBuffer += sizeof(MESSAGEIDTYPE);
    pBuf->dwLength -= sizeof(MESSAGEIDTYPE);
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional facility ie field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed facility
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseFacility(
                PBUFFERDESCR pBuf,
                PFACILITYIE pFieldStruct
             )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(FACILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional bearer capability field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed bearer capability
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseBearerCapability(
    PBUFFERDESCR pBuf,
    PBEARERCAPIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(BEARERCAPIE));
    pFieldStruct->fPresent = FALSE;
    
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional cause field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed cause
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCause(
    PBUFFERDESCR pBuf,
    PCAUSEIE pFieldStruct)
{
    HRESULT hr;
    memset( (PVOID)pFieldStruct, 0, sizeof(CAUSEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional call state field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed call state
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallState(
    PBUFFERDESCR pBuf,
    PCALLSTATEIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLSTATEIE));
    pFieldStruct->fPresent = FALSE;

    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional channel identification field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed channel identity
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseChannelIdentification(
    PBUFFERDESCR pBuf,
    PCHANIDENTIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(CHANIDENTIE));
    pFieldStruct->fPresent = FALSE;

    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional progress indication field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed progress
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseProgress(
    PBUFFERDESCR pBuf,
    PPROGRESSIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(PROGRESSIE));
    pFieldStruct->fPresent = FALSE;
    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional network specific facilities field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed network facitlities
//                  information.
//------------------------------------------------------------------------------
HRESULT 
ParseNetworkSpec(
    PBUFFERDESCR pBuf,
    PNETWORKIE pFieldStruct)
{
   
    memset( (PVOID)pFieldStruct, 0, sizeof(NETWORKIE));
    pFieldStruct->fPresent = FALSE;
        
    HRESULT hr;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional notification indicator field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parse notification indicator
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseNotificationIndicator(
    PBUFFERDESCR pBuf,
    PNOTIFICATIONINDIE pFieldStruct)
{
    memset( (PVOID)pFieldStruct, 0, sizeof(NOTIFICATIONINDIE));
    pFieldStruct->fPresent = FALSE;
    if (GetNextIdent(pBuf->pbBuffer) == IDENT_NOTIFICATION)
    {
        HRESULT hr;
        hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
            &pFieldStruct->pbContents[0]);
        if( FAILED(hr) )
        {
            return hr;
        }
        if (pFieldStruct->dwLength > 0)
        {
            pFieldStruct->fPresent = TRUE;
        }
    }

    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional display field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed display
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseDisplay(
    PBUFFERDESCR pBuf,
    PDISPLAYIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(DISPLAYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


HRESULT
ParseDate(
    PBUFFERDESCR pBuf,
    PDATEIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(DATEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional keypad field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed keypad
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseKeypad(
    PBUFFERDESCR pBuf,
    PKEYPADIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(KEYPADIE));
    pFieldStruct->fPresent = FALSE;
    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional signal field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed signal
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseSignal(
    PBUFFERDESCR pBuf,
    PSIGNALIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(SIGNALIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional information rate field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed information rate
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseInformationRate(
    PBUFFERDESCR pBuf,
    PINFORATEIE pFieldStruct)
{
    HRESULT hr;    
    
    memset( (PVOID)pFieldStruct, 0, sizeof(INFORATEIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);
    
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional calling party number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallingPartyNumber(
    PBUFFERDESCR pBuf,
    PCALLINGNUMBERIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLINGNUMBERIE));
    pFieldStruct->fPresent = FALSE;
    
    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional calling party subaddress field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCallingPartySubaddress(
    PBUFFERDESCR pBuf,
    PCALLINGSUBADDRIE pFieldStruct)
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLINGSUBADDRIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCalledPartyNumber(
                        PBUFFERDESCR pBuf,
                        PCALLEDNUMBERIE pFieldStruct
                      )
{
    memset( (PVOID)pFieldStruct, 0, sizeof(PCALLEDNUMBERIE));
    pFieldStruct->fPresent = FALSE;
    if (GetNextIdent(pBuf->pbBuffer) == IDENT_CALLEDNUMBER)
    {
        BYTE RemainingLength = 0;
    
        // Need 3 bytes for the ident (1), length (1),
        // and type + plan (1) fields.
        if (((LONG)(pBuf->dwLength)) < 3)
        {
            return E_INVALIDARG;
        }

        // skip the ie identifier...    
        pBuf->pbBuffer++;
        pBuf->dwLength--;

        // Get the length of the contents following the length field.
        RemainingLength = *pBuf->pbBuffer;
        pBuf->pbBuffer++;
        pBuf->dwLength--;

        // Get the type + plan fields.
        if (*(pBuf->pbBuffer) & 0x80)
        {
            pFieldStruct->NumberType =
                (BYTE)(*pBuf->pbBuffer & 0xf0);
            pFieldStruct->NumberingPlan =
                (BYTE)(*pBuf->pbBuffer & 0x0f);
            pBuf->pbBuffer++;
            pBuf->dwLength--;
            RemainingLength--;
        }

        // make sure we have at least that much length left...    
        if (((LONG)(pBuf->dwLength)) < RemainingLength)
        {
            return E_INVALIDARG;
        }

        if ( RemainingLength >= MAXVARFIELDLEN)
        {
            return E_INVALIDARG;
        }

        pFieldStruct->PartyNumberLength = RemainingLength;
        pFieldStruct->fPresent = TRUE;

        CopyMemory( pFieldStruct->PartyNumbers, pBuf->pbBuffer, RemainingLength );

        pBuf->pbBuffer += RemainingLength;
        pBuf->dwLength -= RemainingLength;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional called party subaddress field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseCalledPartySubaddress(
                            PBUFFERDESCR pBuf,
                            PCALLEDSUBADDRIE pFieldStruct
                          )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(CALLEDSUBADDRIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional redirecting number field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseRedirectingNumber(
                        PBUFFERDESCR pBuf, 
                        PREDIRECTINGIE pFieldStruct
                      )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(REDIRECTINGIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }
    
    return S_OK;
}


//------------------------------------------------------------------------------
// Parse an optional lower layer compatibility field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseLowLayerCompatibility(
    PBUFFERDESCR pBuf,
    PLLCOMPATIBILITYIE pFieldStruct
    )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(LLCOMPATIBILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, 
        &pFieldStruct->dwLength, &pFieldStruct->pbContents[0]);
    if( FAILED(hr) )
    {
        return hr;
    }
    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

//------------------------------------------------------------------------------
// Parse an optional higher layer compatibility field
//
// Parameters:
//     pbBuffer    Pointer to a descriptor of the buffer
//                  containing the length and a pointer
//                  to the raw bytes of the input stream.
//     pFieldStruct  Pointer to space for parsed 
//                  information.
//------------------------------------------------------------------------------
HRESULT
ParseHighLayerCompatibility(
                            PBUFFERDESCR pBuf,
                            PHLCOMPATIBILITYIE pFieldStruct
                           )
{
    HRESULT hr;
    
    memset( (PVOID)pFieldStruct, 0, sizeof(HLCOMPATIBILITYIE));
    pFieldStruct->fPresent = FALSE;

    hr = ParseVariableOctet(pBuf, &pFieldStruct->dwLength, 
        &pFieldStruct->pbContents[0]);

    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->dwLength > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}


HRESULT
ParseUserToUser(
                PBUFFERDESCR pBuf,
                PUSERUSERIE pFieldStruct
               )
{
    BYTE    bIdent;
    HRESULT hr;
    
    ZeroMemory( (PVOID)pFieldStruct, sizeof(USERUSERIE));
    pFieldStruct->fPresent = FALSE;
    hr = ParseVariableASN(  pBuf, 
                            &bIdent, 
                            &(pFieldStruct->ProtocolDiscriminator),
                            pFieldStruct
                         );
    if( FAILED(hr) )
    {
        return hr;
    }

    if (pFieldStruct->wUserInfoLen > 0)
    {
        pFieldStruct->fPresent = TRUE;
    }

    return S_OK;
}

HRESULT
ParseQ931Field(
                PBUFFERDESCR pBuf,
                PQ931MESSAGE pMessage
              )
{
    FIELDIDENTTYPE bIdent;

    bIdent = GetNextIdent(pBuf->pbBuffer);
    switch (bIdent)
    {
    /*case IDENT_REVCHARGE:
    case IDENT_TRANSITNET:
    case IDENT_RESTART:
    case IDENT_MORE:
    case IDENT_REPEAT:
    case IDENT_SEGMENTED:
    case IDENT_SHIFT:
    case IDENT_CALLIDENT:
    case IDENT_CLOSEDUG:
    case IDENT_SENDINGCOMPLETE:
    case IDENT_PACKETSIZE:
    case IDENT_CONGESTION:
    case IDENT_NETWORKSPEC:
    case IDENT_PLWINDOWSIZE:
    case IDENT_TRANSITDELAY:
    case IDENT_PLBINARYPARAMS:
    case IDENT_ENDTOENDDELAY:
        
        return E_INVALIDARG;*/

    case IDENT_FACILITY:

        return ParseFacility( pBuf, &pMessage->Facility );

    case IDENT_BEARERCAP:
        
        return ParseBearerCapability( pBuf, &pMessage->BearerCapability );

    case IDENT_CAUSE:
        
        return ParseCause(pBuf, &pMessage->Cause);

    case IDENT_CALLSTATE:
        return ParseCallState(pBuf, &pMessage->CallState);

    case IDENT_CHANNELIDENT:
        return ParseChannelIdentification( pBuf, 
            &pMessage->ChannelIdentification );

    case IDENT_PROGRESS:
        return ParseProgress( pBuf, &pMessage->ProgressIndicator );

    case IDENT_NOTIFICATION:
        return ParseNotificationIndicator( pBuf, 
            &pMessage->NotificationIndicator );

    case IDENT_DISPLAY:
        return ParseDisplay( pBuf, &pMessage->Display );

    case IDENT_DATE:
        return ParseDate( pBuf, &pMessage->Date );

    case IDENT_KEYPAD:
        return ParseKeypad( pBuf, &pMessage->Keypad );

    case IDENT_SIGNAL:
        return ParseSignal(pBuf, &pMessage->Signal);

    case IDENT_INFORMATIONRATE:
        return ParseInformationRate( pBuf, &pMessage->InformationRate );

    case IDENT_CALLINGNUMBER:
        return ParseCallingPartyNumber( pBuf, &pMessage->CallingPartyNumber );

    case IDENT_CALLINGSUBADDR:
        return ParseCallingPartySubaddress(pBuf, 
            &pMessage->CallingPartySubaddress);

    case IDENT_CALLEDNUMBER:
        return ParseCalledPartyNumber(pBuf, &pMessage->CalledPartyNumber);

    case IDENT_CALLEDSUBADDR:
        return ParseCalledPartySubaddress( pBuf, 
            &pMessage->CalledPartySubaddress );

    case IDENT_REDIRECTING:
        return ParseRedirectingNumber( pBuf, &pMessage->RedirectingNumber );

    case IDENT_LLCOMPATIBILITY:
        return ParseLowLayerCompatibility( pBuf, 
            &pMessage->LowLayerCompatibility );

    case IDENT_HLCOMPATIBILITY:
        return ParseHighLayerCompatibility( pBuf, 
            &pMessage->HighLayerCompatibility );

    case IDENT_USERUSER:
        return ParseUserToUser(pBuf, &pMessage->UserToUser);

    default:

        //Increment the ident byte
        pBuf->pbBuffer++;
        pBuf->dwLength--;
        return S_OK;
    }
}


//------------------------------------------------------------------------------
// Write a Q931 message type.  See Q931 section 4.4.
//------------------------------------------------------------------------------

void 
WriteMessageType(
                PBUFFERDESCR    pBuf,
                MESSAGEIDTYPE * MessageType,
                DWORD*          pdwPDULen
                )
{
    (*pdwPDULen) += sizeof(MESSAGEIDTYPE);

    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    *(MESSAGEIDTYPE *)(pBuf->pbBuffer) =
        (BYTE)(*MessageType & MESSAGETYPEMASK);
    pBuf->pbBuffer += sizeof(MESSAGEIDTYPE);
}



void 
WriteVariableOctet(
                    PBUFFERDESCR pBuf,
                    BYTE bIdent,
                    BYTE dwLength,
                    BYTE *pbContents,
                    DWORD* pdwPDULen
                  )
{
    if( pbContents == NULL )
    {
        dwLength = 0;
    }

    // space for the length and the identifier bytes and octet array
    (*pdwPDULen) += (2 + dwLength);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // the id byte, then the length byte
    // low 7 bits of the first byte are the identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;
    *pBuf->pbBuffer = dwLength;
    pBuf->pbBuffer++;

    CopyMemory( (PVOID)pBuf->pbBuffer, (PVOID)pbContents, dwLength );
    pBuf->pbBuffer +=  dwLength;
}


void
WriteUserInformation(
                    PBUFFERDESCR    pBuf,
                    BYTE            bIdent,
                    WORD            wUserInfoLen,
                    BYTE *          pbUserInfo,
                    DWORD *         pdwPDULen
                    )
{
    WORD ContentsLength = (WORD)(wUserInfoLen + 1);

    // There has to be at least 4 bytes for the IE identifier,
    // the contents length, and the protocol discriminator (1 + 2 + 1).
    (*pdwPDULen) += (4 + wUserInfoLen);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // low 7 bits of the first byte are the identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;

    // write the contents length bytes.
    *pBuf->pbBuffer = (BYTE)(ContentsLength >> 8);
    pBuf->pbBuffer++;
    *pBuf->pbBuffer = (BYTE)ContentsLength;
    pBuf->pbBuffer++;

    // write the protocol discriminator byte.
    *(pBuf->pbBuffer) = Q931_PROTOCOL_X209;
    pBuf->pbBuffer++;

    CopyMemory( (PVOID)pBuf->pbBuffer, 
            (PVOID)pbUserInfo, 
            wUserInfoLen);

    pBuf->pbBuffer +=  wUserInfoLen;
}


HRESULT
WritePartyNumber(
    PBUFFERDESCR pBuf,
    BYTE bIdent,
    BYTE NumberType,
    BYTE NumberingPlan,
    BYTE bPartyNumberLength,
    BYTE *pbPartyNumbers,
    DWORD *  pdwPDULen )
{
    if (pbPartyNumbers == NULL)
    {
        bPartyNumberLength = 1;
    }

    // space for the ident (1), length (1), and type + plan (1) fields.
    (*pdwPDULen) += (2 + bPartyNumberLength);
    _ASSERTE( pBuf->dwLength > *pdwPDULen );
    
    // low 7 bits of byte 1 are the ie identifier
    *pBuf->pbBuffer = (BYTE)(bIdent & 0x7f);
    pBuf->pbBuffer++;


    // byte 2 is the ie contents length following the length field.
    *pBuf->pbBuffer = (BYTE)(bPartyNumberLength);
    pBuf->pbBuffer++;

    // byte 3 is the type and plan field.
    *pBuf->pbBuffer = (BYTE)(NumberType | NumberingPlan);
    pBuf->pbBuffer++;

    if( pbPartyNumbers != NULL )
    {
        CopyMemory( (PVOID)pBuf->pbBuffer, 
                    (PVOID)pbPartyNumbers, 
                    bPartyNumberLength-1 );
    }
    pBuf->pbBuffer += (bPartyNumberLength-1);

    return S_OK;
}


//
//ASN Parsing functions
//

BOOL 
ParseVendorInfo(
                 OUT PH323_VENDORINFO   pDestVendorInfo,
                 IN VendorIdentifier*  pVendor
               )
{
    memset( (PVOID)pDestVendorInfo, 0, sizeof(H323_VENDORINFO) );

    pDestVendorInfo ->bCountryCode = (BYTE)pVendor->vendor.t35CountryCode;
    pDestVendorInfo ->bExtension = (BYTE)pVendor->vendor.t35Extension;
    pDestVendorInfo ->wManufacturerCode = pVendor->vendor.manufacturerCode;

    if( pVendor->bit_mask & (productId_present) )
    {
        pDestVendorInfo ->pProductNumber = new H323_OCTETSTRING;
        if( pDestVendorInfo ->pProductNumber == NULL )
        {
            goto cleanup;
        }

        pDestVendorInfo ->pProductNumber->wOctetStringLength = 
            (WORD)min(pVendor->productId.length, H323_MAX_PRODUCT_LENGTH - 1);

        pDestVendorInfo ->pProductNumber->pOctetString = (BYTE*)
            new char[pDestVendorInfo ->pProductNumber->wOctetStringLength + 1];

        if( pDestVendorInfo ->pProductNumber->pOctetString == NULL )
        {
            goto cleanup;
        }

        CopyMemory( (PVOID)pDestVendorInfo ->pProductNumber->pOctetString,
                (PVOID)pVendor->productId.value,
                pDestVendorInfo -> pProductNumber->wOctetStringLength );
        
        pDestVendorInfo ->pProductNumber->pOctetString[
            pDestVendorInfo ->pProductNumber->wOctetStringLength] = '\0';
    }
    
    if( pVendor->bit_mask & versionId_present )
    {
        pDestVendorInfo ->pVersionNumber = new H323_OCTETSTRING;

        if( pDestVendorInfo ->pVersionNumber == NULL )
        {
            goto cleanup;
        }
        
        pDestVendorInfo ->pVersionNumber->wOctetStringLength = 
            (WORD)min(pVendor->versionId.length, H323_MAX_VERSION_LENGTH - 1);

        pDestVendorInfo ->pVersionNumber->pOctetString = (BYTE*)
            new char[pDestVendorInfo ->pVersionNumber->wOctetStringLength+1];

        if( pDestVendorInfo ->pVersionNumber->pOctetString == NULL )
        {
            goto cleanup;
        }

        CopyMemory( (PVOID)pDestVendorInfo ->pVersionNumber->pOctetString,
                (PVOID)pVendor->versionId.value,
                pDestVendorInfo ->pVersionNumber->wOctetStringLength);

        pDestVendorInfo ->pVersionNumber->pOctetString[
            pDestVendorInfo ->pVersionNumber->wOctetStringLength] = '\0';
    }

    return TRUE;

cleanup:

    FreeVendorInfo( pDestVendorInfo );
    return FALSE;
}

BOOL 
ParseNonStandardData( 
    OUT H323NonStandardData *       dstNonStdData,
    IN H225NonStandardParameter *   srcNonStdData
    )
{
    H221NonStandard & h221NonStdData = 
        srcNonStdData ->nonStandardIdentifier.u.h221NonStandard;

    if( srcNonStdData ->nonStandardIdentifier.choice ==
            H225NonStandardIdentifier_h221NonStandard_chosen )
    {
        dstNonStdData ->bCountryCode = (BYTE)(h221NonStdData.t35CountryCode);
        dstNonStdData ->bExtension = (BYTE)(h221NonStdData.t35Extension);
        dstNonStdData ->wManufacturerCode = h221NonStdData.manufacturerCode;
    }

    dstNonStdData->sData.wOctetStringLength = (WORD)srcNonStdData->data.length;

    dstNonStdData ->sData.pOctetString =
        (BYTE *)new char[dstNonStdData ->sData.wOctetStringLength];

    if( dstNonStdData -> sData.pOctetString == NULL )
    {
        return FALSE;
    }
    
    CopyMemory( (PVOID)dstNonStdData ->sData.pOctetString,
            (PVOID)srcNonStdData ->data.value,
            dstNonStdData ->sData.wOctetStringLength );

    return TRUE;
}


BOOL 
AliasAddrToAliasNames( 
                        OUT PH323_ALIASNAMES *ppTarget, 
                        IN Setup_UUIE_sourceAddress *pSource
                     )
{
    Setup_UUIE_sourceAddress *CurrentNode = NULL;
    WORD wCount = 0;
    int indexI = 0;
    HRESULT hr;

    *ppTarget = NULL;

    for( CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next )
    {
        wCount++;
    }

    if( wCount == 0 )
    {
        return TRUE;
    }

    *ppTarget = new H323_ALIASNAMES;
    if (*ppTarget == NULL)
    {
        return FALSE;
    }
    ZeroMemory( *ppTarget, sizeof(H323_ALIASNAMES) );
    (*ppTarget)->pItems = new H323_ALIASITEM[wCount];

    if( (*ppTarget)->pItems == NULL )
    {
        goto cleanup;
    }

    for( CurrentNode = pSource; CurrentNode; CurrentNode = CurrentNode->next )
    {
        hr = AliasAddrToAliasItem( &((*ppTarget)->pItems[indexI]),
            &(CurrentNode->value));

        if( hr == E_OUTOFMEMORY )
        {
            WORD indexJ;
            //Free everything that has been allocated so far...
            for (indexJ = 0; indexJ < indexI; indexJ++)
            {
                delete (*ppTarget)->pItems[indexJ].pData;
            }
            goto cleanup;
        }
        else if( SUCCEEDED(hr) )
        {
            indexI++;
        }
    }

    // any aliases?
    if (indexI > 0)
    {
        // save number of aliases
        (*ppTarget)->wCount = (WORD)indexI;
    } 
    else 
    {
        //free everything
        delete (*ppTarget)->pItems;
        delete (*ppTarget);
        *ppTarget = NULL;
        return FALSE;
    }

    return TRUE;

cleanup:
    if( *ppTarget )
    {
        if( (*ppTarget)->pItems )
        {
            delete (*ppTarget)->pItems;
        }

        delete( *ppTarget );
        *ppTarget = NULL;
    }

    return FALSE;
}


HRESULT
AliasAddrToAliasItem(
                    OUT PH323_ALIASITEM pAliasItem,
                    IN AliasAddress *   pAliasAddr
                    )
{
    WORD indexI;

    if( pAliasItem == NULL )
    {
        return E_FAIL;
    }

    memset( (PVOID)pAliasItem, 0, sizeof(H323_ALIASITEM) );

    switch( pAliasAddr->choice )
    {
    case h323_ID_chosen:

        pAliasItem->wType = h323_ID_chosen;
        
        if ((pAliasAddr->u.h323_ID.length != 0) &&
            (pAliasAddr->u.h323_ID.value  != NULL))
        {
            pAliasItem->wDataLength = (WORD)pAliasAddr->u.h323_ID.length;
            pAliasItem->pData = 
                (LPWSTR)new char[(pAliasItem->wDataLength+1) * sizeof(WCHAR)];
            
            if (pAliasItem->pData == NULL)
            {
                return E_OUTOFMEMORY;
            }

            CopyMemory( (PVOID)pAliasItem->pData,
                    (PVOID)pAliasAddr->u.h323_ID.value,
                    pAliasItem->wDataLength * sizeof(WCHAR) );
            pAliasItem->pData[pAliasItem->wDataLength] = L'\0';
        }
        break;

    case e164_chosen:

        pAliasItem->wType = e164_chosen;
        pAliasItem->wDataLength = (WORD)strlen(pAliasAddr->u.e164);
        pAliasItem->pData = 
            (LPWSTR)new char[(pAliasItem->wDataLength + 1) * sizeof(WCHAR)];

        if( pAliasItem->pData == NULL )
        {
            return E_OUTOFMEMORY;
        }

        //converting from byte to UNICODE
        for (indexI = 0; indexI < pAliasItem->wDataLength; indexI++)
        {
            pAliasItem->pData[indexI] = (WCHAR)pAliasAddr->u.e164[indexI];
        }

        pAliasItem->pData[pAliasItem->wDataLength] = '\0';
        break;

    default:
        return E_INVALIDARG;
    } // switch

    return S_OK;
}


void FreeFacilityASN(
    IN Q931_FACILITY_ASN* pFacilityASN
    )
{
    //free non standard data
    if( pFacilityASN->fNonStandardDataPresent != NULL )
    {
        delete pFacilityASN->nonStandardData.sData.pOctetString;
        pFacilityASN->nonStandardData.sData.pOctetString =NULL;
    }
    
    if( pFacilityASN->pAlternativeAliasList != NULL )
    {
        FreeAliasNames(pFacilityASN->pAlternativeAliasList );
        pFacilityASN->pAlternativeAliasList  = NULL;
    }
}


void FreeAlertingASN( 
                     IN Q931_ALERTING_ASN* pAlertingASN
                    )
{
    FreeProceedingASN( (Q931_CALL_PROCEEDING_ASN*)pAlertingASN );
}

void FreeProceedingASN( 
                      IN Q931_CALL_PROCEEDING_ASN* pProceedingASN
                      )
{
    //free non standard data
    if( pProceedingASN->fNonStandardDataPresent == TRUE )
    {
        delete pProceedingASN->nonStandardData.sData.pOctetString;
        pProceedingASN->nonStandardData.sData.pOctetString = NULL;
    }
    
    if( pProceedingASN->fFastStartPresent  &&pProceedingASN->pFastStart )
    {
        FreeFastStart( pProceedingASN->pFastStart );
    }
}


void FreeSetupASN(
    IN Q931_SETUP_ASN* pSetupASN
    )
{
    if( pSetupASN == NULL )
    {
        return;
    }

    if( pSetupASN->pExtensionAliasItem != NULL )
    {
        if( pSetupASN->pExtensionAliasItem -> pData != NULL )
        {
            delete pSetupASN->pExtensionAliasItem -> pData;
        }

        delete pSetupASN->pExtensionAliasItem;
    }

    if( pSetupASN->pExtraAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pExtraAliasList);
        pSetupASN->pExtraAliasList = NULL;
    }
    
    if( pSetupASN->pCalleeAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pCalleeAliasList);
        pSetupASN->pCalleeAliasList = NULL;
    }

    if( pSetupASN->pCallerAliasList != NULL )
    {
        FreeAliasNames(pSetupASN->pCallerAliasList);
        pSetupASN->pCallerAliasList = NULL;
    }

    if( pSetupASN->fNonStandardDataPresent == TRUE )
    {
        delete pSetupASN->nonStandardData.sData.pOctetString;
    }

    if( pSetupASN->EndpointType.pVendorInfo != NULL )
    {
        FreeVendorInfo( pSetupASN->EndpointType.pVendorInfo );
    }

    if( pSetupASN->fFastStartPresent == TRUE )
    {
        if( pSetupASN->pFastStart != NULL )
        {
            FreeFastStart( pSetupASN->pFastStart );
        }
    }
}


void FreeConnectASN(
                    IN Q931_CONNECT_ASN *pConnectASN
                   )
{
    if( pConnectASN != NULL )
    {
        // Cleanup any dynamically allocated fields within SetupASN
        if (pConnectASN->nonStandardData.sData.pOctetString)
        {
            delete pConnectASN->nonStandardData.sData.pOctetString;
            pConnectASN->nonStandardData.sData.pOctetString = NULL;
        }

        if( pConnectASN->EndpointType.pVendorInfo != NULL )
        {
            FreeVendorInfo( pConnectASN->EndpointType.pVendorInfo );
        }

        if( pConnectASN->fFastStartPresent == TRUE )
        {
            if( pConnectASN->pFastStart != NULL )
            {
                FreeFastStart( pConnectASN->pFastStart );
            }
        }
    }
}


void 
FreeFastStart(
               IN PH323_FASTSTART pFastStart
             )
{
    PH323_FASTSTART pTempFastStart;

    while( pFastStart )
    {
        pTempFastStart = pFastStart -> next;

        if(pFastStart -> value)
        {
            delete pFastStart -> value;
        }

        delete pFastStart;

        pFastStart = pTempFastStart;
    }
}



//FastStart is a plain linked list because it is exactly the same struct
//as defined by ASN.1. This allows to pass on the m_pFastStart member to
//the ASN encoder directly without any conversons
PH323_FASTSTART
CopyFastStart(
              IN PSetup_UUIE_fastStart pSrcFastStart
             )
{
    PH323_FASTSTART pCurr, pHead = NULL, pTail = NULL;
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyFastStart entered." ));
    
    while( pSrcFastStart )
    {
        pCurr = new H323_FASTSTART;
        if( pCurr == NULL )
        {
            FreeFastStart( pHead );
            return NULL;
        }

        pCurr -> next = NULL;
        
        if( pHead == NULL )
        {
            pHead = pCurr;
        }
        else
        {
            pTail -> next = pCurr;
        }
        
        pTail = pCurr;

        pCurr -> length = pSrcFastStart -> value.length;
        pCurr -> value = (BYTE*)new char[pCurr -> length];
        if( pCurr -> value == NULL )
        {
            FreeFastStart( pHead );
            return NULL;
        }

        CopyMemory( (PVOID)pCurr -> value,
            (PVOID)pSrcFastStart -> value.value,
            pCurr -> length );

        pSrcFastStart = pSrcFastStart->next;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE, "CopyFastStart exited." ));
    return pHead;
}


void 
FreeVendorInfo( 
               IN PH323_VENDORINFO pVendorInfo 
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeVendorInfo entered." ));

    if( pVendorInfo != NULL )
    {
        if( pVendorInfo ->pProductNumber != NULL )
        {
            if( pVendorInfo ->pProductNumber->pOctetString != NULL )
            {
                delete pVendorInfo ->pProductNumber->pOctetString;
            }

            delete pVendorInfo ->pProductNumber;
        }

        if( pVendorInfo ->pVersionNumber != NULL )
        {
            if( pVendorInfo ->pVersionNumber->pOctetString != NULL )
            {
                delete pVendorInfo ->pVersionNumber->pOctetString;
            }

            delete pVendorInfo ->pVersionNumber;
        }

        memset( (PVOID) pVendorInfo, 0, sizeof(H323_VENDORINFO) );
    }
        
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeVendorInfo exited." ));
}



void 
FreeAliasNames( 
               IN PH323_ALIASNAMES pSource
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasNames entered." ));

    if( pSource != NULL )
    {
        if( pSource->wCount != 0 )
        {
            // Free everything that has been allocated so far...
            int indexI;
            for( indexI = 0; indexI < pSource->wCount; indexI++ )
            {
                if( pSource->pItems[indexI].pPrefix != NULL )
                {
                    H323DBG(( DEBUG_LEVEL_TRACE, "delete prefix:%d.", indexI ));
                    delete pSource->pItems[indexI].pPrefix;
                }
                if( pSource->pItems[indexI].pData != NULL )
                {
                    H323DBG(( DEBUG_LEVEL_TRACE, "delete pdata:%d.", indexI ));
                    delete pSource->pItems[indexI].pData;
                }
            }
            if( pSource->pItems != NULL )
            {
                H323DBG(( DEBUG_LEVEL_TRACE, "delete pitems." ));
                delete pSource->pItems;
            }
        }
        
        H323DBG(( DEBUG_LEVEL_TRACE, "outta loop." ));
        delete pSource;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasNames exited." ));
}


void
FreeAliasItems(
               IN PH323_ALIASNAMES pSource
              )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasItems entered." ));

    if( pSource != NULL )
    {
        if( pSource->wCount != 0 )
        {
            // Free everything that has been allocated so far...
            int indexI;
            for( indexI = 0; indexI < pSource->wCount; indexI++ )
            {
                if( pSource->pItems[indexI].pPrefix )
                {
                    delete pSource->pItems[indexI].pPrefix;
                }
                if( pSource->pItems[indexI].pData )
                {
                    delete pSource->pItems[indexI].pData;
                }
            }
            if( pSource->pItems != NULL )
            {
                delete pSource->pItems;
                pSource->pItems = NULL;
            }
            pSource->wCount = 0;
        }
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "FreeAliasItems exited." ));
}

void 
SetupTPKTHeader(
                OUT BYTE *  pbTpktHeader, 
                IN DWORD   dwLength
                )
{
    dwLength += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    _ASSERTE( dwLength < (1L << 16));

    pbTpktHeader[0] = TPKT_VERSION;
    pbTpktHeader[1] = 0;
    pbTpktHeader[2] = (BYTE)(dwLength >> 8);
    pbTpktHeader[3] = (BYTE)dwLength;
}

int
GetTpktLength( 
              IN char * pTpktHeader 
             )
{
    BYTE * pbTempPtr = (BYTE*)pTpktHeader;
    return (pbTempPtr[2] << 8) + pbTempPtr[3];
}


BOOL
AddAliasItem( 
            IN OUT PH323_ALIASNAMES pAliasNames,
            IN BYTE*                pbAliasName,
            IN DWORD                dwAliasSize,
            IN WORD                 wType
            )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "AddAliasItem entered." ));
    
    PH323_ALIASITEM pAliasItem;
    PH323_ALIASITEM tempPtr;

    tempPtr = (PH323_ALIASITEM)realloc( pAliasNames -> pItems,
        sizeof(H323_ALIASITEM) * (pAliasNames->wCount+1) );

    if( tempPtr == NULL )
    {
        //restore the old pointer in case enough memory was not available to 
        //expand the memory block
        return FALSE;
    }
    
    pAliasNames -> pItems = tempPtr;

    pAliasItem = &(pAliasNames -> pItems[pAliasNames->wCount]);

    pAliasItem->pData = (WCHAR*)new char[dwAliasSize];

    if( pAliasItem ->pData == NULL )
    {
        return FALSE;
    }
    pAliasNames->wCount++;

    // transfer memory
    CopyMemory((PVOID)pAliasItem ->pData,
        pbAliasName,
        dwAliasSize );

    // complete alias
    pAliasItem ->wType         = wType;
    pAliasItem ->wPrefixLength = 0;
    pAliasItem ->pPrefix       = NULL;
    pAliasItem ->wDataLength   = (WORD)wcslen(pAliasItem -> pData);
    _ASSERTE( ((pAliasItem->wDataLength+1)*2) == (WORD)dwAliasSize );

        
    H323DBG(( DEBUG_LEVEL_TRACE, "AddAliasItem exited." ));
    return TRUE;
}


void
FreeAddressAliases( 
                   IN PSetup_UUIE_destinationAddress pAddr 
                  )
{
    PSetup_UUIE_destinationAddress pTempAddr;

    while( pAddr )
    {
        pTempAddr = pAddr -> next;
        if( pAddr ->value.choice == h323_ID_chosen )
        {
            if( pAddr -> value.u.h323_ID.value )
            {
                delete pAddr -> value.u.h323_ID.value;
            }
        }

        delete pAddr;            
        pAddr = pTempAddr;
    }
}


void CopyTransportAddress(
                         OUT TransportAddress& transportAddress,
                         IN PH323_ADDR pCalleeAddr
                         )
{
    DWORD dwAddr = pCalleeAddr->Addr.IP_Binary.dwAddr;

    transportAddress.choice = ipAddress_chosen;
    transportAddress.u.ipAddress.ip.length = 4;
    transportAddress.u.ipAddress.port 
        = pCalleeAddr->Addr.IP_Binary.wPort;
    *(DWORD*)transportAddress.u.ipAddress.ip.value =
        htonl( pCalleeAddr->Addr.IP_Binary.dwAddr );
    //ReverseAddressAndCopy( transportAddress.u.ipAddress.ip.value, dwAddr);
}


void 
AddressReverseAndCopy( 
                        OUT DWORD * pdwAddr, 
                        IN  BYTE *  addrValue
                     )
{
    BYTE *addr = (BYTE *)(pdwAddr);
    
    addr[3] = addrValue[0];
    addr[2] = addrValue[1];
    addr[1] = addrValue[2];
    addr[0] = addrValue[3];
}


Setup_UUIE_sourceAddress *
SetMsgAddressAlias( 
                    IN PH323_ALIASNAMES pAliasNames
                  )
{
    PH323_ALIASITEM pAliasItem;
    Setup_UUIE_sourceAddress *addressAlias, *currHead = NULL;
    WORD    wCount;
    int     indexI;

    for( wCount=0; wCount < pAliasNames->wCount; wCount++ )
    {
        addressAlias = new Setup_UUIE_sourceAddress;

        if( addressAlias == NULL )
        {
            goto cleanup;
        }

        ZeroMemory( (PVOID)addressAlias, sizeof(Setup_UUIE_sourceAddress) );
        
        addressAlias -> next = currHead;
        currHead = addressAlias;
        
        pAliasItem = &(pAliasNames->pItems[wCount]);

        // then do the required memory copying.
        if( pAliasItem -> wType == h323_ID_chosen )
        {
            addressAlias ->value.choice = h323_ID_chosen;
            addressAlias ->value.u.h323_ID.length = pAliasItem -> wDataLength;

            _ASSERTE( pAliasItem -> wDataLength );

            addressAlias->value.u.h323_ID.value = 
                new WCHAR[pAliasItem -> wDataLength];
        
            if( addressAlias->value.u.h323_ID.value == NULL )
            {
                goto cleanup;
            }

            CopyMemory((PVOID)addressAlias->value.u.h323_ID.value,
                   (PVOID)pAliasItem->pData,
                   pAliasItem -> wDataLength * sizeof(WCHAR) );
        }
        else if( pAliasItem -> wType == e164_chosen )
        {
            addressAlias ->value.choice = e164_chosen;

            for( indexI =0; indexI < pAliasItem->wDataLength; indexI++ )
            {
                addressAlias->value.u.e164[indexI] = (BYTE)pAliasItem->pData[indexI];
            }

            addressAlias->value.u.e164[ pAliasItem->wDataLength ] = '\0';
        }
        else
        {
            continue;
        }
    }

    return currHead;

cleanup:

    FreeAddressAliases( (PSetup_UUIE_destinationAddress)currHead );
    return NULL;
}


/*BOOL 
SetSetupMsgAddressAliasWithPrefix(
                                  PH323_ALIASITEM pCallerAlias,
                                  Setup_UUIE_sourceAddress *addressAlias
                                 )
{

    UINT indexI;
    addressAlias -> next = NULL;
    UINT uPrefixLength = pCallerAlias -> wPrefixLength;
    UINT uDataLength = pCallerAlias -> wDataLength;

    if(pCallerAlias->wType == h323_ID_chosen)
    {
        addressAlias->value.choice = h323_ID_chosen;

        addressAlias->value.u.h323_ID.length = 
            (WORD)(uPrefixLength + uDataLength);

        if(!addressAlias->value.u.h323_ID.length)
        {
            addressAlias->value.u.h323_ID.value = NULL;
            //no data to copy
            return TRUE;
        }

        addressAlias->value.u.h323_ID.value =
            (WCHAR*)new char[(uPrefixLength + uDataLength) * sizeof(WCHAR)];
    
        if( addressAlias->value.u.h323_ID.value == NULL )
        {
            return FALSE;
        }
    
        addressAlias->value.u.h323_ID.length = (WORD)(uDataLength+uPrefixLength);
        
        if( uPrefixLength != 0 )
        {
            CopyMemory((PVOID)addressAlias->value.u.h323_ID.value,
                    (PVOID)pCallerAlias->pPrefix,
                    uPrefixLength * sizeof(WCHAR) );
        }            

        if( uDataLength != 0 )
        {
            CopyMemory((PVOID)&addressAlias->value.u.h323_ID.value[uPrefixLength],
                   (PVOID)pCallerAlias->pData,
                   uDataLength * sizeof(WCHAR) );
        }
    }
    else if(pCallerAlias->wType == e164_chosen )
    {
        addressAlias->value.choice = e164_chosen;
        for (indexI = 0; indexI < uPrefixLength; ++indexI)
        {
            addressAlias->value.u.e164[indexI] = (BYTE)(pCallerAlias->pPrefix[indexI]);
        }
        for (indexI = 0; indexI < uDataLength; ++indexI)
        {
            addressAlias->value.u.e164[uPrefixLength + indexI] = (BYTE)(pCallerAlias->pData[indexI]);
        }
        for (indexI = uDataLength + uPrefixLength; indexI < sizeof(addressAlias->value.u.e164); ++indexI)
        {
            addressAlias->value.u.e164[indexI] = 0;
        }
    }
    else
    {
        //un identified alias type
        return FALSE;
    }

    return TRUE;
}*/


void 
CopyVendorInfo( 
               OUT VendorIdentifier* vendor 
              )
{
    H323_VENDORINFO*  pVendorInfo = g_pH323Line -> GetVendorInfo();

    vendor->bit_mask = 0;
    vendor->vendor.t35CountryCode = pVendorInfo ->bCountryCode;
    vendor->vendor.t35Extension = pVendorInfo ->bExtension;
    vendor->vendor.manufacturerCode = pVendorInfo ->wManufacturerCode;
    if (pVendorInfo ->pProductNumber && pVendorInfo ->pProductNumber->pOctetString &&
            pVendorInfo ->pProductNumber->wOctetStringLength)
    {
        vendor->bit_mask |= productId_present;
        vendor->productId.length =
            pVendorInfo ->pProductNumber->wOctetStringLength;
        CopyMemory( (PVOID)&vendor->productId.value,
            (PVOID)pVendorInfo ->pProductNumber->pOctetString,
            pVendorInfo ->pProductNumber->wOctetStringLength);
    }
    if (pVendorInfo ->pVersionNumber && pVendorInfo ->pVersionNumber->pOctetString &&
            pVendorInfo ->pVersionNumber->wOctetStringLength)
    {
        vendor->bit_mask |= versionId_present;
        vendor->versionId.length =
            pVendorInfo ->pVersionNumber->wOctetStringLength;
        CopyMemory( (PVOID)&vendor->versionId.value,
            (PVOID)pVendorInfo ->pVersionNumber->pOctetString,
            pVendorInfo ->pVersionNumber->wOctetStringLength);
    }
}


// check to see if entry is in list
BOOL 
IsInList( 
        IN LIST_ENTRY * List, 
        IN LIST_ENTRY * Entry
        )
{
    LIST_ENTRY *    Pos;

    for( Pos = List -> Flink; Pos != List; Pos = Pos -> Flink )
    {
        if( Pos == Entry )
        {
            return TRUE;
        }
    }

    return FALSE;
}


void WriteProtocolDiscriminator(
                                PBUFFERDESCR    pBuf,
                                DWORD *         dwPDULen
                               )
{
    // space for the length byte
    (*dwPDULen)++;

    _ASSERTE( pBuf->dwLength > *dwPDULen );

    *(PDTYPE *)pBuf->pbBuffer = Q931PDVALUE;
    pBuf->pbBuffer += sizeof(PDTYPE);
}

//------------------------------------------------------------------------------
// Write a variable length Q931 call reference.  See Q931 section 4.3.
//------------------------------------------------------------------------------

void 
WriteCallReference(
                    PBUFFERDESCR    pBuf,
                    WORD *          pwCallReference,
                    DWORD *         pdwPDULen 
                  )
{
    int indexI;

    // space for the length byte
    (*pdwPDULen) += 1+ sizeof(WORD);

    _ASSERTE( pBuf->dwLength > *pdwPDULen );

    // the length byte
    *pBuf->pbBuffer = (BYTE)sizeof(WORD);
    pBuf->pbBuffer++;

    for (indexI = 0; indexI < sizeof(WORD); indexI++)
    {
        // Copy the value bytes to the buffer
        *pBuf->pbBuffer =
            (BYTE)(((*pwCallReference) >> ((sizeof(WORD) - 1 -indexI) * 8)) & 0xff);
        pBuf->pbBuffer++;
    }
}


void
FreeCallForwardParams( 
                      IN PCALLFORWARDPARAMS pCallForwardParams
                     )
{
    LPFORWARDADDRESS pForwardedAddress, pTemp;

    if( pCallForwardParams != NULL )
    {
        if( pCallForwardParams->divertedToAlias.pData != NULL )
        {
            delete pCallForwardParams->divertedToAlias.pData;
        }

        pForwardedAddress = pCallForwardParams->pForwardedAddresses;
        while( pForwardedAddress )
        {
            pTemp = pForwardedAddress->next;
            FreeForwardAddress( pForwardedAddress );
            pForwardedAddress = pTemp;
        }

        delete pCallForwardParams;
    }
}


void    
FreeForwardAddress( 
                   IN LPFORWARDADDRESS pForwardAddress
                  )
{
    if( pForwardAddress != NULL )
    {
        if( pForwardAddress->callerAlias.pData != NULL )
        {
            delete pForwardAddress->callerAlias.pData;
        }

        if( pForwardAddress->divertedToAlias.pData != NULL )
        {
            delete pForwardAddress->divertedToAlias.pData;
        }

        delete pForwardAddress;
    }
}



//Replaces first alias item in the alias list with the alias address passed.
BOOL
MapAliasItem(
    IN PH323_ALIASNAMES pCalleeAliasNames,
    IN AliasAddress*    pAliasAddress )
{
    int iIndex;

    _ASSERTE( pCalleeAliasNames && pCalleeAliasNames->pItems );

    if( pCalleeAliasNames != NULL )
    {
        switch( pAliasAddress->choice )
        {
        case e164_chosen:

            pCalleeAliasNames->pItems[0].wType = pAliasAddress->choice;
                
            if( pCalleeAliasNames->pItems[0].pData != NULL )
            {
                delete pCalleeAliasNames->pItems[0].pData;
            }
        
            pCalleeAliasNames->pItems[0].wDataLength = 
                (WORD)strlen( pAliasAddress->u.e164 );

            pCalleeAliasNames->pItems[0].pData = 
                new WCHAR[pCalleeAliasNames->pItems[0].wDataLength];

            if( pCalleeAliasNames->pItems[0].pData == NULL )
            {
                return FALSE;
            }

            for( iIndex=0; iIndex < pCalleeAliasNames->pItems[0].wDataLength;
                iIndex++ )
            {
                pCalleeAliasNames->pItems[0].pData[iIndex] =
                    pAliasAddress->u.e164[iIndex];
            }
            break;

        case h323_ID_chosen:

            pCalleeAliasNames->pItems[0].wType = pAliasAddress->choice;
                
            if( pCalleeAliasNames->pItems[0].pData != NULL )
            {
                delete pCalleeAliasNames->pItems[0].pData;
            }

            pCalleeAliasNames->pItems[0].wDataLength =
                (WORD)pAliasAddress->u.h323_ID.length;

            pCalleeAliasNames->pItems[0].pData =
                new WCHAR[pCalleeAliasNames->pItems[0].wDataLength];

            if( pCalleeAliasNames->pItems[0].pData == NULL )
            {
                return FALSE;
            }

            CopyMemory( (PVOID)pCalleeAliasNames->pItems[0].pData,
                (PVOID)pAliasAddress->u.h323_ID.value,
                pCalleeAliasNames->pItems[0].wDataLength );

            break;
        }
    }
    return TRUE;
}


//
//creates a new alias list and copies the first alias item from the given list.
//
PH323_ALIASNAMES 
DuplicateAliasName(
    PH323_ALIASNAMES pSrcAliasNames
    )
{
    PH323_ALIASNAMES pDestAliasNames = new H323_ALIASNAMES;
    
    if( pDestAliasNames == NULL )
    {
        return NULL;
    }

    ZeroMemory( pDestAliasNames, sizeof(H323_ALIASNAMES) );

    if( !AddAliasItem( 
            pDestAliasNames, 
            pSrcAliasNames->pItems[0].pData, 
            pSrcAliasNames->pItems[0].wType ) )
    {
        delete pDestAliasNames;
        return NULL;
    }

    return pDestAliasNames;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\q931obj.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    q931obj.h

Abstract:

    
Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#ifndef _Q931_OBJ_H_
#define _Q931_OBJ_H_

#define Q931_RECV_BUFFER_LENGTH     0x2000

typedef struct _RECVBUF
{
     WSABUF  WSABuf;
	 union {
     OVERLAPPED Overlapped;
	 LIST_ENTRY ListEntry;
	 };
     DWORD  dwBytesCopied;
     DWORD  dwPDULen;
     char   arBuf[Q931_RECV_BUFFER_LENGTH];
} RECVBUF;

void FreeAddressAliases( PSetup_UUIE_destinationAddress pAddr );
void CopyTransportAddress( TransportAddress& transportAddress,
                           PH323_ADDR pCalleeAddr );
void AddressReverseAndCopy( DWORD *dwAddr, BYTE* addrValue );
Setup_UUIE_sourceAddress * SetMsgAddressAlias( 
                        PH323_ALIASNAMES pCallerAliasNames );
void CopyVendorInfo( VendorIdentifier* vendor );




HRESULT	Q931AcceptStart	(void);

void	Q931AcceptStop	(void);

BOOL	Q931AllocRecvBuffer	(
	OUT	RECVBUF **	ReturnRecvBuffer);

void	Q931FreeRecvBuffer (
	IN	RECVBUF *	RecvBuffer);

#define Q931_CONN_QUEUE_LEN         64
#define	ACCEPT_BUFFER_LENGTH		((sizeof(SOCKADDR_IN) + 0x10) * 2)

class	Q931_LISTENER;

struct	Q931_ACCEPT_OVERLAPPED
{
	OVERLAPPED		Overlapped;
	LIST_ENTRY		ListEntry;
	Q931_LISTENER *	ParentObject;
	SOCKET			Socket;
	DWORD			BytesTransferred;
	BYTE			DataBuffer	[ACCEPT_BUFFER_LENGTH];
};


class	Q931_LISTENER
{
private:

	CRITICAL_SECTION	m_CriticalSection;
	SOCKET				m_ListenSocket;
	LIST_ENTRY			m_AcceptPendingList;	// contains ACCEPT_OVERLAPPED.ListEntry
	HANDLE				m_StopNotifyEvent;
	SOCKADDR_IN			m_SocketAddress;		// address (actually, only port) listening on

private:

    static void NTAPI IoCompletionCallback (
		IN	DWORD	dwStatus,
		IN	DWORD	BytesTransferred,
		IN	OVERLAPPED *	Overlapped);

    void	Lock	(void)	{ EnterCriticalSection (&m_CriticalSection); }
    void	Unlock	(void)	{ LeaveCriticalSection (&m_CriticalSection); }

	HRESULT	StartLocked	(void);

	HRESULT	AllocIssueAccept	(void);

	HRESULT	IssueAccept (
		IN	Q931_ACCEPT_OVERLAPPED *	AcceptOverlapped);

	void	CompleteAccept (
		IN	DWORD		dwStatus,
		IN	Q931_ACCEPT_OVERLAPPED *	AcceptOverlapped);

public:

	Q931_LISTENER	(void);
    ~Q931_LISTENER	(void);

	HRESULT		Start	(void);
	void		Stop	(void);
	void		WaitIo	(void);
    WORD        GetListenPort (void);
    void        HandleRegistryChange();

};

#endif //_Q931_OBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\media.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    media.cpp

Abstract:

    TAPI Service Provider functions related to media.

        TSPI_lineConditionalMediaDetection
        TSPI_lineGetID
        TSPI_lineMSPIdentify
        TSPI_lineReceiveMSPData
        TSPI_lineSetDefaultMediaDetection
        TSPI_lineSetMediaMode

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/
 

//                                                                           
// Include files                                                             
//                                                                           

#include "globals.h"
#include <initguid.h>
#include "line.h"
#include "ras.h"

// {0F1BE7F8-45CA-11d2-831F-00A0244D2298}
DEFINE_GUID(CLSID_IPMSP,
0x0F1BE7F8,0x45CA, 0x11d2, 0x83, 0x1F, 0x0, 0xA0, 0x24, 0x4D, 0x22, 0x98);


//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:

    If the Service Provider can monitor for the indicated set of media modes 
    AND support the capabilities indicated in pCallParams, then it sets the 
    indicated media moditoring modes for the line and replies with a "success" 
    indication.  Otherwise, it leaves the media monitoring modes for the line 
    unchanged and replies with a "failure" indication.  
    
    A TAPI lineOpen that specifies the device ID LINE_MAPPER typically results
    in calling this procedure for multiple line devices to hunt for a suitable
    line, possibly also opening as-yet unopened lines.  A "success" result 
    indicates that the line is suitable for the calling application's 
    requirements.  Note that the media monitoring modes demanded at the TSPI 
    level are the union of monitoring modes demanded by multiple applications
    at the TAPI level.  As a consequence of this, it is most common for 
    multiple media mode flags to be set simultaneously at this level.  The 
    Service Provider should test to determine if it can support at least the 
    specified set regardless of what modes are currently in effect.

    The Device ID LINE_MAPPER is never used at the TSPI level.

    The service provider shall return an error (e.g., LINEERR_RESOURCEUNAVAIL)
    if, at the time this function is called, it is impossible to place a new 
    call on the specified line device (in other words, if it would return 
    LINEERR_CALLUNAVAIL or LINEERR_RESOURCEUNAVAIL should TSPI_lineMakeCall be 
    invoked immediately after opening the line).

    The function operates strictly synchronously.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring and parameter capabilities tested and set.

    dwMediaModes - Specifies the media mode(s) of interest to the app, of 
        type LINEMEDIAMODE. The dwMediaModes parameter is used to register 
        the app as a potential target for inbound call and call hand off for 
        the specified media mode. This parameter is ignored if the OWNER flag 
        is not set in dwPrivileges. 

    pCallParams - Specifies a far pointer to a structure of type 
        LINECALLPARAMS.  It describes the call parameters that the line device 
        should be able to provide.  

Return Values:

    Returns zero if the function is successful, or a negative error number if 
    an error has occurred. Possible error returns are:

        LINEERR_INVALADDRESSMODE - The address mode is invalid.

        LINEERR_INVALBEARERMODE - The bearer mode is invalid.

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

        LINEERR_RESOURCEUNAVAIL - The specified operation cannot be completed 
            because of resource overcommitment.

--*/
LONG
TSPIAPI
TSPI_lineConditionalMediaDetection(
    HDRVLINE               hdLine, 
    DWORD                  dwMediaModes,
    LPLINECALLPARAMS const pCallParams
    )
{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCondMediaDetect - Entered." ));
    
    // attempt to close line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_INVALLINEHANDLE;
    }

    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "do not support media modes 0x%08lx.",
             dwMediaModes ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }

    // validate pointer
    if (pCallParams != NULL)
    {
        // see if we support media modes specified
        if (pCallParams->dwMediaMode & ~H323_LINE_MEDIAMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR, 
                "do not support media modes 0x%08lx.",
                 pCallParams->dwMediaMode ));

            // do not support media mode
            return LINEERR_INVALMEDIAMODE;
        }

        // see if we support bearer modes
        if (pCallParams->dwBearerMode & ~H323_LINE_BEARERMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "do not support bearer mode 0x%08lx.",
                pCallParams->dwBearerMode ));

            // do not support bearer mode
            return LINEERR_INVALBEARERMODE;
        }

        // see if we support address modes
        if (pCallParams->dwAddressMode & ~H323_LINE_ADDRESSMODES)
        {
            H323DBG(( DEBUG_LEVEL_ERROR,
                "do not support address mode 0x%08lx.",
                pCallParams->dwAddressMode ));

            // do not support address mode
            return LINEERR_INVALADDRESSMODE;
        }
    }

    // retrieve line device pointer from handle
    if (g_pH323Line -> GetHDLine() != hdLine)
    {
        // invalid line device handle
        return LINEERR_INVALLINEHANDLE;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineCondMediaDetect - Entered." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineGetID(
    HDRVLINE    hdLine,
    DWORD       dwAddressID,
    HDRVCALL    hdCall,
    DWORD       dwSelect,
    LPVARSTRING pDeviceID,
    LPCWSTR     pwszDeviceClass,
    HANDLE      hTargetProcess
    )
    
/*++

Routine Description:

    This function returns a device ID for the specified device class 
    associated with the selected line, address or call.

    This function can be used to retrieve a line device ID given a 
    line handle. Although the TAPI DLL has sufficient information to 
    determine the line device ID from a line handle, it may still call 
    this operation in such a fashion on behalf of an application that 
    has opened a line device using LINE_MAPPER.  The Service Provider 
    should support the "line" device class to allow applications to 
    determine the real line device ID of an opened line.

    This function can also be used to obtain the device ID of a phone 
    device or media device (e.g., mci waveform, mci midi, wave, fax, 
    etc.) associated with a call, address or line. This ID can then be 
    used with the appropriate API (e.g., phone, mci, midi, wave, etc.) 
    to select the corresponding media device associated with the specified 
    call.

    Note that the notion of Windows device class is different from that of 
    media mode. For example, the interactive voice or stored voice media 
    modes may be accessed using either the mci waveaudio or the low level 
    wave device classes. A media modes describes a format of information 
    on a call, a device class defines a Windows API used to manage that 
    stream. Often, a single media stream may be accessed using multiple 
    device classes, or a single device class (e.g., the Windows COMM API) 
    may provide access to multiple media modes. 

    Note that a new device class value is defined in TAPI 2.0: 
    
        "comm/datamodem/portname" 
        
    When TSPI_lineGetID is called specifying this device class on a line 
    device that supports the class, the VARSTRING structure returned will 
    contain a null-terminated ANSI (not UNICODE) string specifying the name 
    of the port to which the specified modem is attached, such as "COM1\0". 
    This is intended primarily for identification purposes in user interface, 
    but could be used under some circumstances to open the device directly, 
    bypassing the service provider (if the service provider does not already 
    have the device open itself). If there is no port associated with the 
    device, a null string ("\0") is returned in the VARSTRING structure (with 
    a string length of 1).

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line 
        to be queried.

    dwAddressID - Specifies an address on the given open line device.

    hdCall - Specifies the Service Provider's opaque handle to the call 
        to be queried.

    dwSelect - Specifies the whether the device ID requested is associated 
        with the line, address or a single call, of type LINECALLSELECT. 

    pDeviceID - Specifies a far pointer to the memory location of type 
        VARSTRING where the device ID is returned. Upon successful completion 
        of the request, this location is filled with the device ID. The 
        format of the returned information depends on the method used by the 
        device class (API) for naming devices. 

    pwszDeviceClass - Specifies a far pointer to a NULL-terminated ASCII 
        string that specifies the device class of the device whose ID is 
        requested. Valid device class strings are those used in the SYSTEM.INI 
        section to identify device classes.

    hTargetProcess - The process handle of the application on behalf of which 
        the TSPI_lineGetID function is being invoked. If the information being 
        returned in the VARSTRING structure includes a handle for use by the 
        application, the service provider should create or duplicate the handle
        for the process.

        If hTargetProcess is set to INVALID_HANDLE_VALUE, then the application
        is executing on a remote client system and it is not possible to create
        a duplicate handle directly. Instead, the VARSTRING structure should 
        contain a UNC name of a network device or other name that the remote 
        client can use to access the device. If this is not possible, then the 
        function should fail.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The hdCall parameter is an invalid handle.

        LINEERR_INVALCALLSELECT - The specified dwCallSelect parameter is 
            invalid.

        LINEERR_INVALCALLSTATE - One or more of the specified calls are not in 
            a valid state for the requested operation. 

        LINEERR_NODEVICE - The line device has no associated device for the 
            given device class.

        LINEERR_STRUCTURETOOSMALL - The dwTotalSize member of a structure does 
            not specify enough memory to contain the fixed portion of the 
            structure. The dwNeededSize field has been set to the amount 
            required.
        
--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineGetID - Entered." ));
    // do not support device
    return LINEERR_NODEVICE;
}


LONG
TSPIAPI
TSPI_lineMSPIdentify(
    DWORD  dwDeviceID,
    GUID * pCLSID
    )
    
/*++

Routine Description:

    This procedure is called after TAPI has initialized the line device in 
    order to determine the assoicated Media Service Provider.

Arguments:

    dwDeviceID - Identifies the line device to be opened.  The value 
        LINE_MAPPER for a device ID is not permitted.

    pCLSID - Points to a GUID-sized memory location which the service 
        provider writes the class identifier of the associated media 
        service provider.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 

--*/

{
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMSPIdentify - Entered." ));

    if( g_pH323Line -> GetDeviceID() != dwDeviceID )
    {
        // do not recognize device
        return LINEERR_BADDEVICEID; 
    }

    // copy class id
    *pCLSID = CLSID_IPMSP;
        
    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineMSPIdentify - Exited." ));
    
    // success
    return NOERROR;

}

    
/*++
Routine Description:

    This procedure is called to deliver a payload from the MSP.

Arguments:
    
    hdCall - Handle to line object.

    hdCall - Handle to call object associated with MSP.

    hdMSPLine - Handle to MSP.

    pBuffer - Pointer to opaque buffer with MSP data.

    dwSize - Size of buffer above.

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_OPERATIONFAILED - The operation failed for an unspecified or 
            unknown reason. 
--*/
LONG 
TSPIAPI 
TSPI_lineReceiveMSPData( 
    HDRVLINE hdLine,
    HDRVCALL hdCall,
    HDRVMSPLINE hdMSPLine,
    LPVOID pBuffer, 
    DWORD dwSize 
    )
{
    HTAPIMSPLINE htMSPLine;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRecvMSPData - Entered." ));
    
    // line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }

    PH323_CALL pCall;
    PTspMspMessage pMessage = (PTspMspMessage)pBuffer;

    if( !g_pH323Line -> IsValidMSPHandle( hdMSPLine, &htMSPLine ) )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Invalid MSP handle:%lx.", hdMSPLine ));
        return LINEERR_RESOURCEUNAVAIL;
    }

    // see if call handle is valid
    pCall=g_pH323Line -> FindH323CallAndLock(hdCall);
    if( pCall == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "msp message-wrong call handle." ));
        return LINEERR_INVALCALLHANDLE;
    }

    // validate pointer and message size
    if( dwSize < pMessage -> dwMessageSize )
    {
        pCall -> Unlock();
        H323DBG(( DEBUG_LEVEL_ERROR, "msp message has wrong size." ));
        //error in processing message
        return LINEERR_OPERATIONFAILED;
    }

    //HandleMSPMessage unlocks the call object always.
    if(!pCall -> HandleMSPMessage( pMessage, hdMSPLine, htMSPLine ) )
    {
        //error in processing message
        return LINEERR_OPERATIONFAILED;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineRecvMSPData - Exited." ));
    
    // success
    return NOERROR;
}


/*++

Routine Description:

    This procedure tells the Service Provider the new set of Media Modes to 
    detect for the indicated line (replacing any previous set). It also sets 
    the initial set of Media Modes that should be monitored for on subsequent 
    calls (inbound or outbound) on this line. 

    The TAPI DLL typically calls this function to update the set of detected 
    media modes for the line to the union of all modes selected by all 
    outstanding lineOpens whenever a line is Opened or Closed at the TAPI 
    level. A lineOpen attempt is rejected if media detection is rejected. 
    A single call to this procedure is typically the result of a lineOpen 
    that does not specify the device ID LINE_MAPPER. The Device ID LINE_MAPPER
    is never used at the TSPI level.

Arguments:

    hdLine - Specifies the Service Provider's opaque handle to the line to 
        have media monitoring set.

    dwMediaModes - Specifies the media mode(s) of interest to the TAPI DLL, 
        of type LINEMEDIAMODE. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALLINEHANDLE - The specified line handle is invalid.

        LINEERR_INVALMEDIAMODE - One or more media modes specified as a 
            parameter or in a list is invalid or not supported by the the 
            service provider. 

--*/

LONG
TSPIAPI
TSPI_lineSetDefaultMediaDetection(
    HDRVLINE    hdLine,
    DWORD       dwMediaModes
    )
{
	HRESULT	hResult;

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetDefaultMediaDtect-Entered." ));
    
    // attempt to close line device
    if( hdLine != g_pH323Line -> GetHDLine() )
    {
        return LINEERR_RESOURCEUNAVAIL;
    }
        
    // see if unknown bit is specified 
    if (dwMediaModes & LINEMEDIAMODE_UNKNOWN)
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE, "clearing unknown media mode." ));

        // clear unknown bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_UNKNOWN;
    }

    // see if both audio bits are specified 
    if ((dwMediaModes & LINEMEDIAMODE_AUTOMATEDVOICE) &&
        (dwMediaModes & LINEMEDIAMODE_INTERACTIVEVOICE))
    {
        H323DBG(( DEBUG_LEVEL_VERBOSE,
            "clearing automated voice media mode." ));

        // clear extra audio bit from modes
        dwMediaModes &= ~LINEMEDIAMODE_INTERACTIVEVOICE;
    }

    // see if we support media modes specified
    if (dwMediaModes & ~H323_LINE_MEDIAMODES)
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "do not support media modes 0x%08lx.", dwMediaModes ));

        // do not support media mode
        return LINEERR_INVALMEDIAMODE;
    }
    
    H323DBG(( DEBUG_LEVEL_TRACE,
        "line %d enabled to detect media modes 0x%08lx.",
         g_pH323Line->GetDeviceID(), dwMediaModes ));

    g_pH323Line -> Lock();

    // record media modes to detect
    g_pH323Line->SetMediaModes( dwMediaModes );     

    // see if we need to start listening
    if( g_pH323Line -> IsMediaDetectionEnabled() &&
        (g_pH323Line -> GetState() != H323_LINESTATE_LISTENING)
      )
    {
        hResult = Q931AcceptStart();

        if( hResult != S_OK )
        {
            // release line device
            g_pH323Line -> Unlock();

            // could not cancel listen
            return LINEERR_OPERATIONFAILED;
        }
        g_pH323Line -> SetState( H323_LINESTATE_LISTENING );
        RasStart();
    }
    else if( (g_pH323Line -> GetState() == H323_LINESTATE_LISTENING) &&
             !g_pH323Line -> IsMediaDetectionEnabled() )
    {
        //stop listening means dont close exiting calls but stop accepting new
        //ones for some time close means close all the existing calls and stop
        //listening for new ones

        Q931AcceptStop();
        //RasStop();

        g_pH323Line -> SetState( H323_LINESTATE_OPENED );
    }
               
    // release line device
    g_pH323Line -> Unlock();

    H323DBG(( DEBUG_LEVEL_TRACE, "TSPI_lineSetDefaultMediaDetect - Exited." ));
    
    // success
    return NOERROR;
}


LONG
TSPIAPI
TSPI_lineSetMediaMode(
    HDRVCALL hdCall,
    DWORD    dwMediaMode
    )
    
/*++

Routine Description:

    This function changes the call's media as stored in the call's 
    LINECALLINFO structure.

    Other than changing the call's media as stored in the call's 
    LINECALLINFO structure, this procedure is simply "advisory" in the sense 
    that it indicates an expected media change that is about to occur, rather 
    than forcing a specific change to the call.  Typical usage is to set a 
    calls media mode to a specific known media mode, or to exclude possible 
    media modes as long as the call's media mode is not fully known; i.e., 
    the UNKNOWN media mode flag is set.

Arguments:

    hdCall - Specifies the Service Provider's opaque handle to the call 
        undergoing a change in media mode.  Valid call states: any.

    dwMediaMode - Specifies the new media mode(s) for the call, of type 
        LINEMEDIAMODE. As long as the UNKNOWN media mode flag is set, 
        multiple other media mode flags may be set as well. This is used 
        to indentify a call's media mode as not fully determined, but 
        narrowed down to one of just a small set of specified media modes. 
        If the UNKNOWN flag is not set, then only a single media mode can 
        be specified. 

Return Values:

    Returns zero if the function is successful or a negative error 
    number if an error has occurred. Possible error returns are:

        LINEERR_INVALCALLHANDLE - The specified call handle is invalid.

        LINEERR_INVALMEDIAMODE - The specified media mode parameter is invalid.

        LINEERR_OPERATIONUNAVAIL - The specified operation is not available.

        LINEERR_OPERATIONFAILED - The specified operation failed for 
            unspecified reasons.

--*/

{
    return LINEERR_OPERATIONUNAVAIL; // CODEWORK...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\q931obj.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    q931obj.cpp

Abstract:

    Functionality for accepting the Q931 connections.

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/

#include "globals.h"
#include "q931obj.h"
#include "line.h"
#include "q931pdu.h"
#include "winbase.h"
#include "ras.h"



class   Q931_BUFFER_CACHE
{
private:

    enum { RECV_BUFFER_LIST_COUNT_MAX = 0x10 };

    CRITICAL_SECTION        m_CriticalSection;
    LIST_ENTRY              m_FreeRecvBufferList;
    DWORD                   m_FreeRecvBufferListCount;

private:

    void    Lock    (void)  { EnterCriticalSection (&m_CriticalSection); }
    void    Unlock  (void)  { LeaveCriticalSection (&m_CriticalSection); }

public:

    Q931_BUFFER_CACHE   (void);
    ~Q931_BUFFER_CACHE  (void);

    BOOL    AllocRecvBuffer     (
        OUT RECVBUF **  ReturnRecvBuffer);

    void    FreeRecvBuffer      (
        IN  RECVBUF *   RecvBuffer);

    void    FreeAll     (void);
};


// global data

        Q931_LISTENER       Q931Listener;
static  Q931_BUFFER_CACHE   Q931BufferCache;


HRESULT 
Q931AcceptStart (void)
{
    return Q931Listener.Start();
}


void 
Q931AcceptStop (void)
{
    H323DBG(( DEBUG_LEVEL_TRACE, "Q931AcceptStop entered." ));
    
    Q931Listener.Stop();
    Q931Listener.WaitIo();

    H323DBG(( DEBUG_LEVEL_TRACE, "Q931AcceptStop exited." ));
}


void 
Q931FreeRecvBuffer (
    IN  RECVBUF *   RecvBuffer)
{
    Q931BufferCache.FreeRecvBuffer (RecvBuffer);
}


BOOL 
Q931AllocRecvBuffer (
    OUT RECVBUF **  ReturnRecvBuffer)
{
    return Q931BufferCache.AllocRecvBuffer (ReturnRecvBuffer);
}

// Q931_LISTENER ---------------------------------------------------------

Q931_LISTENER::Q931_LISTENER (void)
{
    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );

    m_ListenSocket = INVALID_SOCKET;

    InitializeListHead (&m_AcceptPendingList);

    H225ASN_Module_Startup();
    H4503PP_Module_Startup();

    _ASSERTE( H225ASN_Module );
    _ASSERTE( H4503PP_Module );

    m_StopNotifyEvent = H323CreateEvent (NULL, TRUE, TRUE, 
        _T( "H323TSP_StopIncomingCallNotify" ) );

    if( m_StopNotifyEvent == NULL )
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to create stop notify event -- will be unable to accept Q.931 connections" ));
    }
}


Q931_LISTENER::~Q931_LISTENER (void)
{
    DeleteCriticalSection (&m_CriticalSection);

    _ASSERTE( m_ListenSocket == INVALID_SOCKET );
    _ASSERTE( IsListEmpty (&m_AcceptPendingList) );

    if (m_StopNotifyEvent)
    {
        CloseHandle (m_StopNotifyEvent);
        m_StopNotifyEvent = NULL;
    }

    if( H225ASN_Module )
    {
        H225ASN_Module_Cleanup();
    }

    if( H4503PP_Module )
    {
        H4503PP_Module_Cleanup();
    }
}


HRESULT Q931_LISTENER::Start (void)
{
    HRESULT hr;

    Lock();

    hr = StartLocked();
    if (hr != S_OK)
    {
        if (m_ListenSocket != INVALID_SOCKET)
        {
            closesocket (m_ListenSocket);
            m_ListenSocket = INVALID_SOCKET;
        }
    }

    Unlock();

    return hr;
}


HRESULT Q931_LISTENER::StartLocked (void)
{
    INT SocketAddressLength;

    if( m_ListenSocket != INVALID_SOCKET )
    {
        return S_OK;
    }

    m_ListenSocket = WSASocket( 
        AF_INET, 
        SOCK_STREAM, 
        IPPROTO_TCP, 
        NULL, 
        0, 
        WSA_FLAG_OVERLAPPED );

    if (m_ListenSocket == INVALID_SOCKET)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, "Q931: failed to create listen socket" ));
        DumpError (GetLastError());
        return GetLastResult();
    }

    m_SocketAddress.sin_family = AF_INET;
    m_SocketAddress.sin_addr.s_addr = htonl (INADDR_ANY);
    m_SocketAddress.sin_port = 
        htons( (WORD)g_RegistrySettings.dwQ931ListenPort );

    if( bind( m_ListenSocket,
            (SOCKADDR *)&m_SocketAddress, 
            sizeof (SOCKADDR_IN) )
            == SOCKET_ERROR)
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to bind to requested port (%d), will try to use dynamic port.",
            g_RegistrySettings.dwQ931ListenPort));

        //ReportTSPEvent( _T("Q931 listen socket failed to bind to port 1720") );

        if( g_RegistrySettings.fIsGKEnabled )
        {
            m_SocketAddress.sin_port = htons (0);

            if( bind( m_ListenSocket, (SOCKADDR *)&m_SocketAddress,
                    sizeof (SOCKADDR_IN) ) == SOCKET_ERROR )
            {
                H323DBG ((DEBUG_LEVEL_ERROR,"Q931: failed to request dynamic "
                    "port for Q.931-cannot accept Q.931 connections" ));

                return E_FAIL;
            }
        }
    }

    SocketAddressLength = sizeof (SOCKADDR_IN);

    if( getsockname( m_ListenSocket,
            (SOCKADDR *)&m_SocketAddress, 
            &SocketAddressLength) )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Q931: failed to query socket address from TCP -- unexpected behavior"));

        return E_FAIL;
    }

    if( listen( m_ListenSocket, Q931_CONN_QUEUE_LEN) == SOCKET_ERROR )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to begin listening on socket:%d",
            WSAGetLastError() ));
        return E_FAIL;
    }

    if( !H323BindIoCompletionCallback( (HANDLE)m_ListenSocket,
        Q931_LISTENER::IoCompletionCallback, 0) )
    {
        H323DBG ((DEBUG_LEVEL_ERROR, 
            "Q931: failed to bind listen socket to i/o completion callback" ));
        return E_FAIL;
    }

    H323DBG(( DEBUG_LEVEL_TRACE, 
        "Q931: listen socket created, bound, and ready to receive connections" ));


    // all looks good
    // issue initial accept buffer(s)

    AllocIssueAccept();
    AllocIssueAccept();
    AllocIssueAccept();
    AllocIssueAccept();

    return S_OK;
}


void 
Q931_LISTENER::Stop(void)
{
    Lock();

    if (m_ListenSocket != INVALID_SOCKET)
    {
        // this implicitly cancels all outstanding I/O against this socket
        closesocket (m_ListenSocket);
        m_ListenSocket = INVALID_SOCKET;
    }

    Unlock();
}


void 
Q931_LISTENER::WaitIo(void)
{
    WaitForSingleObject (m_StopNotifyEvent, INFINITE);
}


WORD 
Q931_LISTENER::GetListenPort(void)
{
    SOCKADDR_IN socketAddress;  
    int SocketAddressLength = sizeof (SOCKADDR_IN);
    ZeroMemory( (PVOID)&socketAddress, sizeof(SOCKADDR_IN) );

    Lock();

    if( getsockname( m_ListenSocket,
            (SOCKADDR *)&socketAddress, 
            &SocketAddressLength) )
    {
        H323DBG(( DEBUG_LEVEL_WARNING, 
            "Q931: failed to query socket address from TCP -- unexpected behavior"));

        Unlock();
        return 0;
    }

    Unlock();
    return ntohs(socketAddress.sin_port);
}


void
Q931_LISTENER::HandleRegistryChange()
{
    if( g_pH323Line -> GetState() == H323_LINESTATE_LISTENING )
    {
        if( g_RegistrySettings.dwQ931ListenPort != GetListenPort() )
        {
            Q931AcceptStop();
            Q931AcceptStart();
        }
    }
}


HRESULT 
Q931_LISTENER::AllocIssueAccept (void)
{
    Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped;
    HRESULT     hr;

    _ASSERTE( m_ListenSocket != INVALID_SOCKET );

    AcceptOverlapped = new Q931_ACCEPT_OVERLAPPED;
    if( AcceptOverlapped != NULL )
    {
        hr = IssueAccept (AcceptOverlapped);
        if (hr != S_OK)
        {
            delete AcceptOverlapped;
        }
    }
    else
    {
        H323DBG(( DEBUG_LEVEL_ERROR, 
            "Q931: failed to allocate connection accept buffer" ));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT 
Q931_LISTENER::IssueAccept (
    IN  Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped
    )
{
    HRESULT     hr;

    _ASSERTE( m_ListenSocket != INVALID_SOCKET );

    ZeroMemory (AcceptOverlapped, sizeof (Q931_ACCEPT_OVERLAPPED));

    AcceptOverlapped -> ParentObject = this;

    AcceptOverlapped -> Socket = WSASocket (
        AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (AcceptOverlapped -> Socket == INVALID_SOCKET)
    {
        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to create new accept socket"));
        DumpLastError();

        return GetLastResult();
    }

    if (!AcceptEx (m_ListenSocket,
        AcceptOverlapped -> Socket,
        AcceptOverlapped -> DataBuffer,
        0,
        sizeof (SOCKADDR_IN) + 0x10,
        sizeof (SOCKADDR_IN) + 0x10,
        &AcceptOverlapped -> BytesTransferred,
        &AcceptOverlapped -> Overlapped)
        && GetLastError() != ERROR_IO_PENDING)
    {
        hr = GetLastResult();

        H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to issue accept on new socket"));
        DumpLastError();

        closesocket (AcceptOverlapped -> Socket);

        return hr;
    }

    if (IsListEmpty (&m_AcceptPendingList))
    {
        ResetEvent (m_StopNotifyEvent);
    }

    InsertTailList (&m_AcceptPendingList, &AcceptOverlapped -> ListEntry);

    H323DBG ((DEBUG_LEVEL_TRACE, 
        "Q931: created new accept socket (%08XH), issued accept request.",
        (DWORD) AcceptOverlapped -> Socket));

    return S_OK;
}


// static
void 
Q931_LISTENER::IoCompletionCallback (
    IN  DWORD           dwStatus,
    IN  DWORD           BytesTransferred,
    IN  OVERLAPPED *    Overlapped
    )
{
    Q931_ACCEPT_OVERLAPPED *    AcceptOverlapped;

    _ASSERTE( Overlapped );

#if _WIN64
    _ASSERTE( (DWORD_PTR) Overlapped != 0xfeeefeeefeeefeee);
    _ASSERTE( (DWORD_PTR) Overlapped != 0xbaadf00dbaadf00d);
#else
    _ASSERTE( (DWORD) Overlapped != 0xfeeefeee);
    _ASSERTE( (DWORD) Overlapped != 0xbaadf00d);
#endif

    AcceptOverlapped = CONTAINING_RECORD(Overlapped, 
        Q931_ACCEPT_OVERLAPPED, Overlapped);
    AcceptOverlapped -> BytesTransferred = BytesTransferred;
    AcceptOverlapped -> ParentObject -> CompleteAccept( dwStatus, AcceptOverlapped );
}


void 
Q931_LISTENER::CompleteAccept(
    IN DWORD                    dwStatus,
    IN Q931_ACCEPT_OVERLAPPED * AcceptOverlapped
    )
{
    SOCKET          Socket = INVALID_SOCKET;
    SOCKADDR_IN     RemoteAddress;
    SOCKADDR_IN *   RemoteAddressPointer;
    INT             RemoteAddressLength;
    SOCKADDR_IN     LocalAddress;
    SOCKADDR_IN *   LocalAddressPointer;
    INT             LocalAddressLength;
    HRESULT         hr;
    DWORD               dwEnable = 1;

    Lock();

    _ASSERTE( IsInList (&m_AcceptPendingList, &AcceptOverlapped -> ListEntry) );
    RemoveEntryList (&AcceptOverlapped -> ListEntry);

    if (IsListEmpty (&m_AcceptPendingList))
    {
        SetEvent (m_StopNotifyEvent);
    }

    if (m_ListenSocket != INVALID_SOCKET)
    {
        if (dwStatus == ERROR_SUCCESS)
        {
            // extract parameters from accepted socket, copy to local stack frame.
            // this is necessary, because we will recycle AcceptOverlapped (with
            // a newly allocated socket) and process the new client later.
            // this gives a high degree of concurrency.

            RemoteAddressPointer = NULL;
            LocalAddressPointer = NULL;

            RemoteAddressLength = sizeof RemoteAddress;
            LocalAddressLength = sizeof LocalAddress;

            GetAcceptExSockaddrs (AcceptOverlapped -> DataBuffer,
                0, sizeof (SOCKADDR_IN), sizeof (SOCKADDR_IN),
                (SOCKADDR **) &RemoteAddressPointer,
                &RemoteAddressLength,
                (SOCKADDR **) &LocalAddressPointer,
                &LocalAddressLength);

            _ASSERTE( RemoteAddressPointer );
            _ASSERTE( LocalAddressPointer );

            if( (RemoteAddressPointer == NULL) || (LocalAddressPointer == NULL) )
            {
                return;
            }

            RemoteAddress = *RemoteAddressPointer;
            LocalAddress = *LocalAddressPointer;
            Socket = AcceptOverlapped -> Socket;

            if( setsockopt( AcceptOverlapped -> Socket, 
                    SOL_SOCKET, 
                    SO_UPDATE_ACCEPT_CONTEXT, 
                    reinterpret_cast <char *> (&m_ListenSocket), 
                    sizeof m_ListenSocket))
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                    "Q931: successfully accepted socket, but SO_UPDATE_ACCEPT_CONTEXT"
                    "failed -- future operations will fail" ));
                // don't fail here
            }

            if( setsockopt( Socket, IPPROTO_TCP, TCP_NODELAY, (char*)&dwEnable,
                sizeof(DWORD) ) == SOCKET_ERROR )
            {
                H323DBG(( DEBUG_LEVEL_WARNING, 
                    "Couldn't set NODELAY option on outgoing call socket:%d, %p", 
                    WSAGetLastError(), this ));
            }
        }
        else 
        {
            H323DBG ((DEBUG_LEVEL_ERROR, "Q931: failed to accept connection"));
            DumpError (dwStatus);

            Socket = INVALID_SOCKET;

            // we will allocate a new socket in IssueAccept
            // if we hit an error accepting on this socket,
            // it can't hurt to use a new socket, anyway.
            closesocket (AcceptOverlapped -> Socket);
        }

        // post the accept context for a new receive

        hr = IssueAccept (AcceptOverlapped);
        if (hr != S_OK)
        {
            H323DBG(( DEBUG_LEVEL_WARNING, "Q931: failed to issue accept on "
                "buffer -- reception of new Q.931 connections may stall" ));

            delete AcceptOverlapped;
        }
    }
    else
    {
        // future accept requests are denied -- module is shutting down.

        if( AcceptOverlapped -> Socket != INVALID_SOCKET )
        {
            closesocket( AcceptOverlapped -> Socket );
            AcceptOverlapped -> Socket = INVALID_SOCKET;
        }

        delete AcceptOverlapped;
    }

    Unlock();

    if (Socket != INVALID_SOCKET)
    {
        H323DBG(( DEBUG_LEVEL_TRACE, "Q931: accepted connection, remote address %08XH:%04X.",
            SOCKADDR_IN_PRINTF (&RemoteAddress)));

        // hand the newly accepted connection off to the call processing code.
        CallProcessIncomingCall (Socket, &LocalAddress, &RemoteAddress);
    }
}



// Q931_BUFFER_CACHE ----------------------------------------------------

Q931_BUFFER_CACHE::Q931_BUFFER_CACHE (void)
{
    // No need to check the result of this one since this object is
    // not allocated on heap, right when the DLL is loaded
    InitializeCriticalSectionAndSpinCount( &m_CriticalSection, 0x80000000 );

    InitializeListHead (&m_FreeRecvBufferList);
    m_FreeRecvBufferListCount = 0;
}

Q931_BUFFER_CACHE::~Q931_BUFFER_CACHE (void)
{
    Q931BufferCache.FreeAll();
    DeleteCriticalSection( &m_CriticalSection );
}


BOOL Q931_BUFFER_CACHE::AllocRecvBuffer (
    OUT RECVBUF **  ReturnRecvBuffer
    )
{
    LIST_ENTRY *    ListEntry;
    RECVBUF *       RecvBuffer;

    Lock();

    if (m_FreeRecvBufferListCount > 0)
    {
        m_FreeRecvBufferListCount--;

        _ASSERTE( IsListEmpty (&m_FreeRecvBufferList) == FALSE );
        ListEntry = RemoveHeadList (&m_FreeRecvBufferList);
        RecvBuffer = CONTAINING_RECORD (ListEntry, RECVBUF, ListEntry);
    }
    else
    {
        // perform global heap allocation after unlocking (better concurrency)
        RecvBuffer = NULL;
    }

    Unlock();

    if( RecvBuffer == NULL )
    {
        RecvBuffer = new RECVBUF;
    }

    *ReturnRecvBuffer = RecvBuffer;
    return !!RecvBuffer;
}


void 
Q931_BUFFER_CACHE::FreeRecvBuffer (
    IN  RECVBUF *   RecvBuffer
    )
{
    Lock();

    _ASSERTE( !IsInList (&m_FreeRecvBufferList, &RecvBuffer -> ListEntry));

    if (m_FreeRecvBufferListCount < RECV_BUFFER_LIST_COUNT_MAX)
    {
        InsertHeadList (&m_FreeRecvBufferList, &RecvBuffer -> ListEntry);
        m_FreeRecvBufferListCount++;
        RecvBuffer = NULL;
    }

    Unlock();

    if( RecvBuffer )
    {
        delete RecvBuffer;
    }
}

void 
Q931_BUFFER_CACHE::FreeAll (void)
{
    LIST_ENTRY *    ListEntry;
    RECVBUF *       RecvBuffer;

    Lock();

    while( IsListEmpty(&m_FreeRecvBufferList) == FALSE )
    {
        _ASSERTE( m_FreeRecvBufferListCount > 0 );
        m_FreeRecvBufferListCount--;

        ListEntry = RemoveHeadList (&m_FreeRecvBufferList);
        RecvBuffer = CONTAINING_RECORD (ListEntry, RECVBUF, ListEntry);

        delete RecvBuffer;
    }

    _ASSERTE( m_FreeRecvBufferListCount == 0 );

    Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\h323\tsp\provider.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    provider.cpp

Abstract:

    TAPI Service Provider functions related to provider info.

        TSPI_providerConfig
        TSPI_providerEnumDevices
        TSPI_providerFreeDialogInstance
        TSPI_providerGenericDialogData
        TSPI_providerInit
        TSPI_providerInstall
        TSPI_providerRemove
        TSPI_providerShutdown
        TSPI_providerUIIdentify

        TUISPI_providerConfig
        TUISPI_providerInstall
        TUISPI_providerRemove

Author:
    Nikhil Bobde (NikhilB)

Revision History:

--*/


//                                                                           
// Include files                                                             
//                                                                           


#include "globals.h"
#include "line.h"
#include "config.h"
#include "q931obj.h"
#include "ras.h"
     

//                                                                           
// Global variables                                                          
//                                                                           


DWORD				g_dwLineDeviceIDBase = -1;
DWORD				g_dwPermanentProviderID = -1;
LINEEVENT			g_pfnLineEventProc = NULL;
HANDLE              g_hCanUnloadDll = NULL;
HANDLE              g_hEventLogSource = NULL;
static	HPROVIDER   g_hProvider = NULL;
ASYNC_COMPLETION	g_pfnCompletionProc = NULL;



//                                                                           //
// Public procedures                                                         //
//                                                                           //

BOOL
H323IsTSPAlreadyInstalled(void)

/*++

Routine Description:

    Searchs registry for previous instance of H323.TSP.

Arguments:

    None.

Return Values:

    Returns true if TSP already installed.

--*/

{
    DWORD i;
    HKEY hKey;
    LONG lStatus;
    DWORD dwNumProviders = 0;
    DWORD dwDataSize = sizeof(DWORD);
    DWORD dwDataType = REG_DWORD;
    LPTSTR pszProvidersKey = TAPI_REGKEY_PROVIDERS;
    LPTSTR pszNumProvidersValue = TAPI_REGVAL_NUMPROVIDERS;
    TCHAR szName[H323_MAXPATHNAMELEN+1];
    TCHAR szPath[H323_MAXPATHNAMELEN+1];

    // attempt to open key
    lStatus = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                pszProvidersKey,
                0,
                KEY_READ,
                &hKey
                );

    // validate status
    if (lStatus != NOERROR)
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "error 0x%08lx opening tapi providers key.", lStatus ));

        // done
        return FALSE;
    }

    // see if installed bit set
    lStatus = RegQueryValueEx(
                hKey,
                pszNumProvidersValue,
                0,
                &dwDataType,
                (LPBYTE) &dwNumProviders,
                &dwDataSize
                );

    // validate status
    if( lStatus != NOERROR )
    {
        H323DBG(( DEBUG_LEVEL_WARNING,
            "error 0x%08lx determining number of providers.", lStatus ));

        // release handle
        RegCloseKey(hKey);

        // done
        return FALSE;
    }

    // loop through each provider
    for (i = 0; i < dwNumProviders; i++)
    {
        // construct path to provider name
        wsprintf(szName, _T("ProviderFileName%d"), i);

        // reinitialize size
        dwDataSize = sizeof(szPath);

        // query the next name
        lStatus = RegQueryValueEx(
                        hKey,
                        szName,
                        0,
                        &dwDataType,
                        (unsigned char*)szPath,
                        &dwDataSize
                        );

        // validate status
        if (lStatus == NOERROR)
        {
            // upper case
            _tcsupr(szPath);

            // compare path string to h323 provider
            if (_tcsstr(szPath, H323_TSPDLL) != NULL)
            {
                // release handle
                RegCloseKey(hKey);

                // done
                return TRUE;
            }

        } else {

            H323DBG((
                DEBUG_LEVEL_WARNING,
                "error 0x%08lx loading %s.",
                lStatus,
                szName
                ));
        }
    }

    // release handle
    RegCloseKey(hKey);

    // done
    return FALSE;
}



//                                                                           
// TSPI procedures                                                           
//                                                                           


/*++

Routine Description:


    This function is called by TAPI in response to receipt of a LINE_CREATE
    message from the service provider, which allows the dynamic creation of
    a new line device.

Arguments:

    dwTempID - The temporary device identifier that the service provider
        passed to TAPI in the LINE_CREATE message.

    dwDeviceID - The device identifier that TAPI assigns to this device if
        this function succeeds.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_BADDEVICEID - The specified line device ID is out of range.

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
            reasons.

--*/

LONG
TSPIAPI
TSPI_providerCreateLineDevice(
    DWORD_PTR dwTempID,
    DWORD dwDeviceID
    )
{
    //in the new TSP we don't support creating multiple H323 lines. 
    //So return success silently but assert in the debug version
    _ASSERTE(0);

    /*H323DBG(( DEBUG_LEVEL_TRACE,
        "creating new device %d (hdLine=0x%08lx).",
        dwDeviceID, dwTempID ));

    // lock line device using temporary device id
    if (!H323GetLineFromIDAndLock(&pLine, (DWORD)dwTempID))
    {
        H323DBG(( DEBUG_LEVEL_ERROR,
            "invalid temp device id 0x%08lx.", dwTempID ));

        // failure
        return LINEERR_BADDEVICEID;
    }

    // initialize new line device
    H323InitializeLine(pLine, dwDeviceID);

    // unlock line
    H323UnlockLine(pLine);*/

    // success
    return NOERROR;
}



/*++

Routine Description:

    TAPI.DLL calls this function before TSPI_providerInit to determine the
    number of line and phone devices supported by the service provider.

Arguments:

    dwPermanentProviderID - Specifies the permanent ID, unique within the
        service providers on this system, of the service provider being
        initialized.

    pdwNumLines - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of line devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    pdwNumPhones - Specifies a far pointer to a DWORD-sized memory location
        into which the service provider must write the number of phone devices
        it is configured to support. TAPI.DLL initializes the value to zero,
        so if the service provider fails to write a different value, the
        value 0 is assumed.

    hProvider - Specifies an opaque DWORD-sized value which uniquely identifies
        this instance of this service provider during this execution of the
        Windows Telephony environment.

    pfnLineCreateProc - Specifies a far pointer to the LINEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send LINE_CREATE messages when a new line device needs to
        be created. This function should not be called to send a LINE_CREATE
        message until after the service provider has returned from the
        TSPI_providerInit procedure.

    pfnPhoneCreateProc - Specifies a far pointer to the PHONEEVENT callback
        procedure supplied by TAPI.DLL. The service provider will use this
        function to send PHONE_CREATE messages when a new phone device needs
        to be created. This function should not be called to send a
        PHONE_CREATE message until after the service provider has returned
        from the TSPI_providerInit procedure.

Return Values:

    Returns zero if the request is successful or a negative error number if
    an error has occurred. Possible return values are:

        LINEERR_NOMEM - Unable to allocate or lock memory.

        LINEERR_OPERATIONFAILED - The specified operation failed for unknown
    