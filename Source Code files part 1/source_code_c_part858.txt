 else
        {
            TscGeneralErrMsg( hMain );
        }

        return hr;
    }

    for( idx = 0 ; idx < items; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode != NULL )
        {
            pNode->FreeServer( );

            pNode->Release( );
        }
    }

    m_rnNodes.DeleteArray( );
    
    return BuildResultNodes( );
}

//----------------------------------------------------------------------------------------------------------
BOOL IsCapableOfBeingAppServer ()
{
    OSVERSIONINFOEX osVersionInfo;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO )&osVersionInfo))
    {
        return (!(osVersionInfo.wSuiteMask & VER_SUITE_BLADE) &&
                (osVersionInfo.wProductType != VER_NT_WORKSTATION));
    }

    return FALSE;
}        

BOOL IsAppServerMode()
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL fSuiteTerminal = FALSE;
    BOOL fSuiteSingleUserTS = FALSE; 

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );
    fSuiteTerminal = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME,
            dwlConditionMask);

    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;
    fSuiteSingleUserTS = VerifyVersionInfo(&osVersionInfo, VER_SUITENAME,
            dwlConditionMask);

    if( (FALSE == fSuiteSingleUserTS) && (TRUE == fSuiteTerminal) )
        return TRUE;
    else
        return FALSE;
}

IsWhistlerAdvanceServer()
{
    OSVERSIONINFOEX osVersionInfo;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO )&osVersionInfo))
    {
        return (osVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) ||
               (osVersionInfo.wSuiteMask & VER_SUITE_DATACENTER);

    }
    else
        return FALSE;
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::BuildSettingsNodes( )
{

    // Resource ID for item move to snodes.h

    //INT rgResid[] = { 
    //                  IDS_DELTEMPONEXIT, 
    //                  IDS_USETEMPDIR,
                      /* IDS_DEFCONSEC, */
    //                  IDS_LICENSING,
    //                  IDS_ADS_ATTR,
    //                  IDS_USERPERM,
    //                  IDS_SINGLE_SESSION,
    //                  -1};

    DWORD dwNumItems = sizeof( RGRESID ) / sizeof( RGRESID[0] );

    TCHAR tchbuffer[ 256 ];

    TCHAR tchKey[ ] = L"Software\\Microsoft\\TSCC\\CLSID";

    HKEY hKey;
    
    DWORD dwStatus;
 
    TCHAR szSubKeyName[ 256 ];

    DWORD dwSubKeyNameLength;
    
    CLSID clsidOther;

    INT nObjectId = 0;

    ISettingsComp *pSettings = NULL;
    IExtendServerSettings *pExtendServerSettings = NULL;

    if( m_pCfgcomp == NULL || FAILED( m_pCfgcomp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ) )
    {
        return E_FAIL;
    }

    ASSERT( sizeof( RGRESID ) / sizeof( RGRESID[0] ) == sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) );
    ASSERT( sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) == sizeof(VALIDOBJECTONADS)/sizeof(VALIDOBJECTONADS[0]) );

    
    for( DWORD idx = 0; idx < dwNumItems  ; idx++ )
    {        
        // error checking, do go over array boundary
        if( !IsCapableOfBeingAppServer() )
        {
            if( idx > sizeof(VALIDOBJECTONSERVER)/sizeof(VALIDOBJECTONSERVER[0]) )
            {
                ASSERT(FALSE);
                continue;
            } 
        }
        else
        {
            if( idx > sizeof(VALIDOBJECTONADS)/sizeof(VALIDOBJECTONADS[0]) )
            {
                ASSERT(FALSE);
                continue;
            } 
        }

        if( ( IsCapableOfBeingAppServer() && VALIDOBJECTONADS[idx] ) || (!IsCapableOfBeingAppServer() && VALIDOBJECTONSERVER[idx] ) )
        {

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , RGRESID[ idx ] , tchbuffer , SIZE_OF_BUFFER( tchbuffer ) ) );

            CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
            if( pSet != NULL )
            {
                pSet->SetObjectId( nObjectId );

                pSet->SetInterface( ( LPUNKNOWN )pSettings );

                if( !pSet->SetAttributeName( tchbuffer ) )
                {
                    ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                }

                m_rgsNodes.Insert( pSet );

                nObjectId++;
            }        
        }
        else
        {
            nObjectId++;
        }        
    }

    pSettings->Release( );

    // Find out how many extension nodes are out there.

    // First we need to get the specific tssd component supplied for session
    // directory services, but only on application servers.
    if(IsAppServerMode() && IsWhistlerAdvanceServer() && ( dwStatus = RegOpenKeyEx( 
                                    HKEY_LOCAL_MACHINE ,
                                    REG_CONTROL_TSERVER ,
                                    0,
                                    KEY_READ,
                                    &hKey ) ) == ERROR_SUCCESS )
    {
        DBGMSG( L"RegOpenKeyEx tssd ok at %s\n" , REG_CONTROL_TSERVER );

        dwSubKeyNameLength = sizeof( szSubKeyName );

        dwStatus = RegQueryValueEx( hKey ,
            REG_TS_SESSDIRCLSID ,
            NULL ,
            NULL ,
            ( LPBYTE )szSubKeyName ,
            &dwSubKeyNameLength );

        DBGMSG( L"tssd RegQueryValueEx for %s\n" , REG_TS_SESSDIRCLSID );

        DBGMSG( L"tssd RegQueryValueEx ret 0x%x\n" , dwStatus );        

        if( dwStatus == ERROR_SUCCESS )
        {
            DBGMSG( L"CCompdata!BuildSettingsNode key name %s\n" , szSubKeyName );

            if( SUCCEEDED( CLSIDFromString( szSubKeyName , &clsidOther ) ) )
            {
                if( SUCCEEDED( CoCreateInstance( 
                    clsidOther ,
                    NULL ,
                    CLSCTX_INPROC_SERVER ,
                    IID_IExtendServerSettings ,
                    ( LPVOID *) &pExtendServerSettings ) ) )
                {
                    if( pExtendServerSettings != NULL )
                    {
                        CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
                        if( pSet != NULL )
                        {
                            pSet->SetObjectId( nObjectId );

                            pSet->SetInterface( ( LPUNKNOWN )pExtendServerSettings );

                            pExtendServerSettings->GetAttributeName( tchbuffer );

                            if( !pSet->SetAttributeName( tchbuffer ) )
                            {
                                ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                            }

                            m_rgsNodes.Insert( pSet );

                            nObjectId++;
                        }
                    }
                    
                    pExtendServerSettings->Release();
                }
            }
        }

        RegCloseKey( hKey );
    }   

    // look for other custom components at HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\TSCC\CLSID

    idx = 0;
    
    if( ( dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 tchKey ,
                                 0,
                                 KEY_READ,
                                 &hKey ) ) == ERROR_SUCCESS )
    {
        
        while( dwStatus == ERROR_SUCCESS )
        {
            dwSubKeyNameLength = SIZE_OF_BUFFER( szSubKeyName );

            dwStatus = RegEnumKeyEx(
                                hKey ,
                                ( DWORD )idx,
                                szSubKeyName ,
                                &dwSubKeyNameLength,
                                NULL ,
                                NULL ,
                                NULL ,
                                NULL 
                                );
            
            if( dwStatus != ERROR_SUCCESS )
            {
                DBGMSG( L"RegEnumKeyEx failed with 0x%x\n" , dwStatus );

                break;
            }
            
            DBGMSG( L"CCompdata!BuildSettingsNode key name %s\n" , szSubKeyName );

            idx++;
            
            
            if( FAILED( CLSIDFromString( szSubKeyName , &clsidOther ) ) )
            {
                continue;
            }
            
            if( SUCCEEDED( CoCreateInstance( 
                                clsidOther ,
                                NULL ,
                                CLSCTX_INPROC_SERVER ,
                                IID_IExtendServerSettings ,
                                ( LPVOID *) &pExtendServerSettings ) ) )
            {


                if( pExtendServerSettings != NULL )
                {
                    CSettingNode *pSet = ( CSettingNode * )new CSettingNode( );
        
                    if( pSet != NULL )
                    {
                        pSet->SetObjectId( nObjectId );

                        pSet->SetInterface( ( LPUNKNOWN )pExtendServerSettings );

                        pExtendServerSettings->GetAttributeName( tchbuffer );

                        if( !pSet->SetAttributeName( tchbuffer ) )
                        {
                            ODS( L"TSCC: BuildSettingsNodes -- SetItemName failed\n" );
                        }

                        m_rgsNodes.Insert( pSet );

                        nObjectId++;
                    }
                }

                pExtendServerSettings->Release();
            }
        } // while

        RegCloseKey( hKey );
    } // if
    
    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::BuildResultNodes( )
{
    CResultNode *pResultNode;
    
    WS *pWs;

    ULONG ulitems = 0;
    
    ULONG cbSize = 0;

    ULONG cItems = 0;

    BOOL bValid = TRUE;
    
    PGUIDTBL pGuidtbl = NULL;

    TCHAR szOldPdName[ MAX_PATH ];

    HRESULT hr = E_FAIL;


    if( SUCCEEDED( m_pCfgcomp->GetWinstationList( &ulitems , &cbSize , &pWs ) ) )
    {
        // Get valid lanids        

        for( ULONG i = 0 ; i < ulitems ; ++i )
        {
            // do not list console

            if( lstrcmpi( pWs[ i ].Name , L"console" ) == 0 )
            {
                continue;
            }

            pResultNode = new CResultNode( );

            if( pResultNode == NULL )
            {
                return E_OUTOFMEMORY;
            }

            pResultNode->SetConName( pWs[ i ].Name , lstrlen( pWs[ i ].Name ) );

            pResultNode->SetTTName( pWs[ i ].pdName , lstrlen( pWs[ i ].pdName ) );

            pResultNode->SetTypeName( pWs[ i ].wdName , lstrlen( pWs[ i ].wdName ) );

            pResultNode->SetComment(  pWs[ i ].Comment , lstrlen( pWs[ i ].Comment ) );

            pResultNode->EnableConnection( pWs[ i ].fEnableWinstation );

            pResultNode->SetImageIdx( ( pWs[ i ].fEnableWinstation ? 1 : 2 ) );

            pResultNode->SetServer( m_pCfgcomp );


            if( lstrcmpi( pWs[i].pdName , szOldPdName ) != 0 )
            {
                if( pGuidtbl != NULL )
                {
                    CoTaskMemFree( pGuidtbl );

                    pGuidtbl = NULL;                    
                }

                hr = m_pCfgcomp->GetLanAdapterList2( pWs[ i ].pdName , &cItems , &pGuidtbl );

                lstrcpy( szOldPdName , pWs[i].pdName );
            }

            if( pGuidtbl != NULL && SUCCEEDED( hr ) )
            {
                BOOL bFoundaMatch = FALSE;

                for( int k = 0; k < ( int )cItems ; ++k )
                {
                    if( ( pGuidtbl[ k ].dwStatus == ERROR_SUCCESS ) && ( pGuidtbl[ k ].dwLana == pWs[ i ].LanAdapter ) )
                    {
                        bFoundaMatch = TRUE;

                        break;
                    }
                }

                if( !bFoundaMatch )
                {
                    DWORD dwStatus;

                    ODS( L"TSCC:BuildResultNodes we found an invalid lanaid\n" );

                    pWs[ i ].fEnableWinstation = 0;

                    m_pCfgcomp->UpDateWS( pWs , UPDATE_ENABLEWINSTATION , &dwStatus, TRUE );

                    pResultNode->EnableConnection( 0 );
                    
                    pResultNode->SetImageIdx( 2 );
                }


                if( bValid ) // once set to false we know we have a winstation that has an invalid lanaid
                {
                    bValid = bFoundaMatch;
                }

            }            
            
    
            if( m_rnNodes.Insert( pResultNode ) == 0 )
            {
                return E_OUTOFMEMORY;
            }
        }

        if( pGuidtbl != NULL )
        {
            CoTaskMemFree( pGuidtbl );
        }

        CoTaskMemFree( pWs );

        
        if( !bValid )
        {
            HWND hwnd;

            BOOL bReadOnly = FALSE;

            m_pCfgcomp->IsSessionReadOnly( &bReadOnly );

            if( bReadOnly )
            {
                return S_OK;
            }

            if( m_pConsole != NULL )
            {
                m_pConsole->GetMainWindow( &hwnd );

                DWORD dwTid;

                HANDLE hThread = CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE  )InitWarningThread,  hwnd , 0 , &dwTid );

                CloseHandle( hThread );                
            }
        }
        
                
        return S_OK;
    }

    return E_FAIL;
}

//----------------------------------------------------------------------------------------------------------
//BOOL CCompdata::GetResultNode( int idx , CResultNode** pRn )
CResultNode * CCompdata::GetResultNode( int idx )
{
    
    return *m_rnNodes.GetAt( idx );
/*
    if( *pRn == NULL )
    {
        return FALSE;
    }

    return TRUE;
    */
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::InsertSettingItems( LPRESULTDATA pResultData )
{
    RESULTDATAITEM rdi;

    HRESULT hr;
    
    CSettingNode *pSettingNode = NULL;

    ASSERT( pResultData != NULL );

    if( pResultData == NULL )
    {
        return E_INVALIDARG;
    }

    ZeroMemory( &rdi , sizeof(RESULTDATAITEM) );

    rdi.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
    
    rdi.str = MMC_CALLBACK;

    if (NULL != m_pCfgcomp)
    {
        DWORD nVal, dwStatus;
        ISettingsComp* pISettingComp = NULL;

        hr = m_pCfgcomp->QueryInterface( IID_ISettingsComp, (void **) &pISettingComp );

        if (SUCCEEDED(hr))
        {
            hr = pISettingComp->GetTermSrvMode( &nVal, &dwStatus );
            
            if (SUCCEEDED(hr))
            {
                g_bAppSrvMode = nVal;
            }

            pISettingComp->Release();
        }
    }

    int nMax = m_rgsNodes.GetSize();

    for( int idx = 0 ; idx < nMax ; ++idx )
    {  
        // init object -- if it fails skip over it
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if( pSettingNode != NULL )
        {
            if( FAILED( pSettingNode->GetNodeStatus( ) ) )
            {
                continue;
            }
        

        /*
        if( m_rgsNodes[ idx ].GetObjectId() == USERSECURITY )
        {
            // check to see if we're remote admin mode
            // if so skip over usersecurity

            if( !bDisplayUserPerm )
            {
                continue;
            }
        }
        */
            rdi.itemID = 1; // unique from connection items

            rdi.lParam = ( LPARAM )pSettingNode;

            rdi.nImage = pSettingNode->GetImageIdx( );

            hr = pResultData->InsertItem( &rdi );

            if( FAILED( hr ) )
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
HRESULT CCompdata::InsertFolderItems( LPRESULTDATA pResultData )
{
    RESULTDATAITEM rdi;

    HRESULT hr;

    // TCHAR tchBuffer[80];

    ASSERT( pResultData != NULL );

    if( pResultData == NULL )
    {
        return E_INVALIDARG;
    }

    ZeroMemory( &rdi , sizeof(RESULTDATAITEM) );

    rdi.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
    
    rdi.str = MMC_CALLBACK;

    int items = m_rnNodes.GetSize( );

    for( int idx = 0 ; idx < items ; ++idx )
    {
        CResultNode *pNode = *m_rnNodes.GetAt( idx );

        if( pNode == NULL )
        {
            return E_FAIL;
        }

        rdi.lParam = ( LPARAM )pNode;

        rdi.nImage = pNode->GetImageIdx( );

        hr = pResultData->InsertItem( &rdi );

        if( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
int CCompdata::GetServer( ICfgComp **ppCfgcomp )
{
    if( m_pCfgcomp != NULL )
    {
        *ppCfgcomp = m_pCfgcomp;

        return  ( ( ICfgComp * )*ppCfgcomp )->AddRef( );
    }

    return 0;
}

//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::OnDeleteItem( LPDATAOBJECT pDo)
{
    ICfgComp *pCfgcomp;

    CResultNode *pNode = dynamic_cast< CResultNode *>( pDo );

    if( pNode != NULL )
    {
        HWND hWnd = NULL;

        m_pConsole->GetMainWindow( &hWnd );
        
        if( pNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

    	TCHAR tchWarnText[ 512 ];

        TCHAR tchmsg[ 256 ];

    	TCHAR tchDeleteTitle[ 80 ];

        LONG lCount;
        
        // check to see if anyone is connected 
        
        pCfgcomp->QueryLoggedOnCount( pNode->GetConName( ) , &lCount );
        
        if( lCount > 0 )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELETELIVECON , tchmsg , SIZE_OF_BUFFER( tchmsg ) ) );

            wsprintf( tchWarnText , tchmsg , pNode->GetConName( ) );            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELETETEXT , tchWarnText , SIZE_OF_BUFFER( tchWarnText ) ) );
        }

    	VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELTITLE , tchDeleteTitle , SIZE_OF_BUFFER( tchDeleteTitle ) ) );

        if( MessageBox( hWnd , tchWarnText , tchDeleteTitle , MB_YESNO | MB_ICONEXCLAMATION ) == IDNO )
        {
            return FALSE;
        }
        
        if( FAILED( pCfgcomp->DeleteWS( pNode->GetConName( ) ) ) )
        {
            // WARN USER
            ErrMessage( hWnd , IDS_ERR_DELFAIL );

        	return FALSE;
           
        }
        else
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );
        }
        
        pCfgcomp->Release( );
    }

    BOOL bFound;

    int idx = m_rnNodes.FindItem( pNode , bFound );

    if( bFound )
    {
        pNode->FreeServer( );

        pNode->Release( );

        m_rnNodes.DeleteItemAt( idx );
    }

    m_pConsole->UpdateAllViews( ( LPDATAOBJECT )m_rnNodes.GetAt( 0 ) , 0 , 0 );

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinDescription( LPOLESTR *ppStr )
{
    TCHAR tchDescription[ 1024 ];

    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_DESCRIPTION , tchDescription , SIZE_OF_BUFFER( tchDescription ) );

    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );

    if( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchDescription );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetProvider( LPOLESTR *ppStr )
{
    TCHAR tchProvider[ 128 ];
    
    int iCharCount = LoadString( _Module.GetResourceInstance( ) , IDS_PROVIDER , tchProvider , SIZE_OF_BUFFER( tchProvider ) );

    *ppStr = ( LPOLESTR )CoTaskMemAlloc( iCharCount * sizeof( TCHAR ) + sizeof( TCHAR ) );

    if( *ppStr != NULL )
    {
        lstrcpy( *ppStr , tchProvider );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// MMC Free up ppStr when it's done
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinVersion( LPOLESTR *ppStr  )
{
    char chVersion[ 32 ] = VER_PRODUCTVERSION_STR;

    TCHAR tchVersion[ 32 ];

    int iCharCount = MultiByteToWideChar( CP_ACP , 0 , chVersion , sizeof( chVersion ) , tchVersion , SIZE_OF_BUFFER( tchVersion ) );
    
    *ppStr = ( LPOLESTR )CoTaskMemAlloc( ( iCharCount + 1 ) * sizeof( TCHAR ) );
    
    if( *ppStr != NULL && iCharCount != 0 )
    {
        lstrcpy( *ppStr , tchVersion );
        
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//----------------------------------------------------------------------------------------------------------
// Supply an icon here for the main icon in the about box
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetSnapinImage( HICON *phIcon )
{
    //*phIcon = ( HICON )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_ABOUT )  , IMAGE_ICON , 37 ,37 , LR_DEFAULTCOLOR );
    *phIcon = ( HICON )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDI_ICON_GENERAL2 )  , IMAGE_ICON , 32 ,32 , LR_DEFAULTCOLOR );

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// Supply an icon here for the main icon in the about box
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetStaticFolderImage(  HBITMAP *phSmallImage , HBITMAP *phSmallImageOpen , HBITMAP *phLargeImage, COLORREF *pClr )
{
    *phSmallImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENSMALL )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );

    *phSmallImageOpen = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENSMALL )  , IMAGE_BITMAP , 16 ,16 , LR_DEFAULTCOLOR );

    *phLargeImage = ( HBITMAP )LoadImage( _Module.GetResourceInstance( ) , MAKEINTRESOURCE( IDB_BITMAP_GENLARGE )  , IMAGE_BITMAP , 32 ,32 , LR_DEFAULTCOLOR );

    *pClr = RGB( 255 , 0 , 255 );

    //return E_NOTIMPL;

    return S_OK;
}

//----------------------------------------------------------------------------------------------------------
// MMC will ask for our help file
//----------------------------------------------------------------------------------------------------------
STDMETHODIMP CCompdata::GetHelpTopic( LPOLESTR *ppszHelpFile )
{
    ODS( L"CCompdata::GetHelpTopic called\n" );

    if( ppszHelpFile == NULL )
    {
        return E_INVALIDARG;
    }

    TCHAR tchHelpFile[ MAX_PATH ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCCSNAPHELP , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) ) );
  
    // mmc will call CoTaskMemFree

    *ppszHelpFile = ( LPOLESTR )CoTaskMemAlloc( sizeof( tchHelpFile ) );

    if( *ppszHelpFile != NULL )
    {
        if( GetSystemWindowsDirectory( *ppszHelpFile , MAX_PATH ) != 0 )
        {
            lstrcat( *ppszHelpFile , tchHelpFile );
        }
        else
        {
            lstrcpy( *ppszHelpFile , tchHelpFile );
        }

        ODS( *ppszHelpFile );

        ODS( L"\n" );

        return S_OK;
    }

    return E_OUTOFMEMORY;
}
//----------------------------------------------------------------------------------------------------------
// Helper methods for fixing the column lengths
//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::GetMaxTextLengthSetting( LPTSTR pszText , PINT pnMaxLen )
{
    INT nIndex = 0;

    INT nCurrentMax = 0;

    INT nMax;

    *pnMaxLen = 0;

    nMax = m_rgsNodes.GetSize( );

    CSettingNode *pSettingNode;

    for( int idx = 0 ; idx < nMax ; ++idx )
    {
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if( pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL )
        {
            nCurrentMax = lstrlen( pSettingNode->GetAttributeName( ) );

            if( *pnMaxLen < nCurrentMax )
            {
                *pnMaxLen = nCurrentMax;

                nIndex = idx;            
            }
        }
    }

    pSettingNode = *m_rgsNodes.GetAt( nIndex );

    if (pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL)
    {

        lstrcpy( pszText , pSettingNode->GetAttributeName( ) );
    }

    return TRUE;
}

//----------------------------------------------------------------------------------------------------------
// Helper methods for fixing the column lengths
//----------------------------------------------------------------------------------------------------------
BOOL CCompdata::GetMaxTextLengthAttribute( LPTSTR pszText , PINT pnMaxLen )
{
    INT nIndex = 0;

    INT nCurrentMax = 0;

    INT nMax;

    *pnMaxLen = 0;

    nMax = m_rgsNodes.GetSize( );

    CSettingNode *pSettingNode = NULL;

    for( int idx = 0 ; idx < nMax ; ++idx )
    {        
        pSettingNode = *m_rgsNodes.GetAt( idx );

        if (pSettingNode != NULL && pSettingNode->GetAttributeName( ) != NULL )
        {

            nCurrentMax = lstrlen( pSettingNode->GetAttributeValue( ) );

            DBGMSG( L"CCompdata!GetMaxTextLengthAttribute AttributeValue = %s\n", pSettingNode->GetAttributeValue( ) );

            if( *pnMaxLen < nCurrentMax )
            {
                *pnMaxLen = nCurrentMax;

                nIndex = idx;            
            }
        }
    }

    pSettingNode = *m_rgsNodes.GetAt( nIndex );
    
    if (pSettingNode != NULL)
    {
        LPTSTR pszValue = pSettingNode->GetAttributeValue( );

        if(pszValue != NULL)
        {
            lstrcpy( pszText , pszValue );    
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}



void InitWarningThread( PVOID pvParam )
{
    HWND hwnd = ( HWND )pvParam;

    TCHAR tchMessage[ 256 ];

    TCHAR tchTitle[ 80 ];

    Sleep( 200 );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABNETWORK , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );
    
    MessageBox( hwnd , tchMessage , tchTitle , MB_ICONINFORMATION | MB_OK );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\rnodes.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _RNODES_H
#define _RNODES_H

#include "dataobj.h"

#include "cfgbkend.h"

/*
#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103
*/

class CResultNode : public CBaseNode
{
    DWORD m_dwImageidx;

    BOOL m_bEnableConnection;
    
    LPTSTR m_pszConnectionName;
    
    LPTSTR m_pszTransportTypeName;

    LPTSTR m_pszTypeName;

    LPTSTR m_pszComment;

    ICfgComp *m_pCfgcomp;
   

public:

    CResultNode( );
    
    CResultNode( CResultNode& x );
    
    ~CResultNode( );

    LPTSTR GetConName( );

    LPTSTR GetTTName( );

    LPTSTR GetTypeName( );

    LPTSTR GetComment( );

    DWORD GetImageIdx( );

    int SetConName( LPTSTR , int );

    int SetTTName( LPTSTR , int );

    int SetTypeName( LPTSTR , int );

    int SetComment( LPTSTR , int );

    int SetImageIdx( DWORD );

    BOOL EnableConnection( BOOL );

    BOOL GetConnectionState( ) const
    {
        return m_bEnableConnection;
    }

    int SetServer( ICfgComp * );

    int GetServer( ICfgComp ** );

    int FreeServer( );

    BOOL m_bEditMode;

    // additional routines 

    BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG );


};


#endif //_RNODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\dataobj.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _DATAOBJ_H
#define _DATAOBJ_H

#include<mmc.h>

#define IDM_ENABLE_CONNECTION 102

#define IDM_RENAME_CONNECTION 103

#define IDM_SETTINGS_PROPERTIES 104

#define IDM_SETTINGS_DELTEMPDIRSONEXIT 105

#define IDM_SETTINGS_USETMPDIR 106

#define IDM_SETTINGS_ADP 110

#define IDM_SETTINGS_SS  111

//This needs to match the definition in tssdjet
#define IDM_MENU_PROPS 2001

// {E26D0049-378C-11d2-988B-00A0C925F917}
static const GUID GUID_MainNode = { 0xe26d0049, 0x378c, 0x11d2, { 0x98, 0x8b, 0x0, 0xa0, 0xc9, 0x25, 0xf9, 0x17 } };

// {E26D0050-378C-11d2-988B-00A0C925F917}
static const GUID GUID_SettingsNode = { 0xe26d0050, 0x378c, 0x11d2, { 0x98, 0x8b, 0x0, 0xa0, 0xc9, 0x25, 0xf9, 0x17 } };

// {fe8e7e84-6f63-11d2-98a9-00a0c925f917}
// extern const GUID GUID_ResultNode = { 0xfe8e7e84 , 0x6f63 , 0x11d2 , { 0x98, 0xa9 , 0x0 , 0x0a0 , 0xc9 , 0x25 , 0xf9 , 0x17 } };

enum { MAIN_NODE = 1 , SETTINGS_NODE ,  RESULT_NODE , RSETTINGS_NODE };

class CBaseNode : public IDataObject
{
    ULONG m_cref;

	INT_PTR m_nNodeType;

public:
    CBaseNode( );

    virtual ~CBaseNode( ) { }

    STDMETHOD( QueryInterface )( REFIID , PVOID * );

    STDMETHOD_( ULONG , AddRef )(  );

    STDMETHOD_( ULONG , Release )( );

    // IDataObject

    STDMETHOD( GetData )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( GetDataHere )( LPFORMATETC , LPSTGMEDIUM );

    STDMETHOD( QueryGetData )( LPFORMATETC );

    STDMETHOD( GetCanonicalFormatEtc )( LPFORMATETC , LPFORMATETC );

    STDMETHOD( SetData )( LPFORMATETC , LPSTGMEDIUM , BOOL );

    STDMETHOD( EnumFormatEtc )( DWORD , LPENUMFORMATETC * );

    STDMETHOD( DAdvise )( LPFORMATETC , ULONG , LPADVISESINK , PULONG );

    STDMETHOD( DUnadvise )( DWORD );

    STDMETHOD( EnumDAdvise )( LPENUMSTATDATA * );

    // BaseNode methods are left to the derived object

	void SetNodeType( INT_PTR nNodeType )
	{
		m_nNodeType = nNodeType;
	}

	INT_PTR GetNodeType( void )
	{
		return m_nNodeType;
	}


    virtual BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG ) { return FALSE; }

    virtual DWORD GetImageIdx( ){ return 0; }

    
    
                           
};

#endif // _DATAOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\rnodes.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include"stdafx.h"
#include"rnodes.h"
#include"resource.h"


//----------------------------------------------------------------------------------
CResultNode::CResultNode( )
{
    m_pszConnectionName = NULL;

    m_pszTransportTypeName = NULL;

    m_pszTypeName = NULL;

    m_pszComment = NULL;

    m_pCfgcomp = NULL;

	SetNodeType( RESULT_NODE );

    m_bEditMode = FALSE;

}
    
//CResultNode( CResultNode& x );
//----------------------------------------------------------------------------------    
CResultNode::~CResultNode( )
{
    ODS( L"CResultNode::dtor -- Deleting result node\n" );

    if( m_pszConnectionName != NULL )
    {
        delete[] m_pszConnectionName;
    }

    if( m_pszTransportTypeName != NULL )
    {
        delete[] m_pszTransportTypeName;
    }

    if( m_pszTypeName != NULL )
    {
        delete[] m_pszTypeName;
    }

    if( m_pszComment != NULL )
    {
        delete[] m_pszComment;
    }


}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetConName( )
{
    return m_pszConnectionName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetTTName( )
{
    return m_pszTransportTypeName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetTypeName( )
{
    return m_pszTypeName;
}
//----------------------------------------------------------------------------------
LPTSTR CResultNode::GetComment( )
{
    return m_pszComment;
}
//----------------------------------------------------------------------------------
DWORD CResultNode::GetImageIdx( )
{
    return m_dwImageidx;
}

//----------------------------------------------------------------------------------
int CResultNode::SetConName( LPTSTR psz , int cwSz )
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    if( m_pszConnectionName != NULL )
    {
        delete[] m_pszConnectionName;

        m_pszConnectionName = NULL;
    }

    m_pszConnectionName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszConnectionName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszConnectionName , psz );

    return cwSz;
}


//----------------------------------------------------------------------------------
int CResultNode::SetTTName( LPTSTR psz , int cwSz )
{    
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    m_pszTransportTypeName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszTransportTypeName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszTransportTypeName , psz );

    return cwSz;
}

//----------------------------------------------------------------------------------
int CResultNode::SetTypeName( LPTSTR psz , int cwSz)
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    m_pszTypeName = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszTypeName == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszTypeName , psz );

    return cwSz;
    
}

//----------------------------------------------------------------------------------
int CResultNode::SetComment( LPTSTR psz , int cwSz )
{
    if( IsBadReadPtr( psz , cwSz * sizeof( TCHAR ) ) )
    {
        return 0;
    }

    if( m_pszComment != NULL )
    {
        delete[] m_pszComment;

        m_pszComment = NULL;
    }

    m_pszComment = ( LPTSTR ) new TCHAR[ cwSz + 1];

    if( m_pszComment == NULL )
    {
        return 0;
    }

    lstrcpy( m_pszComment , psz );

    return cwSz;
 
}

//----------------------------------------------------------------------------------
int CResultNode::SetImageIdx( DWORD dwIdx )
{
    // Check for invalid dwIdx

    m_dwImageidx = dwIdx;

    return dwIdx;
}

//----------------------------------------------------------------------------------
BOOL CResultNode::EnableConnection( BOOL bSet )
{
    m_bEnableConnection = bSet;

    return TRUE;
}

//----------------------------------------------------------------------------------
int CResultNode::SetServer( ICfgComp *pCfgcomp )
{
    if( pCfgcomp == NULL )
    {
        return 0;
    }

    if( m_pCfgcomp != NULL )
    {
        m_pCfgcomp->Release( );

    }

    m_pCfgcomp = pCfgcomp;

    return m_pCfgcomp->AddRef( );
    
}

//----------------------------------------------------------------------------------
int CResultNode::GetServer( ICfgComp **ppCfgcomp )
{
    if( m_pCfgcomp != NULL )
    {
        *ppCfgcomp = m_pCfgcomp;

        return  ( ( ICfgComp * )*ppCfgcomp )->AddRef( );
    }

    return 0;
}

//----------------------------------------------------------------------------------
int CResultNode::FreeServer( )
{
    if( m_pCfgcomp != NULL )
    {
        return m_pCfgcomp->Release( );
    }

    return 0;
}

//----------------------------------------------------------------------------------
BOOL CResultNode::AddMenuItems( LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{
    HRESULT hr;

    TCHAR tchName[ 80 ];

    TCHAR tchStatus[ 256 ];

    CONTEXTMENUITEM cmi;

    if( GetConnectionState( ) )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
    }
    else
    {        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
    }

    cmi.lCommandID = IDM_ENABLE_CONNECTION;

    cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;

    cmi.fFlags = cmi.fSpecialFlags = 0;

    *pl |= CCM_INSERTIONALLOWED_TASK;

    hr = pcmc->AddItem( &cmi );

    if( SUCCEEDED( hr ) )
    {
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RENAMECON , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RENAMECON_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_RENAME_CONNECTION;

        hr = pcmc->AddItem( &cmi );
    }

    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tscc.rc
//
#define IDI_ICON_COMPUTER               16
#define IDS_PROJNAME                    100
#define IDR_COMPDATA                    101
#define IDS_NAMESTRING                  101
#define IDD_WELCOME                     101
#define IDS_WELCOMEHEADER               102
#define IDS_WELCOMESUBHEADER            103
#define IDS_WIZARDTITLE                 104
#define IDD_FINISH                      105
#define IDD_LAN                         106
#define IDD_AUTO_LOGON                  107
#define IDD_LICENSING                   108
#define IDD_INITIAL_PROGRAM             110
#define IDD_CONNECTION_TYPE             111
#define IDD_SECURITY                    112
#define IDD_TIMEOUT                     113
#define IDD_CONNECTION_PROP             114
#define IDD_WALLPAPER                   115
#define IDD_REMOTE_CONTROL              116
#define IDD_GENERAL                     129
#define IDD_LOGONSETTINGS               130
#define IDD_ENVIRONMENT                 131
#define IDD_TIMEOUTSETTING              132
#define IDD_PAGE_SHADOW                 137
#define IDD_TIMEOUTS_PS                 138
#define IDD_TSCC_CLIENT                 141
#define IDD_TSCC_PERMISSIONS            142
#define IDC_CHECK_WALLPAPER             201
#define IDB_TSCC_LOGO                   202
#define IDC_CHECK_CCPL_PS               202
#define IDC_COMBO_CON_WZ                203
#define IDB_TSCC_ICON                   204
#define IDC_RADIO_CNTS_WZ               204
#define IDC_RADIO_UDCCS_WZ              205
#define IDI_ICON_GLOBALGROUP            205
#define IDC_COMBO_ENCRYPT_LVL           206
#define IDI_ICON_LOCALGROUP             206
#define IDC_CHECK_ENCRYPT               207
#define IDI_ICON_USER                   207
#define IDC_LV_USRGRPS                  208
#define IDC_LV_PERMISSIONS              209
#define IDC_CHECK_REMOTECTRL_NOTIFYUSER 210
#define IDI_ICON_GENERAL                210
#define IDC_CHECK_LOGON_PROMPTPASSWD    211
#define IDC_CHECK_LAN_UNLIMITEDCON      212
#define IDC_EDIT_LAN_MAXCONS            213
#define IDC_COMBO_LAN_ADAPTERS          214
#define IDC_CHECK_INITPROG_INHERIT      215
#define IDI_ICON_GENERAL2               215
#define IDC_EDIT_INITPROG_CMDLINE       216
#define IDC_EDIT_INITPROG_WD            217
#define IDC_STATIC_GEN_TYPE             218
#define IDC_STATIC_GEN_TRANSPORT        219
#define IDC_EDIT_USRNAME_WZ             220
#define IDC_EDIT_DOMAIN_WZ              221
#define IDC_EDIT_PASSWD_WZ              222
#define IDC_STATIC_IMAGE_HOLDER         223
#define IDI_ICON_CON                    223
#define IDC_STATIC_NAMESTR              224
#define IDI_ICON_DISCON                 224
#define IDC_STATIC_CONNAME              225
#define IDD_RENAME                      225
#define IDC_STATIC_WELCOME              226
#define IDC_STATIC_FINISH               227
#define IDI_ICON_ABOUT                  227
#define IDC_STATIC_CURRENT_NAME         228
#define IDD_CITRIX_PAGE                 228
#define IDC_CHECKLIST                   229
#define IDD_TRANSPORT_PS                229
#define IDC_CUSTOM1                     230
#define IDD_NETWORK_FACE                231
#define IDD_ASYNC_FACE                  232
#define IDC_STATIC_DESCRIPTION          232
#define IDC_STATIC_DESCR_TITLE          233
#define IDC_STATIC_GEN_DESCRTITLE       234
#define IDC_STATIC_GEN_DESCR            235
#define IDC_STATIC_CONGRP               236
#define IDD_CACHED_SESSIONS             236
#define IDC_STATIC_CON                  237
#define IDD_YESNODIALOG                 237
#define IDC_STATIC_DISCON               238
#define IDD_DEFCONSEC                   238
#define IDC_STATIC_IDLE                 239
#define IDC_STATIC_USRNAME              240
#define IDC_STATIC_DOMAIN               241
#define IDD_DIALOG_PERSESSION           241
#define IDC_STATIC_PASSWD               242
#define IDB_BITMAP_GENLARGE             242
#define IDC_STATIC_CONPASSWD            243
#define IDB_BITMAP_GENSMALL             243
#define IDC_STATIC_CMDLINE              244
#define IDC_STATIC_WF                   245
#define IDC_STATIC_MAXINST              246
#define IDC_STATIC_ENCL                 247
#define IDC_STATIC_WD                   248
#define IDC_STATIC_LSUSR                249
#define IDC_STATIC_LSDOMAIN             250
#define IDC_STATIC_LSPWD                251
#define IDC_STATIC_LSCONPWD             252
#define IDC_STATIC_TIMCON               253
#define IDC_STATIC_TIMDISCON            254
#define IDC_STATIC_TIMIDLE              255
#define IDC_STATIC_TNMAX                256
#define IDC_STATIC_YNTEXTHLDR           257
#define IDC_RADIO_YES                   258
#define IDC_RADIO_NO                    259
#define IDC_STATIC_TEMPPERSESSION       260
#define IDC_STATIC_ADP_HDR              261
#define IDC_RADIO_AD_ENABLE             262
#define IDC_RADIO_ADP_DISABLE           263
#define IDC_TSMSTATIC_RA                265
#define IDS_RAM                         267
#define IDS_ASM                         268
#define IDC_LICENSING_MODE              270
#define IDC_LICENSING_DESCRIPTION       271
#define IDC_LICENSING_TO_REMOTE_ADMIN   272
#define IDC_LICENSING_FROM_REMOTE_ADMIN 273
#define IDD_EDIT_WINSTATION             300
#define IDD_ASYNC_WIZ                   300
#define IDL_WINSTATIONNAME              301
#define IDC_WINSTATIONNAME              302
#define IDL_TDNAME                      304
#define IDC_TDNAME                      305
#define IDL_WDNAME                      306
#define IDC_WDNAME                      307
#define IDL_WSCOMMENT                   308
#define IDC_WSCOMMENT                   309
#define IDC_ADVANCED_WINSTATION         312
#define IDC_CLIENT_SETTINGS             313
#define IDC_EXTENSION_BUTTON            314
#define IDL_ASYNC                       330
#define IDL_ASYNC_DEVICENAME            331
#define IDC_ASYNC_DEVICENAME            332
#define IDC_ASYNC_MODEMINSTALL          333
#define IDC_ASYNC_MODEMCONFIG           334
#define IDL_ASYNC_MODEMCALLBACK         335
#define IDL_ASYNC_MODEMCALLBACK1        336
#define IDC_ASYNC_MODEMCALLBACK         337
#define IDC_ASYNC_MODEMCALLBACK_INHERIT 338
#define IDL_ASYNC_MODEMCALLBACK_PHONENUMBER 339
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER 340
#define IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT 341
#define IDL_ASYNC_CONNECT               342
#define IDC_ASYNC_CONNECT               343
#define IDL_ASYNC_BAUDRATE              344
#define IDC_ASYNC_BAUDRATE              345
#define IDC_ASYNC_DEFAULTS              346
#define IDC_ASYNC_ADVANCED              347
#define IDC_ASYNC_TEST                  348
#define IDD_ASYNC_ADVANCED              500
#define IDL_ASYNC_ADVANCED_FLOWCONTROL  501
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_HARDWARE 502
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_SOFTWARE 503
#define IDC_ASYNC_ADVANCED_FLOWCONTROL_NONE 504
#define IDL_ASYNC_ADVANCED_DTRSTATE     505
#define IDL_ASYNC_ADVANCED_DTRALWAYS    506
#define IDC_ASYNC_ADVANCED_DTROFF       507
#define IDC_ASYNC_ADVANCED_DTRON        508
#define IDL_ASYNC_ADVANCED_RTSSTATE     509
#define IDL_ASYNC_ADVANCED_RTSALWAYS    510
#define IDC_ASYNC_ADVANCED_RTSOFF       511
#define IDC_ASYNC_ADVANCED_RTSON        512
#define IDL_ASYNC_ADVANCED_HARDWARE     513
#define IDC_ASYNC_ADVANCED_HWRX         514
#define IDL_ASYNC_ADVANCED_HWRX         515
#define IDL_ASYNC_ADVANCED_HWTX         516
#define IDC_ASYNC_ADVANCED_HWTX         517
#define IDL_ASYNC_ADVANCED_SOFTWARE     518
#define IDL_ASYNC_ADVANCED_XON          519
#define IDC_ASYNC_ADVANCED_XON          520
#define IDL_ASYNC_ADVANCED_XOFF         521
#define IDC_ASYNC_ADVANCED_XOFF         522
#define IDL_ASYNC_ADVANCED_BASE         523
#define IDC_ASYNC_ADVANCED_BASEDEC      524
#define IDC_ASYNC_ADVANCED_BASEHEX      525
#define IDL_ASYNC_ADVANCED_PARITY       526
#define IDC_ASYNC_ADVANCED_PARITY_NONE  527
#define IDC_ASYNC_ADVANCED_PARITY_EVEN  528
#define IDC_ASYNC_ADVANCED_PARITY_ODD   529
#define IDC_ASYNC_ADVANCED_PARITY_MARK  530
#define IDC_ASYNC_ADVANCED_PARITY_SPACE 531
#define IDL_ASYNC_ADVANCED_STOPBITS     532
#define IDC_ASYNC_ADVANCED_STOPBITS_1   533
#define IDC_ASYNC_ADVANCED_STOPBITS_2   534
#define IDL_ASYNC_ADVANCED_BYTESIZE     535
#define IDC_ASYNC_ADVANCED_BYTESIZE_7   536
#define IDC_ASYNC_ADVANCED_BYTESIZE_8   537
#define IDD_ASYNC_TEST                  620
#define IDC_ATDLG_DTR                   621
#define IDD_ADP_DIALOG                  621
#define IDC_ATDLG_RTS                   622
#define IDC_ATDLG_CTS                   623
#define IDC_ATDLG_DSR                   624
#define IDC_ATDLG_DCD                   625
#define IDC_ATDLG_RI                    626
#define IDL_ATDLG_DEVICE                627
#define IDL_ATDLG_BAUD                  628
#define IDC_ATDLG_EDIT                  629
#define IDC_ATDLG_MODEM_INIT            630
#define IDC_ATDLG_MODEM_LISTEN          631
#define IDC_ATDLG_MODEM_DIAL            632
#define IDL_ATDLG_PHONE_NUMBER          633
#define IDC_ATDLG_PHONE_NUMBER          634
#define IDI_ICON_BULLET                 635
#define IDC_STATIC_SINGLE_SESSION_HDR   637
#define IDC_RADIO_SINGLE_SESSION_ENABLE 638
#define IDC_COMBO1                      1001
#define IDC_COMBO_WIZ_CONTYPE           1001
#define IDC_COMBO_GENERAL_TRANSPORT     1001
#define IDC_COMBO_TRANSPORT_WZ          1001
#define IDC_EDIT_GENERAL_TRANSPORT      1001
#define IDC_COMBO_DEFSEC                1001
#define IDC_COLORDEPTH_OVERRIDE         1001
#define IDC_EDIT2                       1002
#define IDC_ADD_GRPUSR                  1002
#define IDC_EDIT_LOGON_USRNAME          1002
#define IDC_EDIT_GEN_COMMENT            1002
#define IDC_EDIT_ENVIRO_CMDLINE         1002
#define IDC_SPIN1                       1003
#define IDC_REMOVE_GRPUSR               1003
#define IDC_EDIT_LOGON_DOMAIN           1003
#define IDC_EDIT_GEN_MAXCONS            1003
#define IDC_EDIT_ENVIRO_WD              1003
#define IDC_SPIN_WZ                     1003
#define IDC_CHECK1                      1004
#define IDC_EDIT_LOGON_PASSWD           1004
#define IDC_CHECK_ICCP_WZ               1004
#define IDC_CHECK_COLORDEPTH_OVERRIDE   1004
#define IDC_RADIO1                      1005
#define IDC_COMBO_CON_PS                1005
#define IDC_RADIO_DISABLE_REMOTE_CONTROL 1005
#define IDC_COMBO_GEN_LANADAPTER        1005
#define IDC_RADIO_REMOTECTRL_NO         1005
#define IDC_COMBO_TIMEOUTS_CON_PS       1005
#define IDC_RADIO_ENABLE_REMOTE         1005
#define IDC_RADIO_PERSESSION_YES        1005
#define IDC_RADIO2                      1006
#define IDC_RADIO_ENABLE_REMOTECONTROL  1006
#define IDC_EDIT_LOGON_CONFIRMPASSWD    1006
#define IDC_RADIO_NOREMOTE              1006
#define IDC_RADIO_PERSESSION_NO         1006
#define IDC_CHECK2                      1007
#define IDC_COMBO_DISCON_PS             1007
#define IDC_COMBO_GEN_ENCRYPT           1007
#define IDC_CHECK_PROMPTPASSWD_WZ       1007
#define IDC_COMBO_TIMEOUTS_DISCON_PS    1007
#define IDC_EDIT1                       1008
#define IDC_COMBO_IDLE_PS               1008
#define IDC_COMBO_TIMEOUTS_IDLE_PS      1008
#define IDC_EDIT_WSNAME_WZ              1008
#define IDC_EDIT_GENERAL_NAME           1008
#define IDC_EDIT_NEWNAME                1008
#define IDC_EDIT_CACHEDSESSION          1008
#define IDC_EDIT3                       1009
#define IDC_EDIT_COMMENT_WZ             1009
#define IDC_EDIT4                       1010
#define IDC_RADIO_DISCON_PS             1010
#define IDC_EDIT_CONFIRM_WZ             1010
#define IDC_RADIO_TIMEOUTS_DISCON_PS    1010
#define IDC_RADIO3                      1011
#define IDC_RADIO_RESET_PS              1011
#define IDC_RADIO_INHERIT_REMOTE_CONTROL 1011
#define IDC_RADIO_TIMEOUTS_RESET_PS     1011
#define IDC_RADIO_REMOTE_INHERIT        1011
#define IDC_COMBO_DISCON_WZ             1012
#define IDC_CHECK_TIMEOUT_INHERIT       1013
#define IDC_COMBO_IDLE_WZ               1013
#define IDC_CHECK_LOGON_INHERIT         1013
#define IDC_CHECK_GEN_UNLIMITED         1013
#define IDC_CHECK_ENVIRO_INHERIT        1013
#define IDC_CHECK_INHERITTIMEOUT_PS     1013
#define IDC_RADIO4                      1014
#define IDC_CHECK_CONCLIENT_INHERIT     1014
#define IDC_RADIO_FAC_PS                1014
#define IDC_RADIO_REMOTECTRL_WATCH      1014
#define IDC_RADIO_TIMEOUTS_ANYCLIENT_PS 1014
#define IDC_RADIO_WATCH                 1014
#define IDC_RADIO5                      1015
#define IDC_CHECK_DCDM_PS               1015
#define IDC_RADIO_FPC_PS                1015
#define IDC_RADIO_REMOTECTRL_CONTROL    1015
#define IDC_RADIO_TIMEOUTS_PREVCLNT_PS  1015
#define IDC_RADIO_CONTROL               1015
#define IDC_CHECK_CCDL_PS               1016
#define IDC_CHECK_GEN_AUTHEN            1016
#define IDC_CHECK_ENVIRO_RUNONLYAPPS    1016
#define IDC_CHECK_TIMEOUTS_INHERITBKCON_PS 1016
#define IDC_CHECK3                      1017
#define IDC_CHECK_ENVIRO_DISABLEWALL    1017
#define IDC_CHECK_TIMEOUTS_INHERITRECON_PS 1017
#define IDC_CHECK_NOTIFY                1017
#define IDC_CHECK_DMCP_PS               1018
#define IDC_CHECK_DWCPM_PS              1019
#define IDC_CHECK_DCLPM_PS              1020
#define IDC_CHECK_DCCPM_PS              1021
#define IDC_CHECK_DCCM_PS               1022
#define IDC_CHECK_DCAM_PS               1023
#define IDC_SPINCTR_GEN                 1024
#define IDP_ERROR_GET_OVERLAPPED_RESULT_WRITE 1052
#define IDP_ERROR_WRITE_FILE            1053
#define IDS_ERROR_NO_LICENSING_MODE_LIST 1054
#define IDS_ERROR_NO_LICENSING_MODE     1055
#define IDS_ERROR_NO_MEMORY             1056
#define IDS_ERROR_NO_LICENSING_MODE_INFO 1057
#define IDC_RADIO_MAXPROP               18164
#define IDC_STATIC_ENCGRP               18165
#define IDS_ERROR_TITLE                 18636
#define IDS_WARN_TITLE                  18637
#define IDS_ERROR_NUMERICENTRY          18639
#define IDS_NOTIMEOUT                   18640
#define IDS_DIGIT_DOT_DIGIT_TU          18644
#define IDS_DIGIT_TU                    18645
#define IDS_DAYS                        18647
#define IDS_DAY                         18648
#define IDS_HOURS                       18649
#define IDS_HOUR                        18650
#define IDS_MINUTES                     18651
#define IDS_MINUTE                      18652
#define IDS_D                           18653
#define IDS_H                           18654
#define IDS_M                           18655
#define IDS_HR                          18656
#define IDS_HRS                         18657
#define IDS_MIN                         18658
#define IDS_ERROR_TOOMANYDIGITS         18659
#define IDS_ERROR_PARSEINVALID          18660
#define IDS_ERROR_MAXVALEXCEEDED        18661
#define IDS_VERDANABLDFONTSIZE          18662
#define IDS_VERDANABLDFONTNAME          18663
#define IDS_PROVIDER                    18664
#define IDS_DESCRIPTION                 18665
#define IDS_VERSION                     18666
#define IDS_HELPFILE                    18667
#define IDS_COLCONNECT                  18668
#define IDS_COLTRANSPORT                18669
#define IDS_COLTYPE                     18670
#define IDS_COLCOMMENT                  18671
#define IDS_FOLDERCON                   18672
#define IDS_CTXM_NAME                   18673
#define IDS_CTXM_STATUS                 18674
#define IDS_COMBO_CONNECTION            18675
#define IDS_COMBO_DISCONNECTION         18676
#define IDS_COMBO_IDLECONNECTION        18677
#define IDS_PERMS_SPECIAL_QUERY         18678
#define IDS_PERMS_SPECIAL_SET           18679
#define IDS_PERMS_SPECIAL_RESET         18680
#define IDS_PERMS_SPECIAL_SHADOW        18681
#define IDS_PERMS_SPECIAL_LOGON         18682
#define IDS_PERMS_SPECIAL_LOGOFF        18683
#define IDS_PERMS_SPECIAL_MSG           18684
#define IDS_PERMS_SPECIAL_CONNECT       18685
#define IDS_PERMS_SPECIAL_DISCONNECT    18686
#define IDS_PERMS_SPECIAL_DELETE        18687
#define IDS_PERMS_RESOURCE_ADMIN        18688
#define IDS_PERMS_RESOURCE_USER         18689
#define IDS_PERMS_RESOURCE_GUEST        18690
#define IDS_ERR_CONREADFAIL             18691
#define IDS_ERR_CONMAX                  18692
#define IDS_ERR_UNIQUECON               18693
#define IDS_ERR_PASSWDLEN               18694
#define IDS_ERR_PASSWDCONFIRM           18695
#define IDS_SUBHEADER_TIMEOUT           18696
#define IDS_HEADER_LOGONSETTINGS        18697
#define IDS_SUBHEADER_LOGONSETTINGS     18698
#define IDS_HDR_CONTYPE                 18699
#define IDS_SUBHDR_CONTYPE              18700
#define IDS_SUBHDR_SECURITY             18701
#define IDS_HDR_INITPRG                 18702
#define IDS_SUBHDR_INITPRG              18703
#define IDS_HDR_REMOTE                  18704
#define IDS_SUBHDR_REMOTE               18705
#define IDS_HDR_WALLPR                  18706
#define IDS_SUBHDR_WALLPR               18707
#define IDS_HDR_TRANSTYPE               18708
#define IDS_SUBHDR_TRANSTYPE            18709
#define IDS_HDR_LAN                     18710
#define IDS_SUBHDR_LAN                  18711
#define IDS_HDR_ASYNC                   18712
#define IDS_SUBHDR_ASYNC                18713
#define IDS_HDR_TIMEOUT                 18714
#define IDS_SUBHDR_TIMEOUT              18715
#define IDS_INVALID_DEVICE              18716
#define IDS_MAINFOLDERNAME              18717
#define IDS_DELETETEXT                  18718
#define IDS_DELTITLE                    18719
#define IDS_SECURPAGENAME               18720
#define IDS_ERR_PASSWD                  18721
#define IDS_ERR_PASSCONFIRM             18722
#define IDS_ERR_CONNAME                 18723
#define IDS_ERR_CONEXIST                18724
#define IDS_ERR_WINNAME                 18725
#define IDS_HDR_SECURITY                18726
#define IDS_DISABLECONNECTION           18727
#define IDS_DISABLELIVECONNECTION       18728
#define IDS_DELETELIVECON               18729
#define IDS_ERR_INEDITMODE              18730
#define IDS_INVALID_CHARS               18731
#define IDS_ERR_INVALIDCHARS            18732
#define IDS_ERR_LANRECFG                18733
#define IDS_ERR_LANCHANGE               18734
#define IDS_TSCCSNAPHELP                18735
#define IDS_TSCCHELPTOPIC               18736
#define IDS_ERR_DELFAIL                 18737
#define IDS_ERROR_NODEVICES             18738
#define IDP_ERROR_GET_OVERLAPPED_RESULT_READ 18739
#define IDP_ERROR_MODEM_SET_INFO        18740
#define IDP_ERROR_MODEM_GET_INIT        18741
#define IDP_ERROR_MODEM_GET_DIAL        18742
#define IDP_ERROR_MODEM_GET_LISTEN      18743
#define IDP_ERROR_GET_SECURITY_WINSTATION 18744
#define IDP_ERROR_PERMISSIONS_EDITOR_FAILED 18745
#define IDP_ERROR_SET_SECURITY_WINSTATION 18746
#define IDP_ERROR_INTERNAL_SETARGV      18747
#define IDP_ERROR_INTERNAL_PARSECOMMANDLINE 18748
#define IDP_ERROR_OEMTDINIT_CONFIGDLLENUMERATIONFAILURE 18749
#define IDP_ERROR_DISABLE               18750
#define IDP_ERROR_CANT_OPEN_DEVICE      18751
#define IDP_ERROR_CANT_INITIALIZE_DEVICE 18752
#define IDP_ERROR_READ_FILE             18753
#define IDP_ERROR_CANT_INITIALIZE_INPUT_THREAD 18754
#define IDP_ERROR_WAIT_FOR_MULTIPLE_OBJECTS 18755
#define IDP_ERROR_GET_COMM_MODEM_STATUS 18756
#define IDP_ERROR_WAIT_COMM_EVENT       18757
#define IDP_ERROR_CANT_CREATE_INPUT_THREAD 18758
#define IDC_RADIO_LGINFO_WZ             18759
#define IDS_WRN_UNIQUECON               18760
#define IDC_RADIO_MAXCON                18761
#define IDS_CACHEDSESSIONS              18761
#define IDC_CONNECTION_NAME             18762
#define IDS_DELTEMPONEXIT               18762
#define IDC_RADIO_LOGON                 18763
#define IDS_USETEMPDIR                  18763
#define IDS_DEFCONSEC                   18764
#define IDS_LICENSING                   18765
#define IDS_ERR_CACHEDVALUE             18766
#define IDS_SETTINGS_COLUMN1            18767
#define IDS_ATTRIB_COLUMN2              18768
#define IDS_DISABLECON                  18769
#define IDS_DISABLECON_STATUS           18770
#define IDS_ENABLECON                   18771
#define IDS_ENABLECON_STATUS            18772
#define IDS_RENAMECON                   18773
#define IDS_RENAMECON_STATUS            18774
#define IDS_REMOVEONEXIT                18775
#define IDS_USEPERSESSION               18776
#define IDS_RAA                         18777
#define IDS_AS                          18778
#define IDS_AA                          18779
#define IDS_ERROR_INVALID_SD            18780
#define IDS_YES                         18781
#define IDS_NO                          18782
#define IDS_ENABLED                     18783
#define IDS_DISABLED                    18784
#define IDS_YESMENU                     18785
#define IDS_NOMENU                      18786
#define IDS_ENABLEMENU                  18787
#define IDS_DISABLEMENU                 18788
#define IDS_CACHEDSESSION_STATUS        18789
#define IDS_STANDARAD_PROPERTIES_STATUS 18790
#define IDS_NOTDELTEMP_STATUS           18791
#define IDS_DELTEMP_STATUS              18792
#define IDS_PROPERTIES_MENU             18793
#define IDS_NOTUSEPERSESSION_STATUS     18794
#define IDS_USEPERSESSION_STATUS        18795
#define IDS_SETTINGSFOLDER              18798
#define IDS_RENAME_WRN_SINGLE           18799
#define IDS_RENAME_WRN_PL               18800
#define IDC_MODEM_PROP_WIZ              18801
#define IDC_MODEM_PROP_PROP             18802
#define IDP_ERROR_MODEM_PROPERTIES_NOT_AVAILABLE 18803
#define IDS_WRN_TSTCON                  18804
#define IDS_DD_WINTITLE                 18805
#define IDS_UPS_WINTITLE                18806
#define IDP_INVALID_BAUD                18807
#define IDS_REBOOT_REQD                 18808
#define IDS_LIC_ERRTITLE                18812
#define IDS_SETTINGSHELP                18813
#define IDS_TSCACCESSDENIED             18814
#define IDS_TSCERRGENERAL               18815
#define IDS_TSCERRTITLE                 18816
#define IDS_SSERROR                     18817
#define IDS_PROPCHANGE_WRN              18818
#define IDS_PROPCHANGE_WRN_2            18819
#define IDS_TERMSERPROP                 18820
#define IDS_REPORTERROR                 18821
#define IDS_ERR_INVALIDFIRSTCHAR        18822
#define IDS_CHANGE_ASYNC                18823
#define IDS_CHANGE_MODEM                18824
#define IDS_ASYNC_HELPFILE              18825
#define IDS_ACTIVEDESK_MENU             18827
#define IDS_ACTIVEDESK_PROP_STATUS      18828
#define IDS_DISABLE_ADP_STATUS          18829
#define IDS_ENABLE_ADP_STATUS           18830
#define IDS_ADS_ATTR                    18831
#define IDS_NONE                        18834
#define IDS_DISABNETWORK                18835
#define IDS_INVALNETWORK                18836
#define HID_ASYNCTEST                   28324
#define HID_ASYNCADVANCE                28325
#define IDS_USERPERM_W2K                18837
#define IDS_USERPERM_NT4                18838
#define IDS_USERPERM                    18839
#define IDC_RADIO_WIN2KPERM             18840
#define IDC_RADIO_TS4PERM               18841
#define IDC_LTEXT_W2KUSERS              18842
#define IDD_PROPPAGE_TERMINAL_SERVER_PERM 18843
#define IDC_USERPERM_ICON               18844
#define IDI_ICON_WARNING                18845
#define IDS_REMOTEADMIN_ONLY            18846
#define IDC_STATIC_NA                   18847
#define IDS_HARDWARE		            18848
#define IDS_ERR_TERMSRVMODE             18849

//
#define IDD_CUSTOM_SECURITY             18853
#define IDC_GP_LINK                     18854

#define IDS_SINGLE_SESSION              18855
#define IDS_DISABLE_SINGLESESSION_STATUS 18856
#define IDS_ENABLE_SINGLESESSION_STATUS 18857
#define IDD_SINGLE_SESSION              18858

#define IDS_COLORDEPTH_24		18859
#define IDS_COLORDEPTH_16		18860
#define IDS_COLORDEPTH_15		18861
#define IDS_COLORDEPTH_8		18862

#define ID_HELP                         0xE146
#define IDC_STATIC_LEVELOFCTRL          -2
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        636
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         639
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif

//
// MUI localized strings for
// start menu, etc. DO NOT CHANGE THESE VALUES
// without updating tsoc.inx
//
#define IDS_TSCC_STARTMENU_NAME                10000
#define IDS_TSCC_STARTMENU_TIP                 10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\sdlgs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include<stdafx.h>
#include"resource.h"
#include"sdlgs.h"
#include"snodes.h"


#include<shellapi.h>
#include<shlapip.h>
#include <shlobj.h>
#include<shlobjp.h>

BOOL OnHelp( HWND hwnd , LPHELPINFO lphi );

BOOL OnContextMenu( HWND hwnd , POINT& pt );

void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

#define RECTWIDTH( rc )  ((rc).right - (rc).left)
#define RECTHEIGHT( rc ) ((rc).bottom - (rc).top)

extern BOOL g_bAppSrvMode;


#if 0
//--------------------------------------------------------------------------------------
INT_PTR CALLBACK CachedSessionsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;
    
    DWORD nVal = 0;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );
        
        SetFocus( GetDlgItem( hDlg , IDC_EDIT_CACHEDSESSION ) );

        pNode->m_pSettings->GetCachedSessions( &nVal );

        SetDlgItemInt( hDlg , IDC_EDIT_CACHEDSESSION , ( UINT )nVal , FALSE );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            BOOL bSuccess = FALSE;

            UINT uVal = GetDlgItemInt( hDlg , IDC_EDIT_CACHEDSESSION , &bSuccess , FALSE );
            
            if( !bSuccess )
            {
                ErrMessage( hDlg , IDS_ERR_CACHEDVALUE );

                return 0;
            }

            // check for any errors when setting this value

            pNode->SetAttributeValue( ( DWORD )uVal );
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

#endif 

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK UsePerSessionTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;

    // TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

    static INT nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == PERSESSION_TEMPDIR )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }

        SendMessage( GetDlgItem( hDlg , IDC_RADIO_PERSESSION_YES ) , BM_SETCHECK , ( WPARAM )bVal , 0 );
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_PERSESSION_NO ) , BM_SETCHECK , ( WPARAM )!bVal , 0 );
        
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_PERSESSION_YES), !p.fPolicyTempFoldersPerSession);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_PERSESSION_NO), !p.fPolicyTempFoldersPerSession);

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;


    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }            
            
            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_PERSESSION_YES ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

#if 0 // removed from final release
//--------------------------------------------------------------------------------------
INT_PTR CALLBACK DefConSecurityDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode = NULL;
    
    DWORD nVal = 0;
    

    switch( msg )
    {
    case WM_INITDIALOG :
        {
            TCHAR tchBuffer[ 128 ];

            INT rgid[] = { IDS_RAA , IDS_AS , IDS_AA , -1 };
            
            pNode = ( CSettingNode *)lp;

            ASSERT( pNode != NULL );
        
            // ok to store null -- it's initializing DWLP_USER area

            SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

            for( int idx = 0; rgid[ idx ] != -1 ; ++idx )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , rgid[ idx ] , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_ADDSTRING , 0 , ( LPARAM )tchBuffer );
            }


            nVal = ( DWORD )pNode->xx_GetValue( );

            if( nVal == 0 )
            {
                // error message 

                ErrMessage( hDlg , IDS_ERROR_INVALID_SD );
                            
            }
        
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_SETCURSEL , ( WPARAM )( nVal - 1 ) , 0 );

        }

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;


    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }
            
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_DEFSEC ) , CB_GETCURSEL , 0 , 0 );

            if( iSel != CB_ERR )
            {
                INT nOld = pNode->xx_GetValue( );

                if( nOld != ( INT )( iSel + 1 ) )
                {
                    DWORD dwStatus;

                    if( FAILED( pNode->SetAttributeValue( ( DWORD )( iSel + 1 ) , &dwStatus ) ) )
                    {
                        SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                    }
                }
            }
            else
            {
                ErrMessage( hDlg , IDS_ERROR_INVALID_SD );                
            }

            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;

}

#endif

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK LicensingDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;
    DWORD dwStatus;

    static HCURSOR hcurWait;

    static ULONG ulOldSelection;

    static ULONG *rgulModes = NULL;

    static WCHAR **rgszNames = NULL;

    static WCHAR **rgszDescriptions = NULL;

    static ULONG cModes = 0;

    switch( msg )
    {
    case WM_INITDIALOG :
        {
        ULONG ulMode;
        ULONG iMode = 0;        // index of ulMode in rgulModes
        DWORD nTermSrvMode;
        DWORD idcRA;
        RECT rcTextCtrl;
        HRESULT hr;
        HWND hLW;
        ISettingsComp *pSc;
        BOOL fIModeFound = FALSE;

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );

        pSc = reinterpret_cast< ISettingsComp * >( pNode->GetInterface() );

        ASSERT(NULL != pSc)
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        //
        // read valid modes and cache them
        //

        hr = pSc->GetLicensingModeList( &cModes, &rgulModes, &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE_LIST );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        hr = pSc->GetLicensingMode( &ulMode, &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        rgszNames = (WCHAR **) CoTaskMemAlloc(cModes * sizeof(WCHAR *));

        if (NULL == rgszNames)
        {
            ErrMessage( hDlg , IDS_ERROR_NO_MEMORY );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        rgszDescriptions = (WCHAR **) CoTaskMemAlloc(cModes * sizeof(WCHAR *));

        if (NULL == rgszDescriptions)
        {
            ErrMessage( hDlg , IDS_ERROR_NO_MEMORY );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        for (ULONG i = 0; i < cModes; i++)
        {
            hr = pSc->GetLicensingModeInfo(rgulModes[i],rgszNames+i,rgszDescriptions+i,&dwStatus);

            if (FAILED(hr))
            {
                ErrMessage( hDlg , IDS_ERROR_NO_LICENSING_MODE_INFO );
                EndDialog( hDlg , 0 );
                goto done_init;
            }

            if (ulMode == rgulModes[i])
            {
                iMode = i;
                fIModeFound = TRUE;
            }

            SendMessage( GetDlgItem( hDlg , IDC_LICENSING_MODE ) , CB_ADDSTRING , 0 , (LPARAM) rgszNames[i] ); 
        }

        ASSERT(fIModeFound);

        ulOldSelection = iMode;

        //
        // make current mode the selection in the dropdown
        //
        SendMessage( GetDlgItem( hDlg , IDC_LICENSING_MODE ) , CB_SETCURSEL , (WPARAM) iMode , 0 );

        //
        // Show the mode description in the description control
        //
        SetWindowText( GetDlgItem( hDlg , IDC_LICENSING_DESCRIPTION ),  rgszDescriptions[iMode] );

        //
        // make the valid remote admin control visible
        //
        hr = pSc->GetTermSrvMode( &nTermSrvMode , &dwStatus );

        if (FAILED(hr))
        {
            ErrMessage( hDlg , IDS_ERR_TERMSRVMODE );
            EndDialog( hDlg , 0 );
            goto done_init;
        }

        idcRA = nTermSrvMode ? IDC_LICENSING_TO_REMOTE_ADMIN : IDC_LICENSING_FROM_REMOTE_ADMIN;

        //
        // make the remote admin control into a link
        //
        GetWindowRect( GetDlgItem( hDlg , idcRA ) , &rcTextCtrl );

        MapWindowPoints( NULL , hDlg , ( LPPOINT )&rcTextCtrl , 2 );

        LinkWindow_RegisterClass();

        hLW = CreateWindowEx( 0 ,
                              TEXT("Link Window") ,
                              TEXT( "" ) ,
                              WS_CLIPSIBLINGS | WS_TABSTOP | WS_CHILD | WS_VISIBLE,
                              rcTextCtrl.left ,
                              rcTextCtrl.top ,
                              RECTWIDTH( rcTextCtrl ) ,
                              RECTHEIGHT( rcTextCtrl ),
                              hDlg ,
                              ( HMENU )12,
                              NULL,
                              NULL );

        {
            TCHAR tchBuffer[ 512 ];
            GetWindowText( GetDlgItem( hDlg , idcRA ), tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) ;

            SetWindowText( hLW , tchBuffer );
        }

        hcurWait = LoadCursor( NULL , MAKEINTRESOURCE( IDC_WAIT ) ) ;
        }         
done_init:
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;


    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if ( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }            

            LRESULT nCurSel = SendMessage(GetDlgItem( hDlg ,
                                                      IDC_LICENSING_MODE),
                                          CB_GETCURSEL,
                                          0,
                                          0);

            if ( ulOldSelection != (ULONG) nCurSel )
            {
                if( FAILED( pNode->SetAttributeValue( ( DWORD )rgulModes[nCurSel] , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg ,
                                       pNode->GetObjectId( ),
                                       dwStatus );
                }
            }
        }

        if (( LOWORD( wp ) == IDCANCEL ) || ( LOWORD( wp ) == IDOK ))
        {
            LinkWindow_UnregisterClass( _Module.GetModuleInstance() );

            if (NULL != rgszNames)
            {
                CoTaskMemFree(rgszNames);
                rgszNames = NULL;
            }

            if (NULL != rgszDescriptions)
            {
                CoTaskMemFree(rgszDescriptions);
                rgszDescriptions = NULL;
            }

            EndDialog( hDlg , 0 );
        }
        else if (HIWORD( wp ) == CBN_SELCHANGE)
        {
            LRESULT nCurSel = SendMessage((HWND) lp,
                                          CB_GETCURSEL,
                                          0,
                                          0);
            
            ASSERT((ULONG)nCurSel < cModes);

            SetWindowText( GetDlgItem( hDlg , IDC_LICENSING_DESCRIPTION ),
                           rgszDescriptions[nCurSel] );
        }

        break;
    case WM_NOTIFY:

        switch (((LPNMHDR)lp)->code)
        {
            case NM_CHAR:
			
				if( ( ( LPNMCHAR )lp )->ch != VK_SPACE )
				{
					break;
				}

				// else fall through

            case NM_RETURN:	
            case NM_CLICK:
			{                
                TCHAR szFile[MAX_PATH];

                TCHAR szParam[MAX_PATH];

                SHELLEXECUTEINFO sei;

                ZeroMemory( &sei , sizeof( SHELLEXECUTEINFO ) );

                if ( GetSystemDirectory( szFile , SIZE_OF_BUFFER( szFile ) ) )
                {
                    lstrcpy( szParam , TEXT( ",2" ) );

                    lstrcpy( szFile , TEXT( "appwiz.cpl" ) );

                    sei.cbSize = sizeof( SHELLEXECUTEINFO );

                    sei.fMask = SEE_MASK_NOCLOSEPROCESS;

                    sei.lpFile = szFile;

                    sei.lpParameters = szParam;
                 
                    if( ShellExecuteEx( &sei ) )
                    {
                        EndDialog( hDlg, IDCANCEL );                        
                    }
                }
            }

            break;
        }

        break;
    }

    return 0;
}

//--------------------------------------------------------------------------------------
INT_PTR CALLBACK ConfigActiveDesktop( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;

    //TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

	static nOldSelection;

    switch( msg )
    {

    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
               
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == ACTIVE_DESK )
        {
            
            bVal = ( BOOL )pNode->xx_GetValue( );

        }
        
		// control converted into a checkbox if the chkbx is checked it means disable
		// unchecked, well you've guest it.

        if( bVal )
        {
			
            SendMessage( GetDlgItem( hDlg , IDC_RADIO_AD_ENABLE ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );
        }
        else
        {
			SendMessage( GetDlgItem( hDlg , IDC_RADIO_AD_ENABLE ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );
            //SendMessage( GetDlgItem( hDlg , IDC_RADIO_ADP_DISABLE ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );
        }

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_AD_ENABLE ) == BST_CHECKED ? 0 : 1;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}


//--------------------------------------------------------------------------------------
INT_PTR CALLBACK ConfigSingleSession( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;

    //TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

	static nOldSelection;

    switch( msg )
    {

    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
               
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == SINGLE_SESSION )
        {
            
            bVal = ( BOOL )pNode->xx_GetValue( );

        }
        
		// control converted into a checkbox if the chkbx is checked it means enable
		// unchecked, well you've guest it.

			
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_SINGLE_SESSION_ENABLE ) , BM_SETCHECK , ( WPARAM )bVal , 0 );

        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg,IDC_RADIO_SINGLE_SESSION_ENABLE), !p.fPolicySingleSessionPerUser);

        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_SINGLE_SESSION_ENABLE ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}


//--------------------------------------------------------------------------------------
INT_PTR CALLBACK DeleteTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp )
{
    CSettingNode *pNode;

    // TCHAR tchNewName[ 128 ];
    
    BOOL bVal = FALSE;

    static nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == DELETED_DIRS_ONEXIT )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }

        SendMessage( GetDlgItem( hDlg , IDC_RADIO_YES ) , BM_SETCHECK , ( WPARAM )bVal , 0 );
        SendMessage( GetDlgItem( hDlg , IDC_RADIO_NO ) , BM_SETCHECK , ( WPARAM )!bVal , 0 );

        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_YES), !p.fPolicyDeleteTempFoldersOnExit);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_NO), !p.fPolicyDeleteTempFoldersOnExit);
        
        nOldSelection = bVal;
        
        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            if( hDlg == GetParent( ( HWND )wp ) )
            {
                OnContextMenu( ( HWND )wp , pt );
            }
        }

        break;

    case WM_HELP:

        OnHelp( hDlg , ( LPHELPINFO )lp );

        break;

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_YES ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;

                if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//-------------------------------------------------------------------------------
INT_PTR CALLBACK UserPermCompat( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp )
{
	CSettingNode *pNode;
        
    BOOL bVal = FALSE;

    HICON hIcon;

    static nOldSelection;

    switch( msg )
    {
    case WM_INITDIALOG :

        pNode = ( CSettingNode *)lp;

        ASSERT( pNode != NULL );
        
        // ok to store null -- it's initializing DWLP_USER area

        SetWindowLongPtr( hDlg , DWLP_USER , ( LONG_PTR )pNode );

        if( pNode->GetObjectId( ) == USERSECURITY )
        {            
            bVal = ( BOOL )pNode->xx_GetValue( );
        }
        
        if( bVal )
        {
			CheckDlgButton( hDlg , IDC_RADIO_TS4PERM , BST_CHECKED );            
        }
        else
        {
            CheckDlgButton( hDlg , IDC_RADIO_WIN2KPERM , BST_CHECKED );
        }

        nOldSelection = bVal;

       hIcon = LoadIcon( _Module.GetModuleInstance( ) , MAKEINTRESOURCE( IDI_ICON_WARNING ) );

       hIcon = ( HICON )LoadImage( _Module.GetModuleInstance( ) ,
                                    MAKEINTRESOURCE( IDI_ICON_WARNING ) ,
                                    IMAGE_ICON,
                                    0,
                                    0,
                                    0 );



       SendMessage( GetDlgItem( hDlg , IDC_USERPERM_ICON ) , STM_SETICON , ( WPARAM )hIcon , 0 );

        
        break;

	 case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            pNode = ( CSettingNode *)GetWindowLongPtr( hDlg , DWLP_USER );

            if( pNode == NULL )
            {
                break;
            }

            INT nCurrent = IsDlgButtonChecked( hDlg , IDC_RADIO_TS4PERM ) == BST_CHECKED ? 1 : 0;

            if( nOldSelection != nCurrent )
            {
                DWORD dwStatus;                

                // flag error if not in appsrv mode
                // we should never get here -- unless someone mucked around with the registry.

                if( !g_bAppSrvMode )
                {
                    xxxErrMessage( hDlg , IDS_REMOTEADMIN_ONLY , IDS_WARN_TITLE , MB_OK | MB_ICONINFORMATION );

                    CheckRadioButton( hDlg ,
                                      IDC_RADIO_WIN2KPERM , 
                                      IDC_RADIO_TS4PERM,
                                      ( nOldSelection ) ? IDC_RADIO_TS4PERM : IDC_RADIO_WIN2KPERM 
                                    );
                    return 0;

                }

                else if( FAILED( pNode->SetAttributeValue( ( DWORD )nCurrent , &dwStatus ) ) )
                {
                    SnodeErrorHandler( hDlg , pNode->GetObjectId( ) , dwStatus );
                }
            }
            
            EndDialog( hDlg , 0 );

        }

        else if( LOWORD( wp ) == IDCANCEL )
        {
            EndDialog( hDlg , 0 );
        }

        break;
    }

    return 0;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    UNREFERENCED_PARAMETER( hwnd );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }

    if( lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

    ULONG_PTR rgdw[ 2 ];

    rgdw[ 0 ] = ( ULONG_PTR )lphi->iCtrlId;

    rgdw[ 1 ] = ( ULONG_PTR )lphi->dwContextId;

    WinHelp( ( HWND )lphi->hItemHandle , tchHelpFile , HELP_WM_HELP , ( ULONG_PTR )&rgdw );//lphi->dwContextId );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Used when user right clicks the item.  "What's this?" will appear
//
// The first parameter must be the control in the dialog
// because this is a helper function the caller must insure this.
//-------------------------------------------------------------------------------
BOOL OnContextMenu( HWND hwnd , POINT& pt )
{
    UNREFERENCED_PARAMETER( pt );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // Make sure its not a dummy window
    //
    
    if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
    {
        return FALSE;
    }
    
    ULONG_PTR rgdw[ 2 ];
    
    rgdw[ 0 ] = GetDlgCtrlID( hwnd );
    
    rgdw[ 1 ] = GetWindowContextHelpId( hwnd );
    
    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );
    
    WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , ( ULONG_PTR )&rgdw );
    
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\sdlgs.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _SDLGS_H
#define _SDLGS_H

// INT_PTR CALLBACK CachedSessionsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK UsePerSessionTempDirsDlgProc( HWND  , UINT , WPARAM , LPARAM );

INT_PTR CALLBACK DeleteTempDirsDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

// INT_PTR CALLBACK DefConSecurityDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK LicensingDlgProc( HWND hDlg , UINT msg , WPARAM wp , LPARAM lp );

INT_PTR CALLBACK ConfigActiveDesktop( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

INT_PTR CALLBACK UserPermCompat( HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

INT_PTR CALLBACK ConfigSingleSession(HWND hDlg , UINT msg, WPARAM wp , LPARAM lp );

#endif // _SDLGS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\snodes.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include"stdafx.h"
#include"snodes.h"
#include"resource.h"

#define ERROR_USERDEFINED_LICENSE_VIOLATION ( ( DWORD )0xC000026AL )

extern void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

extern void ReportStatusError( HWND hwnd , DWORD dwStatus );

void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus );

//----------------------------------------------------------
CSettingNode::CSettingNode( )
{
    m_szAttributeName = NULL;

    m_szAttributeValue = NULL;

    SetNodeType( RSETTINGS_NODE );

    m_objectid = -1;

    m_pSettings = NULL;

    m_hrStatus = S_OK;
}

//----------------------------------------------------------
void CSettingNode::SetObjectId( INT id )
{
    m_objectid = id;
}

//----------------------------------------------------------
HRESULT CSettingNode::SetAttributeValue( DWORD nVal , PDWORD pdwStatus )
{
    HRESULT hr = S_OK;

    ISettingsComp *pSettings = NULL;

    INT nObjectId = GetObjectId( );

    if( nObjectId < CUSTOM_EXTENSION )
    {
        pSettings = reinterpret_cast< ISettingsComp *>(  m_pSettings );

        if( pSettings == NULL  )
        {
            ODS( L"CSettingNode::SetAttributeValue downcasting failure\n" );

            return E_FAIL;
        }
    }


    if( nObjectId == LICENSING )
    {        
        DWORD dwNewStatus;

        hr = pSettings->SetLicensingMode( nVal , pdwStatus, &dwNewStatus );

        if( SUCCEEDED( hr ) )
        {
            xx_SetValue( nVal );
        }
        else
        {
            if ((NULL != pdwStatus) && (ERROR_SUCCESS == *pdwStatus))
            {
                // make sure any failure gets returned to caller

                *pdwStatus = dwNewStatus;
            }
        }
    }
    else
    {
        if( nObjectId == DELETED_DIRS_ONEXIT ) // Delete temp dirs on exit
        {
            hr =  pSettings->SetDelDirsOnExit( ( BOOL )nVal );
        }
        else if( nObjectId == PERSESSION_TEMPDIR )// User temp dirs per session
        {
            hr = pSettings->SetUseTempDirPerSession( ( BOOL )nVal );
        }
        /* else if( nObjectId == DEF_CONSECURITY ) // default security descriptor
        {
            hr = m_pSettings->SetDefaultSecurity( nVal );
        }*/ 
        else if( nObjectId == ACTIVE_DESK )
        {
            hr = pSettings->SetActiveDesktopState( nVal , pdwStatus );

        }
        else if( nObjectId == USERSECURITY )
        {
            hr = pSettings->SetUserPerm( nVal , pdwStatus );

            if( FAILED( hr ) )
            {
                return hr;
            }
        }
        else if( nObjectId == SINGLE_SESSION )
        {
            hr = pSettings->SetSingleSessionState( nVal , pdwStatus );

        }


        if( FAILED( hr ) )
        {
            if( hr == E_ACCESSDENIED )
            {
                *pdwStatus = ERROR_ACCESS_DENIED;
            }
            else
            {
                *pdwStatus = ( DWORD )hr; // general failure
            }
        
        }
        else
        {
            xx_SetValue( nVal );
        }
    }

    return hr;
}

//----------------------------------------------------------
BOOL CSettingNode::SetAttributeName( LPTSTR psz )
{
    if( psz != NULL )
    {
        int cchText = lstrlen( psz ) + 1;

        if( m_szAttributeName != NULL )
        {
            delete[] m_szAttributeName;
        }

        m_szAttributeName = ( LPTSTR )new TCHAR[ cchText ];

        if( m_szAttributeName != NULL )
        {
            lstrcpy( m_szAttributeName , psz );
        }

        return TRUE;
    }

    return FALSE;
}


//----------------------------------------------------------
LPTSTR CSettingNode::GetAttributeValue( )
{     
    DWORD nVal = 0;

    DWORD dwStatus;
    
    ISettingsComp *pSettings = NULL;

    HRESULT hr = S_OK;

    INT nObjectId = GetObjectId( );

    if( nObjectId < CUSTOM_EXTENSION )
    {        
        pSettings = reinterpret_cast< ISettingsComp *>(  m_pSettings );

        if( pSettings == NULL )
        {            
            hr = E_FAIL;
        }

        ODS( L"Getting attribute value\n" );
    }   
    
    if( SUCCEEDED( hr ) )
    {    
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);

        switch( nObjectId )
        {
        case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit
        
            hr = pSettings->GetDelDirsOnExit( ( PBOOL )&nVal );

            if (p.fPolicyDeleteTempFoldersOnExit)
                nVal = p.fDeleteTempFoldersOnExit;
     
            break;

        case PERSESSION_TEMPDIR:// User temp dirs per session
        
            hr = pSettings->GetUseTempDirPerSession( ( PBOOL )&nVal );

            if (p.fPolicyTempFoldersPerSession)
                nVal = p.fTempFoldersPerSession;
     
            break;
        

        /* case DEF_CONSECURITY: // default security descriptor
        
            hr = m_pSettings->GetDefaultSecurity( &nVal );
        
            break;
            */
        
        case LICENSING: // licensing mode
            
            hr = pSettings->GetLicensingMode( &nVal , &dwStatus );

            break;

        case ACTIVE_DESK:
            
            hr = pSettings->GetActiveDesktopState( ( PBOOL )&nVal , &dwStatus );

            break;

        case USERSECURITY:

            hr = pSettings->GetUserPerm( ( PBOOL )&nVal , &dwStatus );

            break;

        case SINGLE_SESSION:

            hr = pSettings->GetSingleSessionState( ( PBOOL )&nVal , &dwStatus );

            if (p.fPolicySingleSessionPerUser)
                nVal = p.fSingleSessionPerUser;

            break;

        default:
            if( nObjectId >= CUSTOM_EXTENSION )
            {
                ODS( L"Getting attribute value\n" );
                nVal = 0; // we don't care we leave it up to the provider 
                hr = S_OK;
            }

        }
    }

    if( FAILED( hr ) )
    {
        TCHAR szBuffer[ 80 ];

        szBuffer[0] = 0;

        if( m_szAttributeValue != NULL )
        {
            delete[] m_szAttributeValue;
        }
        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SSERROR , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        
        m_szAttributeValue = ( LPTSTR )new TCHAR[ lstrlen( szBuffer ) + 1 ];
        
        if( m_szAttributeValue != NULL )
        {
            lstrcpy( m_szAttributeValue , szBuffer );
        }

        if( nObjectId != LICENSING )
        {
            xx_SetValue( 0 );
        }

    }
    else
    {
        xx_SetValue( nVal );
    }   

    m_hrStatus = hr;

    return m_szAttributeValue;
}

//----------------------------------------------------------
DWORD CSettingNode::GetImageIdx( )
{
    return ( DWORD )3;
}


//----------------------------------------------------------
BOOL CSettingNode::AddMenuItems( LPCONTEXTMENUCALLBACK pcmc , PLONG pl )
{

    HRESULT hr = E_FAIL;

    TCHAR tchName[ 80 ];

    TCHAR tchStatus[ 256 ];

    CONTEXTMENUITEM cmi;

    BOOL bVal = FALSE;

    INT nObjectId = GetObjectId( );

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    switch( nObjectId )
    {

    case DELETED_DIRS_ONEXIT:
                
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;
        
        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {        
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOTDELTEMP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DELTEMP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
            }

            if (p.fPolicyDeleteTempFoldersOnExit)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_DELTEMPDIRSONEXIT;

            hr = pcmc->AddItem( &cmi );
        }


        break;

    case PERSESSION_TEMPDIR:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {                
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOTUSEPERSESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;                
        
            }
            else
            {                
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USEPERSESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;        
            }

            if (p.fPolicyTempFoldersPerSession)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_USETMPDIR;

            hr = pcmc->AddItem( &cmi );
        }

        break;

    /* case DEF_CONSECURITY:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;
        */

    case LICENSING:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;

    case ACTIVE_DESK:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ACTIVEDESK_PROP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLEMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLE_ADP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;  
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLEMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLE_ADP_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;
            }

            cmi.lCommandID = IDM_SETTINGS_ADP;

            hr = pcmc->AddItem( &cmi );
        }

        break;    

    case SINGLE_SESSION:

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        if( SUCCEEDED( hr ) )
        {
            bVal = ( BOOL )xx_GetValue( );

            if( bVal )
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NOMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLE_SINGLESESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;  
            }
            else
            {
                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YESMENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

                cmi.strName = tchName;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLE_SINGLESESSION_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

                cmi.strStatusBarText = tchStatus;
            }

            if (p.fPolicySingleSessionPerUser)
            {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                cmi.fFlags &= 0xFFFFFFFCL; 
                cmi.fFlags |= MF_GRAYED;
            }

            cmi.lCommandID = IDM_SETTINGS_SS;

            hr = pcmc->AddItem( &cmi );
        }

        break;    

    case USERSECURITY:
        
        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPERTIES_MENU , tchName , SIZE_OF_BUFFER( tchName ) ) );

        cmi.strName = tchName;

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_STANDARAD_PROPERTIES_STATUS , tchStatus , SIZE_OF_BUFFER( tchStatus ) ) );

        cmi.strStatusBarText = tchStatus;

        cmi.lCommandID = IDM_SETTINGS_PROPERTIES;
        
        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;//CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        cmi.fFlags = cmi.fSpecialFlags = 0;
        
        *pl |= CCM_INSERTIONALLOWED_TOP; //CCM_INSERTIONALLOWED_TASK;
        
        hr = pcmc->AddItem( &cmi );

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pSetting = reinterpret_cast< IExtendServerSettings * >( m_pSettings );

            if( pSetting != NULL )
            {
                PMENUEXTENSION pMex = NULL;

                INT cbItems = 0;

                if( SUCCEEDED( pSetting->GetMenuItems( &cbItems , &pMex ) ) )
                {
                    for( INT i = 0 ; i < cbItems; i++ )
                    {
                        cmi.strName = pMex[ i ].MenuItemName;

                        cmi.strStatusBarText = pMex[ i ].StatusBarText;

                        cmi.lCommandID = pMex[ i ].cmd;

                        cmi.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        
                        cmi.fFlags = pMex[ i ].fFlags;
                        cmi.fSpecialFlags = 0;
        
                        *pl |= CCM_INSERTIONALLOWED_TOP;
        
                        if (p.fPolicySessionDirectoryActive)
                        {
                            //Gray out everything but properties
                            if (cmi.lCommandID != IDM_MENU_PROPS) 
                            {
                                //Clear the last 2 bits since MF_GRAYED is 
                                //incompatible with MF_DISABLED
                                cmi.fFlags &= 0xFFFFFFFCL; 
                                cmi.fFlags |= MF_GRAYED;
                            }
                        }

                        if (p.fPolicySessionDirectoryLocation)
                        {
                            //Enable the "enable" menu item
                            if (cmi.lCommandID != IDM_MENU_PROPS) 
                            {
                                cmi.fFlags = 0; 
                            }
                        }


                        pcmc->AddItem( &cmi );

                    }

                    hr = S_OK;

                    LocalFree( pMex );
                }

            }
        }

    }
 
    return ( SUCCEEDED( hr ) ? TRUE : FALSE );
    
}

//----------------------------------------------------------
BOOL CSettingNode::SetInterface( LPUNKNOWN pInf )
{
    pInf->AddRef( );

    m_pSettings = pInf;

    return TRUE;
}

//----------------------------------------------------------
CSettingNode::~CSettingNode( )
{
    DBGMSG( L"CSettingNode dtor called for objectid %d\n" , m_objectid );

    if( m_szAttributeName != NULL )
    {
        delete[] m_szAttributeName;
    }

    if( m_szAttributeValue != NULL )
    {
        delete[] m_szAttributeValue;
    }

    if( m_pSettings != NULL )
    {
        m_pSettings->Release( );
    }
}


//---------------------------------------------------------
// Helper functions
//---------------------------------------------------------
BOOL CSettingNode::xx_SetValue( INT nVal )
{
    TCHAR szBuffer[ 1024 ]; 

    szBuffer[0] = 0;

    INT nObjectId = GetObjectId( );

    if( m_szAttributeValue != NULL )
    {
        delete[] m_szAttributeValue;
    }
        
    switch( nObjectId )
    {

    case SINGLE_SESSION:
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        break;
    
    case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
            
        }
        break;

    case PERSESSION_TEMPDIR:// User temp dirs per session
        
        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_YES , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NO , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        break;

    /*
    case DEF_CONSECURITY: // default security descriptor
    
        switch( nVal )
        {
        case 0: // this shoudl never happen
        case 1:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_RAA , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;

        case 2:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_AS , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;

        case 3:

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_AA , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );

            break;
        }

        break;
     */

        
    case LICENSING: // licensing mode
        {
            ISettingsComp *pSettings = reinterpret_cast< ISettingsComp * > (m_pSettings);

            if (NULL != pSettings)
            {
                WCHAR *wszName, *wszDescription;
                DWORD dwStatus;
                HRESULT hr;

                hr = pSettings->GetLicensingModeInfo(
                                                     nVal,
                                                     &wszName,
                                                     &wszDescription,
                                                     &dwStatus);

                if (SUCCEEDED(hr))
                {
                    _ASSERTE( ERROR_SUCCESS == dwStatus );
                    
                    lstrcpyn(szBuffer,wszName,sizeof(szBuffer)/sizeof(TCHAR));
                    
                    CoTaskMemFree(wszName);
                    CoTaskMemFree(wszDescription);
                }
            }
        }
        break;

    case ACTIVE_DESK:

        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ENABLED , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_DISABLED , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }

        break;

    case USERSECURITY:

        if( ( BOOL )nVal )
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USERPERM_NT4 , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }
        else
        {
            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_USERPERM_W2K , szBuffer , SIZE_OF_BUFFER( szBuffer ) ) );
        }

        break;

    default:

        if( nObjectId >= CUSTOM_EXTENSION )
        {
            IExtendServerSettings *pSettings = reinterpret_cast< IExtendServerSettings *>(  m_pSettings );

            if( pSettings != NULL )
            {
                pSettings->GetDisplayableValueName( szBuffer );

                DBGMSG( L"xx_SetValue for Extension returned %s\n" , szBuffer );
            }
        }


    } // switch

    m_szAttributeValue = ( LPTSTR )new TCHAR[ lstrlen( szBuffer ) + 1 ];
    
    if( m_szAttributeValue != NULL )
    {
        lstrcpy( m_szAttributeValue , szBuffer );
    }

    m_nGenericValue = nVal;

    return TRUE;
}
        
//----------------------------------------------------------------------
// And all out central server setting error handler
// this is setup in this manner to allow MMC to own the Msgbx as well
// as the custom dialog pages
//
void SnodeErrorHandler( HWND hParent , INT nObjectId , DWORD dwStatus )
{
    switch( nObjectId )
    {
        
    case DELETED_DIRS_ONEXIT: // Delete temp dirs on exit

    case PERSESSION_TEMPDIR:// User temp dirs per session

    case SINGLE_SESSION: // Restrict to single session per user

    // case DEF_CONSECURITY: // default security descriptor

    case LICENSING: // licensing mode

    case ACTIVE_DESK:
        
        if( dwStatus == ERROR_ACCESS_DENIED )
        {
            TscAccessDeniedMsg( hParent );
        }
        else
        {
            TscGeneralErrMsg( hParent );
        }                
        break;

    case USERSECURITY:

        if( dwStatus != 0 )
        {
            ReportStatusError( hParent , dwStatus ); 
        }
    } // switch


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\snodes.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _SNODES_H
#define _SNODES_H

#include "dataobj.h"

#include "resource.h"

//
// WARNING -
//   Following enum, VALIDOBJECTONSERVER, VALIDOBJECTONADS, and RGRESID 
//   has one to one correspondence, if you add/remove/change order of item, 
//   you must also update the other arrays.
//

//
// Object ID for the item display on the right panel (under server settings)
//
#define CUSTOM_EXTENSION 6

enum { DELETED_DIRS_ONEXIT,     // delete temp. folder on exit
       PERSESSION_TEMPDIR,      // use temporary folder per session
       LICENSING,               // licensing mode
       ACTIVE_DESK,             // active desktop
       USERSECURITY,            // FULL or relax security 
       SINGLE_SESSION};         // single session per user.

//
// Valid item to be display on right panel 
// when running in server.
//
const BOOL VALIDOBJECTONSERVER[] = { 
                                        TRUE, 
                                        TRUE, 
                                        FALSE,  // licensing
                                        TRUE, 
                                        FALSE, 
                                        FALSE };

//
// Valid item to be display on right panel 
// when running in advance server.
//
const BOOL VALIDOBJECTONADS[] = { 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE, 
                                    TRUE };


//
// Resource ID for the item
//
const INT RGRESID [] = {
                         IDS_DELTEMPONEXIT, 
                         IDS_USETEMPDIR,
                         IDS_LICENSING,
                         IDS_ADS_ATTR,
                         IDS_USERPERM,
                         IDS_SINGLE_SESSION };

class CSettingNode : public CBaseNode
{
    LPTSTR m_szAttributeName;
    
    LPTSTR m_szAttributeValue;

    INT m_nGenericValue;

    INT m_objectid;

	HRESULT m_hrStatus;

public:

    CSettingNode( );

    virtual ~CSettingNode( );

    HRESULT SetAttributeValue( DWORD , PDWORD );

    BOOL SetAttributeName( LPTSTR );

    LPTSTR GetAttributeName( ){ return m_szAttributeName; }

    LPTSTR GetAttributeValue( );

    LPTSTR GetCachedValue( ){ return m_szAttributeValue; }

    DWORD GetImageIdx( );

    void SetObjectId( INT );

    INT GetObjectId( ) { return m_objectid; }

    BOOL AddMenuItems( LPCONTEXTMENUCALLBACK , PLONG );

    BOOL SetInterface( LPUNKNOWN );

    BOOL xx_SetValue( INT );

    INT xx_GetValue( ){ return m_nGenericValue; }

	HRESULT GetNodeStatus( ) const { return m_hrStatus; }

    LPUNKNOWN GetInterface( ) { return m_pSettings; }

private:

    LPUNKNOWN m_pSettings;
    
};


#endif //_SNODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\setup.cpp ===
#include "stdafx.h"
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tchar.h>

*/
#include <shellapi.h>
#include <shlobj.h>

//#include "..\setup\inc\logmsg.h"
#include "..\setup\inc\registry.h"


LPCTSTR     RUN_KEY                         = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
LPCTSTR     HELP_POPUPRUN_VALUE             = _T("TerminalServerInstalled");
LPCTSTR     HELP_PUPUP_COMMAND              = _T("rundll32.exe %windir%\\system32\\tscc.dll, TSCheckList");

BOOL IsCallerAdmin( VOID )
{
    BOOL bFoundAdmin = FALSE;
    PSID pSid;
    //
    //  If the admin sid didn't initialize, the service would not have started.
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_NT_AUTHORITY;
    if  (AllocateAndInitializeSid(
            &SidAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pSid
            ))
    {
        ASSERT(pSid != NULL);

        if (!CheckTokenMembership(NULL, pSid, &bFoundAdmin))
        {
            bFoundAdmin = FALSE;
        }
        FreeSid(pSid);
    }

    return bFoundAdmin;
}

void TSCheckList()
{
    if (!IsCallerAdmin())
    {
        return;
    }

    const TCHAR szHelpDir[] = _T("%windir%\\Help");
    const TCHAR szHelpCommand[] = _T("ms-its:%windir%\\help\\termsrv.chm::/ts_checklist_top.htm");
    TCHAR szHelpDirEx[MAX_PATH];


    if (!ExpandEnvironmentStrings(
        szHelpDir,
        szHelpDirEx,
        sizeof(szHelpDirEx)/sizeof(szHelpDirEx[0])))
    {
        return;
    }

    TCHAR szHelpCommandEx[1024];
    if (!ExpandEnvironmentStrings(
        szHelpCommand,
        szHelpCommandEx,
        sizeof(szHelpCommandEx)/sizeof(szHelpCommandEx[0])))
    {
        return;
    }

    //
    // now delete the Run registry entry, and execute the command stored in it.
    //
    CRegistry oReg;
    DWORD dwError = oReg.OpenKey(HKEY_LOCAL_MACHINE, RUN_KEY);
    if (dwError == ERROR_SUCCESS)
    {
        dwError = oReg.DeleteValue(HELP_POPUPRUN_VALUE);
        if (dwError == ERROR_SUCCESS)
        {
            ShellExecute(NULL,
                        TEXT("open"),
                        _T("hh.exe"),
                        szHelpCommandEx,
                        szHelpDirEx,
                        SW_SHOW);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED_)
#define AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include<winsta.h>
#include "cfgbkend.h"
#include "srvsetex.h"

#if __RPCNDR_H_VERSION__ < 440             // This may be needed when building
#define __RPCNDR_H_VERSION__ 440           // on NT5 (1671) to prevent MIDL errors
#define MIDL_INTERFACE(x) interface
#endif

#define ALN_APPLY ( WM_USER + 333 )

#define ERROR_ILLEGAL_CHARACTER         0x01

#define ERROR_INVALID_FIRSTCHARACTER    0x02

#define SPECIAL_ENABLETODISABLE         0x82345678

#define SPECIAL_DISABLETOENABLE         0x82345679

#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
    if( g_fDebug ) OutputDebugString( x );\

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[180]; \
    if( g_fDebug ) {\
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }

#define VERIFY_E( retval , expr ) \
    if( ( expr ) == retval ) \
    {  \
       ODS( L#expr ); \
       ODS( L" returned "); \
       ODS( L#retval ); \
       ODS( L"\n" ); \
    } \


#define VERIFY_S( retval , expr ) \
    if( ( expr ) != retval ) \
{\
      ODS( L#expr ); \
      ODS( L" failed to return " ); \
      ODS( L#retval ); \
      ODS( L"\n" ); \
}\

#define ASSERT( expr ) \
    if( !( expr ) ) \
    { \
       char tchAssertErr[ 180 ]; \
       wsprintfA( tchAssertErr , "Assertion in expression ( %s ) failed\nFile - %s\nLine - %d\nDo you wish to Debug?", #expr , (__FILE__) , __LINE__ ); \
       if( MessageBoxA( NULL , tchAssertErr , "ASSERTION FAILURE" , MB_YESNO | MB_ICONERROR )  == IDYES ) \
       {\
            DebugBreak( );\
       }\
    } \

#else

#define ODS
#define DBGMSG
#define ASSERT( expr )
#define VERIFY_E( retval , expr ) ( expr )
#define VERIFY_S( retval , expr ) ( expr )
#endif

#define WINSTATION_NAME_TRUNCATE_BY 7

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.



#endif // !defined(AFX_STDAFX_H__B91B5FFE_32D2_11D2_9888_00A0C925F917__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\todlg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TODLG_H
#define _TODLG_H

enum TOKEN { TOKEN_DAY , TOKEN_HOUR , TOKEN_MINUTE };


const ULONG kMilliMinute = 60000;
const ULONG kMaxTimeoutMinute = 71580;

#define E_PARSE_VALUEOVERFLOW   0x80000000
#define E_PARSE_INVALID         0xffffffff
#define E_SUCCESS               0
#define E_PARSE_MISSING_DIGITS  0X7fffffff

//---------------------------------------------------------------------
// retains object state for the timeout dlg combx
//---------------------------------------------------------------------
typedef struct _cbxstate
{
    int icbxSel;

    BOOL bEdit;

} CBXSTATE;

//---------------------------------------------------------------------
// keeps a list of the time unit abbreviations and full names
// ie: h hr hrs hour hours
//---------------------------------------------------------------------
typedef struct _toktable
{
    LPTSTR pszAbbrv;

    DWORD dwresourceid;

} TOKTABLE, *PTOKTABLE;

//---------------------------------------------------------------------
// Dialog for Timeout settings page
//---------------------------------------------------------------------
class CTimeOutDlg 
{
    CBXSTATE m_cbxst[ 3 ];

public:
    
    CTimeOutDlg( );
    
    // BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    // BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    // BOOL OnDestroy( );

    // BOOL PersistSettings( HWND );

    // BOOL IsValidSettings( HWND );

    BOOL InitControl( HWND );

    BOOL ReleaseAbbreviates( );

    BOOL OnCommand( WORD , WORD , HWND , PBOOL );
    
    // static BOOL CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL ConvertToMinutes( HWND , PULONG );

    BOOL InsertSortedAndSetCurSel( HWND , DWORD );

    BOOL RestorePreviousValue( HWND );

    BOOL SaveChangedSelection( HWND );

    BOOL OnCBNSELCHANGE( HWND );

    BOOL ConvertToDuration ( ULONG , LPTSTR );

    LRESULT ParseDurationEntry( LPTSTR , PULONG );

    virtual int GetCBXSTATEindex( HWND ) = 0;

    BOOL OnCBEditChange( HWND );

    BOOL DoesContainDigits( LPTSTR );

    BOOL OnCBDropDown( HWND );

    BOOL IsToken( LPTSTR , TOKEN );

    BOOL LoadAbbreviates( );

    BOOL xxxLoadAbbreviate( PTOKTABLE );

    BOOL xxxUnLoadAbbreviate( PTOKTABLE );

};
#endif // _TODLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\todlg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include <prsht.h>
#include "todlg.h"
#include "resource.h"

TOKTABLE tokday[ 4 ] = {
    { NULL , IDS_D },
    { NULL , IDS_DAY },
    { NULL , IDS_DAYS },
    { NULL , ( DWORD )-1 }
};

TOKTABLE tokhour[ 6 ] = {
    { NULL , IDS_H     },
    { NULL , IDS_HR    },
    { NULL , IDS_HRS   },
    { NULL , IDS_HOUR  },
    { NULL , IDS_HOURS },
    { NULL , ( DWORD )-1 }
};

TOKTABLE tokmin[ 5 ] = {
    { NULL , IDS_M       },
    { NULL , IDS_MIN     },
    { NULL , IDS_MINUTE  },
    { NULL , IDS_MINUTES },
    { NULL , ( DWORD )-1 }
};


TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken );

//-------------------------------------------------------------------------------
// CTimeOutDlg::ctor
//-------------------------------------------------------------------------------
CTimeOutDlg::CTimeOutDlg( )
{
    ZeroMemory( &m_cbxst , sizeof( CBXSTATE ) * 3 );
}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InitControl( HWND hCtrl )
{
    int i = GetCBXSTATEindex( hCtrl );

    m_cbxst[ i ].icbxSel = ( int )SendMessage( hCtrl , CB_GETCURSEL , 0 , 0 );

    return TRUE;
}


//-------------------------------------------------------------------------------
// release the parent reference
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ReleaseAbbreviates( )
{
    xxxUnLoadAbbreviate( &tokday[0] );

    xxxUnLoadAbbreviate( &tokhour[0] );

    xxxUnLoadAbbreviate( &tokmin[0] );

    return TRUE;
}



//-------------------------------------------------------------------------------
// OnCommand
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtl , PBOOL pfPersisted )
{
    UNREFERENCED_PARAMETER( wID );

    switch( wNotifyCode )
    {

    case CBN_EDITCHANGE:

        if( OnCBEditChange( hwndCtl ) )
        {
            *pfPersisted = FALSE;
        }

        break;

    case CBN_SELCHANGE:

        if( OnCBNSELCHANGE( hwndCtl ) )
        {
            *pfPersisted = FALSE;
        }


    //case BN_CLICKED:

        break;

    case CBN_DROPDOWN:               // FALLTHROUGH

    case CBN_KILLFOCUS:

        OnCBDropDown( hwndCtl );

        break;

        //return FALSE;
/*
    case ALN_APPLY:

        SendMessage( GetParent( hwndCtl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
        */

    }

    // m_bPersisted = FALSE;
/*
    if( bChange )
    {
        SendMessage( GetParent( GetParent( hwndCtl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtl ) , 0 );
    }
    */

    return FALSE;

}

//-------------------------------------------------------------------------------
// Update the entry if it has been modified by user
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBDropDown( HWND hCombo )
{
    TCHAR tchBuffer[ 80 ];

    ULONG ulTime;

    int i = GetCBXSTATEindex( hCombo );

    if( i < 0 )
    {
        return FALSE;
    }

    if( m_cbxst[ i ].bEdit )
    {
        GetWindowText( hCombo , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );

        if( ParseDurationEntry( tchBuffer , &ulTime ) == E_SUCCESS )
        {
            InsertSortedAndSetCurSel( hCombo , ulTime );
        }

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
// Use this flag to distinguish between hand entry or listbox selection
// setting it to true implies that the use has edit the cbx via typing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBEditChange( HWND hCombo )
{
    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        m_cbxst[ i ].bEdit = TRUE;

        return TRUE;
    }

    return FALSE;
}


//-------------------------------------------------------------------------------
// Determine if user wants to enter a custom time
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::OnCBNSELCHANGE( HWND hwnd )
{
    return SaveChangedSelection( hwnd );
}

//-------------------------------------------------------------------------------
// Saves selected item.
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::SaveChangedSelection( HWND hCombo )
{
    INT_PTR idx = SendMessage( hCombo , CB_GETCURSEL , 0 , 0 );

    int i = GetCBXSTATEindex( hCombo );

    if( i > -1 )
    {
        if( m_cbxst[ i ].icbxSel != idx )
        {
            m_cbxst[ i ].icbxSel = ( int )idx;

            m_cbxst[ i ].bEdit = FALSE;

            return TRUE;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// Restore previous setting
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::RestorePreviousValue( HWND hwnd )
{
    int iSel;

    if( ( iSel = GetCBXSTATEindex( hwnd ) ) > -1 )
    {
        SendMessage( hwnd , CB_SETCURSEL , m_cbxst[ iSel ].icbxSel , 0 );

        return TRUE;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// ConvertToMinutes -- helper for CTimeOutDlg::OnNotify
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToMinutes( HWND hwndCtl , PULONG pulMinutes )
{
    TCHAR tchBuffer[ 80 ];

    TCHAR tchErrTitle[ 80 ];

    TCHAR tchErrMsg[ 256 ];

    TCHAR tchSetting[ 80 ];

    int idx = GetCBXSTATEindex( hwndCtl );

    if( idx < 0 )
    {
        return FALSE;
    }

    ASSERT( idx <= 2 );

    int resID = -1;

    if( idx == 0 )
    {
        resID = IDS_COMBO_CONNECTION;
    }
    else if( idx == 1 )
    {
        resID = IDS_COMBO_DISCONNECTION;
    }
    else if( idx == 2 )
    {
        resID = IDS_COMBO_IDLECONNECTION;
    }

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , resID , tchSetting , SIZE_OF_BUFFER( tchSetting ) ) );

    ULONG_PTR dw = ( ULONG_PTR )&tchSetting[ 0 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TITLE , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

    if( m_cbxst[ idx ].bEdit )
    {
        DBGMSG( L"Automatic %s parsing\n" , tchSetting );

        if( GetWindowText( hwndCtl , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) < 1 )
        {
            *pulMinutes = 0;

            return TRUE;
        }

        LRESULT lr = ParseDurationEntry( tchBuffer , pulMinutes );

        if( lr != E_SUCCESS )
        {
            if( lr == E_PARSE_VALUEOVERFLOW )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_TOOMANYDIGITS , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

                MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            else if( lr == E_PARSE_MISSING_DIGITS || lr == E_PARSE_INVALID )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_PARSEINVALID , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

                FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

                MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

                SetFocus( hwndCtl );
            }
            return FALSE;
        }
    }
    else
    {
        ODS( L"Getting current selection\n" );

        INT_PTR iCurSel = SendMessage( hwndCtl , CB_GETCURSEL , 0 , 0 );

        // See if user wants "No Timeout"

        if( iCurSel == 0 )
        {
            *pulMinutes = 0;

           return TRUE;
        }

        if( ( *pulMinutes = ( ULONG )SendMessage( hwndCtl , CB_GETITEMDATA , iCurSel , 0 ) ) == CB_ERR  )
        {
            *pulMinutes = 0;
        }
    }

    if( *pulMinutes > kMaxTimeoutMinute )
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_ERROR_MAXVALEXCEEDED , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) );

        FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchErrMsg , 0 , 0 , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) , ( va_list * )&dw );

        MessageBox( hwndCtl , tchErrMsg , tchErrTitle , MB_OK | MB_ICONERROR );

        SetFocus( hwndCtl );

        return FALSE;
    }

    *pulMinutes *= kMilliMinute;

    return TRUE;
}

#if 0
//-------------------------------------------------------------------------------
// Lets cut to the chase and find out if this is even worth parsing
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( iswdigit( *pszString ) )
        {
            return TRUE;
        }

        pszString++;
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    float fFrac = 0.0f;

    float fT;

    UINT uPos = 1;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , SIZE_OF_BUFFER( tchNoTimeout ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        *pTime = 0;

        return E_SUCCESS;
    }

    if( !DoesContainDigits( pszTime ) )
    {
        return E_PARSE_MISSING_DIGITS;
    }

    while( *pszTemp )
    {
        if( !iswdigit( *pszTemp ) )
        {
            break;
        }

        // check for overflow

        if( uDec >= 1000000000 )
        {
            return E_PARSE_VALUEOVERFLOW ;
        }

        uDec *= 10;

        uDec += ( *pszTemp - '0' );

        pszTemp++;

    }

    TCHAR tchSDecimal[ 5 ];

    GetLocaleInfo( LOCALE_USER_DEFAULT , LOCALE_SDECIMAL , tchSDecimal , SIZE_OF_BUFFER( tchSDecimal ) );

    if( *pszTemp == *tchSDecimal )
    {
        pszTemp++;

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW;
            }

            uPos *= 10;

            fFrac += ( float )( *pszTemp - '0' ) / ( float )uPos;

            pszTemp++;
        }
    }

    // remove white space

    while( *pszTemp == L' ' )
    {
        pszTemp++;
    }


    if( *pszTemp != NULL )
    {
        if( IsToken( pszTemp , TOKEN_DAY ) )
        {
            *pTime = uDec * 24 * 60;

            fT = ( fFrac * 24.0f * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_HOUR ) )
        {
            *pTime = uDec * 60;

            fT = ( fFrac * 60.0f + 0.5f );

            *pTime += ( ULONG )fT;

            return E_SUCCESS;
        }
        else if( IsToken( pszTemp , TOKEN_MINUTE ) )
        {
            // minutes are rounded up in the 1/10 place

            fT = fFrac + 0.5f;

            *pTime = uDec;

            *pTime += ( ULONG )( fT );

            return E_SUCCESS;

        }

    }

    if( *pszTemp == NULL )
    {

        // if no text is defined considered the entry in hours

        *pTime = uDec * 60;

         fT = ( fFrac * 60.0f + 0.5f );

        *pTime += ( ULONG )fT ;

        return E_SUCCESS;
    }


    return E_PARSE_INVALID;

}

#endif


//-------------------------------------------------------------------------------
// Adds strings to table from resource
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::LoadAbbreviates( )
{
    xxxLoadAbbreviate( &tokday[0] );

    xxxLoadAbbreviate( &tokhour[0] );

    xxxLoadAbbreviate( &tokmin[0] );

    return TRUE;
}

//-------------------------------------------------------------------------------
// Take cares some repetitive work for us
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxLoadAbbreviate( PTOKTABLE ptoktbl )
{
    int idx;

    int nSize;

    TCHAR tchbuffer[ 80 ];

    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        nSize = LoadString( _Module.GetResourceInstance( ) , ptoktbl[ idx ].dwresourceid , tchbuffer , SIZE_OF_BUFFER( tchbuffer ) );

        if( nSize > 0 )
        {
            ptoktbl[ idx ].pszAbbrv = ( TCHAR *)new TCHAR[ nSize + 1 ];

            if( ptoktbl[ idx ].pszAbbrv != NULL )
            {
                lstrcpy( ptoktbl[ idx ].pszAbbrv , tchbuffer );
            }
        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Frees up allocated resources
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::xxxUnLoadAbbreviate( PTOKTABLE ptoktbl )
{
    if( ptoktbl == NULL )
    {
        return FALSE;
    }

    for( int idx = 0; ptoktbl[ idx ].dwresourceid != ( DWORD )-1 ; ++idx )
    {
        if( ptoktbl[ idx ].pszAbbrv != NULL )
        {
            delete[] ptoktbl[ idx ].pszAbbrv;

        }
    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// tear-off token tables
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::IsToken( LPTSTR pszString , TOKEN tok )
{
    TOKTABLE *ptoktable;

    if( tok == TOKEN_DAY )
    {
        ptoktable = &tokday[0];
    }
    else if( tok == TOKEN_HOUR )
    {
        ptoktable = &tokhour[0];
    }
    else if( tok == TOKEN_MINUTE )
    {
        ptoktable = &tokmin[0];
    }
    else
    {
        return FALSE;
    }


    for( int idx = 0 ; ptoktable[ idx ].dwresourceid != -1 ; ++idx )
    {
        if( lstrcmpi( pszString , ptoktable[ idx ].pszAbbrv ) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;

}

#if 0
//-------------------------------------------------------------------------------
// Converts the number minutes into a formated string
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
    ULONG_PTR dw[3];

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    // ASSERT( ulTime != 0 );

    int iHour= ulTime / 60;

    int iDays = iHour / 24;

    dw[ 2 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

    LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_DOT_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

    if( iDays != 0 )
    {
        int iRemainingHours = iHour % 24;

        float fx = ( float )iRemainingHours / 24.0f;

        iRemainingHours = ( int )( fx * 10 );

        LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        dw[ 0 ] = iDays;

        dw[ 1 ] = iRemainingHours;

        if( iRemainingHours == 0 )
        {
            // formatted string requires two arguments

            dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

            if( iDays == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
            }
        }

    }

    else if( iHour != 0 )
    {
        int iRemainingMinutes = ulTime % 60;

        float fx = ( float )iRemainingMinutes / 60.0f;

        iRemainingMinutes = ( int ) ( fx * 10 );

        dw[ 0 ] = iHour;

        dw[ 1 ] = iRemainingMinutes;

        LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        if( iRemainingMinutes == 0 )
        {
            dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

            LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

            if( iHour == 1 )
            {
                LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
            }
        }
    }
    else
    {
        LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );

        LoadString( _Module.GetResourceInstance( ) , IDS_DIGIT_TU , tchTimeFormat , SIZE_OF_BUFFER( tchTimeFormat ) );

        dw[ 0 ] = ulTime ;

        dw[ 1 ] = ( ULONG_PTR )&tchTimeUnit[ 0 ];

        if( ulTime > 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
    }

    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, tchTimeFormat , 0 , 0 , tchOutput , SIZE_OF_BUFFER( tchOutput ) , ( va_list * )&dw );

    lstrcpy( pszDuration , tchOutput );

    return TRUE;
}

#endif

//-------------------------------------------------------------------------------
// Place entry in listbox and set as current selection
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::InsertSortedAndSetCurSel( HWND hCombo , DWORD dwMinutes )
{
    // ASSERT( dwMinutes != ( DWORD )-1 );

    TCHAR tchBuffer[ 80 ];

    INT_PTR iCount = SendMessage( hCombo , CB_GETCOUNT , 0 , 0 );

    for( INT_PTR idx = 0 ; idx < iCount ; ++idx )
    {
        // Don't insert an item that's already in the list

        if( dwMinutes == ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;

            return TRUE;
        }

        if( dwMinutes < ( DWORD )SendMessage( hCombo , CB_GETITEMDATA , idx , 0 ) )
        {
            break;
        }
    }

    // hey if the value has exceeded the max timeout don't bother entering it in our list

    if( dwMinutes > kMaxTimeoutMinute )
    {
        return FALSE;
    }

    if( ConvertToDuration ( dwMinutes , tchBuffer ) )
    {
        idx = SendMessage( hCombo , CB_INSERTSTRING , idx , ( LPARAM )&tchBuffer[ 0 ] );

        if( idx != CB_ERR )
        {
            SendMessage( hCombo , CB_SETITEMDATA , idx , dwMinutes );

        }

        SendMessage( hCombo , CB_SETCURSEL , idx , 0 ) ;
    }

    // must call this here because CB_SETCURSEL does not send CBN_SELCHANGE

    SaveChangedSelection( hCombo );

    return TRUE;
}


/* Modified settings for a more readable time out settings
 * added 1/25/99
 * alhen
*/

//-------------------------------------------------------------------------------
// Removing decimal entries
//-------------------------------------------------------------------------------
LRESULT CTimeOutDlg::ParseDurationEntry( LPTSTR pszTime , PULONG pTime )
{
    TCHAR tchNoTimeout[ 80 ];

    LPTSTR pszTemp = pszTime;

    UINT uDec = 0;

    BOOL bSetDay  = FALSE;
    BOOL bSetHour = FALSE;
    BOOL bSetMin  = FALSE;
    BOOL bEOL     = FALSE;
    BOOL bHasDigit= FALSE;

    *pTime = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchNoTimeout , SIZE_OF_BUFFER( tchNoTimeout ) );

    if( lstrcmpi( pszTime , tchNoTimeout ) == 0 )
    {
        // *pTime = 0;

        return E_SUCCESS;
    }

    while( !bEOL )
    {
        // remove leading white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        while( *pszTemp )
        {
            if( !iswdigit( *pszTemp ) )
            {
                if( !bHasDigit )
                {
                    return E_PARSE_MISSING_DIGITS;
                }

                break;
            }

            // check for overflow

            if( uDec >= 1000000000 )
            {
                return E_PARSE_VALUEOVERFLOW ;
            }

            uDec *= 10;

            uDec += ( *pszTemp - '0' );

            if( !bHasDigit )
            {
                bHasDigit = TRUE;
            }

            pszTemp++;
        }

        // remove intermediate white spaces

        while( *pszTemp == L' ' )
        {
            pszTemp++;
        }

        if( *pszTemp != NULL )
        {
            // Get next token

            TCHAR tchToken[ 80 ];

            pszTemp = GetNextToken( pszTemp , tchToken );


            if( IsToken( tchToken , TOKEN_DAY ) )
            {
                if( !bSetDay )
                {
                    *pTime += uDec * 1440;

                    bSetDay = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_HOUR ) )
            {
                if( !bSetHour )
                {
                    *pTime += uDec * 60;

                    bSetHour = TRUE;
                }

            }
            else if( IsToken( tchToken , TOKEN_MINUTE ) )
            {
                if( !bSetMin )
                {
                    *pTime += uDec;

                    bSetMin = TRUE;
                }

            }
            else
            {
                return E_PARSE_INVALID;
            }

        }
        else
        {
            if( !bSetHour )
            {
                *pTime += uDec * 60;
            }

            bEOL = TRUE;
        }

        uDec = 0;

        bHasDigit = FALSE;

    }

    return E_SUCCESS;
}

//-------------------------------------------------------------------------------
// replacing older api
//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::ConvertToDuration( ULONG ulTime , LPTSTR pszDuration )
{
//    TCHAR dw[] = L"dhm";

    TCHAR tchTimeUnit[ 40 ];

    TCHAR tchTimeFormat[ 40 ];

    TCHAR tchOutput[ 80 ];

    ASSERT( ulTime != 0 );

    int iHour = ( ulTime / 60 );

    int iDays = iHour / 24;

    int iMinute = ulTime % 60;

    // Resolve format

    tchOutput[0] = 0;


    if( iDays > 0 )
    {
        if( iDays == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAY , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_DAYS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        iHour = iHour % 24;

        wsprintf( tchTimeFormat , L"%d %s", iDays , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iHour > 0 )
    {
        if( iHour == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOUR , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_HOURS , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iHour , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    if( iMinute > 0 )
    {
        if( iMinute == 1 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTE , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }
        else
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_MINUTES , tchTimeUnit , SIZE_OF_BUFFER( tchTimeUnit ) );
        }

        wsprintf( tchTimeFormat , L"%d %s", iMinute , tchTimeUnit );

        lstrcat( tchOutput , tchTimeFormat );

        lstrcat( tchOutput , L" " );
    }

    lstrcpy( pszDuration , tchOutput );

    return TRUE;

}

//-------------------------------------------------------------------------------
BOOL CTimeOutDlg::DoesContainDigits( LPTSTR pszString )
{
    while( *pszString )
    {
        if( *pszString != L' ')
        {
            if( iswdigit( *pszString ) )
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }

            pszString++;
        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
TCHAR * GetNextToken( TCHAR *pszString , TCHAR *tchToken )
{
    while( *pszString )
    {
        if( IsCharAlpha( *pszString ) )
        {
            *tchToken = *pszString;
        }
        else
        {
            break;
        }

        tchToken++;

        pszString++;
    }

    *tchToken = '\0';

    return pszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\twiz.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TWIZ_H
#define _TWIZ_H

#include "baswdlg.h"
#include "todlg.h"
#include "asyncdlg.h"

class CCompdata;

//-----------------------------------------------------------------------------
class CWelcome : public CDialogWizBase
{
    HFONT m_hFont;

public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};



//-----------------------------------------------------------------------------
class CConType : public CDialogWizBase
{
    CCompdata *m_pCompdata;

    int m_iOldSelection;
    
public:
    
    CConType( CCompdata * );
    
    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    BOOL OnDestroy( );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL SetConType( HWND );

    BOOL AddEntriesToConType( HWND );

};

//-----------------------------------------------------------------------------
class CLan : public CDialogWizBase
{
    CCompdata *m_pCompdata;

public:

    CLan( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

//-----------------------------------------------------------------------------
class CSecurity : public CDialogWizBase
{
    CCompdata *m_pCompdata;

    Encryption *m_pEncrypt;

	DWORD m_DefaultEncryptionLevelIndex;

public:

    CSecurity( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};

//-----------------------------------------------------------------------------
#if 0  // objects not used in connection wizard
class CTimeout : public CDialogWizBase , public CTimeOutDlg
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCBXSTATEindex( HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

//-----------------------------------------------------------------------------
class CAutoLogon : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL ConfirmPwd( HWND );
};


//-----------------------------------------------------------------------------
class CInitProg : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};
#endif 

//-----------------------------------------------------------------------------
class CRemotectrl : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL OnNotify( int , LPNMHDR , HWND );
};

#if 0
//-----------------------------------------------------------------------------
class CWallPaper : public CDialogWizBase
{
public:

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );
    
    BOOL OnNotify( int , LPNMHDR , HWND );
};
#endif

//-----------------------------------------------------------------------------
class CConProp : public CDialogWizBase , public IWizardProvider
{
    CCompdata *m_pCompdata;

    CArrayT< HPROPSHEETPAGE > m_hOtherPages;

    UINT m_cRef;

    INT_PTR m_iOldSel;


public:

    CConProp( CCompdata * );

    STDMETHOD( QueryInterface )( REFIID , LPVOID * );

    STDMETHOD_( ULONG , AddRef )( );

    STDMETHOD_( ULONG , Release )( );

    STDMETHOD( AddPage )( HPROPSHEETPAGE );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL RemovePages( HWND );

    BOOL AddPages( HWND , int , LPTSTR );

    BOOL InsertThirdPartyPages( LPTSTR );
};

//-----------------------------------------------------------------------------
class CAsync : public CAsyncDlg , public CDialogWizBase
{
    CCompdata * m_pCompdata;
      
public:

    CAsync( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnCommand( WORD , WORD , HWND );
};

//-----------------------------------------------------------------------------
class CFin : public CDialogWizBase
{
    CCompdata * m_pCompdata;

    HFONT m_hFont;

public:

    CFin( CCompdata * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL OnDestroy( );
};



#endif // _TWIZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\tsprsht.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#ifndef _TSPRSHT_H
#define _TSPRSHT_H

#include"baspdlg.h"
#include"todlg.h"
#include<mmc.h>
#include"rnodes.h"
// #include<objsel.h>
#include<commctrl.h>
// #include<winsta.h>
#include<aclui.h>
#include "asyncdlg.h"

#define NUM_OF_PRSHT 8

class CPropsheet
{
    int m_cref;

    LONG_PTR m_hNotify;

    CDialogPropBase *m_pDlg[ NUM_OF_PRSHT ];

    BOOL m_bGotUC;

    PUSERCONFIG m_puc;

    HWND m_hMMCWindow;

public:

    CPropsheet( );

    int AddRef( );

    int Release( );

    HRESULT InitDialogs( HWND , LPPROPERTYSHEETCALLBACK , CResultNode * , LONG_PTR );

    HRESULT SetUserConfig( USERCONFIG&  , PDWORD );

    BOOL ExcludeMachinePolicySettings(USERCONFIG& uc);

    BOOL GetUserConfig( BOOLEAN bPerformMerger );

    BOOL GetCurrentUserConfig( USERCONFIG&, BOOLEAN bPerformMerger );
    
    CResultNode *m_pResNode;

    void PreDestruct( );

    BOOL m_bPropertiesChange;

};

HPROPSHEETPAGE GetSecurityPropertyPage( CPropsheet * );

//-----------------------------------------------------------------------------
class CGeneral : public CDialogPropBase
{
    CPropsheet *m_pParent;

    Encryption *m_pEncrypt;

    DWORD m_DefaultEncryptionLevelIndex;

    INT_PTR m_nOldSel;

public:

    CGeneral( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND );

};

//-----------------------------------------------------------------------------
class CLogonSetting : public CDialogPropBase
{
    CPropsheet *m_pParent;

    WORD m_wOldId;

public:

    CLogonSetting( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND );

    BOOL IsValidSettings( HWND );

    BOOL ConfirmPassWd( HWND );

};

//-----------------------------------------------------------------------------
class CTimeSetting : public CDialogPropBase , public CTimeOutDlg
{
    CPropsheet *m_pParent;

    WORD m_wOldAction;

    WORD m_wOldCon;

	BOOL m_bPrevClient;

public:

    CTimeSetting( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    int GetCBXSTATEindex( HWND );

    void SetTimeoutControls(HWND);

    void SetBkResetControls(HWND);

    void SetReconControls(HWND);

    //void xxxSetControls( HWND , BOOL , int );

    BOOL IsValidSettings( HWND );

    BOOL PersistSettings( HWND );

    
};

/*-----------------------------------------------------------------------------
typedef struct _securedentry
{
    PSID psid;

    ACCESS_MASK amAllowed;

    ACCESS_MASK amDenied;

    TCHAR tchDisplayName[ 260 ];

    TCHAR tchADSPath[ 260 ];

    TCHAR tchType[ 20 ];

} SECUREDENTRY , * PSECUREDENTRY;

//-----------------------------------------------------------------------------
typedef struct _namedentry
{
    TCHAR tchNamedEntry[ 260 ];

    DWORD dwAcepos;

} NAMEDENTRY , * PNAMEDENTRY;

//-----------------------------------------------------------------------------
class CPerm : public CDialogPropBase
{
    CPropsheet *m_pParent;

    HWND m_lvUserGroups;

    HWND m_clPerms;

    HIMAGELIST m_hImglist;

    int m_iLastSelectedItem;

    LPBYTE m_pNE; // named entry blob

    int m_nNE;

public:

    CPerm( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL AddGroupUser( HWND );

    BOOL InsertSelectedItemsInList( HWND , PDSSELECTIONLIST );

    BOOL InitPriviledges( );

    BOOL InitImageList( );

    int GetObjectTypeIcon( LPTSTR );

    BOOL InitSecurityDialog( );

    BOOL ConvertSDtoEntries( PSECURITY_DESCRIPTOR  );

    BOOL ReleaseEntries( );

    BOOL SidToStr( PSID , LPTSTR );

    BOOL ItemDuplicate( PSID );

    BOOL OnNotify( int , LPNMHDR , HWND );

    BOOL GetMask( PDWORD , PDWORD );

    BOOL SetMask( DWORD , DWORD );

    BOOL PersistSettings( HWND ); 

    BOOL ConvertEntriesToSD( PSECURITY_DESCRIPTOR , PSECURITY_DESCRIPTOR * );

    BOOL RemoveGroupUser( HWND );

    BOOL RemoveNamedEntries( );

    BOOL AssembleNamedEntries( );

    BOOL FindNamedEntryAcePos( DWORD  , PSECUREDENTRY );

}; */

//-----------------------------------------------------------------------------
class CEnviro : public CDialogPropBase
{
    CPropsheet *m_pParent;

public:

    CEnviro( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 

};

//-----------------------------------------------------------------------------
class CRemote : public CDialogPropBase
{
    CPropsheet *m_pParent;

    WORD m_wOldRadioID;

    WORD m_wOldSel;

public:

    CRemote( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 
};

//-----------------------------------------------------------------------------
class CClient : public CDialogPropBase
{
    public:

        CClient( CPropsheet * );

        BOOL OnInitDialog( HWND , WPARAM , LPARAM );

        static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

        BOOL GetPropertySheetPage( PROPSHEETPAGE& );

        BOOL OnDestroy( );

        BOOL OnCommand( WORD , WORD , HWND );

        BOOL PersistSettings( HWND ); 

    private:

        void DetermineFieldEnabling(HWND hDlg);
        void SetColorDepthEntry( HWND );

        CPropsheet *m_pParent;

	    INT_PTR m_nColorDepth;
};

//-----------------------------------------------------------------------------
class CSecurityPage : public ISecurityInformation, public CComObjectRoot
{

    DECLARE_NOT_AGGREGATABLE( CSecurityPage )
    BEGIN_COM_MAP( CSecurityPage )
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

public:
    
    CSecurityPage():m_pOriginalSD(NULL),m_pWorldSid(NULL) {};
    ~CSecurityPage()
    { 
        if(m_pOriginalSD)
        {
            delete m_pOriginalSD;
        }
    }

    // *** ISecurityInformation methods ***

    STDMETHOD( GetObjectInformation )( PSI_OBJECT_INFO );

    STDMETHOD( GetSecurity )( SECURITY_INFORMATION , PSECURITY_DESCRIPTOR *, BOOL );

    STDMETHOD( SetSecurity )( SECURITY_INFORMATION , PSECURITY_DESCRIPTOR );
  
    STDMETHOD( GetAccessRights )( const GUID * , DWORD , PSI_ACCESS * , PULONG , PULONG );

    STDMETHOD( MapGeneric )( const GUID *, PUCHAR , ACCESS_MASK * );
  
    STDMETHOD( GetInheritTypes )( PSI_INHERIT_TYPE  * , PULONG );
  
    STDMETHOD( PropertySheetPageCallback )( HWND , UINT , SI_PAGE_TYPE );

    void SetParent( CPropsheet *  );
        
private:

    TCHAR m_szPageName[ 80 ];

    CPropsheet * m_pParent;

    BOOLEAN     m_WritablePermissionsTab;

    PSECURITY_DESCRIPTOR m_pOriginalSD;
    PSID m_pWorldSid;

    void MakeLocalSDCopy( PSECURITY_DESCRIPTOR pSecurityDescriptor );
    void UpdateTSLogonRight(PWINSTATIONNAMEW pWSName, PSECURITY_DESCRIPTOR pSecurityDescriptor );
    BOOL GetChangedUsers(PSECURITY_DESCRIPTOR pSecurityDescriptor, 
                     PSID *&ppLogonAllowSIDs, PSID *&ppLogonDenySIDs,
                     LPDWORD pcLogonAllowSIDs, LPDWORD pcLogonDenySIDs);
    BOOL UserHasLogonPermission(PACL pDacl, PSID pSid);
    BOOL UserHasLogonPermission(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pSid);
    BOOL GetUsersWhoAlreadyHasTSLogonRight(PSID *&ppLogonRightSIDs, LPDWORD pcLogonRightSIDs);
    BOOL GrantRightToUser( PSID pSID );
    BOOL RevokeRightFromUser( PSID pSID );
    BOOL CanRevokeRight( PWINSTATIONNAMEW pWSName, PSID pSID );
    BOOL SetPrivilegeInAccessToken(LPCTSTR PrivilegeName, DWORD dwAttributes);
};

//-----------------------------------------------------------------------------
class CTransNetwork : public CDialogPropBase
{
      CPropsheet *m_pParent;

      ULONG m_ulOldLanAdapter;

      WORD m_oldID;

      ULONG m_uMaxInstOld;

      BOOL m_RemoteAdminMode;

public:

    CTransNetwork( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    BOOL PersistSettings( HWND ); 

    BOOL IsValidSettings( HWND );

};


//-----------------------------------------------------------------------------
class CTransAsync : public CAsyncDlg , public CDialogPropBase
{
      CPropsheet *m_pParent;

public:
    BOOL IsValidSettings(HWND);

    CTransAsync( CPropsheet * );

    BOOL OnInitDialog( HWND , WPARAM , LPARAM );

    static INT_PTR CALLBACK DlgProc( HWND , UINT , WPARAM , LPARAM );

    BOOL GetPropertySheetPage( PROPSHEETPAGE& );

    BOOL OnDestroy( );

    BOOL OnCommand( WORD , WORD , HWND );

    void SetControls( HWND , BOOL );

    BOOL PersistSettings( HWND ); 
};



BOOL InitStrings( );

BOOL FreeStrings( );


//-----------------------------------------------------------------------------
#endif // _TSPRSHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tskill\tskill.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/***********************************************************************
*
*  TSKILL.H
*     This module contains typedefs and defines required for
*     the TSKILL utility.
*
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be
#define MAXNAME 18

/*
 * Resource string IDs
 */
#define IDS_ERROR_MALLOC                                100
#define IDS_ERROR_INVALID_PARAMETERS                    101
#define IDS_ERROR_BAD_PID_NUMBER                        102
#define IDS_ERROR_KILL_PROCESS_FAILED                   103
#define IDS_ERROR_SERVER                                104
#define IDS_ERROR_BAD_PROCESS                           201

#define IDS_KILL_PROCESS                                200
#define IDS_ERROR_ID_ABSENT                             202
#define IDS_ERROR_ENUM_PROCESS                          203
#define IDS_USAGE1                                      204
#define IDS_USAGE2                                      205
#define IDS_USAGE3                                      206
#define IDS_USAGE4                                      207
#define IDS_USAGE5                                      208
#define IDS_USAGE6                                      209
#define IDS_USAGE7                                      210
#define IDS_USAGE8                                      211
#define IDS_USAGE9                                      212
#define IDS_USAGEA                                      213
#define IDS_ERROR_NOT_TS                                214
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\twiz.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "tscc.h"
#include "tscfgex.h"
#include "compdata.h"
#include "resource.h"
#include "winsta.h"
#include "commctrl.h"

//#include "asyncdlg.h"

static USERCONFIG g_uc;

static ASYNCCONFIG g_ac;

static WS g_ws;

static TCHAR tchThirdPartyPath[] = TEXT("Software\\Microsoft\\Tscc\\");

void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable );

static int g_nAsyncOrNetwork;

extern void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

extern void TscAccessDeniedMsg( HWND hwnd );

extern void TscGeneralErrMsg( HWND hwnd );

extern BOOL IsValidConnectionName( LPTSTR szConName , PDWORD );

static BOOL g_bConnectionTypeChanged_forEncryption = FALSE;

static BOOL g_bConnectionTypeChanged_forConProps = FALSE;

LPEXTENDTSWIZARD g_pObj;

//-----------------------------------------------------------------------------
BOOL CDialogWizBase::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_NEXT | PSWIZB_BACK );
    }

    return TRUE;
}


//***********************************************************************************
//                      Welcome Dialog

//-----------------------------------------------------------------------------
BOOL CWelcome::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );

    UNREFERENCED_PARAMETER( lp );

    ODS( L"TSCC-WIZ welcome\n" );

    LOGFONT lgfn;

    int iFontSize;

    TCHAR szFontSize[16];

    ZeroMemory( &lgfn , sizeof( LOGFONT ) );

    LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTSIZE , szFontSize , SIZE_OF_BUFFER(szFontSize) );

    iFontSize = _ttoi( szFontSize );

    HDC hdc = ::GetDC( NULL );

    if( hdc != NULL )
    {
        lgfn.lfHeight = MulDiv( -iFontSize , GetDeviceCaps(hdc , LOGPIXELSY), 72);

        LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTNAME , lgfn.lfFaceName , SIZE_OF_BUFFER(lgfn.lfFaceName) );

        m_hFont = CreateFontIndirect( &lgfn );

        ASSERT( m_hFont != NULL ); // let me know if we got it or not

        SendMessage( GetDlgItem( hwnd , IDC_STATIC_WELCOME ) , WM_SETFONT , ( WPARAM )m_hFont , MAKELPARAM( TRUE , 0 ) );

        g_nAsyncOrNetwork = 0;

        ReleaseDC( NULL , hdc );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CWelcome::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CWelcome *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CWelcome *pDlg = ( CWelcome * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CWelcome ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CWelcome * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CWelcome ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWelcome::OnDestroy( )
{
    DeleteObject( m_hFont );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CWelcome::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_HIDEHEADER | PSP_USETITLE ;

    psp.pszTitle    = MAKEINTRESOURCE( IDS_WIZARDTITLE );

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_WELCOME );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CWelcome::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_WELCOMEHEADER );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_WELCOMESUBHEADER );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CWelcome::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_NEXT );
    }

    return TRUE;
}

//***********************************************************************************
//                    Connection Type Dialog
// Determines the path the wizard will take in configuring the connection

//-----------------------------------------------------------------------------
CConType::CConType(  CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_iOldSelection = -1;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CConType::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CConType *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CConType *pDlg = ( CConType * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CConType ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CConType * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CConType ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );
    //
    // Obtain a list of entries for the contype
    // if not RDP remove the last two entries on the list

    AddEntriesToConType( hwnd );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnNotify( int idCtrl, LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        SetConType( hDlg );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );

}

//-----------------------------------------------------------------------------
// Place entries in connection type combx
//-----------------------------------------------------------------------------
BOOL CConType::AddEntriesToConType( HWND hDlg )
{
    HWND hCtrl = GetDlgItem( hDlg , IDC_COMBO_WIZ_CONTYPE );

    ICfgComp *pCfgcomp = NULL;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    WDNAMEW *wszWdname = NULL;

    BOOL ret = FALSE;


    if( !IsWindow( hCtrl ) )
    {
        return ret;
    }

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        return ret;
    }

    if( SUCCEEDED( pCfgcomp->GetWdTypeList( &ulItems , &cbSize , ( WCHAR ** )&wszWdname ) ) )
    {
        for( ULONG i = 0; i < ulItems ; i++ )
        {
            SendMessage( hCtrl , CB_ADDSTRING , 0 , ( LPARAM )&wszWdname[ i ] );
        }

        CoTaskMemFree( wszWdname );

        SendMessage( hCtrl , CB_SETCURSEL , 0 , 0 );

        ret = TRUE;
    }
    else
    {
        ODS( L"GetWdTypeList -- failed\n" );

        ret = FALSE;
    }

    pCfgcomp->Release( );

    return ret;
}

//-----------------------------------------------------------------------------
BOOL CConType::SetConType( HWND hwnd )
{
    // PROPSHEETPAGE psp;

    TCHAR tchWdName[ WDNAME_LENGTH + 1 ];

    INT_PTR idx = SendMessage( GetDlgItem( hwnd , IDC_COMBO_WIZ_CONTYPE ) , CB_GETCURSEL , 0 , 0 );

    if( idx == CB_ERR )
    {
        return FALSE;
    }

    if( idx != m_iOldSelection )
    {
        g_bConnectionTypeChanged_forEncryption = TRUE;

        g_bConnectionTypeChanged_forConProps = TRUE;

        m_iOldSelection = (INT)idx;
    }

    SendMessage( GetDlgItem( hwnd , IDC_COMBO_WIZ_CONTYPE ) , CB_GETLBTEXT , idx , ( LPARAM )tchWdName );

    lstrcpy( g_ws.wdName , tchWdName );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConType::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_CONNECTION_TYPE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CConType::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_CONTYPE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_CONTYPE );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConType::OnDestroy( )
{
    // m_hOtherPages.DeleteArray( );

    return CDialogWizBase::OnDestroy( );
}

//***********************************************************************************
//                  Network Lan adapters

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CLan::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLan *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CLan *pDlg = ( CLan * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CLan ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CLan * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CLan ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
CLan::CLan( CCompdata *pCompdata )
{
   m_pCompdata = pCompdata;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    // DEVICENAMEW *pdnw = NULL;

    PGUIDTBL pGuidtbl = NULL;

    ICfgComp *pCfgcomp = NULL;

    // ULONG cbSize = 0;

    ULONG ulItems = 0;

    SendMessage( GetDlgItem( hDlg , IDC_SPIN_WZ ) , UDM_SETRANGE32 , 0 , ( LPARAM )999999 );

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"CLan::OnInitDialog GetServer failed\n" );

        return FALSE;
    }

    if( SUCCEEDED( pCfgcomp->GetLanAdapterList2( g_ws.pdName , &ulItems , &pGuidtbl ) ) )
    {
        for( ULONG i = 0 ; i < ulItems ; i++ )
        {
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_ADDSTRING , 0 , ( LPARAM )pGuidtbl[ i ].DispName );

            SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETITEMDATA , ( WPARAM )i , ( LPARAM )pGuidtbl[ i ].dwLana );
        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETCURSEL , 0 , 0 );

        pCfgcomp->BuildGuidTable( &pGuidtbl , ulItems , g_ws.pdName  );

        CoTaskMemFree( pGuidtbl );
    }


    // LanAdapter list requires protocol type
    /*

    if( SUCCEEDED( pCfgcomp->GetLanAdapterList( g_ws.pdName , &ulItems , &cbSize , ( WCHAR ** )&pdnw ) ) )
    {
        for( ULONG i = 0 ; i < ulItems ; i++ )
        {
            if( pdnw[ i ] != NULL )
            {
                SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_ADDSTRING , 0 , ( LPARAM )pdnw[ i ] );
            }
        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_SETCURSEL , 0 , 0 );

        CoTaskMemFree( pdnw );
    }
    */

    pCfgcomp->Release( );


    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ) , BM_CLICK , 0 , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LAN_MAXCONS ) , EM_SETLIMITTEXT , ( WPARAM )6 , 0 );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED)
    {
        if(wID == IDC_CHECK_LAN_UNLIMITEDCON )
        {
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPIN_WZ ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_MAXCON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
        }

        else if(wID == IDC_RADIO_MAXCON)
        {

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPIN_WZ ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LAN_UNLIMITEDCON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

            SetFocus( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) );

            SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_LAN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

		}

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLan::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ), BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            UINT uMax;

            BOOL bOK = FALSE;

            uMax = GetDlgItemInt( hDlg , IDC_EDIT_LAN_MAXCONS , &bOK , FALSE );

            if( !bOK  || uMax > 999999UL )
            {
                ErrMessage( hDlg , IDS_ERR_CONREADFAIL );

                //MessageBox( hDlg , L"Maximum number of connections allowed is 999,999" , L"Error" , MB_OK|MB_ICONERROR );

                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }
        // check for unique lanadapter

        ICfgComp *pCfgcomp;

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_GETCURSEL , 0 , 0 );

        BOOL bUnique = FALSE;

        if( iSel != CB_ERR )
        {
            g_ws.LanAdapter = ( DWORD )SendMessage( GetDlgItem( hDlg , IDC_COMBO_LAN_ADAPTERS ) , CB_GETITEMDATA , ( WPARAM )iSel , 0 );


            if( SUCCEEDED( pCfgcomp->IsNetWorkConnectionUnique( g_ws.wdName , g_ws.pdName , ( ULONG )g_ws.LanAdapter , &bUnique ) ) )
            {
                if( !bUnique )
                {
                    TCHAR tchMessage[256];

                    TCHAR tchWarn[40];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_UNIQUECON , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                    MessageBox( hDlg , tchMessage , tchWarn , MB_ICONINFORMATION | MB_OK );

                    SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                    pCfgcomp->Release( );

                    return TRUE;
                }
            }
        }

        g_ws.PdClass = SdNetwork;

        pCfgcomp->Release( );


        //g_ws.LanAdapter = ( ULONG )iSel;

        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LAN_UNLIMITEDCON ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            g_ws.uMaxInstanceCount = ( ULONG )-1;
        }
        else
        {
            g_ws.uMaxInstanceCount = GetDlgItemInt( hDlg , IDC_EDIT_LAN_MAXCONS , &bUnique , FALSE );

        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}
//-----------------------------------------------------------------------------
BOOL CLan::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_LAN );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CLan::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_LAN );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_LAN );

    return TRUE;
}

//***********************************************************************************
//                      Security dialog -- MSGina or your gina


//-----------------------------------------------------------------------------
CSecurity::CSecurity( CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_pEncrypt = NULL;

    m_DefaultEncryptionLevelIndex = 0;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CSecurity::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CSecurity *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CSecurity *pDlg = ( CSecurity * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CSecurity ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CSecurity * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CSecurity ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;



    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;


    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnDestroy( )
{
    if( m_pEncrypt != NULL )
    {
        CoTaskMemFree( m_pEncrypt );
    }

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{

    if( wNotifyCode == CBN_SELCHANGE && wID == IDC_COMBO_ENCRYPT_LVL )
    {
        if( SendMessage( hwndCtrl , CB_GETDROPPEDSTATE , 0 , 0 ) == FALSE )
        {
            INT_PTR nSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

            if( nSel != CB_ERR && m_pEncrypt != NULL )
            {
                if( m_pEncrypt[ nSel ].szDescr[ 0 ] == 0 )
                {

                    EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , FALSE );


                    ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , SW_HIDE );
                }
                else
                {

                    ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , SW_SHOW );

                    EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) , TRUE );


                    SetWindowText( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) ,  m_pEncrypt[ nSel ].szDescr );
                }

                if( !IsWindowEnabled( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_DESCRIPTION ) ) )
                {
                    RECT rc;
                    RECT rc2;

                    GetWindowRect( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_ENCGRP ) , &rc );

                    GetWindowRect( GetDlgItem( GetParent( hwndCtrl ), IDC_STATIC_DESCRIPTION ) , &rc2 );

                    rc.bottom = rc2.top;

                    MapWindowPoints( NULL , GetParent( hwndCtrl ) , ( LPPOINT )&rc , 2 );

                    SetWindowPos( GetDlgItem( GetParent( hwndCtrl ), IDC_STATIC_ENCGRP ) , 0 , 0 , 0 , rc.right - rc.left , rc.bottom - rc.top , SWP_NOMOVE | SWP_SHOWWINDOW );


                    //resize window
                }

            }
        }

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CSecurity::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );
    // Obtain USERCONFIG struct to determine if msgina is enabled or not
    // otherwise load thirdparty level's of encryption
    /*
    ICfgComp *pCfgcomp;

    if( m_pCompdata->GetServer( &pCfgcomp ) != 0 )
    {
        ULONG ulItems;

        // WdName is an enumtype

        if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( g_ws.wdName , WdName , &ulItems , &m_pEncrypt ) ) )
        {
            for( ULONG i = 0; i < ulItems; ++i )
            {
                SendMessage( GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );
                if(m_pEncrypt[ i ].Flags & ELF_DEFAULT)
                {
                    m_DefaultEncryptionLevelIndex = i;
                }
            }

            SendMessage( GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) , CB_SETCURSEL , (WPARAM)m_DefaultEncryptionLevelIndex, 0 );

            OnCommand( CBN_SELCHANGE , IDC_COMBO_ENCRYPT_LVL , GetDlgItem( hwnd , IDC_COMBO_ENCRYPT_LVL ) );



        }

        pCfgcomp->Release( );
    }
    */

    CheckDlgButton(  hwnd,               // handle to dialog box
                     IDC_CHECK_ENCRYPT,  // button-control identifier
                     BST_UNCHECKED       // check state
                  );


    //SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENCRYPT ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
// Save out information when going to the next area
//-----------------------------------------------------------------------------
BOOL CSecurity::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_SETACTIVE && g_bConnectionTypeChanged_forEncryption )
    {
        ODS( L"Encryption PSN_SETACTIVE\n" );

        ICfgComp *pCfgcomp;

        if( m_pCompdata->GetServer( &pCfgcomp ) != 0 )
        {
            ULONG ulItems = 0;

            HWND hCombo = GetDlgItem( hDlg , IDC_COMBO_ENCRYPT_LVL );

            ASSERT( hCombo != NULL );

            // Remove everything from the list

            SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );


            // WdName is an enumtype

            if( m_pEncrypt != NULL )
            {
                CoTaskMemFree( m_pEncrypt );

                m_pEncrypt = NULL;
            }

            if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( g_ws.wdName , WdName , &ulItems , &m_pEncrypt ) ) )
            {
                for( ULONG i = 0; i < ulItems; ++i )
                {
                    SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );

                    if( m_pEncrypt[ i ].Flags & ELF_DEFAULT )
                    {
                        m_DefaultEncryptionLevelIndex = i;

                    }
                }

                SendMessage( hCombo , CB_SETCURSEL , ( WPARAM )m_DefaultEncryptionLevelIndex, 0 );

                OnCommand( CBN_SELCHANGE , IDC_COMBO_ENCRYPT_LVL , hCombo );

                // SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENCRYPT ) , BM_CLICK , 0 , 0 );
            }
            else
            {
                // no encryption info insert value to none and grey out the control
                TCHAR tchNone[ 80 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_NONE , tchNone , SIZE_OF_BUFFER( tchNone ) );

                SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )tchNone );

                SendMessage( hCombo , CB_SETCURSEL , 0 , 0 );

                EnableWindow( hCombo , FALSE );
            }


            pCfgcomp->Release( );
        }

        g_bConnectionTypeChanged_forEncryption = FALSE;
    }

    else if( pnmh->code == PSN_WIZNEXT )
    {
        if( m_pEncrypt != NULL )
        {
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_ENCRYPT_LVL ) , CB_GETCURSEL , 0  , 0 );

            if( iSel != CB_ERR )
            {
                g_uc.MinEncryptionLevel = ( UCHAR )m_pEncrypt[iSel].RegistryValue;
            }
            else
            {
                g_uc.MinEncryptionLevel = ( UCHAR )m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue;
            }
        }
        else
        {
            g_uc.MinEncryptionLevel = 0;
        }


        g_uc.fUseDefaultGina = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENCRYPT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CSecurity::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_SECURITY );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CSecurity::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_SECURITY );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_SECURITY );

    return TRUE;
}

//***********************************************************************************
//                      Timeout settings dialog
//
#if 0 // not used in the connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTimeout::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeout *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeout *pDlg = ( CTimeout * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeout ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeout * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeout ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// Set time out settings to a default setting
//-----------------------------------------------------------------------------
BOOL CTimeout::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    HWND hCombo[ 3 ] =
    {
        GetDlgItem( hwnd , IDC_COMBO_CON_WZ ),

        GetDlgItem( hwnd , IDC_COMBO_DISCON_WZ ),

        GetDlgItem( hwnd , IDC_COMBO_IDLE_WZ )
    };

    DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }


    SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );

    SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );

    SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );

    // force WM_COMMAND to be sent

    SendMessage( GetDlgItem( hwnd , IDC_RADIO_UDCCS_WZ ) , BM_CLICK , 0 , 0 ) ;

    LoadAbbreviates( );

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTimeout::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    BOOL bEnable;

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_RADIO_UDCCS_WZ  )
        {
            bEnable = FALSE;
        }
        else
        {
            bEnable = TRUE;
        }

        int rgID[] = { IDC_STATIC_CON , IDC_STATIC_DISCON , IDC_STATIC_IDLE , IDC_COMBO_CON_WZ , IDC_COMBO_DISCON_WZ  , IDC_COMBO_IDLE_WZ , -1 };

        EnableGroup( GetParent( hwndCtrl ) , &rgID[0] , bEnable );

    }

    CTimeOutDlg::OnCommand( wNotifyCode , wID , hwndCtrl );

    return FALSE;
}

//-----------------------------------------------------------------------------
// return TRUE if wish not to continue to the next page
//-----------------------------------------------------------------------------
BOOL CTimeout::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_UDCCS_WZ ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            g_uc.fInheritMaxSessionTime = 1;

            g_uc.fInheritMaxDisconnectionTime = 1;

            g_uc.fInheritMaxIdleTime = 1;
        }
        else
        {
            g_uc.fInheritMaxSessionTime = 0;

            g_uc.fInheritMaxDisconnectionTime = 0;

            g_uc.fInheritMaxIdleTime = 0;

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_CON_WZ ) , &g_uc.MaxConnectionTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_DISCON_WZ ) , &g_uc.MaxDisconnectionTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }

            if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_IDLE_WZ ) , &g_uc.MaxIdleTime ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CTimeout::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TIMEOUT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTimeout::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_TIMEOUT );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_TIMEOUT );

    return TRUE;
}

//-----------------------------------------------------------------------------
int CTimeout::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_CON_WZ:

        idx = 0;

        break;

    case IDC_COMBO_DISCON_WZ:

        idx = 1;

        break;

    case IDC_COMBO_IDLE_WZ:

        idx = 2;

        break;
    }

    return idx;
}

#endif
//***********************************************************************************

#if 0 // object not used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CAutoLogon::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAutoLogon *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAutoLogon *pDlg = ( CAutoLogon * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAutoLogon ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAutoLogon * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CAutoLogon ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    int rgID[] = { IDC_EDIT_USRNAME_WZ , IDC_STATIC_USRNAME ,  IDC_EDIT_DOMAIN_WZ , IDC_STATIC_DOMAIN , IDC_EDIT_PASSWD_WZ , IDC_STATIC_PASSWD , IDC_EDIT_CONFIRM_WZ , IDC_STATIC_CONPASSWD , -1 };

    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_ICCP_WZ )
        {
            BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , !bChecked );

            if( !bChecked )
            {
                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_PROMPTPASSWD_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LGINFO_WZ),BM_SETCHECK,(WPARAM)BST_CHECKED,0);

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LGINFO_WZ),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
            }

        }
        else if( wID == IDC_CHECK_PROMPTPASSWD_WZ )
        {
            if( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_ICCP_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );
            }
        }
        else if( wID == IDC_RADIO_LGINFO_WZ )
        {
            BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            if(bChecked)
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , TRUE );

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_PROMPTPASSWD_WZ )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_SETCHECK,(WPARAM)BST_CHECKED,0);
            }
            //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_CLICK,0,0);
        }

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    SendMessage( GetDlgItem( hwnd , IDC_EDIT_USRNAME_WZ ) , EM_SETLIMITTEXT , ( WPARAM )USERNAME_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_DOMAIN_WZ ) , EM_SETLIMITTEXT , ( WPARAM )DOMAIN_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_PASSWD_WZ ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_CONFIRM_WZ ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_ICCP_WZ ) , BM_CLICK , 0 , 0 );

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CAutoLogon::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_AUTO_LOGON );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CAutoLogon::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HEADER_LOGONSETTINGS );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHEADER_LOGONSETTINGS );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc.fInheritAutoLogon = SendMessage( GetDlgItem( hDlg , IDC_CHECK_ICCP_WZ ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

        if( !g_uc.fInheritAutoLogon )
        {
            if( !ConfirmPwd( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                return TRUE;
            }
        }

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_USRNAME_WZ ) , g_uc.UserName , SIZE_OF_BUFFER( g_uc.UserName ) );

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_DOMAIN_WZ ) , g_uc.Domain , SIZE_OF_BUFFER( g_uc.Domain ) );

         GetWindowText( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , g_uc.Password , SIZE_OF_BUFFER( g_uc.Password ) );

         g_uc.fPromptForPassword = SendMessage( GetDlgItem( hDlg , IDC_CHECK_PROMPTPASSWD_WZ ) ,

                BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CAutoLogon::ConfirmPwd( HWND hDlg )
{
    TCHAR tchPzWd[ PASSWORD_LENGTH + 1];

    TCHAR tchConfirm[ PASSWORD_LENGTH + 1];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        return TRUE;
    }

    int iSz = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , tchPzWd , SIZE_OF_BUFFER( tchPzWd ) );

    // warn on the minimum and maximum sizes

    if( iSz > 0 && ( iSz < 6 || iSz > PASSWORD_LENGTH ) )
    {

        ErrMessage( hDlg , IDS_ERR_PASSWD );

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) );

        SendMessage( GetDlgItem( hDlg , IDC_EDIT_PASSWD_WZ ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , L"" );

        return FALSE;
    }

    int iSz2 = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , tchConfirm , SIZE_OF_BUFFER( tchConfirm ) );

    if( iSz == iSz2 )
    {
        if( iSz == 0 )
        {
            return TRUE;
        }

        if( lstrcmp( tchPzWd , tchConfirm ) == 0 )
        {
            return TRUE;
        }
    }

    ErrMessage( hDlg , IDS_ERR_PASSCONFIRM );

    SetFocus( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_CONFIRM_WZ ) , L"" );

    return FALSE;
}

#endif
//***********************************************************************************

#if 0 // object no longer used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CInitProg::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CInitProg *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CInitProg *pDlg = ( CInitProg * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CInitProg ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CInitProg * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CInitProg ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    SendMessage( GetDlgItem( hwnd , IDC_EDIT_INITPROG_CMDLINE ) , EM_SETLIMITTEXT , ( WPARAM )INITIALPROGRAM_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_INITPROG_WD ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_INITPROG_INHERIT ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED && wID == IDC_CHECK_INITPROG_INHERIT )
    {
        int rgID[] = { IDC_EDIT_INITPROG_CMDLINE , IDC_STATIC_CMDLINE , IDC_EDIT_INITPROG_WD , IDC_STATIC_WF , -1 };

        EnableGroup( GetParent( hwndCtrl ) , &rgID[0] , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_INITIAL_PROGRAM );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CInitProg::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_INITPRG );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_INITPRG );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CInitProg::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    g_uc.fInheritInitialProgram = SendMessage( GetDlgItem( hDlg , IDC_CHECK_INITPROG_INHERIT ) , BM_GETCHECK , 0 , 0 );

    if( !g_uc.fInheritInitialProgram )
    {
        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_INITPROG_CMDLINE ) , g_uc.InitialProgram , SIZE_OF_BUFFER( g_uc.InitialProgram ) );

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_INITPROG_WD ) , g_uc.WorkDirectory , SIZE_OF_BUFFER( g_uc.WorkDirectory ) );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

#endif
//***********************************************************************************

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CRemotectrl::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CRemotectrl *pDlg;

    if( msg == WM_INITDIALOG )
    {
        pDlg = ( CRemotectrl * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CRemotectrl ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CRemotectrl * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CRemotectrl ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;


    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
// Set default values for Remote control dialog
//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTECTRL_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_REMOTECTRL_NOTIFYUSER ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

    SendMessage( GetDlgItem( hwnd  , IDC_RADIO_INHERIT_REMOTE_CONTROL ) , BM_CLICK , 0 , 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED && wID == IDC_RADIO_INHERIT_REMOTE_CONTROL ||

        wID == IDC_RADIO_REMOTECTRL_NO || wID == IDC_RADIO_ENABLE_REMOTECONTROL )
    {
        int rgID[] = { IDC_CHECK_REMOTECTRL_NOTIFYUSER , IDC_RADIO_REMOTECTRL_WATCH , IDC_RADIO_REMOTECTRL_CONTROL , -1 };

        EnableGroup( GetParent( hwndCtrl ) , rgID , SendMessage( GetDlgItem( GetParent( hwndCtrl ) ,

            IDC_RADIO_ENABLE_REMOTECONTROL ) , BM_GETCHECK ,  0 , 0 ) == BST_CHECKED );

    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemotectrl::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_INHERIT_REMOTE_CONTROL ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            g_uc.fInheritShadow = FALSE;

            if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTECTRL_NO ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                BOOL bCheckNotify = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_CHECK_REMOTECTRL_NOTIFYUSER ) , BM_GETCHECK , 0 , 0 );

                BOOL bRadioControl = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTECTRL_CONTROL ) , BM_GETCHECK , 0 , 0 );

                if( bCheckNotify )
                {
                    if( bRadioControl )
                    {
                        g_uc.Shadow = Shadow_EnableInputNotify;
                    }
                    else
                    {
                        g_uc.Shadow = Shadow_EnableNoInputNotify;
                    }
                }
                else
                {
                    if( bRadioControl )
                    {
                        g_uc.Shadow = Shadow_EnableInputNoNotify;
                    }
                    else
                    {
                        g_uc.Shadow = Shadow_EnableNoInputNoNotify;
                    }
                }
            }
            else
            {
                g_uc.Shadow = Shadow_Disable;
            }

        }
        else
        {
            g_uc.fInheritShadow = TRUE;
        }

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}


//-----------------------------------------------------------------------------
BOOL CRemotectrl::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_REMOTE_CONTROL );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CRemotectrl::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_REMOTE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_REMOTE );

    return TRUE;
}

//***********************************************************************************
#if 0 // object not used in connection wizard
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CWallPaper::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CWallPaper *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CWallPaper *pDlg = ( CWallPaper * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CWallPaper ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CWallPaper * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CWallPaper ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_WALLPAPER );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CWallPaper::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_WALLPR );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_WALLPR );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CWallPaper::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc.fWallPaperDisabled = SendMessage( GetDlgItem( hDlg , IDC_CHECK_WALLPAPER ) , BM_GETCHECK , 0 , 0  );
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

#endif
//***********************************************************************************

//-----------------------------------------------------------------------------
CConProp::CConProp( CCompdata *pCompdata )
{
    m_pCompdata = pCompdata;

    m_iOldSel = -1;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CConProp::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CConProp *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CConProp *pDlg = ( CConProp * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CConProp ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CConProp * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CConProp ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    g_pObj = NULL;

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_COMMENT_WZ ) , EM_SETLIMITTEXT , ( WPARAM )WINSTATIONCOMMENT_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , EM_SETLIMITTEXT , ( WPARAM )( WINSTATIONNAME_LENGTH - WINSTATION_NAME_TRUNCATE_BY ), 0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_CONNECTION_PROP );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CConProp::DlgProc;

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_TRANSTYPE );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_TRANSTYPE );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    ICfgComp *pCfgcomp;

    if( pnmh->code == PSN_SETACTIVE && g_bConnectionTypeChanged_forConProps )
    {
        PDNAMEW * pDname;

        ULONG ulItems = 0;

        ULONG cbSize = 0;

        ODS( L"CConProp::OnNotify -- PSN_SETACTIVE\n" );

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"CConProp::OnNotify - PSN_SETACTIVE getserver failed\n" );

            return FALSE;
        }

        // remove every item from the list

        HWND hCombo = GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ );

        ASSERT( hCombo != NULL );

        // Remove everything from the list

        SendMessage( hCombo , CB_RESETCONTENT , 0 , 0 );

        // WdName is a flag and not a variable

        if( SUCCEEDED( pCfgcomp->GetTransportTypes( g_ws.wdName , WdName , &ulItems , &cbSize , ( WCHAR ** )&pDname ) ) )
        {
            for( ULONG i = 0 ; i < ulItems ; ++i )
            {
                SendMessage( hCombo , CB_ADDSTRING , 0 , ( LPARAM )pDname[ i ] );
            }

            SendMessage( hCombo , CB_SETCURSEL , ( WPARAM ) 0 , 0 );

            CoTaskMemFree( pDname );
        }

        pCfgcomp->Release( );

        g_bConnectionTypeChanged_forConProps = FALSE;

    }
    else if( pnmh->code == PSN_WIZNEXT )
    {
        DWORD dwErr = 0;

        if( GetWindowText( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , g_ws.Name , SIZE_OF_BUFFER( g_ws.Name ) ) == 0 || !IsValidConnectionName( g_ws.Name , &dwErr ) )
        {
            if( dwErr == ERROR_INVALID_FIRSTCHARACTER )
            {
                ErrMessage( hDlg , IDS_ERR_INVALIDFIRSTCHAR );
            }
            else
            {
                ErrMessage( hDlg , IDS_ERR_INVALIDCHARS );
            }

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) );

            SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

            return TRUE;
        }

        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        BOOL bUnique;

        if( SUCCEEDED( pCfgcomp->IsWSNameUnique( g_ws.Name , &bUnique ) ) )
        {
            if( !bUnique )
            {
                ErrMessage( hDlg , IDS_ERR_CONEXIST );

                SetFocus( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_WSNAME_WZ ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , -1 );

                pCfgcomp->Release( );

                return TRUE;
            }

        }

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_COMMENT_WZ ) , g_ws.Comment , SIZE_OF_BUFFER( g_ws.Comment ) );

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ ) , CB_GETCURSEL , 0 , 0 );

        if( iSel != CB_ERR )
        {
            SendMessage( GetDlgItem( hDlg , IDC_COMBO_TRANSPORT_WZ ) , CB_GETLBTEXT , iSel , ( LPARAM )g_ws.pdName );

            if( iSel != m_iOldSel )
            {
                g_nAsyncOrNetwork = 0;

                m_iOldSel = iSel;
            }
        }


        // get the SDCLASS

        DWORD dwSdClass = 0;

        if( FAILED( pCfgcomp->GetTransportType( g_ws.wdName , g_ws.pdName , &dwSdClass ) ) )
        {
            dwSdClass = SdNone;

            ODS( L"GetTransPortType failed @ CConProp::OnNotify\n" );
        }

        if( dwSdClass == SdNetwork && g_nAsyncOrNetwork != LAN_PAGE )
        {
            g_nAsyncOrNetwork = LAN_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , LAN_PAGE , g_ws.wdName ) );
        }

        else if( dwSdClass == SdAsync && g_nAsyncOrNetwork != ASYNC_PAGE )
        {
            g_nAsyncOrNetwork = ASYNC_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , ASYNC_PAGE , g_ws.wdName ) );
        }

        else if( dwSdClass != SdAsync && dwSdClass != SdNetwork )
        {
            // remove g_nAsyncOrNetwork page and let citrix or third party vendor worry about the transport type

            g_nAsyncOrNetwork = FIN_PAGE;

            VERIFY_S( TRUE , RemovePages( hDlg ) );

            VERIFY_S( TRUE , AddPages( hDlg , -1 , g_ws.wdName ) ); // only add citrix or 3rd parth pages

            // I'm tempted
            // g_nAsyncOrNetwork = 0;

        }


        pCfgcomp->Release( );

    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-------------------------------------------------------------------------------
// We're about to update lanpage or asyncpage and slap in citrix additional pages
// so we need to remove all of them first even the final page
//-------------------------------------------------------------------------------
BOOL CConProp::RemovePages( HWND hDlg )
{
    HPROPSHEETPAGE hPage = NULL;

    for( int idx = /*g_nAsyncOrNetwork*/ LAN_PAGE; idx < MS_DIALOG_COUNT ; idx++ )
    {
        hPage= *m_pCompdata->m_hPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

            m_pCompdata->m_hPages.SetAt( idx , NULL );
        }
    }

    for( idx = 0 ; idx < ( m_hOtherPages.GetSize( ) ) ; ++idx )
    {
        hPage = *m_hOtherPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

            m_hOtherPages.SetAt( idx , NULL );
        }

        m_hOtherPages.DeleteArray( );
    }

    // remove final page

    hPage= *m_pCompdata->m_hPages.GetAt( FIN_PAGE );

    if( hPage != NULL )
    {
        PropSheet_RemovePage( GetParent( hDlg ) , 0 , hPage );

        m_pCompdata->m_hPages.SetAt( FIN_PAGE , NULL );

    }

    return TRUE;

}

//-----------------------------------------------------------------------------
// Now include lanpage or async page or either and slapin citrix pages
//-----------------------------------------------------------------------------
BOOL CConProp::AddPages( HWND hwnd , int idx , LPTSTR szDriverName )
{
    PROPSHEETPAGE psp;

    ASSERT( szDriverName != NULL );

    if( idx == LAN_PAGE )
    {
        if( *m_pCompdata->m_hPages.GetAt( LAN_PAGE ) == NULL )
        {
            m_pCompdata->m_pDlg[ LAN_PAGE ]->GetPropertySheetPage( psp );

            m_pCompdata->m_hPages.SetAt( LAN_PAGE , CreatePropertySheetPage( &psp ) );

            PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( LAN_PAGE ) );
        }

    }
    else if( idx == ASYNC_PAGE )
    {
        if( *m_pCompdata->m_hPages.GetAt( ASYNC_PAGE ) == NULL )
        {
            m_pCompdata->m_pDlg[ ASYNC_PAGE ]->GetPropertySheetPage( psp );

            m_pCompdata->m_hPages.SetAt( ASYNC_PAGE , CreatePropertySheetPage( &psp ) );

            PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( ASYNC_PAGE ) );
        }
    }

    // add thirdparty pages

    ODS( L"Adding third party page\n" );

    VERIFY_S( TRUE , InsertThirdPartyPages( szDriverName ) );
    

    for( idx = 0 ; idx < ( m_hOtherPages.GetSize( ) ) ; ++idx )
    {
        HPROPSHEETPAGE hPage = *m_hOtherPages.GetAt( idx );

        if( hPage != NULL )
        {
            PropSheet_AddPage( GetParent( hwnd ) , hPage );

            m_hOtherPages.SetAt( idx , hPage );
        }

    }

    if( *m_pCompdata->m_hPages.GetAt( FIN_PAGE ) == NULL )
    {
        m_pCompdata->m_pDlg[ FIN_PAGE ]->GetPropertySheetPage( psp );

        m_pCompdata->m_hPages.SetAt( FIN_PAGE , CreatePropertySheetPage( &psp ) );

        PropSheet_AddPage( GetParent( hwnd ) , *m_pCompdata->m_hPages.GetAt( FIN_PAGE ) );

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CConProp::InsertThirdPartyPages( LPTSTR pszKey )
{
    HKEY hKey;

    TCHAR tchKey[ MAX_PATH ];

    TCHAR tchCLSID[ 40 ];

    CLSID clsidOther;

    DWORD dwSize;

    //LPEXTENDTSWIZARD pObj = NULL;

    // make sure the key passed in is valid
    if (pszKey == NULL)
        return FALSE;

    // make sure the key will fit in the buffer
    if ( lstrlen(pszKey) + lstrlen(tchThirdPartyPath) >= MAX_PATH )
        return FALSE;

    lstrcpy( tchKey , tchThirdPartyPath );

    lstrcat( tchKey , pszKey );

    HRESULT hr = E_FAIL;

    if( g_pObj != NULL )
    {
        g_pObj->Release( );

        // we set this to NULL in case Cocreate fails we don't want to
        // deference an interface that went away.

        g_pObj = NULL;
    }

    do
    {

        if( RegOpenKey( HKEY_LOCAL_MACHINE , tchKey , &hKey ) != ERROR_SUCCESS )
        {
            ODS( L"CConProp::InsertThirdPartyPages RegOpenKey failed\n" );
            break;
        }

        dwSize = sizeof( tchCLSID );

        if( RegQueryValueEx( hKey , L"CLSID" , NULL , NULL , ( LPBYTE )&tchCLSID[ 0 ] , &dwSize ) != ERROR_SUCCESS )
        {
            ODS( L"CConProp::InsertThirdPartyPages RegQueryValueEx failed\n" );
            break;
        }

        if( FAILED( CLSIDFromString( tchCLSID , &clsidOther ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages CLSIDFromString failed\n" );
            break;
        }

        if( FAILED( CoCreateInstance( clsidOther , NULL , CLSCTX_INPROC_SERVER , IID_IExtendTSWizard , ( LPVOID *) &g_pObj ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages CoCreate failed\n" );
            break;
        }

        if( FAILED( g_pObj->AddPages( ( LPWIZARDPROVIDER )this ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages ExtWiz->Addpages failed\n" );
            break;
        }

        if( FAILED( g_pObj->SetWinstationName( g_ws.Name ) ) )
        {
            ODS( L"CConProp::InsertThirdPartyPages ExtWiz->SetWinstationName failed\n" );
            break;
        }

        hr = S_OK;

    }while( 0 );    

    RegCloseKey( hKey );

    if( FAILED( hr ) )
    {
        return FALSE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CConProp::QueryInterface( REFIID riid , LPVOID *ppobj )
{
    ODS( L"TSCC-WIZ CConProp QI--" );

    if( riid == IID_IUnknown )
    {
        ODS( L"IUnknown" );

        *ppobj = ( LPUNKNOWN )this;
    }
    else if( riid == IID_IWizardProvider )
    {
        ODS( L"IWizardProvider" );

        *ppobj = ( IWizardProvider *)this;
    }
    else
    {
        DBGMSG( L"Interface not supported %x\n" , riid );

        *ppobj = NULL;

        return( E_NOINTERFACE );
    }

    AddRef( );

    ODS( L"\n" );

    return S_OK;
}

//-----------------------------------------------------------------------------
// For IWizardProvider
//-----------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CConProp::AddRef( )
{
    return InterlockedIncrement( ( LPLONG )&m_cRef );
}

//-----------------------------------------------------------------------------
// For IWizardProvider
//-----------------------------------------------------------------------------
STDMETHODIMP_( ULONG ) CConProp::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cRef ) == 0 )
    {
        //
        // DONOT delete this
        //
        return 0;
    }

    return m_cRef;
}

//-----------------------------------------------------------------------------
// This is the call back function IExtendTSWizard will use to add pages to
// the array
//-----------------------------------------------------------------------------
STDMETHODIMP CConProp::AddPage( HPROPSHEETPAGE hPage )
{
    if( m_hOtherPages.Insert( hPage ) > 0 )
    {
        return S_OK;
    }

    return E_FAIL;
}

//***********************************************************************************

CAsync::CAsync( CCompdata *pComdata )
{
    m_pCompdata = pComdata;
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );

    UNREFERENCED_PARAMETER( lp );

    UNREFERENCED_PARAMETER( hwnd );

    ICfgComp *pCfgcomp = NULL;

    BOOL bRet = TRUE;

    if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Wizard could obtain backend interface for CAsync\n" );

        return FALSE;
    }

    // populate CAsyncDlg members

    m_uc = g_uc;

    pCfgcomp->GetAsyncConfig( g_ws.wdName , WdName , &m_ac );

    pCfgcomp->Release( );

    return bRet;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CAsync::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CAsync *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CAsync *pDlg = ( CAsync * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CAsync ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CAsync * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CAsync ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CAsync::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ASYNC_WIZ );

    psp.pszHeaderTitle = MAKEINTRESOURCE( IDS_HDR_ASYNC );

    psp.pszHeaderSubTitle = MAKEINTRESOURCE( IDS_SUBHDR_ASYNC );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CAsync::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnDestroy( )
{
    AsyncRelease( );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    if( pnmh->code == PSN_WIZNEXT )
    {
        g_uc = m_uc;

        g_ac = m_ac;
    }

    g_ws.PdClass = SdAsync;

    if( pnmh->code == PSN_SETACTIVE )
    {
        ICfgComp * pCfgcomp = NULL;
        if( m_pCompdata->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"Wizard could obtain backend interface for CAsync\n" );

            return FALSE;
        }

        BOOL bRet = CAsyncDlg::OnInitDialog( hDlg ,  g_ws.wdName , NULL , pCfgcomp ) ;

        if(FALSE == bRet)
        {
            PropSheet_PressButton( GetParent(hDlg),PSBTN_BACK );

        }

        if(pCfgcomp)
        {
            pCfgcomp->Release();
        }
    }

    return CDialogWizBase::OnNotify( idCtrl , pnmh , hDlg );
}

//-----------------------------------------------------------------------------
BOOL CAsync::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    BOOL bDummy;

    return CAsyncDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &bDummy );
}

//***********************************************************************************

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CFin::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CFin *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CFin *pDlg = ( CFin * )( ( PROPSHEETPAGE *)lp )->lParam ;

        //
        // Don't use a static pointer here
        // There will be concurrency issues
        //

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CFin ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CFin * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CFin ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_DESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_NOTIFY:

        pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }
    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    UNREFERENCED_PARAMETER( wp );
    UNREFERENCED_PARAMETER( lp );

    LOGFONT lgfn;

    int iFontSize;

    TCHAR szFontSize[16];

    ZeroMemory( &lgfn , sizeof( LOGFONT ) );

    LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTSIZE , szFontSize , SIZE_OF_BUFFER(szFontSize) );

    iFontSize = _ttoi( szFontSize );

    HDC hdc = ::GetDC( NULL );

    if( hdc != NULL )
    {
        lgfn.lfHeight = MulDiv( -iFontSize , GetDeviceCaps(hdc , LOGPIXELSY), 72);

        LoadString( _Module.GetResourceInstance( ) , IDS_VERDANABLDFONTNAME , lgfn.lfFaceName , SIZE_OF_BUFFER(lgfn.lfFaceName) );

        m_hFont = CreateFontIndirect( &lgfn );

        ASSERT( m_hFont != NULL ); // let me know if we got it or not

        SetWindowText( GetDlgItem(hwnd , IDC_CONNECTION_NAME ) ,g_ws.Name );

        SendMessage( GetDlgItem( hwnd , IDC_STATIC_FINISH ) , WM_SETFONT , ( WPARAM )m_hFont , MAKELPARAM( TRUE , 0 ) );

        ReleaseDC( NULL , hdc );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnDestroy( )
{
    DeleteObject( m_hFont );

    return CDialogWizBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CFin::GetPropertySheetPage( PROPSHEETPAGE& psp)
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT | PSP_HIDEHEADER;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_FINISH );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CFin::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CFin::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    HRESULT hResult = S_OK;

    if( pnmh->code == PSN_SETACTIVE )
    {
        PropSheet_SetWizButtons( GetParent( hDlg ) , PSWIZB_BACK | PSWIZB_FINISH  );
    }
    else if( pnmh->code == PSN_WIZFINISH )
    {
        ICfgComp *pCfgcomp;

        m_pCompdata->GetServer( &pCfgcomp );

        //PSECURITY_DESCRIPTOR pSd;

        //LONG lSdsize;

        g_ws.fEnableWinstation = 1;

        BOOL bUnique;

        // verify that network adapter was not modified
        // bugid 253896

        if( SUCCEEDED( pCfgcomp->IsWSNameUnique( g_ws.Name , &bUnique ) ) )
        {
            if( !bUnique )
            {
                ErrMessage( hDlg , IDS_ERR_LANRECFG );

                pCfgcomp->Release( );

                return FALSE;
            }
        }

        if(g_ws.PdClass == SdNetwork)
        {
            if( SUCCEEDED( pCfgcomp->IsNetWorkConnectionUnique( g_ws.wdName , g_ws.pdName , ( ULONG )g_ws.LanAdapter , &bUnique ) ) )
            {
                if( !bUnique )
                {
                    ErrMessage( hDlg , IDS_ERR_LANRECFG );

                    pCfgcomp->Release( );

                    return FALSE;
                }
            }
        }

        TCHAR tchWdkey[ 80 ];

        if( SUCCEEDED( pCfgcomp->GetWdKey( g_ws.wdName , tchWdkey ) ) )
        {
            WDCONFIG2 WdConfig;

            ULONG ulByteCount;

            if( RegWdQuery( NULL, tchWdkey, &WdConfig , sizeof( WDCONFIG2 ) , &ulByteCount ) == ERROR_SUCCESS )
            {
                g_uc.fAutoClientDrives  =   WdConfig.User.fAutoClientDrives;
                g_uc.fAutoClientLpts    =   WdConfig.User.fAutoClientLpts;
                g_uc.fDisableCam        =   WdConfig.User.fDisableCam;
                g_uc.fDisableCcm        =   WdConfig.User.fDisableCcm;
                g_uc.fDisableCdm        =   WdConfig.User.fDisableCdm;
                g_uc.fDisableClip       =   WdConfig.User.fDisableClip;
                g_uc.fDisableCpm        =   WdConfig.User.fDisableCpm;
                g_uc.fDisableLPT        =   WdConfig.User.fDisableLPT;
				g_uc.fInheritAutoClient =   WdConfig.User.fInheritAutoClient;
				g_uc.fForceClientLptDef =   WdConfig.User.fForceClientLptDef;
                g_uc.ColorDepth         =   WdConfig.User.ColorDepth;

            }
            else
            {
                ODS( L"TSCC:Holy cow our wdkeys were not copied going default\n" );
                // Set default values for pages that were removed
                // Logon setting

                g_uc.fAutoClientLpts = 1;
	
                //g_uc.fAutoClientDrives = 1;

                g_uc.fDisableCcm = 1;

                g_uc.fForceClientLptDef = 1;
            }

        }


        g_uc.fInheritMaxSessionTime = 1;

        g_uc.fInheritMaxDisconnectionTime = 1;

        g_uc.fInheritMaxIdleTime = 1;

        g_uc.fInheritResetBroken = 1;

        g_uc.fInheritReconnectSame = 1;

        // Environment

        g_uc.fInheritInitialProgram = 1;

        g_uc.fPromptForPassword = 1;

        // Client Settings

        g_uc.fWallPaperDisabled = 1;

		g_uc.fInheritAutoLogon = 1;

        // Disable cursor flash on servers
        g_uc.fCursorBlinkDisabled = 1;       

        if(g_ws.PdClass == SdAsync)
        {
            ODS( L"TSCC : Async connection about to be configured\n" );

            g_ws.uMaxInstanceCount = 1;

            hResult = pCfgcomp->CreateNewWS( g_ws , sizeof( USERCONFIG ) , &g_uc , &g_ac) ;

        }
        else
        {
            hResult = pCfgcomp->CreateNewWS( g_ws , sizeof( USERCONFIG ) , &g_uc , NULL) ;
        }

        if( SUCCEEDED(hResult) )
        {
            ODS( L"New WS created\n" );

            if( g_pObj != NULL )
            {
                ODS( L" calling finito\n" );

                if( FAILED( g_pObj->Finito( ) ) )
                {
                    ODS( L"TSCC : CFin::OnNotify@g_pObj failed final call\n" );
                }                

                ODS( L"about to release object\n" );

                g_pObj->Release( );                

                //g_pObj = NULL;
            }

            CResultNode  *pResultNode = ( CResultNode * )new CResultNode( );

            if( pResultNode != NULL )
            {
                pResultNode->SetConName( g_ws.Name , SIZE_OF_BUFFER( g_ws.Name ) );

                pResultNode->SetTTName( g_ws.pdName , SIZE_OF_BUFFER( g_ws.pdName ) );

                pResultNode->SetTypeName( g_ws.wdName , SIZE_OF_BUFFER( g_ws.wdName ) );

                pResultNode->SetComment(  g_ws.Comment , SIZE_OF_BUFFER( g_ws.Comment ) );

                pResultNode->EnableConnection( g_ws.fEnableWinstation );

                pResultNode->SetImageIdx( ( g_ws.fEnableWinstation ? 1 : 2 ) );

                pResultNode->SetServer( pCfgcomp );

                m_pCompdata->m_rnNodes.Insert( pResultNode );
            }

            if( g_nAsyncOrNetwork == ASYNC_PAGE )
            {
                 WS *pWs;

                 LONG lSz;

                 TCHAR tchWrnBuf[ 256 ];

                 TCHAR tchOutput[ 512 ];

                 if( SUCCEEDED( pCfgcomp->GetWSInfo(g_ws.Name , &lSz , &pWs ) ) )
                 {
                     if( pWs->fEnableWinstation && pWs->PdClass == SdAsync )
                     {
                         ASYNCCONFIGW AsyncConfig;

                         HRESULT hResult = pCfgcomp->GetAsyncConfig(pWs->Name,WsName,&AsyncConfig);

                         if( SUCCEEDED( hResult ) )
                         {
                             if( AsyncConfig.ModemName[0] )
                             {
                                 LoadString( _Module.GetResourceInstance( ) , IDS_REBOOT_REQD , tchOutput , SIZE_OF_BUFFER( tchOutput ) );

                                 LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWrnBuf , SIZE_OF_BUFFER( tchWrnBuf ) );

                                 MessageBox( hDlg , tchOutput , tchWrnBuf , MB_ICONWARNING | MB_OK );
                             }
                         }
                     }

                     CoTaskMemFree( pWs );
                 }
            }
        }
        else
        {
            if( hResult == E_ACCESSDENIED )
            {
                TscAccessDeniedMsg( hDlg );
            }
            else
            {
                TscGeneralErrMsg( hDlg );
            }
        }

        pCfgcomp->Release();
    }
    return TRUE;
}

//-----------------------------------------------------------------------------
CFin::CFin( CCompdata * pCompdata)
{
    m_pCompdata = pCompdata;
}

//-----------------------------------------------------------------------------
void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable )
{
    while( rgID && *rgID != ( DWORD )-1 )
    {
        EnableWindow( GetDlgItem( hParent , *rgID ) , bEnable );

        rgID++;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\tsprsht.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

#include"stdafx.h"
#include"tsprsht.h"
#include"resource.h"
#include"tarray.h"
#include<tscfgex.h>
#include<shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include "regapi.h"
#include <ntsecapi.h>

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif //NT_SUCCESS

#ifndef STATUS_NO_MORE_ENTRIES
#define STATUS_NO_MORE_ENTRIES           ((NTSTATUS)0x8000001AL)
#endif //STATUS_NO_MORE_ENTRIES

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#endif //STATUS_SUCCESS

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String);


void ErrMessage( HWND hwndOwner , INT_PTR iResourceID );

void TscAccessDeniedMsg( HWND hwnd );

void TscGeneralErrMsg( HWND hwnd );

void xxxErrMessage( HWND  , INT_PTR  , INT_PTR  , UINT  );

void ReportStatusError( HWND hwnd , DWORD dwStatus );

DWORD xxxLegacyLogoffCleanup( PSECURITY_DESCRIPTOR *ppSD , PBOOL );
//extern BOOL g_bEditMode = FALSE;

//
INT_PTR APIENTRY CustomSecurityDlgProc( HWND, UINT, WPARAM, LPARAM );

extern void EnableGroup( HWND hParent , LPINT rgID , BOOL bEnable );

//-----------------------------------------------------------------------------
typedef enum _AcluiApiIndex
{
    ACLUI_CREATE_PAGE = 0,
    ACLUI_EDIT_SECURITY
};

//-----------------------------------------------------------------------------
typedef struct _DLL_FUNCTIONS
{
    LPCSTR pcstrFunctionName;
    LPVOID lpfnFunction;
    HINSTANCE hInst;

} DLL_FUNCTIONS;

//-----------------------------------------------------------------------------
// not subject to localization
//-----------------------------------------------------------------------------
static DLL_FUNCTIONS g_aAclFunctions[] =
{
    "CreateSecurityPage", NULL, NULL ,
     NULL , NULL , NULL
};



//-----------------------------------------------------------------------------
CPropsheet::CPropsheet( )
{
    m_cref = 0;

    m_hNotify = 0;

    m_pResNode = NULL;

    m_bGotUC = FALSE;

    m_puc = NULL;

    m_bPropertiesChange = FALSE;

    m_hMMCWindow = NULL;
}

//-----------------------------------------------------------------------------
int CPropsheet::AddRef( )
{
    DBGMSG( L"Propsheet Refcount at %d\n", ( m_cref + 1 ) );

    return InterlockedIncrement( ( LPLONG )&m_cref );
}

//-----------------------------------------------------------------------------
// called before the destructor
//-----------------------------------------------------------------------------
void CPropsheet::PreDestruct( )
{
    ICfgComp *pCfgcomp = NULL;

    if( m_bPropertiesChange )
    {
        // check to see if any users are logged on

        LONG lCount;

        if( m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            if( SUCCEEDED( pCfgcomp->QueryLoggedOnCount( m_pResNode->GetConName( ) , &lCount ) ) )
            {
                TCHAR tchTitle[ 80 ];

                TCHAR tchMessage[ 256 ];

                TCHAR tchBuffer[ 336 ];

                UINT nFlags = MB_OK | MB_ICONINFORMATION;

                VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TERMSERPROP , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

                if( lCount > 0 )
                {
                    // Notify user that settings will not affect connected users

                    if( lCount == 1 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPCHANGE_WRN , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );
                    }
                    else if( lCount > 1 )
                    {
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_PROPCHANGE_WRN_2, tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                        wsprintf( tchBuffer , tchMessage , m_pResNode->GetConName( ) );
                    }

                    wsprintf( tchBuffer , tchMessage , m_pResNode->GetConName( ) );

                    if( m_hMMCWindow == NULL )
                    {
                        nFlags |= MB_TASKMODAL;
                    }

                    MessageBox( m_hMMCWindow , tchBuffer , tchTitle , MB_OK | MB_ICONINFORMATION );
                }
            }

            pCfgcomp->Release( );
        }

    }

    if( m_puc != NULL )
    {
        CoTaskMemFree( m_puc );
    }

    // FreeStrings( );

    g_aAclFunctions[ ACLUI_CREATE_PAGE ].lpfnFunction = NULL;

    for( INT x = 0; x < NUM_OF_PRSHT ; ++x )
    {
        if( m_pDlg[ x ] != NULL )
        {
            delete[] m_pDlg[x];
        }
    }

    m_pResNode->m_bEditMode = FALSE;
}

//-----------------------------------------------------------------------------
int CPropsheet::Release( )
{
    if( InterlockedDecrement( ( LPLONG )&m_cref ) == 0 )
    {
        MMCFreeNotifyHandle( m_hNotify );

        ODS( L"Propsheet Released\n" );

        PreDestruct( );

        delete this;

        return 0;
    }

    DBGMSG( L"Propsheet Refcount at %d\n", m_cref );

    return m_cref;
}

//-----------------------------------------------------------------------------
HRESULT CPropsheet::InitDialogs( HWND hMMC , LPPROPERTYSHEETCALLBACK pPsc , CResultNode *pResNode , LONG_PTR lNotifyHandle )
{
    PROPSHEETPAGE psp;

    if( pPsc == NULL || pResNode == NULL )
    {
        return E_INVALIDARG;
    }

    m_pResNode = pResNode;

    m_hNotify = lNotifyHandle;

    BOOL bAlloc = FALSE;

    m_hMMCWindow = hMMC;

    m_pResNode->m_bEditMode = TRUE;

    // init array

    for( int x = 0; x < NUM_OF_PRSHT; x++ )
    {
        m_pDlg[ x ] = NULL;
    }

    do
    {
        m_pDlg[ 0 ] = ( CDialogPropBase * )new CGeneral( this );

        if( m_pDlg[ 0 ] == NULL )
        {
            ODS( L"CGeneral object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 1 ] = ( CDialogPropBase * )new CLogonSetting( this );

        if( m_pDlg[ 1 ] == NULL )
        {
            ODS( L"CLogonSetting object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 2 ] = ( CDialogPropBase * )new CTimeSetting( this );

        if( m_pDlg[ 2 ] == NULL )
        {
            ODS( L"CTimeSetting object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        // m_pDlg[ 3 ] = ( CDialogPropBase * )new CPerm( this );

        m_pDlg[ 3 ] = ( CDialogPropBase * )new CEnviro( this );

        if( m_pDlg[ 3 ] == NULL )
        {
            ODS( L"CEnviro object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 4 ] = ( CDialogPropBase * )new CRemote( this );

        if( m_pDlg[ 4 ] == NULL )
        {
            ODS( L"CRemote object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 5 ] = ( CDialogPropBase * )new CClient( this );

        if( m_pDlg[ 5 ] == NULL )
        {
            ODS( L"CClient object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 6 ] = ( CDialogPropBase * )new CTransNetwork( this );

        if( m_pDlg[ 6 ] == NULL )
        {
            ODS( L"CTransNetwork object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        m_pDlg[ 7 ] = ( CDialogPropBase * )new CTransAsync( this );

        if( m_pDlg[ 7 ] == NULL )
        {
            ODS( L"CTransAsync object allocation failed @ CPropsheet::InitDialogs\n" );

            break;
        }

        bAlloc = TRUE;

    }while( 0 );

    if( !bAlloc )
    {
        // try cleaning up before leaving

        for( x = 0; x < NUM_OF_PRSHT ; ++x )
        {
            if( m_pDlg[ x ] != NULL )
            {
                delete[] m_pDlg[x];
            }
        }

        return E_OUTOFMEMORY;
    }

    for( int idx = 0; idx < 5; ++idx )
    {
        if( m_pDlg[ idx ] != NULL )
        {
            if( !m_pDlg[ idx ]->GetPropertySheetPage( psp ) )
            {
                return E_UNEXPECTED;
            }

            if( FAILED( pPsc->AddPage( CreatePropertySheetPage( &psp ) ) ) )
            {
                return E_FAIL;
            }

        }

    }

    HRESULT hr = E_FAIL;

    if( m_pResNode != NULL )
    {
        ICfgComp *pCfgcomp = NULL;

        PWS pWinsta = NULL;

        // don't fail here third party vendor may want to use their own page

        if( m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            LONG cbSize;

            hr = pCfgcomp->GetWSInfo( m_pResNode->GetConName( ) , &cbSize , &pWinsta );

            if( SUCCEEDED( hr ) )
            {
                CDialogPropBase *pDlg = NULL;

                CDialogPropBase *pDlgClientSettings = m_pDlg[ 5 ]; // client settings

                if( pWinsta->PdClass == SdNetwork )
                {
                    pDlg = m_pDlg[ 6 ];
                }                
                else if( pWinsta->PdClass == SdAsync )
                {
                    pDlg = m_pDlg[ 7 ];
                }

                if( pDlg != NULL )
                {
                    if( !pDlgClientSettings->GetPropertySheetPage( psp ) )
                    {
                        ODS( L"Client settings page failed to load\n" );

                        hr = E_UNEXPECTED;
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        hr = pPsc->AddPage( CreatePropertySheetPage( &psp ) );

                    }

                    if( SUCCEEDED( hr ) )
                    {
                        if( !pDlg->GetPropertySheetPage( psp ) )
                        {
                            ODS( L"Transport page failed to load\n" );

                            hr = E_UNEXPECTED;
                        }
                    }

                    if( SUCCEEDED( hr ) )
                    {
                        hr = pPsc->AddPage( CreatePropertySheetPage( &psp ) );
                    }
                }

                CoTaskMemFree( pWinsta );

            }

            pCfgcomp->Release();
        }
    }

    if( SUCCEEDED( hr ) )
    {
        hr = pPsc->AddPage( GetSecurityPropertyPage( this ) );
    }

    return hr;

}

//The UC structure will contain data from a merger between the TSCC data and the machine policy data. We
//don't want all that written to the TSCC data though. If there's a machine policy for a given field, we
//want to replace its data with the data that currently exists in the TSCC section of the registry
BOOL CPropsheet::ExcludeMachinePolicySettings(USERCONFIG& uc)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    USERCONFIG origUC;

    //The default is to call GetUserConfig with a TRUE merge 
    //parameter, so we have to do that before we can call 
    //GetCurrentUserConfig which just returns the cached USERCONFIG structure
    if (!GetUserConfig(FALSE))
        return FALSE;
    if (!GetCurrentUserConfig(origUC, FALSE))
        return FALSE;
    //We have to do this so that the cached USERCONFIG structure 
    //will again have the expected (merged) data
    if (!GetUserConfig(TRUE))
        return FALSE;

    //CRemote fields
    if (p.fPolicyShadow)
    {
        uc.fInheritShadow = origUC.fInheritShadow;
        uc.Shadow = origUC.Shadow;
    }

    //CEnviro fields
    if (p.fPolicyInitialProgram)
    {
        uc.fInheritInitialProgram = origUC.fInheritInitialProgram;
        wcscpy(uc.InitialProgram, origUC.InitialProgram);
        wcscpy(uc.WorkDirectory, origUC.WorkDirectory);
    }

    //CClient fields
    if (p.fPolicyColorDepth)
    {
        uc.fInheritColorDepth = origUC.fInheritColorDepth;
        uc.ColorDepth = origUC.ColorDepth;
    }

    if (p.fPolicyForceClientLptDef)
        uc.fForceClientLptDef = origUC.fForceClientLptDef;
    
    if (p.fPolicyDisableCdm)
        uc.fDisableCdm = origUC.fDisableCdm;
    
    if (p.fPolicyDisableCpm)
        uc.fDisableCpm = origUC.fDisableCpm;

    if (p.fPolicyDisableLPT)
        uc.fDisableLPT = origUC.fDisableLPT;

    if (p.fPolicyDisableCcm)
        uc.fDisableCcm = origUC.fDisableCcm;

    if (p.fPolicyDisableClip)
        uc.fDisableClip = origUC.fDisableClip;

    if (p.fPolicyDisableCam)
        uc.fDisableCam = origUC.fDisableCam;

    //CLogonSetting fields
    if (p.fPolicyPromptForPassword)
        uc.fPromptForPassword = origUC.fPromptForPassword;

    //CGeneral fields
    if (p.fPolicyMinEncryptionLevel)
        uc.MinEncryptionLevel = origUC.MinEncryptionLevel;

    //CTimeSetting fields
    if (p.fPolicyMaxSessionTime)
        uc.MaxConnectionTime = origUC.MaxConnectionTime;

    if (p.fPolicyMaxDisconnectionTime)
        uc.MaxDisconnectionTime = origUC.MaxDisconnectionTime;

    if (p.fPolicyMaxIdleTime)
        uc.MaxIdleTime = origUC.MaxIdleTime;

    if (p.fPolicyResetBroken)
        uc.fResetBroken = origUC.fResetBroken;

    if (p.fPolicyReconnectSame)
        uc.fReconnectSame = origUC.fReconnectSame;

    if (p.fPolicyMaxSessionTime || p.fPolicyMaxDisconnectionTime || p.fPolicyMaxIdleTime)
        uc.fInheritMaxSessionTime = origUC.fInheritMaxSessionTime;
    
    if (p.fPolicyResetBroken)
        uc.fInheritResetBroken = origUC.fInheritResetBroken;

    if (p.fPolicyReconnectSame)
        uc.fInheritReconnectSame = origUC.fInheritReconnectSame;

    return TRUE;
}



//-------------------------------------------------------------------------------
// Use custom interface to persist uc to winstation
//-------------------------------------------------------------------------------
HRESULT CPropsheet::SetUserConfig( USERCONFIG& uc , PDWORD pdwStatus )
{
    ICfgComp *pCfgcomp;

    *pdwStatus = ERROR_INVALID_PARAMETER;

    if( m_pResNode == NULL )
        return E_FAIL;

    if( m_pResNode->GetServer( &pCfgcomp ) == 0 )
        return E_FAIL;

    if (!ExcludeMachinePolicySettings(uc))
        return E_FAIL;

    HRESULT hr = pCfgcomp->SetUserConfig( m_pResNode->GetConName( ) , 0, &uc , pdwStatus );

    if( SUCCEEDED( hr ) )
    {
        m_bGotUC = FALSE;
    }


    pCfgcomp->Release( );

    return hr;

}

//-------------------------------------------------------------------------------
// Use custom interface to obtain the winstation userconfig
// store it in m_puc -- and return t | f
//-------------------------------------------------------------------------------
BOOL CPropsheet::GetUserConfig(BOOLEAN bPerformMerger)
{
    ICfgComp *pCfgcomp;

    if( m_pResNode == NULL )
    {
        return FALSE;
    }

    if( m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        return FALSE;
    }

    LONG lSzReqd;

    if( m_puc != NULL )
    {
        CoTaskMemFree( m_puc );

        m_puc = NULL;
    }

    HRESULT hr = pCfgcomp->GetUserConfig( m_pResNode->GetConName( ) , &lSzReqd , &m_puc, bPerformMerger );

    if( FAILED( hr ) )
    {
        hr = pCfgcomp->GetDefaultUserConfig( m_pResNode->GetConName( ) , &lSzReqd , &m_puc );
    }

    pCfgcomp->Release( );
    
    return ( FAILED( hr ) ? FALSE: TRUE );

}

//-------------------------------------------------------------------------------
// Cache the uc
//-------------------------------------------------------------------------------
BOOL CPropsheet::GetCurrentUserConfig( USERCONFIG& uc, BOOLEAN bPerformMerger )
{
    if( !m_bGotUC )
    {
        m_bGotUC = GetUserConfig(bPerformMerger);
    }

    if( m_puc != NULL )
    {
        uc = *m_puc;
    }

    return m_bGotUC;
}

//*******************************************************************************
//-------------------------------------------------------------------------------
// OnNotify - base class method
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnNotify( int idCtrl , LPNMHDR pnmh , HWND hDlg )
{
    UNREFERENCED_PARAMETER( idCtrl );

    if( pnmh->code == PSN_APPLY )
    {
        if( !m_bPersisted )
        {
            m_bPersisted = PersistSettings( hDlg );
        }
    }

    else if( pnmh->code == PSN_KILLACTIVE )
    {
        if( !m_bPersisted )
        {
            if( !IsValidSettings( hDlg ) )
            {
                SetWindowLongPtr( hDlg , DWLP_MSGRESULT , PSNRET_INVALID_NOCHANGEPAGE );

                return TRUE;
            }

        }
    }

    return FALSE;
}

//-------------------------------------------------------------------------------
// OnCOntextMenu -- base class operation
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnContextMenu( HWND hwnd , POINT& pt )
{
    UNREFERENCED_PARAMETER( pt );

    TCHAR tchHelpFile[ MAX_PATH ];

    ODS( L"CDialogPropBase::OnContextMenu\n" );

    if( m_hWnd == GetParent( hwnd ) )
    {
        //
        // Make sure its not a dummy window
        //

        if( GetDlgCtrlID( hwnd ) <= ( int )-1 )
        {
            return FALSE;
        }

        ULONG_PTR rgdw[ 2 ];

        rgdw[ 0 ] = GetDlgCtrlID( hwnd );

        rgdw[ 1 ] = GetWindowContextHelpId( hwnd );

        LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

        WinHelp( hwnd , tchHelpFile , HELP_CONTEXTMENU , ( ULONG_PTR )&rgdw );

    }

    return TRUE;
}

//-------------------------------------------------------------------------------
// Each control has a helpid assign to them.  Some controls share the same topic
// check for these.
//-------------------------------------------------------------------------------
BOOL CDialogPropBase::OnHelp( HWND hwnd , LPHELPINFO lphi )
{
    UNREFERENCED_PARAMETER( hwnd );

    TCHAR tchHelpFile[ MAX_PATH ];

    //
    // For the information to winhelp api
    //

    if( IsBadReadPtr( lphi , sizeof( HELPINFO ) ) )
    {
        return FALSE;
    }
    
    if( (short)lphi->iCtrlId <= -1 )
    {
        return FALSE;
    }

    LoadString( _Module.GetModuleInstance( ) , IDS_HELPFILE , tchHelpFile , SIZE_OF_BUFFER( tchHelpFile ) );

    DWORD rgdw[ 4 ] = {0,0,0,0};

    rgdw[ 0 ] = ( DWORD )lphi->iCtrlId;

    rgdw[ 1 ] = ( DWORD )lphi->dwContextId;

    WinHelp( ( HWND )lphi->hItemHandle , tchHelpFile , HELP_WM_HELP , ( ULONG_PTR )&rgdw );//lphi->dwContextId );

    return TRUE;
}

//*****************************************************************************
//                  General dialog

CGeneral::CGeneral( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_pEncrypt = NULL;

    m_DefaultEncryptionLevelIndex = 0;

    m_nOldSel = ( INT_PTR )-1;
}

//-----------------------------------------------------------------------------
BOOL CGeneral::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CGeneral::OnInitDialog - PropertySheet: Parent object lost!!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    ZeroMemory( &uc , sizeof( USERCONFIG ) );

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CGeneral::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!!\n" );

        return FALSE;
    }

    // Security

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_AUTHEN ) , BM_SETCHECK , ( WPARAM )uc.fUseDefaultGina , 0 );

    // Network Transport

    if( m_pParent->m_pResNode == NULL )
    {
        return FALSE;
    }

    ICfgComp *pCfgcomp;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    do
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            break;
        }

        // Set Connection name

        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CONNAME ) , m_pParent->m_pResNode->GetConName( ) );

        PWS pWinSta = NULL;

        if( SUCCEEDED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , EM_SETLIMITTEXT , ( WPARAM )WINSTATIONCOMMENT_LENGTH , 0 );

            SetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , pWinSta->Comment );

            //m_pParent->m_pResNode->GetComment( ) );

            SetWindowText( GetDlgItem( hDlg , IDC_STATIC_GEN_TYPE ) , m_pParent->m_pResNode->GetTypeName( ) );

            SetWindowText(  GetDlgItem( hDlg , IDC_EDIT_GENERAL_TRANSPORT ) , pWinSta->pdName );

            // security

            // Encryption *pEncrypt;

            if( SUCCEEDED( pCfgcomp->GetEncryptionLevels( m_pParent->m_pResNode->GetConName( ) , WsName , &ulItems , &m_pEncrypt ) ) )
            {
                BOOL bSet = FALSE;

                for( ULONG i = 0; i < ulItems; ++i )
                {
                    SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_ADDSTRING , 0 , ( LPARAM )m_pEncrypt[ i ].szLevel );
                    if(m_pEncrypt[ i ].Flags & ELF_DEFAULT)
                    {
                        m_DefaultEncryptionLevelIndex = i;
                    }

                    if( uc.MinEncryptionLevel == m_pEncrypt[ i ].RegistryValue )
                    {
                        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_SETCURSEL ,  ( WPARAM )i , 0);

                        bSet = TRUE;

                    }
                }

                POLICY_TS_MACHINE p;
                RegGetMachinePolicy(&p);
                EnableWindow(GetDlgItem(hDlg, IDC_COMBO_GEN_ENCRYPT), !p.fPolicyMinEncryptionLevel);

                if (p.fPolicyFipsEnabled)
                {
                    // FIPS is always the last item in the list so set it as selected                            
                    SendMessage(GetDlgItem(hDlg, IDC_COMBO_GEN_ENCRYPT), CB_SETCURSEL, (WPARAM)ulItems - 1 , 0);
                    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_GEN_ENCRYPT), FALSE);
                }

                if(!bSet)
                {
                    uc.MinEncryptionLevel = (UCHAR)(m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue);

                    SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_SETCURSEL ,  ( WPARAM )m_DefaultEncryptionLevelIndex, 0 );
                }

                OnCommand( CBN_SELCHANGE , IDC_COMBO_GEN_ENCRYPT , GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) );

                if( !IsWindowEnabled( GetDlgItem( hDlg , IDC_STATIC_GEN_DESCR ) ) )
                {
                    RECT rc;
                    RECT rc2;

                    GetWindowRect( GetDlgItem( hDlg , IDC_STATIC_CONGRP ) , &rc );

                    GetWindowRect( GetDlgItem( hDlg , IDC_STATIC_GEN_DESCR ) , &rc2 );

                    rc.bottom = rc2.top;

                    MapWindowPoints( NULL , hDlg , ( LPPOINT )&rc , 2 );

                    SetWindowPos( GetDlgItem( hDlg , IDC_STATIC_CONGRP ) , 0 , 0 , 0 , rc.right - rc.left , rc.bottom - rc.top , SWP_NOMOVE | SWP_SHOWWINDOW );


                    //resize window
                }
            }
            else
            {
                // no encryption info insert value to none and grey out the control
                TCHAR tchNone[ 80 ];

                LoadString( _Module.GetResourceInstance( ) , IDS_NONE , tchNone , SIZE_OF_BUFFER( tchNone ) );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , CB_ADDSTRING , 0 , ( LPARAM )tchNone );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , CB_SETCURSEL , 0 , 0 );

                EnableWindow( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT )  , FALSE );

                EnableWindow( GetDlgItem( hDlg , IDC_STATIC_CONGRP )  , FALSE );
            }

            CoTaskMemFree( pWinSta );
        }

        // check to see if session is readonly

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls
                INT rgIds[] = {  IDC_CHECK_GEN_AUTHEN , IDC_STATIC_CONGRP, IDC_COMBO_GEN_ENCRYPT , -1 };

                EnableGroup( hDlg , &rgIds[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );


    }while( 0 );

   m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}


//-----------------------------------------------------------------------------
INT_PTR CALLBACK CGeneral::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CGeneral *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CGeneral *pDlg = ( CGeneral * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CGeneral ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CGeneral * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CGeneral ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

       pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CGeneral::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED || wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == CBN_SELCHANGE && wID == IDC_COMBO_GEN_ENCRYPT )
    {
        if( SendMessage( hwndCtrl , CB_GETDROPPEDSTATE , 0 , 0 ) == FALSE )
        {
            INT_PTR nSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

            if( nSel != CB_ERR )
            {
                if( nSel != m_nOldSel && m_pEncrypt != NULL )
                {
                    if( m_pEncrypt[ nSel ].szDescr[ 0 ] == 0 )
                    {
                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , FALSE );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , FALSE );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , SW_HIDE );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , SW_HIDE );
                    }
                    else
                    {
                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , SW_SHOW  );

                        ShowWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , SW_SHOW );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) , TRUE );

                        EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCRTITLE ) , TRUE );

                        SetWindowText( GetDlgItem( GetParent( hwndCtrl ) , IDC_STATIC_GEN_DESCR ) ,  m_pEncrypt[ nSel ].szDescr );
                    }

                    m_bPersisted = FALSE;

                    m_nOldSel = nSel;
                }
            }
        }

    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }


    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CGeneral::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_GENERAL );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CGeneral::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CGeneral::PersistSettings( HWND hDlg )
{
    HRESULT hr;

    if( IsValidSettings( hDlg ) )
    {
        ICfgComp *pCfgcomp;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        WS *pWinsta = NULL;

        LONG lSize = 0;

        hr = pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , &lSize , &pWinsta );

        if( SUCCEEDED( hr ) )
        {
            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , pWinsta->Comment , WINSTATIONCOMMENT_LENGTH + 1 );

            m_pParent->m_pResNode->SetComment( pWinsta->Comment , lstrlen( pWinsta->Comment ) );

            DWORD dwStatus;

            hr = pCfgcomp->UpDateWS( pWinsta , UPDATE_COMMENT , &dwStatus, FALSE );

            if( FAILED( hr ) )
            {
                // report error

                ReportStatusError( GetDlgItem( hDlg , IDC_EDIT_GEN_COMMENT ) , dwStatus );
            }

            CoTaskMemFree( pWinsta );
        }

        if( SUCCEEDED( hr ) )
        {

            USERCONFIG uc;

            if( m_pParent->GetCurrentUserConfig( uc, TRUE ) )
            {
                if( m_pEncrypt != NULL )
                {
                    UINT index = ( UCHAR )SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_ENCRYPT ) , CB_GETCURSEL , 0 , 0 );

                    if(index == CB_ERR )
                    {
                        uc.MinEncryptionLevel =(UCHAR) m_pEncrypt[m_DefaultEncryptionLevelIndex].RegistryValue;
                    }
                    else
                    {
                        uc.MinEncryptionLevel = (UCHAR) m_pEncrypt[index].RegistryValue;
                    }
                }
                else
                {
                    uc.MinEncryptionLevel = 0;
                }

                uc.fUseDefaultGina = SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_AUTHEN ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;

                DWORD dwStatus = 0;

                hr = m_pParent->SetUserConfig( uc , &dwStatus );

                if( FAILED( hr ) )
                {
                    // report error

                    ReportStatusError( hDlg , dwStatus );
                }
            }
        }

        if( SUCCEEDED( hr ) )
        {
            ODS( L"TSCC : Forcing reg update on General Page\n" );

            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

            SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

            return TRUE;
        }


        pCfgcomp->Release( );
    }

    return FALSE;
}


//-----------------------------------------------------------------------------
BOOL CGeneral::OnDestroy( )
{
    if( m_pEncrypt != NULL )
    {
        CoTaskMemFree( m_pEncrypt );

        m_pEncrypt = NULL;
    }

    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );

}

//*****************************************************************************

CTransNetwork::CTransNetwork( CPropsheet *pSheet )
{
    ASSERT( pSheet != NULL );

    m_pParent = pSheet;

    // this now behaves as the last combx selection

    m_ulOldLanAdapter = ( ULONG )-1;

    m_oldID = ( WORD )-1;

    m_uMaxInstOld = ( ULONG )-1;

}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTransNetwork::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTransNetwork *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTransNetwork *pDlg = ( CTransNetwork * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTransNetwork ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTransNetwork * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTransNetwork ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    BOOL bReadOnly;
    HICON hIcon;

    m_pParent->AddRef( );

    SendMessage( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , UDM_SETRANGE32 , 0 , ( LPARAM )999999 );

    if( m_pParent->m_pResNode == NULL )
    {
        m_bPersisted = TRUE;
        return FALSE;
    }

    ICfgComp *pCfgcomp = NULL;

    ULONG cbSize = 0;

    ULONG ulItems = 0;

    PGUIDTBL pGuidtbl = NULL;

    do
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            ODS( L"CTransNetwork::OnInitDialog - GetServer failed\n" );

            break;
        }

        WS *pWinSta = NULL;

        pCfgcomp->ForceUpdate();
        pCfgcomp->Refresh();
        if( FAILED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {
            ODS( L"TSCC: GetWSInfo failed in TransNetwork::OnInitDialog\n" );

            break;
        }

        ISettingsComp* pISettingComp = NULL;
        HRESULT hr;
        DWORD dwStatus;
        DWORD nVal;        

        hr = pCfgcomp->QueryInterface( IID_ISettingsComp, (void **) &pISettingComp );

        //
        // Assume we are not remote admin if anything go wrong
        //
        m_RemoteAdminMode = FALSE;

        if( SUCCEEDED(hr) && NULL != pISettingComp )
        {
            hr = pISettingComp->GetTermSrvMode( &nVal, &dwStatus );
            if( SUCCEEDED(hr) && nVal == 0 )
            {
                // we are in RA mode
                m_RemoteAdminMode = TRUE;
            }

            pISettingComp->Release();
        }

        if( FAILED(hr) )
        {
            //
            // QueryInterface() or GetTermSrvMode() failed
            // bring up a error message
            //
            TCHAR tchMessage[ 256 ];

            TCHAR tchWarn[ 40 ];

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_TERMSRVMODE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

            MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_OK );

        }


        // certain operations cannot be performed if the user is not part of the admin group

        pCfgcomp->IsSessionReadOnly( &bReadOnly );


        // Set Connection name

        SetWindowText( GetDlgItem( hDlg , IDC_STATIC_CONNAME ) , m_pParent->m_pResNode->GetConName( ) );

        // List all supported lan adapters for transport type

        ULONG idx;

        if( SUCCEEDED( pCfgcomp->GetLanAdapterList2( m_pParent->m_pResNode->GetTTName() , &ulItems , &pGuidtbl ) ) )
        {
            // verify table is valid

            BOOL bFound = FALSE;

            for( idx = 0 ; idx < ulItems ; ++idx )
            {
                if( pGuidtbl[ idx ].dwStatus != ERROR_SUCCESS && !bReadOnly )
                {
                    pCfgcomp->BuildGuidTable( &pGuidtbl , ulItems , m_pParent->m_pResNode->GetTTName() );

                    break;
                }
            }

            for( idx = 0 ; idx < ulItems ; ++idx )
            {
                if( pGuidtbl[ idx ].dwLana == pWinSta->LanAdapter )
                {
                    bFound = TRUE;

                    break;
                }
            }

            if( !bFound )
            {
                if( !bReadOnly )
                {
                    // Notify user we must rebuild guid table
                    TCHAR tchMessage[ 256 ];

                    TCHAR tchTitle[ 80 ];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_INVALNETWORK , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

                    MessageBox( hDlg , tchMessage , tchTitle , MB_OK | MB_ICONINFORMATION );

                    m_bPersisted = FALSE;

                    SendMessage( GetParent( hDlg ) , PSM_CHANGED , ( WPARAM )hDlg , 0 );
                }

                // reset lana index

                pWinSta->LanAdapter = ( DWORD )-1;

            }

            for( idx = 0 ; idx < ulItems; ++idx )
            {
                if( pGuidtbl[ idx ].dwLana == pWinSta->LanAdapter )
                {
                    // make sure we only set this once
                    // invalid entries will have dwLana set to zero

                    if( m_ulOldLanAdapter == ( DWORD )-1 )
                    {
                        m_ulOldLanAdapter = idx;
                    }
                }

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_ADDSTRING , 0 , ( LPARAM )pGuidtbl[ idx ].DispName );

                SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETITEMDATA , idx , ( LPARAM )pGuidtbl[ idx ].dwLana );
            }

            CoTaskMemFree( pGuidtbl );
        }


        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETCURSEL , ( WPARAM )m_ulOldLanAdapter , 0 );


        if( !m_bPersisted )
        {
            // force IsValidSettings to confirm on the lana uniqueness

            m_ulOldLanAdapter = ( DWORD )-1;
        }


        TCHAR tchMaxConnectionsBuf[6]; // max digits
        SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETLIMITTEXT , SIZE_OF_BUFFER(tchMaxConnectionsBuf)  , 0  );

        BOOL bUnlimitedConnections = FALSE;

        m_uMaxInstOld = pWinSta->uMaxInstanceCount;

        if( TRUE == m_RemoteAdminMode )
        {
            //Display the warning icon
            hIcon = LoadIcon(_Module.GetModuleInstance() , MAKEINTRESOURCE(IDI_ICON_WARNING));
            hIcon = (HICON)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_ICON_WARNING), IMAGE_ICON, 0, 0, 0);
            SendMessage(GetDlgItem(hDlg, IDC_USERPERM_ICON) , STM_SETICON, (WPARAM)hIcon, 0);
            ShowWindow(GetDlgItem(hDlg, IDC_USERPERM_ICON), SW_SHOW);
            
            //Display the warning text
            ShowWindow(GetDlgItem(hDlg, IDC_TSMSTATIC_RA), SW_SHOW);

            //Limit the max connections to 2
            wsprintf(tchMaxConnectionsBuf, L"%d" , 
                    (pWinSta->uMaxInstanceCount > 2 || pWinSta->uMaxInstanceCount == (ULONG) -1) ? 2 : pWinSta->uMaxInstanceCount);
            SendMessage(GetDlgItem(hDlg , IDC_SPINCTR_GEN), UDM_SETRANGE32, 0, (LPARAM)2);

            //Unlimited connections isn't an option
            bUnlimitedConnections = FALSE;
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_GEN_UNLIMITED), FALSE);
        }
        else
        {
            bUnlimitedConnections = (pWinSta->uMaxInstanceCount == (ULONG)-1);

            //Set the max number of connections
            wsprintf(tchMaxConnectionsBuf, L"%d", pWinSta->uMaxInstanceCount);
        }

        //If we're in read only mode, the NIC selector control should be disabled
        if(bReadOnly)
            EnableWindow(GetDlgItem(hDlg, IDC_COMBO_GEN_LANADAPTER), FALSE);

        //If we're in read only mode or a global policy exists, the user shouldn't
        //be able to change the max number of connections
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);
        if (bReadOnly || p.fPolicyMaxInstanceCount)
        {
            //Disable the radio buttons
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_GEN_UNLIMITED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_RADIO_MAXPROP), FALSE);

            // if user have only read access, disable MAX connection and its associated spin control
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_GEN_MAXCONS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SPINCTR_GEN), FALSE);
        }

        if (!bUnlimitedConnections)
        {
            m_oldID = IDC_RADIO_MAXPROP; 
            SetWindowText(GetDlgItem(hDlg, IDC_EDIT_GEN_MAXCONS), tchMaxConnectionsBuf);
        }
        else
        {
            m_oldID = IDC_CHECK_GEN_UNLIMITED;
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_GEN_MAXCONS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SPINCTR_GEN), FALSE);
        }

        //Select the appropriate radio button
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_GEN_UNLIMITED), BM_SETCHECK, (WPARAM)(bUnlimitedConnections), 0);
        SendMessage(GetDlgItem(hDlg, IDC_RADIO_MAXPROP), BM_SETCHECK, (WPARAM)(!bUnlimitedConnections), 0);

        CoTaskMemFree( pWinSta );

        pCfgcomp->Release( );

    }while( 0 );

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_NETWORK_FACE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTransNetwork::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED || wNotifyCode == EN_CHANGE )// || wNotifyCode == CBN_SELCHANGE )
    {
        if( wID == IDC_CHECK_GEN_UNLIMITED )
        {
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPINCTR_GEN ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_MAXPROP),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);


        }

		else if(wID == IDC_RADIO_MAXPROP)
		{
            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            EnableWindow( GetDlgItem( GetParent( hwndCtrl ) , IDC_SPINCTR_GEN ) ,

                SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );

            SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_GEN_UNLIMITED),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

            SetFocus( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

		}

        if ((wID == IDC_CHECK_GEN_UNLIMITED) || (wID == IDC_RADIO_MAXPROP))
        {
            if( wID != m_oldID )
            {
                m_bPersisted = FALSE;
                m_oldID = wID;
            }
        }

        if (wID == IDC_EDIT_GEN_MAXCONS)
            m_bPersisted = FALSE;
    }

    else if( wNotifyCode == CBN_SELCHANGE )
    {
        INT_PTR iSel = SendMessage( hwndCtrl , CB_GETCURSEL , 0 , 0 );

        if( iSel != ( INT_PTR )m_ulOldLanAdapter )
        {
            m_bPersisted = FALSE;
        }
    }


    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::PersistSettings( HWND hDlg )
{
    BOOL bOk = FALSE;

    if( IsValidSettings( hDlg ) )
    {
        ICfgComp *pCfgcomp;

        bOk = TRUE;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        WS winsta;

        ZeroMemory( &winsta , sizeof( WS ) );

        //If a group policy exists, its data will be in the winsta structure. We don't want to write that to 
        //the TSCC registry, so read the TSCC data by getting the User Config without merging the machine policy
        POLICY_TS_MACHINE p;
        RegGetMachinePolicy(&p);

        if (p.fPolicyMaxInstanceCount)
        {
            POLICY_TS_MACHINE pTemp;
            ULONG Length = 0;
            WINSTATIONCONFIG2W WSConfig;
        
            memset(&pTemp, 0, sizeof(POLICY_TS_MACHINE));
            if((ERROR_SUCCESS != RegWinStationQueryEx(NULL,&pTemp,m_pParent->m_pResNode->GetConName( ),&WSConfig,sizeof(WINSTATIONCONFIG2W),&Length,FALSE)))
                return FALSE;

            winsta.uMaxInstanceCount = WSConfig.Create.MaxInstanceCount;
        }
        else
        {
            if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ), BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
                winsta.uMaxInstanceCount = ( ULONG )-1;
            else
                winsta.uMaxInstanceCount = GetDlgItemInt( hDlg , IDC_EDIT_GEN_MAXCONS , &bOk , FALSE );
        }

        INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETCURSEL , 0 , 0 );

        winsta.LanAdapter = ( ULONG )SendMessage(
                                        GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) ,
                                        CB_GETITEMDATA ,
                                        ( WPARAM )iSel ,
                                        0 );

        if( iSel != CB_ERR )
        {
            if( iSel != ( INT_PTR )m_ulOldLanAdapter )
            {
                LONG lCount;

                pCfgcomp->QueryLoggedOnCount( m_pParent->m_pResNode->GetConName( ) , &lCount );

                if( lCount > 0 )
                {
                    // Warn user, changing an active lan adapter will cause all connections to disconnect

                    TCHAR tchMessage[ 256 ];

                    TCHAR tchWarn[ 40 ];

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_LANCHANGE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                    if( MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_YESNO ) == IDNO )
                    {
                        bOk = FALSE;
                    }
                }
            }
        }

        if( bOk && iSel != CB_ERR )
        {
            lstrcpyn( winsta.Name , m_pParent->m_pResNode->GetConName( ) , SIZE_OF_BUFFER( winsta.Name ) - 1 );

            DWORD dwStatus;
            
            DWORD dwUpdateFlags = UPDATE_LANADAPTER;
            if (!p.fPolicyMaxInstanceCount)
                dwUpdateFlags |= UPDATE_MAXINSTANCECOUNT;

            if( FAILED( pCfgcomp->UpDateWS( &winsta , dwUpdateFlags , &dwStatus, FALSE ) ) )
            {
                // report error and get out

                ReportStatusError( hDlg , dwStatus );

                pCfgcomp->Release( );

            }
            else
            {
                ODS( L"Connection LANA persisted\n" );

                m_ulOldLanAdapter = ( ULONG )iSel;

                ODS( L"TSCC : Forcing reg update - CTransNetwork\n" );

                VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

                VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

                // global flag can only be set to true

                m_pParent->m_bPropertiesChange = TRUE;

                PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

                SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

            }

        }

        pCfgcomp->Release( );

    }

    return bOk;
}

//-----------------------------------------------------------------------------
BOOL CTransNetwork::IsValidSettings( HWND hDlg )
{
    BOOL ret = TRUE;

    ICfgComp *pCfgcomp;

    TCHAR tchMessage[ 256 ];

    TCHAR tchWarn[ 40 ];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ), BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        UINT uMax;

        BOOL bOK = FALSE;

        uMax = GetDlgItemInt( hDlg , IDC_EDIT_GEN_MAXCONS , &bOK , FALSE );

        if( !bOK )
        {
            ErrMessage( hDlg , IDS_ERR_CONREADFAIL );

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

            return FALSE;
        }

        if( uMax > 999999UL )
        {
            ErrMessage( hDlg , IDS_ERR_CONMAX );

            SetFocus( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) );

            SendMessage( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

            return FALSE;
        }
    }

    if( m_pParent != NULL && m_pParent->m_pResNode != NULL )
    {
        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
        {
            return FALSE;
        }

        // PDNAMEW pName;

        PWS pWinSta;

        LONG cbSize;

        if( SUCCEEDED( pCfgcomp->GetWSInfo( m_pParent->m_pResNode->GetConName( ) , ( PLONG )&cbSize , &pWinSta ) ) )
        {
            INT_PTR iSel = SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETCURSEL , 0 , 0 );

            BOOL bUnique = TRUE;

            if( iSel != CB_ERR )
            {
                if( iSel != ( int )m_ulOldLanAdapter )
                {
                    ULONG nStations;

					VERIFY_S( S_OK , pCfgcomp->GetNumofWinStations(pWinSta->wdName,pWinSta->pdName,&nStations ) );

                    DBGMSG( L"TSCC: Number of winstations equals = %d\n" , nStations );

                    if( nStations > 1 )
                    {
                        ODS( L"TSCC: We have more than one winstation verify unique lana settings\n" );

                        ULONG ulLana = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_GETITEMDATA , ( WPARAM )iSel , 0 );

                        VERIFY_S( S_OK , pCfgcomp->IsNetWorkConnectionUnique( m_pParent->m_pResNode->GetTypeName( ) , pWinSta->pdName , ulLana , &bUnique ) );
                    }

                    if( !bUnique )
                    {
                        //ErrMessage( hDlg , IDS_ERR_UNIQUECON );
                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_UNIQUECON , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                        MessageBox( hDlg , tchMessage , tchWarn , MB_ICONINFORMATION | MB_OK );

                        ret = FALSE;
                    }
                    else
                    {
                        LONG lCount;

                        pCfgcomp->QueryLoggedOnCount( m_pParent->m_pResNode->GetConName( ) , &lCount );

                        if( lCount > 0 )
                        {
                            // Warn user, changing an active lan adapter will cause all connections to disconnect
                            TCHAR tchMessage[ 256 ];

                            TCHAR tchWarn[ 40 ];

                            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_ERR_LANCHANGE , tchMessage , SIZE_OF_BUFFER( tchMessage ) ) );

                            VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_WARN_TITLE , tchWarn , SIZE_OF_BUFFER( tchWarn ) ) );

                            if( MessageBox( hDlg , tchMessage , tchWarn , MB_ICONWARNING | MB_YESNO ) == IDNO )
                            {
                                ret = FALSE;
                            }
                        }
                    }

                    if( ret )
                    {
                        m_ulOldLanAdapter = (ULONG)iSel;
                    }
                }

            }

            CoTaskMemFree( pWinSta );
        }

        pCfgcomp->Release( );
    }

    if( !ret )
    {
        if( m_uMaxInstOld == ( ULONG )-1 )
        {
            EnableWindow( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , FALSE );

            EnableWindow( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , FALSE );

            SendMessage( GetDlgItem( hDlg , IDC_CHECK_GEN_UNLIMITED ) , BM_CLICK , 0 , 0 );

            m_oldID = IDC_CHECK_GEN_UNLIMITED;
        }
        else
        {
            TCHAR tchBuf[ 16 ];

            EnableWindow( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , TRUE );

            EnableWindow( GetDlgItem( hDlg , IDC_SPINCTR_GEN ) , TRUE );

            wsprintf( tchBuf , L"%d" , m_uMaxInstOld );

            SetWindowText( GetDlgItem( hDlg , IDC_EDIT_GEN_MAXCONS ) , tchBuf );

            SendMessage( GetDlgItem( hDlg , IDC_RADIO_MAXPROP) , BM_CLICK , 0 , 0 );

            m_oldID = IDC_RADIO_MAXPROP;

        }

        SendMessage( GetDlgItem( hDlg , IDC_COMBO_GEN_LANADAPTER ) , CB_SETCURSEL , ( WPARAM )m_ulOldLanAdapter , 0 );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        m_bPersisted = TRUE;
    }

    return ret;
}

//*****************************************************************************
CTransAsync::CTransAsync( CPropsheet * pSheet )
{
    m_pParent = pSheet;    
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    ICfgComp *pCfgcomp = NULL;

    m_pParent->AddRef( );

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Cound not obtain backend interface @  CTransAsync::OnInitDialog\n" );

        return FALSE;
    }

    
    VERIFY_S( TRUE , m_pParent->GetCurrentUserConfig( m_uc, TRUE ) );

    pCfgcomp->GetAsyncConfig( m_pParent->m_pResNode->GetConName() , WsName , &m_ac );

    VERIFY_S( TRUE , CAsyncDlg::OnInitDialog( hwnd , m_pParent->m_pResNode->GetTypeName( ) , m_pParent->m_pResNode->GetConName( ) , pCfgcomp ) ) ;

    BOOL bReadOnly;

    if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
    {
        if( bReadOnly )
        {
            // disable the remaining controls
            INT rgIds[] = {
                IDC_ASYNC_DEVICENAME,
                    IDC_ASYNC_CONNECT,
                    IDC_ASYNC_BAUDRATE,
                    IDC_ASYNC_MODEMCALLBACK_PHONENUMBER,
                    IDC_ASYNC_MODEMCALLBACK_PHONENUMBER_INHERIT,
                    IDC_ASYNC_MODEMCALLBACK,
                    IDC_ASYNC_MODEMCALLBACK_INHERIT,
                    IDC_MODEM_PROP_PROP,
                    IDC_ASYNC_DEFAULTS,
                    IDC_ASYNC_ADVANCED,
                    IDC_ASYNC_TEST, -1
            };


            EnableGroup( hwnd , &rgIds[ 0 ] , FALSE );

        }
    }

    pCfgcomp->Release( );

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTransAsync::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTransAsync *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTransAsync *pDlg = ( CTransAsync * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTransAsync ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTransAsync * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTransAsync ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ASYNC_FACE );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTransAsync::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnDestroy( )
{
    AsyncRelease( );
    
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CTransAsync::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{

    CAsyncDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &m_bPersisted );
    
    if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTransAsync::PersistSettings( HWND hDlg )
{
    if( !IsValidSettings( hDlg ) )
    {
        return FALSE;
    }

    ICfgComp * pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"Cound not obtain backend interface @  CTransAsync::OnInitDialog\n" );

        return FALSE;
    }

    DWORD dwStatus;

    HRESULT hr = pCfgcomp->SetAsyncConfig( m_pParent->m_pResNode->GetConName() , WsName , &m_ac , &dwStatus );

    if( FAILED( hr ) )
    {
        ReportStatusError( hDlg , dwStatus );
    }

    if( SUCCEEDED( hr ) )
    {
        DWORD dwStatus;

        hr = m_pParent->SetUserConfig( m_uc , &dwStatus );

        if( FAILED( hr ) )
        {
            ReportStatusError( hDlg , dwStatus );
        }
    }

    if( SUCCEEDED( hr ) )
    {
        ODS( L"TSCC : Forcing reg update - CTransAsync\n" );

        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );
    }


    pCfgcomp->Release( );

    return SUCCEEDED( hr ) ? TRUE : FALSE;
}

BOOL CTransAsync::IsValidSettings(HWND hDlg)
{
    UNREFERENCED_PARAMETER( hDlg );
    // all async connections are checked for usage
    // thus no two connections can use the same port

    return TRUE;
}


//*****************************************************************************
//                  Logon settings dialog

CLogonSetting::CLogonSetting( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldId = ( WORD )-1;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( !IsBadReadPtr( m_pParent , sizeof( CPropsheet ) ) )
    {
        m_pParent->AddRef( );
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CLogonSetting::OnInitDialog - GetCurrentUserConfig failed!!!\n" );

        return FALSE;
    }

    /*
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_SETCHECK ,

        uc.fInheritAutoLogon ? BST_CHECKED : BST_UNCHECKED , 0 );*/

    if( uc.fInheritAutoLogon == BST_CHECKED )
    {
        CheckRadioButton( hDlg , IDC_CHECK_LOGON_INHERIT , IDC_RADIO_LOGON , IDC_CHECK_LOGON_INHERIT );

        m_wOldId = IDC_CHECK_LOGON_INHERIT;
    }
    else
    {
        CheckRadioButton( hDlg , IDC_CHECK_LOGON_INHERIT , IDC_RADIO_LOGON , IDC_RADIO_LOGON );

        m_wOldId = IDC_RADIO_LOGON;
    }


    SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ), BM_SETCHECK ,
        uc.fPromptForPassword ? BST_CHECKED : BST_UNCHECKED , 0 );

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    EnableWindow( GetDlgItem( hDlg, IDC_CHECK_LOGON_PROMPTPASSWD ), !p.fPolicyPromptForPassword);

    //int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_EDIT_LOGON_DOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_EDIT_LOGON_CONFIRMPASSWD , -1 };

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , EM_SETLIMITTEXT , ( WPARAM )USERNAME_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , EM_SETLIMITTEXT , ( WPARAM )DOMAIN_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , EM_SETLIMITTEXT , ( WPARAM )PASSWORD_LENGTH , 0 );

    if( !uc.fInheritAutoLogon )
    {
        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , ( LPTSTR )uc.UserName );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , ( LPTSTR )uc.Domain );
    }

    if( !uc.fPromptForPassword )
    {
        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , ( LPTSTR )uc.Password );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , ( LPTSTR )uc.Password );
    }

    int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_STATIC_LSUSR ,  IDC_EDIT_LOGON_DOMAIN , IDC_STATIC_LSDOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_STATIC_LSPWD , IDC_EDIT_LOGON_CONFIRMPASSWD , IDC_STATIC_LSCONPWD , -1 };

    EnableGroup( hDlg , &rgID[0] , !uc.fInheritAutoLogon );

    if( !uc.fInheritAutoLogon )
    {
        EnableGroup( hDlg , &rgID[4] , !uc.fPromptForPassword );
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {
        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls

                INT rgIds[] = {
                        IDC_EDIT_LOGON_PASSWD,
                        IDC_EDIT_LOGON_CONFIRMPASSWD,
                        IDC_CHECK_LOGON_PROMPTPASSWD,
                        IDC_CHECK_LOGON_INHERIT,
                        IDC_RADIO_LOGON,
                        -1
                };

                EnableGroup( hDlg , &rgIds[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }



    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CLogonSetting::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CLogonSetting *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CLogonSetting *pDlg = ( CLogonSetting * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CLogonSetting ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CLogonSetting * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CLogonSetting ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_LOGONSETTINGS );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CLogonSetting::DlgProc;

    return TRUE;

}

//---------------------------------------------------------------------------
BOOL CLogonSetting::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
       int rgID[] = { IDC_EDIT_LOGON_USRNAME , IDC_STATIC_LSUSR ,  IDC_EDIT_LOGON_DOMAIN , IDC_STATIC_LSDOMAIN , IDC_EDIT_LOGON_PASSWD , IDC_STATIC_LSPWD , IDC_EDIT_LOGON_CONFIRMPASSWD , IDC_STATIC_LSCONPWD , -1 };

       BOOL bEnable = ( BOOL )SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED;


       if( wID == IDC_CHECK_LOGON_INHERIT )
       {
           EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , bEnable );

           if( bEnable )
           {
               EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );

               SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LOGON),BM_SETCHECK,(WPARAM)BST_CHECKED,0);

           }
           else
           {
               SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_RADIO_LOGON),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);
           }
       }
       else if( wID == IDC_CHECK_LOGON_PROMPTPASSWD )
       {
           if( bEnable )
           {
               EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED );
           }

           // make sure apply button becomes enabled when user checks this box

           m_bPersisted = FALSE;
       }
       else if( wID == IDC_RADIO_LOGON )
       {
           BOOL bChecked = SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ;

            if(bChecked)
            {
                //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LOGON_INHERIT),BM_SETCHECK,(WPARAM)BST_UNCHECKED,0);

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 0 ] , TRUE );

                EnableGroup( GetParent( hwndCtrl ) , &rgID[ 4 ] , !( SendMessage( GetDlgItem( GetParent( hwndCtrl ) , IDC_CHECK_LOGON_PROMPTPASSWD )  , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ) );

            }
            else
            {
                SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_LOGON_INHERIT),BM_SETCHECK,(WPARAM)BST_CHECKED,0);
            }
            //SendMessage(GetDlgItem(GetParent(hwndCtrl), IDC_CHECK_ICCP_WZ),BM_CLICK,0,0);

       }

       // if radio button from the last is different enabled the apply button

       if( m_wOldId != wID )
       {
           m_wOldId = wID;

           m_bPersisted = FALSE;
       }


    }

    else if( wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }

    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }


    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;

}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::PersistSettings( HWND hDlg )
{
    if( m_pParent != NULL )
    {
        USERCONFIG uc;

        m_pParent->GetCurrentUserConfig( uc, TRUE );

        uc.fPromptForPassword = SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;

        if( !uc.fPromptForPassword )
        {
            if( !ConfirmPassWd( hDlg ) )
            {
                return FALSE;
            }
        }
        else
        {
            SecureZeroMemory( ( PVOID )uc.Password , sizeof( uc.Password ) );
        }

        if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
        {
            uc.fInheritAutoLogon = TRUE;

            ZeroMemory( ( PVOID )uc.UserName , sizeof( uc.UserName ) );

            ZeroMemory( ( PVOID )uc.Domain , sizeof( uc.Domain ) );

            SecureZeroMemory( ( PVOID )uc.Password , sizeof( uc.Password ) );
        }
        else
        {
            uc.fInheritAutoLogon = FALSE;

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_USRNAME ) , uc.UserName , USERNAME_LENGTH + 1 );

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_DOMAIN ) , uc.Domain , DOMAIN_LENGTH + 1 );

            GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , uc.Password , PASSWORD_LENGTH + 1 );
        }

        DWORD dwStatus;

        if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
        {
            ReportStatusError( hDlg , dwStatus );

            return FALSE;
        }

        ICfgComp *pCfgcomp = NULL;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            pCfgcomp->Release( );
        }

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::IsValidSettings( HWND hDlg )
{
    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_PROMPTPASSWD ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        return ConfirmPassWd( hDlg );
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CLogonSetting::ConfirmPassWd( HWND hDlg )
{
    TCHAR tchPzWd[ PASSWORD_LENGTH + 1];

    TCHAR tchConfirm[ PASSWORD_LENGTH + 1];

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_LOGON_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        return TRUE;
    }

    int iSz = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , tchPzWd , PASSWORD_LENGTH + 1 );

    // warn on the minimum and maximum sizes

    if( iSz > PASSWORD_LENGTH ) //if( iSz > 0 && ( iSz < 6 || iSz > PASSWORD_LENGTH ) )
    {

        ErrMessage( hDlg , IDS_ERR_PASSWD );

        // set focus back on password and erase the confirm entry

        SetFocus( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) );

        SendMessage( GetDlgItem( hDlg , IDC_EDIT_LOGON_PASSWD ) , EM_SETSEL , ( WPARAM )0 , ( LPARAM )-1 );

        SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , L"" );

        return FALSE;
    }

    int iSz2 = GetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , tchConfirm , PASSWORD_LENGTH + 1 );

    if( iSz == iSz2 )
    {
        if( iSz == 0 )
        {
            return TRUE;
        }

        if( lstrcmp( tchPzWd , tchConfirm ) == 0 )
        {
            return TRUE;
        }
    }

    ErrMessage( hDlg , IDS_ERR_PASSCONFIRM );

    SetFocus( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) );

    SetWindowText( GetDlgItem( hDlg , IDC_EDIT_LOGON_CONFIRMPASSWD ) , L"" );

    return FALSE;
}

//*****************************************************************************
//                  Time out settings dialog


CTimeSetting::CTimeSetting( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldAction = ( WORD )-1;

    m_wOldCon = ( WORD )-1;

	m_bPrevClient = FALSE;

}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    TCHAR tchBuffer[ 80 ];

    if( m_pParent == NULL )
    {
        ODS( L"CTimeSetting::OnInitDialog - PropertySheet: We've lost our parent node!!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    HWND hCombo[ 3 ] =
    {
        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_CON_PS ),

        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_DISCON_PS ),

        GetDlgItem( hwnd , IDC_COMBO_TIMEOUTS_IDLE_PS )
    };

    DWORD rgdwTime[] = { 0 , 1 , 5 , 10 , 15 , 30 , 60 , 120 , 180 , 1440 , 2880 , ( DWORD )-1 };


    for( int idx = 0; rgdwTime[ idx ] != ( DWORD)-1; ++idx )
    {
        if( rgdwTime[ idx ] == 0 )
        {
            LoadString( _Module.GetResourceInstance( ) , IDS_NOTIMEOUT , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
        }
        else
        {
            ConvertToDuration( rgdwTime[ idx ] , tchBuffer );
        }

        for( int inner = 0 ; inner < 3 ; ++inner )
        {
            SendMessage( hCombo[ inner ] , CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );

            SendMessage( hCombo[ inner ] , CB_SETITEMDATA , idx , rgdwTime[ idx ] );
        }
    }


    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CTimeSetting::OnInitDialog - PropertySheet: Could not get current USERCONFIG\n" );

        return FALSE;
    }

    ULONG ulTime;

    if( uc.MaxConnectionTime > 0 )
    {
        ulTime = uc.MaxConnectionTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 0 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 0 ] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 0 ] );

    //
    // Set the current or default disconnection timeout
    //

    if( uc.MaxDisconnectionTime > 0 )
    {
        ulTime = uc.MaxDisconnectionTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 1 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 1] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 1 ] );

    //
    // Set the current or default idle timeout
    //

    if( uc.MaxIdleTime > 0 )
    {
        ulTime = uc.MaxIdleTime / kMilliMinute;

        InsertSortedAndSetCurSel( hCombo[ 2 ] , ulTime );

    }
    else
    {
        SendMessage( hCombo[ 2 ] , CB_SETCURSEL , 0 , 0 );
    }

    CTimeOutDlg::InitControl( hCombo[ 2 ] );

    //
    // all the timeout settings will have the same inherit status (NOT!)
    //
    // GP made all these settings orthogonal.  When we write son of TSCC
    // in Blackcomb, we should allow individual settings.
    //

//  ASSERT( ( BOOL )uc.fInheritMaxSessionTime == ( BOOL )uc.fInheritMaxDisconnectionTime );

//  ASSERT( ( BOOL )uc.fInheritMaxSessionTime == ( BOOL )uc.fInheritMaxIdleTime );

    DBGMSG( L"uc.fInheritMaxSessionTime %d\n" , uc.fInheritMaxSessionTime );

    DBGMSG( L"uc.fInheritMaxDisconnectionTime %d\n" , uc.fInheritMaxDisconnectionTime );

    DBGMSG( L"uc.fInheritMaxIdleTime %d\n" , uc.fInheritMaxIdleTime );

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_SETCHECK , ( WPARAM )( BOOL )!uc.fInheritMaxSessionTime , 0 );

    SetTimeoutControls(hwnd);

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITBKCON_PS ) , BM_SETCHECK , ( WPARAM )!uc.fInheritResetBroken , 0 );

    if( uc.fResetBroken ) //BST_CHECKED : BST_UNCHECKED
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_RESET_PS , BST_CHECKED );

        m_wOldAction = IDC_RADIO_TIMEOUTS_RESET_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_DISCON_PS , BST_CHECKED );

        m_wOldAction = IDC_RADIO_TIMEOUTS_DISCON_PS;
    }

    /*
	if( uc.fReconnectSame )
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_PREVCLNT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_PREVCLNT_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_ANYCLIENT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_ANYCLIENT_PS;
    }
	*/

    SetBkResetControls(hwnd);

    SendMessage( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , BM_SETCHECK , ( WPARAM )!uc.fInheritReconnectSame , 0 );

    //SetReconControls( hwnd , !uc.fInheritReconnectSame );

    LoadAbbreviates( );

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly = FALSE;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // disable the remaining controls
                int rgID[] =    {
                    IDC_COMBO_TIMEOUTS_CON_PS ,
                    IDC_COMBO_TIMEOUTS_DISCON_PS ,
                    IDC_COMBO_TIMEOUTS_IDLE_PS ,

                    IDC_RADIO_TIMEOUTS_DISCON_PS ,
                    IDC_RADIO_TIMEOUTS_RESET_PS ,

                    IDC_RADIO_TIMEOUTS_ANYCLIENT_PS ,
                    IDC_RADIO_TIMEOUTS_PREVCLNT_PS ,

                    IDC_CHECK_INHERITTIMEOUT_PS,
                    IDC_CHECK_TIMEOUTS_INHERITBKCON_PS,
                    IDC_CHECK_TIMEOUTS_INHERITRECON_PS,

                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
		}

		if( !bReadOnly )
		{
			ULONG mask = 0;

			if( SUCCEEDED( pCfgcomp->GetCaps( m_pParent->m_pResNode->GetTypeName( ) , &mask ) ) )
			{
				// citrix only flag

				m_bPrevClient = mask & WDC_RECONNECT_PREVCLIENT;

				if( !m_bPrevClient )
				{
					EnableWindow( GetDlgItem( hwnd , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , FALSE );
				}

				SetReconControls(hwnd);
			}
		}


        pCfgcomp->Release( );
    }

	if( uc.fReconnectSame )
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_PREVCLNT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_PREVCLNT_PS;
    }
    else
    {
        CheckDlgButton( hwnd , IDC_RADIO_TIMEOUTS_ANYCLIENT_PS , BST_CHECKED );

        m_wOldCon = IDC_RADIO_TIMEOUTS_ANYCLIENT_PS;
    }


    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
// the next set of functions manage the enabling and disabling of the controls
//-----------------------------------------------------------------------------

void CTimeSetting::SetTimeoutControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_INHERITTIMEOUT_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_CON_PS), (bOverride && !p.fPolicyMaxSessionTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMCON), (bOverride && !p.fPolicyMaxSessionTime));

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_DISCON_PS), (bOverride && !p.fPolicyMaxDisconnectionTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMDISCON), (bOverride && !p.fPolicyMaxDisconnectionTime));

    EnableWindow(GetDlgItem(hDlg, IDC_COMBO_TIMEOUTS_IDLE_PS), (bOverride && !p.fPolicyMaxIdleTime));
    EnableWindow(GetDlgItem(hDlg, IDC_STATIC_TIMIDLE), (bOverride && !p.fPolicyMaxIdleTime));

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_INHERITTIMEOUT_PS), 
        !(p.fPolicyMaxSessionTime && p.fPolicyMaxDisconnectionTime && p.fPolicyMaxIdleTime));
}

void CTimeSetting::SetBkResetControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITBKCON_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

    EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_DISCON_PS), bOverride && !p.fPolicyResetBroken);
    EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_RESET_PS), bOverride && !p.fPolicyResetBroken);

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITBKCON_PS), !p.fPolicyResetBroken);
}

void CTimeSetting::SetReconControls(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    BOOL bOverride = 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), BM_GETCHECK, 0, 0) == BST_CHECKED);

	if( !m_bPrevClient )
	{
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_ANYCLIENT_PS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_PREVCLNT_PS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), FALSE);
	}
	else
	{
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_ANYCLIENT_PS), bOverride && !p.fPolicyReconnectSame);
        EnableWindow(GetDlgItem(hDlg, IDC_RADIO_TIMEOUTS_PREVCLNT_PS), bOverride && !p.fPolicyReconnectSame);
        EnableWindow(GetDlgItem(hDlg, IDC_CHECK_TIMEOUTS_INHERITRECON_PS), !p.fPolicyReconnectSame);
	}

}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CTimeSetting::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CTimeSetting *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CTimeSetting *pDlg = ( CTimeSetting * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CTimeSetting ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CTimeSetting * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CTimeSetting ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TIMEOUTS_PS );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CTimeSetting::DlgProc;

    return TRUE;

}

//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_INHERITTIMEOUT_PS )
        {
            SetTimeoutControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_CHECK_TIMEOUTS_INHERITBKCON_PS )
        {
            SetBkResetControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_CHECK_TIMEOUTS_INHERITRECON_PS )
        {
            SetReconControls(GetParent(hwndCtrl));

            m_bPersisted = FALSE;
        }
        else if( wID == IDC_RADIO_TIMEOUTS_DISCON_PS || wID == IDC_RADIO_TIMEOUTS_RESET_PS )
        {
            if( wID != m_wOldAction )
            {
                m_wOldAction = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_TIMEOUTS_ANYCLIENT_PS || wID == IDC_RADIO_TIMEOUTS_PREVCLNT_PS )
        {
            if( wID != m_wOldCon )
            {
                m_wOldCon = wID;

                m_bPersisted = FALSE;
            }
        }


    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }
    else
    {
         CTimeOutDlg::OnCommand( wNotifyCode , wID , hwndCtrl , &m_bPersisted );
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
int CTimeSetting::GetCBXSTATEindex( HWND hCombo )
{
    int idx = -1;

    switch( GetDlgCtrlID( hCombo ) )
    {
    case IDC_COMBO_TIMEOUTS_CON_PS:

        idx = 0;

        break;

    case IDC_COMBO_TIMEOUTS_DISCON_PS:

        idx = 1;

        break;

    case IDC_COMBO_TIMEOUTS_IDLE_PS:

        idx = 2;

        break;
    }

    return idx;
}



//-------------------------------------------------------------------------------
// PersistSettings
//-------------------------------------------------------------------------------
BOOL CTimeSetting::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
    {
        uc.fInheritMaxSessionTime = 1;

        uc.fInheritMaxDisconnectionTime = 1;

        uc.fInheritMaxIdleTime = 1;

        // reset timeout values to no timeout

        uc.MaxConnectionTime = 0;

        uc.MaxDisconnectionTime = 0;

        uc.MaxIdleTime = 0;

    }
    else
    {
        uc.fInheritMaxSessionTime = 0;

        uc.fInheritMaxDisconnectionTime = 0;

        uc.fInheritMaxIdleTime = 0;

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_CON_PS ) , &uc.MaxConnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_DISCON_PS ) , &uc.MaxDisconnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_IDLE_PS ) , &uc.MaxIdleTime ) )
        {
            return FALSE;
        }
    }

   if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_TIMEOUTS_INHERITBKCON_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
   {
       uc.fInheritResetBroken = 1;
   }
   else
   {
       uc.fInheritResetBroken = 0;

       uc.fResetBroken = SendMessage( GetDlgItem( hDlg , IDC_RADIO_TIMEOUTS_RESET_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;
   }

   if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_TIMEOUTS_INHERITRECON_PS ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
   {
       uc.fInheritReconnectSame = 1;
   }
   else
   {
       uc.fInheritReconnectSame = 0;

       uc.fReconnectSame = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_RADIO_TIMEOUTS_PREVCLNT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED ? TRUE : FALSE;
   }

   DWORD dwStatus;

   if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
   {
       ReportStatusError( hDlg , dwStatus );

       return FALSE;
   }

   ICfgComp *pCfgcomp = NULL;

   if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
   {
       VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

       VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

       // global flag can only be set to true

       m_pParent->m_bPropertiesChange = TRUE;

       pCfgcomp->Release( );
   }

   PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

   SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

   return TRUE;
}

//-------------------------------------------------------------------------------
// Making sure the user has entered valid info
//-------------------------------------------------------------------------------
BOOL CTimeSetting::IsValidSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    if( SendMessage( GetDlgItem( hDlg , IDC_CHECK_INHERITTIMEOUT_PS ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED )
    {
        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_CON_PS ) , &uc.MaxConnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_DISCON_PS ) , &uc.MaxDisconnectionTime ) )
        {
            return FALSE;
        }

        if( !ConvertToMinutes( GetDlgItem( hDlg , IDC_COMBO_TIMEOUTS_IDLE_PS ) , &uc.MaxIdleTime ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}


//-----------------------------------------------------------------------------
BOOL CTimeSetting::OnDestroy( )
{
    m_pParent->Release( );

    ReleaseAbbreviates( );

    return CDialogPropBase::OnDestroy( );
}

//*****************************************************************************
//                  Environment dialog

CEnviro::CEnviro( CPropsheet *pSheet )
{
    m_pParent = pSheet;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CEnviro::OnInitDialog - PropertySheet: Parent object is lost!!!\n" );
        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CEnviro::OnInitDialog - PropertySheet: Failed to obtain USERCONFIG\n" );

        return FALSE;
    }

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , EM_SETLIMITTEXT , ( WPARAM )INITIALPROGRAM_LENGTH , 0 );

    SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , EM_SETLIMITTEXT , ( WPARAM )DIRECTORY_LENGTH , 0 );

    if(uc.fInheritInitialProgram)
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_INHERIT ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );

    }
    else
    {
        SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_INHERIT ) , BM_SETCHECK , ( WPARAM )BST_CHECKED, 0 );

    }

    if(uc.fInheritInitialProgram)
    {
        SetControls( hwnd , FALSE );
    }
    else
    {
        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , ( LPCTSTR )uc.InitialProgram );

        SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , ( LPCTSTR )uc.WorkDirectory );
    }

    // SendMessage( GetDlgItem( hwnd , IDC_CHECK_ENVIRO_DISABLEWALL ) , BM_SETCHECK , ( WPARAM )uc.fWallPaperDisabled , 0  );

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // make edit controls read-only

                SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_CMDLINE ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                SendMessage( GetDlgItem( hwnd , IDC_EDIT_ENVIRO_WD ) , EM_SETREADONLY , ( WPARAM )TRUE , 0 );

                // disable the remaining controls
                int rgID[] =    {
                    IDC_CHECK_ENVIRO_INHERIT ,
                    // IDC_CHECK_ENVIRO_DISABLEWALL,
                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
    if (p.fPolicyInitialProgram)
    {
        int rgID[] = 
        {
            IDC_CHECK_ENVIRO_INHERIT,
            IDC_EDIT_ENVIRO_CMDLINE,
            IDC_EDIT_ENVIRO_WD, -1
        };
        EnableGroup(hwnd, &rgID[0], FALSE);
    }

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CEnviro::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CEnviro *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CEnviro *pDlg = ( CEnviro * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CEnviro ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CEnviro * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CEnviro ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_ENVIRONMENT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CEnviro::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_ENVIRO_INHERIT )
        {
            SetControls( GetParent( hwndCtrl ) , SendMessage( hwndCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED );
        }

        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == EN_CHANGE )
    {
        m_bPersisted = FALSE;
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
void CEnviro::SetControls( HWND hDlg , BOOL bEnable )
{
    int rgID[] = { IDC_EDIT_ENVIRO_CMDLINE , IDC_STATIC_ENCL ,  IDC_EDIT_ENVIRO_WD , IDC_STATIC_WD ,-1 };

    EnableGroup( hDlg , &rgID[ 0 ] , bEnable );
}

//-----------------------------------------------------------------------------
BOOL CEnviro::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    uc.fInheritInitialProgram = (( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENVIRO_INHERIT ) , BM_GETCHECK , 0 , 0 )) == BST_UNCHECKED;

    if( !uc.fInheritInitialProgram )
    {
        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_ENVIRO_CMDLINE ) , uc.InitialProgram , INITIALPROGRAM_LENGTH + 1);

        GetWindowText( GetDlgItem( hDlg , IDC_EDIT_ENVIRO_WD ) , uc.WorkDirectory , DIRECTORY_LENGTH + 1 );
    }
    else
    {
        ZeroMemory( ( PVOID )uc.InitialProgram , sizeof( uc.InitialProgram ) );

        ZeroMemory( ( PVOID )uc.WorkDirectory , sizeof( uc.WorkDirectory ) );
    }

    // uc.fWallPaperDisabled = ( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_ENVIRO_DISABLEWALL ) , BM_GETCHECK , 0 , 0  );

    DWORD dwStatus;

    if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
    {
        ReportStatusError( hDlg , dwStatus );

        return FALSE;
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
    {
        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        pCfgcomp->Release( );
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CEnviro::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//*****************************************************************************
//                  Shadow dialog

CRemote::CRemote( CPropsheet *pSheet )
{
    m_pParent = pSheet;

    m_wOldRadioID = ( WORD )-1;

    m_wOldSel = ( WORD )-1;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnInitDialog( HWND hwnd , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CRemote::OnInitDialog - PropertySheet: Parent object lost!!\n" );

        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CRemote::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!\n" );

        return FALSE;
    }

    if( uc.fInheritShadow || uc.Shadow == Shadow_Disable )
    {
        // setup some default values

        SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

        SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

        m_wOldSel = IDC_RADIO_WATCH;

        if( uc.fInheritShadow )
        {
            SendMessage( GetDlgItem( hwnd , IDC_RADIO_REMOTE_INHERIT ) , BM_SETCHECK , ( WPARAM )uc.fInheritShadow , 0 );

        }
        else
        {
            SendMessage( GetDlgItem( hwnd , IDC_RADIO_NOREMOTE ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        }

        m_wOldRadioID = ( WORD )( uc.fInheritShadow ? IDC_RADIO_REMOTE_INHERIT : IDC_RADIO_NOREMOTE );

        SetControls( hwnd , FALSE );
    }
    else
    {
        // Controls are initially enabled,  set current status

        SendMessage( GetDlgItem( hwnd , IDC_RADIO_ENABLE_REMOTE ) , BM_SETCHECK , ( WPARAM )TRUE , 0  );

        m_wOldRadioID = IDC_RADIO_ENABLE_REMOTE;

        switch( uc.Shadow )
        {
        case Shadow_EnableInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_CONTROL ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableNoInputNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;

        case Shadow_EnableNoInputNoNotify:

            SendMessage( GetDlgItem( hwnd , IDC_CHECK_NOTIFY ) , BM_SETCHECK , ( WPARAM )FALSE , 0 );

            SendMessage( GetDlgItem( hwnd , IDC_RADIO_WATCH ) , BM_SETCHECK , ( WPARAM )TRUE , 0 );

            break;
        }

        if( IsDlgButtonChecked( hwnd , IDC_RADIO_WATCH ) == BST_CHECKED )
        {
            m_wOldSel = IDC_RADIO_WATCH;
        }
        else
        {
            m_wOldSel = IDC_RADIO_CONTROL;
        }
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {

        BOOL bReadOnly;

        if( SUCCEEDED( pCfgcomp->IsSessionReadOnly( &bReadOnly ) ) )
        {
            if( bReadOnly )
            {
                // disable the remaining controls
                int rgID[] =    {
                    IDC_RADIO_ENABLE_REMOTE ,
                    IDC_RADIO_NOREMOTE,
                    IDC_RADIO_CONTROL,
                    IDC_RADIO_REMOTE_INHERIT,
                    IDC_RADIO_WATCH,
                    IDC_CHECK_NOTIFY,
                    -1
                };


                EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
            }
        }

        pCfgcomp->Release( );
    }

    //Disable all the controls if there is a group policy set
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    if (p.fPolicyShadow)
    {
        int rgID[] = 
        {
            IDC_RADIO_ENABLE_REMOTE ,
            IDC_RADIO_NOREMOTE,
            IDC_RADIO_CONTROL,
            IDC_RADIO_REMOTE_INHERIT,
            IDC_RADIO_WATCH,
            IDC_CHECK_NOTIFY,
            -1
        };

        EnableGroup( hwnd , &rgID[ 0 ] , FALSE );
    }

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hwnd , wp , lp );
}

//-----------------------------------------------------------------------------
void CRemote::SetControls( HWND hDlg , BOOL bEnable )
{
    int rgID[] = { IDC_RADIO_WATCH , IDC_RADIO_CONTROL , IDC_CHECK_NOTIFY , IDC_STATIC_LEVELOFCTRL , -1 };

    EnableGroup( hDlg , &rgID[ 0 ] , bEnable );
}


//-----------------------------------------------------------------------------
INT_PTR CALLBACK CRemote::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CRemote *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CRemote *pDlg = ( CRemote * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CRemote ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CRemote * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CRemote ) ) )
        {
            return 0;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );
    }

    return 0;
}

//-----------------------------------------------------------------------------
BOOL CRemote::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_PAGE_SHADOW );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CRemote::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
        if( wID == IDC_CHECK_NOTIFY )
        {
            m_bPersisted = FALSE;
        }
        else if( wID == IDC_RADIO_REMOTE_INHERIT || wID == IDC_RADIO_NOREMOTE || wID == IDC_RADIO_ENABLE_REMOTE )
        {
            if( m_wOldRadioID != wID )
            {
                if( wID == IDC_RADIO_REMOTE_INHERIT || wID == IDC_RADIO_NOREMOTE )
                {
                    SetControls( GetParent( hwndCtrl ) , FALSE );
                }
                else if( wID == IDC_RADIO_ENABLE_REMOTE )
                {
                    SetControls( GetParent( hwndCtrl ) , TRUE );
                }

                m_wOldRadioID = wID;

                m_bPersisted = FALSE;
            }
        }
        else if( wID == IDC_RADIO_CONTROL || wID == IDC_RADIO_WATCH )
        {
            if( wID != m_wOldSel )
            {
                m_wOldSel = wID;

                m_bPersisted = FALSE;
            }
        }
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    if( !m_bPersisted )
    {
        SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CRemote::OnDestroy( )
{
    m_pParent->Release( );

    return CDialogPropBase::OnDestroy( );
}

//-----------------------------------------------------------------------------
// The nesting may appear scary but its has a nice logic flow to a weird
// datatype called shadow
//-----------------------------------------------------------------------------
BOOL CRemote::PersistSettings( HWND hDlg )
{
    if( m_pParent != NULL )
    {
        USERCONFIG uc;
        m_pParent->GetCurrentUserConfig( uc, TRUE );

        if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_REMOTE_INHERIT ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
        {
            uc.fInheritShadow = FALSE;

            if( SendMessage( GetDlgItem( hDlg , IDC_RADIO_NOREMOTE ) , BM_GETCHECK , 0 , 0 ) == BST_UNCHECKED )
            {
                BOOL bCheckNotify = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_CHECK_NOTIFY ) , BM_GETCHECK , 0 , 0 );

                BOOL bRadioControl = ( BOOL )SendMessage( GetDlgItem( hDlg , IDC_RADIO_CONTROL ) , BM_GETCHECK , 0 , 0 );

                if( bCheckNotify )
                {
                    if( bRadioControl )
                    {
                        uc.Shadow = Shadow_EnableInputNotify;
                    }
                    else
                    {
                        uc.Shadow = Shadow_EnableNoInputNotify;
                    }
                }
                else
                {
                    if( bRadioControl )
                    {
                        uc.Shadow = Shadow_EnableInputNoNotify;
                    }
                    else
                    {
                        uc.Shadow = Shadow_EnableNoInputNoNotify;
                    }
                }
            }
            else
            {
                uc.Shadow = Shadow_Disable;
            }

        }
        else
        {
            uc.fInheritShadow = TRUE;
        }

        DWORD dwStatus;

        if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
        {
            ReportStatusError( hDlg , dwStatus );

            return FALSE;
        }

        ICfgComp *pCfgcomp = NULL;

        if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
        {
            VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

            VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

            // global flag can only be set to true

            m_pParent->m_bPropertiesChange = TRUE;

            pCfgcomp->Release( );
        }

        PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

        SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

        return TRUE;
    }

    return FALSE;
}

//*****************************************************************************
//                  Client settings dialog

CClient::CClient( CPropsheet *pSheet )
{
    m_pParent = pSheet;
	m_nColorDepth = TS_8BPP_SUPPORT;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnInitDialog( HWND hDlg , WPARAM wp , LPARAM lp )
{
    if( m_pParent == NULL )
    {
        ODS( L"CClient::OnInitDialog - PropertySheet: Parent object lost!!\n" );
        return FALSE;
    }

    m_pParent->AddRef( );

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        ODS( L"CClient::OnInitDialog - PropertySheet: GetCurrentUserConfig failed!!\n" );
        return FALSE;
    }

    // Obtain capabilities mask

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        ODS( L"CClient::OnInitDialog  GetServer failed\n" );

        return FALSE;
    }

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CONCLIENT_INHERIT ) , BM_SETCHECK , ( WPARAM )uc.fInheritAutoClient , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL_PS ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientDrives , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , BM_SETCHECK , ( WPARAM )uc.fAutoClientLpts , 0 );

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , BM_SETCHECK , ( WPARAM )uc.fForceClientLptDef , 0 );


    TCHAR tchBuffer[80];
    int nColorDepthIndex = 0;

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_24 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );    
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_24BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_16 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_16BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_15 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_15BPP_SUPPORT );

    LoadString( _Module.GetResourceInstance( ) , IDS_COLORDEPTH_8 , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_ADDSTRING , 0 , ( LPARAM )&tchBuffer[0] );
    SendMessage( GetDlgItem( hDlg, IDC_COLORDEPTH_OVERRIDE ), CB_SETITEMDATA , nColorDepthIndex++ , TS_8BPP_SUPPORT );

    if(uc.fInheritColorDepth)
        SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_SETCHECK , ( WPARAM )BST_UNCHECKED , 0 );
    else
        SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_SETCHECK , ( WPARAM )BST_CHECKED, 0 );

    if (uc.ColorDepth < TS_8BPP_SUPPORT)
    	m_nColorDepth = TS_8BPP_SUPPORT;
    else if (uc.ColorDepth > TS_24BPP_SUPPORT)
    	m_nColorDepth = TS_24BPP_SUPPORT;
    else
    	m_nColorDepth = (int)uc.ColorDepth;

    //Mapping fields
    ULONG mask = 0;
    VERIFY_S(S_OK, pCfgcomp->GetCaps(m_pParent->m_pResNode->GetTypeName(), &mask));

    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), mask & WDC_CLIENT_DRIVE_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), mask & WDC_WIN_CLIENT_PRINTER_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), mask & WDC_CLIENT_LPT_PORT_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCPM_PS), mask & WDC_CLIENT_COM_PORT_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCM_PS), mask & WDC_CLIENT_CLIPBOARD_MAPPING);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCAM_PS), mask & WDC_CLIENT_AUDIO_MAPPING);

    if (!(mask & WDC_CLIENT_DRIVE_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_SETCHECK, (WPARAM)TRUE, 0);
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_SETCHECK, (WPARAM)uc.fDisableCdm, 0);

    if(!(mask & WDC_WIN_CLIENT_PRINTER_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), BM_SETCHECK, (WPARAM)TRUE, 0 );
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), BM_SETCHECK, (WPARAM)uc.fDisableCpm, 0);

    if(!(mask & WDC_CLIENT_LPT_PORT_MAPPING))
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), BM_SETCHECK, (WPARAM)TRUE, 0);
    else
        SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), BM_SETCHECK, (WPARAM)uc.fDisableLPT, 0);

    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCPM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableCcm , 0 );
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableClip , 0 );
    SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCAM_PS ) , BM_SETCHECK , ( WPARAM )uc.fDisableCam , 0 );

    DetermineFieldEnabling(hDlg);
    SetColorDepthEntry(hDlg);

    BOOL bReadOnly;
    if (SUCCEEDED(pCfgcomp->IsSessionReadOnly(&bReadOnly)))
    {
        if(bReadOnly)
        {
            // disable the remaining controls
            int rgID[] =    
            {
                IDC_CHECK_DCDM_PS ,
                IDC_CHECK_DWCPM_PS ,
                IDC_CHECK_DCLPM_PS ,
                IDC_CHECK_DCCPM_PS ,
                IDC_CHECK_DCCM_PS ,
                IDC_CHECK_DCAM_PS ,
                IDC_CHECK_CCDL_PS ,
                IDC_CHECK_CCPL_PS ,
                IDC_CHECK_DMCP_PS ,
                IDC_CHECK_CONCLIENT_INHERIT,
                IDC_CHECK_COLORDEPTH_OVERRIDE,
                IDC_COLORDEPTH_OVERRIDE,
                -1
            };
            EnableGroup( hDlg , &rgID[ 0 ] , FALSE );
        }
    }

    pCfgcomp->Release( );

    m_bPersisted = TRUE;

    return CDialogPropBase::OnInitDialog( hDlg , wp , lp );
}


//-----------------------------------------------------------------------------
//Disable fields if a group policy is set
void CClient::DetermineFieldEnabling(HWND hDlg)
{
    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);
	
    //Mapping fields
    //EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DMCP_PS), !p.fPolicyForceClientLptDef); //Done below since it depends on 2 things
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), !p.fPolicyDisableCdm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DWCPM_PS), !p.fPolicyDisableCpm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCLPM_PS), !p.fPolicyDisableLPT);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCPM_PS), !p.fPolicyDisableCcm);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCCM_PS), !p.fPolicyDisableClip);
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_DCAM_PS), !p.fPolicyDisableCam);

    //Connection fields
	BOOL bEnableConnectionSettings = (SendMessage(GetDlgItem(hDlg, IDC_CHECK_CONCLIENT_INHERIT), BM_GETCHECK, 0, 0) != BST_CHECKED);

    // check to see if client drive mapping is selected if so disable
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_CCDL_PS), bEnableConnectionSettings && 
        (SendMessage(GetDlgItem(hDlg, IDC_CHECK_DCDM_PS), BM_GETCHECK, 0, 0) != BST_CHECKED));

	EnableWindow( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , bEnableConnectionSettings );

	EnableWindow( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , bEnableConnectionSettings && !p.fPolicyForceClientLptDef);

    //Color Depth fields
    EnableWindow(GetDlgItem(hDlg, IDC_CHECK_COLORDEPTH_OVERRIDE), (!p.fPolicyColorDepth));

    BOOL bEnableColorDepthSetting = SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;
    EnableWindow(GetDlgItem(hDlg, IDC_COLORDEPTH_OVERRIDE), (bEnableColorDepthSetting && !p.fPolicyColorDepth));

}


//-----------------------------------------------------------------------------
void CClient::SetColorDepthEntry(HWND hwnd)
{
	BOOL bEnableColorDepthSetting = TRUE;

    // check to see if override Color Depth setting is checked
	bEnableColorDepthSetting = SendMessage( GetDlgItem( hwnd , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;

	//Select the correct combo box entry
	if (bEnableColorDepthSetting)
	{
		//Select the correct value in the combo box based on the current value
		INT_PTR iColorDepthListCount = 0;
		iColorDepthListCount = SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETCOUNT , 0 , 0 );

		//Traverse the list looking an entry with value equal to m_nColorDepth
		for (int iColorDepthListIndex = 0; iColorDepthListIndex < iColorDepthListCount; iColorDepthListIndex++)
		{
			INT_PTR iMatchingColorDepthValue = 0;
			iMatchingColorDepthValue = SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETITEMDATA , iColorDepthListIndex , 0 ) ;

			if (iMatchingColorDepthValue == m_nColorDepth )
			{
				//Value found, set the combo box selection to the correct index
				SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , iColorDepthListIndex , 0 );
				break;
			}
		}

		//Make sure something's been selected - if not, just select the first value in the list
		INT_PTR iSelection = SendMessage ( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_GETCURSEL, 0, 0 );
		if (iSelection == CB_ERR)
			SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , 0 , 0 );
	}
	else
	{
		//Clear the contents of the combo box window if the color depth isn't editable
		SendMessage( GetDlgItem( hwnd, IDC_COLORDEPTH_OVERRIDE ), CB_SETCURSEL , (WPARAM)CB_ERR , 0 );
	}
}

//-----------------------------------------------------------------------------
BOOL CClient::PersistSettings( HWND hDlg )
{
    if( m_pParent == NULL )
    {
        return FALSE;
    }

    USERCONFIG uc;

    if( !m_pParent->GetCurrentUserConfig( uc, TRUE ) )
    {
        return FALSE;
    }

    uc.fInheritAutoClient = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CONCLIENT_INHERIT ) , BM_GETCHECK , 0 , 0 );

    if( !uc.fInheritAutoClient )
    {
        uc.fAutoClientDrives = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCDL_PS ) , BM_GETCHECK , 0 , 0 );

        uc.fAutoClientLpts = SendMessage( GetDlgItem( hDlg , IDC_CHECK_CCPL_PS ) , BM_GETCHECK , 0 , 0 );

        uc.fForceClientLptDef = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DMCP_PS ) , BM_GETCHECK , 0 , 0 );
    }

    uc.fDisableCdm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCDM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCpm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DWCPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableLPT = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCLPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCcm = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCPM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableClip = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCCM_PS ) , BM_GETCHECK , 0 , 0 );

    uc.fDisableCam = SendMessage( GetDlgItem( hDlg , IDC_CHECK_DCAM_PS ) , BM_GETCHECK , 0 , 0 );


    uc.fInheritColorDepth = (( ULONG )SendMessage( GetDlgItem( hDlg , IDC_CHECK_COLORDEPTH_OVERRIDE ) , BM_GETCHECK , 0 , 0 )) == BST_UNCHECKED;

    if( !uc.fInheritColorDepth )
    {
		INT_PTR iColorDepthSel = CB_ERR;
		iColorDepthSel = SendMessage( GetDlgItem( hDlg , IDC_COLORDEPTH_OVERRIDE ) , CB_GETCURSEL, 0 , 0 );

		INT_PTR iColorDepthValue = 0;
		iColorDepthValue = SendMessage( GetDlgItem( hDlg , IDC_COLORDEPTH_OVERRIDE ) , CB_GETITEMDATA , iColorDepthSel , 0 );
		
		uc.ColorDepth = iColorDepthValue;
    }
    else
    {
        uc.ColorDepth = TS_24BPP_SUPPORT;
    }


    DWORD dwStatus;

    if( FAILED( m_pParent->SetUserConfig( uc , &dwStatus ) ) )
    {
        ReportStatusError( hDlg , dwStatus );

        return FALSE;
    }

	ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) > 0 )
    {
        VERIFY_S( S_OK , pCfgcomp->ForceUpdate( ) );

        VERIFY_S( S_OK , pCfgcomp->Refresh( ) );

        // global flag can only be set to true

        m_pParent->m_bPropertiesChange = TRUE;

        pCfgcomp->Release( );
    }

    PostMessage( hDlg , WM_COMMAND , MAKELPARAM( 0 , ALN_APPLY )  , ( LPARAM )hDlg );

    SendMessage( GetParent( hDlg ) , PSM_UNCHANGED , ( WPARAM )hDlg , 0 );

    return TRUE;
}

//-----------------------------------------------------------------------------
INT_PTR CALLBACK CClient::DlgProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    CClient *pDlg;

    if( msg == WM_INITDIALOG )
    {
        CClient *pDlg = ( CClient * )( ( PROPSHEETPAGE *)lp )->lParam ;

        SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pDlg );

        if( !IsBadReadPtr( pDlg , sizeof( CClient ) ) )
        {
            pDlg->OnInitDialog( hwnd , wp , lp );
        }

        return 0;
    }

    else
    {
        pDlg = ( CClient * )GetWindowLongPtr( hwnd , DWLP_USER );

        if( IsBadReadPtr( pDlg , sizeof( CClient ) ) )
        {
            return FALSE;
        }
    }

    switch( msg )
    {

    case WM_NCDESTROY:

        pDlg->OnDestroy( );

        break;

    case WM_COMMAND:

        pDlg->OnCommand( HIWORD( wp ) , LOWORD( wp ) , ( HWND )lp );

        break;

    case WM_CONTEXTMENU:
        {
            POINT pt;

            pt.x = LOWORD( lp );

            pt.y = HIWORD( lp );

            pDlg->OnContextMenu( ( HWND )wp , pt );
        }

        break;

    case WM_HELP:

        pDlg->OnHelp( hwnd , ( LPHELPINFO )lp );

        break;

    case WM_NOTIFY:

        return pDlg->OnNotify( ( int )wp , ( LPNMHDR )lp , hwnd );

        break;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CClient::GetPropertySheetPage( PROPSHEETPAGE& psp )
{
    ZeroMemory( &psp , sizeof( PROPSHEETPAGE ) );

    psp.dwSize      = sizeof( PROPSHEETPAGE );

    psp.dwFlags     = PSP_DEFAULT;

    psp.hInstance   = _Module.GetResourceInstance( );

    psp.pszTemplate = MAKEINTRESOURCE( IDD_TSCC_CLIENT );

    psp.lParam      = ( LPARAM )this;

    psp.pfnDlgProc  = CClient::DlgProc;

    return TRUE;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnCommand( WORD wNotifyCode , WORD wID , HWND hwndCtrl )
{
    if( wNotifyCode == BN_CLICKED )
    {
		if ((wID == IDC_CHECK_CONCLIENT_INHERIT) || (wID == IDC_CHECK_COLORDEPTH_OVERRIDE) || 
                                (wID == IDC_CHECK_DWCPM_PS ) || (wID == IDC_CHECK_DCDM_PS))
        {
            DetermineFieldEnabling(GetParent(hwndCtrl));
        }

        if (wID == IDC_CHECK_COLORDEPTH_OVERRIDE)
            SetColorDepthEntry(GetParent(hwndCtrl));
    }
    else if( wNotifyCode == ALN_APPLY )
    {
        SendMessage( GetParent( hwndCtrl ) , PSM_CANCELTOCLOSE , 0 , 0 );

        return FALSE;
    }

    m_bPersisted = FALSE;

    SendMessage( GetParent( GetParent( hwndCtrl ) ) , PSM_CHANGED , ( WPARAM )GetParent( hwndCtrl ) , 0 );


    return FALSE;
}

//-----------------------------------------------------------------------------
BOOL CClient::OnDestroy( )
{
    m_pParent->Release( );

    return TRUE;
}


/*************************************************************************************************************************/

/*EXTERN_C const GUID IID_ISecurityInformation =
        { 0x965fc360, 0x16ff, 0x11d0, 0x91, 0xcb, 0x0, 0xaa, 0x0, 0xbb, 0xb7, 0x23 };
*/
//
// WinStation General Permissions
//

/*
SI_ACCESS siWinStationAccesses[] =
{
    { &GUID_NULL , WINSTATION_QUERY                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SET                               , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_RESET                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SHADOW                            , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGON                             , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGOFF                            , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_MSG                               , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_CONNECT                           , NULL ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_DISCONNECT                        , NULL , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED, NULL , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_ALL_ACCESS                        , NULL , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_USER_ACCESS                       , NULL , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_GUEST_ACCESS                      , NULL , SI_ACCESS_GENERAL }
};

  */

SI_ACCESS siWinStationAccesses[] =
{
    { &GUID_NULL , WINSTATION_QUERY                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_QUERY ),SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SET                               , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_SET ) ,SI_ACCESS_SPECIFIC },
    //{ &GUID_NULL , WINSTATION_RESET                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_RESET ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_SHADOW                            , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_SHADOW ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_LOGON                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_LOGON ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_RESET                             , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_LOGOFF ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_MSG                               , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_MSG ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_CONNECT                           , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_CONNECT ) ,SI_ACCESS_SPECIFIC },
    { &GUID_NULL , WINSTATION_DISCONNECT                        , MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_DISCONNECT ) , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED, MAKEINTRESOURCE ( IDS_PERMS_SPECIAL_DELETE ) , SI_ACCESS_SPECIFIC},
    { &GUID_NULL , WINSTATION_ALL_ACCESS                        , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_ADMIN ) , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_USER_ACCESS                       , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_USER ) , SI_ACCESS_GENERAL },
    { &GUID_NULL , WINSTATION_GUEST_ACCESS                      , MAKEINTRESOURCE ( IDS_PERMS_RESOURCE_GUEST ) , SI_ACCESS_GENERAL }
};

#define MAX_PERM 12
#define iWinStationDefAccess 11   // index of value in array siWinStationAccesses



//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetAccessRights(
    const GUID  *pguidObjectType,
    DWORD       dwFlags,
    PSI_ACCESS  *ppAccess,
    PULONG       pcAccesses,
    PULONG       piDefaultAccess
)
{
    UNREFERENCED_PARAMETER( dwFlags );

    UNREFERENCED_PARAMETER( pguidObjectType );

    ASSERT( ppAccess != NULL );

    ASSERT( pcAccesses != NULL );

    ASSERT( piDefaultAccess != NULL );

    *ppAccess = siWinStationAccesses;

    *pcAccesses = MAX_PERM;

    *piDefaultAccess = iWinStationDefAccess;

    return S_OK;
}

//-----------------------------------------------------------------------------
// This is consistent with the termsrv code
//-----------------------------------------------------------------------------
GENERIC_MAPPING WinStationMap =
{
    WINSTATION_QUERY      , /*     GenericRead             */
    WINSTATION_USER_ACCESS, /*     GenericWrite            */
    WINSTATION_USER_ACCESS, /*     GenericExecute          */
    WINSTATION_ALL_ACCESS   /*     GenericAll              */
};

//-----------------------------------------------------------------------------
void CSecurityPage::SetParent( CPropsheet *pParent  )
{
    m_pParent = pParent;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::MapGeneric( const GUID  *pguidObjectType , PUCHAR pAceFlags , ACCESS_MASK *pMask )
{
    UNREFERENCED_PARAMETER( pguidObjectType );
    UNREFERENCED_PARAMETER( pAceFlags );

    ASSERT( pMask != NULL );

    MapGenericMask( pMask , &WinStationMap );

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetInheritTypes( PSI_INHERIT_TYPE  *ppInheritTypes ,  PULONG pcInheritTypes )
{
    UNREFERENCED_PARAMETER( ppInheritTypes );
    UNREFERENCED_PARAMETER( pcInheritTypes );


    return E_NOTIMPL;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::PropertySheetPageCallback( HWND hwnd , UINT uMsg , SI_PAGE_TYPE uPage )
{
    UNREFERENCED_PARAMETER( hwnd );
    UNREFERENCED_PARAMETER( uPage );

    if( uMsg == PSPCB_SI_INITDIALOG  )
    {
        ODS( L"CSecurityPage::PropertySheetPageCallback -- Init\n" );

        if (!m_WritablePermissionsTab )
        {

            LinkWindow_RegisterClass();

            DialogBox( _Module.GetResourceInstance( ), MAKEINTRESOURCE(IDD_CUSTOM_SECURITY), 

            hwnd, CustomSecurityDlgProc);

            LinkWindow_UnregisterClass(_Module.GetModuleInstance( ));

        }

    }
    else if( uMsg == PSPCB_RELEASE )
    {


        ODS( L"CSecurityPage::PropertySheetPageCallback -- Release\n" );

    }


    return S_FALSE; //Be sure to return S_FALSE, This supresses other popups.
}

/*
    Change to TSCC's permissions TAB such that the default state is READ-ONLY unless 
    group policy is used to override it.

    If TRUE, permissions TAB can be edited by local Adimn.
    if FALSE, the local Admin should not edit permissions TAB, it is read only
*/

BOOLEAN QueryWriteAccess()
{
    DWORD   ValueType;
    DWORD   ValueSize = sizeof(DWORD);
    DWORD   valueData ;
    LONG    errorCode;

    HKEY   hTSControlKey = NULL;

    //
    // first check the policy tree, 
    //

    POLICY_TS_MACHINE p;
    RegGetMachinePolicy(&p);

    if ( p.fPolicyWritableTSCCPermissionsTAB ) 
    {
        return (BOOLEAN)( p.fWritableTSCCPermissionsTAB ? TRUE : FALSE  );
    }

    // if we got this far, then no policy was set. Check the local machine now.

    errorCode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                                KEY_READ, &hTSControlKey );

    if ( ( errorCode == ERROR_SUCCESS ) && hTSControlKey )
    {
        errorCode = RegQueryValueEx( hTSControlKey, 
                                     POLICY_TS_TSCC_PERM_TAB_WRITABLE , NULL, &ValueType,
                          (LPBYTE) &valueData, &ValueSize );

        RegCloseKey(hTSControlKey); 
    
        if (errorCode == ERROR_SUCCESS )
        {
            return (BOOLEAN)( valueData ? TRUE : FALSE  ) ; 
        }

    }

    // if no localKey, gee... the registry is missing data... return FALSE  to be on the secure side

    return FALSE;
}

/*-----------------------------------------------------------------------------
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
-----------------------------------------------------------------------------*/

STDMETHODIMP CSecurityPage::GetObjectInformation( PSI_OBJECT_INFO pObjectInfo )
{
    ASSERT( pObjectInfo != NULL && !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo ) ) );

    pObjectInfo->dwFlags = SI_OWNER_READONLY | SI_EDIT_PERMS | SI_NO_ACL_PROTECT | SI_PAGE_TITLE | SI_EDIT_AUDITS | SI_ADVANCED | SI_RESET;

    m_WritablePermissionsTab = QueryWriteAccess() ; 

    if( ! m_WritablePermissionsTab ) {
        pObjectInfo->dwFlags |= SI_READONLY;
    }
   

    pObjectInfo->hInstance = _Module.GetResourceInstance( );

    pObjectInfo->pszServerName = NULL;

    pObjectInfo->pszObjectName = m_pParent->m_pResNode->GetConName();

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_SECURPAGENAME , m_szPageName , SIZE_OF_BUFFER( m_szPageName ) ) );

    pObjectInfo->pszPageTitle = m_szPageName;

    return S_OK;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::GetSecurity( SECURITY_INFORMATION RequestedInformation , PSECURITY_DESCRIPTOR *ppSecurityDescriptor , BOOL bDefault )
{
#ifdef DBG
    if( RequestedInformation & OWNER_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - OWNER_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & GROUP_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - GROUP_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & DACL_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - DACL_SECURITY_INFORMATION\n");
    }
    if( RequestedInformation & SACL_SECURITY_INFORMATION )
    {
        ODS( L"CSecurityPage::GetSecurity - SACL_SECURITY_INFORMATION\n");
    }

#endif

    if( 0 == RequestedInformation || NULL == ppSecurityDescriptor )
    {
        ASSERT( FALSE );

        return E_INVALIDARG;
    }

    ICfgComp *pCfgcomp = NULL;

    if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0 )
    {
        return FALSE;
    }

    LONG lSDsize;

    HRESULT hr;

    PSECURITY_DESCRIPTOR  pSD = NULL;

    if( bDefault )
    {
        hr = pCfgcomp->GetDefaultSecurityDescriptor( &lSDsize , &pSD );

        *ppSecurityDescriptor = pSD;

    }
    else
    {   
        BOOL bChanged = FALSE;

        hr = pCfgcomp->GetSecurityDescriptor( m_pParent->m_pResNode->GetConName( ) , &lSDsize , &pSD );
        
        // check for legacy "denied logoff" ace and remove.
        if( xxxLegacyLogoffCleanup( &pSD , &bChanged ) != ERROR_SUCCESS )
        {           
            hr = pCfgcomp->GetDefaultSecurityDescriptor( &lSDsize , &pSD );
        }        
        *ppSecurityDescriptor = pSD;
    }

    pCfgcomp->Release( );
    
    if(SUCCEEDED(hr))
    {
        MakeLocalSDCopy( *ppSecurityDescriptor );
    }

    return hr;
}

//-----------------------------------------------------------------------------
STDMETHODIMP CSecurityPage::SetSecurity( SECURITY_INFORMATION SecurityInformation ,PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    HRESULT hr = S_OK;

    ICfgComp *pCfgcomp = NULL;

    PSECURITY_DESCRIPTOR pSD1;

    if( m_pParent == NULL || m_pParent->m_pResNode == NULL )
    {
        hr = E_UNEXPECTED;
    }

    else if( m_pParent->m_pResNode->GetServer( &pCfgcomp ) != 0 )
    {
        long lSDsize;

        
        hr = pCfgcomp->GetSecurityDescriptor( m_pParent->m_pResNode->GetConName( ) , &lSDsize , &pSD1 );

        if( FAILED( hr ) )
        {
            pCfgcomp->Release( );

            return hr;
        }

        SECURITY_DESCRIPTOR_CONTROL sdc;
        DWORD dwREV;
        PACL pDacl = NULL;
        PACL pSacl = NULL;
        SECURITY_DESCRIPTOR absSD;
        BOOL bSaclPresent = FALSE;
        BOOL bSaclDefaulted = FALSE;
        BOOL bDaclPresent = FALSE;
        BOOL bDaclDefaulted = FALSE;

        //
        // Convert SelfRel to Absolute
        // ignore owner and group
        //


        GetSecurityDescriptorControl( pSD1 , &sdc , &dwREV );
                
        if( !InitializeSecurityDescriptor( &absSD , dwREV ) )
        {
            DBGMSG( L"TSCC!CSecurityPage_SetSecurity InitializeSecurityDescriptor failed with 0x%x\n" , GetLastError( ) );

            return E_FAIL;
        }

        GetSecurityDescriptorDacl( pSD1 , &bDaclPresent , &pDacl , &bDaclDefaulted );

        SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

        GetSecurityDescriptorSacl( pSD1 , &bSaclPresent , &pSacl , &bSaclDefaulted );

        SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );

        // now call SetDACL or SACL depending on SecurityInformation

        if( SecurityInformation & OWNER_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - OWNER_SECURITY_INFORMATION ( default value set )\n");
        }
        if( SecurityInformation & GROUP_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - GROUP_SECURITY_INFORMATION ( default value set )\n");
        }
        if( SecurityInformation & DACL_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - DACL_SECURITY_INFORMATION\n");

            GetSecurityDescriptorDacl( pSecurityDescriptor , &bDaclPresent , &pDacl , &bDaclDefaulted );
            
            SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

        }
        if( SecurityInformation & SACL_SECURITY_INFORMATION )
        {
            ODS( L"CSecurityPage::SetSecurity - SACL_SECURITY_INFORMATION\n");

            GetSecurityDescriptorSacl( pSecurityDescriptor , &bSaclPresent , &pSacl , &bSaclDefaulted );           

            SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );
        }

        PSID SystemSid = NULL;

        SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;

        hr = E_OUTOFMEMORY;

        if( AllocateAndInitializeSid( &NtSidAuthority,
                                      1,
                                      SECURITY_LOCAL_SYSTEM_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &SystemSid ) )
        {

            if( SystemSid != NULL )
            {
                hr = S_OK;
            }
        }

        PSECURITY_DESCRIPTOR pSD = NULL;

        DWORD dwSDLen;

        if( SUCCEEDED( hr ) )
        {
            VERIFY_S( TRUE , SetSecurityDescriptorOwner( &absSD , SystemSid , FALSE ) );

            VERIFY_S( TRUE, SetSecurityDescriptorGroup( &absSD , SystemSid , FALSE ) );
                        
            dwSDLen = 0;
            
            MakeSelfRelativeSD( &absSD, pSD, &dwSDLen);
            
            if (dwSDLen != 0)
            {
                pSD = ( LPBYTE )new BYTE[ dwSDLen ];
            }
           
        }

        if( pSD == NULL )
        {
            ODS( L"TSCC!CSecurityPage::SetSecurity - SD allocation failed\n" );

            hr = E_OUTOFMEMORY;
        }


        if( SUCCEEDED( hr ) )
        {
            if( !MakeSelfRelativeSD( &absSD , pSD , &dwSDLen ) )
            {                
                hr = E_UNEXPECTED;

                DBGMSG( L"MakeSelfRelativeSD - failed in  CSecurityPage::SetSecurity With error %x\n" , GetLastError( ) );
            }

            if( SUCCEEDED( hr ) )
            {
                hr = pCfgcomp->SetSecurityDescriptor(  m_pParent->m_pResNode->GetConName( ) , dwSDLen , pSD );
            }

            if( SUCCEEDED( hr ) )
            {
                ODS( L"TSCC : Update SD for TERMSRV\n" );

                hr = pCfgcomp->ForceUpdate( );

                // global flag can only be set to true

                m_pParent->m_bPropertiesChange = TRUE;

                UpdateTSLogonRight(m_pParent->m_pResNode->GetConName( ), pSD);
            }
            delete[] pSD;
        }

        if( SystemSid != NULL )
        {
            FreeSid( SystemSid );
        }

        // free originally stored SD.

        LocalFree( pSD1 );

        pCfgcomp->Release( );
    }
    return hr;
}

//*************************************************************
//
//  CSecurityPage::MakeLocalSDCopy()
//
//  Purpose:    Makes a copy of the original SD.
//              We'll need it for comparing with SD returned 
//              by Access Control Editor.
//
//  Parameters: IN PSECURITY_DESCRIPTOR pSecurityDescriptor
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
void 
CSecurityPage::MakeLocalSDCopy( 
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    if(m_pOriginalSD)
    {
        delete m_pOriginalSD;
    }

    DWORD dwSDLength = GetSecurityDescriptorLength(pSecurityDescriptor);
    m_pOriginalSD = (PSECURITY_DESCRIPTOR)new BYTE[dwSDLength];

    if(m_pOriginalSD)
    {
        CopyMemory(m_pOriginalSD, pSecurityDescriptor, dwSDLength);
    }
}

//*************************************************************
//
//  CSecurityPage::UpdateTSLogonRight()
//
//  Purpose:    Grants SE_REMOTE_INTERACTIVE_LOGON_NAME right to all users, 
//              who gained Logon permission, but does not have this right yet. 
//              Revokes SE_REMOTE_INTERACTIVE_LOGON_NAME right from all users,
//              who lost Logon permission and don't have Logon permission to
//              any other winstation (connection).
//
//  Parameters: IN PWINSTATIONNAMEW pWSName - connection name
//              IN PSECURITY_DESCRIPTOR pSecurityDescriptor - 
//                new security descriptor
//
//  Return:     NONE
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
void 
CSecurityPage::UpdateTSLogonRight(
        IN PWINSTATIONNAMEW pWSName, 
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
    PSID *ppLogonAllowSIDs = NULL, *ppLogonDenySIDs = NULL; 
    DWORD cLogonAllowSIDs = 0, cLogonDenySIDs = 0;
    
    //No SD to compare to. Do nothing.
    if(!m_pOriginalSD)
    {
        return;
    }

    //Get Everyone's SID. All subsequent functions implicitly use it.
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;

    if(!AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &m_pWorldSid ))
    {
        return;
    }

    //Get SIDs of all users, who have gained or lost Logon permission.
    if(!GetChangedUsers(pSecurityDescriptor, ppLogonAllowSIDs, ppLogonDenySIDs, 
        &cLogonAllowSIDs, &cLogonDenySIDs))
    {
        FreeSid(m_pWorldSid);
        m_pWorldSid = NULL;
        return;
    }
    
    PSID *ppLogonRightSIDs;
    DWORD cLogonRightSIDs = 0;
    DWORD i, j;
    
    //Get SIDs of all users who have SE_REMOTE_INTERACTIVE_LOGON_NAME right.
    if(GetUsersWhoAlreadyHasTSLogonRight(ppLogonRightSIDs, &cLogonRightSIDs))
    {
    
        //Grant SE_REMOTE_INTERACTIVE_LOGON_NAME right to all users who gained Logon
        //permission, but does not have this right yet.
        for(i = 0; i<cLogonAllowSIDs; i++)
        {
            for(j = 0; j<cLogonRightSIDs; j++)
            {
                if(EqualSid(ppLogonAllowSIDs[i],ppLogonRightSIDs[j]))
                {
                    break;    
                }
            }
            //user does not have this right, let's give it to him.
            if(j == cLogonRightSIDs)
            {
                GrantRightToUser(ppLogonAllowSIDs[i]);
            }
        }
    
        //Revoke SE_REMOTE_INTERACTIVE_LOGON_NAME right from all users 
        //who lost Logon permission and don't have Logon permission to
        //any other winstation (connection).
        for(i = 0; i<cLogonDenySIDs; i++)
        {
            for(j = 0; j<cLogonRightSIDs; j++)
            {
                if(EqualSid(ppLogonDenySIDs[i],ppLogonRightSIDs[j]))
                {
                    if(CanRevokeRight(pWSName, ppLogonDenySIDs[i]))
                    {
                        RevokeRightFromUser(ppLogonDenySIDs[i]);
                    } 
                }
            }
        }

    }

    if(ppLogonAllowSIDs)
    {
        delete ppLogonAllowSIDs;
    }
    
    if(ppLogonDenySIDs)
    {
        delete ppLogonDenySIDs;
    }

    if(ppLogonRightSIDs)
    {
        delete ppLogonRightSIDs;
    }

    FreeSid(m_pWorldSid);
    m_pWorldSid = NULL;
}

//*************************************************************
//
//  CSecurityPage::GetChangedUsers()
//
//  Purpose:    Compares original security descriptor with the new one
//              Creates an array of SIDs of all users, who have gained Logon permission,
//              Creates an array of SIDs of all users, who have lost Logon permission,
//
//  Parameters: PSECURITY_DESCRIPTOR pSecurityDescriptor - 
//                        new security descriptor to investigate
//              OUT PSID *&ppLogonAllowSIDs - array of SIDs of users, 
//                        who have gained Logon permission
//              OUT PSID *&ppLogonDenySIDs - array of SIDs of users, 
//                        who have lost Logon permission
//              OUT LPDWORD pcLogonAllowSIDs - number of entries in ppLogonAllowSIDs
//              OUT LPDWORD pcLogonDenySIDs - number of entries in ppLogonDenySIDs
//
//  Return:     TRUE if success
//              FALSE in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::GetChangedUsers(
        IN PSECURITY_DESCRIPTOR pSecurityDescriptor, 
        OUT PSID *&ppLogonAllowSIDs, 
        OUT PSID *&ppLogonDenySIDs,
        OUT LPDWORD pcLogonAllowSIDs, 
        OUT LPDWORD pcLogonDenySIDs)
{
    PACL pNewDacl = NULL;
    PACL pOldDacl = NULL;
    BOOL bNewDaclPresent = FALSE;
    BOOL bOldDaclPresent = FALSE;
    BOOL bDaclDefaulted = FALSE;
   
    ppLogonAllowSIDs = NULL;
    ppLogonDenySIDs = NULL;
    *pcLogonAllowSIDs = 0;
    *pcLogonDenySIDs = 0;
    
    ASSERT(m_pWorldSid);
    ASSERT(m_pOriginalSD);
    
    if(!GetSecurityDescriptorDacl(pSecurityDescriptor,&bNewDaclPresent,&pNewDacl,&bDaclDefaulted))
    {
        return FALSE;
    }

    if(!GetSecurityDescriptorDacl(m_pOriginalSD,&bOldDaclPresent,&pOldDacl,&bDaclDefaulted))
    {
        return FALSE;
    }

    ACL_SIZE_INFORMATION asiAclSize; 
	DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *pAce; 
    DWORD dwAcl_i;
    
    BOOL bResult = FALSE;

    DWORD dwAllowSIDsIndex = 0;

    if(pNewDacl)
    {
        if (GetAclInformation(pNewDacl, 
                    (LPVOID)&asiAclSize, 
                    (DWORD)dwBufLength, 
                    (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            ppLogonAllowSIDs = new PSID[asiAclSize.AceCount];
            
            if(ppLogonAllowSIDs)
            {
                for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
                { 

                    if(GetAce( pNewDacl, dwAcl_i, (LPVOID *)&pAce) &&
                        pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&    
                        pAce->Mask & WINSTATION_LOGON) 
                    {
                        if(UserHasLogonPermission(pNewDacl,PSID(&pAce->SidStart)) && 
                            !UserHasLogonPermission(pOldDacl,PSID(&pAce->SidStart)))
                        {
                            ppLogonAllowSIDs[dwAllowSIDsIndex] =  PSID(&pAce->SidStart);
                            dwAllowSIDsIndex++;
                        }
                    
                    }
                }

                *pcLogonAllowSIDs = dwAllowSIDsIndex;
                bResult = TRUE;
            }
        }
    }
    else
    {
        //No DACL in new SD. Let's if Everyone already had Logon permission
        if(!UserHasLogonPermission(pOldDacl,m_pWorldSid))
        {
            ppLogonAllowSIDs = new PSID[1];
            
            if(ppLogonAllowSIDs)
            {
                ppLogonAllowSIDs[0] = m_pWorldSid;
                *pcLogonAllowSIDs = 1;
                bResult = TRUE;
            }
        }
        else
        {
            bResult = TRUE;
        }
    }

    if(!bResult)
    {
        return FALSE;
    }
    
    bResult = FALSE;

    DWORD dwDenySIDsIndex = 0;

    if(pOldDacl)
    {
        if (GetAclInformation(pOldDacl, 
                    (LPVOID)&asiAclSize, 
                    (DWORD)dwBufLength, 
                    (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            ppLogonDenySIDs = new PSID[asiAclSize.AceCount];
            
            if(ppLogonDenySIDs)
            {
                for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
                { 

                    if(GetAce( pOldDacl, dwAcl_i, (LPVOID *)&pAce) &&
                        pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE &&
                        pAce->Mask & WINSTATION_LOGON) 
                    {
                        if(UserHasLogonPermission(pOldDacl,PSID(&pAce->SidStart)) && 
                            !UserHasLogonPermission(pNewDacl,PSID(&pAce->SidStart)))
                        {
                            ppLogonDenySIDs[dwDenySIDsIndex] =  PSID(&pAce->SidStart);
                            dwDenySIDsIndex++;
                        }
                    
                    }
                }

                *pcLogonDenySIDs = dwDenySIDsIndex;
                bResult = TRUE;
            }
        }
    }
    else
    {
        if(!UserHasLogonPermission(pNewDacl,m_pWorldSid))
        {
            ppLogonDenySIDs = new PSID[1];

            if(ppLogonDenySIDs)
            {
                ppLogonDenySIDs[0] =  m_pWorldSid;
                *pcLogonDenySIDs = 1;
                bResult = TRUE;
            }
        }
        else
        {
            bResult = TRUE;
        }

    }

    if(!bResult && ppLogonAllowSIDs)
    {
        delete ppLogonAllowSIDs;
        ppLogonAllowSIDs = NULL;
        *pcLogonAllowSIDs = 0;
    }

    return bResult;
}

//*************************************************************
//
//  CSecurityPage::UserHasLogonPermission()
//
//  Purpose:    Checks if a user represented by a pSid has explicit 
//              Logon permission 
//
//  Parameters: PACL pDacl - ACL to search for user
//              PSID pSid - User's SID.
//    
//  Return:     TRUE if a user represented by a pSid has explicit 
//              Logon permission.
//              FALSE if not, or in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::UserHasLogonPermission(
    PACL pDacl, 
    PSID pSid)
{
    ASSERT(m_pWorldSid);

    if(!pDacl)
    {
        //DACL == NULL means Everyone - Full Control
        //Let's see if pSid is Everyone's SID
        return EqualSid(pSid, m_pWorldSid);
    }


    ACL_SIZE_INFORMATION asiAclSize; 
	DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *pAce; 
    DWORD dwAcl_i;
    
    if (GetAclInformation(pDacl, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
    { 
 
        for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
        { 

            if(GetAce( pDacl, dwAcl_i, (LPVOID *)&pAce) && 
                (pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE ||
                pAce->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ) 
            {
                if(EqualSid(pSid,PSID(&pAce->SidStart)) &&
                    pAce->Mask & WINSTATION_LOGON)
                {
                    //Denied ACEs always go first
                    if(pAce->Header.AceType == ACCESS_DENIED_ACE_TYPE)
                    {
                        return FALSE;
                    }
                    else
                    {
                       return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}

//*************************************************************
//
//  CSecurityPage::UserHasLogonPermission()
//
//  Purpose:    Checks if a user represented by a pSid has explicit 
//              Logon permission 
//
//  Parameters: PSECURITY_DESCRIPTOR pSecurityDescriptor - 
//                  SD to search for user
//              PSID pSid - User's SID.
//    
//  Return:     TRUE if a user represented by a pSid has explicit 
//              Logon permission.
//              FALSE if not, or in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::UserHasLogonPermission(
    PSECURITY_DESCRIPTOR pSecurityDescriptor, 
    PSID pSid)
{
    PACL pDacl;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
   
    if(!GetSecurityDescriptorDacl(pSecurityDescriptor,&bDaclPresent,&pDacl,&bDaclDefaulted))
    {
        return FALSE;
    }

    return UserHasLogonPermission(pDacl, pSid);
}

//*************************************************************
//
//  CSecurityPage::GetUsersWhoAlreadyHasTSLogonRight()
//
//  Purpose:    Creates an array of SIDs of all users, who have 
//              SE_REMOTE_INTERACTIVE_LOGON_NAME right.
//
//  Parameters: OUT PSID *&ppLogonRightSIDs - array of SIDs of users, 
//                        who have SE_REMOTE_INTERACTIVE_LOGON_NAME right
//              OUT LPDWORD pcLogonRightSIDs - number of entries 
//                        in ppLogonRightSIDs
//
//  Return:     TRUE if success
//              FALSE in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::GetUsersWhoAlreadyHasTSLogonRight(
    PSID *&ppLogonRightSIDs, 
    LPDWORD pcLogonRightSIDs)
{
    ppLogonRightSIDs = NULL;
    *pcLogonRightSIDs = 0;

    //Open Lsa Policy on a local machine
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    LSA_HANDLE hPolicy = NULL;
    NTSTATUS Status;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
    ZeroMemory(&ServerString, sizeof(ServerString)); 
    
    Status = LsaOpenPolicy(&ServerString, &ObjectAttributes, 
        POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES, &hPolicy);

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }
    
    LSA_UNICODE_STRING UserRight;
    PLSA_ENUMERATION_INFORMATION EnumerationBuffer;
	ULONG CountReturned;
    DWORD dwSidBufferSize = 0;

    InitLsaString( &UserRight, T2W(SE_REMOTE_INTERACTIVE_LOGON_NAME));

    Status=LsaEnumerateAccountsWithUserRight(
					hPolicy,
					&UserRight,
					(PVOID *)&EnumerationBuffer,
					&CountReturned);
    if(NT_SUCCESS(Status))
    {
        dwSidBufferSize = CountReturned * sizeof(PSID);
        
        DWORD i;

        for(i=0; i<CountReturned; i++)
        {
            dwSidBufferSize += GetLengthSid(EnumerationBuffer[i].Sid);
        }
        
        ppLogonRightSIDs = (PSID *)new BYTE[dwSidBufferSize];

        if(ppLogonRightSIDs)
        {
            DWORD_PTR CurOffset = DWORD_PTR(CountReturned * sizeof(PSID));
            DWORD CurSidLength = 0;

            for(i=0; i<CountReturned; i++)
            {
                ppLogonRightSIDs[i] = PSID( DWORD_PTR(ppLogonRightSIDs) + CurOffset);
                CurSidLength = GetLengthSid(EnumerationBuffer[i].Sid);
                CopySid(CurSidLength, ppLogonRightSIDs[i], EnumerationBuffer[i].Sid);
                CurOffset += CurSidLength;
            }

            *pcLogonRightSIDs = CountReturned;
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }

        LsaFreeMemory( EnumerationBuffer );
    }
    else
    {
        //Nobody has this right
        if(Status == STATUS_NO_MORE_ENTRIES)
        {
            Status = STATUS_SUCCESS;
        }
    }

    LsaClose(hPolicy);

    return (NT_SUCCESS(Status));

}

//*************************************************************
//
//  CSecurityPage::GrantRightToUser()
//
//  Purpose:    Grants SE_REMOTE_INTERACTIVE_LOGON_NAME 
//              right to a user.
//
//  Parameters: IN PSID pSID - User's SID
//
//  Return:     TRUE if success
//              FALSE in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::GrantRightToUser( 
        IN PSID pSID )
{
    //Open Lsa Policy on a local machine
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    LSA_HANDLE hPolicy = NULL;
    NTSTATUS Status;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
    ZeroMemory(&ServerString, sizeof(ServerString)); 
    
    Status = LsaOpenPolicy(&ServerString, &ObjectAttributes, 
        POLICY_LOOKUP_NAMES | POLICY_CREATE_ACCOUNT, &hPolicy);

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }
    
    LSA_UNICODE_STRING UserRight;

    InitLsaString( &UserRight, T2W(SE_REMOTE_INTERACTIVE_LOGON_NAME));

    Status=LsaAddAccountRights( hPolicy, pSID, &UserRight, 1 );
    
    LsaClose(hPolicy);

    return (NT_SUCCESS(Status));
}

//*************************************************************
//
//  CSecurityPage::RevokeRightFromUser()
//
//  Purpose:    Revokes SE_REMOTE_INTERACTIVE_LOGON_NAME 
//              right from a user.
//
//  Parameters: IN PSID pSID - User's SID
//
//  Return:     TRUE if success
//              FALSE in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::RevokeRightFromUser( 
        IN PSID pSID )
{
    //Open Lsa Policy on a local machine
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    LSA_HANDLE hPolicy = NULL;
    NTSTATUS Status;

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
    ZeroMemory(&ServerString, sizeof(ServerString)); 
    
    Status = LsaOpenPolicy(&ServerString, &ObjectAttributes, POLICY_LOOKUP_NAMES, &hPolicy);

    if(!NT_SUCCESS(Status))
    {
        return FALSE;
    }
    
    LSA_UNICODE_STRING UserRight;

    InitLsaString( &UserRight, T2W(SE_REMOTE_INTERACTIVE_LOGON_NAME));

    Status=LsaRemoveAccountRights(hPolicy, pSID, FALSE, &UserRight, 1);
    
    LsaClose(hPolicy);

    return (NT_SUCCESS(Status));
}

//*************************************************************
//
//  CSecurityPage::CanRevokeRight()
//
//  Purpose:    Checks out that user represented by pSid does not
//              have Logon permission to any connection, 
//              excluding connection referred by pWSName.
//
//  Parameters: IN PWINSTATIONNAMEW pWSName - connection name.
//              IN PSID pSID - User's SID
//
//  Return:     TRUE if it is safe to take this right from the user
//              FALSE if not (i.e. the user has Logon permission to at
//              least one connection excluding connection referred by
//              pWSName), or in case of any error.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/01     skuzin     Created
//
//*************************************************************
BOOL 
CSecurityPage::CanRevokeRight( 
        IN PWINSTATIONNAMEW pWSName, 
        IN PSID pSID )
{
    ICfgComp *pCfgcomp = NULL;

    if( m_pParent == NULL || m_pParent->m_pResNode == NULL ||
        m_pParent->m_pResNode->GetServer( &pCfgcomp ) == 0)
    {
        return FALSE;
    }

    WS *pWs;
    ULONG ulitems = 0;
    ULONG cbSize = 0;

    if( !SUCCEEDED( pCfgcomp->GetWinstationList( &ulitems , &cbSize , &pWs ) ) )
    {
        return FALSE;
    }
    
    PSECURITY_DESCRIPTOR pSD;
    long lSDsize;
    BOOL bResult = TRUE;
    
    for( ULONG i = 0 ; i < ulitems ; ++i )
    {

        if( lstrcmpi( pWs[ i ].Name , pWSName ) )
        {
            if( SUCCEEDED( pCfgcomp->GetSecurityDescriptor( pWs[ i ].Name , &lSDsize , &pSD ) ) )
            {
                if(UserHasLogonPermission(pSD,pSID))
                {
                    bResult = FALSE;
                    LocalFree(pSD);
                    break;
                }

                LocalFree(pSD);
            }
            else
            {
                bResult = FALSE;
                break;
            }
        }
    }
    
    if(bResult)
    {

        //Check also default security descriptor
        if( SUCCEEDED( pCfgcomp->GetDefaultSecurityDescriptor( &lSDsize , &pSD ) ) )
        {
            if(UserHasLogonPermission(pSD,pSID))
            {
                bResult = FALSE;
            }

            LocalFree(pSD);
        }
        else
        {
            bResult = FALSE;
        }
    }
    
    CoTaskMemFree( pWs );
    return bResult;
}

void 
InitLsaString(
    OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String)
{
    DWORD StringLength;

    if (String == NULL) {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
} 

typedef HPROPSHEETPAGE (*CREATEPAGE_PROC) (LPSECURITYINFO);

//-----------------------------------------------------------------------------
HPROPSHEETPAGE GetSecurityPropertyPage( CPropsheet *pParent )
{
    LPVOID *pvFunction = &g_aAclFunctions[ ACLUI_CREATE_PAGE ].lpfnFunction;

    if( *pvFunction == NULL )
    {
        g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst = LoadLibrary( TEXT("ACLUI.DLL") );

        ASSERT( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst != NULL );

        if( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst == NULL )
        {
            return NULL;
        }

        *pvFunction =  ( LPVOID )GetProcAddress( g_aAclFunctions[ ACLUI_CREATE_PAGE ].hInst , g_aAclFunctions[ ACLUI_CREATE_PAGE ].pcstrFunctionName );

        ASSERT( *pvFunction != NULL );

        if( *pvFunction == NULL )
        {
            return NULL;
        }

        CComObject< CSecurityPage > *psecinfo = NULL;

        HRESULT hRes = CComObject< CSecurityPage >::CreateInstance( &psecinfo );

        if( SUCCEEDED( hRes ) )
        {
            // InitStrings();

            psecinfo->SetParent( pParent );

            return ( ( CREATEPAGE_PROC )*pvFunction )( psecinfo );
        }

    }

    return NULL;
}

//-----------------------------------------------------------------------------
// Error messag boxes
//
void ErrMessage( HWND hwndOwner , INT_PTR iResourceID )
{
    xxxErrMessage( hwndOwner , iResourceID , IDS_ERROR_TITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void TscAccessDeniedMsg( HWND hwnd )
{
    xxxErrMessage( hwnd , IDS_TSCACCESSDENIED , IDS_TSCERRTITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void TscGeneralErrMsg( HWND hwnd )
{
    xxxErrMessage( hwnd , IDS_TSCERRGENERAL , IDS_TSCERRTITLE , MB_OK | MB_ICONERROR );
}

//-----------------------------------------------------------------------------
void xxxErrMessage( HWND hwnd , INT_PTR nResMessageId , INT_PTR nResTitleId , UINT nFlags )
{
    TCHAR tchErrMsg[ 256 ];

    TCHAR tchErrTitle[ 80 ];

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) ,  ( UINT )nResMessageId , tchErrMsg , SIZE_OF_BUFFER( tchErrMsg ) ) );

    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) ,  ( UINT )nResTitleId , tchErrTitle , SIZE_OF_BUFFER( tchErrTitle ) ) );

    if( hwnd == NULL )
    {
        nFlags |= MB_TASKMODAL;
    }

    MessageBox( hwnd , tchErrMsg , tchErrTitle , nFlags ) ; //MB_OK|MB_ICONERROR );
}

//-----------------------------------------------------------------------------

void ReportStatusError( HWND hwnd , DWORD dwStatus )
{
    LPTSTR pBuffer = NULL;

    TCHAR tchTitle[ 80 ];

    TCHAR tchBuffer[ 256 ];

    TCHAR tchErr[ 256 ];

    if( dwStatus != 0 )
    {

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_TSCERRTITLE , tchTitle , SIZE_OF_BUFFER( tchTitle ) ) );

        VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_REPORTERROR , tchBuffer , SIZE_OF_BUFFER( tchBuffer ) ) );


        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_FROM_SYSTEM,
                     NULL,                                          //ignored
                     dwStatus    ,                                //message ID
                     MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                     (LPTSTR)&pBuffer,                              //address of buffer pointer
                     0,                                             //minimum buffer size
                     NULL);                                         //no other arguments

        wsprintf( tchErr , tchBuffer , pBuffer );

        ::MessageBox( hwnd , tchErr , tchTitle , MB_OK | MB_ICONERROR );

        if( pBuffer != NULL )
        {
            LocalFree( pBuffer );
        }
    }

}

//=------------------------------------------------------------------------------------------------
// xxxLegacDenyCleanup -- checked for the old LOGOFF bit
//=------------------------------------------------------------------------------------------------
DWORD xxxLegacyLogoffCleanup( PSECURITY_DESCRIPTOR *ppSD , PBOOL pfDaclChanged )
{
    ACL_SIZE_INFORMATION asi;
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    PACL pDacl = NULL;
    SECURITY_DESCRIPTOR_CONTROL sdc;
    DWORD dwREV;
    SECURITY_DESCRIPTOR absSD;
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;
    BOOL bOwnerDefaulted;
    PSID psidOwner = NULL;
    PVOID pAce = NULL;
    PACL pSacl = NULL;
    PSECURITY_DESCRIPTOR pOldSD = NULL;

    DWORD dwStatus = ERROR_SUCCESS;

    ZeroMemory( &asi , sizeof( ACL_SIZE_INFORMATION ) );

    if( !GetSecurityDescriptorDacl( *ppSD ,
                                    &bDaclPresent , 
                                    &pDacl,
                                    &bDaclDefaulted ) )
    {
        dwStatus = GetLastError();
        DBGMSG( L"xxxLegacyLogoffCleanup@GetSecurityDescriptorDacl returned 0x%x\n" , dwStatus );
        return dwStatus;
    }

    do
    {
        *pfDaclChanged = FALSE;

        if( !GetAclInformation( pDacl , &asi , sizeof( asi ) , AclSizeInformation ) )
        {
            dwStatus = GetLastError( );

            DBGMSG( L"xxxLegacyLogoffCleanup@GetAclInformation returned 0x%x\n" , dwStatus );

            break;
        }  

        // killed denied logoff.

        BYTE bAceType;

        for( int i = 0 ; i < ( int )asi.AceCount ; ++i )
        {
            if( !GetAce( pDacl , i , &pAce ) )
            {
                dwStatus = GetLastError( );

                DBGMSG( L"xxxLegacyLogoffCleanup@GetAce returned 0x%x\n" , dwStatus );

                break;
            }

            bAceType = ( ( PACE_HEADER )pAce )->AceType;

            if( bAceType == ACCESS_DENIED_ACE_TYPE || bAceType == ACCESS_ALLOWED_ACE_TYPE )
            {
                // if the denied ace represents a single bit get rid of it
                if( ( ( ACCESS_DENIED_ACE * )pAce )->Mask == WINSTATION_LOGOFF )
                {
                    if( DeleteAce( pDacl , i ) )
                    {
                        // pDacl should have been reallocated to we need to re-obtain the acl info
                        GetAclInformation( pDacl , &asi , sizeof( asi ) , AclSizeInformation );

                        // reset the loop to point to the first ace
                        i=-1;

                        *pfDaclChanged = TRUE;
                    }
                }
                else if( ( ( ACCESS_DENIED_ACE * )pAce )->Mask & WINSTATION_LOGOFF )
                {
                    // if the denied ace is a collection of bits with one as logoff turn the bit off
                    ( ( ACCESS_DENIED_ACE * )pAce )->Mask ^= WINSTATION_LOGOFF;

                    *pfDaclChanged = TRUE;
                }
            }
        }

        

        if( dwStatus == ERROR_SUCCESS && *pfDaclChanged )
        {
            //
            // Convert SelfRel to Absolute
            //

            DWORD dwSDLen = 0;
            
            pOldSD = *ppSD;

            GetSecurityDescriptorControl( *ppSD , &sdc , &dwREV );

            InitializeSecurityDescriptor( &absSD , dwREV );
    
            SetSecurityDescriptorDacl( &absSD , bDaclPresent , pDacl , bDaclDefaulted );

            GetSecurityDescriptorSacl( *ppSD , &bSaclPresent , &pSacl , &bSaclDefaulted );

            SetSecurityDescriptorSacl( &absSD , bSaclPresent , pSacl , bSaclDefaulted );

            GetSecurityDescriptorOwner( *ppSD , &psidOwner , &bOwnerDefaulted );

            SetSecurityDescriptorOwner( &absSD , psidOwner , FALSE );

            SetSecurityDescriptorGroup( &absSD , psidOwner , FALSE );            

            *ppSD = NULL;

            if( !MakeSelfRelativeSD( &absSD , *ppSD , &dwSDLen ) )
            {
                ODS( L"xxxLegacyLogoffCleanup -- MakeSelfRelativeSD failed as expected\n" );

                *ppSD = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , dwSDLen );

                if( *ppSD == NULL )
                {
                    dwStatus = ERROR_NOT_ENOUGH_MEMORY;

                    DBGMSG( L"xxxLegacyLogoffCleanup -- LocalAlloc failed 0x%x\n" , dwStatus );

                    break;
                }

                if( !MakeSelfRelativeSD( &absSD , *ppSD , &dwSDLen ) )
                {
                    dwStatus = GetLastError( );

                    DBGMSG( L"xxxLegacyLogoffCleanup -- MakeSelfRelativeSD failed 0x%x\n" , dwStatus );

                    break;
                }   
                
            }            
        }

    }while( 0 );

    if( pOldSD != NULL )
    {
        LocalFree( pOldSD );
    }

    return dwStatus;

}

//
INT_PTR APIENTRY 
CustomSecurityDlgProc (
        HWND hDlg, 
        UINT uMsg, 
        WPARAM wParam, 
        LPARAM lParam)
{
    UNREFERENCED_PARAMETER( hDlg );

    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This may seem that it does nothin, but it casues this function to return TRUE
        // otherwise, you won't get this dialog!
        break;

    case WM_NOTIFY:
        
        switch (((NMHDR FAR*)lParam)->code)
        {

        case NM_CLICK:
        case NM_RETURN:
            if(wParam == IDC_GP_LINK)
            {
                ShellExecute(NULL,TEXT("open"),TEXT("gpedit.msc"),NULL,NULL,SW_SHOW);
                break;  
            }
            else
            {
                return FALSE;
            }
            

        default:
            return FALSE;
        }
        
        break;
    
    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg,0);
            break;
        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tscc\snapin\tscc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// tscc.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f tsccps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "tscc.h"

#include "tswiz_i.c"
#include "tscc_i.c"
#include "srvsetex_i.c"


#include "Compdata.h"

LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild );


extern const GUID GUID_ResultNode = { 0xfe8e7e84 , 0x6f63 , 0x11d2 , { 0x98, 0xa9 , 0x0 , 0x0a0 , 0xc9 , 0x25 , 0xf9 , 0x17 } };

TCHAR tchSnapKey[]    = TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

TCHAR tchNameString[] = TEXT( "NameString" );

TCHAR tchNameStringIndirect[] = TEXT( "NameStringIndirect" );

TCHAR tchAbout[]      = TEXT( "About" );

TCHAR tchNodeType[]   = TEXT( "NodeTypes" );

TCHAR tchStandAlone[] = TEXT( "StandAlone" );

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_Compdata, CCompdata)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{        
        _Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
       
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HKEY hKeyRoot , hKey;
    
    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];//TEXT( "Software\\Microsoft\\MMC\\Snapins\\" );

    lstrcpy( tchKey , tchSnapKey );

    StringFromGUID2( CLSID_Compdata , tchGUID , SIZE_OF_BUFFER( tchGUID ) );

    lstrcat( tchKey , tchGUID );

    if( RegCreateKey( HKEY_LOCAL_MACHINE , tchKey , &hKeyRoot ) != ERROR_SUCCESS )
    {
        return GetLastError( );
    }

    TCHAR tchBuf[ MAX_PATH ];
    TCHAR tchSysDllPathName[ MAX_PATH + 1];
    DWORD dwLen;

    dwLen = GetModuleFileName( _Module.GetResourceInstance( ) , tchSysDllPathName , MAX_PATH );
	
    // Null terminate the end of string, prefast is complaining about it BUG: 617151
    // GetModuleFileName returns the length of the string, if it fails it returns 0
    tchSysDllPathName[dwLen] = L'\0';


    VERIFY_E( 0 , LoadString( _Module.GetResourceInstance( ) , IDS_NAMESTRING , tchBuf , SIZE_OF_BUFFER( tchBuf ) ) );

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchNameString , NULL , REG_SZ , ( PBYTE )&tchBuf[ 0 ] , SIZE_OF_BUFFER( tchBuf ) ) );
    
    wsprintf( tchBuf , L"@%s,-%d", tchSysDllPathName , IDS_NAMESTRING );    

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchNameStringIndirect , NULL , REG_SZ , ( PBYTE )&tchBuf[ 0 ] , SIZE_OF_BUFFER( tchBuf ) ) );

    VERIFY_S( ERROR_SUCCESS , RegSetValueEx( hKeyRoot , tchAbout , NULL , REG_SZ , ( PBYTE )&tchGUID[ 0 ] , sizeof( tchGUID ) ) );
    
    lstrcpy( tchKey , tchStandAlone );

    RegCreateKey( hKeyRoot , tchKey , &hKey );

    RegCloseKey( hKey );

	lstrcpy( tchKey , tchNodeType );

	RegCreateKey( hKeyRoot , tchKey , &hKey );

	TCHAR szGUID[ 40 ];

	HKEY hDummy;

	StringFromGUID2( GUID_ResultNode , szGUID , SIZE_OF_BUFFER( szGUID ) );

	RegCreateKey( hKey , szGUID , &hDummy );

	RegCloseKey( hDummy );

	RegCloseKey( hKey );

    RegCloseKey( hKeyRoot );

	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HKEY hKey;

    TCHAR tchGUID[ 40 ];

    TCHAR tchKey[ MAX_PATH ];

    lstrcpy( tchKey , tchSnapKey );

    if( RegOpenKey( HKEY_LOCAL_MACHINE , tchKey , &hKey ) != ERROR_SUCCESS )
    {
        return GetLastError( ) ;
    }

    StringFromGUID2( CLSID_Compdata , tchGUID , SIZE_OF_BUFFER( tchGUID ) );

	RecursiveDeleteKey( hKey , tchGUID );
	
	RegCloseKey( hKey );
    
	_Module.UnregisterServer();

	return S_OK;
}

//---------------------------------------------------------------------------
// Delete a key and all of its descendents.
//---------------------------------------------------------------------------
LONG RecursiveDeleteKey( HKEY hKeyParent , LPTSTR lpszKeyChild )
{
	// Open the child.
	HKEY hKeyChild;

	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild , 0 , KEY_ALL_ACCESS, &hKeyChild);

	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}

	// Enumerate all of the decendents of this child.

	FILETIME time;

	TCHAR szBuffer[256];

	DWORD dwSize = SIZE_OF_BUFFER( szBuffer );

	while( RegEnumKeyEx( hKeyChild , 0 , szBuffer , &dwSize , NULL , NULL , NULL , &time ) == S_OK )
	{
        // Delete the decendents of this child.

		lRes = RecursiveDeleteKey(hKeyChild, szBuffer);

		if (lRes != ERROR_SUCCESS)
		{
			RegCloseKey(hKeyChild);

			return lRes;
		}

		dwSize = SIZE_OF_BUFFER( szBuffer );
	}

	// Close the child.

	RegCloseKey( hKeyChild );

	// Delete this child.

	return RegDeleteKey( hKeyParent , lpszKeyChild );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\tskill\tskill.c ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*****************************************************************************
*
*   TSKILL.C for Windows NT Terminal Server
*
*  Description:
*
*     tskill [processID] [/v] [/?]
*
****************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <winstaw.h>
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <utilsub.h>
#include <allproc.h>
#include <winnlsp.h>

#include "tskill.h"
#include "printfoa.h"

WCHAR  user_string[MAX_IDS_LEN+1];


// max length of the locale string
#define MAX_LOCALE_STRING 64

#define MAXCBMSGBUFFER 2048

WCHAR MsgBuf[MAXCBMSGBUFFER];

USHORT help_flag = FALSE;
USHORT v_flag    = FALSE;
USHORT a_flag    = FALSE;

HANDLE hServerName = SERVERNAME_CURRENT;
WCHAR  ServerName[MAX_IDS_LEN+1];
WCHAR  ipLogonId[MAX_IDS_LEN+1];

TOKMAP ptm[] =
{
   {L" ",       TMFLAG_REQUIRED, TMFORM_STRING, MAX_IDS_LEN,   user_string},
   {L"/server", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, ServerName},
   {L"/id",      TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN, &ipLogonId},
   {L"/?",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
   {L"/v",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &v_flag},
   {L"/a",      TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &a_flag},
   {0, 0, 0, 0, 0}
};


/*
 * Local function prototypes.
 */
void Usage( BOOLEAN bError );
BOOLEAN KillProcessUseName();
BOOLEAN KillProcessButConfirmTheID( ULONG TargetPid );
BOOLEAN KillProcess(ULONG TargetPid);
BOOLEAN MatchPattern(PWCHAR String, PWCHAR Pattern);
BOOLEAN CheckImageNameAndKill(PTS_SYS_PROCESS_INFORMATION pProcessInfo);


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main(INT argc, CHAR **argv)
{
    ULONG TargetPid;
    int  i;
    DWORD  rc;
    WCHAR *CmdLine, **argvW, *StopChar;
    WCHAR wszString[MAX_LOCALE_STRING + 1];
       
    setlocale(LC_ALL, ".OCP");
    
    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page    
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);
    
    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    rc = ParseCommandLine(argc-1, argvW+1, ptm, 0);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag || rc ) {

        if ( !help_flag ) {

            Usage(TRUE);
            return(FAILURE);

        } else {

            Usage(FALSE);
            return(SUCCESS);
        }
    }

        // If no remote server was specified, then check if we are running under Terminal Server
        if ((!IsTokenPresent(ptm, L"/server") ) && (!AreWeRunningTerminalServices()))
        {
            ErrorPrintf(IDS_ERROR_NOT_TS);
            return(FAILURE);
        }

    /*
     * Open the specified server
     */
    if( ServerName[0] ) {
        hServerName = WinStationOpenServer( ServerName );
        if( hServerName == NULL ) {
            StringErrorPrintf(IDS_ERROR_SERVER,ServerName);
            PutStdErr( GetLastError(), 0 );
            return(FAILURE);
        }
    }


    /*
    * Check for the command line pid and convert to a ULONG
    */
    TargetPid = wcstoul(user_string, &StopChar, 10);

    if (!TargetPid) {
        //Get the process IDs and Kill.
        return (KillProcessUseName());
    } else if (*StopChar) {
        StringErrorPrintf(IDS_ERROR_BAD_PID_NUMBER, user_string);
        return(FAILURE);
    // end of getting the process ids from names
    } else {
        return( KillProcessButConfirmTheID( TargetPid ) );
    }

}  /* main() */



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {

        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }
   ErrorPrintf(IDS_USAGE1);
   ErrorPrintf(IDS_USAGE2);
   ErrorPrintf(IDS_USAGE3);
   ErrorPrintf(IDS_USAGE4);
   ErrorPrintf(IDS_USAGE5);
   ErrorPrintf(IDS_USAGE6);
   ErrorPrintf(IDS_USAGE7);
   ErrorPrintf(IDS_USAGE8);
   ErrorPrintf(IDS_USAGE9);
   ErrorPrintf(IDS_USAGEA);
}  /* Usage() */


// ***********************************************************************
// KillProcessUseName
//    Gets all the ProcessIDs of all the processes with the name passed
//    to the command line and kill them. Returns FALSE if there are no
//    processes running with the process names.
//
// ***********************************************************************

BOOLEAN KillProcessUseName()
{

    ULONG LogonId, ReturnLength, BufferOffset=0, ulLogonId;
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;

    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    ULONG   NumberOfProcesses;
    ULONG   j;
    BOOLEAN bRet;
    short nTasks=0;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG ProcessSessionId;
    DWORD dwError;

    // if a servername is specified and session id is not specified,
    // prompt an error.

    if (ServerName[0] && !ipLogonId[0] && !a_flag) {
        StringErrorPrintf(IDS_ERROR_ID_ABSENT, ServerName);
        return FAILURE;
    }


    // convert the input task name to lower
    _wcslwr(user_string);

     /*
     *  Get current LogonId
     */
    CurrentLogonId = GetCurrentLogonId();

    // get the login id of the current user.
    //if (!WinStationQueryInformation(hServerName, LOGONID_CURRENT,
    //    WinStationInformation, &WSInfo, sizeof(WSInfo), &ReturnLength)) {
    //    fprintf(stdout, "Error QueryInfo failed");
    //}

    //convert the input logon id to ulong

    ulLogonId = wcstoul(ipLogonId, NULL, 10);


    //Use the input logon id if passed. If not use the current logon ID.
    //LogonId = (!wcscmp(ipLogonId,""))? WSInfo.LogonId:ulLogonId;
    LogonId = (!ipLogonId[0])? CurrentLogonId:ulLogonId;

    bRet = WinStationGetAllProcesses( hServerName,
                                      GAP_LEVEL_BASIC,
                                      &NumberOfProcesses,
                                      &ProcessArray);
    if (bRet == TRUE)
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[j].pTsProcessInfo);
            ProcessSessionId = pProcessInfo->SessionId;

            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if(( ProcessSessionId == LogonId)|| a_flag)
            {
                if (CheckImageNameAndKill(pProcessInfo))
                {
                    nTasks++;
                }
            }
        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            return (FALSE);
        }

        //Enumerate All the processes in order to get the ProcessId
        if (!WinStationEnumerateProcesses(hServerName, (PVOID *)&pProcessBuffer)) {
            if( pProcessBuffer)
                WinStationFreeMemory(pProcessBuffer);
            ErrorPrintf(IDS_ERROR_ENUM_PROCESS);
            return FAILURE;
        }

        //Make use of the ProcessBuffer to get the Process ID after
        //checking for a match in Logon User Name

        do {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)
                &(((PUCHAR)pProcessBuffer)[BufferOffset]);

            /*
             * Point to the CITRIX_INFORMATION which follows the Threads
             */
            pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                         (((PUCHAR)pProcessInfo) +
                          SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                          (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

            if( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {

                ProcessSessionId = pCitrixInfo->LogonId;

            } else {

                ProcessSessionId = (ULONG)(-1);
           }


            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if(( ProcessSessionId == LogonId)|| a_flag)
            {
                if (CheckImageNameAndKill(pProcessInfo))
                {
                    nTasks++;
                }
            }

            BufferOffset += pProcessInfo->NextEntryOffset;

        } while (pProcessInfo->NextEntryOffset != 0);

        if( pProcessBuffer)
        {
            WinStationFreeMemory(pProcessBuffer);
        }
    }
    if(!nTasks)
    {
        StringErrorPrintf(IDS_ERROR_BAD_PROCESS, user_string);
        return FAILURE;
    }

    return SUCCESS;

}
// ***********************************************************************
BOOLEAN
CheckImageNameAndKill(PTS_SYS_PROCESS_INFORMATION pProcessInfo)
{
    WCHAR   ImageName[MAXNAME + 2] = { 0 };
    PWCHAR  p;
    ULONG   TargetPid;
    BOOLEAN bRet = FALSE;

    ImageName[MAXNAME+1] = 0; //force the end of string

    if( pProcessInfo->ImageName.Length == 0 )
    {
        ImageName[0] = 0;
    }
    else if( pProcessInfo->ImageName.Length > MAXNAME * 2)
    {
        wcsncpy(ImageName, pProcessInfo->ImageName.Buffer, MAXNAME);
    }
    else
    {
        wcsncpy(ImageName,  pProcessInfo->ImageName.Buffer, pProcessInfo->ImageName.Length/2);
        ImageName[pProcessInfo->ImageName.Length/2] = 0;
    }


    //convert the imagename to lower
    _wcslwr(ImageName);

    if(ImageName != NULL) {
        p = wcschr(ImageName,'.');
        if (p)
            p[0] = L'\0';

        //get the ProcessID if the imagename matches
        if(MatchPattern(ImageName, user_string) ) {
            TargetPid = (ULONG)(ULONG_PTR)(pProcessInfo->UniqueProcessId);
            bRet = TRUE;
            KillProcess(TargetPid);
        }
    }
    return bRet;
}



// ***********************************************************************
// KillProcess:
//      Kills the process with the specific ProcessID.
// ***********************************************************************

BOOLEAN KillProcess(ULONG TargetPid)
{
    DWORD rc;

    /*
     * Kill the specified process.
     */
    if (v_flag)
        Message(IDS_KILL_PROCESS, TargetPid);


    if ( !WinStationTerminateProcess( hServerName, TargetPid, 0 ) ) {
        rc = GetLastError();
        StringErrorPrintf(IDS_ERROR_KILL_PROCESS_FAILED, user_string);
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL, rc, 0, MsgBuf, MAXCBMSGBUFFER, NULL) != 0)
        {
            fwprintf( stderr, MsgBuf );
        }
        fwprintf( stderr, L"\n");

        return FAILURE;
    }

    return SUCCESS;
}


// ***********************************************************************
// MatchPattern
//      Checks if the passed string matches with the pattern used
//      Return TRUE if it matches and FALSE if not.
//
// String(input)
//       String being checked for the match
// processname (input)
//       Pattern used for the check
// ***********************************************************************


BOOLEAN
MatchPattern(
    PWCHAR String,
    PWCHAR Pattern
    )
{
    WCHAR   c, p, l;

    for (; ;) {
        switch (p = *Pattern++) {
            case 0:                             // end of pattern
                return *String ? FALSE : TRUE;  // if end of string TRUE

            case '*':
                while (*String) {               // match zero or more char
                    if (MatchPattern (String++, Pattern))
                        return TRUE;
                }
                return MatchPattern (String, Pattern);

            case '?':
                if (*String++ == 0)             // match any one char
                    return FALSE;                   // not end of string
                break;

            case '[':
                if ( (c = *String++) == 0)      // match char set
                    return FALSE;                   // syntax

                c = towupper(c);
                l = 0;
                while (p = *Pattern++) {
                    if (p == ']')               // if end of char set, then
                        return FALSE;           // no match found

                    if (p == '-') {             // check a range of chars?
                        p = *Pattern;           // get high limit of range
                        if (p == 0  ||  p == ']')
                            return FALSE;           // syntax

                        if (c >= l  &&  c <= p)
                            break;              // if in range, move on
                    }

                    l = p;
                    if (c == p)                 // if char matches this element
                        break;                  // move on
                }

                while (p  &&  p != ']')         // got a match in char set
                    p = *Pattern++;             // skip to end of set

                break;

            default:
                c = *String++;
                if (c != p)            // check for exact char
                    return FALSE;                   // not a match

                break;
        }
    }
}

// ***********************************************************************
// KillProcessButConfirmTheID
//    Gets all the ProcessIDs of all the processes with the name passed
//    to the command line and kill them. Returns FALSE if there are no
//    processes running with the process names.
//
// ***********************************************************************

BOOLEAN KillProcessButConfirmTheID( ULONG TargetPid )
{

    ULONG BufferOffset=0;
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    ULONG   NumberOfProcesses;
    ULONG   j;
    BOOLEAN bRet;
    BOOLEAN bFound = FALSE;        
    DWORD dwError;


    bRet = WinStationGetAllProcesses( hServerName,
                                      GAP_LEVEL_BASIC,
                                      &NumberOfProcesses,
                                      &ProcessArray);

    if (bRet == TRUE)
    {
        for (j=0; j<NumberOfProcesses; j++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[j].pTsProcessInfo);
            pProcessInfo->SessionId;

            //if a_flag is set, check for the processes in all sessions;
            //if not, check for the processes in one LogonSession only.
            if( pProcessInfo->UniqueProcessId == TargetPid )
            {
                KillProcess( TargetPid );

                bFound = TRUE;

                break;
            }
        }

        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, NumberOfProcesses);

    }
    else    // Maybe a Hydra 4 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            return (FALSE);
        }

        //Enumerate All the processes in order to get the ProcessId
        if (!WinStationEnumerateProcesses(hServerName, (PVOID *)&pProcessBuffer)) {
            if( pProcessBuffer)
                WinStationFreeMemory(pProcessBuffer);
            ErrorPrintf(IDS_ERROR_ENUM_PROCESS);
            return FAILURE;
        }

        //Make use of the ProcessBuffer to get the Process ID after
        //checking for a match in Logon User Name

        do {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) &(((PUCHAR)pProcessBuffer)[BufferOffset]);


            if( pProcessInfo->UniqueProcessId == TargetPid )
            {
                KillProcess( TargetPid );

                bFound = TRUE;

                break;
            }
            
            BufferOffset += pProcessInfo->NextEntryOffset;

        } while (pProcessInfo->NextEntryOffset != 0);

        if( pProcessBuffer)
        {
            WinStationFreeMemory(pProcessBuffer);
        }
    }

    if(!bFound)
    {
        StringErrorPrintf(IDS_ERROR_BAD_PROCESS, user_string);
        return FAILURE;
    }

    return SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utildll\resource.h ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*******************************************************************************
*
* resource.h
*
* UTILDLL resource file defines
*
*
*******************************************************************************/

#define IDS_ALL_LAN_ADAPTERS            1
#define IDS_NO_ADDITIONAL_ERROR_INFO    2
#define IDS_NO_ERROR_TEXT_AVAILABLE     3
#define IDS_STANDARD_ERROR_FORMAT       4
#define IDS_ERROR                       5

#define IDP_ERROR_REGLANA               100
#define IDP_ERROR_REGNETCARD            101

#define IDS_CONSOLE                     200
#define IDS_NETWORK                     201
#define IDS_ASYNC                       202
#define IDS_FRAME                       203
#define IDS_RELIABLE                    204
#define IDS_COMPRESSION                 205
#define IDS_ENCRYPTION                  206
#define IDS_TELNET                      207
#define IDS_UNKNOWN_PROTOCOL            208

#define IDS_ACTIVE                      300
#define IDS_SHORT_ACTIVE                301
#define IDS_CONNECTED                   302
#define IDS_SHORT_CONNECTED             303
#define IDS_CONNECT_QUERY               304
#define IDS_SHORT_CONNECT_QUERY         305
#define IDS_SHADOW                      306
#define IDS_SHORT_SHADOW                307
#define IDS_DISCONNECTED                308
#define IDS_SHORT_DISCONNECTED          309
#define IDS_IDLE                        310
#define IDS_SHORT_IDLE                  311
#define IDS_RESET                       312
#define IDS_SHORT_RESET                 313
#define IDS_DOWN                        314
#define IDS_SHORT_DOWN                  315
#define IDS_INIT                        316
#define IDS_SHORT_INIT                  317
#define IDS_LISTEN                      318
#define IDS_SHORT_LISTEN                319
#define IDS_UNKNOWN                     320
#define IDS_ASYNC_CONNECT_CTS           321
#define IDS_ASYNC_CONNECT_DTR           322
#define IDS_ASYNC_CONNECT_RI            323
#define IDS_ASYNC_CONNECT_DCD           324
#define IDS_ASYNC_CONNECT_FIRSTCHAR     325
#define IDS_ASYNC_CONNECT_PERM          326

#define IDS_INITED                      400
#define IDS_READY                       401
#define IDS_RUN                         402
#define IDS_STANDBY                     403
#define IDS_TERMINATE                   404
#define IDS_WAIT                        405
#define IDS_TRANSIT                     406
#define IDS_STATE_DASHES                407
#define IDS_EXECUTIVE                   408
#define IDS_FREE_PAGE                   409
#define IDS_PAGE_IN                     410
#define IDS_POOL_ALLOC                  411
#define IDS_DELAY_EXECUTION             412
#define IDS_SUSPENDED                   413
#define IDS_USER_REQUEST                414
#define IDS_EVENT_PAIR_HIGH             415
#define IDS_EVENT_PAIR_LOW              416
#define IDS_LPC_RECEIVE                 417
#define IDS_LPC_REPLY                   418
#define IDS_VIRTUAL_MEMORY              419
#define IDS_PAGE_OUT                    420
#define IDS_WAIT1                       421
#define IDS_WAIT2                       422
#define IDS_WAIT3                       423
#define IDS_WAIT4                       424
#define IDS_WAIT5                       425
#define IDS_WAIT6                       426
#define IDS_WAIT7                       427
#define IDS_WAIT8                       428
#define IDS_WAIT9                       429
#define IDS_WAIT10                      430

#define IDS_DOMAIN_ADMINS               431


/* resources from 1000 onwords are used by utilsub */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\makefile.inc ===
#
#       Do not delete this file, needed to build .lib file.
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utildll\utildll.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation

/*******************************************************************************
*
* utildll.c
*
* UTILDLL multi-user utility support functions
*
*
*******************************************************************************/

/*
 * include files
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntcsrsrv.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <nb30.h>
#include <tapi.h>
#include <raserror.h>
#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmwksta.h>
#include <lmremutl.h>
#include <lmapibuf.h>
#include <shlwapi.h>

#define INITGUID
#include "objbase.h"
#include "initguid.h"
//#include "basetyps.h"
#include "devguid.h"
#include "setupapi.h"

#include <winsta.h>

#include <utildll.h>
#include "..\inc\utilsub.h"
#include "..\inc\ansiuni.h"
#include "resource.h"

/*
 * Hydrix helpers function internal defines
 */
#define INITIAL_ENUMERATION_COUNT   16
#define REGISTRY_NETCARDS           TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards")
#define REGISTRY_TITLE              TEXT("Title")
#define REGISTRY_SERVICE_NAME       TEXT("ServiceName")
#define REGISTRY_HIDDEN             TEXT("Hidden")
#define REGISTRY_ROUTE              TEXT("Route")
#define REGISTRY_NETBLINKAGE        TEXT("SYSTEM\\CurrentControlSet\\Services\\NetBIOS\\Linkage")
#define REGISTRY_NETBLINKAGE_LANAMAP TEXT("LanaMap")
#define REGISTRY_SERVICES           TEXT("SYSTEM\\CurrentControlSet\\Services")
#define REGISTRY_DISPLAY_NAME       TEXT("DisplayName")

/*
 * TAPI defines.
 */
#define LOW_MAJOR_VERSION   0x0001
#define LOW_MINOR_VERSION   0x0003
#define HIGH_MAJOR_VERSION  0x0002
#define HIGH_MINOR_VERSION  0x0000

#define LOW_VERSION  ((LOW_MAJOR_VERSION  << 16) | LOW_MINOR_VERSION)
#define HIGH_VERSION ((HIGH_MAJOR_VERSION << 16) | HIGH_MINOR_VERSION)


/*=============================================================================
==   Local Functions Defined
=============================================================================*/
BOOL CheckForComDevice( LPTSTR );
int NetBiosLanaEnum( LANA_ENUM * pLanaEnum );
DWORD EnumerateTapiPorts( PPDPARAMS pPdParams, ULONG Count, ULONG **ppEntries );
VOID CALLBACK DummyTapiCallback(HANDLE, DWORD, DWORD, DWORD, DWORD, DWORD);
BOOL GetAssociatedPortName(char  *szKeyName, WCHAR *wszPortName);
BOOL _UserInGroup( LPWSTR pwszUsername, LPWSTR pwszDomain, LPWSTR pwszGroup );

/*******************************************************************************
 *
 *  StandardErrorMessage - Hydrix helper function
 *
 *      Output an error message with optional additional arguments like the
 *      ErrorMessagexxx routines.  Additionally, a standard error line will
 *      also be output containing the error code and error message associated
 *      with that code.
 *
 *  ENTRY:
 *      pszAppName (input)
 *          Application name for error message box title.
 *      hwndApp (input)
 *          Owner window for error message box.
 *      hinstApp (input)
 *          Instance handle of application.
 *      LogonId (input)
 *          Optional WinStation LogonId for querying special error strings
 *          from WinStation via WinStationGetInformation API.  If this value
 *          is LOGONID_NONE then no special error message code checking will
 *          be done.
 *      nId (input)
 *          System message code to get standard error string for.
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
StandardErrorMessage( LPCTSTR pszAppName,
                      HWND hwndApp,
                      HINSTANCE hinstApp,
                      ULONG LogonId,
                      UINT nId,
                      int nErrorMessageLength,
                      int nArgumentListLength,
                      int nErrorResourceID, ...)
{
    TCHAR* szClientErrorMessage = NULL;
    TCHAR* szClientResourceString = NULL;
    TCHAR* szError = NULL;
    TCHAR* szFormattedErrorMessage = NULL;
    TCHAR* szMessage = NULL;
    TCHAR  szStandardErrorMessage[STANDARD_ERROR_TEXT_LENGTH + 1];

    va_list args;
    va_start( args, nErrorResourceID );

    szClientErrorMessage = (TCHAR*)malloc((nErrorMessageLength + 1) * sizeof(TCHAR));
    if (szClientErrorMessage)
    {
        LoadString( hinstApp, nErrorResourceID, szClientErrorMessage, nErrorMessageLength );

        szClientResourceString = (TCHAR*)malloc((wcslen(szClientErrorMessage) + nArgumentListLength + 1) * sizeof(TCHAR));
        if (szClientResourceString != NULL)
        {
            wvsprintf( szClientResourceString, szClientErrorMessage, args );

            LoadString( GetModuleHandle( UTILDLL_NAME ),
                        IDS_STANDARD_ERROR_FORMAT, szStandardErrorMessage, STANDARD_ERROR_TEXT_LENGTH );

            szError = GetSystemMessage( LogonId, nId);
            if (szError != NULL)
            {
                szFormattedErrorMessage = (TCHAR*)malloc((wcslen(szStandardErrorMessage) + 10 + wcslen(szError) + 1) * sizeof(TCHAR));
                if (szFormattedErrorMessage != NULL)
                {
                    wsprintf( szFormattedErrorMessage, szStandardErrorMessage, nId, szError);

                    //lstrcpy(sz1, pszAppName);

                    szMessage = (TCHAR*)malloc((wcslen(szClientResourceString) + wcslen(szFormattedErrorMessage) + 1) * sizeof(TCHAR));
                    if (szMessage != NULL)
                    {
                        wcscpy(szMessage, szClientResourceString);
                        wcscat(szMessage, szFormattedErrorMessage);

                        MessageBox( hwndApp, szMessage, pszAppName, MB_OK | MB_ICONEXCLAMATION );
    
                        free(szMessage);
                    }
                    free(szFormattedErrorMessage);
                }
                free (szError);
            }
            free(szClientResourceString);
        }
        free (szClientErrorMessage);
    }
    va_end(args);
}  // end StandardErrorMessage


/*******************************************************************************
 *
 *  GetSystemMessageA - Hydrix helper function (ANSI stub)
 *
 *      Return the string associated with the specified system message.
 *
 *  ENTRY:
 *      (refer to GetSystemMessageW)
 *  EXIT:
 *      (refer to GetSystemMessageW)
 *      If cannot allocate temporary UNICODE buffer to call GetSystemMessageW
 *      with, the ntents of chBuffer will be set to the "(no error text
 *      available)" string.
 *
 ******************************************************************************/

LPSTR WINAPI
GetSystemMessageA( ULONG LogonId,
                   UINT nId
                   /*LPSTR chBuffer,
                   int cbBuffSize*/ )
{
    LPWSTR uBuffer = NULL;
    LPSTR aBuffer = NULL;
    int length;
    
    //Call the GetSystemMessageW function
    uBuffer = GetSystemMessageW(LogonId, nId);
    if (uBuffer == NULL)
    {
        //If no message was returned from the GetSystemMessageW
        //function just return a generic error message
        aBuffer = malloc((NO_ERROR_TEXT_LENGTH + 1) * sizeof(char));
        if (aBuffer == NULL)
            return NULL;

        length = LoadStringA( GetModuleHandle( UTILDLL_NAME ),
                              IDS_NO_ERROR_TEXT_AVAILABLE,
                              aBuffer, NO_ERROR_TEXT_LENGTH );
        ASSERT(length);
    }
    else
    {
        length = wcslen(uBuffer) + 1;

        //Convert the result into ANSI in caller supplied buffer.
        aBuffer = malloc(length * sizeof(char));
        if (aBuffer != NULL)
            WideCharToMultiByte(CP_ACP, 0, uBuffer, length - 1, aBuffer, length, 0, 0);

        //Free the temporary buffer.
        free (uBuffer);
    }

    //Return message.
    return(aBuffer);
}  // end GetSystemMessageA


/*******************************************************************************
 *
 *  GetSystemMessageW - Hydrix helper function (UNICODE version)
 *
 *      Return the string associated with the specified system message.
 *
 *  ENTRY:
 *      LogonId (input)
 *          Optional WinStation LogonId for querying special error strings
 *          from WinStation via WinStationGetInformation API.  If this value
 *          is LOGONID_NONE then no special error message code checking will
 *          be done.
 *      nId (input)
 *          System message code to get string for.
 *      chBuffer (input)
 *          Points to buffer to fill with system message string.
 *      cbBuffSize (input)
 *          Maximum number of characters that can be placed in chBuffer.
 *
 *  EXIT:
 *      Returns chBuffer.  Contents of chBuffer will always be set; to
 *      the "(no error text available)" string if error.
 *
 *      Note: the total length of chBuffer (including terminating NULL) will
 *      not exceed the size of the internal temporary buffer (Buffer).
 *
 ******************************************************************************/


//NA 3/9/01 IMPORTANT: Behavior has changed. Instead of expecting a buffer long
//enough to accomodate the message, it now allocates the memory dynamically, so 
//it's up to the calling procedure to deallocate it.
LPWSTR WINAPI
GetSystemMessageW( ULONG LogonId,
                   UINT nId
                   /*LPWSTR chBuffer,
                   int cbBuffSize*/ )
{
    LPWSTR chBuffer = NULL;

    WCHAR StackBuffer[512];
    WCHAR* SpecialBuffer = NULL;
    WCHAR* Buffer = NULL;
    BOOL bSpecialCitrixError = FALSE;
    HINSTANCE cxerror = LoadLibraryW(L"cxerror.dll");
    int length = 0;

    StackBuffer[0]=0;

    //If we have a valid LogonId passed in, determine if the error
    //is a special code requiring that the specific error string be
    //queried from the WinStation.
    if ( LogonId != LOGONID_NONE ) 
    {
        switch ( nId ) 
        {
            case ERROR_CTX_TD_ERROR:               
                length = LoadStringW( GetModuleHandle( UTILDLL_NAME ),
                                      IDS_NO_ADDITIONAL_ERROR_INFO,
                                      StackBuffer,
                                      sizeof(StackBuffer)/sizeof(WCHAR) );
                ASSERT(length);
                SpecialBuffer = malloc((length + 1) * sizeof(WCHAR));
                if (SpecialBuffer != NULL)
                {
                    wcscpy(SpecialBuffer, StackBuffer);
                    bSpecialCitrixError = TRUE;
                }
                break;

            default:
                break;
        }
    }

    //See if this is a Citrix error message first...
    if ( !cxerror ||
         !FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                          FORMAT_MESSAGE_MAX_WIDTH_MASK |
                          FORMAT_MESSAGE_FROM_HMODULE |
                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                          (LPCVOID)cxerror,
                          nId,
                          0,
                          (LPWSTR)&Buffer,
                          0,
                          NULL ) ) 
    {
        //It's not a Citrix error message; fetch system message.
        if ( !FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                              FORMAT_MESSAGE_MAX_WIDTH_MASK |
                              FORMAT_MESSAGE_FROM_SYSTEM |
                              FORMAT_MESSAGE_ALLOCATE_BUFFER,
                              NULL,
                              nId,
                              0,
                              (LPWSTR)&Buffer,
                              0,
                              NULL ) ) 
        {
            //It's not a system message; don't know what the message is...
            length = LoadStringW( GetModuleHandle( UTILDLL_NAME ),
                                  IDS_NO_ERROR_TEXT_AVAILABLE,
                                  StackBuffer,
                                  sizeof(StackBuffer)/sizeof(WCHAR) );
            ASSERT(length);
            Buffer = LocalAlloc(0,(length + 1) * sizeof(WCHAR));
            if (Buffer == NULL)
            {
                if (SpecialBuffer != NULL)
                    free (SpecialBuffer);
                return NULL;
            }
            wcscpy(Buffer, StackBuffer);
        }
    }
    if ( cxerror )
        FreeLibrary(cxerror);

    length = wcslen(Buffer);
    if ( bSpecialCitrixError )
        length += wcslen(SpecialBuffer) + 2;

    chBuffer = malloc((length + 1) * sizeof(WCHAR));
    if (chBuffer != NULL)
    {
        wcscpy(chBuffer, Buffer);

        //If we fetched a special Citrix error string, tack it onto the end
        //of whatever we've buffered already.
        if ( bSpecialCitrixError )
        {
            lstrcatW(chBuffer, L"  ");
            lstrcatW(chBuffer, SpecialBuffer);
        }
    }

    if (Buffer != NULL)
        LocalFree (Buffer);

    if (( bSpecialCitrixError ) && (SpecialBuffer != NULL))
        free (SpecialBuffer);

    return(chBuffer);

}  // end GetSystemMessageW


/*******************************************************************************
 *
 *  WinEnumerateDevices - Hydrix helper function
 *
 *      Perform PD device enumeration for the specified PD.
 *
 *  ENTRY:
 *      hWnd (input)
 *          Parent window for error message, if needed.
 *      pPdConfig (input)
 *          Points to PDCONFIG3 structure of the PD.
 *      pEntries (output)
 *          Points to variable to return number of devices that were enumerated.
 *      bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 *  EXIT:
 *      (PPDPARAMS) Points to the PDPARAMS array containing the enumeration
 *                  results if sucessful.  The caller must perform a LocalFree
 *                  of this array when done.  NULL if error; error set for
 *                  GetLastError();
 *      If the returned error code is anything other than
 *      ERROR_NOT_ENOUGH_MEMORY, the caller can assume that none of the
 *      requested devices were available to be enumerated.
 *
 ******************************************************************************/

typedef BOOL (WINAPI * PPDENUMERATE)( PPDCONFIG3, PULONG, PPDPARAMS, PULONG, BOOL );

PPDPARAMS WINAPI
WinEnumerateDevices( HWND hWnd,
                     PPDCONFIG3 pPdConfig,
                     PULONG pEntries,
                     BOOL bInSetup )
{
    PPDENUMERATE pPdEnumerate;
    ULONG ByteCount;
    DWORD Error;
    int i;
    PPDPARAMS pPdParams = NULL;

    /*
     * Enumerate according to class.
     */
    switch ( pPdConfig->Data.SdClass ) {

        case SdAsync:
            pPdEnumerate = AsyncDeviceEnumerate;
            break;

        case SdNetwork:
            if ( pPdConfig->Data.PdFlag & PD_LANA ) {

                /*
                 * This is a LANA based network PD (ie, NetBIOS).  Perform
                 * NetBIOS enumerate.
                 */
                pPdEnumerate = NetBIOSDeviceEnumerate;

            }
            else {

                /*
                 * This is a physical lan adapter based network (TCP/IP,
                 * IPX, SPX, etc).  Enumerate based on the associated network
                 * protocol service name.
                 */
                pPdEnumerate = NetworkDeviceEnumerate;
            }
            break;

        default:
            return(NULL);
    }

    /*
     * Call enumerate in loop till we hit enough buffer entries to handle
     * a complete enumeration.  NOTE: some enumeration routines will return
     * the necessary ByteCount on 'insufficient buffer' status; others won't.
     */
    for ( ByteCount = 0, i = INITIAL_ENUMERATION_COUNT; ; i *= 2 ) {


        if ( pPdParams != NULL )
            LocalFree(pPdParams);

        pPdParams = (PPDPARAMS)LocalAlloc(
                                         LPTR,
                                         ByteCount ?
                                         ByteCount :
                                         (ByteCount = sizeof(PDPARAMS) * i) );


        if ( pPdParams == NULL ) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto OutOfMemory;
        }

        /*
         * Perform enumeration and break loop if successful.
         */
        if ( (*pPdEnumerate)( pPdConfig,
                              pEntries,
                              pPdParams,
                              &ByteCount,
                              bInSetup ) )
            break;

        /*
         * If we received any other error other than 'insufficient buffer',
         * quit (quietly).
         */
        if ( (Error = GetLastError()) != ERROR_INSUFFICIENT_BUFFER )
            goto BadEnumerate;
    }

    /*
     * Success: return the PDPARAMS pointer.
     */
    return(pPdParams);

    /*==============================================================================
     * Error returns
     *============================================================================*/
    BadEnumerate:
    LocalFree(pPdParams);
    OutOfMemory:
    return(NULL);

}  // end WinEnumerateDevices


/*******************************************************************************
 *
 *  NetworkDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of Lan Adapter indexes of network cards bound to the the
 *   specified protocol.  The Lan Adapter is returned in the LanAdapter field
 *   of each PDPARAMS array.  A LanAdapter value of 0 indicates 'any configured
 *   network card'.  Indexes >=1 indicate 1-based index into the specific
 *   protocol's  "servicename"\Linkage\Route registry entry to specify the
 *   particular network card.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable receives the required size of the
 *       buffer.
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *          ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              The specified network's service was not found, indicating that
 *              the protocol was not configured.  This error code can be
 *              interpreted as 'no devices are configured for the xxx protocol'
 *              for reporting purposes.
 *          ERROR_xxxx
 *              Registry error code.
 *
 ******************************************************************************/

BOOL WINAPI
NetworkDeviceEnumerate( PPDCONFIG3 pPdConfig,
                        PULONG pEntries,
                        PPDPARAMS pPdParams,
                        PULONG pByteCount,
                        BOOL bInSetup )
{
    ULONG i, Count;
    LPTSTR szRoute, szRouteStr;
    LONG Status;
    DWORD ValueSize, Type;
    TCHAR szKey[256];
    HKEY Handle;

    /*
     * Get maximum number of LanAdapter indexes that can be returned.
     */
    Count = *pByteCount / sizeof(PDPARAMS);

    /*
     * Form key for service name associated with this PD and fetch
     * the Linkage\Route strings.
     */
    _snwprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                TEXT("%s\\%s\\Linkage"), REGISTRY_SERVICES,
                pPdConfig->ServiceName );
    szKey[sizeof(szKey)/sizeof(TCHAR) - 1] = TEXT('\0');
    if ( (Status = RegOpenKeyEx( HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &Handle ))
         != ERROR_SUCCESS ) {
        Status = ERROR_DEV_NOT_EXIST;
        goto BadRegistryOpen;
    }

    /*
     * Alloc and read in the linkage route multi-string.
     */
    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                     NULL, &Type,
                                     NULL, &ValueSize ))
          != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) )
        goto BadQuery1;

    if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        goto BadAlloc;
    }

    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                     NULL, &Type,
                                     (LPBYTE)szRoute, &ValueSize ))
          != ERROR_SUCCESS) )
        goto BadQuery2;

    /*
     * Close the registry key handle and count the route strings to obtain
     * the number of entries to report in the enumeration.
     */
    RegCloseKey(Handle);
    for ( i = 1, szRouteStr = szRoute; lstrlen(szRouteStr); i++ )
        szRouteStr += (lstrlen(szRouteStr) + 1);
    LocalFree(szRoute);

    /*
     * If we don't have enough PDPARAMS structures to report all of the
     * LanAdapter indexes, return error.
     */
    if ( i > Count ) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        *pByteCount = (i * sizeof(PDPARAMS));
        goto BadBufferSize;
    }

    /*
     * Set the LanAdapter fields of the first 'i' PDPARAMS structures to
     * the indexes (0-based), set total number of entries, and return success.
     */
    for ( Count = 0, *pEntries = i; Count < i; pPdParams++, Count++ )
        pPdParams->Network.LanAdapter = (LONG)Count;
    return(TRUE);

    /*==============================================================================
     * Error returns
     *============================================================================*/
    BadQuery2:
    LocalFree(szRoute);
    BadAlloc:
    BadQuery1:
    RegCloseKey(Handle);
    BadBufferSize:
    BadRegistryOpen:
    SetLastError(Status);
    return(FALSE);

}  // end NetworkDeviceEnumerate


/*******************************************************************************
 *
 *  QueryCurrentWinStation  - Hydrix helper function
 *
 *      Query the currently logged-on WinStation information.
 *
 *  ENTRY:
 *      pWSName (output)
 *          Points to string to place current WinStation name.
 *      pUserName (output)
 *          Points to string to place current User name.
 *      pLogonId (output)
 *          Points to ULONG to place current LogonId.
 *      pFlags (output)
 *          Points to ULONG to place current WinStation's flags.
 *
 *  EXIT:
 *      (BOOL) TRUE if the user's current WinStation information was queried
 *              sucessfully; FALSE otherwise.  The error code is set for
 *              GetLastError() to retrieve.
 *
 ******************************************************************************/

BOOL WINAPI
QueryCurrentWinStation( PWINSTATIONNAME pWSName,
                        LPTSTR pUserName,
                        PULONG pLogonId,
                        PULONG pFlags )
{
    ULONG Flags = 0;
    WINSTATIONINFORMATION WSInfo;
#ifdef WINSTA
    ULONG ReturnLength;
#endif // WINSTA

#ifdef WINSTA
    /*
     * Fetch the WinStation's basic information.
     */
    if ( !WinStationQueryInformation( SERVERNAME_CURRENT,
                                      LOGONID_CURRENT,
                                      WinStationInformation,
                                      &WSInfo,
                                      sizeof(WSInfo),
                                      &ReturnLength ) )
        goto BadQuery;

    /*
     * Check for shadow capability if WinStation is connected.  If the
     * WinStation is not connected, we can't shadow.
     */
    if ( WSInfo.ConnectState != State_Disconnected ) {

        WDCONFIG WdConfig;

        /*
         * Query Wd config stuff.
         */
        if ( !WinStationQueryInformation( SERVERNAME_CURRENT,
                                          LOGONID_CURRENT,
                                          WinStationWd,
                                          &WdConfig,
                                          sizeof(WdConfig),
                                          &ReturnLength ) )
            goto BadQuery;

        /*
         * Set WinStation's Wd flags.
         */
        Flags = WdConfig.WdFlag;
    }
#else
    lstrcpy(WSInfo.WinStationName, TEXT("console"));
    lstrcpy(WSInfo.UserName, TEXT("bonzo"));
    WSInfo.LogonId = 0;
#endif // WINSTA

    /*
     * Set WinStation information into caller's variables, and return success.
     */
    lstrcpy( pWSName, WSInfo.WinStationName );
    lstrlwr(pWSName);
    lstrcpy( pUserName, WSInfo.UserName );
    lstrlwr(pUserName);
    *pLogonId = WSInfo.LogonId;
    *pFlags = Flags;

    return(TRUE);

    /*==============================================================================
     * Error returns
     *============================================================================*/
#ifdef WINSTA
    BadQuery:
#endif // WINSTA
    return(FALSE);

}  // end QueryCurrentWinStation


/*******************************************************************************
 *
 *  RegGetNetworkDeviceName - Hydrix helper function
 *
 *      Obtain the network device name associated with the given WinStation PD.
 *
 *  ENTRY:
 *      hServer (input)
 *          Handle to Hydrix Server
 *      pPdConfig (input)
 *          Points to the PDCONFIG3 structure for the WinStation's PD.
 *      pPdParams (input)
 *          Points to the PDPARAMS structure for the WinStation's PD.
 *      szDeviceName (output)
 *          Points to buffer to return the network device name.
 *      nDeviceName (input)
 *          Specifies the maxmum number of characters that can be stored in
 *          szDeviceName.
 *
 *  EXIT:
 *      No return.  Will always place a string representation of
 *      pPdParams->Network.LanAdapter along with an appropriate error string
 *      in pDeviceName if the network device name could not be read from the
 *      registry.
 *
 ******************************************************************************/

typedef struct _LANAMAP {
    BYTE enabled;
    BYTE lana;
} LANAMAP, *PLANAMAP;

LONG WINAPI
RegGetNetworkDeviceName( HANDLE hServer,
                         PPDCONFIG3 pPdConfig,
                         PPDPARAMS pPdParams,
                         LPTSTR szDeviceName,
                         int nDeviceName )
{
    int i, length;
    LPTSTR szRoute, szRouteStr, p;
    LONG Status = ERROR_SUCCESS;
    DWORD ValueSize, Type;
    TCHAR szKey[256];
    HKEY Handle;
    HKEY hkey_local_machine;
    PLANAMAP pLanaMap, pLana;

    if ( hServer == NULL)
        hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
        hkey_local_machine = hServer;

    /*
     * Check for NetBIOS (PD_LANA) mapping or other mapping.
     */
    if ( !(pPdConfig->Data.PdFlag & PD_LANA) ) {

        LPTSTR szRoute, szRouteStr;

        /*
         * Non-LANA mapping.  If the LanAdapter is 0, treat this as the
         * special 'all configured network cards' value and return that
         * string as the device name.
         */
        if ( pPdParams->Network.LanAdapter == 0 ) {
            TCHAR szString[256];

            length = LoadString( GetModuleHandle( UTILDLL_NAME ),
                                 IDS_ALL_LAN_ADAPTERS, szString, 256 );
            ASSERT(length);
            lstrncpy(szDeviceName, szString, nDeviceName);
            szDeviceName[nDeviceName-1] = TEXT('\0');
            return Status;
        }

        /*
         * Form key for service name associated with this PD and fetch
         * the Linkage\Route strings.
         */
        _snwprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                    TEXT("%s\\%s\\Linkage"), REGISTRY_SERVICES,
                    pPdConfig->ServiceName );
        szKey[sizeof(szKey)/sizeof(TCHAR) - 1] = TEXT('\0');
        if ( (Status = RegOpenKeyEx( hkey_local_machine, szKey, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            goto Error;

        /*
         * Alloc and read in the linkage route multi-string.
         */
        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                         NULL, &Type,
                                         NULL, &ValueSize ))
              != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) )
            goto Error;

        if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_ROUTE,
                                         NULL, &Type,
                                         (LPBYTE)szRoute, &ValueSize ))
              != ERROR_SUCCESS) ) {
            LocalFree(szRoute);
            goto Error;
        }

        /*
         * Close the registry key handle and point to the route string
         * associated with this LanAdapter index.
         */
        RegCloseKey(Handle);
        for ( i = 1, szRouteStr = szRoute;
            i < pPdParams->Network.LanAdapter; i++ ) {

            szRouteStr += (lstrlen(szRouteStr) + 1);

            if ( !lstrlen(szRouteStr) ) {

                /*
                 * Error: Index past end of route multi-string.
                 */
                LocalFree(szRoute);
                Status = ERROR_DEV_NOT_EXIST;
                goto Error;
            }
        }

        /*
         * Isolate the service string representing the lowest binding
         * in the route and convert it to its display name.
         */
        *(p = (szRouteStr + lstrlen(szRouteStr) - 1)) = TEXT('\0');
        for ( ; *p != TEXT('\"'); p-- );
        p++;
        if ( (Status = RegGetNetworkServiceName( hServer, p, szDeviceName, nDeviceName ))
             != ERROR_SUCCESS ) {
            LocalFree(szRoute);
            goto Error;
        }

        /*
         * Clean up and return.
         */
        LocalFree(szRoute);
        return Status;

    }
    else {

        /*
         * NetBIOS LANA #: see which LanaMap entry corresponds to the specified
         * Lan Adapter.
         */
        if ( (Status = RegOpenKeyEx( hkey_local_machine, REGISTRY_NETBLINKAGE, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            goto Error;

        /*
         * Alloc and read the LanaMap
         */
        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_NETBLINKAGE_LANAMAP,
                                         NULL, &Type,
                                         NULL, &ValueSize))
              != ERROR_SUCCESS) || (Type != REG_BINARY) ) {
            RegCloseKey(Handle);
            goto Error;
        }

        if ( !(pLanaMap = (PLANAMAP)LocalAlloc(LPTR, ValueSize)) ) {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

        if ( (Status = RegQueryValueEx( Handle, REGISTRY_NETBLINKAGE_LANAMAP,
                                        NULL, &Type,
                                        (LPBYTE)pLanaMap, &ValueSize))
             != ERROR_SUCCESS ) {
            LocalFree(pLanaMap);
            RegCloseKey(Handle);
            goto Error;
        }

        /*
         * Loop through LanaMap to check for match with the specified Lan
         * Adapter #.
         */
        for ( pLana = pLanaMap, i = 0;
            i < (int)(ValueSize / sizeof(LANAMAP));
            i++, pLana++ ) {

            if ( pLana->lana == (BYTE)(pPdParams->Network.LanAdapter) ) {

                TCHAR szHighestBinding[256], szLowestBinding[256];

                LocalFree(pLanaMap);

                /*
                 * Match found.  Alloc and fetch the Route multi-string
                 */
                if ( ((Status = RegQueryValueEx( Handle,
                                                 REGISTRY_ROUTE,
                                                 NULL, &Type,
                                                 NULL, &ValueSize))
                      != ERROR_SUCCESS) || (Type != REG_MULTI_SZ) ) {
                    RegCloseKey(Handle);
                    goto Error;
                }

                if ( !(szRoute = (LPTSTR)LocalAlloc(LPTR, ValueSize)) ) {
                    Status = ERROR_NOT_ENOUGH_MEMORY;
                    goto Error;
                }

                if ( (Status = RegQueryValueEx( Handle,
                                                REGISTRY_ROUTE,
                                                NULL, &Type,
                                                (LPBYTE)szRoute, &ValueSize))
                     != ERROR_SUCCESS ) {
                    LocalFree(szRoute);
                    RegCloseKey(Handle);
                    goto Error;
                }

                /*
                 * Free the registry key handle and make a local copy of the
                 * 'i'th multi string, which is the binding route for this lana.
                 */
                RegCloseKey(Handle);
                for ( szRouteStr = szRoute; i > 0; i-- )
                    szRouteStr += (lstrlen(szRouteStr) + 1);
                lstrncpy(szDeviceName, szRouteStr, nDeviceName);
                szDeviceName[nDeviceName-1] = TEXT('\0');
                LocalFree(szRoute);

                /*
                 * Isolate the service string representing the highest binding
                 * in the route and convert it to its display name.
                 */
                szRouteStr = szDeviceName + 1;     // skip first "
                for ( p = szRouteStr; *p && *p != TEXT('\"'); p++ );
                if ( !(*p) )
                    goto Error;
                *p = TEXT('\0');
                if ( (Status = RegGetNetworkServiceName(
                                                       hServer,
                                                       szRouteStr,
                                                       szHighestBinding,
                                                       sizeof(szHighestBinding)/sizeof(TCHAR) ))
                     != ERROR_SUCCESS )
                    goto Error;

                /*
                 * Isolate the service string representing the lowest binding
                 * in the route and convert it to its display name.
                 */
                if ( !(*(szRouteStr = p+1)) ) {

                    *szLowestBinding = TEXT('\0');

                }
                else {

                    *(p = (szRouteStr + lstrlen(szRouteStr) - 1)) = TEXT('\0');
                    for ( ; *p != TEXT('\"'); p-- );
                    p++;
                    if ( (Status = RegGetNetworkServiceName(
                                                           hServer,
                                                           p,
                                                           szLowestBinding,
                                                           sizeof(szLowestBinding)/sizeof(TCHAR) ))
                         != ERROR_SUCCESS )
                        goto Error;
                }

                /*
                 * Build the complete name string.
                 */
                _snwprintf( szDeviceName, nDeviceName, TEXT("%s => %s"),
                            szHighestBinding, szLowestBinding );

                /*
                 * Return.
                 */
                return ERROR_SUCCESS;
            }
        }

        /*
         * No match found.
         */
        LocalFree(pLanaMap);
        RegCloseKey(Handle);
        goto Error;
    }

    /*==============================================================================
     * Error returns
     *============================================================================*/
    Error:
    {
        TCHAR sz1[256], sz2[1024];
        int length;

        length = LoadString( GetModuleHandle( UTILDLL_NAME ),
                             (pPdConfig->Data.PdFlag & PD_LANA) ?
                             IDP_ERROR_REGLANA :
                             IDP_ERROR_REGNETCARD,
                             sz1, 256 );

        wsprintf( sz2, sz1, pPdParams->Network.LanAdapter, Status );
        lstrncpy(szDeviceName, sz2, nDeviceName);
        szDeviceName[nDeviceName-1] = TEXT('\0');
    }
    return Status;

}  // end RegGetNetworkDeviceName


/*******************************************************************************
 *
 *  RegGetNetworkServiceName - Hydrix helper function
 *
 *      Obtain the display name associated with a given network service name.
 *      If the service is a reference to a physical network card, will return
 *      the title of the card as obtained from the LOCAL_MACHINE\Software\
 *      Microsoft\Windows NT\NetworkCards registry.
 *
 *  ENTRY:
 *      hServer (input)
 *          Handle of the Hydrix Server
 *      szServiceKey (input)
 *          Key string into the LOCAL_MACHINE\System\CurrentControlSet\Services
 *          registry.
 *      szServiceName (output)
 *          Points to buffer to return the service's display name.
 *      nServiceName (input)
 *          Specifies the maxmum number of characters that can be stored in
 *          szServiceName.
 *
 *  EXIT:
 *      ERROR_SUCCESS if a service name was sucessfully found and returned;
 *      error code otherwise.
 *
 *      NOTE: If the service name is for an entry in the NetworkCards resistry
 *            and the entry is flagged as 'hidden', the service name will be
 *            blank.  This will flag caller's logic to ignore the entry.
 *
 ******************************************************************************/

LONG WINAPI
RegGetNetworkServiceName( HANDLE hServer,
                          LPTSTR szServiceKey,
                          LPTSTR szServiceName,
                          int nServiceName )
{
    LONG Status;
    DWORD ValueSize, Type, dwValue;
    TCHAR szKey[256];
    LPTSTR szTemp;
    HKEY Handle;
    HKEY hkey_local_machine;

    if (hServer == NULL)
        hkey_local_machine = HKEY_LOCAL_MACHINE;
    else
        hkey_local_machine = hServer;

    lstrnprintf( szKey, sizeof(szKey)/sizeof(TCHAR),
                 TEXT("%s\\%s"), REGISTRY_SERVICES, szServiceKey );
    szKey[sizeof(szKey)/sizeof(TCHAR) - 1] = TEXT('\0');

    if ( (Status = RegOpenKeyEx( hkey_local_machine,
                                 szKey, 0,
                                 KEY_READ, &Handle ))
         != ERROR_SUCCESS )
        return(Status);

    /*
     * Alloc and read in the service's DisplayName value (if there).
     */
    if ( ((Status = RegQueryValueEx( Handle, REGISTRY_DISPLAY_NAME,
                                     NULL, &Type,
                                     NULL, &ValueSize ))
          != ERROR_SUCCESS) || (Type != REG_SZ) ) {

        HKEY Subkey;
        FILETIME KeyTime;
        DWORD i;

        /*
         * The service doesn't have a DisplayName associated with it (it's a
         * Network Card's service name).  Traverse the NetworkCards registry
         * entries and find the entry associated with this service name
         * (if it exists).
         */
        RegCloseKey(Handle);
        if ( (Status = RegOpenKeyEx( hkey_local_machine,
                                     REGISTRY_NETCARDS, 0,
                                     KEY_READ, &Handle ))
             != ERROR_SUCCESS )
            return(Status);

        for ( i = 0, ValueSize = sizeof(szKey)/sizeof(TCHAR) ;
            RegEnumKeyEx( Handle, i, szKey, &ValueSize,
                          NULL, NULL, NULL, &KeyTime ) == ERROR_SUCCESS ;
            i++, ValueSize = sizeof(szKey)/sizeof(TCHAR) ) {

            /*
             * Open the Network Card's registry.
             */
            if ( (Status = RegOpenKeyEx( Handle,
                                         szKey, 0,
                                         KEY_READ, &Subkey ))
                 != ERROR_SUCCESS ) {
                RegCloseKey(Handle);
                return(Status);
            }

            /*
             * Alloc and fetch the card's service name.  Continue net card
             * enumeration if service name not found.
             */
            if ( ((Status = RegQueryValueEx( Subkey,
                                             REGISTRY_SERVICE_NAME,
                                             NULL, &Type,
                                             NULL, &ValueSize))
                  != ERROR_SUCCESS) || (Type != REG_SZ) ) {
                RegCloseKey(Subkey);
                continue;
            }

            szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
            if(NULL == szTemp)
            {
                RegCloseKey(Subkey);
                RegCloseKey(Handle);
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            if ( (Status = RegQueryValueEx( Subkey,
                                            REGISTRY_SERVICE_NAME,
                                            NULL, &Type,
                                            (LPBYTE)szTemp, &ValueSize))
                 != ERROR_SUCCESS ) {
                LocalFree(szTemp);
                RegCloseKey(Subkey);
                continue;
            }

            /*
             * If the current Network Card's service name matches the service
             * name that we're looking for, fetch the card's title.
             */
            if ( !lstrcmpi(szServiceKey, szTemp) ) {

                LocalFree(szTemp);

                ValueSize = sizeof(dwValue);
                if ( (RegQueryValueEx( Subkey, REGISTRY_HIDDEN,
                                       NULL, &Type,
                                       (LPBYTE)&dwValue, &ValueSize )
                      == ERROR_SUCCESS) &&
                     (Type == REG_DWORD) &&
                     (dwValue == 1) ) {

                    /*
                     * Entry is hidden: return empty title.
                     */
                    *szServiceName = TEXT('\0');

                }
                else {

                    /*
                     * Entry is not hidden: Alloc for the card's title.
                     */
                    if ( ((Status = RegQueryValueEx( Subkey,
                                                     REGISTRY_TITLE,
                                                     NULL, &Type,
                                                     NULL, &ValueSize))
                          != ERROR_SUCCESS) || (Type != REG_SZ) ) {
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return(Status);
                    }
                    szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
                    if(NULL == szTemp)
                    {
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }

                    /*
                     * Fetch the title.
                     */
                    if ( (Status = RegQueryValueEx( Subkey,
                                                    REGISTRY_TITLE,
                                                    NULL, &Type,
                                                    (LPBYTE)szTemp, &ValueSize))
                         != ERROR_SUCCESS ) {
                        LocalFree(szTemp);
                        RegCloseKey(Subkey);
                        RegCloseKey(Handle);
                        return(Status);
                    }

                    /*
                     * Copy the card's title.
                     */
                    lstrncpy(szServiceName, szTemp, nServiceName);
                    szServiceName[nServiceName-1] = TEXT('\0');
                    LocalFree(szTemp);
                }

                /*
                 * Clean up and return success.
                 */
                RegCloseKey(Subkey);
                RegCloseKey(Handle);
                return(ERROR_SUCCESS);

            }
            else {

                /*
                 * This is not the Network Card that we're looking for.  Close
                 * it's registry key, free the service name buffer, and continue
                 * enumeration loop.
                 */
                LocalFree(szTemp);
                RegCloseKey(Subkey);
            }
        }

        /*
         * Network Card not found with service name matching the one supplied.
         * Close NetworkCards registry key and return failure,
         */
        RegCloseKey(Handle);
        return(ERROR_DEV_NOT_EXIST);

    }
    else {

        szTemp = (LPTSTR)LocalAlloc(LPTR, ValueSize);
        if(NULL == szTemp)
        {
            RegCloseKey(Handle);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ( ((Status = RegQueryValueEx( Handle, REGISTRY_DISPLAY_NAME,
                                         NULL, &Type,
                                         (LPBYTE)szTemp, &ValueSize ))
              == ERROR_SUCCESS) )
            lstrncpy(szServiceName, szTemp, nServiceName);
        szServiceName[nServiceName-1] = TEXT('\0');

        LocalFree(szTemp);
        RegCloseKey(Handle);
        return(Status);
    }

}  // end RegGetNetworkServiceName


/*******************************************************************************
 *
 *  AsyncDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of async device names.  This will return both 'COM' devices
 *   and TAPI configured modems.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable is set to 0 (caller should double
 *       the input buffer and try again).
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *          ERROR_NOT_ENOUGH_MEMORY
 *              not enough memory to allocate working buffer(s)
 *          ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              the QueryDosDevice call failed.  This error code can be
 *              interpreted as 'no async devices are configured' for reporting
 *              purposes.
 *
 ******************************************************************************/

#define MAX_QUERY_BUFFER    (1024*16)

BOOL WINAPI
AsyncDeviceEnumerate( PPDCONFIG3 pPdConfig,
                      PULONG pEntries,
                      PPDPARAMS pPdParams,
                      PULONG pByteCount,
                      BOOL bInSetup )
{
    DWORD    Error = ERROR_SUCCESS;
    ULONG    Count;
    HKEY     hRoot = NULL;
    DWORD    BufSize, NameSize, Type, Index, SaveBufSize, SaveNameSize;
    LONG     Result = 0;
    LONG     nDosDevice = 0;
    LPTSTR   pBuffer = NULL, pBufferEnd = NULL;
    LPTSTR   pNameBuffer = NULL, pName;
    BOOLEAN  bRetVal = FALSE;

    /*
     *  Get maximum number of names that can be returned
     */
    Count = *pByteCount / sizeof(PDPARAMS);
    *pByteCount = 0;
    *pEntries = 0;

    /*
     *  Allocate buffer
     */
    SaveBufSize  = MAX_QUERY_BUFFER;
    SaveNameSize = MAX_QUERY_BUFFER;

    BufSize  = SaveBufSize;
    NameSize = SaveNameSize;

    if ( !(pBuffer = (LPTSTR)LocalAlloc(LPTR, BufSize * sizeof(TCHAR))) ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( !(pNameBuffer = (LPTSTR)LocalAlloc(LPTR, NameSize)) ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    /*
     * If we're in Setup, obtain devices from the SERIALCOMM section in
     * LOCAL MACHINE registry, since the serial device driver(s) are most
     * likely not running.  Otherwise, we'll query all DosDevices and
     * return those that are COM devices and are not currently in use.
     */
    if ( bInSetup ) {

        Result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               TEXT("HARDWARE\\DEVICEMAP\\SERIALCOMM"),
                               0,    // Reserved
                               KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,
                               &hRoot );

        if ( Result != ERROR_SUCCESS ) {

            //
            // This is usually the result of having no ports, so the key
            // SERIALCOMM does not exist.
            //
            goto Cleanup;
        }

        for ( Index=0; ; Index++ ) {

            // Each enumerate stomps on our buffer sizes
            BufSize  = SaveBufSize;
            NameSize = SaveNameSize;

            Result = RegEnumValue( hRoot,
                                   Index,
                                   pBuffer,
                                   &BufSize,
                                   NULL,    // Reserved
                                   &Type,
                                   (LPBYTE)pNameBuffer,
                                   &NameSize );

            if ( Result == ERROR_INSUFFICIENT_BUFFER ) {

                // Reallocate the buffer
                LocalFree( pBuffer );
                pBuffer = (LPTSTR)LocalAlloc(LPTR, BufSize * sizeof(TCHAR));
                if ( pBuffer == NULL ) {
                    // Try and reallocate next key
                    SaveBufSize = BufSize = 0;
                    continue;
                }
                else {
                    SaveBufSize = BufSize;
                }

                // Reallocate the name buffer
                LocalFree( pNameBuffer );
                pNameBuffer = (LPTSTR)LocalAlloc(LPTR, NameSize);
                if ( pNameBuffer == NULL ) {
                    // Try and reallocate next key
                    SaveNameSize = NameSize = 0;
                    continue;
                }
                else {
                    SaveNameSize = NameSize;
                }

                Result = RegEnumValue( hRoot,
                                       Index,
                                       pBuffer,
                                       &BufSize,
                                       NULL,    // Reserved
                                       &Type,
                                       (LPBYTE)pNameBuffer,
                                       &NameSize );
            }

            // We are done
            if ( Result == ERROR_NO_MORE_ITEMS ) {
                bRetVal = TRUE;
                Result = 0;
                goto Cleanup;
            }

            if ( Result != ERROR_SUCCESS ) {
                goto Cleanup;
            }

            if ( Count > 0 ) {

                if ( Type != REG_SZ ) {
                    continue;
                }

                pPdParams->SdClass = SdAsync;
                lstrcpy( pPdParams->Async.DeviceName, pNameBuffer );
                pPdParams++;
                Count--;
                (*pEntries)++;

            }
            else {

                Error = ERROR_INSUFFICIENT_BUFFER;
                goto Cleanup;
            }
        }

    }
    else {    // not in Setup

        /*
         *  Get complete device list
         */
        nDosDevice = QueryDosDevice( NULL, pBuffer, MAX_QUERY_BUFFER );
        if ( !nDosDevice)
        {
            Error = ERROR_DEV_NOT_EXIST;
            goto Cleanup;
        }

        /*
         *  Find each device name in list
         */
        pName = pBuffer;
        pBufferEnd = pBuffer + nDosDevice;
        while ( *pName && (pName < pBufferEnd) )  {
            if ( CheckForComDevice( pName ) ) {
                if ( Count > 0 ) {
                    pPdParams->SdClass = SdAsync;
                    lstrcpy( pPdParams->Async.DeviceName, pName );
                    pPdParams++;
                    Count--;
                    (*pEntries)++;
                }
                else {

                    Error = ERROR_INSUFFICIENT_BUFFER;
                    goto Cleanup;
                }
            }
            pName += (lstrlen(pName) + 1);
        }

        bRetVal = TRUE;     // sucessful enumeration
    }

    Cleanup:
    /*
     * If no errors yet, perform TAPI device enumeration.
     */
    if ( bRetVal ) {

        if ( (Error = EnumerateTapiPorts( pPdParams,
                                          Count,
                                          &pEntries ))
             != ERROR_SUCCESS ) {

            bRetVal = FALSE;
        }
    }

    if ( pBuffer ) {
        LocalFree( pBuffer );
    }

    if ( pNameBuffer ) {
        LocalFree( pNameBuffer );
    }

    if ( hRoot ) {
        CloseHandle( hRoot );
    }
    SetLastError(Error);
    return(bRetVal);

}  // AsyncDeviceEnumerate


/*******************************************************************************
 *
 *  NetBIOSDeviceEnumerate - Hydrix helper function
 *
 *   Returns a list of NetBIOS lana adapter numbers.
 *
 * ENTRY:
 *    pPdConfig (input)
 *       Points to PDCONFIG3 structure of the PD.
 *    pEntries (output)
 *       When the function finishes successfully, the variable pointed to
 *       by the pEntries parameter contains the number of entries actually
 *       returned.
 *    pPdParams (output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of PDPARAMS structures.
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pPdParams parameter. If the buffer is too small to receive all the
 *       entries, on output this variable receives the required size of the
 *       buffer.
 *    bInSetup (input)
 *          TRUE if we're operating in Setup; FALSE otherwise.
 *
 * EXIT:
 *      TRUE: enumeration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError(), and are the
 *      following possible values:
 *        v  ERROR_INSUFFICIENT_BUFFER
 *              enumeration failed because of an insufficient pPdParams
 *              buffer size to contain all devices
 *          ERROR_DEV_NOT_EXIST
 *              the NetBiosLanaEnum call failed.  This error code can be
 *              interpreted as 'no netbios devices are configured' for reporting
 *              purposes.
 *
 ******************************************************************************/

BOOL WINAPI
NetBIOSDeviceEnumerate( PPDCONFIG3 pPdConfig,
                        PULONG pEntries,
                        PPDPARAMS pPdParams,
                        PULONG pByteCount,
                        BOOL bInSetup )
{
    LANA_ENUM LanaEnum;
    NTSTATUS Status;
    int i;

    /*
     *  Issue netbios enum command
     */
    if ( Status = NetBiosLanaEnum( &LanaEnum ) ) {
        SetLastError(ERROR_DEV_NOT_EXIST);
        return(FALSE);
    }

    /*
     *  Make sure user's buffer is big enough
     */
    if ( LanaEnum.length > (*pByteCount / sizeof(PDPARAMS)) ) {

        *pByteCount = LanaEnum.length * sizeof(PDPARAMS);
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return(FALSE);
    }

    /*
     *  Return number of entries
     */
    *pEntries = (ULONG) LanaEnum.length;

    /*
     *  Return lana numbers
     */
    for ( i=0; i < (int)LanaEnum.length; i++, pPdParams++ ) {
        pPdParams->SdClass = SdNetwork;
        pPdParams->Network.LanAdapter = LanaEnum.lana[i];
    }

    return(TRUE);

}  // NetBIOSDeviceEnumerate


/*******************************************************************************
 *
 *  FormDecoratedAsyncDeviceName - Hydrix helper function
 *
 *   Format a decorated async device name if a modem is defined.
 *
 * ENTRY:
 *    pDeviceName (output)
 *       Points to buffer that will contain the decorated name (or undecorated
 *       name if no modem).
 *    pPdParams (input)
 *       Points to the ASYNCCONFIG structure to be used in forming the
 *       decorated name.
 *
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
FormDecoratedAsyncDeviceName( LPTSTR pDeviceName,
                              PASYNCCONFIG pAsyncConfig )
{
    if ( *(pAsyncConfig->ModemName) )
        wsprintf( pDeviceName, TEXT("%s - %s"),
                  pAsyncConfig->DeviceName,
                  pAsyncConfig->ModemName );
    else
        lstrcpy( pDeviceName,
                 pAsyncConfig->DeviceName );

}  // end FormDecoratedAsyncDeviceName


/*******************************************************************************
 *
 *  ParseDecoratedAsyncDeviceName - Hydrix helper function
 *
 *   Given a decorated async device name, form it's component device and
 *   modem name portions.
 *
 * ENTRY:
 *    pDeviceName (input)
 *       Points to buffer that contain the decorated async device name.
 *    pAsyncConfig (output)
 *       Points to the ASYNCCONFIG structure to save the device (in
 *       ->DeviceName) and modem (in ->ModemName).
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
ParseDecoratedAsyncDeviceName( LPCTSTR pDeviceName,
                               PASYNCCONFIG pAsyncConfig )
{
    int i;

    /*
     * Form DeviceName portion up to the first blank.
     */
    for ( i=0; *pDeviceName && (*pDeviceName != TEXT(' ')); i++ )
        (pAsyncConfig->DeviceName)[i] = *pDeviceName++;
    (pAsyncConfig->DeviceName)[i] = TEXT('\0');

    /*
     * Skip the ' - ' decoration (to the next space).
     */
    if ( *pDeviceName ) {
        for ( pDeviceName++;
            *pDeviceName && (*pDeviceName != TEXT(' '));
            pDeviceName++ );
    }

    /*
     * Form the ModemName from the remainder of the string.
     */
    i = 0;
    if ( *pDeviceName ) {

        for ( pDeviceName++; *pDeviceName ; i++ )
            (pAsyncConfig->ModemName)[i] = *pDeviceName++;
    }
    (pAsyncConfig->ModemName)[i] = TEXT('\0');

}  // end ParseDecoratedAsyncDeviceName


/*******************************************************************************
 *
 *  SetupAsyncCdConfig - Hydrix helper function
 *
 *   Given a properly configured ASYNCCONFIG structure, set up a given
 *   CDCONFIG structure.
 *
 * ENTRY:
 *    pAsyncConfig (input)
 *       Points properly configured ASYNCCONFIG structure.
 *    pCdConfig (output)
 *       Points to the CDCONFIG structure to setup.
 * EXIT:
 *
 ******************************************************************************/

void WINAPI
SetupAsyncCdConfig( PASYNCCONFIG pAsyncConfig,
                    PCDCONFIG pCdConfig )
{
    memset(pCdConfig, 0, sizeof(CDCONFIG));

    if ( *(pAsyncConfig->ModemName) ) {

        pCdConfig->CdClass = CdModem;
        lstrcpy( pCdConfig->CdName, TEXT("cdmodem") );
        lstrcpy( pCdConfig->CdDLL, TEXT("cdmodem.dll") );
    }

}  // end SetupAsyncCdConfig


/*******************************************************************************
 *
 *  InstallModem - Hydrix helper function
 *
 *   Install UNIMODEM modem(s).
 *
 * ENTRY:
 *    hwndOwner
 *       Window handle that owns the installation dialog.
 * EXIT:
 *      TRUE: installation completed; FALSE: error or user canceled.
 *
 *      If an error, the error code can be retrieved via GetLastError().
 *
 ******************************************************************************/

BOOL WINAPI
InstallModem( HWND hwndOwner )
{
    HDEVINFO hdi;
    BOOL bStatus = FALSE;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /*
     * Create a modem DeviceInfoSet
     */
    if ( (hdi = SetupDiCreateDeviceInfoList( (LPGUID)&GUID_DEVCLASS_MODEM,
                                             hwndOwner )) ) {

        SP_INSTALLWIZARD_DATA iwd;

        /*
         * Initialize the InstallWizardData
         */
        memset(&iwd, 0, sizeof(iwd));
        iwd.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        iwd.ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
        iwd.hwndWizardDlg = hwndOwner;

        /*
         * Set the InstallWizardData as the ClassInstallParams
         */
        if ( SetupDiSetClassInstallParams( hdi,
                                           NULL,
                                           (PSP_CLASSINSTALL_HEADER)&iwd,
                                           sizeof(iwd)) ) {

            /*
             * Call the class installer to invoke the installation
             * wizard.
             */
            SetCursor(hcur);
            hcur = NULL;

            if ( SetupDiCallClassInstaller( DIF_INSTALLWIZARD,
                                            hdi,
                                            NULL) ) {

                /*
                 * Success.  The wizard was invoked and finished.
                 */
                SetupDiCallClassInstaller( DIF_DESTROYWIZARDDATA,
                                           hdi,
                                           NULL );
                bStatus = TRUE;
            }
        }

        /*
         * Clean up
         */
        SetupDiDestroyDeviceInfoList( hdi );
    }

    if (hcur)
        SetCursor(hcur);

    return(bStatus);

}  // end InstallModem


/*******************************************************************************
 *
 *  ConfigureModem - Hydrix helper function
 *
 *   Configure the specified UNIMODEM modem.
 *
 * ENTRY:
 *    pModemName
 *       Name of UNIMODEM modem to configure.
 *    hwndOwner
 *       Window handle that owns the configuration dialog.
 * EXIT:
 *      TRUE: configuration was sucessful; FALSE otherwise.
 *
 *      The error code can be retrieved via GetLastError().
 *
 ******************************************************************************/

BOOL WINAPI
ConfigureModem( LPCTSTR pModemName,
                HWND hwndOwner )
{
    BOOL bStatus = FALSE;
    COMMCONFIG ccDummy;
    COMMCONFIG * pcc;
    DWORD dwSize;
    HCURSOR hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

    ccDummy.dwProviderSubType = PST_MODEM;
    dwSize = sizeof(COMMCONFIG);
    GetDefaultCommConfig(pModemName, &ccDummy, &dwSize);

    pcc = (COMMCONFIG *)LocalAlloc(LPTR, (UINT)dwSize);
    if ( pcc ) {

        pcc->dwProviderSubType = PST_MODEM;
        if ( GetDefaultCommConfig(pModemName, pcc, &dwSize) ) {

            COMMCONFIG *pccOld = (COMMCONFIG *)LocalAlloc(LPTR, (UINT)dwSize);

            if ( pccOld ) {

                memcpy(pccOld, pcc, dwSize);
            }

            SetCursor(hcur);
            hcur = NULL;

            bStatus = TRUE;
            if ( CommConfigDialog(pModemName, hwndOwner, pcc) ) {

                if ( !SetDefaultCommConfig(pModemName, pcc, dwSize) )
                    bStatus = FALSE;
            }

            LocalFree((HLOCAL)pcc);
        }
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (hcur)
        SetCursor(hcur);

    return(bStatus);

}  // end ConfigureModem


///////////////////////////////////////////////////////////////////////////////
// Static Helper Functions


/*******************************************************************************
 *
 *  CheckForComDevice - local helper function
 *
 *  check if device name is a serial com device
 *
 * ENTRY:
 *    pName (input)
 *       device name
 *
 * EXIT:
 *    TRUE  - serial device
 *    FALSE - not a serial device
 *
 ******************************************************************************/

static BOOL
CheckForComDevice( LPTSTR pName )
{
    FILE_FS_DEVICE_INFORMATION DeviceInformation;
    IO_STATUS_BLOCK IoStatus;
    HANDLE Handle;
    DEVICENAME Name;
    NTSTATUS Status;

    if ( (lstrlen(pName) == 2 && pName[1] == TEXT(':')) ||
         !lstrcmpi(pName, TEXT("aux")) ||
         !lstrnicmp(pName, TEXT("lpt"), 3) ||
         !lstrnicmp(pName, TEXT("prn"), 3) ||
         !lstrnicmp(pName, TEXT("display"), 7) ||
         !lstrnicmp(pName, TEXT("$VDMLPT"), 7))
        return(FALSE);

    lstrcpy( Name, TEXT("\\\\.\\") );
    lstrcat( Name, pName );

    try
    {
        Handle = CreateFile( Name,
                             GENERIC_READ | GENERIC_WRITE,
                             0,     // exclusive access
                             NULL,      // no security attr
                             OPEN_EXISTING, // must exist
                             0,
                             NULL       // no template
                           );
    }
    __except (1)
    {
        if ( Handle != INVALID_HANDLE_VALUE )
        {
            CloseHandle( Handle );
            Handle = INVALID_HANDLE_VALUE;
        }
    }

    if ( Handle == INVALID_HANDLE_VALUE )
        return(FALSE);

    Status = NtQueryVolumeInformationFile( (HANDLE) Handle,
                                           &IoStatus,
                                           &DeviceInformation,
                                           sizeof(DeviceInformation),
                                           FileFsDeviceInformation );

    CloseHandle( Handle );

    if ( (Status != STATUS_SUCCESS) ||
         (DeviceInformation.DeviceType != FILE_DEVICE_SERIAL_PORT) )
        return(FALSE);

    return(TRUE);

}  // end CheckForComDevice


/*******************************************************************************
 *
 * NetBiosLanaEnum - local helper function
 *
 *  enumerate lana numbers
 *
 * ENTRY:
 *     pLanaEnum (input)
 *        pointer to receive LAN_ENUM structure
 * EXIT:
 *      NO_ERROR - succesful
 *
 ******************************************************************************/

typedef struct _LANA_MAP {
    BOOLEAN Enum;
    UCHAR Lana;
} LANA_MAP, *PLANA_MAP;

static int
NetBiosLanaEnum( LANA_ENUM * pLanaEnum )
{
    int ProviderCount;
    void * pProviderNames = NULL;
    PLANA_MAP pLanaMap = NULL;
    HKEY netbiosKey = NULL;
    ULONG providerListLength;
    ULONG lanaMapLength;
    ULONG type;
    int i;
    LPTSTR currentProviderName;
    int rc;

    //
    // Read the registry for information on all Netbios providers,
    // including Lana numbers, protocol numbers, and provider device
    // names.  First, open the Netbios key in the registry.
    //

    rc = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGISTRY_NETBLINKAGE, 0,
                       MAXIMUM_ALLOWED, &netbiosKey );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the size of the provider names.  We need this so
    // that we can allocate enough memory to hold it.
    //

    providerListLength = 0;

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("Bind"),
                        NULL,
                        &type,
                        NULL,
                        &providerListLength
                        );
    if ( rc != ERROR_MORE_DATA && rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Allocate enough memory to hold the mapping.
    //
    if ( (pProviderNames = LocalAlloc(LPTR,providerListLength)) == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Get the list of transports from the registry.
    //

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("Bind"),
                        NULL,
                        &type,
                        (PVOID)pProviderNames,
                        &providerListLength
                        );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the size of the Lana map.  We need this so that we
    // can allocate enough memory to hold it.
    //

    providerListLength = 0;

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("LanaMap"),
                        NULL,
                        &type,
                        NULL,
                        &lanaMapLength
                        );
    if ( rc != ERROR_MORE_DATA && rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Allocate enough memory to hold the Lana map.
    //

    if ( (pLanaMap = LocalAlloc(LPTR,lanaMapLength)) == NULL ) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto error_exit;
    }

    //
    // Get the list of transports from the registry.
    //

    rc = RegQueryValueEx(
                        netbiosKey,
                        TEXT("LanaMap"),
                        NULL,
                        &type,
                        (PVOID)pLanaMap,
                        &lanaMapLength
                        );
    if ( rc != NO_ERROR ) {
        goto error_exit;
    }

    //
    // Determine the number of Netbios providers loaded on the system.
    //
    ProviderCount = (int) (lanaMapLength / sizeof(LANA_MAP));

    //
    // Fill in the lana array
    //
    pLanaEnum->length = 0;
    for ( currentProviderName = pProviderNames, i = 0;
        *currentProviderName != UNICODE_NULL && i < ProviderCount;
        currentProviderName += lstrlen( currentProviderName ) + 1, i++ ) {

        if ( pLanaMap[i].Enum &&
             lstrstr( currentProviderName, TEXT("Nbf_") ) ) {
            pLanaEnum->lana[ pLanaEnum->length++ ] = pLanaMap[i].Lana;
        }
    }

    error_exit:

    if ( netbiosKey != NULL )
        RegCloseKey( netbiosKey );

    if ( pProviderNames != NULL )
        LocalFree( pProviderNames );

    if ( pLanaMap != NULL )
        LocalFree( pLanaMap );

    return( rc );
}


//
// NOTE: Butchd 9-26-96
// all of this following TAPI-related code is from various
// \nt\private\net\ras\src\ui\setup\src\ files
//
/******************************************************************************
 *
 *  EnumerateTapiPorts - local helper function
 *
 *  Determine all TAPI configured modems.
 *
 *  ENTRY
 *      pPdParams (output)
 *          Points to array of PDPARAMS structures to save enumerated TAPI
 *          modems into.
 *      Count (input)
 *          Specifies number of entries in the pPdParams array.
 *      ppEntries (input/output)
 *          Points to pointer to variable containing the existing number of
 *          PDPARAMS entries already stored at addresses prior to pPdParams.
 *          The referenced variable will be incremented by the number of
 *          TAPI modems found and stored in the pPdParams array.
 *  EXIT
 *    Returns ERROR_SUCCESS if successful, error code if not.
 *
 *****************************************************************************/

DWORD
EnumerateTapiPorts( PPDPARAMS pPdParams,
                    ULONG Count,
                    ULONG **ppEntries )
{
    LINEINITIALIZEEXPARAMS params;
    LINEDEVCAPS            *linedevcaps ;
    LINEEXTENSIONID        extensionid ;
    HLINEAPP               TapiLine = (HLINEAPP)0;
    DWORD                  NegotiatedApiVersion ;
    DWORD                  NegotiatedExtVersion = 0;
    WORD                   i;
    DWORD                  lines = 0 ;
    BYTE                   buffer[1000] ;
    CHAR                   szregkey[512];
    WCHAR                  wszDeviceName[DEVICENAME_LENGTH+1];
    WCHAR                  wszModemName[DEVICENAME_LENGTH+1];
    CHAR                   szModemName[DEVICENAME_LENGTH+1];
    LONG                   lerr;
    DWORD                  Status = ERROR_TAPI_CONFIGURATION;
    DWORD                  dwApiVersion = HIGH_VERSION;
    BOOL                   fSuccess = FALSE;
    ULONG                  RASIsUsingPort = 0;
    HKEY                   CurKey, CurKey2;
    DWORD                  KeyCount=0, KeySize, CurSize, DataType;
    TCHAR                  szSubKey[255], CurRASDev[1024], szMainKey[255], *pCurRASDev;

    /*
     * Un-comment / edit the following line if time needed to allow newly
     * added modem to appear in TAPI's enumeration list.
     */
    //  Sleep(4000L);

    /*
     * Initialize TAPI.
     */
    memset(&params, 0, sizeof(params));
    params.dwTotalSize = sizeof(params);
    params.dwOptions   = LINEINITIALIZEEXOPTION_USEEVENT;
    if ( lerr = lineInitializeExA( &TapiLine,
                                   GetModuleHandle( UTILDLL_NAME ),
                                   (LINECALLBACK)DummyTapiCallback,
                                   NULL,
                                   &lines,
                                   &dwApiVersion,
                                   &params ) )
        goto error;

    /*
     * Get configured TAPI modems on all lines.
     */
    for ( i = 0; i < lines; i++ ) {

        if ( lineNegotiateAPIVersion( TapiLine, i,
                                      LOW_VERSION, HIGH_VERSION,
                                      &NegotiatedApiVersion,
                                      &extensionid ) ) {
            continue ;
        }

        memset( buffer, 0, sizeof(buffer) );

        linedevcaps = (LINEDEVCAPS *)buffer;
        linedevcaps->dwTotalSize = sizeof(buffer);

        /*
         * Get this line's dev caps (ANSI).
         */
        if ( lineGetDevCapsA( TapiLine, i,
                              NegotiatedApiVersion,
                              NegotiatedExtVersion,
                              linedevcaps ) ) {
            continue ;
        }

        /*
li         * Only process modems.
         */
        if ( linedevcaps->dwMediaModes & LINEMEDIAMODE_DATAMODEM ) {

            /*
             * The linedevcaps stuff is in ASCII.
             */
            DWORD j;
            char *temp;

            /*
             * Convert all nulls in the device class string to non nulls.
             */
            for ( j = 0, temp = (char *)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset);
                j < linedevcaps->dwDeviceClassesSize;
                j++, temp++ ) {

                if ( *temp == '\0' )
                    *temp = ' ';
            }

            /*
             * Select only those devices that have comm/datamodem as a
             * device class.
             */
            if ( strstr( (char*)((BYTE *)linedevcaps+linedevcaps->dwDeviceClassesOffset),
                         "comm/datamodem" ) == NULL ) {
                continue;
            }

            /*
             * Fetch modem name (line name).
             */
            strncpy( szModemName,
                     (char *)((BYTE *)linedevcaps+linedevcaps->dwLineNameOffset),
                     DEVICENAME_LENGTH );
            szModemName[DEVICENAME_LENGTH] = '\0';
            MultiByteToWideChar(CP_ACP, 0, szModemName, -1, wszModemName, DEVICENAME_LENGTH + 1);

            /*
             * The registry key name where the modem specific information is
             * stored is at dwDevSpecificOffset + 2 * DWORDS
             *
             * The device specifc string is not unicode so copy that as
             * an ansii string
             */
            strncpy( szregkey,
                     (char *)linedevcaps+linedevcaps->dwDevSpecificOffset+(2*sizeof(DWORD)),
                     linedevcaps->dwDevSpecificSize );
            szregkey[linedevcaps->dwDevSpecificSize] = '\0';

            if ( !GetAssociatedPortName( szregkey, wszDeviceName ) ) {

                goto error;
            }

            /*
             * If RAS is installed and is using the port configured with this
             * modem, we will return the modem, but the Parity field will be
             * set to 1, indicating that RAS is using the port.  This is done
             * so that WinCfg (or other caller) can filter out the raw port
             * (device name) as well as the TAPI modem from the list.
             */
            RASIsUsingPort = 0;
            //See if the RAS Key even exists
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\RAS\\TAPI DEVICES"), 0, KEY_ALL_ACCESS, &CurKey) == ERROR_SUCCESS) {

                KeySize = sizeof(szSubKey) / sizeof( TCHAR );
                KeyCount = 0;
                while (RegEnumKeyEx( CurKey,
                                     KeyCount++,
                                     szSubKey,
                                     &KeySize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL
                                   ) != ERROR_NO_MORE_ITEMS) {

                    wcscpy(szMainKey,TEXT("SOFTWARE\\Microsoft\\RAS\\TAPI DEVICES"));
                    wcscat(szMainKey,TEXT("\\"));
                    wcscat(szMainKey,szSubKey);

                    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, szMainKey, 0, KEY_ALL_ACCESS, &CurKey2) == ERROR_SUCCESS) {
                        CurSize = sizeof(CurRASDev);
                        if (RegQueryValueEx(
                                           CurKey2,
                                           TEXT("Address"),
                                           NULL,
                                           &DataType,
                                           (LPBYTE)CurRASDev,
                                           &CurSize
                                           ) == ERROR_SUCCESS) {

                            for ( pCurRASDev = CurRASDev;
                                *pCurRASDev && !RASIsUsingPort; ) {

                                if ( lstrcmpi(pCurRASDev, wszDeviceName) == 0 )
                                    RASIsUsingPort = 1;
                                else
                                    pCurRASDev += (wcslen(pCurRASDev) + 1);
                            }
                        }
                        RegCloseKey(CurKey2);
                    }

                    KeySize = sizeof(szSubKey) / sizeof( TCHAR );
                }
                RegCloseKey(CurKey);
            }

            /*
             * Save DeviceName and ModemName to PDPARAMS
             * structure and bump counts.  Also, set the BaudRate
             * element to the TAPI line index so that the caller can
             * determine the most recently added line, and set the Parity
             * field to 0 if RAS is not using the line, 1 if RAS is
             * using the line (so caller can filter properly).
             */
            if ( Count > 0 ) {

                pPdParams->SdClass = SdAsync;
                lstrcpy( pPdParams->Async.DeviceName, wszDeviceName );
                lstrcpy( pPdParams->Async.ModemName, wszModemName );
                pPdParams->Async.BaudRate = (ULONG)i;
                pPdParams->Async.Parity = RASIsUsingPort;
                pPdParams++;
                Count--;
                (**ppEntries)++;

            }
            else {

                Status = ERROR_INSUFFICIENT_BUFFER;
                goto error;
            }
        }
    }
    Status = ERROR_SUCCESS;

    error:
    if ( TapiLine )
        lineShutdown(TapiLine);

    return( Status );

}  // end EnumerateTapiPorts


/******************************************************************************
 *
 *  DummyTapiCallback - local helper function
 *
 *  A dummy callback routine to satisfy TAPI initialization.
 *
 *  ENTRY
 *      (see TAPI lineInitialize documentation)
 *  EXIT
 *
 *****************************************************************************/

VOID CALLBACK
DummyTapiCallback (HANDLE context, DWORD msg, DWORD instance, DWORD param1, DWORD param2, DWORD param3)
{
}  // end DummyTapiCallback


/******************************************************************************
 *
 *  GetAssociatedPortName - local helper function
 *
 *  Determine the 'attached to' (port) for the given modem via it's device
 *  specific registry key (szKeyName).
 *
 *  ENTRY
 *      (see TAPI lineInitialize documentation)
 *  EXIT
 *
 *****************************************************************************/

#define VALNAME_ATTACHEDTO "AttachedTo"

BOOL
GetAssociatedPortName( char  *szKeyName,
                       WCHAR * wszPortName )
{
    HKEY   hKeyModem;
    DWORD  dwType;
    DWORD  cbValueBuf;
    char   szPortName[DEVICENAME_LENGTH+1];

    if ( RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        szKeyName,
                        0,
                        KEY_READ,
                        &hKeyModem ) ) {

        return( FALSE );
    }

    cbValueBuf = sizeof( szPortName );
    if ( RegQueryValueExA( hKeyModem,
                           VALNAME_ATTACHEDTO,
                           NULL,
                           &dwType,
                           (LPBYTE)&szPortName,
                           &cbValueBuf ) ) {
        RegCloseKey(hKeyModem);
        return ( FALSE );
    }

    RegCloseKey( hKeyModem );

    MultiByteToWideChar(CP_ACP, 0, szPortName, -1, wszPortName, DEVICENAME_LENGTH + 1);

    return( TRUE );

}  // end GetAssociatedPortName


/*
 * Defines and typedefs
 */
typedef struct _userlist {
    struct _userlist *pNext;
    WCHAR UserName[USERNAME_LENGTH+1];
} USERLIST, *PUSERLIST;

#define MAX_DOMAINANDNAME     ((DOMAIN_LENGTH+1+USERNAME_LENGTH+1)*sizeof(WCHAR))
#define MAX_BUFFER            (10*MAX_DOMAINANDNAME)

/*
 * Local variables
 */
WCHAR *s_pszCompareList = NULL;
WCHAR s_szServer[256];

/*
 * Local functions.
 */
WCHAR *_ctxCreateAnonymousUserCompareList();

/*******************************************************************************
 *
 *  InitializeAnonymousUserCompareList - helper routine
 *
 *    Creates a list of all local users who currently belong to the local
 *    Anonymous group on the specified server, and saves the server name.
 *
 * ENTRY:
 *    pszServer (input)
 *       Name of server to query users for.
 *
 ******************************************************************************/

void WINAPI
InitializeAnonymousUserCompareList( const WCHAR *pszServer )
{
    if ( s_pszCompareList )
        free( s_pszCompareList );

    wcscpy(s_szServer, pszServer);

    s_pszCompareList = _ctxCreateAnonymousUserCompareList();
}


/*******************************************************************************
 *
 *  HaveAnonymousUsersChanged - helper routine
 *
 *    Using the saved server name, fetch current list of local users that
 *    belong to the local Anonymous group and compare with saved list.
 *
 * ENTRY:
 * EXIT:
 *    On exit, the original compare list is freed and server name cleared.
 *
 ******************************************************************************/

BOOL WINAPI
HaveAnonymousUsersChanged()
{
    BOOL bChanged = FALSE;
    WCHAR *pszNewCompareList, *pszOldName, *pszNewName;

    if ( s_pszCompareList && *s_szServer ) {

        if ( pszNewCompareList = _ctxCreateAnonymousUserCompareList() ) {

            bChanged = TRUE;

            for ( pszOldName = s_pszCompareList, pszNewName = pszNewCompareList;
                (*pszOldName != L'\0') && (*pszNewName != L'\0'); ) {

                if ( wcscmp(pszOldName, pszNewName) )
                    break;
                pszOldName += (wcslen(pszOldName) + 1);
                pszNewName += (wcslen(pszNewName) + 1);
            }

            if ( (*pszOldName == L'\0') && (*pszNewName == L'\0') )
                bChanged = FALSE;

            free(pszNewCompareList);
        }
    }

    if ( s_pszCompareList )
        free( s_pszCompareList );

    s_pszCompareList = NULL;

    memset(s_szServer, 0, sizeof(s_szServer));

    return(bChanged);
}


/*******************************************************************************
 *
 *  _ctxCreateAnonymousUserCompareList - local routine
 *
 *    Routine to get local anonymous users and place in sorted string list.
 *
 * ENTRY:
 * EXIT:
 *      pszCompareList - Returns pointer to buffer containing sorted string
 *                       list of local anonymous users, double null terminated.
 *                       NULL if error.
 *
 ******************************************************************************/

WCHAR *
_ctxCreateAnonymousUserCompareList()
{
    DWORD                        EntriesRead, EntriesLeft, ResumeHandle = 0;
    NET_API_STATUS               rc;
    WCHAR                        DomainAndUsername[256], *pszCompareList = NULL;
    DWORD                        i, TotalCharacters = 0;
    LPWSTR                       p;
    PLOCALGROUP_MEMBERS_INFO_3   plgrmi3 = NULL;
    PUSERLIST                    pUserListBase = NULL, pNewUser;

    /*
     * Loop till all local anonymous users have been retrieved.
     */
    do {

        /*
         *  Get first batch
         */
        if ( (rc = NetLocalGroupGetMembers( s_szServer,
                                            PSZ_ANONYMOUS,
                                            3,
                                            (LPBYTE *)&plgrmi3,
                                            MAX_BUFFER,
                                            &EntriesRead,
                                            &EntriesLeft,
                                            (PDWORD_PTR)(&ResumeHandle) )) &&
             (rc != ERROR_MORE_DATA ) ) {

            break;
        }

        /*
         *  Process first batch
         */
        for ( i = 0; i < EntriesRead; i++ ) {

            /*
             *  Get DOMAIN/USERNAME
             */
            wcscpy( DomainAndUsername, plgrmi3[i].lgrmi3_domainandname );

            /*
             *  Check that DOMAIN is actually LOCAL MACHINE NAME
             */
            if ( (p = wcsrchr( DomainAndUsername, L'\\' )) != NULL ) {

                /*
                 * Make sure that this user belongs to specified
                 * server.
                 */
                *p = L'\0';
                if ( _wcsicmp( DomainAndUsername, &s_szServer[2] ) ) {
                    continue;
                }
            }

            /*
             * Allocate list element and insert this username into list.
             */
            if ( (pNewUser = (PUSERLIST)malloc(sizeof(USERLIST))) == NULL ) {

                rc = ERROR_OUTOFMEMORY;
                break;
            }

            pNewUser->pNext = NULL;
            wcscpy(pNewUser->UserName, p+1);
            TotalCharacters += wcslen(p+1) + 1;

            if ( pUserListBase == NULL ) {

                /*
                 * First item in list.
                 */
                pUserListBase = pNewUser;

            }
            else {

                PUSERLIST pPrevUserList, pUserList;
                pPrevUserList = pUserList = pUserListBase;

                for ( ; ; ) {

                    if ( wcscmp(pNewUser->UserName, pUserList->UserName) < 0 ) {

                        if ( pPrevUserList == pUserListBase ) {

                            /*
                             * Insert at beginning of list.
                             */
                            pUserListBase = pNewUser;

                        }
                        else {

                            /*
                             * Insert into middle or beginning of list.
                             */
                            pPrevUserList->pNext = pNewUser;
                        }

                        /*
                         * Link to next.
                         */
                        pNewUser->pNext = pUserList;
                        break;

                    }
                    else if ( pUserList->pNext == NULL ) {

                        /*
                         * Add to end of list.
                         */
                        pUserList->pNext = pNewUser;
                        break;
                    }

                    pPrevUserList = pUserList;
                    pUserList = pUserList->pNext;
                }
            }
        }

        /*
         *  Free memory
         */
        if ( plgrmi3 != NULL ) {
            NetApiBufferFree( plgrmi3 );
        }

    } while ( rc == ERROR_MORE_DATA );

    /*
     * Allocate buffer for multi-string compare list if no error so far
     * and terminate in case of empty list.
     */
    if ( rc == ERROR_SUCCESS ) {

        pszCompareList = (WCHAR *)malloc( (++TotalCharacters) * 2 );

        if( pszCompareList != NULL )
        {
            *pszCompareList = L'\0';
        }
    }

    /*
     * Traverse and free username list, creating the multi-string compare
     * list if buffer is available (no error so far).
     */
    if ( pUserListBase ) {

        PUSERLIST pUserList = pUserListBase,
                              pNext = NULL;
        WCHAR *pBuffer = pszCompareList;

        do {

            pNext = pUserList->pNext;

            if ( pBuffer ) {

                wcscpy(pBuffer, pUserList->UserName);
                pBuffer += (wcslen(pBuffer) + 1);
                *pBuffer = L'\0';   // auto double-null terminate
            }

            free(pUserList);
            pUserList = pNext;

        } while ( pUserList );
    }

    return(pszCompareList);
}


/*******************************************************************************
 *
 *  GetUserFromSid - Hydrix helper function
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      cbUserName (input)
 *          Specifies the size in bytes of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary.
 *
 *  EXIT:
 *
 *      GetUserFromSid() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 ******************************************************************************/

void WINAPI
GetUserFromSid( PSID pSid,
                LPTSTR pUserName,
                DWORD cbUserName )
{
    TCHAR DomainBuffer[DOMAIN_LENGTH], UserBuffer[USERNAME_LENGTH];
    DWORD cbDomainBuffer=sizeof(DomainBuffer), cbUserBuffer=sizeof(UserBuffer),
                                                            Error;
    LPTSTR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cbUserBuffer,
                            DomainBuffer, &cbDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cbDomainBuffer > sizeof(DomainBuffer) ) {

                if ( !(pDomainBuffer =
                       (LPTSTR)LocalAlloc(
                                         LPTR, cbDomainBuffer * sizeof(TCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cbUserBuffer > sizeof(UserBuffer) ) {

                if ( !(pUserBuffer =
                       (LPTSTR)LocalAlloc(
                                         LPTR, cbUserBuffer * sizeof(TCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                    pUserBuffer ?
                                    pUserBuffer : UserBuffer,
                                    &cbUserBuffer,
                                    pDomainBuffer ?
                                    pDomainBuffer : DomainBuffer,
                                    &cbDomainBuffer,
                                    &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        }
        else {

            goto BadLookup;
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary,
     * and make lower case.
     */
    lstrncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer,
              cbUserName - 1 );
    pUserName[cbUserName-1] = TEXT('\0');
    lstrlwr(pUserName);

    /*
     * Free our local allocs (if any) and return.
     */
    if ( pDomainBuffer )
        LocalFree(pDomainBuffer);
    if ( pUserBuffer )
        LocalFree(pUserBuffer);
    return;

    /*--------------------------------------
     * Error clean-up and return...
     */
    BadLookup:
    BadUserAlloc:
    BadDomainAlloc:
    if ( pDomainBuffer )
        LocalFree(pDomainBuffer);
    if ( pUserBuffer )
        LocalFree(pUserBuffer);
    LoadString( GetModuleHandle( UTILDLL_NAME ),
                IDS_UNKNOWN, pUserName, cbUserName - 1 );
    pUserName[cbUserName-1] = TEXT('\0');
    return;

}  // end GetUserFromSid


/*******************************************************************************
 *
 *  CachedGetUserFromSid - Hydrix helper function
 *
 *      Provides entry point for a direct call to the UTILSUB.LIB
 *      GetUserNameFromSid, which performs its own caching of usernames.
 *
 *  ENTRY:
 *      See UTILSUB.LIB GetUserNameFromSid (procutil.c)
 *  EXIT:
 *      See UTILSUB.LIB GetUserNameFromSid (procutil.c)
 *
 ******************************************************************************/

void WINAPI
CachedGetUserFromSid( PSID pSid,
                      PWCHAR pUserName,
                      PULONG pcbUserName )
{
    GetUserNameFromSid( pSid, pUserName, pcbUserName );

}  // end CachedGetUserFromSid

/*****************************************************************************
 *
 *  TestUserForAdmin - Hydrix helper function
 *
 *   Returns whether the current thread is running under admin
 *   security.
 *
 * ENTRY:
 *   dom (input)
 *     TRUE/FALSE - whether we want DOMAIN admin (as compared to local admin)
 *
 * EXIT:
 *   TRUE/FALSE - whether user is specified admin
 *
 ****************************************************************************/

BOOL WINAPI
TestUserForAdmin( BOOL dom )
{
    BOOL IsMember, IsAnAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    PSID AdminSid;


    if (RtlAllocateAndInitializeSid(
                                     &SystemSidAuthority,
                                     2,
                                     SECURITY_BUILTIN_DOMAIN_RID,
                                     DOMAIN_ALIAS_RID_ADMINS,
                                     0, 0, 0, 0, 0, 0,
                                     &AdminSid
                                     ) != STATUS_SUCCESS)
    {
        IsAnAdmin = FALSE;
    }
    else
    {
        if (!CheckTokenMembership(  NULL,
                                    AdminSid,
                                    &IsMember))
        {
            RtlFreeSid(AdminSid);
            IsAnAdmin = FALSE;
        }
        else
        {
            RtlFreeSid(AdminSid);
            IsAnAdmin = IsMember;
        }
    }

    return IsAnAdmin;

//    UNUSED dom;

} // end of TestUserForAdmin


/*****************************************************************************
 *
 *  IsPartOfDomain - Hydrix helper function
 *
 *   Returns whether the current server participates in a domain.
 *
 * ENTRY:
 *
 * EXIT:
 *   TRUE or FALSE
 *
 ****************************************************************************/

BOOL WINAPI
IsPartOfDomain(VOID)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo;
    OBJECT_ATTRIBUTES ObjAttributes;
    BOOL IsDomainName = FALSE;

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes( &ObjAttributes, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( NULL,
                            &ObjAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PolicyHandle );

    if ( !NT_SUCCESS(Status) )
        goto done;

    //
    // Get the name of the primary domain from LSA
    //
    Status = LsaQueryInformationPolicy( PolicyHandle,
                                        PolicyPrimaryDomainInformation,
                                        (PVOID *)&DomainInfo );

    (void) LsaClose( PolicyHandle );

    if ( !NT_SUCCESS(Status) )
        goto done;

    if ( DomainInfo->DomainSid )
        IsDomainName = TRUE;

    (void) LsaFreeMemory( DomainInfo );

    done:
    return( IsDomainName );

}  // end IsPartOfDomain


/*******************************************************************************
 *
 *  StrSdClass - Hydrix helper function
 *
 *      Returns pointer to string representing the specified SdClass.
 *
 *  ENTRY:
 *      SdClass (input)
 *          The SDCLASS to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the SDCLASS.
 *
 ******************************************************************************/

LPTSTR SdClassStrings[9] = { NULL};

LPCTSTR WINAPI
StrSdClass( SDCLASS SdClass )
{
    TCHAR buffer[256];

    WORD wID = IDS_UNKNOWN_PROTOCOL;

    switch ( SdClass ) {

        case SdConsole:
            wID = IDS_CONSOLE;
            break;

        case SdNetwork:
            wID = IDS_NETWORK;
            break;

        case SdAsync:
            wID = IDS_ASYNC;
            break;

        case SdFrame:
            wID = IDS_FRAME;
            break;

        case SdReliable:
            wID = IDS_RELIABLE;
            break;

        case SdCompress:
            wID = IDS_COMPRESSION;
            break;

        case SdEncrypt:
            wID = IDS_ENCRYPTION;
            break;

        case SdTelnet:
            wID = IDS_TELNET;
            break;
    }

    // If we haven't loaded the string yet, do it now
    if (!SdClassStrings[wID - IDS_CONSOLE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        SdClassStrings[wID - IDS_CONSOLE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == SdClassStrings[wID - IDS_CONSOLE])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(SdClassStrings[wID - IDS_CONSOLE], buffer);

    }

    return(SdClassStrings[wID]);

}  // end StrSdClass


/*******************************************************************************
 *
 *  StrConnectState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified WinStation
 *      connection state.
 *
 *  ENTRY:
 *      ConnectState (input)
 *          The WinStation connect state to associate with a string.
 *      bShortString (input)
 *          If TRUE, returns a short(er) version of the string (if there is
 *          one); FALSE returns the full spelling.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the connect state.
 *
 *  Note: The short version of the string may be the same as the long version.
 *          (i.e. "active")  However, there are two string resources in case
 *          the long version of the string is not short in a language other
 *          than English.
 ******************************************************************************/

LPTSTR ConnectStateStrings[21] = { NULL};

LPCTSTR WINAPI
StrConnectState( WINSTATIONSTATECLASS ConnectState,
                 BOOL bShortString )
{
    TCHAR buffer[256];
    WORD wID = IDS_UNKNOWN;

    switch ( ConnectState ) {

        case State_Active:
            wID  = bShortString ? IDS_SHORT_ACTIVE : IDS_ACTIVE;
            break;

        case State_Connected:
            wID  = bShortString ? IDS_SHORT_CONNECTED : IDS_CONNECTED;
            break;

        case State_ConnectQuery:
            wID  = bShortString ? IDS_SHORT_CONNECT_QUERY : IDS_CONNECT_QUERY;
            break;

        case State_Shadow:
            wID  = bShortString ? IDS_SHORT_SHADOW : IDS_SHADOW;
            break;

        case State_Disconnected:
            wID  = bShortString ? IDS_SHORT_DISCONNECTED : IDS_DISCONNECTED;
            break;

        case State_Idle:
            wID  = bShortString ? IDS_SHORT_IDLE  : IDS_IDLE;
            break;

        case State_Reset:
            wID  = bShortString ? IDS_SHORT_RESET  : IDS_RESET;
            break;

        case State_Down:
            wID  = bShortString ? IDS_SHORT_DOWN  : IDS_DOWN;
            break;

        case State_Init:
            wID  = bShortString ? IDS_SHORT_INIT  : IDS_INIT;
            break;

        case State_Listen:
            wID  = bShortString ? IDS_SHORT_LISTEN : IDS_LISTEN;
            break;
    }

    // If we haven't loaded the string yet, do it now
    if (!ConnectStateStrings[wID - IDS_ACTIVE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        ConnectStateStrings[wID - IDS_ACTIVE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == ConnectStateStrings[wID - IDS_ACTIVE])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(ConnectStateStrings[wID - IDS_ACTIVE], buffer);
    }

    return(ConnectStateStrings[wID - IDS_ACTIVE]);


}  // end StrConnectState


/*******************************************************************************
 *
 *  StrProcessState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified process state.
 *
 *  ENTRY:
 *      State (input)
 *          The process state to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the process state.
 *
 ******************************************************************************/

LPTSTR ProcessStateStrings[8] = { NULL};

WORD StateTable[] = {
    IDS_INITED,
    IDS_READY,
    IDS_RUN,
    IDS_STANDBY,
    IDS_TERMINATE,
    IDS_WAIT,
    IDS_TRANSIT,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES,
    IDS_STATE_DASHES
};

LPCTSTR WINAPI
StrProcessState( ULONG State )
{
    TCHAR buffer[256];

    WORD wID = StateTable[State];

    // If we haven't loaded the string yet, do it now
    if (!ProcessStateStrings[wID - IDS_INITED]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        ProcessStateStrings[wID - IDS_INITED] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == ProcessStateStrings[wID - IDS_INITED])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(ProcessStateStrings[wID - IDS_INITED], buffer);
    }

    return(ProcessStateStrings[wID - IDS_INITED]);


}  // end StrProcessState


/*******************************************************************************
 *
 *  StrSystemWaitReason - Hydrix helper function
 *
 *      Returns pointer to string representing the specified 'system'
 *      wait reason code.
 *
 *  ENTRY:
 *      WaitReason (input)
 *          The system wait reason code to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the system wait reason.
 *
 ******************************************************************************/

LPTSTR SystemWaitStrings[31] = { NULL};

WORD SystemWaitReason[] = {
    IDS_EXECUTIVE,          // Executive
    IDS_FREE_PAGE,          // FreePage
    IDS_PAGE_IN,            // PageIn
    IDS_POOL_ALLOC,         // PoolAlloc
    IDS_DELAY_EXECUTION,    // DelayExecution
    IDS_SUSPENDED,          // Suspended
    IDS_USER_REQUEST,       // UserRequest
    IDS_EXECUTIVE,          // Executive
    IDS_FREE_PAGE,          // FreePage
    IDS_PAGE_IN,            // PageIn
    IDS_POOL_ALLOC,         // PoolAllocation
    IDS_DELAY_EXECUTION,    // DelayExecution
    IDS_SUSPENDED,          // Suspended
    IDS_USER_REQUEST,       // UserRequest
    IDS_EVENT_PAIR_HIGH,    // EventPairHigh
    IDS_EVENT_PAIR_LOW,     // EventPairLow
    IDS_LPC_RECEIVE,        // LpcReceive
    IDS_LPC_REPLY,          // LpcReply
    IDS_VIRTUAL_MEMORY,     // VirtualMemory
    IDS_PAGE_OUT,           // PageOut
    IDS_WAIT1,
    IDS_WAIT2,
    IDS_WAIT3,
    IDS_WAIT4,
    IDS_WAIT5,
    IDS_WAIT6,
    IDS_WAIT7,
    IDS_WAIT8,
    IDS_WAIT9,
    IDS_WAIT10
};

LPCTSTR WINAPI
StrSystemWaitReason( ULONG WaitReason )
{
    TCHAR buffer[256];

    WORD wID = SystemWaitReason[WaitReason];

    // If we haven't loaded the string yet, do it now
    if (!SystemWaitStrings[wID - IDS_EXECUTIVE]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID, buffer, lengthof(buffer) );
        SystemWaitStrings[wID - IDS_EXECUTIVE] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
                if(NULL == SystemWaitStrings[wID - IDS_EXECUTIVE])
                {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return NULL;
                }
        wcscpy(SystemWaitStrings[wID - IDS_EXECUTIVE], buffer);
    }

    return(SystemWaitStrings[wID - IDS_EXECUTIVE]);


}  // end StrSystemWaitReason


/*******************************************************************************
 *
 *  StrAsyncConnectState - Hydrix helper function
 *
 *      Returns pointer to string representing the specified async connect state.
 *
 *  ENTRY:
 *      State (input)
 *          The async connect state to associate with a string.
 *
 *  EXIT:
 *      (LPCTSTR) Points to string representing the async connect state.
 *
 ******************************************************************************/

LPTSTR AsyncConnectStateStrings[6] = { NULL };

LPCTSTR WINAPI
StrAsyncConnectState( ASYNCCONNECTCLASS State )
{
    TCHAR buffer[256];
    WORD wID = State - Connect_CTS;

    // If we haven't loaded the string yet, do it now
    if (!AsyncConnectStateStrings[wID]) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   wID + IDS_ASYNC_CONNECT_CTS, buffer, lengthof(buffer) );
        AsyncConnectStateStrings[wID] = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == AsyncConnectStateStrings[wID])
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(AsyncConnectStateStrings[wID], buffer);
    }

    return(AsyncConnectStateStrings[wID]);


}  // end StrProcessState


/*******************************************************************************
*
*  GetUnknownString - Hydrix helper function
*
*      Returns pointer to the string representing an unknown
*      Connect State or DateTimeString (IDS_UNKNOWN)
*      This is primarily so that WinAdmin can compare against it
*
*  ENTRY:
*      None
*
*  EXIT:
*      (LPCTSTR) Points to string representing the unknown string
*
******************************************************************************/

LPTSTR UnknownString = NULL;

LPCTSTR WINAPI
GetUnknownString()
{
    TCHAR buffer[256];

    // if we haven't loaded the string yet, do it now
    if (!UnknownString) {
        LoadString(GetModuleHandle( UTILDLL_NAME ),
                   IDS_UNKNOWN, buffer, lengthof(buffer) );
        UnknownString = LocalAlloc(LPTR, 2*(wcslen(buffer)+1));
        if(NULL == UnknownString)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        lstrcpy(UnknownString, buffer);
    }

    return(UnknownString);

}  // end GetUnknownString


/*******************************************************************************
 *
 *  CalculateElapsedTime - Hydrix helper function
 *
 *      Determines the difference between a specified LARGE_INTEGER time value
 *      and the current system time, saves this 'elapsed time' into the
 *      specified ELAPSEDTIME structure.
 *
 *  ENTRY:
 *      pTime (input)
 *          Points to LARGE_INTEGER of time for difference calculation.
 *      pElapsedTime (output)
 *          Points to ELAPSEDTIME structure to save elapsed time.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
CalculateElapsedTime( LARGE_INTEGER *pTime,
                      ELAPSEDTIME *pElapsedTime )
{
    LARGE_INTEGER InputTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DiffTime;
    SYSTEMTIME ltime;
    ULONG d_time;

    /*
     * Fetch the current time and zero out the specified ELAPSEDTIME structure.
     */
    GetLocalTime( &ltime );
    memset( pElapsedTime, 0, sizeof(ELAPSEDTIME) );

    if ( (pTime->HighPart == 0 && pTime->LowPart == 0 ) ||
         !FileTimeToLocalFileTime( (FILETIME*)pTime, (FILETIME*)&InputTime ) ||
         !SystemTimeToFileTime( &ltime, (FILETIME *)&CurrentTime ) )
        return;

    /*
     * Get the number of seconds since specified time.
     */
    DiffTime = CalculateDiffTime( InputTime, CurrentTime );
    d_time = DiffTime.LowPart;

    /*
     * Calculate the days, hours, minutes, seconds since specified time.
     */
    pElapsedTime->days = (USHORT)(d_time / 86400L); // days since
    d_time = d_time % 86400L;                       // seconds => partial day
    pElapsedTime->hours = (USHORT)(d_time / 3600L); // hours since
    d_time  = d_time % 3600L;                       // seconds => partial hour
    pElapsedTime->minutes = (USHORT)(d_time / 60L); // minutes since
    pElapsedTime->seconds = (USHORT)(d_time % 60L); // seconds remaining

}  // end CalculateElapsedTime


/*******************************************************************************
 *
 *  CompareElapsedTime - Hydrix helper function
 *
 *      Determines the difference between two ELAPSEDTIME values.
 *
 *  ENTRY:
 *      pElapsedTime1 (input)
 *          Points to first ELAPSEDTIME
 *      pElapsedTime2 (input)
 *          Points to ELAPSEDTIME structure to save elapsed time.
 *      bCompareSeconds (input)
 *          TRUE to include the seconds member in comparison; false otherwise.
 *
 *  EXIT:
 *      < 1 if first time is less than second time
 *      0 if times are the same
 *      > 1 if first time is greater than second time
 *
 ******************************************************************************/

int WINAPI
CompareElapsedTime( ELAPSEDTIME *pElapsedTime1,
                    ELAPSEDTIME *pElapsedTime2,
                    BOOL bCompareSeconds )
{
    int result;

    if ( !(result = pElapsedTime1->days - pElapsedTime2->days)       &&
         !(result = pElapsedTime1->hours - pElapsedTime2->hours)     &&
         !(result = pElapsedTime1->minutes - pElapsedTime2->minutes) &&
         (!bCompareSeconds ||
          !(result = pElapsedTime1->seconds - pElapsedTime2->seconds) ) )
        return(0);
    else
        return(result);

}  // end CompareElapsedTime


/*******************************************************************************
 *
 *  ElapsedTimeString - Hydrix helper function
 *
 *      Converts the specified ELAPSEDTIME into a string of the form
 *      "ddd+hh:mm:ss" or, optionally "ddd+hh:mm" (suppress seconds).
 *
 *  ENTRY:
 *      pElapsedTime (input)
 *          Points to ELAPSEDTIME structure to convert to string.
 *      bIncludeSeconds (input)
 *          If TRUE, will include seconds in string; FALSE will exclude.
 *      pString (output)
 *          Points to location to store elapsed time string.
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
ElapsedTimeString( ELAPSEDTIME *pElapsedTime,
                   BOOL bIncludeSeconds,
                   LPTSTR pString )
{
    if ( bIncludeSeconds ) {

        if ( pElapsedTime->days > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u+%02u:%02u:%02u"),
                       pElapsedTime->days,
                       pElapsedTime->hours,
                       pElapsedTime->minutes,
                       pElapsedTime->seconds );
        else if ( pElapsedTime->hours > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u:%02u:%02u"),
                       pElapsedTime->hours,
                       pElapsedTime->minutes,
                       pElapsedTime->seconds );
        else if ( pElapsedTime->minutes > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u:%02u"),
                       pElapsedTime->minutes,
                       pElapsedTime->seconds );
        else if ( pElapsedTime->seconds > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u"),
                       pElapsedTime->seconds );
        else
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT(".") );
    }
    else {

        if ( pElapsedTime->days > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u+%02u:%02u"),
                       pElapsedTime->days,
                       pElapsedTime->hours,
                       pElapsedTime->minutes );
        else if ( pElapsedTime->hours > 0 )
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u:%02u"),
                       pElapsedTime->hours,
                       pElapsedTime->minutes );
        else if ( pElapsedTime->minutes > 0 )
            wnsprintf( pString,
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT("%u"),
                       pElapsedTime->minutes );
        else
            wnsprintf( pString, 
                       MAX_ELAPSED_TIME_LENGTH,
                       TEXT(".") );
    }

}  // end ElapsedTimeString


/*******************************************************************************
 *
 *  DateTimeString - Hydrix helper function
 *
 *      Converts the specified LARGE_INTEGER time value into a date/time string
 *      of the form "mm/dd/yy hh:mm".
 *
 *  ENTRY:
 *      pTime (input)
 *          Points to LARGE_INTEGER of time to convert to string.
 *      pString (output)
 *          Points string to store converted date/time into.
 *
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
DateTimeString( LARGE_INTEGER *pTime,
                LPTSTR pString )
{
    FILETIME LocalTime;
    SYSTEMTIME stime;
    LPTSTR lpTimeStr;
    int nLen;

    if ( FileTimeToLocalFileTime( (FILETIME *)pTime, &LocalTime ) &&
         FileTimeToSystemTime( &LocalTime, &stime ) ) {

        //Get Date Format
        nLen = GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_SHORTDATE,
                    &stime,
                    NULL,
                    NULL,
                    0);
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if(NULL == lpTimeStr)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            wcscpy(pString, L"");
            return;
        }
        nLen = GetDateFormat(
                    LOCALE_USER_DEFAULT,
                    DATE_SHORTDATE,
                    &stime,
                    NULL,
                    lpTimeStr,
                    nLen);
        wcscpy(pString, lpTimeStr);
        wcscat(pString, L" ");
        GlobalFree(lpTimeStr);

        //Get Time Format
        nLen = GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    TIME_NOSECONDS,
                    &stime,
                    NULL,
                    NULL,
                    0);
        lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
        if(NULL == lpTimeStr)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            wcscpy(pString, L"");
            return;
        }
        nLen = GetTimeFormat(
                    LOCALE_USER_DEFAULT,
                    TIME_NOSECONDS,
                    &stime,
                    NULL,
                    lpTimeStr,
                    nLen);
        wcscat(pString, lpTimeStr);
        GlobalFree(lpTimeStr);
    }
    else
        LoadString( GetModuleHandle( UTILDLL_NAME ),
                    IDS_UNKNOWN, pString, lengthof(pString) );

}  // end DateTimeString


/*******************************************************************************
 *
 *  CurrentDateTimeString - Hydrix helper function
 *
 *      Converts the current system time into a date/time string of the form
 *      "mm/dd/yy hh:mm".
 *
 *  ENTRY:
 *      pString (output)
 *          Points string to store converted date/time into.
 *  EXIT:
 *
 ******************************************************************************/

void WINAPI
CurrentDateTimeString( LPTSTR pString )
{
    SYSTEMTIME stime;
    LPTSTR lpTimeStr;
    int nLen;

    GetLocalTime(&stime);
    //Get DateFormat
    nLen = GetDateFormat(
                LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                &stime,
                NULL,
                NULL,
                0);
    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
    if(NULL == lpTimeStr)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        wcscpy(pString, L"");
        return;
    }
    nLen = GetDateFormat(
                   LOCALE_USER_DEFAULT,
                DATE_SHORTDATE,
                &stime,
                NULL,
                lpTimeStr,
                nLen);
    wcscpy(pString, lpTimeStr);
    wcscat(pString, L" ");
    GlobalFree(lpTimeStr);

    //Get Time Format
    nLen = GetTimeFormat(
                   LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                &stime,
                NULL,
                NULL,
                0);
    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));
    if(NULL == lpTimeStr)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        wcscpy(pString, L"");
        return;
    }
    nLen = GetTimeFormat(
                   LOCALE_USER_DEFAULT,
                TIME_NOSECONDS,
                &stime,
                NULL,
                lpTimeStr,
                nLen);
    wcscat(pString, lpTimeStr);
    GlobalFree(lpTimeStr);

}  // end CurrentDateTimeString


/*******************************************************************************
 *
 *  CalculateDiffTime - Hydrix helper function
 *
 *  Calculate the time difference between two LARGE_INTEGER time values.
 *
 * ENTRY:
 *    FirstTime (input)
 *       The first (lower) time value.
 *    SecondTime (input)
 *       The second (higher) time value.
 *
 * EXIT:
 *    LARGE_INTEGER - the time difference
 *
 ******************************************************************************/

LARGE_INTEGER WINAPI
CalculateDiffTime( LARGE_INTEGER FirstTime, LARGE_INTEGER SecondTime )
{
    LARGE_INTEGER DiffTime;

    DiffTime = RtlLargeIntegerSubtract( SecondTime, FirstTime );
    DiffTime = RtlExtendedLargeIntegerDivide( DiffTime, 10000000, NULL );
    return(DiffTime);

}  // end CalculateDiffTime


/*******************************************************************************
 *
 *  EnumerateMultiUserServers - Hydrix helper function
 *
 *      Enumerate the Hydrix servers on the network by Domain
 *
 *  ENTRY:
 *      pDomain (input)
 *          Specifies the domain to enumerate; NULL for current domain.
 *
 *  EXIT:
 *      (LPTSTR) Points to LocalAlloced buffer containing results of the
 *               enumeration, in multi-string format, if sucessful; NULL if
 *               error.  The caller must perform a LocalFree of this buffer
 *               when done.  If error (NULL), the error code is set for
 *               retrieval by GetLastError();
 *
 ******************************************************************************/

LPWSTR WINAPI
EnumerateMultiUserServers( LPWSTR pDomain )

{
    PSERVER_INFO_101 pInfo = NULL;
    DWORD dwByteCount, dwIndex, TotalEntries;
    DWORD AvailCount = 0;
    LPWSTR pTemp, pBuffer = NULL;

    /*
     * Enumerate all WF servers on the specified domain.
     */
    if ( NetServerEnum ( NULL,
                         101,
                         (LPBYTE *)&pInfo,
                         (DWORD) -1,
                         &AvailCount,
                         &TotalEntries,
                         SV_TYPE_TERMINALSERVER,
                         pDomain,
                         NULL ) ||
         !AvailCount )
        goto done;

    /*
     * Traverse list and calculate the total byte count for list of
     * servers that will be returned.
     */
    for ( dwByteCount = dwIndex = 0; dwIndex < AvailCount; dwIndex++ ) {

        dwByteCount += (wcslen(pInfo[dwIndex].sv101_name) + 1) * 2;
    }
    dwByteCount += 2;   // for ending null

    /*
     * Allocate memory.
     */
    if ( (pBuffer = LocalAlloc(LPTR, dwByteCount)) == NULL ) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    /*
     * Traverse list again and copy servers to buffer.
     */
    for ( pTemp = pBuffer, dwIndex = 0; dwIndex < AvailCount; dwIndex++ ) {

        wcscpy(pTemp, pInfo[dwIndex].sv101_name);
        pTemp += (wcslen(pInfo[dwIndex].sv101_name) + 1);
    }
    *pTemp = L'\0';     // ending null

    done:
    if ( AvailCount && pInfo )
        NetApiBufferFree( pInfo );

    return(pBuffer);

}  // end EnumerateMultiUserServers


/******************************************************************************
 *
 *      _UserInGroup
 *          Internal function, determines if a user is a member of any of the
 *          groups passed in
 *
 *  ENTRY:
 *      pwszUsername (IN) - Username to test group membership of
 *
 *      pwszDomain (IN)   - Domain of the user passed in
 *
 *      pwszGroup (IN)    - String array of all the allowed groups
 *
 *  EXIT:
 *      Returns BOOLEAN value if user is a member of one of the groups
 *  HISTORY:
 *
 *
 *****************************************************************************/
BOOL _UserInGroup( LPWSTR pwszUsername, LPWSTR pwszDomain, LPWSTR pwszGroup )
{
    DWORD                EntriesRead;
    DWORD                EntriesLeft;
    NET_API_STATUS       rc;
    PGROUP_USERS_INFO_0  pszGroups;
    ULONG                i;
    PWCHAR               pwcUser;
    WCHAR                szBuf[MAX_PATH];
    LPWKSTA_INFO_100     pWorkstationInfo = NULL;
    WCHAR                szDomainController[50];
#if DBG
    DbgPrint( "MSGINA: UserInGroup: look(%S\\%S)  group(%S)\n",
              pwszDomain, pwszUsername, pwszGroup );
#endif
    // This call will return the domain of the computer, not the domain of the user
    if (( NetWkstaGetInfo( NULL,
                           100,
                           (LPBYTE *)&pWorkstationInfo )) == NERR_Success) {
        if( !CtxGetAnyDCName( NULL,
                              pWorkstationInfo->wki100_langroup,
                              szDomainController ) ){
            NetApiBufferFree((LPVOID)pWorkstationInfo);
            return( FALSE );
        }
    }
    else {
        return (FALSE);
    }

    if ( wcscmp( pWorkstationInfo->wki100_langroup, pwszDomain ) != 0 ) {
        // user is from a different domain than the machine (trusted domain)
        // need to change username to reflect the domain
        wcscpy( szBuf, pwszDomain );
        wcscat( szBuf, L"\\" );
        wcscat( szBuf, pwszUsername );
        pwcUser = szBuf;
    }
    else {
        pwcUser = pwszUsername;
    }

    rc = NetUserGetLocalGroups( szDomainController,
                                pwcUser,
                                0, // level
                                LG_INCLUDE_INDIRECT, // flags
                                (LPBYTE*)&pszGroups,
                                MAX_BUFFER,
                                &EntriesRead,
                                &EntriesLeft );

    if( pWorkstationInfo != NULL )
        NetApiBufferFree((LPVOID)pWorkstationInfo);

    if ( rc != NERR_Success ) {
        return( FALSE );
    }

    for ( i=0; i < EntriesRead; i++ ) {
        if ( wcscmp( pszGroups[i].grui0_name, pwszGroup ) == 0 ) {
            NetApiBufferFree( pszGroups );
            pszGroups = NULL;
            return( TRUE );
        }
    }

    NetApiBufferFree( pszGroups );
    pszGroups = NULL;
    return(FALSE);

}


/******************************************************************************
 *
 *  CtxGetAnyDCName
 *      Function to find a any DC of a specified domain.  The call
 *      NetGetAnyDCName does not work as needed in all occasions.
 *      ie.  Trusted domains and the current server being a DC.
 *
 *  ENTRY:
 *      pServer (IN)  -  Server on which to run the call (RPC)
 *
 *      pDomain (IN)  -  Domain you are inquring about, does not need to be
 *                          current domain
 *
 *      pBuffer (OUT) -  Pointer to a string containg a DC name, buffer must
 *                       be passed in.
 *  EXIT:
 *      BOOL  Success
 *
 *  HISTORY:
 *
 *
 *****************************************************************************/

BOOL
CtxGetAnyDCName ( PWCHAR pServer, PWCHAR pDomain, PWCHAR pBuffer )
{

    PWCHAR               pDomainController = NULL;
    PWCHAR               pLocalDomainDC    = NULL;
    SERVER_INFO_101*     ServerBuf         = NULL;
    BOOLEAN              rc = TRUE;
    BOOLEAN              bFoundDC = FALSE;

    // This call will return the domain of the computer, not the domain of the user
        if (( NetGetAnyDCName(NULL,
                              pDomain,
                              (LPBYTE *)&pDomainController)) != NERR_Success) {
//
// NetGetAnyDCName doesn't work in two situations
//  1.  If the domain is a trusted domain, it must be run from a DC.  So we find our local
//           DC and have it run getanydcname for us.
//  2.  If we are a DC it will fail.  So a second check is made to see
//         if in fact we are a DC or not
//

            // find a local DC in which to RPC to
            if( NetGetAnyDCName( NULL,
                                 NULL,
                                 (LPBYTE *) &pLocalDomainDC ) == NERR_Success ) {
                // Make the call as an RPC and pass it the Domain name
                if( NetGetAnyDCName( pLocalDomainDC,
                                          pDomain,
                                          (LPBYTE *) &pDomainController ) == NERR_Success){
                    bFoundDC = TRUE;
                }
            }

            // if it wasn't a trusted domain, maybe we are a domain controller
            if( !bFoundDC ) {
                if( NetServerGetInfo( NULL,
                                      101,
                                      (LPBYTE*)&ServerBuf ) == NERR_Success ) {
                    if( ServerBuf->sv101_type & (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL) ) {
                        pDomainController = NULL;
                    }
                    else {
                       rc = FALSE;
                       goto done;
                    }
                }
                else {
                    rc = FALSE;
                    goto done;
                }
            }
        }
    if( pDomainController )
        wcscpy( pBuffer, pDomainController);
    else
        *pBuffer = '\0';
done:

    if( pLocalDomainDC )
        NetApiBufferFree( pLocalDomainDC );
    if( pDomainController )
        NetApiBufferFree( pDomainController );
    if( ServerBuf )
        NetApiBufferFree( ServerBuf );

    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\expand.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   EXPAND.C
*
*   
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include "utilsubres.h" // resources refrenced in this file.

void ErrorOutFromResource(UINT uiStringResource, ...);

#define INCL_DOSPROCESS
#define INCL_DOSFILEMGR
#define INCL_DOSERRORS
#define INCL_ERRORS
#ifdef DOS
#define INCL_NOXLATE_DOS16
#endif

#include "expand.h"

#define TRUE 1
#define FALSE 0

#define SUCCESS 0       /* function call successful */
#define FAILURE (-1)    /* function call had a failure */

#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */

#define uint unsigned int
#define ulong unsigned long
#define ushort unsigned short

/*
 * struct search_rec is used to form a linked list of path specifications
 * that are still left to be searched.
 */
struct search_rec {
   struct search_rec *next;
   WCHAR *dir_spec;         /* path spec up until component w/ wildcard */
   WCHAR *wild_spec;        /* component containing wildcard char(s) */
   WCHAR *remain;           /* remainder of name after wildcard component */
   ushort attr;
   };

/*
 * global variables
 */
static struct search_rec *search_head = NULL;

/*
 * prototypes of functions referenced
 */
split_path(WCHAR *, WCHAR *, WCHAR *, WCHAR *);
add_search_list(WCHAR *, WCHAR *, WCHAR *, ushort);
add_arg_to_list(WCHAR *, ARGS *);
do_tree(struct search_rec *, ushort, ARGS *);
file_exists(WCHAR *);


/******************************************************************************
*
* args_init()
*
*   Initialize the ARGS struct passed as an argument.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*       maxargs = max number of args expected
*
*   EXIT:
*
******************************************************************************/

void
args_init( ARGS *argp,
           int maxargs )
{

   argp->argc = 0;
   argp->argv = argp->argvp = NULL;
   argp->maxargc = argp->maxargs = maxargs;
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
* args_trunc()
*
*   Truncate the memory used by the ARGS struct
*   so that unused memory is freed.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_trunc( ARGS *argp )
{

   /*
    * call realloc to shrink size of argv array, set maxargc = argc
    * to indicate no more room in argv array.
    */
   realloc(argp->argv, (argp->argc + 1) * sizeof(WCHAR*));
   argp->maxargc = argp->argc;

   /*
    * call realloc to shrink size of argument string buffer, set bufend
    * pointer to current buf pointer to indicate buf is full.
    */
   realloc(argp->buf, (size_t)(argp->bufptr - argp->buf));
   argp->bufend = argp->bufptr - 1;
}


/******************************************************************************
*
* args_reset()
*
*   Re-initialize the ARGS struct passed as an argument,
*   free memory if possible.
*
*   ENTRY:
*       argp = pointer to ARGS struct
*
*   EXIT:
*
******************************************************************************/

void
args_reset( ARGS *argp )
{

   /*
    * if there is an argv array, but it has been truncated, then free
    * the array so a new one will be allocated later.
    */
   if (argp->argv && argp->maxargc != argp->maxargs) {
      free(argp->argv);
      argp->argv = NULL;
   }
   argp->argc = 0;
   argp->argvp = argp->argv;
   argp->maxargc = argp->maxargs;

   /*
    * if there is an argument buffer, but it has been truncated, then
    * free the buffer so a new one will be allocated later.
    */
   if (argp->buf && argp->bufend != argp->buf + MAX_ARG_ALLOC - 1) {
      free(argp->buf);
      argp->buf = argp->bufend = NULL;
   }
   argp->bufptr = argp->buf;
}


/******************************************************************************
*
* args_free()
*
*   Will free the memory allocated for
*   argument storage by all preceeding calls to expand_path().
*   Args_init() must be called before reusing this ARGS structure.
*
*   ENTRY:
*       argp = pointer to ARGSW struct
*
*   EXIT:
*
******************************************************************************/

void
args_free( ARGS *argp )
{

   if (argp->argv != NULL)
      free(argp->argv);
   argp->argv = argp->argvp = NULL;

   if (argp->buf != NULL)
      free(argp->buf);
   argp->buf = argp->bufptr = argp->bufend = NULL;
}


/******************************************************************************
*
* expand_path()
*
*   This routine will expand the specified path string into pathnames
*   that match.  The matching pathnames will be added to the specified
*   argv array and the specified argc count will be incremented to
*   reflect the number of pathnames added.
*
*   This routine will expand filename arguments in Unix fashion
*   (i.e. '[..]' is supported, '?' and '*' are allowed anywhere in the
*   pathname, even in the directory part of the name, and the
*   name/extension separator '.' is not treated special but is just
*   considered part of the filename).
*
*   Storage for the pathname strings will be obtained via malloc.
*   This space may later be free'd with a call to args_free();
*
*   ENTRY:
*       path     Pathname string to be expanded.
*       attr     Attribute bits of files to include
*                   (regular, directory, hidden, system).
*                   -1 = return the specified pathname string unmodified
*                        in the argv array.
*       argp     Pointer to an ARGSW struct containing fields to be used/
*                updated by expand_path.  The ARGS struct must be initialized
*                by calling args_init() before calling expand_path().
*
*    EXIT:
*       TRUE  -- indicates at least 1 pathname was found matching
*                the pathname string specified.
*       FALSE -- indicates no matching pathnames were found.  The specified
*                pathname string is returned unmodified in the argv array.
*
******************************************************************************/

int
expand_path( WCHAR *path,
             ushort attr,
             ARGS *argp )
{
   int argc, add_count, rc, i, j, k;
   WCHAR **argv;
   WCHAR dirname[128], wild[128], remain[128];
   struct search_rec *save, *q;

#ifdef DEBUG
   printf("expand_path: path=%s attr=%d\n", path, attr);
#endif

   argc = argp->argc;
   argv = argp->argvp;
   if ( attr != -1 && split_path(path, dirname, wild, remain)) {
      add_search_list(dirname, wild, remain, attr);
      while (search_head) {
         /*
          * save the next portion and allow new directories to be
          * added to the head.
          */
         save = search_head->next;
         search_head->next = NULL;

         /*
          * perform the do_tree operation on the current path
          */
         rc = do_tree(search_head, attr, argp);

         /*
          * restore the saved list at the end of the head list
          */
         if ( save ) {
            q = search_head;
            while ( q->next ) {
               q = q->next;
            }
            q->next = save;
         }

         /*
          * move to the next path in the list and free the memory used
          * by the link we are done with
          */
         do {
            q = search_head;
            search_head = search_head->next;
            free( q->dir_spec );
            free( q->wild_spec );
            free( q->remain );
            free( q );
         } while (rc==FAILURE && search_head);
      }
   }

/*
 * If no filenames were expanded, just put the original name
 * into the buffer and indicate no names were expanded.
 */
   if (argc == argp->argc) {
      add_arg_to_list(path, argp);
      return(FALSE);
   }

/*
 * Sort the names just added
 */
   if ( argv == NULL )
      argv = argp->argv;
   add_count = argp->argc - argc;
   for (i=add_count-1; i>0; --i) {
      uint swap = FALSE;
      for (j=0; j<i; ++j) {
         if (!argv[j] || !argv[j+1]) {
            ErrorOutFromResource(IDS_INTERNAL_ERROR_1);
            //fprintf(stderr,"internal error 1\n");
         }
         for (k=0; k<128; ++k) {
            if (argv[j][k] < argv[j+1][k]) {
               break;
            } else if (argv[j][k] > argv[j+1][k]) {
               WCHAR *temp;
               swap = TRUE;
               temp = argv[j];
               argv[j] = argv[j+1];
               argv[j+1] = temp;
               break;
            }
         }
         if (k>125) {
            ErrorOutFromResource(IDS_INTERNAL_ERROR_2);
            // fprintf(stderr,"internal error 2\n");
         }
      }
      if (!swap) {
         break;
      }
   }
   return(TRUE);
}


/******************************************************************************
*
* add_search_list()
*
*    Adds a record to the global search list, search_head.
*
******************************************************************************/

static
add_search_list(
    WCHAR *dir_spec,        /* the dir to be added to the list */
    WCHAR *wild_spec,       /* the file to be added to the list */
    WCHAR *remain_spec,     /* remaining portion of pathname */
    ushort attr )
{
   struct search_rec *new, /* pointer to the new link */
                     *q;   /* used to traverse the linked list */

#ifdef DEBUG
   wprintf(L"add_search_list: dir=%s: file=%s: rem=%s:\n", dir_spec, wild_spec, remain_spec);
#endif

/*
 * allocate the new link.  make sure that it is initialized to zeros.
 */
   new = malloc(sizeof(struct search_rec));

   if (!new) {
      ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_MALLOC);
      // fprintf(stderr, "add_search_list: not enough memory (malloc)");
      return FAILURE;
   }

   memset(new, 0, sizeof(struct search_rec));

/*
 * allocate memory for and copy the dir spec and file spec.
 */
   if (dir_spec)
   {
       new->dir_spec = _wcsdup(dir_spec);
       if( new->dir_spec == NULL )
       {
           ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP1);
            // fprintf(stderr, "add_search_list: not enough memory (strdup1)");
            return FAILURE;
       }

       _wcslwr( new->dir_spec );
   }
   if (wild_spec)
   {
      new->wild_spec = _wcsdup(wild_spec);
      if (new->wild_spec == NULL )
      {
          ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP2);
          // fprintf(stderr, "add_search_list: not enough memory (strdup2)");
          return FAILURE;
      }

      _wcslwr( new->wild_spec );
      
   }
   if (remain_spec)
   {
       new->remain = _wcsdup(remain_spec);
       if( new->remain == NULL )
       {
           ErrorOutFromResource(IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP3);
            // fprintf(stderr, "add_search_list: not enough memory (strdup3)");
            return FAILURE;
       }

       _wcslwr( new->remain );

   }

/*
 * store file attributes
 */
   if (remain_spec)
      new->attr = attr | SUBDIR;
   else
      new->attr = attr;

/*
 * add the new link at the end of the list
 */
   if (!search_head) {
      search_head = new;
   } else {
      q = search_head;
      while (q->next) {
         q = q->next;
      }
      q->next = new;
   }

   return SUCCESS;
}


/******************************************************************************
*
* add_arg_to_list()
*
*   This routine adds the specified argument string to the argv array,
*   and increments the argv pointer and argc counter.
*   If necessary, memory for the argument string is allocated.
*
*   EXIT:
*       SUCCESS -- if argument added successfully
*       FAILURE -- if argument could not be added
*             (indicates too many args or out of memory for argument string)
*
******************************************************************************/
static int
add_arg_to_list( WCHAR *arg_string,
                 ARGS *argp )
{
   size_t len;

#ifdef DEBUG
   wprintf(L"add_arg_to_list: arg_string=%s:, argc=%d, argvp=%x, maxargs=%d\n",
           arg_string,argp->argc,argp->argvp,argp->maxargc);
#endif
   if (argp->argc >= argp->maxargc) {
      ErrorOutFromResource(IDS_TOO_MANY_ARGUMENTS);
      // fprintf(stderr,"add_arg_to_list: too many arguments\n");
      return FAILURE;
   }
   if (!argp->argv) {
      argp->argv = malloc(sizeof(WCHAR *) * (argp->maxargs+1));
      if (argp->argv) {
         argp->argc = 0;
         argp->argvp = argp->argv;
         argp->maxargc = argp->maxargs;
      } else {
         ErrorOutFromResource(IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY);
         // fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   if (!argp->buf) {
      argp->buf = malloc(MAX_ARG_ALLOC);
      if (argp->buf) {
         argp->bufptr = argp->buf;
         argp->bufend = argp->buf + MAX_ARG_ALLOC - 1;
      } else {
         ErrorOutFromResource(IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY);
         // fprintf(stderr,"add_arg_to_list: not enough memory\n");
         return FAILURE;
      }
   }
   len = wcslen(arg_string) + 1;
   if (argp->bufptr + len > argp->bufend) {
      ErrorOutFromResource(IDS_ARGS_TO_LIST_ARG_BUFFER_SMALL);
      // fprintf(stderr,"add_arg_to_list: argument buffer too small\n");
      return FAILURE;
   }
   wcscpy(argp->bufptr, arg_string);
   *(argp->argvp) = argp->bufptr;
   argp->bufptr += len;
   ++argp->argc;
   ++argp->argvp;
   *(argp->argvp) = NULL;
   return SUCCESS;
}


/******************************************************************************
*
* do_tree()
*
******************************************************************************/

static
do_tree( struct search_rec *searchp,
         ushort attr,
         ARGS *argp )
{
   int rc;                 /* return code from Dos calls */
   WIN32_FIND_DATA result; /* the structure returned from FindFirst/Next */
   ushort count = 1;       /* number of files to look for at one time */
   HANDLE handle;   /* the dir handle used by FindFirst/Next */
   WCHAR full_path[128];    /* used to hold the path/file combination */
   WCHAR dirname[128], wild[128], remain[128];
   WCHAR *fptr;             /* pointer to file portion of full_path */
   ULONG Status;

#ifdef DEBUG
   wprintf(L"do_tree: dirname=%s:\n", searchp->dir_spec);
#endif

   /*
    * build up directory part of path and save a pointer to the file portion
    */
   wcscpy(full_path, searchp->dir_spec);
   fptr = full_path + wcslen(searchp->dir_spec);
   wcscpy(fptr, L"*.*");

   handle = FindFirstFile ( full_path,                  /* files to find */
			&result
		       );

   if(handle == INVALID_HANDLE_VALUE){
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES) {
           // no files match
	   return(SUCCESS);
       }
       return(FAILURE);
   }

   rc = TRUE;
   while (rc) {
      /*
       * do not do anything for the "." and ".." entries
       */
      if (wcscmp(result.cFileName, L".") == 0 ||
         wcscmp(result.cFileName, L"..") == 0) {
         rc = FindNextFile( handle, &result );
         continue;
      }

      /*
       * fully qualify the found file
       */
      wcscpy(fptr, _wcslwr(result.cFileName));
      if (searchp->remain)
         wcscat(full_path, searchp->remain);

      /*
       * see if current wild_spec matches FindFirst/Next file
       */
      if (unix_match(searchp->wild_spec, result.cFileName)) {
         if (searchp->remain && split_path(full_path, dirname, wild, remain)) {
            if (result.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY &&
		file_exists(dirname))
               add_search_list(dirname, wild, remain, attr);
         } else if (file_exists(full_path)) {
            rc = add_arg_to_list(full_path, argp);
            if (rc != SUCCESS)
               break;
         }
      }

      /*
       * find the next file
       */
      rc = FindNextFile( handle, &result );
   }

   /*
    * if no more files to find then reset the error code back to successful.
    */

   if(!rc) {
       Status = GetLastError();
       if(Status == ERROR_NO_MORE_FILES)
	   rc = SUCCESS;
   }

   return rc;
}


/******************************************************************************
*
* split_path()
*
*   This routine splits the specified pathname into 3 parts, any of which
*   may be null; 1) the pathname from the beginning up to but not including
*   the first component containing a wildcard character, 2) the component
*   containing the wildcard, and 3) the remainder of the path string after
*   the component containing the wildcard.
*
*   Examples:
*      Original path              dir            file     remain
*      "c:\mydir\dir??\*.c"       "c:\mydir\"    "dir??"  "\*.c"
*      "*\abc.def"                ""             "*"      "\abc.def"
*      "mydir\*.c"                "mydir\"       "*.c"    ""
*
*   EXIT:
*       TRUE  -- if the pathname could be split
*       FALSE -- otherwise (i.e. pathname did not contain any wildcards)
*
******************************************************************************/

static int
split_path( WCHAR *path,
            WCHAR *dir,
            WCHAR *file,
            WCHAR *remain )
{
   WCHAR *cp, *end_dir, *end_wild = NULL;

#ifdef DEBUG
   wprintf("split_path: path=%s:\n", path);
#endif
   for (cp=end_dir=path; *cp!=L'\0'; ) {
      if (*cp==L'\\' || *cp==L'/' || *cp==L':') {
         ++cp;
         while (*cp==L'\\' || *cp==L'/' ) ++cp;
         end_dir = cp;
      } else if (*cp==L'*' || *cp==L'?' || *cp==L'[') {
         ++cp;
         while (*cp!=L'\\' && *cp!=L'/' && *cp!=L'\0') ++cp;
         end_wild = cp;
         break;
      } else {
         ++cp;
      }
   }
   if (!end_wild)
      return(FALSE);

   for (cp=path; cp<end_dir; ++cp, ++dir)
      *dir = *cp;
   *dir = L'\0';
   for (cp=end_dir; cp<end_wild; ++cp, ++file)
      *file = *cp;
   *file = L'\0';
   wcscpy(remain, cp);
#ifdef DEBUG
   wprintf("split_path: dir=%s: file=%s: remain=%s:\n", dir, file, remain);
#endif

   return(TRUE);
}


/******************************************************************************
*
* file_existsW()
*
*   Returns TRUE if specified file exists, otherwise returns FALSE.
*
******************************************************************************/

static int
file_exists( WCHAR *path )
{
   size_t len;
   WCHAR path2[MAX_PATH];
   WCHAR ch;
   ULONG Result;

   if ( (path == NULL) || (wcslen(path) > MAX_PATH) )
       return FALSE;

   lstrcpyn(path2, path, MAX_PATH);
   len = wcslen(path2);
   while ((ch=path2[--len]) == L'\\' || ch == L'/' ) path2[len] = L'\0';
   
   Result = GetFileAttributes(path2);
   if(Result == 0xFFFFFFFF) {
       return(FALSE);
   }
   return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\helpers.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  HELPERS.C
*
*  Various helper functions.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//#include <ntddvdeo.h>
#include <ntddkbd.h>
#include <ntddmou.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>

#include <winstaw.h>
#include <utilsub.h>
#include <tchar.h>

#include "utilsubres.h" // resources refrenced in this file.


#define PERCENT TEXT('%')
#define NULLC TEXT('\0')
#define MAXCBMSGBUFFER 2048
TCHAR MsgBuf[MAXCBMSGBUFFER];
HANDLE NtDllHandle = NULL;

TCHAR *
mystrchr(TCHAR const *string, int c);


/* makarp, #259849
   we cannot put an rc file in this file.
   so we need to keep all the string resources referenced in this file in
   utildll.dll.
*/

/* this function returns the string resource from utildll.dll */
BOOL GetResourceStringFromUtilDll(UINT uID, LPTSTR szBuffer, int iBufferSize)
{
    HINSTANCE hUtilDll = LoadLibrary(TEXT("utildll.dll"));
    if (hUtilDll)
    {
        int iReturn = LoadString(hUtilDll, uID, szBuffer, iBufferSize);
        int iLastError = GetLastError();
        FreeLibrary( hUtilDll );

        if ( iReturn != 0 && iReturn < iBufferSize)
        {
            // we have got the string
            return TRUE;

        }
        else if (iReturn == 0)
        {
            _ftprintf( stderr, _T("GetResourceStringFromUtilDll: LoadString failed, Error %ld\n"), iLastError);
            return FALSE;
        }
        else
        {
            // we have provided insufficient buffer.
            _ftprintf(stderr, _T("GetResourceStringFromUtilDll: Insufficient buffer for resource string"));
            return FALSE;
        }

    }
    else
    {
        _ftprintf(stderr, _T("GetResourceStringFromUtilDll: LoadLibrary failed for utildll.dll, %ld"), GetLastError());
        return FALSE;
    }
}

/* this function is used internally.
 it prints an error message on stderr
 its like ErrorPrintf except it looks for
 the resource into utildll.dll
 This function accepts the  arguments in WCHAR.
*/

void ErrorOutFromResource(UINT uiStringResource, ...)
{

    WCHAR szBufferString[512];
    WCHAR szBufferMessage[1024];

    va_list args;
    va_start( args, uiStringResource);

    if (GetResourceStringFromUtilDll(uiStringResource, szBufferString, 512))
    {
        vswprintf( szBufferMessage, szBufferString, args );
        My_fwprintf( stderr, szBufferMessage);
    }
    else
    {
        fwprintf( stderr, L"ErrorOutFromResource:GetResourceStringFromUtilDll failed, Error %ld\n", GetLastError());
        PutStdErr( GetLastError(), 0 );
    }

    va_end(args);
}



int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist);

/*******************************************************************************
 *
 *  CalculateCrc16
 *
 *      Calculates a 16-bit CRC of the specified buffer.
 *
 *  ENTRY:
 *      pBuffer (input)
 *          Points to buffer to calculate CRC for.
 *      length (input)
 *          Length in bytes of the buffer.
 *
 *  EXIT:
 *      (USHORT)
 *          The 16-bit CRC of the buffer.
 *
 ******************************************************************************/

/*
 * updcrc macro derived from article Copyright (C) 1986 Stephen Satchell.
 *  NOTE: First argument must be in range 0 to 255.
 *        Second argument is referenced twice.
 *
 * Programmers may incorporate any or all code into their programs,
 * giving proper credit within the source. Publication of the
 * source routines is permitted so long as proper credit is given
 * to Stephen Satchell, Satchell Evaluations and Chuck Forsberg,
 * Omen Technology.
 */

#define updcrc(cp, crc) ( crctab[((crc >> 8) & 255)] ^ (crc << 8) ^ cp)


/* crctab calculated by Mark G. Mendel, Network Systems Corporation */
unsigned short crctab[256] = {
    0x0000,  0x1021,  0x2042,  0x3063,  0x4084,  0x50a5,  0x60c6,  0x70e7,
    0x8108,  0x9129,  0xa14a,  0xb16b,  0xc18c,  0xd1ad,  0xe1ce,  0xf1ef,
    0x1231,  0x0210,  0x3273,  0x2252,  0x52b5,  0x4294,  0x72f7,  0x62d6,
    0x9339,  0x8318,  0xb37b,  0xa35a,  0xd3bd,  0xc39c,  0xf3ff,  0xe3de,
    0x2462,  0x3443,  0x0420,  0x1401,  0x64e6,  0x74c7,  0x44a4,  0x5485,
    0xa56a,  0xb54b,  0x8528,  0x9509,  0xe5ee,  0xf5cf,  0xc5ac,  0xd58d,
    0x3653,  0x2672,  0x1611,  0x0630,  0x76d7,  0x66f6,  0x5695,  0x46b4,
    0xb75b,  0xa77a,  0x9719,  0x8738,  0xf7df,  0xe7fe,  0xd79d,  0xc7bc,
    0x48c4,  0x58e5,  0x6886,  0x78a7,  0x0840,  0x1861,  0x2802,  0x3823,
    0xc9cc,  0xd9ed,  0xe98e,  0xf9af,  0x8948,  0x9969,  0xa90a,  0xb92b,
    0x5af5,  0x4ad4,  0x7ab7,  0x6a96,  0x1a71,  0x0a50,  0x3a33,  0x2a12,
    0xdbfd,  0xcbdc,  0xfbbf,  0xeb9e,  0x9b79,  0x8b58,  0xbb3b,  0xab1a,
    0x6ca6,  0x7c87,  0x4ce4,  0x5cc5,  0x2c22,  0x3c03,  0x0c60,  0x1c41,
    0xedae,  0xfd8f,  0xcdec,  0xddcd,  0xad2a,  0xbd0b,  0x8d68,  0x9d49,
    0x7e97,  0x6eb6,  0x5ed5,  0x4ef4,  0x3e13,  0x2e32,  0x1e51,  0x0e70,
    0xff9f,  0xefbe,  0xdfdd,  0xcffc,  0xbf1b,  0xaf3a,  0x9f59,  0x8f78,
    0x9188,  0x81a9,  0xb1ca,  0xa1eb,  0xd10c,  0xc12d,  0xf14e,  0xe16f,
    0x1080,  0x00a1,  0x30c2,  0x20e3,  0x5004,  0x4025,  0x7046,  0x6067,
    0x83b9,  0x9398,  0xa3fb,  0xb3da,  0xc33d,  0xd31c,  0xe37f,  0xf35e,
    0x02b1,  0x1290,  0x22f3,  0x32d2,  0x4235,  0x5214,  0x6277,  0x7256,
    0xb5ea,  0xa5cb,  0x95a8,  0x8589,  0xf56e,  0xe54f,  0xd52c,  0xc50d,
    0x34e2,  0x24c3,  0x14a0,  0x0481,  0x7466,  0x6447,  0x5424,  0x4405,
    0xa7db,  0xb7fa,  0x8799,  0x97b8,  0xe75f,  0xf77e,  0xc71d,  0xd73c,
    0x26d3,  0x36f2,  0x0691,  0x16b0,  0x6657,  0x7676,  0x4615,  0x5634,
    0xd94c,  0xc96d,  0xf90e,  0xe92f,  0x99c8,  0x89e9,  0xb98a,  0xa9ab,
    0x5844,  0x4865,  0x7806,  0x6827,  0x18c0,  0x08e1,  0x3882,  0x28a3,
    0xcb7d,  0xdb5c,  0xeb3f,  0xfb1e,  0x8bf9,  0x9bd8,  0xabbb,  0xbb9a,
    0x4a75,  0x5a54,  0x6a37,  0x7a16,  0x0af1,  0x1ad0,  0x2ab3,  0x3a92,
    0xfd2e,  0xed0f,  0xdd6c,  0xcd4d,  0xbdaa,  0xad8b,  0x9de8,  0x8dc9,
    0x7c26,  0x6c07,  0x5c64,  0x4c45,  0x3ca2,  0x2c83,  0x1ce0,  0x0cc1,
    0xef1f,  0xff3e,  0xcf5d,  0xdf7c,  0xaf9b,  0xbfba,  0x8fd9,  0x9ff8,
    0x6e17,  0x7e36,  0x4e55,  0x5e74,  0x2e93,  0x3eb2,  0x0ed1,  0x1ef0
};

USHORT WINAPI
CalculateCrc16( PBYTE pBuffer,
                USHORT length )
{

   USHORT Crc = 0;
   USHORT Data;

   while ( length-- ) {
      Data = (USHORT) *pBuffer++;
      Crc = updcrc( Data, Crc );
   }

   return(Crc);

} /* CalculateCrc16() */


/*****************************************************************************
*
*  ExecProgram
*     Build a command line argument string and execute a program.
*
*  ENTRY:
*       pProgCall (input)
*           ptr to PROGRAMCALL structure with program to execute.
*       argc (input)
*           count of the command line arguments.
*       argv (input)
*           vector of strings containing the command line arguments.
*
*  EXIT:
*       (int)
*           0 for success; 1 for error.  An error message will have already
*           been output on error.
*
*****************************************************************************/

#define ARGS_LEN       512      // maximum # of characters on command line
                                // for CreateProcess() call.

INT WINAPI
ExecProgram( PPROGRAMCALL pProgCall,
             INT argc,
             WCHAR **argv )
{
    int count;
    WCHAR program[50];
    PWCHAR pCurrArg;
    STARTUPINFO StartInfo;
    PROCESS_INFORMATION ProcInfo;
    BOOL flag;
    DWORD Status;
    WCHAR wszFullPath[MAX_PATH]; //contains the full path name of the program
    WCHAR wszCmdLine[MAX_PATH + ARGS_LEN + 5]; //for the quoted string and NULL
    PWSTR pwstrFilePart;

    wcscpy(program, pProgCall->Program);
    //
    //Fix 330770 TS: Suspicious CreateProcess call using no program name might execute c:\program.exe	AdamO	02/28/2001
    //get the full path of the program
    //search in the same way as createprocess would
    //
    if (!SearchPath(NULL, program, NULL, MAX_PATH, wszFullPath, &pwstrFilePart)) {
        ErrorOutFromResource(IDS_TS_SYS_UTIL_NOT_FOUND, program);
        // fwprintf(stderr, L"Terminal Server System Utility %s Not Found\n", program);
        return(1);
    }

    //
    //create the command line args
    //
    wcscpy(wszCmdLine, L"\"");
    wcscat(wszCmdLine, wszFullPath);
    wcscat(wszCmdLine, L"\"");

    if (pProgCall->Args != NULL) {

        wcscat(wszCmdLine, L" ");
        
        if ( (wcslen(pProgCall->Args) + wcslen(wszCmdLine) + 3) > sizeof(wszCmdLine) / sizeof(WCHAR) ) {
        // IDS_MAX_CMDLINE_EXCEEDED
            ErrorOutFromResource(IDS_MAX_CMDLINE_EXCEEDED);
            // fwprintf(stderr, L"Maximum command line length exceeded\n");
            return(1);
        }
        
        wcscat(wszCmdLine, pProgCall->Args);
    }

    for (count = 0; count < argc; count++) {

        pCurrArg = argv[count];
        
        if ( (int)(wcslen(pCurrArg) + wcslen(wszCmdLine) + 3) > sizeof(wszCmdLine) / sizeof(WCHAR) ) {

        // IDS_MAX_CMDLINE_EXCEEDED
            ErrorOutFromResource(IDS_MAX_CMDLINE_EXCEEDED);
            // fwprintf(stderr, L"Maximum command line length exceeded\n");
            return(1);
        }
        wcscat(wszCmdLine, L" ");
        wcscat(wszCmdLine, pCurrArg);
    }

    /*
     * Setup the NT CreateProcess parameters
     */
    memset( &StartInfo, 0, sizeof(StartInfo) );
    StartInfo.cb = sizeof(STARTUPINFO);
    StartInfo.lpReserved = NULL;
    StartInfo.lpTitle = NULL; // Use the program name
    StartInfo.dwFlags = 0;  // no extra flags
    StartInfo.cbReserved2 = 0;
    StartInfo.lpReserved2 = NULL;

    
    flag = CreateProcess(wszFullPath, // full path of the program
                   wszCmdLine, // arguments
                   NULL, // lpsaProcess
                   NULL, // lpsaThread
                   TRUE, // Allow handles to be inherited
                   0,    // No additional creation flags
                   NULL, // inherit parent environment block
                   NULL, // inherit parent directory
                   &StartInfo,
                   &ProcInfo);

    if ( !flag ) {

        Status = GetLastError();
        if(Status == ERROR_FILE_NOT_FOUND) {
            ErrorOutFromResource(IDS_TS_SYS_UTIL_NOT_FOUND, program);
            // fwprintf(stderr, L"Terminal Server System Utility %s Not Found\n", program);
            return(1);

        } else if ( Status == ERROR_INVALID_NAME ) {

        ErrorOutFromResource(IDS_BAD_INTERNAL_PROGNAME, program, wszCmdLine);
            // fwprintf(stderr, L"Bad Internal Program Name :%s:, args :%s:\n", program, wszCmdLine);
            return(1);
        }

        ErrorOutFromResource(IDS_CREATEPROCESS_FAILED, Status);
        // fwprintf(stderr, L"CreateProcess Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Wait for the process to terminate
     */
    Status =  WaitForSingleObject(ProcInfo.hProcess, INFINITE);
    if ( Status == WAIT_FAILED ) {

        Status = GetLastError();
        ErrorOutFromResource(IDS_WAITFORSINGLEOBJECT_FAILED, Status);
        // fwprintf(stderr, L"WaitForSingle Object Failed, Status %u\n", Status);
        return(1);
    }

    /*
     * Close the process and thread handles
     */
    CloseHandle(ProcInfo.hThread);
    CloseHandle(ProcInfo.hProcess);
    return(0);

} /* ExecProgram() */


/*****************************************************************************
*
*  ProgramUsage
*     Output a standard 'usage' message for the given program.
*
*  ENTRY:
*       pProgramName (input)
*           Points to string of program's name.
*       pProgramCommands (input)
*           Points to an array of PROGRAMCALL structures defining the
*           valid commands for the program.  The last element in the array
*           will contain all 0 or NULL items.
*       fError (input)
*           If TRUE, will output message with fwprintf to stderr; otherwise,
*           will output message to stdout via wprintf.
*
*  EXIT:
*
*   Only commands not flagged as 'alias' commands will be output in the
*   usage message.
*
*****************************************************************************/

VOID WINAPI
ProgramUsage( LPCWSTR pProgramName,
              PPROGRAMCALL pProgramCommands,
              BOOLEAN fError )
{
    WCHAR        szUsage[83];  // 80 characters per line + newline chars & null
    PPROGRAMCALL pProg;
    BOOL         bFirst;
    size_t       i;
    size_t       namelen = wcslen(pProgramName);

    i = wsprintf(szUsage, L"%s {", pProgramName);
    for ( pProg = pProgramCommands->pFirst, bFirst = TRUE;
          pProg != NULL;
          pProg = pProg->pNext ) {

        if ( !pProg->fAlias ) {

            if ( (i + wcslen(pProg->Command) + (bFirst ? 1 : 3)) >= 80 ) {

                wcscat(szUsage, L"\n");

                if ( fError )
                    My_fwprintf(stderr, szUsage);
                else
                    My_wprintf(szUsage);

                bFirst = TRUE;
                for ( i=0; i < namelen; i++)
                    szUsage[i] = L' ';
            }

            i += wsprintf( &(szUsage[i]),
                           bFirst ? L" %s" : L" | %s",
                           pProg->Command );
            bFirst = FALSE;
        }
    }

    wcscat(szUsage, L" }\n");

    if ( fError )
        My_fwprintf(stderr, szUsage);
    else
        My_wprintf(szUsage);
}
/*******************************************************************************
 *  ScanPrintfString
 *      Scans a string, detects any % and double it
 *      (Use it for any string argument before calling ErrorPrintf)
 *
 *******************************************************************************/
#define PERCENTCHAR L'%'

BOOLEAN ScanPrintfString(PWCHAR pSource, PWCHAR *ppDest)
{
    size_t i, j = 0, k = 0, n = 0;
    size_t SourceLength;
    PWCHAR pDest = NULL;

    if ( (pSource == 0) || (ppDest == 0))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    SourceLength = wcslen(pSource);
    for (i = 0; i < SourceLength; i++)
    {
        if (pSource[i] == PERCENTCHAR)
        {
            n++;
        }
    }

    if (n != 0)     // at least one %, we need to build a new string.
    {
        pDest = (PWCHAR)malloc((SourceLength + n + 1) * sizeof(WCHAR));
        *ppDest  = pDest;
        if (pDest == NULL)
        {
            return FALSE;
        }
        else
        {
            //
            // rescan and copy
            //
            for (i = 0; i < SourceLength; i++)
            {
                if (pSource[i] == PERCENTCHAR)
                {
                    if ( i > j )
                    {
                        memcpy(&(pDest[k]), &(pSource[j]), (i - j) * sizeof(WCHAR));
                        k += (i-j);
                        j = i;
                    }
                    pDest[k] = PERCENTCHAR;
                    pDest[k+1] = PERCENTCHAR;
                    k += 2;
                    j++;
                }
            }
            if (i > j)
            {
                memcpy(&(pDest[k]), &(pSource[j]), (i - j) * sizeof(WCHAR));
            }
            pDest[SourceLength + n] = L'\0';
        }
    }
    else            // OK pSource is fine; no need of a new string.
    {
        *ppDest = NULL;
    }
    return (TRUE);
}


/*******************************************************************************
 *
 *  Message
 *      Display a message to stdout with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nResourceID (input)
 *          Resource ID of the format string to use in the message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
Message( int nResourceID, ...)
{
    WCHAR sz1[256], sz2[512];

    va_list args;
    va_start( args, nResourceID );

    if ( LoadString( NULL, nResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        My_wprintf( sz2 );

    } else {

        fwprintf( stderr, L"{Message(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
    }

    va_end(args);

}  /* Message() */



/************************************************************************************
 *  StringMessage
 *      used as a pre-routine for Message in case the argument is a single string
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringMessage(int nErrorResourceID, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, pFixedString);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, pString);
        }
    }
    else
    {
        Message(nErrorResourceID, L" ");
    }
}

/************************************************************************************
 *  StringErrorPrintf
 *      used as a pre-routine for ErrorPrintf in case the argument is a single string
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringErrorPrintf(int nErrorResourceID, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            ErrorPrintf(nErrorResourceID, pFixedString);
            free(pFixedString);
        }
        else
        {
            ErrorPrintf(nErrorResourceID, pString);
        }
    }
    else
    {
        ErrorPrintf(nErrorResourceID, L" ");
    }
}

/************************************************************************************
 *  StringDwordMessage
 *      used as a pre-routine for Message in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringDwordMessage(int nErrorResourceID, PWCHAR pString, DWORD Num)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, pFixedString, Num);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, pString, Num);
        }
    }
    else
    {
        Message(nErrorResourceID, L" ", Num);
    }
}
/************************************************************************************
 *  DwordStringMessage
 *      used as a pre-routine for Message in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
DwordStringMessage(int nErrorResourceID, DWORD Num, PWCHAR pString)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            Message(nErrorResourceID, Num, pFixedString);
            free(pFixedString);
        }
        else
        {
            Message(nErrorResourceID, Num, pString);
        }
    }
    else
    {
        Message(nErrorResourceID, Num, L" ");
    }
}
/************************************************************************************
 *  StringDwordErrorPrintf
 *      used as a pre-routine for ErrorPrintf in case the argument are:
 *      a single string + a ulong
 *      (fix for bug #334374)
 *
 ************************************************************************************/
VOID WINAPI
StringDwordErrorPrintf(int nErrorResourceID, PWCHAR pString, DWORD Num)
{
    PWCHAR pFixedString = NULL;
    if (ScanPrintfString(pString, &pFixedString) )
    {
        if (pFixedString != NULL)
        {
            ErrorPrintf(nErrorResourceID, pFixedString, Num);
            free(pFixedString);
        }
        else
        {
            ErrorPrintf(nErrorResourceID, pString, Num);
        }
    }
    else
    {
        ErrorPrintf(nErrorResourceID, L" ", Num);
    }
}

/*******************************************************************************
 *
 *  ErrorPrintf
 *      Output an error message to stderr with variable arguments.  Message
 *      format string comes from the application resources.
 *
 *  ENTRY:
 *      nErrorResourceID (input)
 *          Resource ID of the format string to use in the error message.
 *      ... (input)
 *          Optional additional arguments to be used with format string.
 *
 *  EXIT:
 *
 ******************************************************************************/

VOID WINAPI
ErrorPrintf( int nErrorResourceID, ...)
{

    WCHAR sz1[256], sz2[512];


    va_list args;
    va_start( args, nErrorResourceID );

    if ( LoadString( NULL, nErrorResourceID, sz1, 256 ) ) {

        vswprintf( sz2, sz1, args );
        My_fwprintf( stderr, sz2 );

    } else {

        fwprintf( stderr, L"{ErrorPrintf(): LoadString failed, Error %ld, (0x%08X)}\n",
                  GetLastError(), GetLastError() );
        PutStdErr( GetLastError(), 0 );
    }

    va_end(args);

}  /* ErrorPrintf() */


/*******************************************************************************
 *
 *  TruncateString
 *
 *  This routine truncates given string with elipsis '...' suffix, if needed.
 *
 *
 *  ENTRY:
 *     pString (input/output)
 *        pointer to string to truncate
 *     MaxLength (input)
 *        maximum length of string
 *
 *  EXIT:
 *     nothing
 *
 ******************************************************************************/

VOID WINAPI
TruncateString( PWCHAR pString, int MaxLength )
{
    /*
     *  if string is too long, trucate it
     */
    if ( (int)wcslen(pString) > MaxLength && MaxLength > 2 ) {
        wcscpy( pString + MaxLength - 3, L"..." );
    }

}  /* TruncateString() */


/*******************************************************************************
 *
 *  EnumerateDevices
 *
 *  Perform PD device enumeration for the specified PD DLL.
 *
 *  ENTRY:
 *      pDllName (input)
 *          Pointer to DLLNAME string specifying the PD DLL to enumerate.
 *      pEntries (output)
 *          Points to variable to return number of devices that were enumerated.
 *
 *  EXIT:
 *      (PPDPARAMS) Points to a malloc()'ed PDPARAMS array containing the
 *                  enumeration results if sucessful.  The caller must perform
 *                  free of this array when done.  NULL if error.
 *
 ******************************************************************************/

/*
 * Typedefs for PdEnumerate function (from ...WINDOWS\INC\CITRIX\PDAPI.H)
 */
typedef NTSTATUS (APIENTRY * PPDENUMERATE)(PULONG, PPDPARAMS, PULONG);
#define INITIAL_ENUMERATION_COUNT   30

PPDPARAMS WINAPI
EnumerateDevices( PDLLNAME pDllName,
                  PULONG pEntries )
{
    PPDENUMERATE pPdEnumerate;
    HANDLE Handle;
    ULONG ByteCount;
    NTSTATUS Status;
    int i;
    PPDPARAMSW pPdParams = NULL;

    /*
     *  Load the specified PD DLL.
     */
    if ( (Handle = LoadLibrary(pDllName)) == NULL ) {

        ErrorOutFromResource(IDS_DEVICE_ENUM_CANT_LOAD, pDllName);

        // fwprintf(
           //  stderr,
           // L"Device enumeration failure:\n\tCan't load the %s DLL for device enumeration\n",
           // pDllName );
        goto CantLoad;
    }

    /*
     *  Get the PD enumeration function's load entry pointer.
     */
    if ( (pPdEnumerate =
          (PPDENUMERATE)GetProcAddress((HMODULE)Handle, "PdEnumerate"))
            == NULL ) {

        ErrorOutFromResource(IDS_DEVENUM_NO_ENTRY_POINT, pDllName);
        // fwprintf(
           //  stderr,
           // L"Device enumeration failure:\n\tDLL %s has no enumeration entry point\n",
           // pDllName );
        goto EnumerateMissing;
    }

    /*
     * Call enumerate in loop till we hit enough buffer entries to handle
     * a complete enumeration.
     */
    for ( i = INITIAL_ENUMERATION_COUNT; ; i *= 2 ) {


        if ( pPdParams == NULL ) {
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        } else {
            free(pPdParams);
            pPdParams =
                (PPDPARAMS)malloc(ByteCount = (sizeof(PDPARAMS) * i));
        }

        if ( pPdParams == NULL ) {
            ErrorOutFromResource(IDS_ERROR_MEMORY);
            // fwprintf(stderr, L"Error allocating memory\n");
            goto OutOfMemory;
        }

        /*
         * Perform enumeration and break loop if successful.
         */
        if ( (Status = (*pPdEnumerate)(pEntries, pPdParams, &ByteCount))
                == STATUS_SUCCESS )
            break;

        /*
         * If we received any other error other than 'buffer too small',
         * complain and quit.
         */
        if ( Status != STATUS_BUFFER_TOO_SMALL ) {

            ErrorOutFromResource(IDS_DEVICE_ENUM_FAILED, pDllName, Status);
            // fwprintf(
               //  stderr,
               //  L"Device enumeration failure\n\tDLL %s, Error 0x%08lX\n",
               //  pDllName, Status );
            goto BadEnumerate;
        }
    }

    /*
     * Close the DLL handle and return the PDPARAMS pointer.
     */
    CloseHandle(Handle);
    return(pPdParams);

/*-------------------------------------
 * Error cleanup and return
 */
BadEnumerate:
    free(pPdParams);
OutOfMemory:
EnumerateMissing:
    CloseHandle( Handle );
CantLoad:
    return(NULL);

}  /* EnumerateDevices() */


/******************************************************************************
 *
 *  wfopen
 *
 *  UNICODE version of fopen
 *
 *  ENTRY:
 *    filename (input)
 *       UNICODE filename to open.
 *    mode (input)
 *       UNICODE file open mode string.
 *
 *  EXIT:
 *      Pointer to FILE or NULL if open error.
 *
 *****************************************************************************/

FILE * WINAPI
wfopen( LPCWSTR filename, LPCWSTR mode )
{
    PCHAR FileBuf, ModeBuf;
    FILE *pFile;

    if ( !(FileBuf = (PCHAR)malloc((wcslen(filename)+1) * sizeof(CHAR))) )
        goto BadFileBufAlloc;

    if ( !(ModeBuf = (PCHAR)malloc((wcslen(mode)+1) * sizeof(CHAR))) )
        goto BadModeBufAlloc;

    /*
     * Convert UNICODE strings to ANSI and call ANSI fopen.
     */
    wcstombs(FileBuf, filename, wcslen(filename)+1);
    wcstombs(ModeBuf, mode, wcslen(mode)+1);
    pFile = fopen(FileBuf, ModeBuf);

    /*
     * Clean up and return
     */
    free(FileBuf);
    free(ModeBuf);
    return(pFile);

/*-------------------------------------
 * Error cleanup and return
 */
BadModeBufAlloc:
    free(FileBuf);
BadFileBufAlloc:
    return(NULL);

}  /* wfopen() */


/******************************************************************************
 *
 *  wfgets
 *
 *  UNICODE version of fgets
 *
 *  ENTRY:
 *    Buffer (output)
 *       Buffer to place string retreived from stream
 *    Len (input)
 *       Maximum number of WCHARs in buffer.
 *    Stream (input)
 *       STDIO file stream for input
 *
 *  EXIT:
 *      Pointer to Buffer or NULL.
 *
 *****************************************************************************/

PWCHAR WINAPI
wfgets( PWCHAR Buffer, int Len, FILE *Stream )
{
    PCHAR  AnsiBuf, pRet;
    size_t count;

    if ( !(AnsiBuf = (PCHAR)malloc(Len * sizeof(CHAR))) )
        goto BadAnsiBufAlloc;

    /*
     * Get the ANSI version of the string from the stream
     */
    if ( !(pRet = fgets(AnsiBuf, Len, Stream)) )
        goto NullFgets;

    /*
     * Convert to UNICODE string in user's buffer.
     */
    count = mbstowcs(Buffer, AnsiBuf, strlen(AnsiBuf)+1);

    /*
     * Clean up and return
     */
    free(AnsiBuf);
    return(Buffer);

/*-------------------------------------
 * Error cleanup and return
 */
NullFgets:
    free(AnsiBuf);
BadAnsiBufAlloc:
    return(NULL);

}  /* wfgets() */




/***    PutStdErr - Print a message to STDERR
 *
 *  Purpose:
 *      Calls PutMsg sending STDERR as the handle to which the message
 *      will be written.
 *
 *  int PutStdErr(unsigned MsgNum, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      ...             - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from PutMsg()                      M026
 *
 */

int WINAPI
PutStdErr(unsigned int MsgNum, unsigned int NumOfArgs, ...)
{
        int Result;

        va_list arglist;

        va_start(arglist, NumOfArgs);
        Result = PutMsg(MsgNum, NumOfArgs, &arglist);
        va_end(arglist);
        return Result;
}


int
FindMsg(unsigned MsgNum, PTCHAR NullArg, unsigned NumOfArgs, va_list *arglist)
{
    unsigned msglen;
    DWORD msgsource;
    TCHAR *Inserts[ 2 ];
    CHAR numbuf[ 32 ];
    TCHAR   wnumbuf[ 32 ];

    //
    // find message without doing argument substitution
    //

    if (MsgNum == ERROR_MR_MID_NOT_FOUND) {
        msglen = 0;
    }
    else {
#ifdef LATER
        msgsource = MsgNum >= IDS_ERROR_MALLOC ?
                       FORMAT_MESSAGE_FROM_HMODULE :
                       FORMAT_MESSAGE_FROM_SYSTEM;
#endif
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM;
        msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               MsgNum,
                               0,
                               MsgBuf,
                               MAXCBMSGBUFFER,
                               NULL
                             );
        if (msglen == 0) {
            if (NtDllHandle == NULL) {
                NtDllHandle = GetModuleHandle( TEXT("NTDLL") );
            }
            msgsource = FORMAT_MESSAGE_FROM_HMODULE;
            msglen = FormatMessage(msgsource | FORMAT_MESSAGE_IGNORE_INSERTS,
                                   (LPVOID)NtDllHandle,
                                   MsgNum,
                                   0,
                                   MsgBuf,
                                   MAXCBMSGBUFFER,
                                   NULL
                                 );
        }
    }

    if (msglen == 0) {
        //
        // didn't find message
        //
        msgsource = FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY;
        _ultoa( MsgNum, numbuf, 16 );
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, numbuf, -1, wnumbuf, 32);
        Inserts[ 0 ]= wnumbuf;
#ifdef LATER
        Inserts[ 1 ]= (MsgNum >= IDS_ERROR_MALLOC ? TEXT("Application") : TEXT("System"));
#endif
        Inserts[ 1 ]= TEXT("System");
        MsgNum = ERROR_MR_MID_NOT_FOUND;
        msglen = FormatMessage(msgsource,
                               NULL,
                               MsgNum,
                               0,
                               MsgBuf,
                               MAXCBMSGBUFFER,
                               (va_list *)Inserts
                             );
    }
    else {

        // see how many arguments are expected and make sure we have enough

        PTCHAR tmp;
        ULONG count;

        tmp=MsgBuf;
        count = 0;
        while (tmp = mystrchr(tmp, PERCENT)) {
            tmp++;
            if (*tmp >= TEXT('1') && *tmp <= TEXT('9')) {
                count += 1;
            }
            else if (*tmp == PERCENT) {
                tmp++;
            }
        }
        if (count > NumOfArgs) {
            PTCHAR *LocalArgList;
            ULONG i;

            LocalArgList = (PTCHAR*)malloc(sizeof(PTCHAR) * count);

            if( LocalArgList == NULL )
            {
                msglen = 0;
            }
            else
            {
                for (i=0; i<count; i++)
                {
                    if (i < NumOfArgs)
                    {
                        LocalArgList[i] = (PTCHAR)(ULONG_PTR)va_arg( *arglist, ULONG );
                    }
                    else
                    {
                        LocalArgList[i] = NullArg;
                    }
                }
                msglen = FormatMessage(msgsource | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                       NULL,
                                       MsgNum,
                                       0,
                                       MsgBuf,
                                       MAXCBMSGBUFFER,
                                       (va_list *)LocalArgList
                                     );
                free(LocalArgList);
            }
        }
        else {
            msglen = FormatMessage(msgsource,
                                   NULL,
                                   MsgNum,
                                   0,
                                   MsgBuf,
                                   MAXCBMSGBUFFER,
                                   arglist
                                 );
        }
    }
    return msglen;
}

/***    PutMsg - Print a message to a handle
 *
 *   Purpose:
 *      PutMsg is the work routine which interfaces command.com with the
 *      DOS message retriever.  This routine is called by PutStdOut and
 *      PutStdErr.
 *
 *  int PutMsg(unsigned MsgNum, unsigned Handle, unsigned NumOfArgs, ...)
 *
 *  Args:
 *      MsgNum          - the number of the message to print
 *      NumOfArgs       - the number of total arguments
 *      Handle          - the handle to print to
 *      Arg1 [Arg2...]  - the additonal arguments for the message
 *
 *  Returns:
 *      Return value from DOSPUTMESSAGE                 M026
 *
 *  Notes:
 *    - PutMsg builds an argument table which is passed to DOSGETMESSAGE;
 *      this table contains the variable information which the DOS routine
 *      inserts into the message.
 *    - If more than one Arg is sent into PutMsg, it (or they)  are taken
 *      from the stack in the first for loop.
 *    - M020 MsgBuf is a static array of 2K length.  It is temporary and
 *      will be replaced by a more efficient method when decided upon.
 *
 */

int
PutMsg(unsigned int MsgNum, unsigned int NumOfArgs, va_list *arglist)
{
        unsigned msglen;
    PTCHAR   NullArg = TEXT(" ");
    WCHAR    szErrorNo[256];

    if (GetResourceStringFromUtilDll(IDS_ERROR_NUMBER, szErrorNo, 256))
    {
        fwprintf( stderr, szErrorNo, MsgNum );
    }

    msglen = FindMsg(MsgNum,NullArg,NumOfArgs,arglist);
    My_fwprintf( stderr, MsgBuf );

    return NO_ERROR;
}


 /***
 * mystrchr(string, c) - search a string for a character
 *
 * mystrchr will search through string and return a pointer to the first
 * occurance of the character c. This version of mystrchr knows about
 * double byte characters. Note that c must be a single byte character.
 *
 */

TCHAR *
mystrchr(TCHAR const *string, int c)
{

        /* handle null seperatly to make main loop easier to code */
        if (string == NULL)
            return(NULL);

        if (c == NULLC)
        return((TCHAR *)(string + wcslen(string)));

    return wcschr( string, (TCHAR)c );
}



 /***
 * My_wprintf(format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_wprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_wprintf(
    const wchar_t *format,
    ...
    )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(stdout, format, args);

    va_end(args);

    return cchWChar;
}



 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    HANDLE hOut;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    if ((GetFileType(hOut) & ~FILE_TYPE_REMOTE) == FILE_TYPE_CHAR) {
        DWORD  cchWChar;
        WCHAR  szBufferMessage[1024];

        vswprintf( szBufferMessage, format, argptr );
        cchWChar = wcslen(szBufferMessage);
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
        return cchWChar;
    }

    return vfwprintf(str, format, argptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\printfoa.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
// File: PRINTFOA.C
//
//============================================================================

// Include Files:
//===============

#include <printfoa.h>

// Extern Data:												
//=============


// Global Data:
//=============


// Function Prototypes:
//=====================


// Code:
//======


#undef printf
#undef wprintf

// Function: int ANSI2OEM_Printf(const char *format, ...)
//=======================================================
//
// Desc:  Takes ANSI code page characters and prints them out 
//			in OEM code page
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
int ANSI2OEM_Printf(const char *format, ...)
{
    va_list arg_marker;
    char buffer[256];
	WCHAR uniBuffer[256];

	// sprintf the buffer
    va_start(arg_marker, format);
    vsprintf(buffer, format, arg_marker);
	va_end(arg_marker);

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return printf(buffer);
    }

	// clear it out
	memset(uniBuffer, 0, sizeof(uniBuffer));

	// convert it to unicode
	MultiByteToWideChar(CP_ACP, 0, buffer, strlen(buffer), uniBuffer, 
                        sizeof(uniBuffer) / sizeof(WCHAR));

	// change the code page of the buffer
	CharToOemW(uniBuffer, buffer);

	// do the actual printf
    return printf(buffer);
}
// end - int ANSI2OEM_Printf(const char *format, ...)


// Function: int ANSI2OEM_Wprintf(const wchar_t *format, ...)
//=======================================================
//
// Desc: Takes ANSI code page characters and prints them out 
//			in OEM code page
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
int ANSI2OEM_Wprintf(const wchar_t *format, ...)
{
	va_list arg_marker;
    wchar_t buffer[256];
	char oemBuffer[256];

	// do the sprintf
    va_start(arg_marker, format);
    wvsprintf(buffer, format, arg_marker);
	va_end(arg_marker);

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return wprintf(buffer);
    }

	// clear the buffer
	memset(oemBuffer, 0, sizeof(oemBuffer));
	
	// change the code page	of the buffer (this function outputs ascii)
	CharToOemW(buffer, oemBuffer);

    return printf(oemBuffer);
} 
// end - int ANSI2OEM_Wprintf(const wchar_t *format, ...)


// Function: void OEM2ANSIW(WCHAR *buffer, USHORT len)
//=======================================================
//
// Desc: converts wide characters from the OEM code page to 
//			ANSI
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
void OEM2ANSIW(WCHAR *buffer, USHORT len)
{
    int     BufferNeeded;
    char    *temp = NULL;
    WCHAR   *cvt;

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return;
    }

	// allocate a wide character buffer
	cvt = (WCHAR *) LocalAlloc( 0, (len+1) * sizeof(WCHAR) );

	if (cvt) {

        // determine the buffer size needed for the multi byte string
        BufferNeeded = WideCharToMultiByte(CP_OEMCP, 0, buffer, len, NULL, 0,
            NULL, NULL);

        // allocate the temporary buffer
        temp = (char *)LocalAlloc(0, BufferNeeded+1);

        if (temp) {

    		// clear them out
    		memset(temp, 0, BufferNeeded+1);
    		memset(cvt, 0, (len + 1) * sizeof(WCHAR));

    		// convert the incoming wide buffer to a multi byte buffer
		    WideCharToMultiByte(CP_OEMCP, 0, buffer, len, temp, BufferNeeded+1,
                NULL, NULL);

    		// convert the oem multi byte buffer to ansi (wide)
    		OemToCharBuffW(temp, cvt, len);

    		// copy the buffer onto the orginal
    		wcscpy(buffer, cvt);
        }
	} 

	// clean up
	if (cvt)
		LocalFree(cvt);

	if (temp)
		LocalFree(temp); 
}
// end - void OEM2ANSIW(WCHAR *buffer, USHORT len)

// Function: void OEM2ANSIA(char *buffer, USHORT len)
//=======================================================
//
// Desc: converts ascii characters from the OEM code page to 
//			ANSI
//
// Input: 
//
// Return:
//
// Misc: 
//
//=======================================================
void OEM2ANSIA(char *buffer, USHORT len)
{
    WCHAR *temp;

    if (GetACP() == GetOEMCP()) {
        // In case of Far East, ACP and OEMCP are equal, then return.
        return;
    }

	temp = (WCHAR *) LocalAlloc(9, (len+1) * sizeof(WCHAR));

	if (temp) {

		// set the buffer
		memset(temp, 0, (len+1) * sizeof(WCHAR));

		// convert the oem multi byte buffer to ansi (wide)
		OemToCharBuffW(buffer, temp, len);

		// convert from wide back to multi byte
		WideCharToMultiByte(CP_OEMCP, 0, temp, wcslen(temp), buffer, len+1, NULL, NULL);

		// clean up
		LocalFree(temp);
	} 

}
// end - void OEM2ANSIA(char *buffer, USHORT len)



// - end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\parse.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   PARSE.C
*
*      This module contains the code to implement generic parsing routines
*      for utilities.  There are several parsing routines included here.
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineW()
*         IsTokenPresentW()
*         SetTokenPresentW()
*         SetTokenNotPresentW()
*
*
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>
#include <expand.h>

// Verify that these are used internally, and do not rep. OS flags
// usage appears in parse.c and expand.c only
//
#define READ_ONLY 0x0001   /* file is read only */
#define HIDDEN    0x0002   /* file is hidden */
#define SYSTEM    0x0004   /* file is a system file */
#define VOLUME    0x0008   /* file is a volume label */
#define SUBDIR    0x0010   /* file is a subdirectory */
#define ARCHIVE   0x0020   /* file has archive bit on */


/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/
static USHORT StoreArgument(PTOKMAPW, WCHAR *);

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/
ARGS  arg_data;

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

VOID
SetBoolean(
    PTOKMAPW TokenMap,
    BOOL Value
    )
{
    //
    // Folks pass in a variety of types and sizes as "boolean".  Carefully
    // perform the write based on the size of the token map: first clear the
    // entire field, then (if Value != FALSE) set the only the first byte to
    // TRUE.
    //

    ZeroMemory( TokenMap->tmAddr, TokenMap->tmDLen );
    if (Value != FALSE) {
        *((PCHAR)TokenMap->tmAddr) = TRUE;
    }
}

/*****************************************************************************
*
*   ParseCommandLineW (UNICODE version)
*
*      This is the main function of the ParseCommandLine function. If the
*      caller is passing argv from the main() function the caller is
*      is responsible for pointing to argv[1], unless he wants this function
*      to parse the program name (argv[0]).
*
*      If the user wishes to parse an admin file it is necessary to massage
*      the data into a form compatible with the command line arguements
*      passed to a main() function before calling ParseCommandLine().
*
*   ENTRY:
*      argc - count of the command line arguments.
*      argv - vector of strings containing the
*      ptm  - pointer to begining of the token map array
*      flag - USHORT set of flags (see utilsub.h for flag descriptions).
*
*   EXIT:
*      Normal:                           ********** NOTE***********
*         PARSE_FLAG_NO_ERROR            * All errors returned    *
*                                        * from this function are *
*      Error:                            * BIT flags and must be  *
*         PARSE_FLAG_NO_PARMS            * converted by caller to *
*         PARSE_FLAG_INVALID_PARM        * OS/2+ ERRORS!!!!       *
*         PARSE_FLAG_TOO_MANY_PARMS      ********** NOTE***********
*         PARSE_FLAG_MISSING_REQ_FIELD
*   ALGORITHM:
*
****************************************************************************/

USHORT WINAPI
ParseCommandLineW( INT argc,
                   WCHAR **argv,
                   PTOKMAPW ptm,
                   USHORT flag )
{
   BOOL      everyonespos = FALSE;
   WCHAR     *pChar;
   USHORT    rc, argi, found;
   size_t    tokenlen, arglen;
   PTOKMAPW   ptmtmp, nextpositional;
   PFILELIST pFileList;

   rc = PARSE_FLAG_NO_ERROR;

   /*--------------------------------------------------------------------------
   -- If there are no parameters inform the caller of this fact.
   --------------------------------------------------------------------------*/
   if(argc == 0) {
      rc |= PARSE_FLAG_NO_PARMS;
      return(rc);
   }

   /*--------------------------------------------------------------------------
   -- Find the first positional parameter in the token map array, if any.
   -- Also set the valid memory locations to '\0'.
   --------------------------------------------------------------------------*/
   nextpositional = NULL;
   for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
      if(ptmtmp->tmDLen && !(flag & PCL_FLAG_NO_CLEAR_MEMORY)) {
         pChar = (WCHAR *) ptmtmp->tmAddr;
         /*
          * Clear the 'string' form fields for tmDLen*sizeof(WCHAR) bytes;
          * all other forms to tmDLen bytes.
          */
         if ( (ptmtmp->tmForm == TMFORM_S_STRING) ||
              (ptmtmp->tmForm == TMFORM_DATE) ||
              (ptmtmp->tmForm == TMFORM_PHONE) ||
              (ptmtmp->tmForm == TMFORM_STRING) ||
              (ptmtmp->tmForm == TMFORM_X_STRING) )
            memset(pChar, L'\0', (ptmtmp->tmDLen*sizeof(WCHAR)));
        else
            memset(pChar, L'\0', ptmtmp->tmDLen);
      }
      if(ptmtmp->tmToken[0] != L'/' && ptmtmp->tmToken[0] != L'-' && nextpositional == NULL) {
         nextpositional = ptmtmp;
      }
   }

   /*--------------------------------------------------------------------------
   -- Scan the argument array looking for /x or -x switches or positional
   -- parameters.  If a switch is found look it up in the token map array
   -- and if found see if it has a trailing parameter of the format:
   --              -x:foo || /x:foo || -x foo || /x foo
   -- when found set the found flag and if there is a trailing parameter
   -- store it at the location the user requested.
   --
   -- If it is not found in the token map array return the proper error
   -- unless the user requests us to ignore it (PCL_FLAG_IGNORE_INVALID).
   --
   -- If it is a positional parameter enter it into the token map array if
   -- there is room for it (i.e. nextpositional != NULL), if there is no
   -- room for it then return the proper error.
   --------------------------------------------------------------------------*/
   for(argi=0; argi<argc;) {
      if(everyonespos) {
         if( (wcslen(nextpositional->tmAddr) + wcslen(argv[argi]) + 1) > nextpositional->tmDLen) {
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            return(rc);
         }
         wcscat((WCHAR *) nextpositional->tmAddr, L" ");
         wcscat((WCHAR *) nextpositional->tmAddr, argv[argi]);
         argi++;
      }
      else if(argv[argi][0] == L'/' ||     /* argument is a switch (/x or -x) */
         argv[argi][0] == L'-') {
         found = FALSE;
         for(ptmtmp=ptm; ptmtmp->tmToken != NULL; ptmtmp++) {
            /*-----------------------------------------------------------------
             --   The string is found if a few requirements are met:
             --   1) The first N-1 characters are the same, where N is
             --      the length of the string in the token map array.
             --      We ignore the first character (could be '-' or '/').
             --   2) If the strings are not the same length, then the only
             --      valid character after /x can be ':', this is only  true
             --      if the switch has a trailing parameter.
             ----------------------------------------------------------------*/
            tokenlen = wcslen(ptmtmp->tmToken);    /* get token length       */
            arglen   = wcslen(argv[argi]);         /* get argument length    */
            if(!(_wcsnicmp(&(ptmtmp->tmToken[1]), &(argv[argi][1]), tokenlen-1))) {
               if(tokenlen != arglen) {            /* not same length        */
                  if(ptmtmp->tmForm != TMFORM_VOID && /* if trailing parm is    */
                     argv[argi][tokenlen] == L':') {/* delemited with a ':'   */
                     if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                        rc |= PARSE_FLAG_DUPLICATE_FIELD;
                     }
                     found = TRUE;                 /* then report it found.  */
                     break;
                  }
               }
               else {                              /* all character same and */
                  if(ptmtmp->tmFlag & TMFLAG_PRESENT) { /* seen already  */
                     rc |= PARSE_FLAG_DUPLICATE_FIELD;
                  }
                  found = TRUE;                    /* strings are the same   */
                  break;                           /* len report it found.   */
               }
            }
         }
         /* switch not found in token map array and not requested to ignore */
         if(found != TRUE && !(flag & PCL_FLAG_IGNORE_INVALID)) {
            rc |= PARSE_FLAG_INVALID_PARM;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
            ++argi;
         }
         else if (!found) {
            ++argi;
         }
         else {               /* switch was found in token map array */
            if(ptmtmp->tmForm == TMFORM_VOID) { /* no trailing parameter, done */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               ++argi;
            }
            else if(ptmtmp->tmForm == TMFORM_BOOLEAN) {  /* need confirmation */
               ptmtmp->tmFlag |= TMFLAG_PRESENT;
               SetBoolean(ptmtmp, TRUE);
               ++argi;
            }
            else {         /* has a trailing parameter */
               if(argv[argi][tokenlen] == L':') { /* all in one switch (i.e. /x:foo) */
                  if(StoreArgument(ptmtmp, &(argv[argi][tokenlen+1]))) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                  }
                  ++argi;                 /* bump up to next argument */
               }
               else {   /* two argument switch (i.e. /x foo) */
                  if ((++argi >= argc) ||
                      (argv[argi][0] == L'/') ||
                      (argv[argi][0] == L'-')) { /* bump up to trailing parm */
                     switch ( ptmtmp->tmForm ) {
                     case TMFORM_S_STRING:
                     case TMFORM_STRING:
                        ptmtmp->tmFlag |= TMFLAG_PRESENT;
                        pChar    = (WCHAR *) ptmtmp->tmAddr;
                        pChar[0] = (WCHAR)NULL;
                        break;
                     default:
                        rc |= PARSE_FLAG_INVALID_PARM;
                        if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                           return(rc);
                        }
                        break;
                     }
                  }
                  else if(StoreArgument(ptmtmp, argv[argi])) {
                     ptmtmp->tmFlag |= TMFLAG_PRESENT;
                     if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
                  else {
                     rc |= PARSE_FLAG_INVALID_PARM;
                     if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                        return(rc);
                     }
                     ++argi;           /* bump up to next argument         */
                  }
               }
            }
         }
      }                                /* endif - is switch                */
      else {                           /* argument is a positional parmater*/
         if(nextpositional == NULL) {  /* if there are no positional left  */
            rc |= PARSE_FLAG_TOO_MANY_PARMS;
            if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
               return(rc);
            }
         }
         else {                        /* set positional in token array **/
            /*
            *  Is the current PTM the start of TMFORM_FILES?
            */
            if (nextpositional->tmForm == TMFORM_FILES) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               args_init(&arg_data, MAX_ARG_ALLOC);
               do {
                  /*
                  *  If no match was found then return the current id.
                  */
//                if (!expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data)) {
//                   arg_data.argc--;
//                   arg_data.argvp--;
//                }
                  expand_path(argv[argi], (HIDDEN|SYSTEM), &arg_data);
               } while (++argi<argc);
               pFileList = (PFILELIST) nextpositional->tmAddr;
               pFileList->argc = arg_data.argc;
               pFileList->argv = &arg_data.argv[0];
               return (rc);
            }
            else if(StoreArgument(nextpositional, argv[argi])) {
               nextpositional->tmFlag |= TMFLAG_PRESENT;
               if(flag & PCL_FLAG_RET_ON_FIRST_SUCCESS) {
                  return(rc);
               }
               /*--------------------------------------------------------------
               -- if this is an X_STRING then every thing from now on is
               -- going to be a concatenated string
               --------------------------------------------------------------*/
               if(nextpositional->tmForm == TMFORM_X_STRING) {
                  everyonespos = TRUE;
               }
               else {
                  for(++nextpositional; nextpositional->tmToken!=NULL; nextpositional++) {
                     if(nextpositional->tmToken[0] != L'/' && nextpositional->tmToken[0] != L'-') {
                        break;
                     }
                  }
                  if(nextpositional->tmToken == NULL) {  /* ran out of PP */
                     nextpositional = NULL;
                  }
               }
            }
            else {                                    /* invalid PP */
               rc |= PARSE_FLAG_INVALID_PARM;
               if(!(flag & PCL_FLAG_CONTINUE_ON_ERROR)) {
                  return(rc);
               }
            }
         }
         argi++;
      }
   }

   for(ptmtmp=ptm; ptmtmp->tmToken!=NULL; ptmtmp++) {
      if(ptmtmp->tmFlag & TMFLAG_REQUIRED && !(ptmtmp->tmFlag & TMFLAG_PRESENT)) {
         rc |= PARSE_FLAG_MISSING_REQ_FIELD;
         break;
      }
   }

   return(rc);

}  // end ParseCommandLineW


/*****************************************************************************
*
*   IsTokenPresentW (UNICODE version)
*
*       Determines if a specified command line token (in given TOKMAPW array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentW( PTOKMAPW ptm,
                 PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentW


/*****************************************************************************
*
*   SetTokenPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentW( PTOKMAPW ptm,
                  PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentW


/*****************************************************************************
*
*   SetTokenNotPresentW (UNICODE version)
*
*       Forces a specified command line token (in given TOKMAPW array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPW array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPW array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentW( PTOKMAPW ptm,
                     PWCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !wcscmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentW


/*****************************************************************************
*
*   StoreArgument:
*
*   ENTRY:
*      ptm - a pointer to an entry in the token array map
*      s   - the argument to be entered into the current token array map entry.
*
*   EXIT:
*      Normal:
*         TRUE
*
*      Error:
*         FALSE
*
*   ALGORITHM:
*
****************************************************************************/

USHORT
StoreArgument( PTOKMAPW ptm,
               WCHAR *s )
{
   char *pByte;
   WCHAR *pChar;
   SHORT *pShort;
   USHORT *pUShort;
   LONG *pLong;
   ULONG *pULong;

   WCHAR *pEnd = s; //pointer to end of conversion

   /*
    * If the string is empty, allow it for real 'strings'!
    */
   if( !wcslen(s) ) {
      switch ( ptm->tmForm ) {
      case TMFORM_S_STRING:
      case TMFORM_STRING:
         pChar    = (WCHAR *) ptm->tmAddr;
         pChar[0] = (WCHAR)NULL;
         return( TRUE );
      }
      return( FALSE );
   }

   /*
    * Fail if there is no room to store result.
    */
   if ( ptm->tmDLen == 0) {
      return(FALSE);
   }

   switch(ptm->tmForm) {
      case TMFORM_BOOLEAN:
         SetBoolean(ptm, TRUE);
         break;
      case TMFORM_BYTE:
         pByte = (BYTE *) ptm->tmAddr;
        *pByte = (BYTE) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_CHAR:
         pChar = (WCHAR *) ptm->tmAddr;
        *pChar = s[0];
         break;
      case TMFORM_S_STRING:
         if (*s == L'\\') {
            ++s;
         }
      case TMFORM_DATE:
      case TMFORM_PHONE:
      case TMFORM_STRING:
      case TMFORM_X_STRING:
         
         //Added by a-skuzin
         //case when we need parameter to start with '-' or '/' and use "\-" or"\/"
		 if(s[0]==L'\\' && (s[1]==L'-' || s[1]==L'/' || s[1]==L'\\') ) {
	    	  ++s;
		 }
         //end of "added by a-skuzin"
         
         pChar = (WCHAR *) ptm->tmAddr;
         wcsncpy(pChar, s, ptm->tmDLen);
         break;
      case TMFORM_SHORT:
         pShort = (SHORT *) ptm->tmAddr;
        *pShort = (SHORT) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_USHORT:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_LONG:
         pLong = (LONG *) ptm->tmAddr;
        *pLong = wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_SERIAL:
      case TMFORM_ULONG:
          if ( s[0] == L'-') {        /* no negative numbers! */
             return (FALSE);
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = (ULONG) wcstol(s, &pEnd, 10);
        if (pEnd == s)
        {
            return FALSE;
        }
         break;
      case TMFORM_HEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pUShort = (USHORT *) ptm->tmAddr;
        *pUShort = (USHORT) wcstoul(s,NULL,16);
         break;
      case TMFORM_LONGHEX:
         if ( s[0] == L'-') {        /* no negative numbers! */
            return( FALSE );
         }
         pULong = (ULONG *) ptm->tmAddr;
        *pULong = wcstoul(s,NULL,16);
         break;
      default:                         /* if invalid format return FALSE */
         return(FALSE);
         break;
   }

   return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\umatch.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*   UMATCH.C
*
*   The unix_match() function, performing unix style wild-card matching on
*   a given file name.
*
*
******************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <string.h>

#define TRUE 1
#define FALSE 0

/******************************************************************************
*
* unix_match()
*
*   Check specified filename (found_file) to see if it matches
*   the filename with global characters (with globals).
*   Uses unix style wild-card matching.
*
*   EXIT:
*       TRUE  -- the specified filename matched the filename with wildcards
*       FALSE -- the specified filename did not match
*
******************************************************************************/

int
unix_match(
     WCHAR *with_globals,     /* the file with possible global characters */
     WCHAR *found_file )      /* file name returned - no globals in it */
{
   WCHAR *c1, *c2, *start_c1, *start_c2, *sav_c1, *sav_c2;
   WCHAR ch, ch2;
   int  i, j, k, char_ok, match, want_match;

/*
 * Play with filename so that blanks are removed.
 */
   j = k = 0;
   for (i=0; found_file[i]!=L'\0'; ++i) {
      if (found_file[i] == L' ') {
         if (j == 0) {
            j = i;
         } else {
            found_file[i] = L'\0';
         }
      } else if (found_file[i] == L'.') {
         k = i;
      }
   }
   if (j && k) {
      wcscpy(&found_file[j], &found_file[k]);
   }

/*
 * If Search name is just "*", simply return success now.
 */
   if (with_globals[0]==L'*' && with_globals[1]==L'\0') {
      return TRUE;
   }

#ifdef DEBUG
   wprintf("unix_match: search=%s: found=%s:\n", with_globals, found_file);
#endif

/*
 * Now compare the 2 filenames to see if we have a match.
 */
   c1 = with_globals,
   c2 = found_file;
   start_c1 = sav_c1 = NULL;
      while (*c2!=L'\0') {
         char_ok = FALSE;
         switch (*c1) {
         case L'\0':
            break;
         case '*':
            while (*++c1 == L'*') ;     /* skip consecutive '*'s */
            if (*c1 == L'\0') {         /* if we reached the end, we match */
               return TRUE;
            }
            start_c1 = c1;             /* remember where '*' was and where */
            start_c2 = c2;             /* we were in filename string */
            sav_c1 = NULL;
            char_ok = TRUE;
            break;
         case L'?':
            ++c1; ++c2;
            char_ok = TRUE;
            break;
         case L'[':
            if (!sav_c1) {
               sav_c1 = c1;
               sav_c2 = c2;
            }
            match = FALSE;
            want_match = TRUE;
            if (*++c1 == L'!') {
               ++c1;
               want_match = FALSE;
            }
            while ((ch=*c1) && ch != L']') {             /* BJP */
               if (c1[1] == L'-') {
                  ch2 = *c2;
                  if (ch<=ch2 && c1[2]>=ch2) {
                     match = TRUE;
                     break;
                  }
                  ++c1; ++c1;    /* skip '-' and following char */
               } else if (ch == *c2) {
                  match = TRUE;
                  break;
               }
               ++c1;
            }
            if (want_match) {
               if (match) {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               } else if (!start_c1) {
                  return FALSE;
               }
            } else /*!want_match*/ {
               if (match) {
                  return FALSE;
               } else if (start_c1) {
                  if (sav_c1 != start_c1) {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     ++c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  } else if (c2[1] == L'\0') {
                     while ((ch=*c1++) && ch != L']') ;  /* BJP */
                     c2 = sav_c2;
                     sav_c1 = NULL;
                     char_ok = TRUE;
                  }
               } else {
                  while ((ch=*c1++) && ch != L']') ;     /* BJP */
                  ++c2;
                  char_ok = TRUE;
               }
            }
            break;
         default:
            if (*c1 == *c2) {     /* See if this char matches exactly */
               ++c1; ++c2;
               char_ok = TRUE;
            }
         }
         if (!char_ok) {               /* No match found */
            if (start_c1) {            /* If there was a '*', start over after*/
               c1 = start_c1;          /* the '*', and one char further into */
               c2 = ++start_c2;        /* the filename string than before */
            } else {
               return FALSE;
            }
         }
      }

   while (*c1==L'*') ++c1;

   if (*c1==L'\0' && *c2==L'\0')
      return TRUE;
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\parse_a.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*****************************************************************************
*
*   PARSE_A.C
*
*      ANSI stubs / replacements for the UNICODE command line parsing
*      routines (parse.c)
*
*      External Entry Points:  (defined in utilsub.h)
*
*         ParseCommandLineA()
*         IsTokenPresentA()
*         SetTokenPresentA()
*         SetTokenNotPresentA()
*
*
****************************************************************************/

/* Get the standard C includes */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

#include <winstaw.h>
#include <utilsub.h>

/*=============================================================================
 ==   Local Functions Defined
 ============================================================================*/

/*=============================================================================
 ==   External Functions Used
 ============================================================================*/

/*=============================================================================
 ==   Local Variables Used
 ============================================================================*/

/*=============================================================================
 ==   Global Variables Used
 ============================================================================*/

/*****************************************************************************
*
*   ParseCommandLineA (ANSI stub for ParseCommandLineW)
*
*   Thunks over argv_a (ANSI) to argv_w (UNICODE) and TOKMAPA to TOKMAPW,
*   calls ParseCommandLineW(), then thunks back TOKMAPW to TOKMAPA and
*   returns
*
*   ENTRY:
*       (refer to ParseCommandLineW)
*   EXIT:
*       (refer to ParseCommandLineW), plus
*       PARSE_FLAG_NOT_ENOUGH_MEMORY
*
****************************************************************************/

#define tmFormIsString(x) ((x == TMFORM_S_STRING) || (x == TMFORM_DATE) || (x == TMFORM_PHONE) || (x == TMFORM_STRING) || (x == TMFORM_X_STRING))

USHORT WINAPI
ParseCommandLineA( INT argc,
                   CHAR **argv_a,
                   PTOKMAPA ptm_a,
                   USHORT flag )
{
    int i;
    size_t len1, len2;
    USHORT rc = PARSE_FLAG_NOT_ENOUGH_MEMORY;   // default to memory error
    WCHAR **argv_w = NULL;
    PTOKMAPA ptmtmp_a;
    PTOKMAPW ptmtmp_w, ptm_w = NULL;

    /*
     * If no parameters, we skip a lot of work.
     */
    if ( argc == 0 ) {
        rc = PARSE_FLAG_NO_PARMS;
        return(rc);
    }

    /*
     * Alloc and form WCHAR argvw array.
     */
    if ( !(argv_w = (WCHAR **)malloc( (len1 = argc * sizeof(WCHAR *)) )) )
        goto done;  // memory error
    memset(argv_w, 0, len1);     // zero all to init pointers to NULL
    for ( i = 0; i < argc; i++ ) {
        if ( argv_w[i] = malloc((len1 = ((len2 = strlen(argv_a[i])+1) * 2))) ) {
            memset(argv_w[i], 0, len1);
            mbstowcs(argv_w[i], argv_a[i], len2);
        } else {
            goto done;  // memory error
        }
    }

    /*
     * Alloc and form TOKMAPW array.
     */
    for ( ptmtmp_a=ptm_a, i=0;
          ptmtmp_a->tmToken != NULL;
          ptmtmp_a++, i++ );
    if ( !(ptm_w = (PTOKMAPW)malloc( (len1 = ++i * sizeof(TOKMAPW)) )) )
        goto done;  // memory error
    memset(ptm_w, 0, len1);     // zero all to init pointers to NULL
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_a->tmToken != NULL;
          ptmtmp_w++, ptmtmp_a++ ) {

        /*
         * Allocate and convert token.
         */
        if ( ptmtmp_w->tmToken =
                malloc((len1 = ((len2 = strlen(ptmtmp_a->tmToken)+1) * 2))) ) {
            memset(ptmtmp_w->tmToken, 0, len1);
            mbstowcs(ptmtmp_w->tmToken, ptmtmp_a->tmToken, len2);
        } else {
            goto done;  // memory error
        }

        /*
         * Copy flag, form, and length (no conversion needed).
         */
        ptmtmp_w->tmFlag = ptmtmp_a->tmFlag;
        ptmtmp_w->tmForm = ptmtmp_a->tmForm;
        ptmtmp_w->tmDLen = ptmtmp_a->tmDLen;

        /*
         * Allocate or copy address if a data length was specified.
         */
        if ( ptmtmp_w->tmDLen ) {

            /*
             * Allocate new WCHAR address if we're a string type.
             * Otherwise, point to original address (no conversion needed).
             */
            if ( tmFormIsString(ptmtmp_w->tmForm) ) {

                if ( ptmtmp_w->tmAddr =
                        malloc(len1 = ptmtmp_w->tmDLen*sizeof(WCHAR)) )
                    memset(ptmtmp_w->tmAddr, 0, len1);
                else
                    goto done;  // memory error

            } else {

                ptmtmp_w->tmAddr = ptmtmp_a->tmAddr;
            }

            /*
             * For proper default behavior, zero ANSI address contents if
             * the "don't clear memory" flag is not set.
             */
            if ( !(flag & PCL_FLAG_NO_CLEAR_MEMORY) )
                memset(ptmtmp_a->tmAddr, 0, ptmtmp_a->tmDLen);
        }
    }

    /*
     * Call ParseCommandLineW
     */
    rc = ParseCommandLineW(argc, argv_w, ptm_w, flag);

    /*
     * Copy flags for each TOPMAPW element.  Also, convert to ANSI strings
     * that were present on the command line into caller's TOKMAPA array, if
     * data length was specified.
     */
    for ( ptmtmp_w=ptm_w, ptmtmp_a=ptm_a;
          ptmtmp_w->tmToken != NULL;
          ptmtmp_w++, ptmtmp_a++ ) {

        ptmtmp_a->tmFlag = ptmtmp_w->tmFlag;

        if ( ptmtmp_w->tmDLen &&
             (ptmtmp_w->tmFlag & TMFLAG_PRESENT) &&
             tmFormIsString(ptmtmp_w->tmForm) )
            wcstombs(ptmtmp_a->tmAddr, ptmtmp_w->tmAddr, ptmtmp_w->tmDLen);
    }

done:
    /*
     * Free the argvw array.
     */
    if ( argv_w ) {

        for ( i = 0; i < argc; i++ ) {
            if ( argv_w[i] )
                free(argv_w[i]);
        }
        free(argv_w);
    }

    /*
     * Free the TOKMAPW tokens, string addresses, and TOKMAK array itself.
     */
    if ( ptm_w ) {

        for ( ptmtmp_w=ptm_w; ptmtmp_w->tmToken != NULL; ptmtmp_w++ ) {

            /*
             * Free token.
             */
            free(ptmtmp_w->tmToken);

            /*
             * Free address if a data length was specified and we're a
             * string type.
             */
            if ( ptmtmp_w->tmDLen && tmFormIsString(ptmtmp_w->tmForm) )
                free(ptmtmp_w->tmAddr);
        }
        free(ptm_w);
    }

    /*
     * Return ParseCommandLineW status.
     */
    return(rc);

}  // end ParseCommandLineA


/*****************************************************************************
*
*   IsTokenPresentA (ANSI version)
*
*       Determines if a specified command line token (in given TOKMAPA array)
*       was present on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for.
*
*   EXIT:
*       TRUE if the specified token was present on the command line;
*       FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
IsTokenPresentA( PTOKMAPA ptm,
                 PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) )
            return( (ptm[i].tmFlag & TMFLAG_PRESENT) ? TRUE : FALSE );
    }

    return(FALSE);

}  // end IsTokenPresentA


/*****************************************************************************
*
*   SetTokenPresentA (ANSI version)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is set).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenPresentA( PTOKMAPA ptm,
                  PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag |= TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenPresentA


/*****************************************************************************
*
*   SetTokenNotPresentA (ANSI Versio)
*
*       Forces a specified command line token (in given TOKMAPA array)
*       to be flagged as 'not present' on the command line.
*
*   ENTRY:
*       ptm (input)
*           Points to 0-terminated TOKMAPA array to scan.
*       pToken (input)
*           The token to scan for and set flags.
*
*   EXIT:
*       TRUE if the specified token was found in the TOKMAPA array
*       (TMFLAG_PRESENT flag is reset).  FALSE otherwise.
*
****************************************************************************/

BOOLEAN WINAPI
SetTokenNotPresentA( PTOKMAPA ptm,
                     PCHAR pToken )
{
    int i;

    for ( i = 0; ptm[i].tmToken; i++ ) {
        if ( !strcmp( ptm[i].tmToken, pToken ) ) {
            ptm[i].tmFlag &= ~TMFLAG_PRESENT;
            return(TRUE);
        }
    }

    return(FALSE);

}  // end SetTokenNotPresentA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\toolinit.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/*
 *
 *  Module Name:
 *
 *      toolinit.c
 *
 *  Abstract:
 *
 *      This file contains initialization code that is shared among all
 *      the command line tools.
 *
 *  Author:
 *
 *      Breen Hagan (BreenH) Dec-16-98
 *
 *  Environment:
 *
 *      User Mode
 */

#include <windows.h>
#include <printfoa.h>

/*
 *  Function Implementations.
 */

/*
 *  MassageCommandLine()
 *
 *  Obtains the command line, parses it as a UNICODE string, and returns
 *  it in the ANSI argv style.
 *
 *  Parameters:
 *      IN DWORD    dwArgC: The number of arguments on the command line.
 *
 *  Return Values:
 *      Returns a WCHAR array (WCHAR **), or NULL if an error occurs.
 *      Extended error information is available from GetLastError().
 *
 */

WCHAR**
MassageCommandLine(
    IN DWORD    dwArgC
    )
{
    BOOL    fInQuotes = FALSE, fInWord = TRUE;
    DWORD   i, j, k, l;
    WCHAR   *CmdLine;
    WCHAR   **ArgVW;

    /*
     *  argv can't be used because its always ANSI.
     */

    CmdLine = GetCommandLineW();

    /*
     *  Convert from OEM character set to ANSI.
     */
	
    //OEM2ANSIW(CmdLine, (USHORT)wcslen(CmdLine));

    /*
     * Massage the new command line to look like an argv type
     * because ParseCommandLine() depends on this format
     */

    ArgVW = (WCHAR **)LocalAlloc(
                        LPTR,
                        (dwArgC + 1) * (sizeof(WCHAR *))
                        );
    if(ArgVW == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(NULL);
    }

    /*
     *  Parse CmdLine by spaces (or tabs), ignoring spaces inside double quotes;
     *  i.e. "1 2" is one argument, but cannot contain the double quotes
     *  after parsing. Also, multiple spaces inside quotes are maintained,
     *  while multiple spaces outside of quotes are condensed. Example:
     *
     *  test.exe 1 "2 3"  4"5  6"7 8 '9 10'
     *      will have as arguments:
     *
     *      0:  test.exe
     *      1:  1
     *      2:  2 3
     *      3:  45  67
     *      4:  8
     *      5:  '9
     *      6:  10'
     */

    i = j = k = 0;

    while (CmdLine[i] != (WCHAR)NULL) {
        if (CmdLine[i] == L' '||CmdLine[i] == L'\t') {
            if (!fInQuotes) {
                fInWord = FALSE;

                if (i != k) {
                    CmdLine[i] = (WCHAR)NULL;

                    ArgVW[j] = (WCHAR *)LocalAlloc(
                                            LPTR,
                                            (i - k + 1) * (sizeof(WCHAR))
                                            );
                    if (ArgVW[j] != NULL) {
                        wcscpy(ArgVW[j], &(CmdLine[k]));
                        k = i + 1;
                        j++;

                        if (j > dwArgC) {
                            SetLastError(ERROR_INVALID_PARAMETER);
                            goto CleanUp;
                        }
                    } else {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto CleanUp;
                    }
                } else {
                    k = i + 1;
                }
            }
        } else if (CmdLine[i] == L'\"') {
            size_t nLen = wcslen(&(CmdLine[i]));
            
            //Added by a-skuzin
            //case when we need to have quota inside parameter and use " \" "
            if(i && (CmdLine[i-1] == L'\\')) {
                MoveMemory(
                        &(CmdLine[i-1]),
                        &(CmdLine[i]),
                        (nLen+1) * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                i--;
                fInWord = TRUE;
                goto increment;
            }
            //end of "added by a-skuzin"

            //  Special case a double quote by itself or at the end of the line

            if (fInQuotes && (l == i)) {
                if ((nLen == 1) || (CmdLine[i + 1] == L' ') || (CmdLine[i + 1] == L'\t')) {
                    k = i;
                    CmdLine[k] = (WCHAR)NULL;
                    fInQuotes = FALSE;
                    goto increment;
                }
            }

            if (fInQuotes && fInWord) {
                if ((nLen == 2) && (CmdLine[i + 1] == L'\"')) {
                    MoveMemory(
                        &(CmdLine[i]),
                        &(CmdLine[i + 1]),
                        nLen * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                    goto increment;
                }

                if ((nLen >= 3) &&
                    (CmdLine[i + 1] == L'\"') &&
                    (CmdLine[i + 2] != L' ') &&
                    (CmdLine[i + 2] != L'\t')) {
                    fInQuotes = FALSE;
                    MoveMemory(
                        &(CmdLine[i]),
                        &(CmdLine[i + 1]),
                        nLen * sizeof(WCHAR) // drop 1 char, add NULL
                        );
                    goto increment;
                }

                if ((nLen >= 3) &&
                    (CmdLine[i + 1] == L'\"') &&
                    (CmdLine[i + 2] == L' ') &&
					(CmdLine[i + 2] == L'\t')) {
                    goto increment;
                }
            }

            if (!fInQuotes && fInWord && (nLen == 1) && (j == 0)) {
                goto increment;
            }

            fInQuotes = !fInQuotes;
            if (fInQuotes && !fInWord) {
                fInWord = TRUE;
                l = i;
            }

            MoveMemory(
                &(CmdLine[i]),
                &(CmdLine[i + 1]),
                nLen * sizeof(WCHAR) // drop 1 char, add NULL
                );

            i--;
        } else {
            fInWord = TRUE;
        }

increment:
        i++;
    }

    if (i != k) {
        if (j >= dwArgC) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto CleanUp;
        }

        ArgVW[j] = (WCHAR *)LocalAlloc(
                            LPTR,
                                (i - k + 1) * (sizeof(WCHAR))
                                );
        if (ArgVW[j] != NULL) {
            wcscpy(ArgVW[j], &(CmdLine[k]));
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto CleanUp;
        }
    } else if (fInQuotes && (l == i)) {
        if (j >= dwArgC) {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto CleanUp;
        }

        ArgVW[j] = (WCHAR *)LocalAlloc(
                            LPTR,
                                (i - k + 1) * (sizeof(WCHAR))
                                );
        if (ArgVW[j] != NULL) {
            wcscpy(ArgVW[j], &(CmdLine[k]));
        } else {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto CleanUp;
        }
    }

    ArgVW[dwArgC] = (WCHAR)NULL;

    return(ArgVW);

CleanUp:

    for (i = 0; i < dwArgC; i++) {
        if (ArgVW[i] != NULL) {
            LocalFree(ArgVW[i]);
        }
    }

    LocalFree(ArgVW);

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\utilsubres.h ===
//  Copyright (c) 1999 Microsoft Corporation
// utilsubres.h

/*
   these ids are for the strings used by utilsub.lib.
   these must not conflict with any of the users of utilsub.lib
*/

#define BASE_UTILSUB_STRING                     1000
#define IDS_UNKNOWN_USERNAME                    BASE_UTILSUB_STRING+0
#define IDS_MAX_CMDLINE_EXCEEDED                BASE_UTILSUB_STRING+1
#define IDS_TS_SYS_UTIL_NOT_FOUND               BASE_UTILSUB_STRING+2
#define IDS_BAD_INTERNAL_PROGNAME               BASE_UTILSUB_STRING+3
#define IDS_CREATEPROCESS_FAILED                BASE_UTILSUB_STRING+4
#define IDS_WAITFORSINGLEOBJECT_FAILED          BASE_UTILSUB_STRING+5
#define IDS_DEVICE_ENUM_CANT_LOAD               BASE_UTILSUB_STRING+6
#define IDS_DEVENUM_NO_ENTRY_POINT              BASE_UTILSUB_STRING+7
#define IDS_ERROR_MEMORY                        BASE_UTILSUB_STRING+8
#define IDS_DEVICE_ENUM_FAILED                  BASE_UTILSUB_STRING+9
#define IDS_INTERNAL_ERROR_1                    BASE_UTILSUB_STRING+10
#define IDS_INTERNAL_ERROR_2                    BASE_UTILSUB_STRING+11
#define IDS_ADD_SRCH_LIST_NO_MEMORY_MALLOC      BASE_UTILSUB_STRING+12
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP1     BASE_UTILSUB_STRING+13
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP2     BASE_UTILSUB_STRING+14
#define IDS_ADD_SRCH_LIST_NO_MEMORY_STRDUP3     BASE_UTILSUB_STRING+15
#define IDS_TOO_MANY_ARGUMENTS                  BASE_UTILSUB_STRING+16
#define IDS_ARGS_TO_LIST_NOT_ENOUGH_MEMORY      BASE_UTILSUB_STRING+17
#define IDS_ARGS_TO_LIST_ARG_BUFFER_SMALL       BASE_UTILSUB_STRING+18
#define IDS_ERROR_NUMBER                        BASE_UTILSUB_STRING+19
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\procutil.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  PROCUTIL.C
*
*  Various useful utilities for dealing with processes
*  that are useful across a range of utilities and apps.
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

// from helpers.c
BOOL GetResourceStringFromUtilDll(UINT uID, LPTSTR szBuffer, int iBufferSize);
void ErrorOutFromResource(UINT uiStringResource, ...);

#include "utilsubres.h" // resources refrenced in this file.
        

/*
 * Local function prototypes.
 */
VOID LookupSidUser( PSID pSid, PWCHAR pUserName, PULONG pcbUserName );

/*
 * RefreshProcessObjectCaches()
 *
 *  Refresh (invalidate) any caches that may be used by process object
 *  utilities.
 *
 * This is currently a place holder, but is here so that utilities can call
 * it, thus being isolated from any future decisions to add caching.
 */
VOID WINAPI
RefreshProcessObjectCaches()
{
    RefreshUserSidCrcCache();
}

/******************************************************************************
 *
 * ProcessObjectMatch
 *
 * General Name match function against a process.
 *
 * The multi-user admin utilities can take a user name, winstation name,
 * a winstation id, or process id as an argument to a command that targets
 * a process for some action (query status, kill, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given process because the name represents the NT user
 * account, a winstations system name, the winstations unique id, or the
 * processes unique id.
 *
 * The various information about a process is supplied by the caller. Because
 * of the way processes are enumerated from the NT system, it is easier
 * and faster for the caller to supply this information than for the routine
 * to retrieve it itself. This could be folded into a general EnumerateProcess()
 * if needed. Currently this routine serves the purpose of having one unified
 * way of handling process objects across all utilities.
 *
 *
 * Matching:
 *
 *  An integer number is assumed to be an NT process ID unless NumberIsLogonId
 *  is set, which then says to treat it as a LogonId.
 *
 *  A name starting with a character is tested first as a winstation name, then
 *  as a user name, finally as a program image name.  A user or group name
 *  could stand alone, or be preceded by a '\' to be [somewhat] compatible
 *  with the OS/2 product.
 *
 * Parameters:
 *
 *  Pid (input)
 *      Windows NT unique process identifier
 *  LogonId (input)
 *      Logon (also called Session) ID the process is executing on.
 *  NumberIsLogonId (input)
 *      Treat a number in pMatchName as a LogonId not an PID number.
 *  pMatchName (input)
 *      Name for match testing
 *  pWinStationName (input)
 *      Name of WinStation for process.
 *  pUserName (input)
 *      Name of User for process.
 *  pImageName (input)
 *      Image name of executing program for process.
 *
 *****************************************************************************/

BOOLEAN WINAPI
ProcessObjectMatch( HANDLE Pid,
                    ULONG LogonId,
                    int NumberIsLogonId,
                    PWCHAR pMatchName,
                    PWCHAR pWinStationName,
                    PWCHAR pUserName,
                    PWCHAR pImageName )
{
    ULONG tmp;
    HANDLE htmp;

    /*
     * Check for wild card
     */
    if( pMatchName[0] == L'*' ) return( TRUE );

    /*
     * If someone puts a '\' in front of pMatchName, strip it off
     */
    if( pMatchName[0] == L'\\' ) pMatchName++;

    /*
     * First, if the match name is a number, check for == to process ID or
     * LogonId.
     */
    if( iswdigit( pMatchName[0] ) ) {
        tmp = wcstol( pMatchName, NULL, 10 );
        htmp = LongToPtr (tmp);

            if( NumberIsLogonId && (tmp == LogonId) )
            return( TRUE );
            else if( htmp == Pid )
                return( TRUE );
        else
                return( FALSE );
    }

    /*
     * Then, check the match name against the WinStation Name of the process.
     */
    if ( !_wcsicmp( pWinStationName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Then, check the match name against the UserName of the process.
     */
    if( !_wcsicmp( pUserName, pMatchName ) ) {
        return( TRUE );
    }

    /*
     * Finally, check the match name against the image name of the process.
     */
    if( !_wcsicmp( pImageName, pMatchName ) ) {
        return(TRUE);
    }

    return( FALSE );
}


/*
 * This is the cache maintained by the GetUserNameFromSid function
 *
 * It is thread safe through the use of ULock.
 */

typedef struct TAGUSERSIDLIST {
    struct TAGUSERSIDLIST *Next;
    USHORT SidCrc;
    WCHAR UserName[USERNAME_LENGTH+1];
} USERSIDLIST, *PUSERSIDLIST;

static PUSERSIDLIST pUList = NULL;
static RTL_CRITICAL_SECTION ULock;
static BOOLEAN ULockInited = FALSE;

/***************************************************************************
 *
 *  InitULock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitULock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( ULockInited == FALSE ){
       status = RtlInitializeCriticalSection( &ULock );
       if (status == STATUS_SUCCESS) {
           ULockInited = TRUE;
       }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}


/***************************************************************************
 *
 * RefreshUserSidCrcCache
 *
 *  Invalidate the User/SidCrc cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshUserSidCrcCache( )
{
    NTSTATUS status = STATUS_SUCCESS;
    PUSERSIDLIST pEntry, pNext;

    if( pUList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pUList = NULL;

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 *
 * GetUserNameFromSid
 *
 *  Attempts to retrieve the user (login) name of the process by first looking
 *  in our User/SidCrc cache table, then (if no match) looking up the SID in
 *  the SAM database and adding the new entry to the User/SidCrc table.
 *
 *  Input
 *
 *   IN pUserSid   Sid pointer
 *
 *   OUT NameBuf   WCHAR pointer to buffer for name
 *
 *   IN/OUT  pBufSize   PULONG NameBuf size ( in WCHARS)
 *
 *  Will always return a user name, which will be "(unknown)" if the SID is
 *  invalid or can't determine the user/SID relationship for any other reason.
 *
 *****************************************************************************/

VOID WINAPI
GetUserNameFromSid( PSID pUserSid, PWCHAR pBuffer, PULONG pcbBuffer )
{
    NTSTATUS status = STATUS_SUCCESS;
    USHORT SidCrc = 0;
    PUSERSIDLIST pEntry;

    /*
     * Make sure critical section has been inited
     */
    if( !ULockInited ) {
       status = InitULock();
    }

    /*
     * Determine SID length in bytes and calculate a 16-bit CRC for it,
     * to facilitate quick matching.
     */
    if ( pUserSid )
        SidCrc = CalculateCrc16( (PBYTE)pUserSid,
                                 (USHORT)GetLengthSid(pUserSid) );

    /*
     * First: Before performing the expensive LookupAccountSid() function,
     * see if we've encountered this SID already, and match the user name
     * if so.
     */
    if ( status == STATUS_SUCCESS && pUList ) {

        RtlEnterCriticalSection( &ULock );

        pEntry = pUList;

        while( pEntry ) {

            if ( SidCrc == pEntry->SidCrc ) {

                wcsncpy( pBuffer, pEntry->UserName, (*pcbBuffer)-1 );
                pBuffer[(*pcbBuffer)-1] = 0;
                *pcbBuffer = wcslen(pBuffer);
                RtlLeaveCriticalSection( &ULock );
                return;
            }
            pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &ULock );
    }

    /*
     * Last resort: Determine the user name associated with the SID using
     * the LookupAccountSid() API, embedded in our local function
     * LookupSidUser().
     */
    LookupSidUser( pUserSid, pBuffer, pcbBuffer );

    /*
     * Add this new User/Sid relationship in our User/Sid cache list.
     */
    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &ULock );

        if ( (pEntry = (PUSERSIDLIST)malloc(sizeof(USERSIDLIST))) ) {

            pEntry->SidCrc = SidCrc;
            wcsncpy( pEntry->UserName, pBuffer, USERNAME_LENGTH);
            pEntry->UserName[USERNAME_LENGTH] = 0;
            pEntry->Next = pUList;
            pUList = pEntry;
        }

        RtlLeaveCriticalSection( &ULock );
    }
}


/******************************************************************************
 * LookupSidUser
 *
 *      Fetch the user name associated with the specified SID.
 *
 *  ENTRY:
 *      pSid (input)
 *          Points to SID to match to user name.
 *      pUserName (output)
 *          Points to buffer to place the user name into.
 *      pcbUserName (input/output)
 *          Specifies the size in WCHARS of the user name buffer.  The returned
 *          user name will be truncated to fit this buffer (including NUL
 *          terminator) if necessary and this variable set to the number of
 *          characters copied to pUserName.
 *
 *  EXIT:
 *
 *      LookupSidUser() will always return a user name.  If the specified
 *      SID fails to match to a user name, then the user name "(unknown)" will
 *      be returned.
 *
 *****************************************************************************/

VOID
LookupSidUser( PSID pSid,
               PWCHAR pUserName,
               PULONG pcbUserName )
{
    WCHAR DomainBuffer[DOMAIN_LENGTH], UserBuffer[USERNAME_LENGTH];
    DWORD cbDomainBuffer = sizeof(DomainBuffer) / sizeof(DomainBuffer[0]);
    DWORD cbUserBuffer = sizeof(UserBuffer) / sizeof(UserBuffer[0]);
    DWORD Error;
    PWCHAR pDomainBuffer = NULL, pUserBuffer = NULL;
    SID_NAME_USE SidNameUse;

    /*
     * Fetch user name from SID: try user lookup with a reasonable Domain and
     * Sid buffer size first, before resorting to alloc.
     */
    if ( !LookupAccountSid( NULL, pSid,
                            UserBuffer, &cbUserBuffer,
                            DomainBuffer, &cbDomainBuffer, &SidNameUse ) ) {

        if ( ((Error = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) ) {

            if ( cbDomainBuffer > sizeof(DomainBuffer)/sizeof(DomainBuffer[0]) ) {

                if ( !(pDomainBuffer =
                        (PWCHAR)malloc(
                            cbDomainBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadDomainAlloc;
                }
            }

            if ( cbUserBuffer > sizeof(UserBuffer)/sizeof(UserBuffer[0]) ) {

                if ( !(pUserBuffer =
                        (PWCHAR)malloc(
                            cbUserBuffer * sizeof(WCHAR))) ) {

                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    goto BadUserAlloc;
                }
            }

            if ( !LookupAccountSid( NULL, pSid,
                                     pUserBuffer ?
                                        pUserBuffer : UserBuffer,
                                     &cbUserBuffer,
                                     pDomainBuffer ?
                                        pDomainBuffer : DomainBuffer,
                                     &cbDomainBuffer,
                                     &SidNameUse ) ) {

                Error = GetLastError();
                goto BadLookup;
            }

        } else {

            goto BadLookup;
        }
    }

    /*
     * Copy the user name into the specified buffer, truncating if necessary.
     */
    wcsncpy( pUserName, pUserBuffer ? pUserBuffer : UserBuffer,
              (*pcbUserName)-1 );
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);

    /*
     * Free our allocs (if any) and return.
     */
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    return;

/*--------------------------------------
 * Error clean-up and return...
 */
BadLookup:
BadUserAlloc:
BadDomainAlloc:
    if ( pDomainBuffer )
        free(pDomainBuffer);
    if ( pUserBuffer )
        free(pUserBuffer);
    GetResourceStringFromUtilDll(IDS_UNKNOWN_USERNAME, pUserName, (*pcbUserName)-1);
    pUserName[(*pcbUserName)-1] = 0;
    *pcbUserName = wcslen(pUserName);
    return;
}

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/

BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\utilsub\wstutil.c ===
//  Copyright (c) 1998-1999 Microsoft Corporation
/******************************************************************************
*
*  WSTUTIL.C
*
*  Various useful utilities for dealing with multi-user WinStations and User
*  accounts that are useful across a range of utilities and apps.
*
*
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <process.h>
#include <string.h>
#include <malloc.h>

#include <winstaw.h>
#include <utilsub.h>

/*
 * RefreshAllCaches
 *
 *  Invalidate any caches maintained by the UTILSUB.DLL
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *  Any caches in the UTILSUB.DLL have been invalidated insuring fresh
 *  system information on future calls.
 *
 */
VOID WINAPI
RefreshAllCaches()
{
    RefreshWinStationCaches();
    RefreshProcessObjectCaches();
}

/*
 * RefreshWinStationCaches
 *
 *  Invalidate any caches maintained by the WinStation helper utilities.
 *
 *  This does not need to be called for utilities that exit when done, but
 *  are for server, or monitoring type programs that need to periodicly
 *  see the latest system information.
 *  IE: A new user could have logged onto a given winstation since the last
 *      call.
 *
 *
 * Exit
 *
 *   Makes sure that any WinStation helper utility calls will return the
 *   system information at least up to date as the time that this call
 *   was made.
 *
 */
VOID WINAPI
RefreshWinStationCaches()
{
    RefreshWinStationObjectCache();
    RefreshWinStationNameCache();
}

/*
 * GetCurrentLogonId
 *
 * Gets the WinStation ID for the current processes WinStation
 *
 * Exit
 *
 *  ID of the current processes WinStation
 *
 */

ULONG WINAPI
GetCurrentLogonId()
{
    return( NtCurrentPeb()->SessionId );
}

/*
 * GetCurrentWinStationName
 *
 * Get the current UNICODE name for the WinStation for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator).
 *
 *   pName - Pointer to wide character buffer for name
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentWinStationName( PWCHAR pName, int MaxSize )
{
    GetWinStationNameFromId( NtCurrentPeb()->SessionId, pName, MaxSize );
}

/*
 * This is the cache maintained by the GetWinStationNameFromId function
 *
 * It is thread safe through the use of WLock.
 */

typedef struct TAGWINSTATIONLIST {
    struct TAGWINSTATIONLIST *Next;
    LOGONID LogonId;
} WINSTATIONLIST, *PWINSTATIONLIST;

static PWINSTATIONLIST pWList = NULL;
static RTL_CRITICAL_SECTION WLock;
static BOOLEAN WLockInited = FALSE;

/***************************************************************************
 *
 *  InitWLock
 *
 *  Since we do not require the user to call an initialize function,
 *  we must initialize our critical section in a thread safe manner.
 *
 *  The problem is, a critical section is needed to guard against multiple
 *  threads trying to init the critical section at the same time.
 *
 *  The solution that Nt uses, in which RtlInitializeCriticalSection itself
 *  uses, is to wait on a kernel supported process wide Mutant before proceding.
 *  This Mutant almost works by itself, but RtlInitializeCriticalSection does
 *  not wait on it until after trashing the semaphore count. So we wait on
 *  it ourselves, since it can be acquired recursively.
 *
 ***************************************************************************/
NTSTATUS InitWLock()
{
    NTSTATUS status = STATUS_SUCCESS;

    RtlEnterCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    /*
     * Make sure another thread did not beat us here
     */
    if( WLockInited == FALSE ){
        status = RtlInitializeCriticalSection( &WLock );

        if (status == STATUS_SUCCESS) {
            WLockInited = TRUE;
        }
    }

    RtlLeaveCriticalSection((PRTL_CRITICAL_SECTION)NtCurrentPeb()->LoaderLock);

    return status;
}

/***************************************************************************
 *
 * RefreshWinStationNameCache
 *
 *  Invalidate the WinStation Name cache so that the newest information
 *  will be fetched from the system.
 *
 ***************************************************************************/

VOID WINAPI
RefreshWinStationNameCache( )
{
    NTSTATUS status = STATUS_SUCCESS;

    PWINSTATIONLIST pEntry, pNext;

    if( pWList == NULL ) return;

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        pEntry = pWList;

        while( pEntry ) {
           pNext = pEntry->Next;
           free( pEntry );
           pEntry = pNext;
        }

        pWList = NULL;

        RtlLeaveCriticalSection( &WLock );
    }
}

/*
 * GetWinStationNameFromId
 *
 *  Attempt to retrieve the WinStationName for the given LogonId.
 *
 *  Parameters:
 *
 *     LogonId (input)
 *       Unique LogonId
 *
 *     pName (output)
 *       Pointer to buffer for name
 *
 *     MaxSize (input)
 *       Maximum number of characters in buffer (including terminator).
 *
 *  Returns
 *     TRUE if name was retreived, FALSE otherwise.
 *
 */

BOOLEAN WINAPI
GetWinStationNameFromId( ULONG LogonId, PWCHAR pName, int MaxSize )
{    
    return xxxGetWinStationNameFromId( SERVERNAME_CURRENT , LogonId , pName , MaxSize );    
}

/*----------------------------------------------------------------------------------------
/*
 * xxxGetWinStationNameFromId
 *
 *  Attempt to retrieve the WinStationName for the given LogonId.
 *
 *  Parameters:
 *  
 *     hServer ( input )
 *       rpc handle to termsrv
 *
 *     LogonId (input)
 *       Unique LogonId
 *
 *     pName (output)
 *       Pointer to buffer for name
 *
 *     MaxSize (input)
 *       Maximum number of characters in buffer (including terminator).
 *
 *  Returns
 *     TRUE if name was retreived, FALSE otherwise.
 *
 */

BOOLEAN WINAPI
xxxGetWinStationNameFromId( HANDLE hServer , ULONG LogonId, PWCHAR pName, int MaxSize )
{
    NTSTATUS status = STATUS_SUCCESS;
    PLOGONID pIdBase, pId;
    int          rc;
    ULONG        Count;
    PWINSTATIONLIST pEntryBase, pEntry;

    // Since We do not have a WinStationNamefromId Sm Api like we do for
    // LogonIdfromName, we will perform a WinStationEnumerate function across
    // all WinStations known by the Session Manager, and store them in a locally
    // maintained list. We do this so we that this search against the session
    // manager is not done every time we're called.
    //
    // Another alternative that was tested is to open the WinStation itself
    // and then do a WinStationQueryInformation against it in order to
    // retrieve its name from itself. This is much slower because we must
    // set up and tear down an LPC connection to each WinStation, as opposed
    // to the one connection we get to the session manager.

    /*
     * Make sure critical section has been inited
     */
    if( !WLockInited ) {
       status = InitWLock();
    }

    if (status == STATUS_SUCCESS) {
        RtlEnterCriticalSection( &WLock );

        // Initialize the list the first time
        if( pWList == NULL ) {

            rc = WinStationEnumerate( hServer, &pIdBase, &Count );
            if( rc ) {

                /*
                 * Allocate an Entry for each enumerated winstation.
                 */
                pEntryBase = (PWINSTATIONLIST)malloc( Count * sizeof(WINSTATIONLIST) );
                    if( pEntryBase == NULL ) {

                   pWList = NULL; // We are having severe problems
                   SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                   WinStationFreeMemory(pIdBase);
                   RtlLeaveCriticalSection( &WLock );
                             return( FALSE );
                         }

               /*
                * Load up Entries.
                */
                for ( pEntry = pEntryBase, pId = pIdBase;
                      Count ;
                      Count--, pEntry++, pId++ ) {

                    pEntry->LogonId = *pId;
                    pEntry->Next = pWList;
                    pWList = pEntry;
                }

                /*
                 * Free enumerate buffer.
                 */
                WinStationFreeMemory(pIdBase);
                 }

        } // End if pWList == NULL

        pEntry = pWList;
        while ( pEntry ) {

                if( pEntry->LogonId.LogonId == LogonId ) {

                wcsncpy( pName, pEntry->LogonId.WinStationName, MaxSize-1 );
                pName[MaxSize-1] = 0;
                RtlLeaveCriticalSection( &WLock );
                     return( TRUE );
                }
           pEntry = pEntry->Next;
        }

        RtlLeaveCriticalSection( &WLock );
    }

    // If we can not find its name, print its ID #

    wsprintf( pName, L"ID %d", LogonId );

    return( TRUE );
}

/*----------------------------------------------------------------------------------------
/*
 * GetCurrentUserName
 *
 * Get the current UNICODE name for the logon USER for this process
 *
 * Input:
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
VOID WINAPI
GetCurrentUserName( PWCHAR pName, int MaxSize )
{
    /*
     * The quickest way appears to open the current processes WinStation and
     * get the name from it. The other way would be to open the process, then
     * its token, extract the SID, then lookup the SID in the SAM database.
     * We have conviently stored the user name in the WinStation at Logon
     * time, so we'll use that.
     */
    GetWinStationUserName( SERVERNAME_CURRENT , LOGONID_CURRENT, pName, MaxSize );
    return;
}


/*
 * GetWinStationUserName
 *
 * Get the UNICODE name for the USER for the winstation
 *
 * Input:
 *
 *   hServer - handle to termsrv
 *
 *   LogonId - integer identifier for WinStation
 *
 *   pName - Pointer to wide character buffer for name
 *
 *   MaxSize - Maximum number of characters in buffer (including terminator)
 *
 *
 * Output:
 *
 */
BOOLEAN WINAPI
GetWinStationUserName( HANDLE hServer , ULONG LogonId, PWCHAR pName, int MaxSize )
{
    BOOLEAN rc;
    ULONG ReturnLength;
    WINSTATIONINFORMATION Info;

    if( MaxSize == 0) return( FALSE );

    memset( &Info, 0, sizeof(WINSTATIONINFORMATION) );

    rc = WinStationQueryInformation( hServer,
                                     LogonId,
                                     WinStationInformation,
                                     (PVOID)&Info,
                                     sizeof(WINSTATIONINFORMATION),
                                     &ReturnLength);
    if(!rc){
        pName[0] = 0;
        return( FALSE );
    }
    if(ReturnLength != sizeof(WINSTATIONINFORMATION)) {
        pName[0] = 0; // Version mismatch
        return( FALSE );
    }
    /*
     * Now copy the name out
     */
    if( MaxSize > USERNAME_LENGTH ) {
        MaxSize = USERNAME_LENGTH;
    }
    wcsncpy( pName, Info.UserName, MaxSize-1 );
    pName[MaxSize-1] = 0; // insure null termination if string is truncated
    return( TRUE );
}


/*
 * These variables maintain a one entry cache so that we
 * do not have to keep querying the winstation (causes an LPC)
 * each time called.
 */
static ULONG CachedId = (ULONG)(-1);
static WCHAR CachedUserName[USERNAME_LENGTH];

/**************************************************************************
*
* RefreshWinStationObjectCache
*
* Flush the cache for the WinStationObject name comparision function.
*
**************************************************************************/

VOID WINAPI
RefreshWinStationObjectCache()
{
    CachedId = (ULONG)(-1);
    CachedUserName[0] = 0;
}

/*
 * WinStationObjectMatch
 *
 * General Name match function against a WinStation.
 *
 * The admin utilities can take a user name, winstation name, or
 * a winstation id as an argument to a command that targets a winstation
 * for some action (send a message, query status, reset, etc.)
 *
 * This function does general compares of the supplied name to see if it
 * applies to the given winstation because the name represents the logged
 * on user of the winstation, the winstations system name when attached, or
 * the winstations unique id.
 *
 *
 * NOTE: The caching for this function assumes typical use of comparing this
 *       winstation against a list of names across multiple calls.
 *       It does not optimize for comparing one name at a time across all
 *       winstation(s) in succession.
 *
 * Parameters:
 *
 *   hServer ( input ) remote termsrv
 *
 *   Id (input) WinStation Id for do the match against
 *
 *   pName (input) UNICODE name for match testing
 */

BOOLEAN WINAPI
WinStationObjectMatch( HANDLE hServer , PLOGONID Id, PWCHAR pName )
{
    ULONG tmp;

    /*
     * Handle the wild card case
     */
    if( pName[0] == L'*' ) {
        return( TRUE );
    }

    /*
     * See if the supplied name is the name assigned to the WinStation
     */
    if( !_wcsnicmp( pName, Id->WinStationName, WINSTATIONNAME_LENGTH ) ) {
       return( TRUE );
    }

    /*
     * See if it represents the numerical id for the winstation
     */
    if( iswdigit( pName[0] ) ) {
       tmp = (ULONG)wcstol( pName, NULL, 10 );
       if( tmp == Id->LogonId ) {
          return( TRUE );
       }
    }

    /*
     * Else extract the logged on user name from the winstation itself
     * and compare this.
     */
    if( CachedId == Id->LogonId ) {
       if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
          return( TRUE );
       }
    }

    if ( Id->State == State_Down )
        return( FALSE );

    if( GetWinStationUserName( hServer , Id->LogonId, CachedUserName, USERNAME_LENGTH ) ) {
        CachedId = Id->LogonId;
    }
    else {
       CachedId = (ULONG)(-1); // In case name was trashed
       return( FALSE );
    }

    if( !_wcsnicmp( CachedUserName, pName, USERNAME_LENGTH ) ) {
       return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\wfprof\tsprof.c ===
/******************************************************************************
*
*   TSPROF.C
*
*   Description:
*
*   Copyright Citrix Systems Inc. 1997
*
*   Copyright (c) 1998 - 1999 Microsoft Corporation
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 11-Apr-1997
*
*   $Log:   N:\nt\private\utils\citrix\wfprof\VCS\tsprof.c  $
*
*     Rev 1.5   May 04 1998 17:46:34   tyl
*  bug 2019 - oem to ansi
*
*     Rev 1.4   Jan 30 1998 20:46:22   yufengz
*  change the file name
*
*     Rev 1.3   Jun 26 1997 18:26:30   billm
*  move to WF40 tree
*
*     Rev 1.2   23 Jun 1997 16:20:02   butchd
*  update
*
*     Rev 1.1   29 Apr 1997 21:35:20   kurtp
*  I fixed a bug in this file, update, duh!
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <locale.h>
#include <winnlsp.h>

#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmremutl.h>

#include <winstaw.h>
#include <utilsub.h>
#include <printfoa.h>

#include "wfprof.h"



/*=============================================================================
==  Macros
=============================================================================*/


/*=============================================================================
==  Variables
=============================================================================*/

WCHAR * pServerName = NULL;

WCHAR DomainName[MAX_IDS_LEN + 1];
WCHAR SourceUser[MAX_IDS_LEN + 1];
WCHAR DestinationUser[MAX_IDS_LEN + 1];
WCHAR WFProfilePath[MAX_IDS_LEN + 1];


/*=============================================================================
==   Data types and definitions
=============================================================================*/

USHORT copy_flag    = FALSE;
USHORT update_flag  = FALSE;
USHORT query_flag   = FALSE;
USHORT help_flag    = FALSE;
USHORT local_flag   = FALSE;

TOKMAP ptm[] = {

      {L" ",        TMFLAG_REQUIRED, TMFORM_STRING,  MAX_IDS_LEN,    SourceUser},
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DestinationUser},
      {L"/Domain",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DomainName},
      {L"/Profile", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WFProfilePath},
      {L"/Local",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &local_flag},

      {L"/Copy",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &copy_flag},
      {L"/Q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &query_flag},
      {L"/Update",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &update_flag},

      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};


// max length of the locale string
#define MAX_LOCALE_STRING 64

#define SOURCE_USER  (ptm[0].tmFlag & TMFLAG_PRESENT)
#define DEST_USER    (ptm[1].tmFlag & TMFLAG_PRESENT)
#define DOMAIN       (ptm[2].tmFlag & TMFLAG_PRESENT)
#define PROFILE_PATH (ptm[3].tmFlag & TMFLAG_PRESENT)
#define LOCAL        (ptm[4].tmFlag & TMFLAG_PRESENT)



/*=============================================================================
==  Functions
=============================================================================*/

void Usage( BOOLEAN bError );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( int argc, char **argv )
{
    int   i;
    int   Error;
    ULONG ReturnLength;
    WCHAR **argvW;
    USERCONFIG UserConfig;
    WCHAR      wszString[MAX_LOCALE_STRING + 1];

    setlocale(LC_ALL, ".OCP");

    // We don't want LC_CTYPE set the same as the others or else we will see
    // garbage output in the localized version, so we need to explicitly
    // set it to correct console output code page
    _snwprintf(wszString, sizeof(wszString)/sizeof(WCHAR), L".%d", GetConsoleOutputCP());
    wszString[sizeof(wszString)/sizeof(WCHAR) - 1] = L'\0';
    _wsetlocale(LC_CTYPE, wszString);

    SetThreadUILanguage(0);

    /*
     *  Massage the command line.
     */

    argvW = MassageCommandLine((DWORD)argc);
    if (argvW == NULL) {
        ErrorPrintf(IDS_ERROR_MALLOC);
        return(FAILURE);
    }

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    Error = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag ) {

        Usage(FALSE);
        return(SUCCESS);
    }
    else if ( Error ||
        (!copy_flag && !update_flag && !query_flag) ||
        (copy_flag && update_flag) ||
        (copy_flag && query_flag) ||
        (update_flag && query_flag) ||
        (copy_flag && !DEST_USER) ||
        (update_flag && !PROFILE_PATH) ||
        (!DOMAIN && !LOCAL) ||
        (DOMAIN && LOCAL) ) {

        Usage(TRUE);
        return(FAILURE);
    }

    /*
     *  Get server name for domain name
     */
    if ( LOCAL ) {
        pServerName = NULL;
        Error = ERROR_SUCCESS;
    }
    else {
        Error = NetGetDCName( (WCHAR)NULL, DomainName, (LPBYTE *)&pServerName );
    }

    if ( Error == ERROR_SUCCESS ) {

        /*
         *  Update or Query
         */
        if ( update_flag || query_flag ) {


query_it:

            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
            if(Error != ERROR_SUCCESS)
            {
                Error = RegDefaultUserConfigQuery(pServerName,
                                                            &UserConfig,                // address for userconfig buffer
                                                            sizeof(UserConfig),         // size of buffer
                                                            &ReturnLength);
            }

            if ( Error == ERROR_SUCCESS )
            {

                if ( query_flag )
                {
                    TCHAR tchOutput[ 512 ];
                    TCHAR tchFormat[ 256 ];
                    DWORD_PTR dw[ 3 ];

                    dw[ 0 ] = (DWORD_PTR)(ULONG_PTR)&DomainName[0];
                    dw[ 1 ] = (DWORD_PTR)(ULONG_PTR)&SourceUser[0];
                    dw[ 2 ] = (DWORD_PTR)(ULONG_PTR)&UserConfig.WFProfilePath[0];

                    LoadString( NULL , IDS_QUERY3 , tchFormat , sizeof( tchFormat ) / sizeof( TCHAR ) );


                    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   tchFormat ,
                                   0 ,
                                   0 ,
                                   tchOutput ,
                                   sizeof( tchOutput ) / sizeof( TCHAR ) ,
                                   ( va_list * )&dw );

                    My_wprintf( tchOutput );



                    /*
                    StringMessage( IDS_QUERY1, 
                                   DomainName);
                    StringMessage( IDS_QUERY2,
                                   SourceUser);
                    StringMessage( IDS_QUERY3,
                                   UserConfig.WFProfilePath );
                                   */
                }
                else
                {

                            wcscpy( UserConfig.WFProfilePath, WFProfilePath );

                            Error = RegUserConfigSet( pServerName,
                                                      SourceUser,
                                                      &UserConfig,
                                                      sizeof(UserConfig) );

                            if ( Error == ERROR_SUCCESS )
                            {
                                query_flag = TRUE;
                                goto query_it;
                            }
                            else
                            {
                                ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                            }
                    }


            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
        else if ( copy_flag ) {

            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS )
            {
    
                if ( query_flag )
                {
                    TCHAR tchOutput[ 512 ];
                    TCHAR tchFormat[ 256 ];
                    ULONG_PTR dw[ 3 ];

                    dw[ 0 ] = (ULONG_PTR)&DomainName[0];
                    dw[ 1 ] = (ULONG_PTR)&SourceUser[0];
                    dw[ 2 ] = (ULONG_PTR)&UserConfig.WFProfilePath[0];

                    LoadString( NULL , IDS_QUERY3 , tchFormat , sizeof( tchFormat ) / sizeof( TCHAR ) );


                    FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                   tchFormat ,
                                   0 ,
                                   0 ,
                                   tchOutput ,
                                   sizeof( tchOutput )  / sizeof( TCHAR ) ,
                                   ( va_list * )&dw );

                    My_wprintf( tchOutput );

                    /*
                    StringMessage( IDS_QUERY1, 
                                   DomainName);
                    StringMessage( IDS_QUERY2,
                                   SourceUser);
                    StringMessage( IDS_QUERY3,
                                   UserConfig.WFProfilePath );
                    */
                }
                else {

                    if ( PROFILE_PATH ) {
                        wcscpy( UserConfig.WFProfilePath, WFProfilePath );
                    }

                    Error = RegUserConfigSet( pServerName,
                                              DestinationUser,
                                              &UserConfig,
                                              sizeof(UserConfig) );

                    if ( Error != ERROR_SUCCESS ) {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
    }
    else {
        ErrorPrintf(IDS_ERROR_GET_DC, Error, Error);
    }

    return( (Error == ERROR_SUCCESS ? SUCCESS : FAILURE) );
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    }

    Message(IDS_USAGE1);
    Message(IDS_USAGE2);
    Message(IDS_USAGE3);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\wfprof\wfprof.h ===
/***********************************************************************
*
*  WFPROF.H
*
*  Copyright Citrix Systems Inc. 1997
*
*  Copyright (c) 1998 - 1999 Microsoft Corporation
*
*************************************************************************/

/*
 * General application definitions.
 */
#define SUCCESS 0
#define FAILURE 1

#define MAX_IDS_LEN   256     // maximum length that the input parm can be


/*
 * Resource string IDs
 */
#define IDS_ERROR_INVALID_PARAMETERS                    100
#define IDS_ERROR_GET_DC                                101
#define IDS_ERROR_GET_USER_CONFIG                       102
#define IDS_ERROR_SET_USER_CONFIG                       103
#define IDS_ERROR_MALLOC                                104

#define IDS_USAGE1                                      200
#define IDS_USAGE2                                      201
#define IDS_USAGE3                                      202
#define IDS_QUERY1                                      203
#define IDS_QUERY2                                      204
#define IDS_QUERY3                                      205
#define IDS_ERROR_NOT_TS                                206
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\wfprof\wfprof.c ===
/******************************************************************************
*
*   WFPROF.C
*
*   Description: 
*
*   Copyright Citrix Systems Inc. 1997
*
*   Copyright (c) 1998 - 1999 Microsoft Corporation
*
*   Author: Kurt Perry (kurtp)
*
*   Date: 11-Apr-1997
*
*   $Log:   M:\nt\private\utils\citrix\wfprof\VCS\wfprof.c  $
*  
*     Rev 1.3   Jun 26 1997 18:26:30   billm
*  move to WF40 tree
*  
*     Rev 1.2   23 Jun 1997 16:20:02   butchd
*  update
*  
*     Rev 1.1   29 Apr 1997 21:35:20   kurtp
*  I fixed a bug in this file, update, duh!
*
*******************************************************************************/

#include <nt.h>
#include <ntrtl.h>                // NT runtime library definitions
#include <nturtl.h>
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <lmerr.h>
#include <lmcons.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmremutl.h>

#include <citrix\winstaw.h>
#include <utilsub.h>

#include "wfprof.h"


/*=============================================================================
==  Macros
=============================================================================*/


/*=============================================================================
==  Variables
=============================================================================*/

WCHAR * pServerName = NULL;

WCHAR DomainName[MAX_IDS_LEN + 1];
WCHAR SourceUser[MAX_IDS_LEN + 1];
WCHAR DestinationUser[MAX_IDS_LEN + 1];
WCHAR WFProfilePath[MAX_IDS_LEN + 1];


/*=============================================================================
==   Data types and definitions
=============================================================================*/

USHORT copy_flag    = FALSE;
USHORT update_flag  = FALSE;
USHORT query_flag   = FALSE;
USHORT help_flag    = FALSE;
USHORT local_flag   = FALSE;

TOKMAP ptm[] = {

      {L" ",        TMFLAG_REQUIRED, TMFORM_STRING,  MAX_IDS_LEN,    SourceUser}, 
      {L" ",        TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DestinationUser}, 
      {L"/Domain",  TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    DomainName}, 
      {L"/Profile", TMFLAG_OPTIONAL, TMFORM_STRING,  MAX_IDS_LEN,    WFProfilePath}, 
      {L"/Local",   TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &local_flag}, 

      {L"/Copy",    TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &copy_flag}, 
      {L"/Q",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &query_flag},
      {L"/Update",  TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &update_flag},

      {L"/?",       TMFLAG_OPTIONAL, TMFORM_BOOLEAN, sizeof(USHORT), &help_flag},
      {0, 0, 0, 0, 0}
};

#define SOURCE_USER  (ptm[0].tmFlag & TMFLAG_PRESENT)
#define DEST_USER    (ptm[1].tmFlag & TMFLAG_PRESENT) 
#define DOMAIN       (ptm[2].tmFlag & TMFLAG_PRESENT) 
#define PROFILE_PATH (ptm[3].tmFlag & TMFLAG_PRESENT) 
#define LOCAL        (ptm[4].tmFlag & TMFLAG_PRESENT) 



/*=============================================================================
==  Functions
=============================================================================*/

void Usage( BOOLEAN bError );


/*******************************************************************************
 *
 *  main
 *
 ******************************************************************************/

int __cdecl
main( int argc, char **argv )
{
    int   i;
    int   Error;
    ULONG ReturnLength;
    WCHAR **argvW;
    USERCONFIG UserConfig;

    /*
     * Massage the new command line to look like an argv[] type
     * because ParseCommandLine() depends on this format
     */
    argvW = (WCHAR **)malloc( sizeof(WCHAR *) * (argc+1) );
    if(argvW == NULL) {
        printf( "Error: malloc failed\n" );
        return(FAILURE);
    }

    for( i=0; i < argc; i++ ) {
        argvW[i] = (WCHAR *)malloc( (strlen(argv[i]) + 1) * sizeof(WCHAR) );
        wsprintf( argvW[i], L"%S", argv[i] );
    }
    argvW[argc] = NULL;

    /*
     *  parse the cmd line without parsing the program name (argc-1, argv+1)
     */
    Error = ParseCommandLine(argc-1, argvW+1, ptm, PCL_FLAG_NO_CLEAR_MEMORY);

    /*
     *  Check for error from ParseCommandLine
     */
    if ( help_flag ) {

        Usage(FALSE);
        return(SUCCESS);
    }
    else if ( Error || 
        (!copy_flag && !update_flag && !query_flag) ||
        (copy_flag && update_flag) ||
        (copy_flag && query_flag) ||
        (update_flag && query_flag) ||
        (copy_flag && !DEST_USER) ||
        (update_flag && !PROFILE_PATH) ||
        (!DOMAIN && !LOCAL) ||
        (DOMAIN && LOCAL) ) {

        Usage(TRUE);
        return(FAILURE);
    }

    /*
     *  Get server name for domain name
     */
    if ( LOCAL ) {
        pServerName = NULL;
        Error = ERROR_SUCCESS;
    }
    else {
        Error = NetGetDCName( (WCHAR)NULL, DomainName, (LPBYTE *)&pServerName );
    }

    if ( Error == ERROR_SUCCESS ) {

        /*
         *  Update or Query
         */
        if ( update_flag || query_flag ) {
        
        
query_it:
    
            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
            	                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS ) {
    
                if ( query_flag ) {
                    Message( IDS_QUERY, 
                             DomainName, 
                             SourceUser, 
                             UserConfig.WFProfilePath );
                }
                else {
    
                    wcscpy( UserConfig.WFProfilePath, WFProfilePath );
    
                    Error = RegUserConfigSet( pServerName,
                                              SourceUser,
                                              &UserConfig,
                    	                      sizeof(UserConfig) );
    
                    if ( Error == ERROR_SUCCESS ) {
                        query_flag = TRUE;
                        goto query_it;
                    }
                    else {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
        else if ( copy_flag ) {
    
            Error = RegUserConfigQuery( pServerName,
                                        SourceUser,
                                        &UserConfig,
                                        sizeof(UserConfig),
                                        &ReturnLength );
    
            if ( Error == ERROR_SUCCESS ) {
    
                if ( query_flag ) {
                    Message( IDS_QUERY, 
                             DomainName, 
                             SourceUser, 
                             UserConfig.WFProfilePath );
                }
                else {
    
                    if ( PROFILE_PATH ) {
                        wcscpy( UserConfig.WFProfilePath, WFProfilePath );
                    }
    
                    Error = RegUserConfigSet( pServerName,
                                              DestinationUser,
                                              &UserConfig,
                                              sizeof(UserConfig) );
    
                    if ( Error != ERROR_SUCCESS ) {
                        ErrorPrintf(IDS_ERROR_SET_USER_CONFIG, Error, Error);
                    }
                }
            }
            else {
                ErrorPrintf(IDS_ERROR_GET_USER_CONFIG, Error, Error);
            }
        }
    }
    else {
        ErrorPrintf(IDS_ERROR_GET_DC, Error, Error);
    }

    return( (Error == ERROR_SUCCESS ? SUCCESS : FAILURE) );
}



/*******************************************************************************
 *
 *  Usage
 *
 *      Output the usage message for this utility.
 *
 *  ENTRY:
 *      bError (input)
 *          TRUE if the 'invalid parameter(s)' message should preceed the usage
 *          message and the output go to stderr; FALSE for no such error
 *          string and output goes to stdout.
 *
 *  EXIT:
 *      
 *
 ******************************************************************************/

void
Usage( BOOLEAN bError )
{
    if ( bError ) {
        ErrorPrintf(IDS_ERROR_INVALID_PARAMETERS);
    } 

    Message(IDS_USAGE1);
    Message(IDS_USAGE2);
    Message(IDS_USAGE3);

}  /* Usage() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\allsrvpg.cpp ===
/*******************************************************************************
*
* allsrvpg.cpp
*
* implementations of the All Servers info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\allsrvpg.cpp  $
*
*     Rev 1.8   19 Feb 1998 20:01:44   donm
*  removed latest extension DLL support
*
*     Rev 1.7   19 Feb 1998 17:39:48   donm
*  removed latest extension DLL support
*
*     Rev 1.6   15 Feb 1998 09:14:56   donm
*  update
*
*     Rev 1.2   19 Jan 1998 17:36:06   donm
*  new ui behavior for domains and servers
*
*     Rev 1.5   19 Jan 1998 16:45:34   donm
*  new ui behavior for domains and servers
*
*     Rev 1.4   03 Nov 1997 15:18:28   donm
*  Added descending sort
*
*     Rev 1.3   18 Oct 1997 18:49:38   donm
*  update
*
*     Rev 1.2   13 Oct 1997 18:41:08   donm
*  update
*
*     Rev 1.1   26 Aug 1997 19:13:56   donm
*  bug fixes/changes from WinFrame 1.7
*
*     Rev 1.0   30 Jul 1997 17:10:18   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "allsrvpg.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
//USES_CONVERSION
static int _convert;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////////
// MESSAGE MAP: CAllServerServersPage
//
IMPLEMENT_DYNCREATE(CAllServerServersPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerServersPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerServersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVER_LIST, OnColumnclick)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_SERVER_LIST, OnServerItemChanged)
        ON_NOTIFY(NM_SETFOCUS, IDC_SERVER_LIST, OnSetfocusServerList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_SERVER_LIST , OnKillfocusServerList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerServersPage ctor
//
CAllServerServersPage::CAllServerServersPage()
        : CAdminPage(CAllServerServersPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerServersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerServersPage ctor


/////////////////////////////
// F'N: CAllServerServersPage dtor
//
CAllServerServersPage::~CAllServerServersPage()
{

}  // end CAllServerServersPage dtor


////////////////////////////////////////
// F'N: CAllServerServersPage::DoDataExchange
//
void CAllServerServersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerServersPage)
        DDX_Control(pDX, IDC_SERVER_LIST, m_ServerList);
        //}}AFX_DATA_MAP

}  // end CAllServerServersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerServersPage::AssertValid
//
void CAllServerServersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerServersPage::AssertValid


//////////////////////////////
// F'N: CAllServerServersPage::Dump
//
void CAllServerServersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerServersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CAllServerServersPage::OnSize
//
void CAllServerServersPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_ServerList.GetSafeHwnd())
                m_ServerList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerServersPage::OnSize


static ColumnDef ServerColumns[] = {
        CD_SERVER,
        CD_TCPADDRESS,
        CD_IPXADDRESS,
        CD_NUM_SESSIONS
};

#define NUM_AS_SERVER_COLUMNS sizeof(ServerColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CAllServerServersPage::OnInitialUpdate
//
void CAllServerServersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_SERVER_COLUMNS; col++) {
                columnString.LoadString(ServerColumns[col].stringID);
                m_ServerList.InsertColumn(col, columnString, ServerColumns[col].format, ServerColumns[col].width, col);
        }

        m_CurrentSortColumn = SERVERS_COL_SERVER;

}  // end CAllServerServersPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerServersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerServersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 4, 0);

        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
        m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
        m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);

        m_ImageList.SetOverlayImage(m_idxNotSign, 1);
        m_ImageList.SetOverlayImage(m_idxQuestion, 2);

        m_ServerList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerServersPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerServersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerServersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerServersPage::AddIconToImageList


//////////////////////////////
// F'N: CAllServerServersPage::Reset
//
void CAllServerServersPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayServers( pT->GetNodeType( ) );
    }
    else
    {
        DisplayServers( NODE_NONE );
    }

} // end CAllServerServersPage::Reset


//////////////////////////////
// F'N: CAllServerServersPage::AddServer
//
void CAllServerServersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // We have to make sure the server isn't already in the list
        // Add the server to the list
        if(AddServerToList(pServer)) {
            // Tell the list to sort itself
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerServersPage::AddServer


//////////////////////////////
// F'N: CAllServerServersPage::RemoveServer
//
void CAllServerServersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();
        // Find out how many items in the list
        int ItemCount = m_ServerList.GetItemCount();

        // Go through the items are remove this server
        for(int item = 0; item < ItemCount; item++) {
                CServer *pListServer = (CServer*)m_ServerList.GetItemData(item);

                if(pListServer == pServer) {
                        m_ServerList.DeleteItem(item);
                        pServer->ClearAllSelected();
                        break;
                }
        }
        UnlockListControl();

}  // end CAllServerServersPage::RemoveServer


//////////////////////////////
// F'N: CAllServerServersPage::UpdateServer
//
void CAllServerServersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        // If we aren't connected to the server anymore, remove it from the list control
        if(pServer->IsState(SS_NOT_CONNECTED)) {
                RemoveServer(pServer);
                return;
        }

        // If we just connected to this server, add it to the list control
        if(pServer->IsState(SS_GOOD)) {
                AddServer(pServer);
                return;
        }

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) {
                // Change the icon overlay
                USHORT NewState;
                // Change the icon/overlay for the server
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) NewState = STATE_NOT;
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(!pServer->IsState(SS_GOOD)) NewState = STATE_QUESTION;
                // If it is fine, we want to remove any overlays from the icon
                else NewState = STATE_NORMAL;

                // Set the tree item to the new state
                m_ServerList.SetItemState(item, NewState, 0x0F00);

                ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

                // TCP Address
                m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

                // IPX Address
                m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

                CString NumString;
                if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                        NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
                } else {
                        NumString.LoadString(IDS_NOT_APPLICABLE);
                }

                m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);
        }

        // Tell the list to sort itself
        if(m_CurrentSortColumn == SERVERS_COL_NUMWINSTATIONS
                || m_CurrentSortColumn == SERVERS_COL_TCPADDRESS
                || m_CurrentSortColumn == SERVERS_COL_IPXADDRESS)
                        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

        UnlockListControl();

}  // end CAllServerServersPage::UpdateServer


//////////////////////////////
// F'N: CAllServerServersPage::AddServerToList
//
BOOL CAllServerServersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        // If we aren't currently connected to the server, don't display it
        if(!pServer->IsState(SS_GOOD)) return FALSE;

        LockListControl();

        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) return FALSE;

        //////////////////////
        // Fill in the columns
        //////////////////////
        // Name - put at the end of the list
        item = m_ServerList.InsertItem(m_ServerList.GetItemCount(), pServer->GetName(),
                                                                pServer->IsCurrentServer() ? m_idxCurrentServer : m_idxServer);

        // If the server isn't sane, put a not sign over the icon
        if(!pServer->IsServerSane()) m_ServerList.SetItemState(item, STATE_NOT, 0x0F00);
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(!pServer->IsState(SS_GOOD)) m_ServerList.SetItemState(item, STATE_QUESTION, 0x0F00);

        ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

        // TCP Address
        m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

        // IPX Address
        m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

        // Connected
        CString NumString;
        if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
        } else {
                NumString.LoadString(IDS_NOT_APPLICABLE);
        }

        m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);

        m_ServerList.SetItemData(item, (DWORD_PTR)pServer);

        UnlockListControl();

    return TRUE;

}  // end CAllServerServersPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerServersPage::DisplayServers
//
void CAllServerServersPage::DisplayServers( NODETYPE ntType )
{
    LockListControl();

    // Clear out the list control
    m_ServerList.DeleteAllItems();

    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

    // Get a pointer to the list of servers
    doc->LockServerList();
    CObList *pServerList = doc->GetServerList();

    // Iterate through the Server list
    POSITION pos = pServerList->GetHeadPosition();

    while(pos)
    {
        CServer *pServer = (CServer*)pServerList->GetNext(pos);

        // check to see if its just for favorites
        if( ntType == NODE_FAV_LIST )        
        { 
            if( pServer->GetTreeItemFromFav() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else if( ntType == NODE_THIS_COMP )
        {
            if( pServer->GetTreeItemFromThisComputer( ) != NULL )
            {
                AddServerToList( pServer );
            }
        }
        else
        {
            AddServerToList(pServer);
        }

    }  // end while(pos)

    doc->UnlockServerList();

    UnlockListControl();

}  // end CAllServerServersPage::DisplayServers


//////////////////////////////
// F'N: CAllServerServersPage::OnServerItemChanged
//
void CAllServerServersPage::OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here
        CServer *pServer = (CServer*)m_ServerList.GetItemData(pLV->iItem);

        if(pLV->uNewState & LVIS_SELECTED) {
                pServer->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                pServer->ClearSelected();
        }

        *pResult = 0;

}  // end CAllServerServersPage::OnServerItemChanged


//////////////////////////////
// F'N: CAllServerServersPage::OnColumnclick
//
void CAllServerServersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerServersPage::OnColumnclick


//////////////////////////////
// F'N: CAllServerServersPage::OnContextMenu
//
void CAllServerServersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ServerList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ServerList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ServerList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ServerList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ServerList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_SERVER_POPUP);
        // set the temp selected item so that handler doesn't think
        // this came from the tree
        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
        doc->SetTreeTemp(NULL, NODE_NONE);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerServersPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CAllServerUsersPage
//
IMPLEMENT_DYNCREATE(CAllServerUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerUsersPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerUsersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_USER_LIST , OnKillfocusUserList )
        // ON_WM_SETFOCUS( )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerUsersPage ctor
//
CAllServerUsersPage::CAllServerUsersPage()
        : CAdminPage(CAllServerUsersPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerUsersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerUsersPage ctor


/////////////////////////////
// F'N: CAllServerUsersPage dtor
//
CAllServerUsersPage::~CAllServerUsersPage()
{
}  // end CAllServerUsersPage dtor


////////////////////////////////////////
// F'N: CAllServerUsersPage::DoDataExchange
//
void CAllServerUsersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerUsersPage)
        DDX_Control(pDX, IDC_USER_LIST, m_UserList);
        //}}AFX_DATA_MAP

}  // end CAllServerUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerUsersPage::AssertValid
//
void CAllServerUsersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerUsersPage::AssertValid


//////////////////////////////
// F'N: CAllServerUsersPage::Dump
//
void CAllServerUsersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CAllServerUsersPage::OnSize
//
void CAllServerUsersPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_UserList.GetSafeHwnd())
                m_UserList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);
}  // end CAllServerUsersPage::OnSize


static ColumnDef UserColumns[] = {
        CD_SERVER,
        CD_USER3,
        CD_SESSION,
        CD_ID,
        CD_STATE,
        CD_IDLETIME,
        CD_LOGONTIME
};

#define NUM_AS_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CAllServerUsersPage::OnInitialUpdate
//
void CAllServerUsersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_USER_COLUMNS; col++) {
                columnString.LoadString(UserColumns[col].stringID);
                m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_USERS_COL_SERVER;

}  // end CAllServerUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CAllServerUsersPage::OnUserItemChanged
//
void CAllServerUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{   
    NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

    if(pLV->uNewState & LVIS_SELECTED)
    {
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
        pWinStation->SetSelected();
    }

    if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED))
    {
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
        pWinStation->ClearSelected();       
    }
    
    *pResult = 0;

}  // end CAllServerUsersPage::OnUserItemChanged


/////////////////////////////////////
// F'N: CAllServerUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerUsersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 2, 0);

        m_idxUser = AddIconToImageList(IDI_USER);
        m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

        m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerUsersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CAllServerUsersPage::Reset
//
void CAllServerUsersPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayUsers( pT->GetNodeType() );
    }   
    else
    {
        DisplayUsers( NODE_NONE );
    }

} // end CAllServerUsersPage::Reset


//////////////////////////////
// F'N: CAllServerUsersPage::AddServer
//
void CAllServerUsersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the server's users to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

} // end CAllServerUsersPage::AddServer


//////////////////////////////
// F'N: CAllServerUsersPage::RemoveServer
//
void CAllServerUsersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_UserList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_UserList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

} // end CAllServerUsersPage::RemoveServer


//////////////////////////////
// F'N: CAllServerUsersPage::UpdateServer
//
void CAllServerUsersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerUsersPage::UpdateServer


//////////////////////////////
// F'N: CAllServerUsersPage::UpdateWinStations
//
void CAllServerUsersPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_UserList.FindItem(&FindInfo, -1);

                // If the WinStation is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
                        // Remove the WinStation from the list
                        m_UserList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // change the user name
                        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());
                        // change the WinStation Name
                        if(pWinStation->GetName()[0])
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
                        }


            // change the Connect State
                        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
                        // change the Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);
                        // change the Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';
                        // change the

                        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

                        if(m_CurrentSortColumn != AS_USERS_COL_ID)
                                bAnyChanged = TRUE;

                        continue;
                }

                // If the WinStation is not in the list but now has a user, add it to the list
                if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CAllServerUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CAllServerUsersPage::AddUserToList
//
int CAllServerUsersPage::AddUserToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////
        // Server - put at the end of the list
        int item = m_UserList.InsertItem(m_UserList.GetItemCount(), pServer->GetName(),
                pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

        // User
        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

        // WinStation Name
        if(pWinStation->GetName()[0])
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
        }

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_UserList.SetItemText(item, AS_USERS_COL_ID, ColumnString);

        // Connect State
        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
        {
                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

        // Attach a pointer to the CWinStation structure to the list item
        m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);
        
        //bug #191727
        //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CAllServerUsersPage::AddUserToList


//////////////////////////////
// F'N: CAllServerUsersPage::AddServerToList
//
BOOL CAllServerUsersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                // only show the WinStation if it has a user
                if(pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                }
        }  // end while(pos)

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CAllServerUsersPage::AddServerToList


//////////////////////////////
// F'N: CAllServerUsersPage::OnColumnclick
//
void CAllServerUsersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerUsersPage::OnColumnclick


//////////////////////////////
// F'N: CAllServerUsersPage::OnContextMenu
//
void CAllServerUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_UserList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }

                /*
                RECT rect;
                m_UserList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_UserList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                {
                    //
                    // ListView HitTest bug? return -1 but item display as selected.
                    // workaround for now, Al can fix this later
                    //
                    UINT iCount = m_UserList.GetItemCount( );
                    RECT rc;

                    for( Item = 0 ; Item < iCount ; Item++ )
                    {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                            break;
                        }
                    }

                    if( Item >= iCount )
                    {
                        return;
                    }

                }

                //
                // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
                // manually set it to selected state
                //
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

                if( !pWinStation )
                    return;

                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    pWinStation->SetSelected();
                }
        }

        CMenu menu;

        menu.LoadMenu(IDR_USER_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerUsersPage::OnContextMenu


/////////////////////////////////////
// F'N: CAllServerUsersPage::DisplayUsers
//
void CAllServerUsersPage::DisplayUsers( NODETYPE ntType )
{
        LockListControl();

        // Clear out the list control
        m_UserList.DeleteAllItems();

                // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos2 = pServerList->GetHeadPosition();

        while(pos2)
        {           
            CServer *pServer = (CServer*)pServerList->GetNext(pos2);

            if( ntType == NODE_FAV_LIST )        
            {
                if( pServer->GetTreeItemFromFav() != NULL )
                {
                    AddServerToList(pServer);
                }
            }
            else if( ntType == NODE_THIS_COMP )
            {
                if( pServer->GetTreeItemFromThisComputer() != NULL )
                {
                    AddServerToList(pServer);
                }
            }
            else
            {
                AddServerToList( pServer );
            }
        } // end while(pos2)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CAllServerUsersPage::DisplayUsers

/////////////////////////////////////
// F'N: CAllServerUsersPage::ClearSelections
//
void CAllServerUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            // you could do your own processing on nItem here
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CAllServerWinStationsPage
//
IMPLEMENT_DYNCREATE(CAllServerWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerWinStationsPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerWinStationsPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_WINSTATION_LIST , OnKillfocusWinstationList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerWinStationsPage ctor
//
CAllServerWinStationsPage::CAllServerWinStationsPage()
        : CAdminPage(CAllServerWinStationsPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerWinStationsPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerWinStationsPage ctor


/////////////////////////////
// F'N: CAllServerWinStationsPage dtor
//
CAllServerWinStationsPage::~CAllServerWinStationsPage()
{

}  // end CAllServerWinStationsPage dtor


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::DoDataExchange
//
void CAllServerWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerWinStationsPage)
        DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
        //}}AFX_DATA_MAP

}  // end CAllServerWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerWinStationsPage::AssertValid
//
void CAllServerWinStationsPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerWinStationsPage::AssertValid


//////////////////////////////
// F'N: CAllServerWinStationsPage::Dump
//
void CAllServerWinStationsPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerWinStationsPage::Dump

#endif //_DEBUG


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnWinStationItemChanged
//
void CAllServerWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;


    if(pLV->uNewState & LVIS_SELECTED)
    {
        CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
        pWinStation->SetSelected();
    }
    if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED))
    {
        CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
        pWinStation->ClearSelected();        
    }

    *pResult = 0;

}  // end CAllServerWinStationsPage::OnWinStationItemChanged


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnSize
//
void CAllServerWinStationsPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_StationList.GetSafeHwnd())
                m_StationList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
        CD_SERVER,
        CD_SESSION2,
        CD_USER2,
        CD_ID,
        CD_STATE,
        CD_TYPE,
        CD_CLIENT_NAME,
        CD_IDLETIME,
        CD_LOGONTIME,
        CD_COMMENT
};

#define NUM_AS_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnInitialUpdate
//
void CAllServerWinStationsPage::OnInitialUpdate()
{
        // Call the parent class
        CFormView::OnInitialUpdate();

        // builds the image list for the list control
        BuildImageList();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_AS_WINS_COLUMNS; col++) {
                columnString.LoadString(WinsColumns[col].stringID);
                m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_WS_COL_SERVER;

}  // end CAllServerWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerWinStationsPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 11, 0);

        m_idxBlank  = AddIconToImageList(IDI_BLANK);
        m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxConsole = AddIconToImageList(IDI_CONSOLE);
        m_idxNet = AddIconToImageList(IDI_NET);
        m_idxAsync = AddIconToImageList(IDI_ASYNC);
        m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
        m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
        m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
        m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
        m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);

        m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerWinStationsPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CAllServerWinStationsPage::AddIconToImageList


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::Reset
//
void CAllServerWinStationsPage::Reset(void *p)
{
    CTreeNode *pT = ( CTreeNode * )p;

    if( pT != NULL )
    {
        DisplayStations( pT->GetNodeType( ) );
    }
    else
    {
        DisplayStations( NODE_NONE );
    }

}  // end CAllServerWinStationsPage::Reset


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddServer
//
void CAllServerWinStationsPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add server's WinStations to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerWinStationsPage::AddServer


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::RemoveServer
//
void CAllServerWinStationsPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_StationList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_StationList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CAllServerWinStationsPage::RemoveServer


//////////////////////////////
// F'N: CAllServerWinStationsPage::UpdateServer
//
void CAllServerWinStationsPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerWinStationsPage::UpdateServer


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::UpdateWinStations
//
void CAllServerWinStationsPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_StationList.FindItem(&FindInfo, -1);

                // If the process is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && item == -1) {

                        AddWinStationToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if(!pWinStation->IsCurrent() && item != -1) {
                        // Remove the WinStation from the list
                        m_StationList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // Figure out which icon to use
                        int WhichIcon = m_idxBlank;
                        BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();

                        if(pWinStation->GetState() != State_Disconnected
                        && pWinStation->GetState() != State_Idle) {
                                switch(pWinStation->GetSdClass()) {
                                        case SdAsync:
                                                if(pWinStation->IsDirectAsync())
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                                else
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                                break;

                                        case SdNetwork:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                                break;

                                        default:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                        break;
                                }
                        }

                        m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

                        // WinStation Name
                        if(pWinStation->GetName()[0])
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
                        }

                        // User
                        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

                        // Logon ID
                        CString ColumnString;
                        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
                        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

                        // Connect State
                        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

                        // Type
                        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

                        // Client Name
                        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

                        // Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

                        // Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';

                        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

                        // Comment
                        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

                        if(m_CurrentSortColumn != AS_WS_COL_ID)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

} // end CAllServerWinStationsPage::UpdateWinStations


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddWinStationToList
//
int CAllServerWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Figure out which icon to use
        int WhichIcon = m_idxBlank;
        BOOL bCurrentWinStation = pWinStation->IsCurrentWinStation();

        if(pWinStation->GetState() != State_Disconnected
                && pWinStation->GetState() != State_Idle) {
                switch(pWinStation->GetSdClass()) {
                        case SdAsync:
                                if(pWinStation->IsDirectAsync())
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                else
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                break;

                        case SdNetwork:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                break;

                        default:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                break;
                }
        }

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////

        // Server Name
        int item = m_StationList.InsertItem(m_StationList.GetItemCount(), pServer->GetName(), WhichIcon);
        // WinStation Name
        if(pWinStation->GetName()[0])
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
        }

        // User
        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

        // Connect State
        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Type
        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

        // Client Name
        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
        if(pWinStation->GetState() == State_Active
                && pWinStation->GetLastInputTime().QuadPart <= pWinStation->GetCurrentTime().QuadPart)
        {
            LARGE_INTEGER DiffTime = CalculateDiffTime(pWinStation->GetLastInputTime(), pWinStation->GetCurrentTime());            
            
            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;            

            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining
            
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
            pWinStation->SetIdleTime(IdleTime);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart)
        {
            DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
            
            if( LogonTimeString[0] != 0 )
            {           
                pDoc->FixUnknownString(LogonTimeString);
            }
        }
        else LogonTimeString[0] = '\0';

        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

        // Comment
        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

        // Attach a pointer to the CWinStation structure to the list item
        m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

        //bug #191727
        //m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CAllServerWinStationsPage::AddWinStationToList


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::AddServerToList
//
BOOL CAllServerWinStationsPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                AddWinStationToList(pWinStation);
        }

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CAllServerWinStationsPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerWinStationsPage::DisplayStations
//
void CAllServerWinStationsPage::DisplayStations( NODETYPE ntType )
{
    // Clear out the list control
    m_StationList.DeleteAllItems();

    // Get a pointer to the document's list of servers
    CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

    ((CWinAdminDoc*)GetDocument())->LockServerList();
    // Iterate through the server list
    POSITION pos = pServerList->GetHeadPosition();

    while(pos)
    {
        CServer *pServer = (CServer*)pServerList->GetNext(pos);

        if( ntType == NODE_FAV_LIST )        
        {
            if( pServer->GetTreeItemFromFav() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else if( ntType == NODE_THIS_COMP )
        {
            if( pServer->GetTreeItemFromThisComputer() != NULL )
            {
                AddServerToList(pServer);
            }
        }
        else
        {
            AddServerToList( pServer );
        }            
    }

    ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CAllServerWinStationsPage::DisplayStations


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnColumnclick
//
void CAllServerWinStationsPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerWinStationsPage::OnColumnclick


////////////////////////////////////////
// F'N: CAllServerWinStationsPage::OnContextMenu
//
void CAllServerWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_StationList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_StationList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_StationList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_WINSTATION_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerWinStationsPage::OnContextMenu


//////////////////////////////////
// MESSAGE MAP: CAllServerProcessesPage
//
IMPLEMENT_DYNCREATE(CAllServerProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerProcessesPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerProcessesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_PROCESS_LIST , OnKillfocusProcessList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CAllServerProcessesPage ctor
//
CAllServerProcessesPage::CAllServerProcessesPage()
        : CAdminPage(CAllServerProcessesPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerProcessesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerProcessesPage ctor


///////////////////////////////
// F'N: CAllServerProcessesPage dtor
//
CAllServerProcessesPage::~CAllServerProcessesPage()
{
}  // end CAllServerProcessesPage dtor


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::DoDataExchange
//
void CAllServerProcessesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerProcessesPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
                DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
        //}}AFX_DATA_MAP

}  // end CAllServerProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CAllServerProcessesPage::AssertValid
//
void CAllServerProcessesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerProcessesPage::AssertValid


////////////////////////////////
// F'N: CAllServerProcessesPage::Dump
//
void CAllServerProcessesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnSize
//
void CAllServerProcessesPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetClientRect(&rect);

        rect.top += LIST_TOP_OFFSET;

        if(m_ProcessList.GetSafeHwnd())
                m_ProcessList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerProcessesPage::OnSize

static ColumnDef ProcColumns[] = {
        CD_SERVER,
        CD_USER,
        CD_SESSION,
        CD_PROC_ID,
        CD_PROC_PID,
        CD_PROC_IMAGE
};

#define NUM_AS_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnInitialUpdate
//
void CAllServerProcessesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_AS_PROC_COLUMNS; col++) {
                columnString.LoadString(ProcColumns[col].stringID);
                m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_PROC_COL_SERVER;

}  // end CAllServerProcessesPage::OnInitialUpdate


////////////////////////////////
// F'N: CAllServerProcessesPage::Reset
//
void CAllServerProcessesPage::Reset(void *)
{
        // We don't want to display processes until the user clicks
        // on the "Processes" tab

}  // end CAllServerProcessesPage::Reset


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::AddServer
//
void CAllServerProcessesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's processes to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CAllServerProcessesPage::AddServer


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::RemoveServer
//
void CAllServerProcessesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        LockListControl();

        int ItemCount = m_ProcessList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(item-1);
                CServer *pListServer = pProcess->GetServer();

                if(pListServer == pServer) {
                        m_ProcessList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CAllServerProcessesPage::RemoveServer


//////////////////////////////
// F'N: CAllServerProcessesPage::UpdateServer
//
void CAllServerProcessesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CAllServerProcessesPage::UpdateServer


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::UpdateProcesses
//
void CAllServerProcessesPage::UpdateProcesses(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the processes
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                // If the process is new, add it to the list
                if(pProcess->IsNew()) {

                        if(AddProcessToList(pProcess) != -1)
                                bAnyAdded = TRUE;
                        continue;
                }

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pProcess;

                // Find the Process in our list
                int item = m_ProcessList.FindItem(&FindInfo, -1);

                // If the process is no longer current,
                // remove it from the list
                if(!pProcess->IsCurrent() && item != -1) {
                        // Remove the Process from the list
                        m_ProcessList.DeleteItem(item);
                        pProcess->ClearSelected();
                }

                // If the process info has changed, change
                // it's info in our tree
                if(pProcess->IsChanged() && item != -1)
                {
                        // WinStation Name
                        CWinStation *pWinStation = pProcess->GetWinStation();
                        if(pWinStation)
                        {
                                if(pWinStation->GetName()[0])
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                                else
                                {
                                        CString NameString(" ");
                                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                                }
                        }
                        if(m_CurrentSortColumn == AS_PROC_COL_WINSTATION)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockProcessList();

        if(bAnyChanged || bAnyAdded) {
                LockListControl();
                SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
                UnlockListControl();
        }

}  // end CAllServerProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::RemoveProcess
//
void CAllServerProcessesPage::RemoveProcess(CProcess *pProcess)
{
        ASSERT(pProcess);

        LockListControl();

        // Find out how many items in the list
        int ItemCount = m_ProcessList.GetItemCount();

        // Go through the items and remove this process
        for(int item = 0; item < ItemCount; item++) {
                CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);

                if(pListProcess == pProcess) {
                        m_ProcessList.DeleteItem(item);
                        break;
                }
        }

        UnlockListControl();
}


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::AddProcessToList
//
int CAllServerProcessesPage::AddProcessToList(CProcess *pProcess)
{
        ASSERT(pProcess);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        CServer *pServer = pProcess->GetServer();

        LockListControl();
        // Server - put at end of list
        int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetServer()->GetName(), NULL);

        // User
        m_ProcessList.SetItemText(item, AS_PROC_COL_USER, pProcess->GetUserName());

        // WinStation Name
        CWinStation *pWinStation = pProcess->GetWinStation();
        if(pWinStation) {

                if(pWinStation->GetName()[0])
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                else {
                        CString NameString(" ");
                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                }



    }

        // ID
        CString ProcString;
        ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
        m_ProcessList.SetItemText(item, AS_PROC_COL_ID, ProcString);

        // PID
        ProcString.Format(TEXT("%lu"), pProcess->GetPID());
        m_ProcessList.SetItemText(item, AS_PROC_COL_PID, ProcString);

        // Image
        m_ProcessList.SetItemText(item, AS_PROC_COL_IMAGE, pProcess->GetImageName());
        m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

        m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_SELECTED | LVIS_FOCUSED );

        UnlockListControl();

        return item;

}  // end CAllServerProcessesPage::AddProcessToList


////////////////////////////////
// F'N: CAllServerProcessesPage::AddServerToList
//
BOOL CAllServerProcessesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

        pServer->EnumerateProcesses();
        CObList *pProcessList = pServer->GetProcessList();
        pServer->LockProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                AddProcessToList(pProcess);
        }

        pServer->UnlockProcessList();

    return TRUE;

}  // end CAllServerProcessesPage::AddServerToList


////////////////////////////////
// F'N: CAllServerProcessesPage::DisplayProcesses
//
void CAllServerProcessesPage::DisplayProcesses( NODETYPE ntType )
{
        CWaitCursor Nikki;

        LockListControl();

        // Clear out the list control
        m_ProcessList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();
        
        CServer *pTempServer;

        while(pos)
        {
            CServer *pServer = (CServer*)pServerList->GetNext(pos);

            pTempServer = NULL;

            if( ntType == NODE_FAV_LIST )        
            { 
                if( pServer->GetTreeItemFromFav() != NULL )
                {

                    pTempServer = pServer;
                }
            }
            else if( ntType == NODE_THIS_COMP )
            {
                if( pServer->GetTreeItemFromThisComputer( ) != NULL )
                {
                    pTempServer = pServer;
                }
            }
            else
            {
                pTempServer = pServer;
            }

            if( pTempServer != NULL && pTempServer->IsServerSane())
            {
                AddServerToList( pTempServer );
            }  // end if(pServer->IsServerSane())
        } // end while(pos)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CAllServerProcessesPage::DisplayProcesses


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnProcessItemChanged
//
void CAllServerProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->ClearSelected();
        }

        *pResult = 0;

}  // end CAllServerProcessesPage::OnProcessItemChanged


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnColumnclick
//
void CAllServerProcessesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CAllServerProcessesPage::OnColumnclick


//////////////////////////////////////////
// F'N: CAllServerProcessesPage::OnContextMenu
//
void CAllServerProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ProcessList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }

                /*
                RECT rect;
                m_ProcessList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ProcessList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_PROCESS_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CAllServerProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CAllServerLicensesPage
//
IMPLEMENT_DYNCREATE(CAllServerLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CAllServerLicensesPage, CFormView)
        //{{AFX_MSG_MAP(CAllServerLicensesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnclick)
        ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
        //ON_NOTIFY( NM_KILLFOCUS , IDC_LICENSE_LIST , OnKillfocusLicenseList )
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CAllServerLicensesPage ctor
//
CAllServerLicensesPage::CAllServerLicensesPage()
        : CAdminPage(CAllServerLicensesPage::IDD)
{
        //{{AFX_DATA_INIT(CAllServerLicensesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_bSortAscending = TRUE;

}  // end CAllServerLicensesPage ctor


/////////////////////////////
// F'N: CAllServerLicensesPage dtor
//
CAllServerLicensesPage::~CAllServerLicensesPage()
{

}  // end CAllServerLicensesPage dtor


////////////////////////////////////////
// F'N: CAllServerLicensesPage::DoDataExchange
//
void CAllServerLicensesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CAllServerLicensesPage)
        DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
        //}}AFX_DATA_MAP

}  // end CAllServerLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CAllServerLicensesPage::AssertValid
//
void CAllServerLicensesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CAllServerLicensesPage::AssertValid


//////////////////////////////
// F'N: CAllServerLicensesPage::Dump
//
void CAllServerLicensesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CAllServerLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnSize
//
void CAllServerLicensesPage::OnSize(UINT nType, int cx, int cy)
{
        RECT rect;
        GetWindowRect(&rect);

        CWnd *pWnd = GetDlgItem(IDC_LOCAL_AVAILABLE);
        if(pWnd) {
                RECT rect2;
                pWnd->GetWindowRect(&rect2);
                rect.top = rect2.bottom + 5;
        }

        ScreenToClient(&rect);

        if(m_LicenseList.GetSafeHwnd())
                m_LicenseList.MoveWindow(&rect, TRUE);

        // CFormView::OnSize(nType, cx, cy);

}  // end CAllServerLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
        CD_SERVER,
        CD_LICENSE_DESC,
        CD_LICENSE_REG,
        CD_USERCOUNT,
        CD_POOLCOUNT,
        CD_LICENSE_NUM
};

#define NUM_AS_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnInitialUpdate
//
void CAllServerLicensesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_AS_LICENSE_COLUMNS; col++) {
                columnString.LoadString(LicenseColumns[col].stringID);
                m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_LICENSE_COL_SERVER;

}  // end CAllServerLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CAllServerLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CAllServerLicensesPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 5, 0);

        m_idxBase = AddIconToImageList(IDI_BASE);
        m_idxBump = AddIconToImageList(IDI_BUMP);
        m_idxEnabler = AddIconToImageList(IDI_ENABLER);
        m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);
       
        m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CAllServerLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CAllServerLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CAllServerLicensesPage::AddIconToImageList(int iconID)
{
    HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
    
    return m_ImageList.Add(hIcon);
    
}  // end CAllServerLicensesPage::AddIconToImageList


/////////////////////////////////////
// F'N: CAllServerLicensesPage::Reset
//
void CAllServerLicensesPage::Reset(void *p)
{
        DisplayLicenses();
        DisplayLicenseCounts();

}  // end CAllServerLicensesPage::Reset


/////////////////////////////////////
// F'N: CAllServerLicensesPage::AddServer
//
void CAllServerLicensesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's licenses to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);
    }

}  // end F'N: CAllServerLicensesPage::AddServer


/////////////////////////////////////
// F'N: CAllServerLicensesPage::RemoveServer
//
void CAllServerLicensesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

        int ItemCount = m_LicenseList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CLicense *pLicense = (CLicense*)m_LicenseList.GetItemData(item-1);
                CServer *pListServer = pLicense->GetServer();

                if(pListServer == pServer) {
                        m_LicenseList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

}  // end CAllServerLicensesPage::RemoveServer


//////////////////////////////
// F'N: CAllServerLicensesPage::UpdateServer
//
void CAllServerLicensesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

        if(pServer->IsState(SS_GOOD))
                AddServer(pServer);

} // end CAllServerLicensesPage::UpdateServer


/////////////////////////////////////
// F'N: CAllServerLicensesPage::AddServerToList
//
BOOL CAllServerLicensesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

        int item;

        pServer->LockLicenseList();

        // Get a pointer to the Server's list of licenses
        CObList *pLicenseList = pServer->GetLicenseList();

        // Iterate through the License list
        POSITION pos = pLicenseList->GetHeadPosition();

        while(pos) {
                CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

                //////////////////////
                // Fill in the columns
                //////////////////////
                int WhichIcon;

                switch(pLicense->GetClass()) {
                        case LicenseBase:
                                WhichIcon = m_idxBase;
                                break;
                        case LicenseBump:
                                WhichIcon = m_idxBump;
                                break;
                        case LicenseEnabler:
                                WhichIcon = m_idxEnabler;
                                break;
                        case LicenseUnknown:
                                WhichIcon = m_idxUnknown;
                                break;
                }

                // Server Name
                item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pServer->GetName(), WhichIcon);

                // Description
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_DESCRIPTION, pLicense->GetDescription());

                // Registered
                CString RegString;
                RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_REGISTERED, RegString);

                BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
                        && pLicense->GetTotalCount() == 4095
                        && pServer->GetCTXVersionNum() == 0x00000040);

                // User (Total) Count
                CString CountString;
                if(bUnlimited)
                        CountString.LoadString(IDS_UNLIMITED);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_USERCOUNT, CountString);

                // Pool Count
                if(bUnlimited)
                        CountString.LoadString(IDS_NOT_APPLICABLE);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_POOLCOUNT, CountString);

                // License Number
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

                m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
        }  // end while(pos)

        pServer->UnlockLicenseList();

    return TRUE;

}  // end CAllServerLicensesPage::AddServerToList


/////////////////////////////////////
// F'N: CAllServerLicensesPage::DisplayLicenseCounts
//
void CAllServerLicensesPage::DisplayLicenseCounts()
{
        // Get a pointer to our document
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
        ExtGlobalInfo *pExtGlobalInfo = pDoc->GetExtGlobalInfo();

        if(pExtGlobalInfo) {
                BOOL bUnlimited = (pExtGlobalInfo->NetworkLocalAvailable == 32767);

                CString LicenseString;

                if(bUnlimited) {
                        LicenseString.LoadString(IDS_UNLIMITED);
                        SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
                        SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
                        SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
                        SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

                } else {

                        LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalInstalled);
                        SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
                        LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalAvailable);
                        SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
                        LicenseString.Format(TEXT("%lu"),
                        pExtGlobalInfo->NetworkPoolInstalled + pExtGlobalInfo->NetworkLocalInstalled);
                        SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);

                        LicenseString.Format(TEXT("%lu"),
                        pExtGlobalInfo->NetworkPoolAvailable + pExtGlobalInfo->NetworkLocalAvailable);
                        SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

                }

                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkLocalInUse);
                SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolInstalled);
                SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolInUse);
                SetDlgItemText(IDC_POOL_INUSE, LicenseString);
                LicenseString.Format(TEXT("%lu"), pExtGlobalInfo->NetworkPoolAvailable);
                SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);

                LicenseString.Format(TEXT("%lu"),
                pExtGlobalInfo->NetworkPoolInUse + pExtGlobalInfo->NetworkLocalInUse);
                SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
        }

}  // end CAllServerLicensesPage::DisplayLicenseCounts


/////////////////////////////////////
// F'N: CAllServerLicensesPage::DisplayLicenses
//
void CAllServerLicensesPage::DisplayLicenses()
{
        // Clear out the list control
        m_LicenseList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CAllServerLicensesPage::DisplayLicenses


/////////////////////////////////////
// F'N: CAllServerLicensesPage::OnColumnclick
//
void CAllServerLicensesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        SortByColumn(VIEW_ALL_SERVERS, PAGE_AS_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

        *pResult = 0;

}  // end CAllServerLicensesPage::OnColumnclick


//=-----------------------------------------------------------------------------------------
void CAllServerUsersPage::OnKillfocusUserList(NMHDR* , LRESULT* pResult)
{
    m_UserList.Invalidate( );

    *pResult = 0;
}

void CAllServerUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L" CAllServerUsersPage::OnSetfocusUserList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate( );

/*
    int nItem;

    int nCount = m_UserList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_UserList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_UserList.GetNextItem( -1 , LVNI_FOCUSED );

            m_UserList.Update( nItem );
        }
    }
*/
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   
}

//=-----------------------------------------------------------------------------------------
void CAllServerProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_ProcessList.Invalidate( );

    *pResult = 0;
}

void CAllServerProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{    
    ODS( L" CAllServerProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate();
/*
    int nItem;

    int nCount = m_ProcessList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_ProcessList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_ProcessList.GetNextItem( -1 , LVNI_FOCUSED );

            m_ProcessList.Update( nItem );
        }
    }
*/  
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

//=-----------------------------------------------------------------------------------------
void CAllServerWinStationsPage::OnKillfocusWinstationList(NMHDR* , LRESULT* pResult)
{
    m_StationList.Invalidate( );

    *pResult = 0;
}

//=-----------------------------------------------------------------------------------------
void CAllServerWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerWinStationsPage::OnSetfocusWinstationList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate();

/*
    int nItem;

    int nCount = m_StationList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_StationList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_StationList.GetNextItem( -1 , LVNI_FOCUSED );

            m_StationList.Update( nItem );
        }
    }
*/    
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

/////////////////////////////////////
// F'N: CAllServerWinStationsPage::ClearSelections
//
void CAllServerWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            // you could do your own processing on nItem here
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//=-----------------------------------------------------------------------------------------
void CAllServerServersPage::OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_ServerList.Invalidate();

    *pResult = 0;
}

void CAllServerServersPage::OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerServersPage::OnSetfocusServerList\n" );
   
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
/*
    int nItem;

    int nCount = m_ServerList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_ServerList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_ServerList.GetNextItem( -1 , LVNI_FOCUSED );

            m_ServerList.Update( nItem );
        }
    }
*/  
    m_ServerList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   

}

//=-----------------------------------------------------------------------------------------
void CAllServerLicensesPage::OnKillfocusLicenseList(NMHDR*, LRESULT* pResult)
{
    m_LicenseList.Invalidate();

    *pResult = 0;
}

void CAllServerLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CAllServerLicensesPage::OnSetfocusLicenseList\n" );
  
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate();

/*
    int nItem;

    int nCount = m_LicenseList.GetSelectedCount();

    if( nCount == 0 )
    {
        m_LicenseList.SetItemState( 0 , LVIS_SELECTED , LVIS_SELECTED );
    }
    else
    {
        for( int i = 0 ; i < nCount; +++i )
        {
            nItem = m_LicenseList.GetNextItem( -1 , LVNI_FOCUSED );

            m_LicenseList.Update( nItem );
        }
    }
*/    
    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;   


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\admindoc.h ===
/*******************************************************************************
*
* admindoc.h
*
* interface of the CWinAdminDoc class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\admindoc.h  $
*  
*     Rev 1.8   19 Feb 1998 17:39:36   donm
*  removed latest extension DLL support
*  
*     Rev 1.6   19 Jan 1998 16:45:32   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.5   03 Nov 1997 15:17:26   donm
*  Added Domains
*  
*     Rev 1.4   22 Oct 1997 21:06:10   donm
*  update
*  
*     Rev 1.3   18 Oct 1997 18:49:30   donm
*  update
*  
*     Rev 1.2   13 Oct 1997 18:41:42   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:13:28   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:10:14   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _ADMINDOC_H
#define _ADMINDOC_H

#include <afxmt.h>

#define TV_THISCOMP     0x1
#define TV_FAVS         0x2
#define TV_ALLSERVERS   0x4

enum FOCUS_STATE { TREE_VIEW , TAB_CTRL , PAGED_ITEM };
class CWinAdminDoc : public CDocument
{
protected: // create from serialization only
	CWinAdminDoc();
	DECLARE_DYNCREATE(CWinAdminDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinAdminDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual BOOL CanCloseFrame(CFrameWnd *pFW);
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWinAdminDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// return a pointer to the server linked list
	CObList *GetServerList() { return &m_ServerList; }
	// return a pointer to the Wd linked list
	CObList *GetWdList() { return &m_WdList; }
    // return a pointer to the domain linked list
    CObList *GetDomainList() { return &m_DomainList; }
	// remember currently selected node in tree
	void SetTreeCurrent(CObject* selected, NODETYPE type);
	// remember a temporary tree item (for some context menus)
	void SetTreeTemp(CObject* selected, NODETYPE type) {
			m_pTempSelectedNode = selected;
		    m_TempSelectedType = type;
	}
	// Returns the current view
	VIEW GetCurrentView() { return m_CurrentView; }
	// sets the  current view
	void SetCurrentView(VIEW view) { m_CurrentView = view; }
	// Returns the current page
	int GetCurrentPage() { return m_CurrentPage; }
	// sets the current page
	void SetCurrentPage(int page) { m_CurrentPage = page; }
	// Returns a pointer to the currently selected tree node
	CObject *GetCurrentSelectedNode() { return m_CurrentSelectedNode; }
	// Returns a pointer to the temp selected tree node
	CObject *GetTempSelectedNode() { return m_pTempSelectedNode; }
	// send a message to selected WinStations
	void SendWinStationMessage(BOOL bTemp, MessageParms* pParms);
	// connect to selected WinStation
	void ConnectWinStation(BOOL bTemp, BOOL bUser);	// TRUE if User, FALSE if WinStation
	// disconnect selected WinStations
	void DisconnectWinStation(BOOL bTemp);
	// reset selected WinStations
	void ResetWinStation(BOOL bTemp, BOOL bReset);	// TRUE if Reset, FALSE if Logoff
	// shadow selected WinStations
	void ShadowWinStation(BOOL bTemp);
	// show status dialog for selected WinStations
	void StatusWinStation(BOOL bTemp);
	// terminate selected processes
	void TerminateProcess();
	// do a refresh
	void Refresh();
	// Connect to selected Server(s)
	void ServerConnect();
    // Disconnect from the selected Server(s)
    void ServerDisconnect();
	// Connect to all the servers in temporarily selected Domain
	void TempDomainConnectAllServers();
	// Disconnect from all servers in temporarily selected Domain
	void TempDomainDisconnectAllServers();
	// Find all the servers in a Domain
	void DomainFindServers();
	// Connect to all the servers in currently selected Domain
	void CurrentDomainConnectAllServers();
	// Disconnect from all servers in currently selected Domain
	void CurrentDomainDisconnectAllServers();
	// Connect to all servers
	void ConnectToAllServers();
	// Disconnect from all servers
	void DisconnectFromAllServers();
	// Find all servers in all domains
	void FindAllServers();
	// lock the server linked list
	void LockServerList() { m_ServerListCriticalSection.Lock(); }
	// unlock the server linked list
	void UnlockServerList() { m_ServerListCriticalSection.Unlock(); }
	// lock the Wd linked list
	void LockWdList() { m_WdListCriticalSection.Lock(); }
	// unlock the Wd linked list
	void UnlockWdList() { m_WdListCriticalSection.Unlock(); }
	// returns a pointer to a given CServer object if it is in our list
	CServer *FindServerByName(TCHAR *pServerName);
	// returns a pointer to a given CWd object if it is in our list
	CWd *FindWdByName(TCHAR *pWdName);
	// sets the AllViewsReady variable
	void SetAllViewsReady() { 
		if(m_pMainWnd && ::IsWindow(m_pMainWnd->GetSafeHwnd())) {
			m_pMainWnd->SendMessage(WM_ADMIN_VIEWS_READY, 0, 0);
		}
		m_AllViewsReady = TRUE; 
	}
	// returns TRUE if all the views are ready
	BOOL AreAllViewsReady() { return m_AllViewsReady; }
	// sets the m_pMainWnd variable
	void SetMainWnd(CWnd *pWnd) { m_pMainWnd = pWnd; }
	// returns the m_pMainWnd variable
	CWnd *GetMainWnd() { return m_pMainWnd; }
	// returns TRUE as long as the process enum thread should keep running
	static BOOL ShouldProcessContinue() { return m_ProcessContinue; }
	// Add a Server to ServerList in sorted order
	void AddServer(CServer *pServer);
	// Inform the document that the Process List Refresh Time has changed
	void ProcessListRefreshChanged(UINT refresh) { m_ProcessWakeUpEvent.SetEvent(); }
	void FixUnknownString(TCHAR *string) { if(!wcscmp(string, m_UnknownString)) wcscpy(string,TEXT(" ")); }
	ULONG GetCurrentSubNet() { return m_CurrentSubNet; }
	void SetCurrentSubNet(ULONG sn) { m_CurrentSubNet = sn; }
	ExtServerInfo *GetDefaultExtServerInfo() { return m_pDefaultExtServerInfo; }
	ExtGlobalInfo *GetExtGlobalInfo() { return m_pExtGlobalInfo; }
    // Returns a pointer to the current domain object
    CDomain *GetCurrentDomain() { return m_pCurrentDomain; }
    // Returns a pointer to the current server object
    CServer *GetCurrentServer() { return m_pCurrentServer; }

	// Functions to check whether certain actions can be performed on the
	// currently selected items in the views
	BOOL CanConnect();
	BOOL CanDisconnect();
	BOOL CanRefresh() { return !m_InRefresh; }
	BOOL CanReset();
	BOOL CanShadow();
	BOOL CanSendMessage();
	BOOL CanStatus();
	BOOL CanLogoff();
	BOOL CanTerminate();
    BOOL CanServerConnect();
    BOOL CanServerDisconnect();
	BOOL CanTempConnect();
	BOOL CanTempDisconnect();
	BOOL CanTempReset();
	BOOL CanTempShadow();
	BOOL CanTempSendMessage();
	BOOL CanTempStatus();
	BOOL CanTempDomainConnect();
	BOOL CanTempDomainFindServers();
	BOOL CanDomainConnect();
    BOOL IsAlreadyFavorite( );

    void SetOnTabFlag( ){ m_fOnTab = TRUE; }
    void ResetOnTabFlag( ) { m_fOnTab = FALSE; }
    BOOL IsOnTabFlagged( ) { return m_fOnTab; }
	
	// Background thread to enumerate processes for the current server
	// Called with CreateThread
	static DWORD WINAPI ProcessThreadProc(LPVOID);
	HANDLE m_hProcessThread;
	static BOOL m_ProcessContinue;
	// Event to wakeup process thread so that
	// he can exit (WaitForSingleEvent instead of Sleep)
	// or enumerate processes
	CEvent m_ProcessWakeUpEvent;

	// Function to terminate a process
	// Called with AfxBeginThread
	static UINT TerminateProc(LPVOID);

    // Set the connections persistent preference
    void SetConnectionsPersistent(BOOL p) { m_ConnectionsPersistent = p; }
    // Should connections be persistent?
    BOOL AreConnectionsPersistent() { return(m_ConnectionsPersistent == TRUE); }   
    // Should we connect to a particular server?
    BOOL ShouldConnect(LPWSTR pServerName);

    BOOL ShouldAddToFav( LPTSTR pServerName );


    // Are we shutting down
    BOOL IsInShutdown() { return m_bInShutdown; }

    void ServerAddToFavorites( BOOL );

    FOCUS_STATE GetLastRegisteredFocus( ){ return m_focusstate; }
    void RegisterLastFocus( FOCUS_STATE x ) { m_focusstate = x; }

    FOCUS_STATE GetPrevFocus( ) { return m_prevFocusState; }
    void SetPrevFocus( FOCUS_STATE x ) { m_prevFocusState = x; }

    void AddToFavoritesNow();
    
    // Add a Domain to DomainList in sorted order
    void AddDomain(CDomain *pDomain);
    
    static NODETYPE gm_CurrentSelType;

private:
    
	// Read the list of trusted domains and builds linked list of domains
	void BuildDomainList();
	// builds the list of CWd objects
	void BuildWdList();
	// Helper function for the above
	BOOL CheckActionAllowed(BOOL (*CheckFunction)(CWinStation *pWinStation), BOOL AllowMultileSelected);
	// Callbacks passed to CheckActionAllowed
	static BOOL CheckConnectAllowed(CWinStation *pWinStation);
	static BOOL CheckDisconnectAllowed(CWinStation *pWinStation);
	static BOOL CheckResetAllowed(CWinStation *pWinStation);
	static BOOL CheckSendMessageAllowed(CWinStation *pWinStation);
	static BOOL CheckShadowAllowed(CWinStation *pWinStation);
	static BOOL CheckStatusAllowed(CWinStation *pWinStation);
	// Called when the CMainFrame is about to close
	// Does what the destructor used to do
	void Shutdown(CDialog *pDlg);
	// Display message string in shutdown dialog
	void ShutdownMessage(UINT id, CDialog *dlg);
	// Read the user preferences
	void ReadPreferences();
	// Write the user preferences
	void WritePreferences();

    // Function to Enumerate the Hydra Servers on the Network.
    static LPWSTR EnumHydraServers(LPWSTR pDomain, DWORD VerMajor, DWORD VerMinor);

	CObList m_ServerList;				// List of CServer objects
	CCriticalSection m_ServerListCriticalSection;

	CObList m_WdList;					// List of CWd objects
	CCriticalSection m_WdListCriticalSection;

	// List of Domains
	// This list does not have a critical section (and lock/unlock functions)
	// because it is never used by two different threads at the same time
    CObList m_DomainList;				
	CObject* m_CurrentSelectedNode;
	NODETYPE m_CurrentSelectedType;
    
	// TempSelected are for server context menus in the tree
	// so that tree item doesn't have to be selected to
	// make popup menu work
	CObject* m_pTempSelectedNode;
	NODETYPE m_TempSelectedType;

	void UpdateAllProcesses();
	LPCTSTR m_UnknownString;	// Pointer to the "(unknown)" string from UTILDLL.DLL
	ULONG m_CurrentSubNet;		// Subnet of the current server

	VIEW m_CurrentView;
	int m_CurrentPage;
	BOOL m_AllViewsReady;
	BOOL m_InRefresh;
	BOOL m_bInShutdown;
	CWnd *m_pMainWnd;
    CDomain *m_pCurrentDomain;
	CServer *m_pCurrentServer;
	ExtServerInfo *m_pDefaultExtServerInfo;
	ExtGlobalInfo *m_pExtGlobalInfo;

    // user preferences
    UINT m_ConnectionsPersistent;
    LPWSTR m_pPersistentConnections;
    LPWSTR m_pszFavList;

    FOCUS_STATE m_focusstate;
    FOCUS_STATE m_prevFocusState;

    BOOL m_fOnTab;

// Generated message map functions
protected:
	//{{AFX_MSG(CWinAdminDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif	// _ADMINDOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\allsrvpg.h ===
/*******************************************************************************
*
* allsrvpg.h
*
* - declarations for the All Servers info pages
* - the all server info pages are all CFormView derivatives
* based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\allsrvpg.h  $
*  
*     Rev 1.4   19 Jan 1998 16:45:38   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.3   03 Nov 1997 15:18:32   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:41:14   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:13:58   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:10:26   butchd
*  Initial revision.
*  
*******************************************************************************/


#ifndef _ALLSERVERPAGES_H
#define _ALLSERVERPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"


//////////////////////////
// CLASS: CAllServerServersPage
//
class CAllServerServersPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerServersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerServersPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerServersPage)
	enum { IDD = IDD_ALL_SERVER_SERVERS };
	CListCtrl	m_ServerList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxServer;		// index of Server image
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxNotSign;		// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayServers( NODETYPE );			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerServersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerServersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerServersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusServerList(NMHDR* , LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerServersPage


//////////////////////////
// CLASS: CAllServerUsersPage
//
class CAllServerUsersPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerUsersPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerUsersPage)
	enum { IDD = IDD_ALL_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers( NODETYPE );			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList( NMHDR* , LRESULT* );
    afx_msg void OnSetFocus( CWnd * );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerUsersPage


//////////////////////////
// CLASS: CAllServerWinStationsPage
//
class CAllServerWinStationsPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerWinStationsPage)
	enum { IDD = IDD_ALL_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations( NODETYPE );			
    virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList( NMHDR* , LRESULT* );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerWinStationsPage


////////////////////////////
// CLASS: CAllServerProcessesPage
//
class CAllServerProcessesPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerProcessesPage)
	enum { IDD = IDD_ALL_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateProcesses(CServer *pServer);
	void RemoveProcess(CProcess *pProcess);

private:
	virtual void Reset(void *);
	void DisplayProcesses( NODETYPE );			
	BOOL AddServerToList(CServer *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* , LRESULT* pResult);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerProcessesPage


//////////////////////////
// CLASS: CAllServerLicensesPage
//
class CAllServerLicensesPage : public CAdminPage
{
friend class CAllServersView;

protected:
	CAllServerLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServerLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CAllServerLicencesPage)
	enum { IDD = IDD_ALL_SERVER_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image

private:
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	void DisplayLicenseCounts();
	virtual void Reset(void*);
	BOOL AddServerToList(CServer *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServerLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServerLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CAllServerLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* , LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServerLicensesPage


#endif  // _ALLSERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\allsrvvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* allsrvvw.cpp
*
* implementation of the CServerView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "allsrvvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PageDef CAllServersView::pages[] = {
	{ NULL, RUNTIME_CLASS( CAllServerServersPage ),    IDS_TAB_SERVERS,     PAGE_AS_SERVERS,	PF_PICASSO_ONLY},
	{ NULL, RUNTIME_CLASS( CAllServerUsersPage ),      IDS_TAB_USERS,       PAGE_AS_USERS,		NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerWinStationsPage ),IDS_TAB_WINSTATIONS, PAGE_AS_WINSTATIONS,NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerProcessesPage ),  IDS_TAB_PROCESSES,   PAGE_AS_PROCESSES,	NULL           },
	{ NULL, RUNTIME_CLASS( CAllServerLicensesPage ),   IDS_TAB_LICENSES,    PAGE_AS_LICENSES,	PF_PICASSO_ONLY}    
};


//////////////////////////
// MESSAGE MAP: CAllServersView
//
IMPLEMENT_DYNCREATE(CAllServersView, CView)

BEGIN_MESSAGE_MAP(CAllServersView, CView)
	//{{AFX_MSG_MAP(CAllServersView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_WA_SERVER_CHANGEPAGE, OnChangePage)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_ALL_SERVERS_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )

END_MESSAGE_MAP()


///////////////////////
// F'N: CServerView ctor
//
CAllServersView::CAllServersView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_AS_USERS;

}  // end CAllServersView ctor


///////////////////////
// F'N: CAllServersView dtor
//
CAllServersView::~CAllServersView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CAllServersView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CAllServersView::AssertValid
//
void CAllServersView::AssertValid() const
{
	CView::AssertValid();

}  // end CAllServersView::AssertValid


////////////////////////
// F'N: CAllServersView::Dump
//
void CAllServersView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CAllServersView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CAllServersView::OnCreate
//
int CAllServersView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CAllServersView::OnCreate


///////////////////////////////////
// F'N: CAllServersView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CAllServersView::OnInitialUpdate() 
{
    // Determine whether we are running under Picasso
    BOOL bPicasso = ((CWinAdminApp*)AfxGetApp())->IsPicasso();

    // create the Tabs
    m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
    m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_ALL_SERVERS_TABS);


    m_pTabFont = new CFont;
    if(m_pTabFont) {
        m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
        m_pTabs->SetFont(m_pTabFont, TRUE);
    }

    TCHAR szTemp[40];
    CString tabString;

    int index = 0;
    for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
        // If the page is shown under Picasso only and we're not running
        // under Picasso, skip to the next one
        if((pages[i].flags & PF_PICASSO_ONLY) && !bPicasso) continue;
        tabString.LoadString(pages[i].tabStringID);
        lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
        AddTab(index, szTemp, i);
        pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
        pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
        GetDocument()->AddView(pages[i].m_pPage);
        index++;
    }

    m_pTabs->SetCurSel(0);	

    m_CurrPage = bPicasso ? PAGE_AS_SERVERS : PAGE_AS_USERS;

	// post a changepage msg to display the page for the currently selected tab
//	PostMessage(WM_WA_SERVER_CHANGEPAGE);

}  // end CAllServersView::OnInitialUpdate


//////////////////////////
// F'N: CAllServersView::OnSize
//
// 
//
void CAllServersView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the Tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CAllServersView::OnSize


//////////////////////////
// F'N: CAllServersView::OnDraw
//
// - the CAllServersView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CAllServersView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CAllServersView::OnDraw


/////////////////////////
// F'N: CAllServersView::Reset
//
// - 'resets' the view
//
void CAllServersView::Reset(void *p)
{
	CWaitCursor Nikki;
	SendMessage(WM_WA_SERVER_CHANGEPAGE);	// ???	Post

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// This is necessary until we update on the fly
	for(int i = 0; i < NUMBER_OF_AS_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset( p ); //NULL);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CAllServersView::Reset


//////////////////////////
// F'N: CAllServersView::AddTab
//
void CAllServersView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CAllServersView::AddTab


////////////////////////////////
// F'N: CAllServersView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
// If wParam is set, sets the focus to the page. This is currently
// only done when the user clicks on a tab
//
LRESULT CAllServersView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
				
	// switch to the appropriate view
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(index);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();
	if( wParam )
    {
        pages[index].m_pPage->SetFocus();
    }
    

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// If the new page is the processes page, we want to display the processes now
	if(index == PAGE_AS_PROCESSES)
    {
        void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

        CNodeType *pNodeType = ( CNodeType * )pCurrentSelectedNode;

        NODETYPE m;

        if( pNodeType == NULL )
        {
            m = NODE_NONE;
        }
        else
        {
            m = pNodeType->m_nodetype;
        }

        ((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->DisplayProcesses( m );
    }

	return 0;

}  // end CAllServersView::OnChangeview


void CAllServersView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"AllServersView::OnTabSelChange\n" );
	OnChangePage( 0 , 0);
	*pResult = 0;

}  // end CAllServersView::OnTabSelChange


LRESULT CAllServersView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->AddServer((CServer*)lParam);
	}		
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->AddServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->AddServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->AddServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->AddServer((CServer*)lParam);
    }
	
	return 0;

}  // end CAllServersView::OnAdminAddServer


LRESULT CAllServersView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->RemoveServer((CServer*)lParam);
	}
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->RemoveServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->RemoveServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->RemoveServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->RemoveServer((CServer*)lParam);
    }

	return 0;

}  // end CAllServersView::OnAdminRemoveServer


LRESULT CAllServersView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage) {
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);
	}
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->UpdateServer((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->UpdateServer((CServer*)lParam);
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage) {
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->UpdateServer((CServer*)lParam);
    }

	return 0;

}  // end CAllServersView::OnAdminUpdateServer


LRESULT CAllServersView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->UpdateProcesses((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminUpdateProcesses


LRESULT CAllServersView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CAllServersView::OnAdminRemoveProcess


LRESULT CAllServersView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
    NODETYPE m;

    CNodeType *pNodeType = ( CNodeType * )lParam;

    if( pNodeType == NULL )
    {
        m = NODE_NONE;
    }
    else
    {
        m = pNodeType->m_nodetype;
    }

	((CAllServerProcessesPage*)pages[PAGE_AS_PROCESSES].m_pPage)->DisplayProcesses( m );

	return 0;

}  // end CAllServersView::OnAdminRedisplayProcesses


LRESULT CAllServersView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CAllServerUsersPage*)pages[PAGE_AS_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CAllServerWinStationsPage*)pages[PAGE_AS_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminUpdateWinStations


LRESULT CAllServersView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_AS_SERVERS].m_pPage)
		((CAllServerServersPage*)pages[PAGE_AS_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_AS_LICENSES].m_pPage)
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->DisplayLicenseCounts();

	return 0;

}  // end CAllServersView::OnAdminUpdateServerInfo
 

LRESULT CAllServersView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
    if(pages[PAGE_AS_LICENSES].m_pPage)
        ((CAllServerLicensesPage*)pages[PAGE_AS_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CAllServersView::OnAdminRedisplayLicenses

//=-------------------------------------------------------------------------
// OnTabbed is called when the mainframe received VK_TAB
// this hacked fix takes advantage of the known ui layout of tsadmin
// we know we are in either three places -- treeview tabctrl listctrl
// tabbing is a forward motion so focus is moved with respect to the layout
// this code is duplicated in all view classes
//
LRESULT CAllServersView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CAllServersView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CAllServersView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CAllServersView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CAllServersView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CAllServersView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CAllServersView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\admindoc.cpp ===
/*******************************************************************************
*
* admindoc.cpp
*
* implementation of the CWinAdminDoc class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\admindoc.cpp  $
*
*     Rev 1.15   25 Apr 1998 13:43:08   donm
*  MS 2167: try to use proper Wd from registry
*
*     Rev 1.14   19 Feb 1998 17:39:28   donm
*  removed latest extension DLL support
*
*     Rev 1.12   19 Jan 1998 16:45:28   donm
*  new ui behavior for domains and servers
*
*     Rev 1.11   13 Nov 1997 13:18:46   donm
*  removed check for ICA for shadowing
*
*     Rev 1.10   07 Nov 1997 23:05:58   donm
*  fixed inability to logoff/reset
*     Rev 1.0   30 Jul 1997 17:10:10   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"

#include "admindoc.h"
#include "dialogs.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _STRESS_BUILD
extern BOOL g_fWaitForAllServersToDisconnect;
#endif

DWORD Shadow_WarningProc( LPVOID param );
INT_PTR CALLBACK ShadowWarn_WndProc( HWND , UINT , WPARAM , LPARAM );
void CenterDlg(HWND hwndToCenterOn , HWND hDlg );
HWND g_hwndShadowWarn = NULL;
DWORD g_dwTreeViewExpandedStates;

// Initialize static variable
NODETYPE CWinAdminDoc::gm_CurrentSelType = NODE_NONE;

#define WM_SETTHEEVENT ( WM_USER + 755 )

//  Sort order for Connect States
ULONG SortOrder[] =
{
        3, //State_Active               user logged on to WinStation
        2, //State_Connected    WinStation connected to client
        0, //State_ConnectQuery in the process of connecting to client
        5, //State_Shadow               shadowing another WinStation
        4, //State_Disconnected WinStation logged on without client
        6, //State_Idle                 waiting for client to connect
        1, //State_Listen               WinStation is listening for connection
        9, //State_Reset                WinStation is being reset
        7, //State_Down                 WinStation is down due to error
        8  //State_Init                 WinStation in initialization
};

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc

IMPLEMENT_DYNCREATE(CWinAdminDoc, CDocument)

BEGIN_MESSAGE_MAP(CWinAdminDoc, CDocument)
        //{{AFX_MSG_MAP(CWinAdminDoc)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CWinAdminDoc::m_ProcessContinue = TRUE;

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc constructor
//
CWinAdminDoc::CWinAdminDoc()
{
    // TODO: add one-time construction code here
    m_CurrentSelectedNode = NULL;
    m_CurrentSelectedType = NODE_NONE;
    m_pTempSelectedNode = NULL;
    m_TempSelectedType = NODE_NONE;
    m_AllViewsReady = FALSE;
    m_hProcessThread = NULL;
    m_pCurrentDomain = NULL;
    m_pCurrentServer = NULL;
    m_pPersistentConnections = NULL;
    m_InRefresh = FALSE;
    m_bInShutdown = FALSE;
    m_UnknownString = ::GetUnknownString();

    ASSERT( m_UnknownString != NULL );

    ((CWinAdminApp*)AfxGetApp())->SetDocument(this);

    // If there is an extension DLL, get a pointer to it's global
    // info structure
    LPFNEXGETGLOBALINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetGlobalInfoProc();
    if(InfoProc)
    {
        m_pExtGlobalInfo = (*InfoProc)();
    }
    else
    {
        m_pExtGlobalInfo = NULL;
    }
    // create the default extended server info
    // for servers that haven't had their extended info
    // created yet
    m_pDefaultExtServerInfo = new ExtServerInfo;
    CString NAString;
    NAString.LoadString(IDS_NOT_APPLICABLE);

    memset(m_pDefaultExtServerInfo, 0, sizeof(ExtServerInfo));
    // This is so the N/A TcpAddresses will sort at the end
    m_pDefaultExtServerInfo->RawTcpAddress = 0xFFFFFFFF;
    m_pDefaultExtServerInfo->ServerTotalInUse = 0xFFFFFFFF;
    lstrcpyn(m_pDefaultExtServerInfo->TcpAddress, NAString, sizeof(m_pDefaultExtServerInfo->TcpAddress) / sizeof(TCHAR));
    lstrcpyn(m_pDefaultExtServerInfo->IpxAddress, NAString, sizeof(m_pDefaultExtServerInfo->IpxAddress) / sizeof(TCHAR));

    m_focusstate = TREE_VIEW;
    m_prevFocusState = TAB_CTRL;
    m_fOnTab = FALSE;

    m_pszFavList = NULL;

}  // end CWinAdminDoc::CWinAdminDoc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc destructor
//
CWinAdminDoc::~CWinAdminDoc()
{
        // all code moved to Shutdown();

   delete m_pDefaultExtServerInfo;
   if(m_pPersistentConnections) LocalFree(m_pPersistentConnections);

   if( m_UnknownString != NULL )
   {
       LocalFree( ( PVOID )m_UnknownString );
   }

}       // end CWinAdminDoc::~CWinAdminDoc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShutdownMessage
//
void CWinAdminDoc::ShutdownMessage(UINT id, CDialog *pDlg)
{
        ASSERT(pDlg);

        CString AString;

        AString.LoadString(id);
        pDlg->SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

}       // end CWinAdminDoc::ShutdownMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::Shutdown
//
void CWinAdminDoc::Shutdown(CDialog *pDlg)
{
    ASSERT(pDlg);
    
    m_bInShutdown = TRUE;
    
    // Iterate through the domain list
    POSITION pos = m_DomainList.GetHeadPosition();    
    
    ShutdownMessage(IDS_SHUTDOWN_DOMAINTHREADS, pDlg);
    
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        pDomain->ClearBackgroundContinue();
        // Fire off the event to wake him up if he is
        // waiting
        pDomain->SetEnumEvent();
    }
    
    pos = m_DomainList.GetHeadPosition();
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        pDomain->StopEnumerating();
    }

    // Tell the process thread to terminate and wait for it to do so
    
    // make sure the process thread is still running first
    DWORD dwThreadExitCode;
    GetExitCodeThread(m_hProcessThread, &dwThreadExitCode);
    if (dwThreadExitCode == STILL_ACTIVE)
    {
        ShutdownMessage(IDS_SHUTDOWN_PROCTHREAD, pDlg);
                
        m_ProcessContinue = FALSE;

        // fire off the event to wake him up if he is waiting
        m_ProcessWakeUpEvent.SetEvent();

        // wait until the thread is finished
        WaitForSingleObject(m_hProcessThread, INFINITE);

        // we're done with our process thread so we can close the handle
        CloseHandle(m_hProcessThread);
    }

    ShutdownMessage(IDS_SHUTDOWN_PREFS, pDlg);
    
    WritePreferences();
    
    LockServerList();
    
    ShutdownMessage(IDS_SHUTDOWN_NOTIFY, pDlg);
    
    // First, tell all the server background threads to stop.
    // We do this before the destructor for each server does it
    // so that the background threads for all the servers can stop
    // and we don't have to wait until we get to the destructor for
    // each server
    pos = m_ServerList.GetHeadPosition();
    
    while(pos)
    {
        // Go to the next server in the list
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        pServer->ClearBackgroundContinue();
    }
    
    // Iterate through the server list
    pos = m_ServerList.GetHeadPosition();
    
    while(pos) {
        // Go to the next server in the list
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        if(pServer->IsState(SS_GOOD)) {
            CString AString;
            AString.Format(IDS_DISCONNECTING, pServer->GetName());
            pDlg->SetDlgItemText(IDC_SHUTDOWN_MSG, AString);
        }
        
        pServer->Disconnect( );
        
        delete pServer;
    }
    
    m_ServerList.RemoveAll();
    UnlockServerList();
    
    // Iterate through the domain list
    pos = m_DomainList.GetHeadPosition();
    
    while(pos) {
        // Go to the next domain in the list
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
        delete pDomain;
    }
    
    m_DomainList.RemoveAll();
    
    // If there is an extension DLL, call it's shutdown function
    LPFNEXSHUTDOWNPROC ShutdownProc = ((CWinAdminApp*)AfxGetApp())->GetExtShutdownProc();
    if(ShutdownProc) {
        (*ShutdownProc)();
    }
    
    // Iterate through the Wd list
    LockWdList();
    
    pos = m_WdList.GetHeadPosition();
    
    while(pos) {
        // Go to the next Wd in the list
        CWd *pWd = (CWd*)m_WdList.GetNext(pos);
        delete pWd;
    }
    
    m_WdList.RemoveAll();
    UnlockWdList();
    
    ShutdownMessage(IDS_DONE, pDlg);
    
}       // end CWinAdminDoc::Shutdown


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanCloseFrame
//
BOOL CWinAdminDoc::CanCloseFrame(CFrameWnd *pFW)
{
    ASSERT(pFW);
    
    CWaitCursor Nikki;
    
    CDialog dlgWait;
    dlgWait.Create(IDD_SHUTDOWN, pFW);
    
    Shutdown(&dlgWait);
    
    dlgWait.PostMessage(WM_CLOSE);
    return TRUE;
    
}       // end CWinAdminDoc::CanCloseFrame


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::OnNewDocument
//
BOOL CWinAdminDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    
    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)
    
    ReadPreferences();
    
    BuildWdList();
    
    BuildDomainList();
    
    // Create a pServer object for the Server we are running on, this will give
    // him a headstart in getting his information
    CServer *pServer = new CServer(m_pCurrentDomain, ((CWinAdminApp*)AfxGetApp())->GetCurrentServerName(), FALSE, TRUE);
    
    m_pCurrentServer = pServer;
    
    if( pServer )
    {
        AddServer(pServer);
    }
    
    // Start enumerating servers in the current domain
    // if(m_pCurrentDomain) m_pCurrentDomain->StartEnumerating();
    
    // Start the background thread to enumerate processes  
    DWORD dwThreadID;
    m_hProcessThread = CreateThread(NULL,       // default security attributes
                                    0,          // default stack size
                                    CWinAdminDoc::ProcessThreadProc,     
                                    this,       // param passed into threadProc
                                    0,          // default creation flags
                                    &dwThreadID);
    // make sure our thread created by ensuring the handle is non null
    if (!m_hProcessThread)
    {
        return FALSE;
    }
    
    return TRUE;
    
}       // end CWinAdminDoc::OnNewDocument


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc serialization
//
void CWinAdminDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
    
}       // end CWinAdminDoc::Serialize


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc diagnostics
//
#ifdef _DEBUG
void CWinAdminDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CWinAdminDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShouldConnect
//
// Returns TRUE if the server is in the list of persistent connections
//
BOOL CWinAdminDoc::ShouldConnect(LPWSTR pServerName)
{
    ASSERT(pServerName);
    
    if(m_ConnectionsPersistent && m_pPersistentConnections)
    {
        LPWSTR pTemp = m_pPersistentConnections;
        while(*pTemp)
        {
            if( !wcscmp( pTemp , pServerName ) )
            {
                return TRUE;
            }
            
            // Go to the next server in the buffer
            
            pTemp += (wcslen(pTemp) + 1);
        }
    }
    
    return FALSE;
}

//=-------------------------------------------------------------------
BOOL CWinAdminDoc::ShouldAddToFav( LPTSTR pServerName )
{
    ODS( L"CWinAdminDoc::ShouldAddToFav\n" );
    
    if( m_pszFavList != NULL )
    {
        LPTSTR pszTemp = m_pszFavList;
        
        while(*pszTemp)
        {
            if( !wcscmp( pszTemp , pServerName ) )
            {
                DBGMSG( L"Adding %s to favorites\n" , pszTemp );
                return TRUE;
            }
            
            // Go to the next server in the buffer
            
            pszTemp += ( wcslen( pszTemp ) + 1 );
        }
    }
    
    return FALSE;
}



/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ProcessThreadProc
//
// Static member function for process thread
// Called with AfxBeginThread
// Thread terminates when function returns
//
DWORD WINAPI CWinAdminDoc::ProcessThreadProc(LPVOID _doc)
{
    ASSERT(_doc);
    
    // We need a pointer to the document so we can make
    // calls to member functions
    CWinAdminDoc *pDoc = (CWinAdminDoc*)_doc;
    
    // We can't send messages to the view until they're ready
    
    while(!pDoc->AreAllViewsReady()) Sleep(500);
    
    pDoc->AddToFavoritesNow( );
    
    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
    
    if( p != NULL )
    {
        
        p->SendMessage( WM_ADMIN_UPDATE_TVSTATE , 0 , 0 );
    }
    
    while(1) {
        // We don't want to do this constantly, it eats up processor cycles
        // Document destructor will signal the event to wake us up if he
        // wants us to quit
        pDoc->m_ProcessWakeUpEvent.Lock(((CWinAdminApp*)AfxGetApp())->GetProcessListRefreshTime());
        
        // Make sure we don't have to quit
        if(!ShouldProcessContinue()) return 0;
        
        // We only want to enumerate processes if the page is VIEW_SERVER or VIEW_WINSTATION
        if(pDoc->GetCurrentView() == VIEW_SERVER || pDoc->GetCurrentView() == VIEW_WINSTATION) {
            CServer *pServer = (pDoc->GetCurrentView() == VIEW_SERVER) ? (CServer*)pDoc->GetCurrentSelectedNode()
                : (CServer*)((CWinStation*)pDoc->GetCurrentSelectedNode())->GetServer();
            
            // Enumerate processes for this server if his state is SS_GOOD
            if(pServer->IsState(SS_GOOD)) {
                pServer->EnumerateProcesses();
            }
            
            // Make sure we don't have to quit
            if(!ShouldProcessContinue()) return 0;
            
            // We only want to send a message to update the view if the
            // view is still VEIW_SERVER/VIEW_WINSTATION and the currently
            // selected Server is the same one that we just enumerate processes for
            if((pDoc->GetCurrentView() == VIEW_SERVER && pServer == (CServer*)pDoc->GetCurrentSelectedNode())
                || (pDoc->GetCurrentView() == VIEW_WINSTATION && pServer == (CServer*)((CWinStation*)pDoc->GetCurrentSelectedNode())->GetServer())) {
                CFrameWnd *pWnd = (CFrameWnd*)pDoc->GetMainWnd();
                if(pWnd && ::IsWindow(pWnd->GetSafeHwnd())) pWnd->SendMessage(WM_ADMIN_UPDATE_PROCESSES, 0, (LPARAM)pServer);
            }
        }
        
        // Make sure we don't have to quit
        if(!ShouldProcessContinue()) return 0;
        
    }
    
    return 0;
    
}       // end CWinAdminDoc::ProcessThreadProc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::UpdateAllProcesses
//
void CWinAdminDoc::UpdateAllProcesses()
{
    LockServerList();
    
    POSITION pos = m_ServerList.GetHeadPosition();
    while(pos) {
        
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        // Enumerate processes for this server if his state is SS_GOOD
        if(pServer->IsState(SS_GOOD)) {
            pServer->EnumerateProcesses();
            
            // Send a message to the view to update this server's processes
            CFrameWnd *p = (CFrameWnd*)GetMainWnd();
            if(p && ::IsWindow(p->GetSafeHwnd())) p->SendMessage(WM_ADMIN_UPDATE_PROCESSES, 0, (LPARAM)pServer);
        }
    }
    
    UnlockServerList();
    
}       // end CWinAdminDoc::UpdateAllProcesses


static TCHAR szWinAdminAppKey[] = REG_SOFTWARE_TSERVER TEXT("\\TSADMIN");
static TCHAR szConnectionsPersistent[] = TEXT("ConnectionsPersistent");
static TCHAR szFavList[] = TEXT("Favorites" );
static TCHAR szTVStates[] = TEXT( "TreeViewStates" );
static TCHAR szConnections[] = TEXT("Connections");

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ReadPreferences
//
// Read user preferences
//
void CWinAdminDoc::ReadPreferences()
{
    HKEY hKeyWinAdmin;
    DWORD dwType, cbData, dwValue;
    
    // Set to defaults
    m_ConnectionsPersistent = FALSE;
    
    // Open registry key for our application
    DWORD Disposition;
    
    if( RegCreateKeyEx( HKEY_CURRENT_USER ,
        szWinAdminAppKey,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_READ,
        NULL,
        &hKeyWinAdmin,
        &Disposition) != ERROR_SUCCESS )
    {
        return;
    }
    
    // Read the favorites list
    DWORD dwLen = 0;
    
    dwType = 0;
    
    // See how big the multi-string is
    
    int err = RegQueryValueEx( hKeyWinAdmin,
        szFavList,
        NULL,
        &dwType,
        NULL,
        &dwLen );
    
    if( err == ERROR_SUCCESS || err == ERROR_BUFFER_OVERFLOW )
    {
        m_pszFavList = ( LPWSTR )LocalAlloc( 0 , dwLen );
        
        if( m_pszFavList != NULL )
        {
            memset( m_pszFavList , 0 , dwLen );
            
            RegQueryValueEx( hKeyWinAdmin,
                szFavList,
                NULL,
                &dwType,
                (LPBYTE)m_pszFavList,
                &dwLen);            
        }        
    }        
    
    
    // Read the Connections Persist preference
    
    cbData = sizeof( m_ConnectionsPersistent );
    
    if( RegQueryValueEx( hKeyWinAdmin ,
        szConnectionsPersistent ,
        NULL,
        &dwType,
        (LPBYTE)&dwValue,
        &cbData) == ERROR_SUCCESS)
    {
        m_ConnectionsPersistent = dwValue;
    }
    
    // If connections are persistent, read the list of connections saved
    if( m_ConnectionsPersistent )
    {
        dwLen = 0;
        dwType = 0;
        // See how big the multi-string is
        err = RegQueryValueEx( hKeyWinAdmin,
            szConnections,
            NULL,
            &dwType,
            NULL,
            &dwLen );
        
        if(err && (err != ERROR_BUFFER_OVERFLOW) )
        {
            RegCloseKey(hKeyWinAdmin);
            return;
        }        
        
        m_pPersistentConnections = (LPWSTR)LocalAlloc(0, dwLen);
        
        if( m_pPersistentConnections != NULL )
        {
            memset(m_pPersistentConnections, 0, dwLen);
            
            RegQueryValueEx( hKeyWinAdmin,
                szConnections,
                NULL,
                &dwType,
                (LPBYTE)m_pPersistentConnections,
                &dwLen);
        }
    }
    
    g_dwTreeViewExpandedStates = 0;
    
    dwLen = sizeof( g_dwTreeViewExpandedStates );
    
    RegQueryValueEx( hKeyWinAdmin , 
        szTVStates,
        NULL,
        &dwType,
        ( LPBYTE )&g_dwTreeViewExpandedStates,
        &dwLen );
    
    
    RegCloseKey(hKeyWinAdmin);
    
}       // end CWinAdminDoc::ReadPreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::WritePreferences
//
// Write user preferences
//
void CWinAdminDoc::WritePreferences()
{
    HKEY hKeyWinAdmin;
    DWORD dwValue;
    
    // Open registry key for our application
    DWORD Disposition;

    if( RegCreateKeyEx( HKEY_CURRENT_USER,
                        szWinAdminAppKey,
                        0,
                        TEXT(""),
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &hKeyWinAdmin,
                        &Disposition) != ERROR_SUCCESS )
    {
        return;
    }
    
    // Write the servers that are in the favorite list
    DWORD dwByteCount = 0;
    
    LockServerList();

    POSITION pos = m_ServerList.GetHeadPosition();

#ifdef _STRESS_BUILD
    int nStressServerLimit = 0;
#endif;

    while(pos)
    {
#ifdef _STRESS_BUILD
        if( nStressServerLimit >= 10000 )
        {
            break;
        }

        nStressServerLimit++;
#endif

        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

        if( pServer->GetTreeItemFromFav( ) != NULL )
        {
            // format is domain/server
            if( pServer->GetDomain( ) )
            {
                dwByteCount += ( wcslen( pServer->GetDomain( )->GetName() ) * 2 );
                dwByteCount += 2;
            }
            dwByteCount += ( wcslen( pServer->GetName() ) + 1) * 2;
        }
    }

    LPWSTR pBuffer = NULL;

    if( dwByteCount != 0 )
    {
        dwByteCount += 2;   // for ending null

        // Allocate memory.       

        if( ( pBuffer = ( LPWSTR )LocalAlloc( LPTR, dwByteCount ) ) != NULL )
        {
            // Traverse list again and copy servers to buffer.
            LPWSTR pTemp = pBuffer;

            pos = m_ServerList.GetHeadPosition();

#ifdef _STRESS_BUILD 
            nStressServerLimit = 0;
#endif

            while(pos)
            {

#ifdef _STRESS_BUILD
                if( nStressServerLimit >= 10000 )
                {
                    break;
                }

                nStressServerLimit++;
#endif
                // Go to the next server in the list
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

                if( pServer->GetTreeItemFromFav( ) != NULL )
                {
                    if( pServer->GetDomain( ) )
                    {
                        lstrcpy( pTemp , pServer->GetDomain( )->GetName( ) );
                        lstrcat( pTemp , L"/" );
                    }
                    lstrcat(pTemp, pServer->GetName());

                    pTemp += ( wcslen( pTemp ) + 1);
                }
            }
        
            *pTemp = L'\0';     // ending null
        
            RegSetValueEx (hKeyWinAdmin, szFavList, 0, REG_MULTI_SZ, (PBYTE)pBuffer, dwByteCount);
        
            LocalFree(pBuffer);        
        }
    }
    else
    {
        RegDeleteValue( hKeyWinAdmin , szFavList );
    }

    UnlockServerList();

    // Write the persistent connections preference
    dwValue = m_ConnectionsPersistent;

    RegSetValueEx( hKeyWinAdmin,
                   szConnectionsPersistent,
                   0,
                   REG_DWORD,
                   (LPBYTE)&dwValue,
                   sizeof(DWORD)
                   );
    
    if( m_ConnectionsPersistent )
    {
        // Create a multistring of the persistent connections
        // loop through the list of servers and see how much memory
        // to allocate for the multistring.
        dwByteCount = 0;
        
        LockServerList();
        pos = m_ServerList.GetHeadPosition();
        while(pos)
        {
            // Go to the next server in the list
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if( pServer->IsState(SS_GOOD) )
            {
                dwByteCount += (wcslen(pServer->GetName()) + 1) * 2;
            }
        }
        
        UnlockServerList();

        dwByteCount += 2;   // for ending null
        
        // Allocate memory.
        pBuffer = NULL;
        
        if( ( pBuffer = ( LPWSTR )LocalAlloc( LPTR, dwByteCount ) ) != NULL )
        {
            // Traverse list again and copy servers to buffer.
            LPWSTR pTemp = pBuffer;            
            LockServerList();
            pos = m_ServerList.GetHeadPosition();
            while(pos)
            {
                // Go to the next server in the list
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if( pServer->IsState(SS_GOOD) )
                {
                    wcscpy(pTemp, pServer->GetName());
                    pTemp += (wcslen(pServer->GetName()) + 1);
                }
            }
            
            UnlockServerList();
            
            *pTemp = L'\0';     // ending null
            
            // write the registry entry
            RegSetValueEx(hKeyWinAdmin, szConnections, 0, REG_MULTI_SZ, (PBYTE)pBuffer, dwByteCount);
            
            LocalFree(pBuffer);
        }

    }
    else
    {
        RegDeleteValue(hKeyWinAdmin, szConnections);
    }

    // persist treeview state

    // send message to treeview to retreive tv state bits

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    DWORD dwTVStates = 0;

    if( p != NULL )
    {
        dwTVStates = ( DWORD )p->SendMessage( WM_ADMIN_GET_TV_STATES , 0 , 0 );
    }

    RegSetValueEx( hKeyWinAdmin , szTVStates , 0 , REG_DWORD , ( PBYTE )&dwTVStates , sizeof( DWORD ) );
    
    RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminDoc::WritePreferences

/*
static TCHAR DOMAIN_KEY[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
static TCHAR PRIMARY_VAL[] = TEXT("CachePrimaryDomain");
static TCHAR CACHE_VAL[] =  TEXT("DomainCache");
*/

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::BuildDomainList
//
// Read the list of trusted domains from the registry
// and build a linked list of CDomains
//
void CWinAdminDoc::BuildDomainList()
{
    /*
    HKEY hKey,hSubKey;
    DWORD size = 128;
    DWORD dwIndex = 0;
    */
    
    PDOMAIN_CONTROLLER_INFO pDCI;


    if( DsGetDcName( NULL ,
                     NULL , 
                     NULL ,
                     NULL ,
                     DS_RETURN_FLAT_NAME,
                     &pDCI ) == NO_ERROR )
    {
        CDomain *pDomain = new CDomain( pDCI->DomainName );

        if(pDomain != NULL )
        {
            pDomain->SetCurrentDomain();

            m_pCurrentDomain = pDomain;

            AddDomain( pDomain );
        }

        NetApiBufferFree( pDCI );


        // query for the other domains

        LPWSTR szDomainNames = NULL;

        if( NetEnumerateTrustedDomains( NULL ,
                                        &szDomainNames ) == ERROR_SUCCESS )
        {
            LPWSTR pszDN = szDomainNames;

            while( *pszDN )
            {
                CDomain *pNewDomain = new CDomain( pszDN );
            
                if( pNewDomain != NULL )
                {
                    AddDomain( pNewDomain );
                }
            
                pszDN += ( wcslen( pszDN ) + 1 );
            }
    
            NetApiBufferFree( szDomainNames );
        }
    }
}       // end CWinAdminDoc::BuildDomainList


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::AddDomain
//
// Add a Domain to DomainList in sorted order
//
void CWinAdminDoc::AddDomain(CDomain *pNewDomain)
{
    ASSERT(pNewDomain);

        BOOLEAN bAdded = FALSE;
        POSITION pos, oldpos;
        int Index;

        // Traverse the DomainList and insert this new Domain,
        // keeping the list sorted by Name.
    for(Index = 0, pos = m_DomainList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);

        if(wcscmp(pDomain->GetName(), pNewDomain->GetName()) > 0) {
            // The new object belongs before the current list object.
            m_DomainList.InsertBefore(oldpos, pNewDomain);
                        bAdded = TRUE;
                        // NOTE: If you add a critical section to protect the domain list,
                        // you should change this to a break; and unlock the list
                        // just before exiting this function
            return;
        }
    }

    // If we haven't yet added the Domain, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_DomainList.AddTail(pNewDomain);
        }

}       // end CWinAdminDoc::AddDomain


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::BuildWdList
//
// Read the list of Wds from the registry
// and build a linked list of CWds
//
void CWinAdminDoc::BuildWdList()
{
    LONG Status;
    ULONG Index, ByteCount, Entries;
    WDNAME WdKey;
    LONG QStatus;
    WDCONFIG2 WdConfig;
    TCHAR WdDll[MAX_PATH];
        CWd *pWd;

        // Initialize the Wd list.
    for ( Index = 0, Entries = 1, ByteCount = sizeof(WDNAME);
          (Status =
           RegWdEnumerate( SERVERNAME_CURRENT,
                           &Index,
                           &Entries,
                           WdKey,
                           &ByteCount )) == ERROR_SUCCESS;
          ByteCount = sizeof(WDNAME) ) {

        if ( ( QStatus = RegWdQuery( SERVERNAME_CURRENT, WdKey, &WdConfig,
                                     sizeof(WdConfig),
                                     &ByteCount ) ) != ERROR_SUCCESS ) {

//If this is added back in, the signature of StandardErrorMessage has changed!!!!
#if 0
            STANDARD_ERROR_MESSAGE(( WINAPPSTUFF, LOGONID_NONE, QStatus,
                                     IDP_ERROR_REGWDQUERY, WdKey ))
            return(FALSE);
#endif
        }

        /*
         * Only place this Wd in the WdList if it's DLL is present
         * on the system.
         */
        GetSystemDirectory( WdDll, MAX_PATH );
        lstrcat( WdDll, TEXT("\\Drivers\\") );
        lstrcat( WdDll, WdConfig.Wd.WdDLL );
        lstrcat( WdDll, TEXT(".sys" ) );
        if ( _waccess( WdDll, 0 ) != 0 )
            continue;

        pWd = new CWd(&WdConfig, (PWDNAME)&WdKey);

        m_WdList.AddTail(pWd);
        }

}       // end CWinAdminDoc::BuildWdList


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::Refresh
//
// Perform a Refresh
//
void CWinAdminDoc::Refresh()
{
        // We don't want to refresh if we are currently doing one
        if(m_InRefresh) return;

        CWaitCursor Nikki;

        m_InRefresh = TRUE;

        // Wake up our background tasks that enumerates servers
        POSITION pos = m_DomainList.GetHeadPosition();
        while(pos) {
                CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
                pDomain->SetEnumEvent();
        }

        // Make each of the Server's background tasks enumerate WinStations
        LockServerList();
        pos = m_ServerList.GetHeadPosition();
        while(pos) {
                ULONG WSEventFlags;
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if(pServer->IsHandleGood() && pServer->IsState(SS_GOOD)) {
                        WinStationWaitSystemEvent(pServer->GetHandle(), WEVENT_FLUSH, &WSEventFlags);
                }
        }

        UnlockServerList();

        // If the current page is a processes page, tell appropriate process enumeration
        // background thread to do their thing

        if(m_CurrentView == VIEW_ALL_SERVERS && m_CurrentPage == PAGE_AS_PROCESSES) {
                UpdateAllProcesses();
        }

        if(m_CurrentView == VIEW_DOMAIN && m_CurrentPage == PAGE_DOMAIN_PROCESSES) {
                UpdateAllProcesses();
        }

        if((m_CurrentView == VIEW_SERVER && m_CurrentPage == PAGE_PROCESSES)
                || (m_CurrentView == VIEW_WINSTATION && m_CurrentPage == PAGE_WS_PROCESSES)) {
                m_ProcessWakeUpEvent.SetEvent();
        }

        m_InRefresh = FALSE;

}  // end CWinAdminDoc::Refresh


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::AddServer
//
// Add a Server to ServerList in sorted order
//
void CWinAdminDoc::AddServer(CServer *pNewServer)
{
    ASSERT(pNewServer);
    
    LockServerList();
    
    BOOLEAN bAdded = FALSE;
    POSITION pos, oldpos;
    int Index;
    
    // Traverse the ServerList and insert this new Server,
    // keeping the list sorted by Name.
    for(Index = 0, pos = m_ServerList.GetHeadPosition(); pos != NULL; Index++)
    {
        oldpos = pos;

        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        
        if( lstrcmpi( pServer->GetName() , pNewServer->GetName() ) > 0 )
        {
            // The new object belongs before the current list object.
            m_ServerList.InsertBefore(oldpos, pNewServer);
            bAdded = TRUE;
            break;
        }
    }
    
    // If we haven't yet added the Server, add it now to the tail
    // of the list.
    if(!bAdded)
    {
        m_ServerList.AddTail(pNewServer);
    }
    
    UnlockServerList();

}       // end CWinAdminDoc::AddServer

//=----------------------------------------------------------------------------------
//= AddToFavoritesNow will add all persisted servers to the fav node and
//= connect to them as appropriate.
void CWinAdminDoc::AddToFavoritesNow( )
{
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    LPTSTR pszDomain = NULL;
    LPTSTR pszServer = NULL;
    LPTSTR pszDomServer = NULL;

    int nJump = 0;

    POSITION pos;

    if( m_pszFavList != NULL )
    {
        pszDomServer = m_pszFavList;
        
        while( *pszDomServer )
        {
            pos = m_DomainList.GetHeadPosition();

            nJump = wcslen( pszDomServer );

            pszDomain = pszDomServer;

            TCHAR *pTemp = pszDomServer;

            while( *pTemp )
            {
                if( *pTemp == L'/' )
                {
                    break;
                }

                pTemp++;
            }
            
            if(*pTemp == L'/')
            {
                *pTemp = 0;
                pTemp++;
                pszServer = pTemp;
            }
            else
            {
                //there is no domain for this server
                pszServer = pszDomServer;
                pszDomain = NULL;
            }
            
            // let's check to see if server already exist primarily "this computer"
            if( m_pCurrentServer != NULL && lstrcmpi( pszServer , m_pCurrentServer->GetName( ) ) == 0 )
            {
                p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)m_pCurrentServer );
            }
            else
            {
                CDomain *pDomain = NULL;
                CServer *pServer = NULL;

                if( pszDomain )
                {
                    BOOL bFound = FALSE;

                    while( pos )
                    {                
                        pDomain = (CDomain*)m_DomainList.GetNext(pos);                
                
                        if( _wcsicmp( pDomain->GetName() ,  pszDomain ) == 0 )
                        {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if(!bFound)
                    {
                        pDomain = new CDomain( pszDomain );

                        if( pDomain != NULL )
                        {
                            AddDomain( pDomain );
                         
                            p->SendMessage( WM_ADMIN_ADD_DOMAIN , (WPARAM)NULL , ( LPARAM )pDomain );
                        }
                    }
                }

                pServer = new CServer( pDomain , pszServer , FALSE , FALSE );
                
                if( pServer != NULL )
                {
                    pServer->SetManualFind( );

                    AddServer(pServer);
        
                    p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)pServer);
        
                }
            }
            
            pszDomServer += nJump + 1;                        
        }
    }   

    // check to see if we need to connect these servers.

    LockServerList();

    pos = m_ServerList.GetHeadPosition();

    while( pos )
    {
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);

        if( ShouldConnect( pServer->GetName( ) ) )
        {
            if( pServer->GetTreeItemFromFav( ) != NULL )
            {
                pServer->Connect( );
            }
        }
    }


    UnlockServerList();


}
/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindServerByName
//
// returns a pointer to a given CServer object if it is in our list
//
CServer* CWinAdminDoc::FindServerByName(TCHAR *pServerName)
{
        ASSERT(pServerName);

        LockServerList();

        POSITION pos = m_ServerList.GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                if( lstrcmpi( pServer->GetName() , pServerName ) == 0)
                {
                    UnlockServerList();
                    return pServer;
                }
        }

        UnlockServerList();

        return NULL;

}       // end CWinAdminDoc::FindServerByName


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindWdByName
//
// returns a pointer to a given CWd object if it is in our list
//
CWd* CWinAdminDoc::FindWdByName(TCHAR *pWdName)
{
        ASSERT(pWdName);

        LockWdList();

        POSITION pos = m_WdList.GetHeadPosition();

        while(pos) {
                CWd *pWd = (CWd*)m_WdList.GetNext(pos);
                if(wcscmp(pWd->GetName(), pWdName) == 0) {
                        UnlockWdList();
                        return pWd;
                }
        }

        UnlockWdList();

        return NULL;

}       // end CWinAdminDoc::FindWdByName


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::SetTreeCurrent
//
void CWinAdminDoc::SetTreeCurrent(CObject* selected, NODETYPE type)
{
        m_CurrentSelectedNode = selected;
        m_CurrentSelectedType = type;
        
        // We need to be able to check the current selected type from other 
        // threads, in particular when resetting, disconnecting and sending
        // a message, to check that we still have a valid winstation
        CWinAdminDoc::gm_CurrentSelType = type;
        CString TitleString;

        // Set the window title
        switch(m_CurrentSelectedType) {
                case NODE_ALL_SERVERS:
                        TitleString.LoadString(IDS_TREEROOT);
                        SetTitle(TitleString);
                        break;
                case NODE_DOMAIN:
                        TitleString.Format(TEXT("\\\\%s"), ((CDomain*)selected)->GetName());
                        SetTitle(TitleString);
                        break;
                case NODE_SERVER:
                        SetTitle(((CServer*)selected)->GetName());
                        break;
                case NODE_WINSTATION:
                        SetTitle(((CWinStation*)selected)->GetServer()->GetName());
                        break;

                case NODE_THIS_COMP:
                        TitleString.LoadString( IDS_THISCOMPUTER );
                        SetTitle( TitleString );
                        break;

                case NODE_FAV_LIST:
                        TitleString.LoadString( IDS_FAVSERVERS );
                        SetTitle( TitleString );
                        break;
        }

}       // end CWinAdminDoc::SetTreeCurrent


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::SendWinStationMessage
//
//      bTemp is TRUE if message is to be sent to the temporarily selected
//      tree item.
//
void CWinAdminDoc::SendWinStationMessage(BOOL bTemp, MessageParms *pParms)
{
    ASSERT(pParms);

    // Are we sending a message to temporarily selected tree item?
    if(bTemp) 
    {
        // Is the temporarily selected item in the tree a WinStation?
        if(m_TempSelectedType == NODE_WINSTATION) 
        {
            // If the winstation we're working on disappears before we get here
            // then just return
            if (m_CurrentSelectedType != NODE_WINSTATION)
            {
                return;
            }

            pParms->pWinStation = (CWinStation*)m_pTempSelectedNode;
            pParms->bActionOnCurrentSelection = TRUE;
            AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParms);
        }

        return;
    }

    // Is the WinStation selected in the tree?
    if(m_CurrentSelectedType == NODE_WINSTATION) 
    {
        pParms->pWinStation = (CWinStation*)m_CurrentSelectedNode;
        pParms->bActionOnCurrentSelection = TRUE;
        AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParms);
    }

    // Go through the list of WinStations on the currently selected server
    // and send messages to those that are selected
    else if(m_CurrentView == VIEW_SERVER) 
    {
        // Get a pointer to the selected server
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // Lock the server's list of WinStations
        pServer->LockWinStationList();
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) 
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected()) 
            {
                // Make a copy of the MessageParms
                MessageParms *pParmsCopy = new MessageParms;
                if(pParmsCopy) 
                {
                    memcpy(pParmsCopy, pParms, sizeof(MessageParms));
                    // Start a thread to send the message
                    pParmsCopy->pWinStation = pWinStation;
                    pParmsCopy->bActionOnCurrentSelection = FALSE;
                    AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParmsCopy);
                }
            }
        }

        // Unlock the list of WinStations
        pServer->UnlockWinStationList();

        // Delete MessageParms - we sent copies to the WinStation objects
        // They will delete their copies
        delete pParms;
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) 
    {
        LockServerList();
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2) 
        {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            // Lock the server's list of WinStations
            pServer->LockWinStationList();
            // Get a pointer to the server's list of WinStations
            CObList *pWinStationList = pServer->GetWinStationList();

            // Iterate through the WinStation list
            POSITION pos = pWinStationList->GetHeadPosition();

            while(pos) 
            {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                if(pWinStation->IsSelected()) 
                {
                    // Make a copy of the MessageParms
                    MessageParms *pParmsCopy = new MessageParms;
                    if(pParmsCopy) 
                    {
                        memcpy(pParmsCopy, pParms, sizeof(MessageParms));
                        // Start a thread to send the message
                        pParmsCopy->pWinStation = pWinStation;
                        pParmsCopy->bActionOnCurrentSelection = FALSE;
                        AfxBeginThread((AFX_THREADPROC)CWinStation::SendMessage, pParmsCopy);
                    }
                }
            }

            // Unlock the list of WinStations
            pServer->UnlockWinStationList();
        }

        UnlockServerList();

        // Delete MessageParms - we sent copies to the WinStation objects
        // They will delete their copies
        delete pParms;
    }

}       // end CWinAdminDoc::SendWinStationMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ConnectWinStation
//
//      bTemp is TRUE if we are to connect to the temporarily selected tree item.
//
void CWinAdminDoc::ConnectWinStation(BOOL bTemp, BOOL bUser)
{
        // Are we connecting to temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->Connect(NULL);
                }

                return;
        }


        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->Connect(NULL);
        }
        // Go through the list of WinStations on the currently selected server
        // and disconnect those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                // do the connect
                                pWinStation->Connect(bUser);
                                break;  // we can only connect to one WinStation
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        // do the connect
                                        pWinStation->Connect(bUser);
                                        break;  // we can only connect to one WinStation
                                }
                        }
                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();
        }

}       // end CWinAdminDoc::ConnectWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::StatusWinStation
//
//      bTemp is TRUE if we are to show status for the temporarily selected tree item.
//
void CWinAdminDoc::StatusWinStation(BOOL bTemp)
{
        // Are we showing status for the temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->ShowStatus();
                }

                return;
        }

        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->ShowStatus();
        }
        // Go through the list of WinStations on the currently selected server
        // and show status for those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                                pWinStation->ShowStatus();
                        }
                }

                // Unlock the list of WinStations
                pServer->UnlockWinStationList();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                        pWinStation->ShowStatus();
                                }
                        }

                        // Unlock the list of WinStations
                        pServer->UnlockWinStationList();
                }

                UnlockServerList();
        }

}       // end CWinAdminDoc::StatusWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DisconnectWinStation
//
//      bTemp is TRUE if we are disconnecting the temporarily selected tree item.
//
void CWinAdminDoc::DisconnectWinStation(BOOL bTemp)
{            
    CWinStation * pCurWinStation;
    CServer     * pCurServer;

    // Are we disconnecting the temporarily selected tree item?
    if(bTemp) 
    {
        // Is the temporarily selected item in the tree a WinStation?
        if(m_TempSelectedType == NODE_WINSTATION) 
        {    
            // If the winstation we're working on disappears before we get here
            // then just return
            if (m_CurrentSelectedType != NODE_WINSTATION)
            {
                return;
            }

            // create a disconnect parameters structure
            DisconnectParms * pDisconParms = new DisconnectParms;
            if(pDisconParms)
            {
                // get currecnt selected node winstation and server
                pCurWinStation = (CWinStation*)m_pTempSelectedNode;
                pCurServer     = pCurWinStation->GetServer();

                pDisconParms->hServer   = pCurServer->GetHandle();
                pDisconParms->ulLogonId = pCurWinStation->GetLogonId();
                pDisconParms->bActionOnCurrentSelection = TRUE;

                AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pDisconParms);

                // the thread will delete pDisconParms
            }
        }
        return;
    }

    if(m_CurrentSelectedType == NODE_WINSTATION) 
    {
        // create a disconnect parameters structure
        DisconnectParms *pDisconParms = new DisconnectParms;
        if(pDisconParms)
        {
            // get currecnt selected node winstation and server
            pCurWinStation = (CWinStation*)m_CurrentSelectedNode;
            pCurServer     = pCurWinStation->GetServer();

            pDisconParms->hServer   = pCurServer->GetHandle();
            pDisconParms->ulLogonId = pCurWinStation->GetLogonId();
            pDisconParms->bActionOnCurrentSelection = TRUE;

            AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pDisconParms);

            // the thread will delete pDisconParms
        }
    }

    // Go through the list of WinStations on the currently selected server
    // and disconnect those that are selected
    else if(m_CurrentView == VIEW_SERVER) 
    {
        // Get a pointer to the selected server
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // Lock the server's list of WinStations
        pServer->LockWinStationList();
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) 
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected()) 
            {
                // create a disconnect parameters structure
                DisconnectParms *pDisconParms = new DisconnectParms;
                if(pDisconParms)
                {
                    // get currecnt selected node winstation and server
                    //pCurWinStation = (CWinStation*)m_pTempSelectedNode;
                    pCurServer     = pWinStation->GetServer();

                    pDisconParms->hServer   = pCurServer->GetHandle();
                    pDisconParms->ulLogonId = pWinStation->GetLogonId();
                    pDisconParms->bActionOnCurrentSelection = FALSE;

                    // Start a thread to do the disconnect                            
                    AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pDisconParms);

                    // the thread will delete pDisconParms
                }
            }
        }

        // Unlock the list of WinStations
        pServer->UnlockWinStationList();
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) 
    {
        LockServerList();
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2) 
        {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            // Lock the server's list of WinStations
            pServer->LockWinStationList();
            // Get a pointer to the server's list of WinStations
            CObList *pWinStationList = pServer->GetWinStationList();

            // Iterate through the WinStation list
            POSITION pos = pWinStationList->GetHeadPosition();

            while(pos) 
            {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                if(pWinStation->IsSelected()) 
                {
                    // create a disconnect parameters structure
                    DisconnectParms *pDisconParms = new DisconnectParms;
                    if(pDisconParms)
                    {
                        // get currecnt selected node winstation and server
                        //pCurWinStation = (CWinStation*)m_pTempSelectedNode;
                        pCurServer     = pWinStation->GetServer();

                        pDisconParms->hServer   = pCurServer->GetHandle();
                        pDisconParms->ulLogonId = pWinStation->GetLogonId();
                        pDisconParms->bActionOnCurrentSelection = FALSE;

                        // Start a thread to do the disconnect                            
                        AfxBeginThread((AFX_THREADPROC)CWinStation::Disconnect, pDisconParms);

                        // the thread will delete pDisconParms
                    }
                }
            }

            // Unlock the list of WinStations
            pServer->UnlockWinStationList();
        }

        UnlockServerList();
    }
}       // end CWinAdminDoc::DisconnectWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ResetWinStation
//
//      bTemp is TRUE if we are to reset the temporarily selected tree item.
//      bReset is TRUE if reset, FALSE if logoff
//
void CWinAdminDoc::ResetWinStation(BOOL bTemp, BOOL bReset)
{
    // Are we resetting the temporarily selected tree item?
    if(bTemp)
    {
        // Is the temporarily selected item in the tree a WinStation?
        if(m_TempSelectedType == NODE_WINSTATION)
        {
            // If the winstation we're working on disappears before we get here
            // then just return
            if (m_CurrentSelectedType != NODE_WINSTATION)
            {
                return;
            }

            // create a reset parameters structure
            ResetParms *pResetParms = new ResetParms;
            if(pResetParms)
            {
                pResetParms->pWinStation = (CWinStation*)m_pTempSelectedNode;
                pResetParms->bReset = bReset;
                pResetParms->bActionOnCurrentSelection = TRUE;
                AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);

                // the thread will delete pResetParms
            }
        }
        
        return;
    }
    
    if(m_CurrentSelectedType == NODE_WINSTATION)
    {
        // create a reset parameters structure
        ResetParms *pResetParms = new ResetParms;

        if(pResetParms)
        {
            pResetParms->pWinStation = (CWinStation*)m_CurrentSelectedNode;
            pResetParms->bReset = bReset;
            pResetParms->bActionOnCurrentSelection = TRUE;
            AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);

            // the thread will delete pResetParms
        }
    }
    // Go through the list of WinStations on the currently selected server
    // and reset those that are selected
    else if(m_CurrentView == VIEW_SERVER)
    {
        // Get a pointer to the selected server
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // Lock the server's list of WinStations
        pServer->LockWinStationList();
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

            if(pWinStation->IsSelected())
            {
                // create a reset parameters structure
                ResetParms *pResetParms = new ResetParms;

                if(pResetParms)
                {
                    pResetParms->pWinStation = pWinStation;
                    pResetParms->bReset = bReset;
                    pResetParms->bActionOnCurrentSelection = FALSE;

                    // Start a thread to do the reset
                    AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);
                    // the thread will delete pResetParms
                }
            }
        }
        
        // Unlock the list of WinStations
        pServer->UnlockWinStationList();
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {
        LockServerList();
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2)
        {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            // Lock the server's list of WinStations
            pServer->LockWinStationList();
            // Get a pointer to the server's list of WinStations
            CObList *pWinStationList = pServer->GetWinStationList();            
            // Iterate through the WinStation list
            POSITION pos = pWinStationList->GetHeadPosition();
            
            while(pos)
            {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                if( pWinStationList != NULL && pWinStation->IsSelected() )
                {                           
                    if( GetCurrentPage( ) == PAGE_AS_USERS && pWinStation->GetState() == State_Listen )
                    {
                        // from a user experience if the listener winstation has been selected from a 
                        // previous page that went out of focus - then not skipping this winstation
                        // would appear as if we disconnected from every connected winstation.

                        continue;
                    }
                    // create a reset parameters structure
                    ResetParms *pResetParms = new ResetParms;
                    if( pResetParms != NULL )
                    {
                        pResetParms->pWinStation = pWinStation;
                        pResetParms->bReset = bReset;
                        pResetParms->bActionOnCurrentSelection = FALSE;
                        // Start a thread to do the reset
                        DBGMSG( L"TSMAN!CWinAdminDoc_ResetWinStation %s\n", pWinStation->GetName() );
                        AfxBeginThread((AFX_THREADPROC)CWinStation::Reset, pResetParms);
                    }                 
                }
            }
            
            // Unlock the list of WinStations
            pServer->UnlockWinStationList();
        }
        
        UnlockServerList();
    }
    
}       // end CWinAdminDoc::ResetWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ShadowWinStation
//
//      bTemp is TRUE if we are to shadow the temporarily selected tree item.
//
void CWinAdminDoc::ShadowWinStation(BOOL bTemp)
{
        // Are we resetting the temporarily selected tree item?
        if(bTemp) {
                // Is the temporarily selected item in the tree a WinStation?
                if(m_TempSelectedType == NODE_WINSTATION) {
                        ((CWinStation*)m_pTempSelectedNode)->Shadow();
                }

                return;
        }

        // Is the WinStation selected in the tree?
        if(m_CurrentSelectedType == NODE_WINSTATION) {
                ((CWinStation*)m_CurrentSelectedNode)->Shadow();
        }
        // Go through the list of WinStations on the currently selected server
        // and send messages to those that are selected
        else if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of WinStations
                pServer->LockWinStationList();
                // Get a pointer to the server's list of WinStations
                CObList *pWinStationList = pServer->GetWinStationList();
        BOOL IsLockAlreadyReleased = FALSE;

                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();

                while(pos) {
                        CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                        if(pWinStation->IsSelected()) {
                        pServer->UnlockWinStationList();
                IsLockAlreadyReleased = TRUE;
                                pWinStation->Shadow();
                                break;  // we can only shadow one WinStation
                        }
                }

                // Unlock the list of WinStations
        if (IsLockAlreadyReleased == FALSE) {
                    pServer->UnlockWinStationList();
        }
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                LockServerList();
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of WinStations
                        pServer->LockWinStationList();
                        // Get a pointer to the server's list of WinStations
                        CObList *pWinStationList = pServer->GetWinStationList();
            BOOL IsLockAlreadyReleased = FALSE;

                        // Iterate through the WinStation list
                        POSITION pos = pWinStationList->GetHeadPosition();

                        while(pos) {
                                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                                if(pWinStation->IsSelected()) {
                                pServer->UnlockWinStationList();
                    IsLockAlreadyReleased = TRUE;
                                        pWinStation->Shadow();
                                        break;  // we can only shadow one WinStation
                                }
                        }

                        // Unlock the list of WinStations
            if (IsLockAlreadyReleased == FALSE) {
                            pServer->UnlockWinStationList();
            }
            else
            {
                break;  // we can only shadow one WinStation
            }
                }
                UnlockServerList();
        }

}       // end CWinAdminDoc::ShadowWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ServerConnect
//
void CWinAdminDoc::ServerConnect()
{
    ODS( L"CWinAdminDoc::ServerConnect\n" );
    // Is the Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER)
    {
        CServer *pServer = (CServer*)m_pTempSelectedNode;
        // Tell the server to connect        
        if ((pServer->GetState() == SS_BAD) && (pServer->HasLostConnection() || !(pServer->IsServerSane())))
        {
            ODS( L"\tDisconnecting from server\n" );
            /* disconnect */
            pServer->Disconnect( );
        }
        pServer->Connect();
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {
        LockServerList();
        POSITION pos = m_ServerList.GetHeadPosition();
        ODS( L"\tenumerating from server list\n" );
        while(pos) {
            // Get a pointer to the server
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            // If this Server is selected, connect to it
            if( pServer->IsSelected() )
            {
                // Tell the server to connect
                
                if ((pServer->GetState() == SS_BAD) && (pServer->HasLostConnection() || !(pServer->IsServerSane())))
                {
                    ODS( L"\tDisconnecting from server\n" );
                    /* disconnect */
                    pServer->Disconnect( );
                }
                pServer->Connect();
            }
        }
        UnlockServerList();
    }

}  // end CWinAdminDoc::ServerConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ServerDisconnect
//
void CWinAdminDoc::ServerDisconnect()
{
        // Is the Server selected in the tree?
        if(m_TempSelectedType == NODE_SERVER) {
                CServer *pServer = (CServer*)m_pTempSelectedNode;
                // Tell the server to disconnect
                pServer->Disconnect();
        }
        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
        CString AString;
            CDialog dlgWait;
            dlgWait.Create(IDD_SHUTDOWN, NULL);

                LockServerList();
        // Do a first loop to signal the server background threads that they must stop
                POSITION pos = m_ServerList.GetHeadPosition();
                while(pos) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                        // If this Server is selected, stop its background thread
                        if(pServer->IsSelected()) {
                // thell the server background thread to stop
                pServer->ClearBackgroundContinue();
            }
                }
        // do a second loop to disconnect the servers
                pos = m_ServerList.GetHeadPosition();
                while(pos) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                        // If this Server is selected, disconnect from it
                        if(pServer->IsSelected()) {
                            AString.Format(IDS_DISCONNECTING, pServer->GetName());
                            dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

                        // Tell the server to disconnect
                        pServer->Disconnect();
                        }
                }
                UnlockServerList();

        dlgWait.PostMessage(WM_CLOSE);

        }

}  // end CWinAdminDoc::ServerDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TempDomainConnectAllServers
//
// Connect to all the servers in temporarily selected Domain
//
void CWinAdminDoc::TempDomainConnectAllServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {
                ((CDomain*)m_pTempSelectedNode)->ConnectAllServers();
        }

}  // end CWinAdminDoc::TempDomainConnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TempDomainDisconnectAllServers
//
// Disconnect from all servers in temporarily selected Domain
//
void CWinAdminDoc::TempDomainDisconnectAllServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_pTempSelectedNode)->DisconnectAllServers();
        }

}       // end CWinAdminDoc::TempDomainDisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CurrentDomainConnectAllServers
//
// Connect to all the servers in currently selected Domain
//
void CWinAdminDoc::CurrentDomainConnectAllServers()
{
        if(m_CurrentSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_CurrentSelectedNode)->ConnectAllServers();

        }

}  // end CWinAdminDoc::CurrentDomainConnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CurrentDomainDisconnectAllServers
//
// Disconnect from all servers in currently selected Domain
//
void CWinAdminDoc::CurrentDomainDisconnectAllServers()
{
        if(m_CurrentSelectedType == NODE_DOMAIN) {

                ((CDomain*)m_CurrentSelectedNode)->DisconnectAllServers();
        }

}       // end CWinAdminDoc::CurrentDomainDisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DomainFindServers
//
// Find all servers in a Domain
//
void CWinAdminDoc::DomainFindServers()
{
        if(m_TempSelectedType == NODE_DOMAIN) {
                CDomain *pDomain = (CDomain*)m_pTempSelectedNode;

                if(!pDomain->GetThreadPointer()) pDomain->StartEnumerating();
        }

}       // end CWinAdminDoc::DomainFindServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::ConnectToAllServers
//
// Connect to all the servers
//
void CWinAdminDoc::ConnectToAllServers()
{
        LockServerList();
        POSITION pos = m_ServerList.GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
                // If this server isn't currently connected, connect to it
                if(pServer->IsState(SS_NOT_CONNECTED)) {
                        // Tell the server to connect
                    pServer->Connect();
                }
        }

        UnlockServerList();

}  // end CWinAdminDoc::ConnectToAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::DisconnectFromAllServers
//
// Disconnect from all the servers
//
void CWinAdminDoc::DisconnectFromAllServers()
{
    CString AString;
    CDialog dlgWait;
    dlgWait.Create(IDD_SHUTDOWN, NULL);
    
    
    // tell each domain thread to stop enumerating while we're shutting down all servers

#ifdef _STRESS_BUILD
    g_fWaitForAllServersToDisconnect = 1;
#endif

    POSITION pos;
    
    LockServerList();    
    
    // Do a first loop to signal the server background threads that they must stop
    pos = m_ServerList.GetHeadPosition();

    while( pos )
    {
        // Get a pointer to the server
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        
        // If this Server is currently connected, tell the server background thread to stop
        if(pServer->GetState() != SS_NOT_CONNECTED)
        {
            pServer->ClearBackgroundContinue();
        }
    }
    // do a second loop to disconnect the servers
    pos = m_ServerList.GetHeadPosition();
    while(pos)
    {
        // Get a pointer to the server
        CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
        // If this server is currently connected, disconnect from it
        if(pServer->GetState() != SS_NOT_CONNECTED)
        {
            AString.Format(IDS_DISCONNECTING, pServer->GetName());
            dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);
            // Tell the server to disconnect
            pServer->Disconnect();
        }
    }
    
    UnlockServerList();
    
    dlgWait.PostMessage(WM_CLOSE);

#ifdef _STRESS_BUILD
    g_fWaitForAllServersToDisconnect = 0;
#endif
    
}  // end CWinAdminDoc::DisconnectFromAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::FindAllServers
//
// find all Servers in all Domains
//
void CWinAdminDoc::FindAllServers()
{
        if(m_bInShutdown) return;

        POSITION pos = m_DomainList.GetHeadPosition();
        while(pos) {
                // Get a pointer to the domain
                CDomain *pDomain = (CDomain*)m_DomainList.GetNext(pos);
                // If this domain isn't currently enumerating servers, tell it to
                if(!pDomain->GetThreadPointer()) pDomain->StartEnumerating();

        }

}  // end CWinAdminDoc::FindAllServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TerminateProcess
//
void CWinAdminDoc::TerminateProcess()
{
        if(m_CurrentView == VIEW_SERVER) {
                // Get a pointer to the selected server
                CServer *pServer = (CServer*)m_CurrentSelectedNode;
                // Lock the server's list of Processes
                pServer->LockProcessList();
                // Get a pointer to the server's list of Processes
                CObList *pProcessList = pServer->GetProcessList();

                // Iterate through the Process list
                POSITION pos = pProcessList->GetHeadPosition();

                while(pos) {
                        CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                        if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                                // Start a thread to do the terminate
                                AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                        }
                }

                // Unlock the list of Processes
                pServer->UnlockProcessList();
        }

        else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
                POSITION pos2 = m_ServerList.GetHeadPosition();
                while(pos2) {
                        // Get a pointer to the server
                        CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
                        // Lock the server's list of Processes
                        pServer->LockProcessList();
                        // Get a pointer to the server's list of Processes
                        CObList *pProcessList = pServer->GetProcessList();

                        // Iterate through the Process list
                        POSITION pos = pProcessList->GetHeadPosition();

                        while(pos) {
                                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                                if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                                        // Start a thread to do the terminate
                                        AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                                }
                        }

                        // Unlock the list of Processes
                        pServer->UnlockProcessList();
                }
        }

        else if(m_CurrentView == VIEW_WINSTATION) {
                 // Get the Server for the currently viewed WinStation
                 CServer *pServer = (CServer*)((CWinStation*)m_CurrentSelectedNode)->GetServer();

          // Lock the server's list of Processes
          pServer->LockProcessList();
          // Get a pointer to the server's list of Processes
          CObList *pProcessList = pServer->GetProcessList();

          // Iterate through the Process list
          POSITION pos = pProcessList->GetHeadPosition();

          while(pos) {
                  CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                  if(pProcess->IsSelected() && !pProcess->IsTerminating()
                                        && (pProcess->GetWinStation() == (CWinStation*)m_CurrentSelectedNode)) {
                          // Start a thread to do the terminate
                          AfxBeginThread((AFX_THREADPROC)CWinAdminDoc::TerminateProc, pProcess);
                  }
          }

          // Unlock the list of Processes
          pServer->UnlockProcessList();
        }

}       // end CWinAdminDoc::TerminateProcess


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::TerminateProc
//
UINT CWinAdminDoc::TerminateProc(LPVOID parms)
{
        ASSERT(parms);

        CProcess *pProcess = (CProcess*)parms;
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Set the flag to say that we are trying to terminate this process
        pProcess->SetTerminating();

        CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();


        if(WinStationTerminateProcess(pProcess->GetServer()->GetHandle(),pProcess->GetPID(), 0))
        {
                // Send a message to remove the process from the view
        if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                p->SendMessage(WM_ADMIN_REMOVE_PROCESS, 0, (LPARAM)pProcess);

        }
    }
        else
        {
                pProcess->ClearTerminating();
                //Display Error Message
                if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                        DWORD Error = GetLastError();
                        
                        //We need this to know the length of the error message
                        //now that StandardErrorMessage requires that
                        CString tempErrorMessage;
                        tempErrorMessage.LoadString(IDS_CANNOT_TERMINATE);
                        StandardErrorMessage(AfxGetAppName(), AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
                                             LOGONID_NONE,Error,tempErrorMessage.GetLength(),wcslen(pProcess->GetImageName()),
                                             IDS_CANNOT_TERMINATE,pProcess->GetImageName());
                }

        }

        return 0;

}       // end CWinAdminDoc::TerminateProc


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckConnectAllowed
//
BOOL CWinAdminDoc::CheckConnectAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        // If they are the same WinStation, don't let them connect
        if(pWinStation->GetServer()->IsCurrentServer()
                && ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId() == pWinStation->GetLogonId())
                        return FALSE;

        if((((CWinAdminApp*)AfxGetApp())->GetCurrentWSFlags() & WDF_SHADOW_SOURCE)
                && !pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole()
                && (pWinStation->IsDisconnected() || pWinStation->IsActive())
                && pWinStation->IsOnCurrentServer())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckConnectAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckDisconnectAllowed
//
BOOL CWinAdminDoc::CheckDisconnectAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole()
                && pWinStation->IsConnected())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckDisconnectAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckResetAllowed
//
BOOL CWinAdminDoc::CheckResetAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsSystemConsole())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckResetAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckShadowAllowed
//
BOOL CWinAdminDoc::CheckShadowAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        // If they are the same WinStation, don't let them shadow
        if( pWinStation->GetServer()->IsCurrentServer() &&
            ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId() == pWinStation->GetLogonId() )
        {
            return FALSE;
        }

        if(!pWinStation->HasOutstandingThreads() &&
           !pWinStation->IsDown() &&    // winstation is not down
           !pWinStation->IsListener() &&    // not a listening winstation
           !pWinStation->IsDisconnected() &&   //not disconnected
           (((CWinAdminApp*)AfxGetApp())->GetCurrentWSFlags() & WDF_SHADOW_SOURCE) && // We are valid shadow source, query winstation's wdflag in registry
           (pWinStation->CanBeShadowed()) &&  // target can be shadow.
           (pWinStation->GetState() != State_Shadow)) // target is not already in shadow
        {
            return TRUE;
        }

        return FALSE;

}       // end CWinAdminDoc::CheckShadowAllowed



/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckSendMessageAllowed
//
BOOL CWinAdminDoc::CheckSendMessageAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
        && !pWinStation->IsListener()
                && pWinStation->IsConnected())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckSendMessageAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckStatusAllowed
//
BOOL CWinAdminDoc::CheckStatusAllowed(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        if(!pWinStation->HasOutstandingThreads()
                && !pWinStation->IsDown()
                && !pWinStation->IsDisconnected()
                && !pWinStation->IsIdle()
                && !pWinStation->IsListener()
                && !pWinStation->IsSystemConsole())
                        return TRUE;

        return FALSE;

}       // end CWinAdminDoc::CheckStatusAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CheckActionAllowed
//
BOOL CWinAdminDoc::CheckActionAllowed(BOOL (*CheckFunction)(CWinStation *pWinStation), BOOL AllowMultipleSelected)
{
    ASSERT(CheckFunction);
    
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_CurrentSelectedType == NODE_WINSTATION)
    { 
        CWinStation *pWinStation = (CWinStation*)m_CurrentSelectedNode;
        return CheckFunction(pWinStation);
    }
    
    // We only care if the current view is Server or All Listed Servers
    if(m_CurrentView == VIEW_SERVER)
    {     
        // We need to make sure we are on the WinStation or Users page
        if(m_CurrentPage != PAGE_WINSTATIONS && m_CurrentPage != PAGE_USERS)
        {       
            return FALSE;
        }
        int NumSelected = 0;
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // If there aren't any WinStations selected on this server, return
        if(!pServer->GetNumWinStationsSelected())
        {     
            return FALSE;
        }
        
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected())
            {
                if(!CheckFunction(pWinStation))
                {
                    pServer->UnlockWinStationList();
                    return FALSE;
                }
                NumSelected++;
                if(!AllowMultipleSelected && NumSelected > 1)
                {
                    pServer->UnlockWinStationList();
                    return FALSE;
                }
            }
        }
        
        pServer->UnlockWinStationList();
        // If we got here, all the selected WinStations passed our criteria
        if(NumSelected) return TRUE;
    }
    else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN)
    {        
        // If we are doing a refresh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // We need to make sure we are on the WinStation or Users page
        if(m_CurrentPage != PAGE_AS_WINSTATIONS && m_CurrentPage != PAGE_AS_USERS
            && m_CurrentPage != PAGE_DOMAIN_WINSTATIONS && m_CurrentPage != PAGE_DOMAIN_USERS)
            return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        POSITION pos1 = m_ServerList.GetHeadPosition();
        
        while(pos1) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos1);
            // Are there any WinStations selected on this server?
            if(pServer->GetNumWinStationsSelected()) {
                pServer->LockWinStationList();
                CObList *pWinStationList = pServer->GetWinStationList();
                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();
                
                while(pos) {
                    CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                    if(pWinStation->IsSelected()) {
                        if(!CheckFunction(pWinStation)) {
                            pServer->UnlockWinStationList();
                            UnlockServerList();
                            return FALSE;
                        }
                        NumSelected++;
                        if(!AllowMultipleSelected && NumSelected > 1) {
                            pServer->UnlockWinStationList();
                            UnlockServerList();
                            return FALSE;
                        }
                    }
                }
                pServer->UnlockWinStationList();
            } // end if(pServer->GetNumWinStationsSelected())
        }
        
        UnlockServerList();

        // If we got this far, all the selected WinStations passed the criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
} // end CWinAdminDoc::CheckActionAllowed


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanConnect
//
// Returns TRUE if the currently selected item in views can be Connected to
//
BOOL CWinAdminDoc::CanConnect()
{
        return CheckActionAllowed(CheckConnectAllowed, FALSE);

}       // end CWinAdminDoc::CanConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanDisconnect
//
// Returns TRUE if the currently selected item in views can be Disconnected
//
BOOL CWinAdminDoc::CanDisconnect()
{    
    return CheckActionAllowed(CheckDisconnectAllowed, TRUE);

}       // end CWinAdminDoc::CanDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanReset
//
// Returns TRUE if the currently selected item in views can be Reset
//
BOOL CWinAdminDoc::CanReset()
{
        return CheckActionAllowed(CheckResetAllowed, TRUE);

}       // end CWinAdminDoc::CanReset


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanShadow
//
// Returns TRUE if the currently selected item in views can be Shadowed
//
BOOL CWinAdminDoc::CanShadow()
{
        return CheckActionAllowed(CheckShadowAllowed, FALSE);

}       // end CWinAdminDoc::CanShadow


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanSendMessage
//
// Returns TRUE if the currently selected item in views can be sent a message
//
BOOL CWinAdminDoc::CanSendMessage()
{
        return CheckActionAllowed(CheckSendMessageAllowed, TRUE);

}       // end CWinAdminDoc::CanSendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanStatus
//
// Returns TRUE if the currently selected item in views can show Status
//
BOOL CWinAdminDoc::CanStatus()
{
        return CheckActionAllowed(CheckStatusAllowed, TRUE);

}       // end CWinAdminDoc::CanStatus


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanLogoff
//
// Returns TRUE if the currently selected item in views can be Logged Off
//
BOOL CWinAdminDoc::CanLogoff()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_CurrentSelectedType == NODE_WINSTATION) {
        return FALSE;
    }
    
    // We only care if the current view is Server or All Listed Servers
    if(m_CurrentView == VIEW_SERVER) {
        // We need to make sure we are on the Users page
        if(m_CurrentPage != PAGE_USERS) return FALSE;
        BOOL Answer = FALSE;
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        // If there aren't any WinStations selected on this server, return
        if(!pServer->GetNumWinStationsSelected()) return FALSE;
        
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos) {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            if(pWinStation->IsSelected()) {
                if(!pWinStation->HasOutstandingThreads())
                    Answer = TRUE;
            }
        }
        
        pServer->UnlockWinStationList();
        return Answer;
    } else if(m_CurrentView == VIEW_ALL_SERVERS || m_CurrentView == VIEW_DOMAIN) {
        // If we are doing a refesh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // We need to make sure we are on the Users page
        if(m_CurrentPage != PAGE_AS_USERS && m_CurrentPage != PAGE_DOMAIN_USERS) return FALSE;
        BOOL Answer = FALSE;
        
        LockServerList();
        POSITION pos1 = m_ServerList.GetHeadPosition();
        
        while(pos1) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos1);
            
            // Are there any WinStations selected on this server?
            if(pServer->GetNumWinStationsSelected()) {
                pServer->LockWinStationList();
                CObList *pWinStationList = pServer->GetWinStationList();
                // Iterate through the WinStation list
                POSITION pos = pWinStationList->GetHeadPosition();
                
                while(pos) {
                    CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                    if(pWinStation->IsSelected()) {
                        if(!pWinStation->HasOutstandingThreads())
                            Answer = TRUE;
                    }
                }
                pServer->UnlockWinStationList();
            } // end if(pServer->GetNumWinStationsSelected())
        }
        
        UnlockServerList();
        return Answer;
    }
    
    return FALSE;

}       // end CWinAdminDoc::CanLogoff


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTerminate
//
// Returns TRUE if the currently selected item in views can be Terminated
//
BOOL CWinAdminDoc::CanTerminate()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    // We have to be in All Selected Servers, Server, or WinStation view
    if((m_CurrentView == VIEW_ALL_SERVERS && m_CurrentPage == PAGE_AS_PROCESSES)
        || (m_CurrentView == VIEW_DOMAIN && m_CurrentPage == PAGE_DOMAIN_PROCESSES)) {
        // If we are doing a refresh, we can't do anything else
        if(m_InRefresh) return FALSE;
        // Loop through all the servers and see if any processes are selected
        LockServerList();
        
        POSITION pos2 = m_ServerList.GetHeadPosition();
        while(pos2) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos2);
            
            // Are there any processes selected on this server?
            if(pServer->GetNumProcessesSelected()) {
                pServer->LockProcessList();
                CObList *pProcessList = pServer->GetProcessList();
                
                POSITION pos = pProcessList->GetHeadPosition();
                while(pos) {
                    CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
                    // We only need one process to be selected
                    if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                        pServer->UnlockProcessList();
                        UnlockServerList();
                        return TRUE;
                    }
                }
                
                pServer->UnlockProcessList();
            } // end if(pServer->GetNumProcessesSelected())
        }
        UnlockServerList();
        return FALSE;
    }
    
    if(m_CurrentView == VIEW_SERVER && m_CurrentPage == PAGE_PROCESSES) {
        CServer *pServer = (CServer*)m_CurrentSelectedNode;
        
        // If there aren't any processes selected on this server, return
        if(!pServer->GetNumProcessesSelected()) return FALSE;
        
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();
        
        POSITION pos = pProcessList->GetHeadPosition();
        while(pos) {
            CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
            // We only need one process to be selected
            if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                pServer->UnlockProcessList();
                return TRUE;
            }
        }
        
        pServer->UnlockProcessList();
        return FALSE;
    }
    
    if(m_CurrentView == VIEW_WINSTATION && m_CurrentPage == PAGE_WS_PROCESSES) {
        CServer *pServer = (CServer*)((CWinStation*)m_CurrentSelectedNode)->GetServer();
        
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();
        
        POSITION pos = pProcessList->GetHeadPosition();
        while(pos) {
            CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);
            // We only need one process to be selected
            if(pProcess->IsSelected() && !pProcess->IsTerminating()) {
                pServer->UnlockProcessList();
                return TRUE;
            }
        }
        
        pServer->UnlockProcessList();
        return FALSE;
        
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTerminate

//=--------------------------------------------------------
BOOL CWinAdminDoc::IsAlreadyFavorite( )
{
    if(m_TempSelectedType == NODE_SERVER)
    {
        CServer *pServer = (CServer*)m_pTempSelectedNode;
        
        if( pServer->GetTreeItemFromFav( ) != NULL )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanServerConnect
//
// Returns TRUE if the currently selected server in views can be connected to
//
BOOL CWinAdminDoc::CanServerConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER) {
        if(((CServer*)m_pTempSelectedNode)->GetState() == SS_NOT_CONNECTED || 
            ((CServer*)m_pTempSelectedNode)->GetState() == SS_BAD ) return TRUE;
    }
    
    // Is a Server selected in the tree?
    else if(m_CurrentSelectedType == NODE_SERVER) {
        if(((CServer*)m_CurrentSelectedNode)->GetState() == SS_NOT_CONNECTED ||
            ((CServer*)m_CurrentSelectedNode)->GetState() == SS_BAD ) return TRUE;
    }
    
    // We only care if the current view is Domain or All Listed Servers
    else if(m_CurrentView == VIEW_DOMAIN) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_DOMAIN_SERVERS) return FALSE;
        int NumSelected = 0;
        CDomain *pDomain = (CDomain*)m_CurrentSelectedNode;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected() && pServer->GetDomain() == pDomain) {
                if(!pServer->IsState(SS_NOT_CONNECTED)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    else if(m_CurrentView == VIEW_ALL_SERVERS) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_AS_SERVERS) return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected()) {
                if(!pServer->IsState(SS_NOT_CONNECTED)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanServerConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanServerDisconnect
//
// Returns TRUE if the currently selected server in views can be disconnected from
//
BOOL CWinAdminDoc::CanServerDisconnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Server selected in the tree?
    if(m_TempSelectedType == NODE_SERVER) {
        if(((CServer*)m_pTempSelectedNode)->GetState() == SS_GOOD) return TRUE;
    }
    
    // Is a Server selected in the tree?
    else if(m_CurrentSelectedType == NODE_SERVER) {
        if(((CServer*)m_CurrentSelectedNode)->GetState() == SS_GOOD) return TRUE;
    }
    
    // We only care if the current view is Domain or All Listed Servers
    else if(m_CurrentView == VIEW_DOMAIN) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_DOMAIN_SERVERS) return FALSE;
        int NumSelected = 0;
        CDomain *pDomain = (CDomain*)m_CurrentSelectedNode;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected() && pServer->GetDomain() == pDomain) {
                if(!pServer->IsState(SS_GOOD)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    else if(m_CurrentView == VIEW_ALL_SERVERS) {
        // We need to make sure we are on the Servers page
        if(m_CurrentPage != PAGE_AS_SERVERS) return FALSE;
        int NumSelected = 0;
        
        LockServerList();
        
        // Iterate through the Server list
        POSITION pos = m_ServerList.GetHeadPosition();
        
        while(pos) {
            CServer *pServer = (CServer*)m_ServerList.GetNext(pos);
            if(pServer->IsSelected()) {
                if(!pServer->IsState(SS_GOOD)) {
                    UnlockServerList();
                    return FALSE;
                }
                NumSelected++;
            }
        }
        
        UnlockServerList();
        // If we got here, all the selected Servers passed our criteria
        if(NumSelected) return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanServerDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempConnect
//
// Returns TRUE if the temporarily selected item in views can be Connected to
//
BOOL CWinAdminDoc::CanTempConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckConnectAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDisconnect
//
// Returns TRUE if the temporarily selected item in views can be Disconnected
//
BOOL CWinAdminDoc::CanTempDisconnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckDisconnectAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDisconnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempReset
//
// Returns TRUE if the temporarily selected item in views can be Reset
//
BOOL CWinAdminDoc::CanTempReset()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) 
    {
        // If the winstation we're working on disappears before we get here
        // then just return
        if (m_CurrentSelectedType == NODE_WINSTATION)
        {
            return CheckResetAllowed((CWinStation*)m_pTempSelectedNode);
        }
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempReset


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempShadow
//
// Returns TRUE if the temporarily selected item in views can be Shadowed
//
BOOL CWinAdminDoc::CanTempShadow()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckShadowAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempShadow


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempSendMessage
//
// Returns TRUE if the temporarily selected item in views can be sent a message
//
BOOL CWinAdminDoc::CanTempSendMessage()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckSendMessageAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempSendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempStatus
//
// Returns TRUE if the temporarily selected item in views can show Status
//
BOOL CWinAdminDoc::CanTempStatus()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a WinStation selected in the tree?
    if(m_TempSelectedType == NODE_WINSTATION) {
        return CheckStatusAllowed((CWinStation*)m_pTempSelectedNode);
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempStatus


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDomainConnect
//
// Returns TRUE if the temporarily selected Domain in tree can have all it's
// Servers connected/disconnected to/from.
//
BOOL CWinAdminDoc::CanTempDomainConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_TempSelectedType == NODE_DOMAIN) {
        if(((CDomain*)m_pTempSelectedNode)->IsState(DS_ENUMERATING))
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDomainConnect


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanTempDomainFindServers
//
// Returns TRUE if the temporarily selected Domain in tree can go out
// and find Servers
//
BOOL CWinAdminDoc::CanTempDomainFindServers()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_TempSelectedType == NODE_DOMAIN) {
        if(!((CDomain*)m_pTempSelectedNode)->GetThreadPointer())
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanTempDomainFindServers


/////////////////////////////////////////////////////////////////////////////
// CWinAdminDoc::CanDomainConnect
//
// Returns TRUE if the currently selected Domain in tree can have all it's
// Servers connected/disconnected to/from.
//
BOOL CWinAdminDoc::CanDomainConnect()
{
    // If we are shutting down, we don't care anymore
    if(m_bInShutdown) return FALSE;
    
    // Is a Domain selected in the tree?
    if(m_CurrentSelectedType == NODE_DOMAIN) {
        if(((CDomain*)m_CurrentSelectedNode)->IsState(DS_ENUMERATING))
            return TRUE;
    }
    
    return FALSE;
    
}       // end CWinAdminDoc::CanDomainConnect

//------------------------------------------------------------------------------
void CWinAdminDoc::ServerAddToFavorites( BOOL bAdd )
{
    ODS( L"CWinAdminDoc::ServerAddToFavorites\n");
    // we got here from a context menu selection    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    if(m_TempSelectedType == NODE_SERVER && pDoc != NULL )
    {
        CServer* pServer = ( CServer* )m_pTempSelectedNode;
        
        if( pServer != NULL )
        {
            
            // test to see if the server is being removed
            
            if( pServer->IsState(SS_DISCONNECTING) )
            {
                ODS( L"=-sneaky popup menu was up when server went away\n=-not adding server to favs\n");
                
                return;
            }
            
            CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
            
            if( p !=NULL && ::IsWindow(p->GetSafeHwnd() ) )
            {
                // ok we're off to treeview ville
                
                if( bAdd )
                {
                    p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)pServer);
                }
                else
                {
                    p->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV, 0 , (LPARAM)pServer);
                }
            }
        }
    }
}


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CWinStation Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CWinStation::CWinStation
//
CWinStation::CWinStation(CServer *pServer, PLOGONID pLogonId)
{
    ASSERT(pServer);
    
    m_WinStationFlags = 0L;
    m_OutstandingThreads = 0;
    
    m_hTreeItem = NULL;
    m_hFavTree = NULL;
    m_hTreeThisComputer = NULL;
    
    m_pWd = NULL;
    m_UserName[0] = '\0';
    m_WdName[0] = '\0';
    m_ClientName[0] = '\0';
    m_Comment[0] = '\0';
    m_SdClass = SdNone;
    m_LogonTime.HighPart = 0L;
    m_LogonTime.LowPart = 0L;
    m_LastInputTime.HighPart = 0L;
    m_LastInputTime.LowPart = 0L;
    m_CurrentTime.HighPart = 0L;
    m_CurrentTime.LowPart = 0L;
    m_IdleTime.days = 0;
    m_IdleTime.hours = 0;
    m_IdleTime.minutes = 0;
    m_IdleTime.seconds = 0;
    m_pExtensionInfo = NULL;
    m_pExtWinStationInfo = NULL;
    m_pExtModuleInfo = NULL;
    m_NumModules = 0;
    m_ProtocolType = 0;
    m_clientDigProductId[0] = '\0';
    
    
    
    SetCurrent();
    
    m_pServer = pServer;
    m_LogonId = pLogonId->LogonId;
    wcscpy(m_Name, pLogonId->WinStationName);
    m_State = pLogonId->State;
    m_SortOrder = SortOrder[pLogonId->State];
    
    HANDLE Handle = m_pServer->GetHandle();
    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    ULONG Length;
    PDCONFIG PdConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationPd, &PdConfig,
        sizeof(PDCONFIG), &Length)) {
        m_SdClass = PdConfig.Create.SdClass;
        wcscpy(m_PdName, PdConfig.Create.PdName);
        
        if(m_SdClass == SdAsync) {
            CDCONFIG CdConfig;
            if(WinStationQueryInformation(Handle, m_LogonId, WinStationCd, &CdConfig,
                sizeof(CDCONFIG), &Length)) {
                if(CdConfig.CdClass != CdModem) SetDirectAsync();
            }
        }
    }
    
    WDCONFIG WdConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationWd, &WdConfig,
        sizeof(WDCONFIG), &Length)) {
        wcscpy(m_WdName, WdConfig.WdName);
        m_pWd = pDoc->FindWdByName(m_WdName);
        
        //      if(WdConfig.WdFlag & WDF_SHADOW_TARGET) SetCanBeShadowed();
        
        
        WINSTATIONCLIENT WsClient;
        
        if(WinStationQueryInformation(Handle, m_LogonId, WinStationClient, &WsClient,
            sizeof(WINSTATIONCLIENT), &Length)) {
            wcscpy(m_ClientName, WsClient.ClientName);
            wcscpy(m_clientDigProductId, WsClient.clientDigProductId);
        }
    }
    
    WINSTATIONCONFIG WsConfig;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationConfiguration,
        &WsConfig, sizeof(WINSTATIONCONFIG), &Length)) {
        
        wcscpy(m_Comment, WsConfig.Comment);

        if(WdConfig.WdFlag & WDF_SHADOW_TARGET)
        {
            //
            // WHY we have IsDisconnected() then IsConnected() ?
            // WHY we don't allow shadowing view only session
            //
            if( (!((IsDisconnected()) &&
                ((WsConfig.User.Shadow == Shadow_EnableInputNotify) ||
                (WsConfig.User.Shadow == Shadow_EnableNoInputNotify))))
                || (IsConnected()) )
            {
                SetCanBeShadowed();
            }
        }
    }
    
    WINSTATIONINFORMATION WsInfo;
    
    if(WinStationQueryInformation(Handle, m_LogonId, WinStationInformation, &WsInfo,
        sizeof(WINSTATIONINFORMATION), &Length))
    {
        // the state may have already changed
        
        m_State = WsInfo.ConnectState;
        wcscpy(m_UserName, WsInfo.UserName);
        
        m_LogonTime = WsInfo.LogonTime;
        
        m_LastInputTime = IsActive() ? WsInfo.LastInputTime : WsInfo.DisconnectTime;
        m_CurrentTime = WsInfo.CurrentTime;            
        // Calculate elapsed time
        if((IsActive() || IsDisconnected()) && m_LastInputTime.QuadPart <= m_CurrentTime.QuadPart && m_LastInputTime.QuadPart)
        {                
            LARGE_INTEGER DiffTime = CalculateDiffTime(m_LastInputTime, m_CurrentTime);
            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;
            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining               
            m_IdleTime = IdleTime;
            TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
    }
    
    WINSTATIONCLIENT ClientData;
    
    // Get the protocol this WinStation is using
    if(WinStationQueryInformation(  Handle,
        m_LogonId,
        WinStationClient,
        &ClientData,
        sizeof(WINSTATIONCLIENT),
        &Length ) ) {
        m_ProtocolType = ClientData.ProtocolType;
        m_EncryptionLevel = ClientData.EncryptionLevel;
    }
    
    // If there is a user, set a flag bit
    if(wcslen(m_UserName)) SetHasUser();
    else ClearHasUser();
    
    // Remember when we got this information
    SetLastUpdateClock();
    SetQueriesSuccessful();        
    
    // If there is an extension DLL loaded, allow it to add it's own info for this WinStation
    LPFNEXWINSTATIONINITPROC InitProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationInitProc();
    if(InitProc) {
        m_pExtensionInfo = (*InitProc)(Handle, m_LogonId);
        if(m_pExtensionInfo) {
            LPFNEXGETWINSTATIONINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetWinStationInfoProc();
            if(InfoProc) {
                m_pExtWinStationInfo = (*InfoProc)(m_pExtensionInfo);
            }
        }
    }
    
}       // end CWinStation::CWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinStation::~CWinStation
//
CWinStation::~CWinStation()
{
    // Remove all of the processes attributed to this WinStation
    // from the Server's list
    m_pServer->RemoveWinStationProcesses(this);
    
    // If there is an extension DLL, let it cleanup anything it added to this WinStation
    LPFNEXWINSTATIONCLEANUPPROC CleanupProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationCleanupProc();
    if(CleanupProc) {
        (*CleanupProc)(m_pExtensionInfo);
    }
    
    if(m_pExtModuleInfo) {
        // Get the extension DLL's function to free the module info
        LPFNEXFREEWINSTATIONMODULESPROC FreeModulesProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeWinStationModulesProc();
        if(FreeModulesProc) {
            (*FreeModulesProc)(m_pExtModuleInfo);
        } else {
            TRACE0("WAExGetWinStationModules exists without WAExFreeWinStationModules\n");
            ASSERT(0);
        }
    }
    
}       // end CWinStation::~CWinStation


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Update
//
// Updates this WinStation with new data from another CWinStation
//
BOOL CWinStation::Update(CWinStation *pWinStation)
{
    ASSERT(pWinStation);
    
    // Check for any information that has changed
    BOOL bInfoChanged = FALSE;
    
    // Check the State
    if(m_State != pWinStation->GetState()) {
        // If the old state was disconnected, then we want to
        // go out and get the module (client) information again
        if(m_State == State_Disconnected)
            ClearAdditionalDone();
        m_State = pWinStation->GetState();
        // Sort order only changes when state changes
        m_SortOrder = pWinStation->GetSortOrder();
        bInfoChanged = TRUE;
    }
    
    // Check the UserName
    if(wcscmp(m_UserName, pWinStation->GetUserName()) != 0) {
        SetUserName(pWinStation->GetUserName());
        if(pWinStation->HasUser()) SetHasUser();
        else ClearHasUser();
        bInfoChanged = TRUE;
    }
    
    // Check the SdClass
    if(m_SdClass != pWinStation->GetSdClass()) {
        m_SdClass = pWinStation->GetSdClass();
        bInfoChanged = TRUE;
    }
    
    // Check the Comment
    if(wcscmp(m_Comment, pWinStation->GetComment()) != 0) {
        SetComment(pWinStation->GetComment());
        bInfoChanged = TRUE;
    }
    
    // Check the WdName
    if(wcscmp(m_WdName, pWinStation->GetWdName()) != 0) {
        SetWdName(pWinStation->GetWdName());
        SetWd(pWinStation->GetWd());
        bInfoChanged = TRUE;
    }
    
    // Check the Encryption Level
    if (GetEncryptionLevel() != pWinStation->GetEncryptionLevel() ) {
        SetEncryptionLevel(pWinStation->GetEncryptionLevel());
        bInfoChanged = TRUE;
    }
    
    // Check the Name
    if(wcscmp(m_Name, pWinStation->GetName()) != 0) {
        SetName(pWinStation->GetName());
        bInfoChanged = TRUE;
    }
    
    // Check the Client Name
    if(wcscmp(m_ClientName, pWinStation->GetClientName()) != 0) {
        SetClientName(pWinStation->GetClientName());
        bInfoChanged = TRUE;
    }

    if(wcscmp(m_clientDigProductId, pWinStation->GetClientDigProductId()) != 0) {
        SetClientDigProductId(pWinStation->GetClientDigProductId());
        bInfoChanged = TRUE;
    }

    
    // Always copy the LastInputTime
    SetLastInputTime(pWinStation->GetLastInputTime());
    // Always copy the CurrentTime
    SetCurrentTime(pWinStation->GetCurrentTime());
    // Always copy the LogonTime
    // (The logon time is not set when we create a CWinStation on the fly)
    SetLogonTime(pWinStation->GetLogonTime());
    // Always copy the IdleTime
    SetIdleTime(pWinStation->GetIdleTime());
    // Always copy the Can Shadow flag
    if(pWinStation->CanBeShadowed()) SetCanBeShadowed();
    
    // Copy the Extension Info pointer if necessary
    if(pWinStation->GetExtensionInfo() && !m_pExtensionInfo) {
        m_pExtensionInfo = pWinStation->GetExtensionInfo();
        pWinStation->SetExtensionInfo(NULL);
    }
    
    // Copy the Extended Info pointer if necessary
    if(pWinStation->GetExtendedInfo() && !m_pExtWinStationInfo) {
        m_pExtWinStationInfo = pWinStation->GetExtendedInfo();
        pWinStation->SetExtendedInfo(NULL);
    }
    
    // If this guy hasn't been updated in a while, do it now
    if(!bInfoChanged) {
        clock_t now = clock();
        if((now - GetLastUpdateClock()) > 30)
            bInfoChanged = TRUE;
    }
    
    if(bInfoChanged) {
        SetChanged();
        SetLastUpdateClock();
    }
    
    return bInfoChanged;
    
}       // end CWinStation::Update


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Connect
//
void CWinStation::Connect(BOOL bUser)
{
    TCHAR szPassword[PASSWORD_LENGTH+1];
    BOOL bFirstTime = TRUE;
    DWORD Error;
    HANDLE hServer = m_pServer->GetHandle();
    
    // Start the connect loop with null password to try first.
    szPassword[0] = '\0';
    while(1) {
        if(WinStationConnect(hServer, m_LogonId, LOGONID_CURRENT, szPassword, TRUE))
            break;  // success - break out of loop
        
        if(((Error = GetLastError()) != ERROR_LOGON_FAILURE) || !bFirstTime ) {
            //We need this to know the length of the error message
            //now that StandardErrorMessage requires that
            CString tempErrorMessage;
            tempErrorMessage.LoadString(IDS_ERR_CONNECT);
            StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_CONNECT, m_LogonId);
        }
        
        // If a 'logon failure' brought us here, issue password dialog.
        // Otherwise, break the connect loop.
        if(Error == ERROR_LOGON_FAILURE) {
            
            CPasswordDlg CPDlg;
            
            CPDlg.SetDialogMode(bUser ? PwdDlg_UserMode : PwdDlg_WinStationMode);
            if(CPDlg.DoModal() == IDOK ) {
                lstrcpy(szPassword, CPDlg.GetPassword());
            } else {
                break;  // user CANCEL: break connect loop
            }
        } else
            break;      // other error: break connect loop
        
        // the next time through the loop won't be the first
        bFirstTime = FALSE;
    }
    
    SecureZeroMemory((PVOID)szPassword , sizeof(szPassword));
    
    return;
    
}       // end CWinStation::Connect


/////////////////////////////////////////////////////////////////////////////
// CWinStation::ShowStatus
//
void CWinStation::ShowStatus()
{
    switch(m_SdClass) {
    case SdNetwork:
    case SdNasi:
        new CNetworkStatusDlg(this);
        break;
        
    case SdAsync:
        new CAsyncStatusDlg(this);
        break;
        
    default:
        break;
    }
    
}       // end CWinStation::ShowStatus


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Shadow
//
void CWinStation::Shadow()
{
    WINSTATIONCONFIG WSConfig;
    SHADOWCLASS Shadow;
    ULONG ReturnLength;
    DWORD ShadowError;
    HANDLE hServer = m_pServer->GetHandle();
    
    // Determine the WinStation's shadow state.
    if(!WinStationQueryInformation(hServer,
        m_LogonId,
        WinStationConfiguration,
        &WSConfig, sizeof(WINSTATIONCONFIG),
        &ReturnLength ) ) {
        // Can't query WinStation configuration; complain and return
        return;
    }
    Shadow = WSConfig.User.Shadow;
    
    // If shadowing is disabled, let the user know and return
    if(Shadow == Shadow_Disable ) {
        DWORD Error = GetLastError();  

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW_DISABLED);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW_DISABLED, m_LogonId);
        
        return;
    }
    
    // If the WinStation is disconnected and shadow notify is 'on',
    // let the user know and break out.
    if((m_State == State_Disconnected) &&
        ((Shadow == Shadow_EnableInputNotify) ||
        (Shadow == Shadow_EnableNoInputNotify)) ) {
        DWORD Error = GetLastError();

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, Error, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON, m_LogonId);
        
        return;
    }
    
    // Display the 'start shadow' dialog for hotkey reminder and
    // final 'ok' prior to shadowing.
    CShadowStartDlg SSDlg;
    SSDlg.m_ShadowHotkeyKey = ((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyKey();
    SSDlg.m_ShadowHotkeyShift = ((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyShift();
    
    if(SSDlg.DoModal() != IDOK) {
        return;
    }
    
    // launch UI thread.
    
    DWORD tid;
    
    HANDLE hThread = ::CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE )Shadow_WarningProc , ( LPVOID )AfxGetInstanceHandle() , 0 , &tid );
   
    
    ((CWinAdminApp*)AfxGetApp())->SetShadowHotkeyKey(SSDlg.m_ShadowHotkeyKey);
    ((CWinAdminApp*)AfxGetApp())->SetShadowHotkeyShift(SSDlg.m_ShadowHotkeyShift);
    
    // Invoke the shadow DLL.
    CWaitCursor Nikki;
    
    // allow UI thread to init window
    Sleep( 900 );
    
    // Shadow API always connects to local server,
    // passing target servername as a parameter.
    
    
    BOOL bOK = WinStationShadow(SERVERNAME_CURRENT, m_pServer->GetName(), m_LogonId,
        (BYTE)((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyKey(),
        (WORD)((CWinAdminApp*)AfxGetApp())->GetShadowHotkeyShift());
    if (!bOK)
    {
        ShadowError = GetLastError();
    }
    
   
    if( g_hwndShadowWarn != NULL )
    {
        OutputDebugString( L"Posting WM_DESTROY to dialog\n");
        
        EndDialog( g_hwndShadowWarn , 0 );
        //PostMessage( g_hwndShadowWarn , WM_CLOSEDIALOG , 0 , 0 );
    }
    
    
    if( !bOK )
    {
        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_SHADOW);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            m_LogonId, ShadowError, tempErrorMessage.GetLength(), 10, IDS_ERR_SHADOW, m_LogonId);
    }
    
    CloseHandle( hThread );
    
}       // end CWinStation::Shadow


/////////////////////////////////////////////////////////////////////////////
// CWinStation::SendMessage
//
UINT CWinStation::SendMessage(LPVOID pParam)
{
    ASSERT(pParam);
    
    ULONG Response;
    UINT RetVal = 0;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();
    
    MessageParms *pMsgParms = (MessageParms*)pParam;

    // If we are operating on the current selected Item in the tree it's
    // possible that the winstation has disappeared by the time we get here
    // so we should just gracefully cleanup
    if (pMsgParms->bActionOnCurrentSelection)
    {
        if (CWinAdminDoc::gm_CurrentSelType != NODE_WINSTATION)
        {
            goto Cleanup;
        }
    }    


    HANDLE hServer = pMsgParms->pWinStation->m_pServer->GetHandle();
    
    if(!WinStationSendMessage(hServer,
        pMsgParms->pWinStation->m_LogonId,
        pMsgParms->MessageTitle, (wcslen(pMsgParms->MessageTitle)+1)*sizeof(TCHAR),
        pMsgParms->MessageBody, (wcslen(pMsgParms->MessageBody)+1)*sizeof(TCHAR),
        MB_OK, 60, &Response, TRUE ) ) {
        DWORD Error = GetLastError();

        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_MESSAGE);
        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            pMsgParms->pWinStation->m_LogonId, Error, tempErrorMessage.GetLength(),
            10, IDS_ERR_MESSAGE, pMsgParms->pWinStation->m_LogonId);
        
        RetVal = 1;
    }
    
Cleanup:
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();

    delete pMsgParms;

    return RetVal;
    
}       // end CWinStation::SendMessage


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Disconnect
//
UINT CWinStation::Disconnect(LPVOID pParam)
{
    ASSERT(pParam);
    
    UINT   RetVal = 0;
    HANDLE hServer;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();

    DisconnectParms *pDisconnectParms = (DisconnectParms*)pParam;

    // If we are operating on the current selected Item in the tree it's
    // possible that the winstation has disappeared by the time we get here
    // so we should just gracefully cleanup
    if (pDisconnectParms->bActionOnCurrentSelection)
    {
        if (CWinAdminDoc::gm_CurrentSelType != NODE_WINSTATION)
        {
            goto Cleanup;
        }
    }   

    hServer = pDisconnectParms->hServer;
    
    if(!WinStationDisconnect(hServer, pDisconnectParms->ulLogonId, TRUE)) 
    {
        DWORD Error = GetLastError();

        // We need this to know the length of the error message
        // now that StandardErrorMessage requires that
        CString tempErrorMessage;
        tempErrorMessage.LoadString(IDS_ERR_DISCONNECT);

        StandardErrorMessage(AfxGetAppName(),  
                             AfxGetMainWnd()->m_hWnd, 
                             AfxGetInstanceHandle(),
                             pDisconnectParms->ulLogonId,
                             Error, 
                             tempErrorMessage.GetLength(), 
                             10, 
                             IDS_ERR_DISCONNECT, 
                             pDisconnectParms->ulLogonId);
        RetVal = 1;
    }

Cleanup:
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();
    
    delete pDisconnectParms;

    return RetVal;
}       // end CWinStation::Disconnect


/////////////////////////////////////////////////////////////////////////////
// CWinStation::Reset
//
UINT CWinStation::Reset(LPVOID pParam)
{
    ASSERT(pParam);
    
    UINT RetVal = 0;
    
    ((CWinAdminApp*)AfxGetApp())->BeginOutstandingThread();
    
    ResetParms *pResetParms = (ResetParms*)pParam;
    
    // If we are operating on the current selected Item in the tree it's
    // possible that the winstation has disappeared by the time we get here
    // so we should just gracefully cleanup
    if (pResetParms->bActionOnCurrentSelection)
    {
        if (CWinAdminDoc::gm_CurrentSelType != NODE_WINSTATION)
        {
            goto Cleanup;
        }
    }

    HANDLE hServer = pResetParms->pWinStation->m_pServer->GetHandle();
    
    if(!WinStationReset(hServer, pResetParms->pWinStation->m_LogonId, TRUE))
    {
        DWORD Error = GetLastError();
        
        //We need this to know the length of the error message
        //now that StandardErrorMessage requires that
        CString tempErrorMessage1, tempErrorMessage2;
        tempErrorMessage1.LoadString(IDS_ERR_RESET);
        tempErrorMessage2.LoadString(IDS_ERR_USER_LOGOFF);

        StandardErrorMessage(AfxGetAppName(),  AfxGetMainWnd()->m_hWnd, AfxGetInstanceHandle(),
            pResetParms->pWinStation->m_LogonId, Error, 
            pResetParms->bReset ? tempErrorMessage1.GetLength() : tempErrorMessage2.GetLength(), 10,
            pResetParms->bReset ? IDS_ERR_RESET : IDS_ERR_USER_LOGOFF, pResetParms->pWinStation->m_LogonId);
        RetVal = 1;
    }

Cleanup:
    ((CWinAdminApp*)AfxGetApp())->EndOutstandingThread();
    
    delete pParam;
    
    return RetVal;
    
}       // end CWinStation::Reset


/////////////////////////////////////////////////////////////////////////////
// CWinStation::QueryAdditionalInformation
//
void CWinStation::QueryAdditionalInformation()
{
    ULONG ReturnLength;
    HANDLE hServer = m_pServer->GetHandle();
    WINSTATIONCLIENT ClientData;
    
    // Set all the strings to start with a NULL
    m_ClientDir[0] = '\0';
    m_ModemName[0] = '\0';
    m_ClientLicense[0] = '\0';
    m_ClientAddress[0] = '\0';
    m_Colors[0] = '\0';
    
    // Set all the values to 0
    m_ClientBuildNumber = 0;
    m_ClientProductId = 0;
    m_HostBuffers = 0;
    m_ClientBuffers = 0;
    m_BufferLength = 0;
    m_ClientSerialNumber = 0;
    m_VRes = 0;
    m_HRes = 0;
    
    SetAdditionalDone();
    
    if ( WinStationQueryInformation( hServer,
        m_LogonId,
        WinStationClient,
        &ClientData,
        sizeof(WINSTATIONCLIENT),
        &ReturnLength ) ) {
        
        // Assign string values.
        wcscpy(m_ClientDir, ClientData.ClientDirectory);
        wcscpy(m_ModemName, ClientData.ClientModem);
        wcscpy(m_ClientLicense, ClientData.ClientLicense);
        wcscpy(m_ClientAddress, ClientData.ClientAddress);
        
        switch ( ClientData.ColorDepth ) {
        case 0x0001:
            wcscpy(m_Colors, TEXT("16"));
            break;
        case 0x0002:
            wcscpy(m_Colors, TEXT("256"));
            break;
        case 0x0004:
            wcscpy(m_Colors, TEXT("64K"));
            break;
        case 0x0008:
            wcscpy(m_Colors, TEXT("16M"));
            break;
        case 0x0010:
            wcscpy(m_Colors, TEXT("32M"));
            break;
            
        }
        
        // Assign numeric values.
        m_ClientBuildNumber = ClientData.ClientBuildNumber;
        m_ClientProductId = ClientData.ClientProductId;
        m_HostBuffers = ClientData.OutBufCountHost;
        m_ClientBuffers = ClientData.OutBufCountClient;
        m_BufferLength = ClientData.OutBufLength;
        m_ClientSerialNumber = ClientData.SerialNumber;
        m_HRes = ClientData.HRes;
        m_VRes = ClientData.VRes;
    }
    
    // If there is an extension DLL loaded, allow it to add it's own info for this WinStation
    LPFNEXWINSTATIONINFOPROC InfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtWinStationInfoProc();
    if(InfoProc) {
        (*InfoProc)(m_pExtensionInfo, m_State);
    }
    
    LPFNEXGETWINSTATIONMODULESPROC ModuleProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetWinStationModulesProc();
    if(ModuleProc) {
        if(m_pExtModuleInfo) {
            // Get the extension DLL's function to free the module info
            LPFNEXFREEWINSTATIONMODULESPROC FreeModulesProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeWinStationModulesProc();
            if(FreeModulesProc) {
                (*FreeModulesProc)(m_pExtModuleInfo);
            } else {
                TRACE0("WAExGetWinStationModules exists without WAExFreeWinStationModules\n");
                ASSERT(0);
            }
        }
        
        m_pExtModuleInfo = (*ModuleProc)(GetExtensionInfo(), &m_NumModules);
    }
    
}       //      end CWinStation::QueryAdditionalInformation


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CProcess Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CProcess::CProcess
//
CProcess::CProcess(ULONG PID,
                   ULONG LogonId,
                   CServer *pServer,
                   PSID pSID,
                   CWinStation *pWinStation,
                   TCHAR *ImageName)
{
    ASSERT(pServer);
    
    DWORD dwImageNameLen;

    m_Flags = PF_CURRENT;
    m_PID = PID;
    m_LogonId = LogonId;
    m_pServer = pServer;
    m_pWinStation = pWinStation;
    m_ImageName = NULL;
    
    if(PID == 0 && !pSID)
    {
        CString sTemp;
        sTemp.LoadString(IDS_SYSTEM_IDLE_PROCESS);

        // allocate memory for Image Name and copy to member variable
        dwImageNameLen = sTemp.GetLength();
        m_ImageName = (LPTSTR)LocalAlloc(LPTR, (dwImageNameLen + 1) * sizeof(TCHAR));
        if (m_ImageName != NULL)
        {
            _tcscpy(m_ImageName, sTemp);
        }

        SetSystemProcess();
        _tcscpy(m_UserName, TEXT("System"));
        m_SidCrc = 0;
    }
    else
    {            
        if(pSID) {
            DWORD SidLength = GetLengthSid(pSID);
            m_SidCrc = CalculateCrc16((PBYTE)pSID, (USHORT)SidLength);
        } else m_SidCrc = 0;
        
        DetermineProcessUser(pSID);

        // allocate memory for Image Name and copy to member variable
        dwImageNameLen = _tcslen(ImageName);
        m_ImageName = (LPTSTR)LocalAlloc(LPTR, (dwImageNameLen + 1) * sizeof(TCHAR));
        if (m_ImageName != NULL)
        {
            _tcscpy(m_ImageName, ImageName);
            if(QuerySystemProcess()) SetSystemProcess();
        }        
    }
    
}       // end CProcess::CProcess


TCHAR *SysProcTable[] = {
    TEXT("csrss.exe"),
        TEXT("smss.exe"),
        TEXT("screg.exe"),
        TEXT("lsass.exe"),
        TEXT("spoolss.exe"),
        TEXT("EventLog.exe"),
        TEXT("netdde.exe"),
        TEXT("clipsrv.exe"),
        TEXT("lmsvcs.exe"),
        TEXT("MsgSvc.exe"),
        TEXT("winlogon.exe"),
        TEXT("NETSTRS.EXE"),
        TEXT("nddeagnt.exe"),
        TEXT("wfshell.exe"),
        TEXT("chgcdm.exe"),
        TEXT("userinit.exe"),
        NULL
};


/////////////////////////////////////////////////////////////////////////////
// CProcess::~CProcess
//
/////////////////////////////////////////////////////////////////////////////
CProcess::~CProcess()
{
    if (m_ImageName != NULL)
    {
        LocalFree(m_ImageName);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CProcess::QuerySystemProcess
//
BOOL CProcess::QuerySystemProcess()
{
    // First: if the user name is 'system' or no image name is present, treat
    // as a 'system' process.
    if(!lstrcmpi(m_UserName, TEXT("system")) ||
        !(*m_ImageName) )
        return TRUE;
    
    // Last: if the image name is one of the well known 'system' images,
    // treat it as a 'system' process.
    for(int i = 0; SysProcTable[i]; i++)
        if(!lstrcmpi( m_ImageName, SysProcTable[i]))
            return TRUE;
        
        // Not a 'system' process.
        return FALSE;
        
}       // end CProcess::QuerySystemProcess


/////////////////////////////////////////////////////////////////////////////
// CProcess::DetermineProcessUser
//
void CProcess::DetermineProcessUser(PSID pSid)
{
    CObList *pUserSidList = m_pServer->GetUserSidList();
    
    // Look for the user Sid in the list
    POSITION pos = pUserSidList->GetHeadPosition();
    
    while(pos)
    {
        CUserSid *pUserSid = (CUserSid*)pUserSidList->GetNext(pos);
        
        if(pUserSid->m_SidCrc == m_SidCrc)
        {
            wcscpy(m_UserName, pUserSid->m_UserName);
            
            return;
            
        }
    }
    
    // It wasn't in the list
    // Get the user from the Sid and put it in our list
    
    GetUserFromSid(pSid, m_UserName, USERNAME_LENGTH);
    
    if (!lstrcmpi(m_UserName,TEXT("system")))
    {
        wcscpy(m_UserName, TEXT("System")); // to make the UI guys happy
    }
    
    CUserSid *pUserSid = new CUserSid;
    if(pUserSid == NULL)
    {
        return;        
    }
    
    pUserSid->m_SidCrc = m_SidCrc;

    memset(pUserSid->m_UserName, 0, sizeof(pUserSid->m_UserName));
    
    lstrcpy(pUserSid->m_UserName, m_UserName);
    
    pUserSidList->AddTail(pUserSid);
    
    
}       // end CProcess::DetermineProcessUser


/////////////////////////////////////////////////////////////////////////////
// CProcess::Update
//
BOOL CProcess::Update(CProcess *pProcess)
{
    ASSERT(pProcess);
    
    BOOL bChanged = FALSE;
    
    // Check the WinStation
    if(m_pWinStation != pProcess->GetWinStation())
    {
        m_pWinStation = pProcess->GetWinStation();
        bChanged = TRUE;
    }
    else
    {
        if(m_pWinStation->IsChanged())
        {
            bChanged = TRUE;
        }
    }
    
    if(bChanged) SetChanged();
    
    return bChanged;
    
}       // end CProcess::Update


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CLicense Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CLicense::CLicense
//
CLicense::CLicense(CServer *pServer, ExtLicenseInfo *pLicenseInfo)
{
    ASSERT(pServer);
    ASSERT(pLicenseInfo);
    
    m_pServer = pServer;
    m_Class = pLicenseInfo->Class;
    m_PoolLicenseCount = pLicenseInfo->PoolLicenseCount;
    m_LicenseCount = pLicenseInfo->LicenseCount;
    m_Flags = pLicenseInfo->Flags;
    wcscpy(m_RegSerialNumber, pLicenseInfo->RegSerialNumber);
    wcscpy(m_LicenseNumber, pLicenseInfo->LicenseNumber);
    wcscpy(m_Description, pLicenseInfo->Description);
    
    // Figure out the pooling count
    if(m_Flags & ELF_POOLING)
        m_PoolCount = m_PoolLicenseCount;
    else m_PoolCount = 0xFFFFFFFF;
    
}       // end CLicense::CLicense


//////////////////////////////////////////////////////////////////////////////////////////
//
//      CWd Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////
static CHAR szEncryptionLevels[] = "ExtEncryptionLevels";


/////////////////////////////////////////////////////////////////////////////
// CWd::CWd
//
CWd::CWd(PWDCONFIG2 pWdConfig, PWDNAME pRegistryName)
{
    m_pEncryptionLevels = NULL;
    m_NumEncryptionLevels = 0L;
    
    wcscpy(m_WdName, pWdConfig->Wd.WdName);
    wcscpy(m_RegistryName, pRegistryName);
    
    // Load the extension DLL for this WD
    m_hExtensionDLL = ::LoadLibrary(pWdConfig->Wd.CfgDLL);
    if(m_hExtensionDLL) {
        // Get the entry points
        m_lpfnExtEncryptionLevels = (LPFNEXTENCRYPTIONLEVELSPROC)::GetProcAddress(m_hExtensionDLL, szEncryptionLevels);
        if(m_lpfnExtEncryptionLevels) {
            m_NumEncryptionLevels = (*m_lpfnExtEncryptionLevels)(NULL, &m_pEncryptionLevels);
        }
    }
    
}       // end CWd::CWd


/////////////////////////////////////////////////////////////////////////////
// CWd::~CWd
//
CWd::~CWd()
{
    if(m_hExtensionDLL) {
        ::FreeLibrary(m_hExtensionDLL);
    }
    
    
}       // end CWd::~CWd


/////////////////////////////////////////////////////////////////////////////
// CWd::GetEncryptionLevelString
//
BOOL CWd::GetEncryptionLevelString(DWORD Value, CString *pString)
{
    if(!m_NumEncryptionLevels) return FALSE;
    
    for(LONG i = 0; i < m_NumEncryptionLevels; i++) {
        // Is this the right encryption level
        if(Value == m_pEncryptionLevels[i].RegistryValue) {
            TCHAR estring[128];
            if(::LoadString(m_hExtensionDLL,
                m_pEncryptionLevels[i].StringID, estring, 127)) {
                pString->Format(TEXT("%s"), estring);
                return TRUE;
            }
            return FALSE;
        }
    }
    
    return FALSE;
}       // end CWd::GetEncryptionLevelString

//------------------------------------------------
DWORD Shadow_WarningProc( LPVOID param )
{
    HINSTANCE hInst = ( HINSTANCE )param;
    
    OutputDebugString( L"Shadow_WarningProc called\n" );
    
    DialogBox( hInst , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) , NULL , ShadowWarn_WndProc );
    
    OutputDebugString( L"Shadow_WarningProc exiting thread\n" );
    
    ExitThread( 0 );
    
    return 0;
}



//------------------------------------------------
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        
        g_hwndShadowWarn = hwnd;
        
        OutputDebugString( L"WM_INITDIALOG -- in ShadowWarn_WndProc\n" );
        
        CenterDlg( GetDesktopWindow( ) , hwnd );
        
        break;
        
        
    case WM_CLOSE:
        
        EndDialog( hwnd , 0 );
        
        break;
    }
    
    return FALSE;
}


void CenterDlg(HWND hwndToCenterOn , HWND hDlg )
{
    RECT rc, rcwk, rcToCenterOn;
    
    
    SetRect( &rcToCenterOn , 0 , 0 , GetSystemMetrics(SM_CXSCREEN) , GetSystemMetrics( SM_CYSCREEN ) );
    
    if (hwndToCenterOn != NULL)
    {
        ::GetWindowRect(hwndToCenterOn, &rcToCenterOn);
    }
    
    ::GetWindowRect( hDlg , &rc);
    
    UINT uiWidth = rc.right - rc.left;
    UINT uiHeight = rc.bottom - rc.top;
    
    rc.left = (rcToCenterOn.left + rcToCenterOn.right)  / 2 - ( rc.right - rc.left )   / 2;
    rc.top  = (rcToCenterOn.top  + rcToCenterOn.bottom) / 2 - ( rc.bottom - rc.top ) / 2;
    
    //ensure the dialog always with the work area
    if(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcwk, 0))
    {
        UINT wkWidth = rcwk.right - rcwk.left;
        UINT wkHeight = rcwk.bottom - rcwk.top;
        
        if(rc.left + uiWidth > wkWidth)     //right cut
            rc.left = wkWidth - uiWidth;
        
        if(rc.top + uiHeight > wkHeight)    //bottom cut
            rc.top = wkHeight - uiHeight;
        
        if(rc.left < rcwk.left)             //left cut
            rc.left += rcwk.left - rc.left;
        
        if(rc.top < rcwk.top)               //top cut
            rc.top +=  rcwk.top - rc.top;
        
    }
    
    ::SetWindowPos( hDlg, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER |
        SWP_NOCOPYBITS | SWP_DRAWFRAME);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\allsrvvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.h
*
* declarations for the CAllServersView class
*
*
*******************************************************************************/

#ifndef _ALLSERVERSVIEW_H
#define _ALLSERVERSVIEW_H

#include "allsrvpg.h"

const int NUMBER_OF_AS_PAGES = 5;

////////////////////
// CLASS: CAllServersView
//
class CAllServersView : public CAdminView
{
friend class CRightPane;

private:
	CMyTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;
	int m_CurrPage;

		
protected:
	CAllServersView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAllServersView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_AS_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAllServersView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAllServersView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CAllServersView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM ) ;
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
    
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAllServersView


#endif  // _ALLSERVERSVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\basetree.h ===
/*******************************************************************************
*
* basetree.h
*
* - declarations for the CBaseTreeView class
* - the CBaseTreeView class is the class which the tree views are
* - derived from.
* - derived from CTreeView
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\basetree.h  $
*  
*     Rev 1.4   19 Feb 1998 17:40:04   donm
*  removed latest extension DLL support
*  
*     Rev 1.2   19 Jan 1998 16:46:04   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.1   03 Nov 1997 15:23:08   donm
*  update
*  
*     Rev 1.0   13 Oct 1997 22:32:48   donm
*  Initial revision.
*  
*******************************************************************************/

#ifndef _BASETREE_H
#define _BASETREE_H

#include "afxcview.h"

///////////////////////
// CLASS: CBaseTreeView
//
class CBaseTreeView : public CTreeView
{
friend class CTreeTabCtrl;
friend class CLeftPane;

protected:
	CBaseTreeView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBaseTreeView)

// Attributes
protected:
	CImageList m_ImageList;	   // image list associated with the tree control
	CCriticalSection m_TreeControlCriticalSection;

	BOOL m_bInitialExpand;	// we haven't done an initial Expand on the tree because
									// there aren't any nodes beneath the root

// Operations
public:

    HTREEITEM GetNextItem( HTREEITEM hItem);

protected:

	DWORD_PTR GetCurrentNode();
	// Adds an icon's image to the image list and returns the image's index
	int AddIconToImageList(int);	
	// Adds an item to the tree
	HTREEITEM AddItemToTree(HTREEITEM, CString, HTREEITEM, int, LPARAM);
	// Locks the tree control for exclusive use and returns a reference
	// to the tree control
	CTreeCtrl& LockTreeControl() { 
		m_TreeControlCriticalSection.Lock(); 
		return GetTreeCtrl();
	}
	// Unlocks the tree control
	void UnlockTreeControl() { m_TreeControlCriticalSection.Unlock(); }
	void ForceSelChange();
	
private:

	// Builds the image list
	virtual void BuildImageList();
	
	// Collapses a tree item 
	void Collapse(HTREEITEM hItem);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBaseTreeView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBaseTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBaseTreeView)
	afx_msg LRESULT OnExpandAll(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnCollapseAll(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnCollapseToThirdLevel(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnCollapseToRootChildren(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CBaseTreeView

#endif  // _BASETREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\basetree.cpp ===
/*******************************************************************************
*
* basetree.cpp
*
* implementation of the CBaseTreeView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\basetree.cpp  $
*
*     Rev 1.4   19 Feb 1998 17:39:58   donm
*  removed latest extension DLL support
*
*     Rev 1.2   19 Jan 1998 17:03:10   donm
*  new ui behavior for domains and servers
*
*     Rev 1.1   03 Nov 1997 15:21:28   donm
*  update
*
*     Rev 1.0   13 Oct 1997 22:31:30   donm
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "basetree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////
// MESSAGE MAP: CBaseTreeView
//
IMPLEMENT_DYNCREATE(CBaseTreeView, CTreeView)

BEGIN_MESSAGE_MAP(CBaseTreeView, CTreeView)
	//{{AFX_MSG_MAP(CBaseTreeView)
	ON_MESSAGE(WM_ADMIN_EXPANDALL, OnExpandAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSEALL, OnCollapseAll)
	ON_MESSAGE(WM_ADMIN_COLLAPSETOSERVERS, OnCollapseToThirdLevel)
    ON_MESSAGE(WM_ADMIN_COLLAPSETODOMAINS, OnCollapseToRootChildren)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChange)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////
// F'N: CBaseTreeView ctor
//
CBaseTreeView::CBaseTreeView()
{
	m_bInitialExpand = FALSE;

}  // end CBaseTreeView ctor


//////////////////////////
// F'N: CBaseTreeView dtor
//
CBaseTreeView::~CBaseTreeView()
{

}  // end CBaseTreeView dtor


/////////////////////////////
// F'N: CBaseTreeView::OnDraw
//
void CBaseTreeView::OnDraw(CDC* pDC)
{
	CWinAdminDoc* pDoc = (CWinAdminDoc*)GetDocument();
	ASSERT(pDoc != NULL);
	ASSERT_VALID(pDoc);
}  // end CBaseTreeView::OnDraw


#ifdef _DEBUG
//////////////////////////////////
// F'N: CBaseTreeView::AssertValid
//
void CBaseTreeView::AssertValid() const
{
	CTreeView::AssertValid();	

}  // end CBaseTreeView::AssertValid


///////////////////////////
// F'N: CBaseTreeView::Dump
//
void CBaseTreeView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);

}  // end CBaseTreeView::Dump
#endif

//////////////////////////////////////
// F'N: CBaseTreeView::PreCreateWindow
//
BOOL CBaseTreeView::PreCreateWindow(CREATESTRUCT& cs)
{
	// Set the style bits for the CTreeCtrl
	cs.style |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_DISABLEDRAGDROP
		| TVS_SHOWSELALWAYS;
	
	return CTreeView::PreCreateWindow(cs);

}  // end CBaseTreeView::PreCreateWindow


/////////////////////////////////////
// F'N: CBaseTreeView::BuildImageList
//
void CBaseTreeView::BuildImageList()
{
	// do nothing

}  // end CBaseTreeView::BuildImageList


//////////////////////////////////////
// F'N: CBaseTreeView::OnInitialUpdate
//
// - constructs the image list for the tree, saving indices to each icon
//   in member variables (m_idxCitrix, m_idxServer, etc.)
//
void CBaseTreeView::OnInitialUpdate()
{
	CTreeView::OnInitialUpdate();

	// build the image list for the tree control
	BuildImageList();		
	
}  // end CBaseTreeView::OnInitialUpdate


/////////////////////////////////////////
// F'N: CBaseTreeView::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CBaseTreeView::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CBaseTreeView::AddIconToImageList


////////////////////////////////////
// F'N: CBaseTreeView::AddItemToTree
//
//	Adds an item with the given attributes to the CTreeCtrl
//
HTREEITEM CBaseTreeView::AddItemToTree(HTREEITEM hParent, CString szText, HTREEITEM hInsAfter, int iImage, LPARAM lParam)
{
    HTREEITEM hItem;
    TV_ITEM tvItem = {0};
    TV_INSERTSTRUCT tvInsert;

    ASSERT(lParam);

    tvItem.mask           = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;
    TCHAR temp[255];
    lstrcpyn(temp, szText, sizeof(temp) / sizeof(TCHAR));
    tvItem.pszText        = temp;
    tvItem.cchTextMax     = lstrlen(szText);
    tvItem.iImage         = iImage;
    tvItem.iSelectedImage = iImage;
    tvItem.lParam		  = lParam;

    tvInsert.item         = tvItem;
    tvInsert.hInsertAfter = hInsAfter;
    tvInsert.hParent      = hParent;

    hItem = GetTreeCtrl().InsertItem(&tvInsert);

    if(!m_bInitialExpand && hItem) {
        m_bInitialExpand = GetTreeCtrl().Expand(GetTreeCtrl().GetRootItem(), TVE_EXPAND);
    }

    return hItem;

}  // end CBaseTreeView::AddItemToTree


///////////////////////////////////
// F'N: CBaseTreeView::GetCurrentNode
//
DWORD_PTR CBaseTreeView::GetCurrentNode()
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR node = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();
	
	return node;

}  // end CBaseTreeView::GetCurrentNode


///////////////////////////////////
// F'N: CBaseTreeView::OnSelChange
//
// - this f'n posts a WM_ADMIN_CHANGEVIEW message to the mainframe, passing along
//   a pointer to the newly selected tree item's info structure in lParam so
//   that the mainframe can make an intelligent decision as far as how to
//   interpret the message
//
//	Passes TRUE as wParam for WM_ADMIN_CHANGEVIEW message to signify
//	that the message was caused by a user mouse click
//
void CBaseTreeView::OnSelChange(NMHDR* pNMHDR, LRESULT* pResult)
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR value = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();

	// Tell the document that the current item in the tree has changed
    CTreeNode *pNode = (CTreeNode*)value;
    
    if( pNode != NULL )
    {
	    ((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);

        ((CWinAdminDoc*)GetDocument())->SetTreeCurrent( pNode->GetTreeObject(), pNode->GetNodeType());
	    
        // send a "change view" msg to the mainframe with the info structure ptr as a parm

	    CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();        
        
        pMainWnd->SendMessage(WM_ADMIN_CHANGEVIEW, *pResult == 0xc0 ? TRUE : FALSE , (LPARAM)pNode);
    }

	*pResult = 0;

}  // end CBaseTreeView::OnSelChange


///////////////////////////////////
// F'N: CBaseTreeView::ForceSelChange
//
// Called by treeview when the state of an item in the tree has changed
// which is likely to cause the current view in the right pane to change.
//
// This f'n posts a WM_ADMIN_CHANGEVIEW message to the mainframe, passing along
// a pointer to the newly selected tree item's info structure in lParam so
// that the mainframe can make an intelligent decision as far as how to
// interpret the message
//
// Puts a FALSE in wParam of the WM_ADMIN_CHANGEVIEW message which
// tells the right pane that this was not caused by a user clicking
// on the item in the tree
//
void CBaseTreeView::ForceSelChange()
{
	LockTreeControl();
	HTREEITEM hCurr = GetTreeCtrl().GetSelectedItem();
	DWORD_PTR value = GetTreeCtrl().GetItemData(hCurr);
	UnlockTreeControl();

	// Tell the document that the current item in the tree has changed
	((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);
	((CWinAdminDoc*)GetDocument())->SetTreeCurrent(((CTreeNode*)value)->GetTreeObject(), ((CTreeNode*)value)->GetNodeType());

	// send a "change view" msg to the mainframe with the info structure ptr as a parm
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	pMainWnd->PostMessage(WM_ADMIN_CHANGEVIEW, FALSE, (LPARAM)value);	// SendMessage causes blank pages

}  // end CBaseTreeView::ForceSelChange


////////////////////////////////
// F'N: CBaseTreeView::OnExpandAll
//
//	Expands all levels of the tree, starting at the root
//
LRESULT CBaseTreeView::OnExpandAll(WPARAM wParam, LPARAM lParam)
{
	LockTreeControl();
	// get a count of the items in the tree
	UINT itemCount = GetTreeCtrl().GetCount();

	// get the handle of the root item and Expand it
	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	for(UINT i = 0; i < itemCount; i++)  {
		GetTreeCtrl().Expand(hTreeItem, TVE_EXPAND);
		hTreeItem = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_NEXTVISIBLE);
	}

	UnlockTreeControl();

	return 0;
}  // end CBaseTreeView::OnExpandAll


////////////////////////////////
// F'N: CBaseTreeView::Collapse
//
//	Helper function to collapse a tree item
//	NOTE: This function calls itself recursively
//
void CBaseTreeView::Collapse(HTREEITEM hItem)
{
	LockTreeControl();

	CTreeCtrl &tree = GetTreeCtrl();

	// Get his first child and collapse him
	HTREEITEM hChild = tree.GetNextItem(hItem, TVGN_CHILD);
	if(hChild) Collapse(hChild);
	// Collapse him
	tree.Expand(hItem, TVE_COLLAPSE);
	// Get his first sibling and collapse him
	HTREEITEM hSibling = tree.GetNextItem(hItem, TVGN_NEXT);
	if(hSibling) Collapse(hSibling);

	UnlockTreeControl();
}  // end CBaseTreeView::Collapse


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseAll
//
//	Collapses all levels of the tree, starting at the root
//
LRESULT CBaseTreeView::OnCollapseAll(WPARAM wParam, LPARAM lParam)
{
	// Call the recursive function to do all
	// the collapsing
	Collapse(GetTreeCtrl().GetRootItem());

	return 0;

}  // end CBaseTreeView::OnCollapseAll


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseToThirdLevel
//
//	Collapses tree down to show just root children and their children
//
LRESULT CBaseTreeView::OnCollapseToThirdLevel(WPARAM wParam, LPARAM lParam)
{
   UINT i = 0;

	LockTreeControl();
	// Get the root item
	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();

   // Collapse to Root Child for First two nodes. They are This Computer and Favorite Servers
   while (hTreeItem && i < 2) {

        i++;

        // Get the first node
        HTREEITEM hNode = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_CHILD);
        while(hNode) {
            Collapse(hNode);
            // go to the next node
            hNode = GetTreeCtrl().GetNextItem(hNode, TVGN_NEXT);
        }

        hTreeItem = GetTreeCtrl().GetNextSiblingItem(hTreeItem);
   }

   if (hTreeItem) {
   
    	// Get the first node
    	HTREEITEM hRootChild = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_CHILD);
    	while(hRootChild) {
            HTREEITEM hThirdLevel = GetTreeCtrl().GetNextItem(hRootChild, TVGN_CHILD);
            while(hThirdLevel) {
    		    // collapse him
    		    GetTreeCtrl().Expand(hThirdLevel, TVE_COLLAPSE);
    		    // go to the next one
    		    hThirdLevel = GetTreeCtrl().GetNextItem(hThirdLevel, TVGN_NEXT);
            }
            hRootChild = GetTreeCtrl().GetNextItem(hRootChild, TVGN_NEXT);
    	}      
   }

	UnlockTreeControl();

	return 0;

}  // end CBaseTreeView::OnCollapseToThirdLevel


////////////////////////////////
// F'N: CBaseTreeView::OnCollapseToRootChildren
//
//	Collapses tree down to show just root and it's immediate children
//
LRESULT CBaseTreeView::OnCollapseToRootChildren(WPARAM wParam, LPARAM lParam)
{
    LockTreeControl();

    // Get the root item
    HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();

    // Skip This Computer and Favorite Servers
    if (hTreeItem) {
        hTreeItem = GetTreeCtrl().GetNextSiblingItem(hTreeItem);
        if (hTreeItem) {
            hTreeItem = GetTreeCtrl().GetNextSiblingItem(hTreeItem);
        }
    }

    if(hTreeItem) {

        // Get the first node
        HTREEITEM hNode = GetTreeCtrl().GetNextItem(hTreeItem, TVGN_CHILD);
        while(hNode) {
            Collapse(hNode);
            // go to the next node
            hNode = GetTreeCtrl().GetNextItem(hNode, TVGN_NEXT);
        }        
    }

    UnlockTreeControl();

    return 0;

}  // end CBaseTreeView::OnCollapseToRootChildren



////////////////////////////////
// F'N: CBaseTreeView::OnDestroy
//
void CBaseTreeView::OnDestroy()
{
	LockTreeControl();

	UINT itemCount = GetTreeCtrl().GetCount();

	HTREEITEM hTreeItem = GetTreeCtrl().GetRootItem();
	for(UINT i = 0; i < itemCount; i++)  {
		CTreeNode *node = ((CTreeNode*)GetTreeCtrl().GetItemData(hTreeItem));
		delete (CTreeNode*)(GetTreeCtrl().GetItemData(hTreeItem));
		hTreeItem = GetNextItem(hTreeItem);
	}

	UnlockTreeControl();

}  // end CBaseTreeView::OnDestroy


////////////////////////////////
// F'N: CBaseTreeView::GetNextItem
//
// GetNextItem  - Get next item as if outline was completely expanded
// Returns      - The item immediately below the reference item
// hItem        - The reference item
//
HTREEITEM CBaseTreeView::GetNextItem( HTREEITEM hItem )
{
	HTREEITEM       hti;
	CTreeCtrl &tree = GetTreeCtrl();
	
	if(tree.ItemHasChildren( hItem ) )
		return tree.GetChildItem( hItem );           // return first child
    else {                // return next sibling item
		// Go up the tree to find a parent's sibling if needed.
        while( (hti = tree.GetNextSiblingItem( hItem )) == NULL ) {
			if( (hItem = tree.GetParentItem( hItem ) ) == NULL )
				return NULL;
		}
	}

	return hti;

}	// end CBaseTreeView::GetNextItem
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\blankvw.cpp ===
/*******************************************************************************
*
* blankvw.cpp
*
* implementation of the CBlankView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BLANKVW.CPP  $
*  
*     Rev 1.0   30 Jul 1997 17:11:04   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "blankvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////
// MESSAGE MAP: CBlankView
//
IMPLEMENT_DYNCREATE(CBlankView, CView)

BEGIN_MESSAGE_MAP(CBlankView, CView)
	//{{AFX_MSG_MAP(CBlankView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////
// F'N: CBlankView ctor
//
// - the m_id member var has no implicit meaning; it's just a place
//   to stick a number if you want to show a CBlankView someplace
//   and want a little clue as to who caused it to appear or something
//
CBlankView::CBlankView()
{


}  // end CBlankView ctor


/////////////////////////
// F'N: CBlankView dtor
//
CBlankView::~CBlankView()
{
}  // end CBlankView dtor


#ifdef _DEBUG
/////////////////////////////////
// F'N: CBlankView::AssertValid
//
void CBlankView::AssertValid() const
{
	CView::AssertValid();

}  // end CBlankView::AssertValid


//////////////////////////
// F'N: CBlankView::Dump
//
void CBlankView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CBlankView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CBlankView::OnDraw
//
// - the text "CBlankView  ID #x" is always displayed in medium
//   gray in the center of the view, where 'x' is the current
//   value of m_id
//
void CBlankView::OnDraw(CDC* pDC) 
{
	CRect rect;
	GetClientRect(&rect);

	pDC->SetTextColor(RGB(160, 160, 160));
	pDC->SetBkMode(TRANSPARENT);

//	CString szTemp;
//	szTemp.Format("CBlankView  ID #%d", m_id);

//	pDC->DrawText(szTemp, -1, &rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
	
}  // end CBlankView::OnDraw
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\colsort.cpp ===
/*******************************************************************************
*
* colsort.cpp
*
* Helper functions to sort columns
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\colsort.cpp  $
*  
*     Rev 1.10   19 Feb 1998 17:40:12   donm
*  removed latest extension DLL support
*  
*     Rev 1.7   12 Feb 1998 14:20:50   donm
*  missed some State columns
*  
*     Rev 1.6   12 Feb 1998 12:59:20   donm
*  State columns wouldn't sort because they were being treated as numbers
*  
*     Rev 1.5   10 Nov 1997 14:51:30   donm
*  fixed endless recursion in SortTextItems
*  
*     Rev 1.4   07 Nov 1997 23:06:38   donm
*  CompareTCPAddress would trap if ExtServerInfo was NULL
*  
*     Rev 1.3   03 Nov 1997 15:23:22   donm
*  added descending sort/cleanup
*  
*     Rev 1.2   15 Oct 1997 19:50:34   donm
*  update
*  
*     Rev 1.1   13 Oct 1997 18:39:54   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:26   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Compare function for columns of WinStations
/* no longer used since we want an alphabetical order
int CALLBACK CompareWinStation(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	ULONG sort1 = ((CWinStation*)lParam1)->GetSortOrder();
	ULONG sort2 = ((CWinStation*)lParam2)->GetSortOrder();
	if(sort1 == sort2) {
		SDCLASS pd1 = ((CWinStation*)lParam1)->GetSdClass();
		SDCLASS pd2 = ((CWinStation*)lParam2)->GetSdClass();
		if(pd1 == pd2) retval = 0;
		else if(pd1 < pd2) retval = -1;
		else retval =  1;
	}
	else if(sort1 < sort2) retval = -1;
	else retval = 1;

    return(lParamSort ? retval : -retval);
}
*/

// Compare function for columns of Idle Times
int CALLBACK CompareIdleTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;
	ELAPSEDTIME idle1 = ((CWinStation*)lParam1)->GetIdleTime();
	ELAPSEDTIME idle2 = ((CWinStation*)lParam2)->GetIdleTime();
	// check days first
	if(idle1.days < idle2.days) retval = -1;
	else if(idle1.days > idle2.days) retval = 1;
	// check hours
	else if(idle1.hours < idle2.hours) retval = -1;
	else if(idle1.hours > idle2.hours) retval = 1;
	// check minutes
	else if(idle1.minutes < idle2.minutes) retval = -1;
	else if(idle1.minutes > idle2.minutes) retval = 1;
	// check seconds
	else if(idle1.seconds < idle2.seconds) retval = -1;
	else if(idle1.seconds > idle2.seconds) retval = 1;

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Logon Times
int CALLBACK CompareLogonTime(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	LARGE_INTEGER logon1 = ((CWinStation*)lParam1)->GetLogonTime();
	LARGE_INTEGER logon2 = ((CWinStation*)lParam2)->GetLogonTime();

	if(logon1.QuadPart == logon2.QuadPart) retval = 0;
	else if(logon1.QuadPart < logon2.QuadPart) retval = -1;
	else retval = 1;

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of TCP/IP Addresses
int CALLBACK CompareTcpAddress(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

    ExtServerInfo *ex1 = (ExtServerInfo*)((CServer*)lParam1)->GetExtendedInfo();
    ExtServerInfo *ex2 = (ExtServerInfo*)((CServer*)lParam2)->GetExtendedInfo();

    if(!ex1 && !ex2) retval = 0;
    else if(ex1 && !ex2) retval = 1;
    else if(!ex1 && ex2) retval = -1;
    else {
	    ULONG tcp1 = ex1->RawTcpAddress;
	    ULONG tcp2 = ex2->RawTcpAddress;

	    if(tcp1 == tcp2) retval = 0;
	    else if(tcp1 < tcp2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Module dates
int CALLBACK CompareModuleDate(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	// Compare the dates first
	USHORT date1 = ((ExtModuleInfo*)lParam1)->Date;
	USHORT date2 = ((ExtModuleInfo*)lParam2)->Date;

	if(date1 < date2) retval = -1;
	else if(date1 > date2) retval = 1;
	// Dates are the same, compare the times
    else {
	    USHORT time1 = ((ExtModuleInfo*)lParam1)->Time;
	    USHORT time2 = ((ExtModuleInfo*)lParam2)->Time;
	    if(time1 == time2) retval = 0;
	    else if(time1 < time2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// Compare function for columns of Module versions
int CALLBACK CompareModuleVersions(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    int retval = 0;

	if(!lParam1 || !lParam2) return 0;

	// Compare the low versions first
	BYTE lowversion1 = ((ExtModuleInfo*)lParam1)->LowVersion;
	BYTE lowversion2 = ((ExtModuleInfo*)lParam2)->LowVersion;

	if(lowversion1 < lowversion2) retval = -1;
	else if(lowversion1 > lowversion2) retval = 1;
	// Low versions are the same, compare high version
    else {
	    BYTE highversion1 = ((ExtModuleInfo*)lParam1)->HighVersion;
	    BYTE highversion2 = ((ExtModuleInfo*)lParam2)->HighVersion;
	    if(highversion1 == highversion2) retval = 0;
	    else if(highversion1 < highversion2) retval = -1;
	    else retval = 1;
    }

    return(lParamSort ? retval : -retval);
}


// SortTextItems	- Sort the list based on column text
// Returns		- Returns true for success
// nCol			- column that contains the text to be sorted
// bAscending		- indicate sort order
// low			- row to start scanning from - default row is 0
// high			- row to end scan. -1 indicates last row
BOOL SortTextItems( CListCtrl *pList, int nCol, BOOL bAscending,
					int low /*= 0*/, int high /*= -1*/ ){
	if( nCol >= ((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount() )		
		return FALSE;

	if( high == -1 ) high = pList->GetItemCount() - 1;	

	int lo = low;	
	int hi = high;
	CString midItem;
	
	if( hi <= lo ) return FALSE;

	midItem = pList->GetItemText( (lo+hi)/2, nCol );

	// loop through the list until indices cross	
	while( lo <= hi )	{

		// rowText will hold all column text for one row		
		CStringArray rowText;

		// find the first element that is greater than or equal to
		// the partition element starting from the left Index.		
		if( bAscending )
			while( ( lo < high ) && ( pList->GetItemText(lo, nCol) < midItem ) )				
				++lo;		
		else
			while( ( lo < high ) && ( pList->GetItemText(lo, nCol) > midItem ) )				
				++lo;

		// find an element that is smaller than or equal to
		// the partition element starting from the right Index.		
		if( bAscending )
			while( ( hi > low ) && ( pList->GetItemText(hi, nCol) > midItem ) )
				--hi;		
		else
			while( ( hi > low ) && ( pList->GetItemText(hi, nCol) < midItem ) )				
				--hi;

		// if the indexes have not crossed, swap		
		// and if the items are not equal
		if( lo <= hi )		
		{			
			// swap only if the items are not equal
			if( pList->GetItemText(lo, nCol) != pList->GetItemText(hi, nCol))
			{				
				// swap the rows
				LV_ITEM lvitemlo, lvitemhi;				
				int nColCount =
					((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount();
				rowText.SetSize( nColCount );				
				
				int i;				
				for( i=0; i<nColCount; i++)
					rowText[i] = pList->GetItemText(lo, i);
				lvitemlo.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
				lvitemlo.iItem = lo;				
				lvitemlo.iSubItem = 0;
				lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED |
					LVIS_FOCUSED | LVIS_SELECTED |
					LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;
				
				lvitemhi = lvitemlo;
				lvitemhi.iItem = hi;				

				pList->GetItem( &lvitemlo );				
				pList->GetItem( &lvitemhi );

				for( i=0; i<nColCount; i++)					
					pList->SetItemText(lo, i, pList->GetItemText(hi, i));

				lvitemhi.iItem = lo;				
				pList->SetItem( &lvitemhi );				
				
				for( i=0; i<nColCount; i++)
					pList->SetItemText(hi, i, rowText[i]);				
				
				lvitemlo.iItem = hi;
				pList->SetItem( &lvitemlo );			
			}			
			
			++lo;			
			--hi;		
		}	
	}

	// If the right index has not reached the left side of array
	// must now sort the left partition.	
	if( low < hi )
		SortTextItems( pList, nCol, bAscending , low, hi);

	// If the left index has not reached the right side of array
	// must now sort the right partition.	
	if( lo < high )
		SortTextItems( pList, nCol, bAscending , lo, high );	

	return TRUE;
}


long myatol(CString sTemp)
{

    return((long)wcstoul(sTemp.GetBuffer(0), NULL, 10));
}


BOOL SortNumericItems( CListCtrl *pList, int nCol, BOOL bAscending,long low, long high)
{	
	if( nCol >= ((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount() )		
		return FALSE;	

	if( high == -1 ) high = pList->GetItemCount() - 1;	
	long lo = low;
    long hi = high;

	long midItem;		

	if( hi <= lo ) return FALSE;	

	midItem = myatol(pList->GetItemText( (lo+hi)/2, nCol ));
	
	// loop through the list until indices cross	
	while( lo <= hi )	
	{ 
		// rowText will hold all column text for one row		
		CStringArray rowText;

		// find the first element that is greater than or equal to 
		// the partition element starting from the left Index.		
		if( bAscending )
			while( ( lo < high ) && (myatol(pList->GetItemText(lo, nCol)) < midItem ) )
				++lo;           		
		else
			while( ( lo < high ) && (myatol(pList->GetItemText(lo, nCol)) > midItem ) )				
				++lo;
                
		// find an element that is smaller than or equal to 
		// the partition element starting from the right Index.		
		if( bAscending )
			while( ( hi > low ) && (myatol(pList->GetItemText(hi, nCol)) > midItem ) )
				--hi;           		
		else
			while( ( hi > low ) && (myatol(pList->GetItemText(hi, nCol)) < midItem ) )				
				--hi;
				
		// if the indexes have not crossed, swap                
		// and if the items are not equal		
		if( lo <= hi )		
		{
			// swap only if the items are not equal
			if(myatol(pList->GetItemText(lo, nCol)) != myatol(pList->GetItemText(hi, nCol)) )
			{                               				
				// swap the rows
				LV_ITEM lvitemlo, lvitemhi;                				
				int nColCount =
					((CHeaderCtrl*)pList->GetDlgItem(0))->GetItemCount();

				rowText.SetSize( nColCount );

				int i;
				for( i=0; i < nColCount; i++)							
					rowText[i] = pList->GetItemText(lo, i);

                lvitemlo.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
				lvitemlo.iItem = lo;				
				lvitemlo.iSubItem = 0;
				lvitemlo.stateMask = LVIS_CUT | LVIS_DROPHILITED |
							LVIS_FOCUSED |  LVIS_SELECTED |
							LVIS_OVERLAYMASK | LVIS_STATEIMAGEMASK;
				lvitemhi = lvitemlo;
				lvitemhi.iItem = hi;
				
				pList->GetItem( &lvitemlo );
				pList->GetItem( &lvitemhi );

				for( i=0; i< nColCount; i++)
					pList->SetItemText(lo, i, pList->GetItemText(hi, i) );

				lvitemhi.iItem = lo;				
				pList->SetItem( &lvitemhi );

				for( i=0; i< nColCount; i++)							
					pList->SetItemText(hi, i, rowText[i]);

                lvitemlo.iItem = hi;				
				pList->SetItem( &lvitemlo );			
			}						
			
			++lo;
			--hi;
		}
	}		
	
	// If the right index has not reached the left side of array
	// must now sort the left partition.	
	if( low < hi )
		SortNumericItems( pList, nCol, bAscending , low, hi);

	// If the left index has not reached the right side of array
	// must now sort the right partition.	
	if( lo < high )
		SortNumericItems( pList, nCol, bAscending , lo, high );		

	return TRUE;
}


// Our lookup table has structures of this type
typedef struct _ColumnLookup {
   int View;         // The view the page is in
	int Page;			// Page that needs to be sorted
	int ColumnNumber;	// Column that need to be sorted
	int (CALLBACK *CompareFunc)(LPARAM,LPARAM,LPARAM); // Callback to send to CListCtrl.SortItems
} ColumnLookup;


// This table only includes structures for columns that aren't sorted
// using the SortTextItems() function
// NULL for the CompareFunc means that SortNumericItems() should be called
ColumnLookup ColumnTable[] = {
	// Server User's Page - CWinStation
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_ID, NULL },
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_SERVER, PAGE_USERS, USERS_COL_LOGONTIME, CompareLogonTime },
	// Server WinStation's Page - CWinStation
//	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_ID, NULL },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_SERVER, PAGE_WINSTATIONS, WS_COL_LOGONTIME, CompareLogonTime },
	// Server Processes' columns - CProcess
	{ VIEW_SERVER, PAGE_PROCESSES, PROC_COL_ID, NULL },
    { VIEW_SERVER, PAGE_PROCESSES, PROC_COL_PID, NULL },
	// Server Info (Hotfix) columns - CHotfix
	{ VIEW_SERVER, PAGE_INFO, HOTFIX_COL_INSTALLEDON, NULL },
	// WinStation Processes' columns - CProcess
	{ VIEW_WINSTATION, PAGE_WS_PROCESSES, WS_PROC_COL_ID, NULL },
	{ VIEW_WINSTATION, PAGE_WS_PROCESSES, WS_PROC_COL_PID, NULL },
	// WinStation Modules columns - CModule
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_FILEDATETIME, CompareModuleDate },
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_SIZE, NULL },
	{ VIEW_WINSTATION, PAGE_WS_MODULES, MODULES_COL_VERSIONS, CompareModuleVersions },
	// All Server Servers columns - CServer
	{ VIEW_ALL_SERVERS, PAGE_AS_SERVERS, SERVERS_COL_TCPADDRESS, CompareTcpAddress },
	{ VIEW_ALL_SERVERS, PAGE_AS_SERVERS, SERVERS_COL_NUMWINSTATIONS, NULL },
	// All Server Users columns - CWinStation
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_ALL_SERVERS, PAGE_AS_USERS, AS_USERS_COL_LOGONTIME, CompareLogonTime },
	// All Server WinStations columns - CWinStation
//	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_ALL_SERVERS, PAGE_AS_WINSTATIONS, AS_WS_COL_LOGONTIME, CompareLogonTime },
	// All Server Processes columns - CProcess
	{ VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, AS_PROC_COL_ID, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_PROCESSES, AS_PROC_COL_PID, NULL },
	// All Server Licenses columns - CLicense
	{ VIEW_ALL_SERVERS, PAGE_AS_LICENSES, AS_LICENSE_COL_USERCOUNT, NULL },
	{ VIEW_ALL_SERVERS, PAGE_AS_LICENSES, AS_LICENSE_COL_POOLCOUNT, NULL },
	// Domain Servers columns - CServer
	{ VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, SERVERS_COL_TCPADDRESS, CompareTcpAddress },
	{ VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, SERVERS_COL_NUMWINSTATIONS, NULL },
	// Domain Users columns - CWinStation
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_DOMAIN, PAGE_DOMAIN_USERS, AS_USERS_COL_LOGONTIME, CompareLogonTime },
	// Domain WinStations columns - CWinStation
//	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_WINSTATION, CompareWinStation },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_IDLETIME, CompareIdleTime },
	{ VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, AS_WS_COL_LOGONTIME, CompareLogonTime },
	// Domain Processes columns - CProcess
	{ VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, AS_PROC_COL_ID, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, AS_PROC_COL_PID, NULL },
	// Domain Licenses columns - CLicense
	{ VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, AS_LICENSE_COL_USERCOUNT, NULL },
	{ VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, AS_LICENSE_COL_POOLCOUNT, NULL },
};


/////////////////////////////////////////////////////////////////////////////
// SortByColumn
//
//	Page - page to be sorted
//	List - pointer to list control to call ->SortItems member function of
//	ColumnNumber - which column is to be sorted on
//  bAscending - TRUE if ascending, FALSE if descending
//
static int insort = 0;
void SortByColumn(int View, int Page, CListCtrl *List, int ColumnNumber, BOOL bAscending)
{
	if(insort) return;

	insort = 1;
	BOOL found = FALSE;

	// Look up the type of column from the ColumnNumber in our table
	int TableSize = sizeof(ColumnTable) / sizeof(ColumnLookup);

	for(int i = 0; i < TableSize; i++) {
		if(ColumnTable[i].View == View &&
			ColumnTable[i].Page == Page &&
			ColumnTable[i].ColumnNumber == ColumnNumber) {
				if(ColumnTable[i].CompareFunc)
					List->SortItems(ColumnTable[i].CompareFunc, bAscending);
				else
					SortNumericItems(List, ColumnNumber, bAscending, 0, -1);
				found = TRUE;
				break;
		}
	}

	if(!found) SortTextItems( List, ColumnNumber, bAscending, 0, -1);

	insort = 0;

}  // end SortByColumn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\bwinsvw.h ===
/*******************************************************************************
*
* bwinsvw.h
*
* declaration of the CBadWinStationView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\BWINSVW.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:22   butchd
*  Initial revision.
*
*******************************************************************************/

/////////////////////////////////////////////////////////////////////////////
// CBadWinStationView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CBadWinStationView : public CFormView
{
friend class CRightPane;

protected:
	CBadWinStationView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBadWinStationView)

// Form Data
public:
	//{{AFX_DATA(CBadWinStationView)
	enum { IDD = IDD_BAD_WINSTATION };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBadWinStationView)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBadWinStationView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CBadWinStationView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\blankvw.h ===
/*******************************************************************************
*
* blankvw.h
*
* - header for the CBlankView class
* - implementation can be found in blankvw.cpp
*
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\blankvw.h  $
*  
*     Rev 1.1   13 Oct 1997 18:40:04   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:08   butchd
*  Initial revision.
*
*******************************************************************************/

//////////////////////
// FILE: 
//
//
#ifndef _BLANKVIEW_H
#define _BLANKVIEW_H


//////////////////////
// CLASS: CBlankView
//
// - this class is just a utility view that i use to fill in
//   spaces until i write up better views for them, or to test
//   simple stuff (i.e print debugging info it the view)
//
class CBlankView : public CAdminView
{
friend class CRightPane;

protected:
	CBlankView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBlankView)

// Attributes
protected:
	
// Operations
protected:
	void Reset(void) { };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBlankView)
	protected:
	virtual void OnDraw(CDC* pDC);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBlankView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    LRESULT OnTabbed( WPARAM , LPARAM ) 
    {return 0;}
	// Generated message map functions
protected:
	//{{AFX_MSG(CBlankView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CBlankView

#endif  // _BLANKVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\dialogs.h ===
/*******************************************************************************
*
* dialogs.h
*
* declarations of all the dialog classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\dialogs.h  $
*  
*     Rev 1.3   19 Jan 1998 16:46:10   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.2   13 Oct 1997 18:40:20   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:14:28   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:11:32   butchd
*  Initial revision.
*
*******************************************************************************/

#include "threads.h"
#include "led.h"

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg dialog

class CSendMessageDlg : public CDialog
{
// Construction
public:
	CSendMessageDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSendMessageDlg)
	enum { IDD = IDD_MESSAGE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

    TCHAR m_szUserName[USERNAME_LENGTH+1];
    TCHAR m_szTitle[MSG_TITLE_LENGTH+1];
    TCHAR m_szMessage[MSG_MESSAGE_LENGTH+1];

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSendMessageDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSendMessageDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg dialog

class CShadowStartDlg : public CDialog
{
// Construction
public:
	CShadowStartDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CShadowStartDlg)
	enum { IDD = IDD_SHADOWSTART };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	DWORD m_ShadowHotkeyShift;
	int m_ShadowHotkeyKey;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CShadowStartDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CShadowStartDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnSelChange( );
	afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog

typedef enum _PwdMode {
	PwdDlg_UserMode,
	PwdDlg_WinStationMode
} PwdMode;

class CPasswordDlg : public CDialog
{
// Construction
public:
	CPasswordDlg(CWnd* pParent = NULL);   // standard constructor
	LPCTSTR GetPassword() { return m_szPassword; }
	void SetDialogMode(PwdMode mode) { m_DlgMode = mode; }

// Dialog Data
	//{{AFX_DATA(CPasswordDlg)
	enum { IDD = IDD_CONNECT_PASSWORD };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPasswordDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	PwdMode m_DlgMode;
	TCHAR m_szPassword[PASSWORD_LENGTH+1];

	// Generated message map functions
	//{{AFX_MSG(CPasswordDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog
const int MAX_AUTOREFRESH_DIGITS = 5;
const int MIN_AUTOREFRESH_VALUE = 1;
const int MAX_AUTOREFRESH_VALUE = 9999;

class CPreferencesDlg : public CDialog
{
// Construction
public:
	CPreferencesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPreferencesDlg)
	enum { IDD = IDD_PREFERENCES };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPreferencesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

private:

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPreferencesDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	afx_msg void OnPreferencesProcManual();
	afx_msg void OnPreferencesProcEvery();
	afx_msg void OnPreferencesStatusEvery();
	afx_msg void OnPreferencesStatusManual();
	afx_msg void OnClose();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog

class CStatusDlg : public CDialog
{
// Construction
public:
	CStatusDlg(CWinStation *pWinStation, UINT Id, CWnd* pParent = NULL);   // standard constructor
	CWSStatusThread *m_pWSStatusThread;

protected:
	virtual void InitializeStatus();
    virtual void SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                                PWINSTATIONINFORMATION pNew );

	// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatusDlg)
	protected:
	virtual void PostNcDestroy();
	virtual BOOL PreTranslateMessage(MSG *pMsg);
	//}}AFX_VIRTUAL

// Implementation
protected:
	CWinStation *m_pWinStation;
//    ULONG m_LogonId;
    BOOL m_bReadOnly;
    WINSTATIONNAME m_WSName;
    SIZE m_LittleSize;
    SIZE m_BigSize;
    BOOL m_bWeAreLittle;
    BOOL m_bResetCounters;
    BOOL m_bReliable;
    WINSTATIONINFORMATION m_WSInfo;
    PROTOCOLSTATUS m_BaseStatus;
    UINT m_IBytesPerFrame;
    UINT m_OBytesPerFrame;
    TCHAR m_szIPercentFrameErrors[10];
    TCHAR m_szOPercentFrameErrors[10];
    TCHAR m_szICompressionRatio[10];
    TCHAR m_szOCompressionRatio[10];

	// Generated message map functions
	//{{AFX_MSG(CStatusDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
    afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
	afx_msg void OnResetcounters();
	afx_msg void OnClickedRefreshnow();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg dialog
#define NUM_LEDS    6
#define ASYNC_LED_TOGGLE_MSEC   200

class CAsyncStatusDlg : public CStatusDlg
{
// Construction
public:
	CAsyncStatusDlg(CWinStation *pWinStation, CWnd* pParent = NULL);   // standard constructor
	~CAsyncStatusDlg();

    HBRUSH m_hRedBrush;
    UINT_PTR m_LEDToggleTimer;
    CLed *  m_pLeds[NUM_LEDS];


// Dialog Data
	//{{AFX_DATA(CAsyncStatusDlg)
	enum { IDD = IDD_ASYNC_STATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAsyncStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                        PWINSTATIONINFORMATION pNew );
    void InitializeStatus();

	// Generated message map functions
	//{{AFX_MSG(CAsyncStatusDlg)
		afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
	    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
		afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
		afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
		afx_msg void OnResetcounters();
		afx_msg void OnClickedRefreshnow();
		afx_msg void OnMoreinfo();
	    afx_msg void OnTimer(UINT nIDEvent);
		afx_msg void OnNcDestroy();
		virtual BOOL OnInitDialog();
	    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
		afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg dialog

class CNetworkStatusDlg : public CStatusDlg
{
// Construction
public:
	CNetworkStatusDlg(CWinStation *pWinStation, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNetworkStatusDlg)
	enum { IDD = IDD_NETWORK_STATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNetworkStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNetworkStatusDlg)
	afx_msg LRESULT OnStatusStart(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnStatusAbort(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnRefreshNow(WPARAM wParam, LPARAM lParam);
	afx_msg void OnResetcounters();
	afx_msg void OnClickedRefreshnow();
	afx_msg void OnMoreinfo();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnCommandHelp(void);

	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMyDialog dialog

class CMyDialog : public CDialog
{
// Construction
public:
	CMyDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMyDialog)
	enum { IDD = IDD_DIALOG_FINDSERVER };
	CString	m_cstrServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMyDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\dialogs.cpp ===
/*******************************************************************************
*
* dialogs.cpp
*
* implementation of all dialog classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\dialogs.cpp  $
*  
*     Rev 1.7   25 Apr 1998 13:43:16   donm
*  MS 2167: try to use proper Wd from registry
*  
*     Rev 1.6   19 Jan 1998 16:46:08   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.5   03 Nov 1997 19:16:10   donm
*  removed redundant message to add server to views
*  
*     Rev 1.4   03 Nov 1997 15:24:16   donm
*  fixed AV in CServerFilterDialog
*  
*     Rev 1.3   22 Oct 1997 21:07:10   donm
*  update
*  
*     Rev 1.2   18 Oct 1997 18:50:10   donm
*  update
*  
*     Rev 1.1   13 Oct 1997 18:40:16   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:11:28   butchd
*  Initial revision.
*  
*******************************************************************************/


#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "admindoc.h"
#include "dialogs.h"
#include "..\..\inc\ansiuni.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg dialog


CSendMessageDlg::CSendMessageDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSendMessageDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSendMessageDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CSendMessageDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSendMessageDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSendMessageDlg, CDialog)
	//{{AFX_MSG_MAP(CSendMessageDlg)
	ON_WM_HELPINFO()
	ON_COMMAND(ID_HELP,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSendMessageDlg message handlers
void CSendMessageDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CSendMessageDlg::IDD + HID_BASE_RESOURCE);
	return;
}

BOOL CSendMessageDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
 
	// Form the default the message title.
    CString DefTitleString;
    TCHAR szTime[MAX_DATE_TIME_LENGTH];

    CurrentDateTimeString(szTime);
    DefTitleString.LoadString(IDS_DEFAULT_MESSAGE_TITLE);
    wsprintf(m_szTitle, DefTitleString, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName(), szTime);

    // Initialize the title edit control and set maximum length for title
    // and message.
    SetDlgItemText(IDC_MESSAGE_TITLE, m_szTitle);
    ((CEdit *)GetDlgItem(IDC_MESSAGE_TITLE))->LimitText(MSG_TITLE_LENGTH);
    ((CEdit *)GetDlgItem(IDC_MESSAGE_MESSAGE))->LimitText(MSG_MESSAGE_LENGTH);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSendMessageDlg::OnOK() 
{
	// TODO: Add extra validation here

    // Get the message title and message text.
    GetDlgItemText(IDC_MESSAGE_TITLE, m_szTitle, MSG_TITLE_LENGTH+1);
    GetDlgItemText(IDC_MESSAGE_MESSAGE, m_szMessage, MSG_MESSAGE_LENGTH+1);
	
	CDialog::OnOK();
}

BOOL CSendMessageDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
	    if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}
	return (TRUE);

}


/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg dialog


CShadowStartDlg::CShadowStartDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CShadowStartDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CShadowStartDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

////////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg static tables



struct {
    LPCTSTR String;
    DWORD VKCode;
} HotkeyLookupTable[] =
    {
        TEXT("0"),            '0',
        TEXT("1"),            '1',
        TEXT("2"),            '2',
        TEXT("3"),            '3',
        TEXT("4"),            '4',
        TEXT("5"),            '5',
        TEXT("6"),            '6',
        TEXT("7"),            '7',
        TEXT("8"),            '8',
        TEXT("9"),            '9',
        TEXT("A"),            'A',
        TEXT("B"),            'B',
        TEXT("C"),            'C',
        TEXT("D"),            'D',
        TEXT("E"),            'E',
        TEXT("F"),            'F',
        TEXT("G"),            'G',
        TEXT("H"),            'H',
        TEXT("I"),            'I',
        TEXT("J"),            'J',
        TEXT("K"),            'K',
        TEXT("L"),            'L',
        TEXT("M"),            'M',
        TEXT("N"),            'N',
        TEXT("O"),            'O',
        TEXT("P"),            'P',
        TEXT("Q"),            'Q',
        TEXT("R"),            'R',
        TEXT("S"),            'S',
        TEXT("T"),            'T',
        TEXT("U"),            'U',
        TEXT("V"),            'V',
        TEXT("W"),            'W',
        TEXT("X"),            'X',
        TEXT("Y"),            'Y',
        TEXT("Z"),            'Z',
        TEXT("{backspace}"),  VK_BACK,
        TEXT("{delete}"),     VK_DELETE,
        TEXT("{down}"),       VK_DOWN,
        TEXT("{end}"),        VK_END,
        TEXT("{enter}"),      VK_RETURN,
///        TEXT("{esc}"),        VK_ESCAPE,                           // KLB 07-16-95
///        TEXT("{F1}"),         VK_F1,
        TEXT("{F2}"),         VK_F2,
        TEXT("{F3}"),         VK_F3,
        TEXT("{F4}"),         VK_F4,
        TEXT("{F5}"),         VK_F5,
        TEXT("{F6}"),         VK_F6,
        TEXT("{F7}"),         VK_F7,
        TEXT("{F8}"),         VK_F8,
        TEXT("{F9}"),         VK_F9,
        TEXT("{F10}"),        VK_F10,
        TEXT("{F11}"),        VK_F11,
        TEXT("{F12}"),        VK_F12,
        TEXT("{home}"),       VK_HOME,
        TEXT("{insert}"),     VK_INSERT,
        TEXT("{left}"),       VK_LEFT,
        TEXT("{-}"),          VK_SUBTRACT,
        TEXT("{pagedown}"),   VK_NEXT,
        TEXT("{pageup}"),     VK_PRIOR,
        TEXT("{+}"),          VK_ADD,
        TEXT("{prtscrn}"),    VK_SNAPSHOT,
        TEXT("{right}"),      VK_RIGHT,
        TEXT("{spacebar}"),   VK_SPACE,
        TEXT("{*}"),          VK_MULTIPLY,
        TEXT("{tab}"),        VK_TAB,
        TEXT("{up}"),         VK_UP,
        NULL,           NULL
    };


void CShadowStartDlg::OnSelChange( )
{/*
*/
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Get the current hotkey selection.
    DWORD dwKey = ( DWORD )pComboBox->GetItemData(pComboBox->GetCurSel());

    switch (dwKey )
    {
    case VK_ADD :
    case VK_MULTIPLY:
    case VK_SUBTRACT:
        // change the text
        GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_SHOW);
        break;
    default :
        // change the text
        GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_SHOW);
        break;
    }
}
void CShadowStartDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CShadowStartDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CShadowStartDlg, CDialog)
	//{{AFX_MSG_MAP(CShadowStartDlg)
	ON_WM_HELPINFO()
    ON_CBN_SELCHANGE( IDC_SHADOWSTART_HOTKEY , OnSelChange )
	ON_COMMAND(ID_HELP,OnCommandHelp)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CShadowStartDlg message handlers
void CShadowStartDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CShadowStartDlg::IDD + HID_BASE_RESOURCE);
	return;
}

BOOL CShadowStartDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

   	GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_HIDE);
   	GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_SHOW);

	// TODO: Add extra initialization here
    int index, match = -1;
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Initialize the hotkey combo box.
    for(int i=0; HotkeyLookupTable[i].String; i++ ) {
        if((index = pComboBox->AddString(HotkeyLookupTable[i].String)) < 0) {
//            ErrorMessage(IDP_ERROR_STARTSHADOWHOTKEYBOX);
            break;
        }
        if(pComboBox->SetItemData(index, HotkeyLookupTable[i].VKCode) < 0) {
            pComboBox->DeleteString(index);
//            ErrorMessage(IDP_ERROR_STARTSHADOWHOTKEYBOX);
            break;
        }

        //  If this is our current hotkey key, save it's index.
        if(m_ShadowHotkeyKey == (int)HotkeyLookupTable[i].VKCode) {
            match = index;
            switch ( HotkeyLookupTable[i].VKCode)
            {
            case VK_ADD :
            case VK_MULTIPLY:
            case VK_SUBTRACT:
                // change the text
               	GetDlgItem(IDC_PRESS_KEY)->ShowWindow(SW_HIDE);
               	GetDlgItem(IDC_PRESS_NUMKEYPAD)->ShowWindow(SW_SHOW);
                break;
            }
        }

    }

    // Select the current hotkey string in the combo box.
    if(match)
        pComboBox->SetCurSel(match);

    // Initialize shift state checkboxes.
    CheckDlgButton( IDC_SHADOWSTART_SHIFT,
					(m_ShadowHotkeyShift & KBDSHIFT) ?
                        TRUE : FALSE );
    CheckDlgButton( IDC_SHADOWSTART_CTRL,
                    (m_ShadowHotkeyShift & KBDCTRL) ?
                        TRUE : FALSE );
    CheckDlgButton( IDC_SHADOWSTART_ALT,
                    (m_ShadowHotkeyShift & KBDALT) ?
                        TRUE : FALSE );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CShadowStartDlg::OnOK() 
{
	// TODO: Add extra validation here
    CComboBox *pComboBox = ((CComboBox *)GetDlgItem(IDC_SHADOWSTART_HOTKEY));

    // Get the current hotkey selection.
    m_ShadowHotkeyKey = (int)pComboBox->GetItemData(pComboBox->GetCurSel());

	// Get shift state checkbox states and form hotkey shift state.
    m_ShadowHotkeyShift = 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_SHIFT))->GetCheck() ?
            KBDSHIFT : 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_CTRL))->GetCheck() ?
            KBDCTRL : 0;
    m_ShadowHotkeyShift |=
        ((CButton *)GetDlgItem(IDC_SHADOWSTART_ALT))->GetCheck() ?
            KBDALT : 0;
	
	CDialog::OnOK();
}


BOOL CShadowStartDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);
	
}


/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg dialog


CPasswordDlg::CPasswordDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPasswordDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPasswordDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPasswordDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPasswordDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPasswordDlg, CDialog)
	//{{AFX_MSG_MAP(CPasswordDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPasswordDlg message handlers

BOOL CPasswordDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	CString Prompt;

    Prompt.LoadString((m_DlgMode == PwdDlg_UserMode) ?
                            IDS_PWDDLG_USER : IDS_PWDDLG_WINSTATION );
    SetDlgItemText(IDL_CPDLG_PROMPT, Prompt);
    ((CEdit *)GetDlgItem(IDC_CPDLG_PASSWORD))->LimitText(PASSWORD_LENGTH);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPasswordDlg::OnOK() 
{
	// TODO: Add extra validation here
	// Read password.
    GetDlgItemText(IDC_CPDLG_PASSWORD, m_szPassword, PASSWORD_LENGTH+1);
	CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg dialog

CPreferencesDlg::CPreferencesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPreferencesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPreferencesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPreferencesDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPreferencesDlg, CDialog)
	//{{AFX_MSG_MAP(CPreferencesDlg)
	ON_BN_CLICKED(IDC_PREFERENCES_PROC_MANUAL, OnPreferencesProcManual)
	ON_BN_CLICKED(IDC_PREFERENCES_PROC_EVERY, OnPreferencesProcEvery)
	ON_BN_CLICKED(IDC_PREFERENCES_STATUS_EVERY, OnPreferencesStatusEvery)
	ON_BN_CLICKED(IDC_PREFERENCES_STATUS_MANUAL, OnPreferencesStatusManual)
	ON_WM_CLOSE()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreferencesDlg message handlers


BOOL CPreferencesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	// TODO: Add extra initialization here
	CWinAdminApp *App = (CWinAdminApp*)AfxGetApp();
    CWinAdminDoc *pDoc = (CWinAdminDoc*)App->GetDocument();

	if(App->GetProcessListRefreshTime() == INFINITE) {
		CheckRadioButton(IDC_PREFERENCES_PROC_MANUAL, IDC_PREFERENCES_PROC_EVERY, 
			IDC_PREFERENCES_PROC_MANUAL);
		SetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS, 5);
	} else {
		CheckRadioButton(IDC_PREFERENCES_PROC_MANUAL, IDC_PREFERENCES_PROC_EVERY,
			IDC_PREFERENCES_PROC_EVERY);
		SetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS, App->GetProcessListRefreshTime()/1000);
	}

	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow((App->GetProcessListRefreshTime() == INFINITE) ? FALSE : TRUE);
	((CEdit *)GetDlgItem(IDC_PREFERENCES_PROC_SECONDS))->LimitText(MAX_AUTOREFRESH_DIGITS-1);
	((CSpinButtonCtrl*)GetDlgItem(IDC_PREFERENCES_PROC_SPIN))->SetRange(MIN_AUTOREFRESH_VALUE, MAX_AUTOREFRESH_VALUE);

	if(App->GetStatusRefreshTime() == INFINITE) {
		CheckRadioButton(IDC_PREFERENCES_STATUS_MANUAL, IDC_PREFERENCES_STATUS_EVERY, 
			IDC_PREFERENCES_STATUS_MANUAL);
		SetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS, 1);	
	} else {
		CheckRadioButton(IDC_PREFERENCES_STATUS_MANUAL, IDC_PREFERENCES_STATUS_EVERY,
			IDC_PREFERENCES_STATUS_EVERY);
		SetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS, App->GetStatusRefreshTime()/1000);
	}

	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow((App->GetStatusRefreshTime() == INFINITE) ? FALSE : TRUE);
	((CEdit *)GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS))->LimitText(MAX_AUTOREFRESH_DIGITS-1);
	((CSpinButtonCtrl*)GetDlgItem(IDC_PREFERENCES_STATUS_SPIN))->SetRange(MIN_AUTOREFRESH_VALUE, MAX_AUTOREFRESH_VALUE);

	CheckDlgButton(IDC_PREFERENCES_CONFIRM, App->AskConfirmation() ? TRUE : FALSE);
    CheckDlgButton(IDC_PREFERENCES_SAVE, App->SavePreferences() ? TRUE : FALSE);
    CheckDlgButton(IDC_PREFERENCES_PERSISTENT, pDoc->AreConnectionsPersistent() ? TRUE : FALSE);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CPreferencesDlg::OnOK() 
{
	// TODO: Add extra validation here
	CWinAdminApp *App = (CWinAdminApp*)AfxGetApp();
    CWinAdminDoc *pDoc = (CWinAdminDoc*)App->GetDocument();

	ULONG value;

	if(((CButton*)GetDlgItem(IDC_PREFERENCES_PROC_MANUAL))->GetCheck()) {
		App->SetProcessListRefreshTime(INFINITE);
		// Tell the document that it has changed so
		// that he can wakeup the process thread
		((CWinAdminDoc*)App->GetDocument())->ProcessListRefreshChanged(INFINITE);
	} else {
		value = GetDlgItemInt(IDC_PREFERENCES_PROC_SECONDS);

		if((value < MIN_AUTOREFRESH_VALUE) || (value > MAX_AUTOREFRESH_VALUE)) {
			// Invalid automatic refresh value
			CString MessageString;
			CString TitleString;
			CString FormatString;
	
			TitleString.LoadString(AFX_IDS_APP_TITLE);
			FormatString.LoadString(IDS_REFRESH_RANGE);
			
			MessageString.Format(FormatString, MIN_AUTOREFRESH_VALUE,
					MAX_AUTOREFRESH_VALUE);
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);

            GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->SetFocus();
            return;
        } else {
			// Has the value changed
			BOOL bChanged = FALSE;
			if(value*1000 != App->GetProcessListRefreshTime())
				bChanged = TRUE;
            //Save value in member variable as msec.
            App->SetProcessListRefreshTime(value * 1000);
			// Tell the document that it has changed so
			// that he can wakeup the process thread
			if(bChanged) {
				((CWinAdminDoc*)App->GetDocument())->ProcessListRefreshChanged(value * 1000);
			}
        }
	}

	if(((CButton*)GetDlgItem(IDC_PREFERENCES_STATUS_MANUAL))->GetCheck()) {
		App->SetStatusRefreshTime(INFINITE);
	} else {
		value = GetDlgItemInt(IDC_PREFERENCES_STATUS_SECONDS);

		if((value < MIN_AUTOREFRESH_VALUE) || (value > MAX_AUTOREFRESH_VALUE)) {
			// Invalid automatic refresh value
			CString MessageString;
			CString TitleString;
			CString FormatString;
	
			TitleString.LoadString(AFX_IDS_APP_TITLE);
			FormatString.LoadString(IDS_REFRESH_RANGE);
			
			MessageString.Format(FormatString, MIN_AUTOREFRESH_VALUE,
					MAX_AUTOREFRESH_VALUE);
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);

            GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->SetFocus();
            return;
        } else {
            //Save value in member variable as msec.
            App->SetStatusRefreshTime(value * 1000);
        }
	}

    App->SetConfirmation(((CButton *)GetDlgItem(IDC_PREFERENCES_CONFIRM))->GetCheck());
    App->SetSavePreferences(((CButton *)GetDlgItem(IDC_PREFERENCES_SAVE))->GetCheck());
    pDoc->SetConnectionsPersistent(((CButton *)GetDlgItem(IDC_PREFERENCES_PERSISTENT))->GetCheck());

	CDialog::OnOK();
}


void CPreferencesDlg::OnClose() 
{
	// TODO: Add your message handler code here and/or call default
	
	CDialog::OnClose();
}


void CPreferencesDlg::OnPreferencesProcManual() 
{	
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow(FALSE);
}


void CPreferencesDlg::OnPreferencesProcEvery() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_PROC_SECONDS)->EnableWindow(TRUE);
}


void CPreferencesDlg::OnPreferencesStatusEvery() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow(TRUE);
}


void CPreferencesDlg::OnPreferencesStatusManual() 
{
	// TODO: Add your control notification handler code here
	GetDlgItem(IDC_PREFERENCES_STATUS_SECONDS)->EnableWindow(FALSE);	
}


BOOL CPreferencesDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);	

}


/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog


CStatusDlg::CStatusDlg(CWinStation *pWinStation, UINT Id, CWnd* pParent /*=NULL*/)
	: CDialog(Id, pParent)
{
	m_pWinStation = pWinStation;
	//{{AFX_DATA_INIT(CStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


BEGIN_MESSAGE_MAP(CStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CStatusDlg)
	ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
    ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
    ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
    ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
	ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
	ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg message handlers

BOOL CStatusDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

    /*
     * Fetch current (big) size of dialog, then calculate the window size
     * needed to show the 'little' version of the dialog.  Then, size the
     * window to the little version size and set the size flag to indicate
     * that we're 'little'.
     */
	RECT rectBigSize, rectLittleSize;

    GetWindowRect(&rectBigSize);
    m_BigSize.cx = (rectBigSize.right - rectBigSize.left) + 1;
    m_BigSize.cy = (rectBigSize.bottom - rectBigSize.top) + 1;

	// Some status dialogs don't have "More Info"
    CWnd *pWnd = GetDlgItem(IDC_MOREINFO);
	if(pWnd) {
		pWnd->GetWindowRect(&rectLittleSize);

	    m_LittleSize.cx = m_BigSize.cx;
		m_LittleSize.cy = (rectLittleSize.bottom - rectBigSize.top) + 10;

		SetWindowPos( NULL, 0, 0, m_LittleSize.cx, m_LittleSize.cy,
			          SWP_NOMOVE | SWP_NOZORDER );
		m_bWeAreLittle = TRUE;
	}

#if 0
    /*
     * Disable the 'reset counters' button if we're read-only, and set the
     * 'reset counters' flag to FALSE;
     */
    if ( m_bReadOnly )
        GetDlgItem(IDC_RESETCOUNTERS)->EnableWindow(FALSE);
    
#endif
    /*
     * Create CWSStatusThread, intialize its member variables, and start it up.
     */
	m_pWSStatusThread = new CWSStatusThread;
    if(m_pWSStatusThread) {
	    m_pWSStatusThread->m_LogonId = m_pWinStation->GetLogonId();
	    m_pWSStatusThread->m_hServer = m_pWinStation->GetServer()->GetHandle();
	    m_pWSStatusThread->m_hDlg = m_hWnd;
	    VERIFY(m_pWSStatusThread->CreateThread());
    }

    m_bResetCounters = FALSE;

	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS2)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS2)->ShowWindow(SW_HIDE);

    // If we don't have Reliable Pd loaded, default error fields to 'N/A'
    // (m_szICompressionRatio got initialized to the 'n/a' string)...
    if(!m_bReliable) {
        SetDlgItemText(IDC_COMMON_IFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_IPERCENTFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OPERCENTFRAMEERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_ITIMEOUTERRORS, m_szICompressionRatio);
        SetDlgItemText(IDC_COMMON_OTIMEOUTERRORS, m_szICompressionRatio);
    }

    // Default the Compression Ratio fields to 'N/A'.
    SetDlgItemText(IDC_COMMON_ICOMPRESSIONRATIO, m_szICompressionRatio);
    SetDlgItemText(IDC_COMMON_OCOMPRESSIONRATIO, m_szICompressionRatio);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CStatusDlg::SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                             PWINSTATIONINFORMATION pNew )
{
    /*
     * If the 'reset counters' flag is set, 1-fill the current Input and Output
     * PROTOCOLCOUNTERS structures (to force all fields to update), copy the
     * pNew PROTOCOLSTATUS information into the global m_BaseStatus structure,
     * and reset the flag.
     */
    if(m_bResetCounters) {
        memset(&pCurrent->Status.Input, 0xff, sizeof(pCurrent->Status.Input));
        memset(&pCurrent->Status.Output, 0xff, sizeof(pCurrent->Status.Output));
        m_BaseStatus = pNew->Status;
        m_bResetCounters = FALSE;
    }

    /*
     * Set title and determine Pds loaded if change in connect state.
     */
    if(pCurrent->ConnectState != pNew->ConnectState)  {
        TCHAR szTitle[128];
        CString TitleFormat;
        LPCTSTR pState = NULL;

        TitleFormat.LoadString(IDS_STATUS_FORMAT);

        pState = StrConnectState( pNew->ConnectState, FALSE );
        if(pState)
        {
            wsprintf( szTitle, TitleFormat, pNew->LogonId,pState);
            SetWindowText(szTitle);
        }  

        /*
         * TODO when WinStationGetInformation can return all PDs loaded:
         * Determine Pds that are loaded and set the state of
         * associated flags and field defaults.
         */
    }

    /*
     * Set UserName and WinStationName if change.  We will also
     * set the WinStationName if there was a change in the connect state,
     * even if the WinStationName itself may not have changed, since we
     * represent connected and disconnect WinStationName fields differently.
     */
    if(lstrcmp(pCurrent->UserName, pNew->UserName))
        SetDlgItemText(IDC_COMMON_USERNAME, pNew->UserName);

    if(lstrcmp(pCurrent->WinStationName, pNew->WinStationName) ||
         (pCurrent->ConnectState != pNew->ConnectState)) {

        TCHAR szWSName[WINSTATIONNAME_LENGTH+3];

        if(pNew->ConnectState == State_Disconnected) {

            lstrcpy( szWSName, TEXT("(") );
            lstrcat( szWSName, pNew->WinStationName );
            lstrcat( szWSName, TEXT(")") );

        } else
            lstrcpy( szWSName, pNew->WinStationName );

        SetDlgItemText(IDC_COMMON_WINSTATIONNAME, szWSName);
    }

    /*
     * Set the common Input and Output numeric fields.
     */
    if(pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes)
        SetDlgItemInt(IDC_COMMON_IBYTES,
                                pNew->Status.Input.Bytes -
                                    m_BaseStatus.Input.Bytes,
                                FALSE);
    if(pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes)
        SetDlgItemInt(IDC_COMMON_OBYTES,
                                pNew->Status.Output.Bytes -
                                    m_BaseStatus.Output.Bytes,
                                FALSE);

    if(pCurrent->Status.Input.Frames != pNew->Status.Input.Frames)
        SetDlgItemInt(IDC_COMMON_IFRAMES,
                                pNew->Status.Input.Frames -
                                    m_BaseStatus.Input.Frames,
                                FALSE);
    if(pCurrent->Status.Output.Frames != pNew->Status.Output.Frames)
        SetDlgItemInt(IDC_COMMON_OFRAMES,
                                pNew->Status.Output.Frames -
                                    m_BaseStatus.Output.Frames,
                                FALSE);

    if((pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes) ||
         (pCurrent->Status.Input.Frames != pNew->Status.Input.Frames)) {

        UINT temp;

        temp = (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames) ?
                ((pNew->Status.Input.Bytes - m_BaseStatus.Input.Bytes) /
                 (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames)) : 0;

        if(temp != m_IBytesPerFrame)
            SetDlgItemInt(IDC_COMMON_IBYTESPERFRAME,
                                    m_IBytesPerFrame = temp, FALSE);
    }
    if((pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes) ||
         (pCurrent->Status.Output.Frames != pNew->Status.Output.Frames)) {

        UINT temp;

        temp = (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames) ?
                ((pNew->Status.Output.Bytes - m_BaseStatus.Output.Bytes) /
                 (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames)) : 0;

        if(temp != m_OBytesPerFrame)
            SetDlgItemInt( IDC_COMMON_OBYTESPERFRAME,
                                    m_OBytesPerFrame = temp, FALSE);
    }

    if(m_bReliable) {

        if(pCurrent->Status.Input.Errors != pNew->Status.Input.Errors)
            SetDlgItemInt(IDC_COMMON_IFRAMEERRORS,
                                    pNew->Status.Input.Errors -
                                        m_BaseStatus.Input.Errors,
                                    FALSE);
        if(pCurrent->Status.Output.Errors != pNew->Status.Output.Errors)
            SetDlgItemInt(IDC_COMMON_OFRAMEERRORS,
                                    pNew->Status.Output.Errors -
                                        m_BaseStatus.Output.Errors,
                                    FALSE);

        if((pCurrent->Status.Input.Frames != pNew->Status.Input.Frames) ||
             (pCurrent->Status.Input.Errors != pNew->Status.Input.Errors)) {

            TCHAR szTemp[10];
            int q, r;

            if((pNew->Status.Input.Errors - m_BaseStatus.Input.Errors) &&
                 (pNew->Status.Input.Frames - m_BaseStatus.Input.Frames)) {
                double temp;

                temp = ((double)(pNew->Status.Input.Errors - m_BaseStatus.Input.Errors) * 100.0)
                        / (double)(pNew->Status.Input.Frames - m_BaseStatus.Input.Frames);
                q = (int)temp;
                if ( (r = (int)((temp - (double)q) * 100.0)) == 0 )
                    r = 1;

            } else {
                /*
                 * Special case for 0 frames or 0 errors.
                 */
                q = 0;
                r = 0;
            }
            lstrnprintf(szTemp, 10, TEXT("%d.%02d%%"), q, r);

            /*
             * Only output if changed from previous.
             */
            if(lstrcmp(szTemp, m_szIPercentFrameErrors)) {
                lstrcpy(m_szIPercentFrameErrors, szTemp);
        		GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS)->ShowWindow(SW_HIDE);
        		GetDlgItem(IDC_COMMON_IPERCENTFRAMEERRORS2)->ShowWindow(SW_SHOW);
                SetDlgItemText(IDC_COMMON_IPERCENTFRAMEERRORS2, szTemp);
            }
        }

        if((pCurrent->Status.Output.Frames != pNew->Status.Output.Frames) ||
             (pCurrent->Status.Output.Errors != pNew->Status.Output.Errors)) {

            TCHAR szTemp[10];
            int q, r;

            if((pNew->Status.Output.Errors - m_BaseStatus.Output.Errors) &&
                 (pNew->Status.Output.Frames - m_BaseStatus.Output.Frames)) {
                double temp;

                temp = ((double)(pNew->Status.Output.Errors - m_BaseStatus.Output.Errors) * 100.0)
                        / (double)(pNew->Status.Output.Frames - m_BaseStatus.Output.Frames);
                q = (int)temp;
                if ( (r = (int)((temp - (double)q) * 100.0)) == 0 )
                    r = 1;

            } else {
                /*
                 * Special case for 0 frames or 0 errors.
                 */
                q = 0;
                r = 0;
            }
            lstrnprintf(szTemp, 10, TEXT("%d.%02d%%"), q, r);

            /*
             * Only output if changed from previous.
             */
            if(lstrcmp(szTemp, m_szOPercentFrameErrors)) {
                lstrcpy(m_szOPercentFrameErrors, szTemp);
        		GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS)->ShowWindow(SW_HIDE);
        		GetDlgItem(IDC_COMMON_OPERCENTFRAMEERRORS2)->ShowWindow(SW_SHOW);
                SetDlgItemText(IDC_COMMON_OPERCENTFRAMEERRORS2, szTemp);
            }
        }

        if(pCurrent->Status.Input.Timeouts != pNew->Status.Input.Timeouts)
            SetDlgItemInt(IDC_COMMON_ITIMEOUTERRORS,
                                    pNew->Status.Input.Timeouts -
                                        m_BaseStatus.Input.Timeouts,
										FALSE);
        if(pCurrent->Status.Output.Timeouts != pNew->Status.Output.Timeouts)
            SetDlgItemInt(IDC_COMMON_OTIMEOUTERRORS,
                                    pNew->Status.Output.Timeouts -
                                        m_BaseStatus.Output.Timeouts,
                                    FALSE);
    }

    /*
     * NOTE: for these compression ratio calculations, the "CompressedBytes" field is
     * actually 'Bytes before compression', that is, it is the byte count in the middle
     * of the WD/PD stack.  "WdBytes" are the bytes input/output at the app level (and is
     * not displayed in any WinAdmin counters).  "CompressedBytes" include any overhead
     * bytes added by the stack.  "Bytes" represent the actual number of bytes input/output
     * over the 'wire'; hence, we use Bytes for all counter display and "CompressedBytes" to
     * calculate compression ratios.
     */
    if((pNew->Status.Input.CompressedBytes || m_BaseStatus.Input.CompressedBytes) &&
         ((pCurrent->Status.Input.Bytes != pNew->Status.Input.Bytes) ||
          (pCurrent->Status.Input.CompressedBytes != pNew->Status.Input.CompressedBytes)) ) {

        TCHAR szTemp[10];
        int q, r;

        if((pNew->Status.Input.CompressedBytes - m_BaseStatus.Input.CompressedBytes)) {
            double temp;

            temp = (double)(pNew->Status.Input.CompressedBytes -
                            m_BaseStatus.Input.CompressedBytes) /
                   (double)(pNew->Status.Input.Bytes - m_BaseStatus.Input.Bytes);
            q = (int)temp;
            r = (int)((temp - (double)q) * 100.0);

        } else {
            /*
             * Special case for 0 compressed bytes (compression turned off or counters reset).
             */
            q = 0;
            r = 0;
        }
        lstrnprintf(szTemp, 10, TEXT("%d.%02d"), q, r);

        /*
         * Only output if changed from previous.
         */
        if(lstrcmp(szTemp, m_szICompressionRatio)) {
            lstrcpy(m_szICompressionRatio, szTemp);
        	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO)->ShowWindow(SW_HIDE);
        	GetDlgItem(IDC_COMMON_ICOMPRESSIONRATIO2)->ShowWindow(SW_SHOW);
            SetDlgItemText(IDC_COMMON_ICOMPRESSIONRATIO2, szTemp);
        }
    }

    if((pNew->Status.Output.CompressedBytes || m_BaseStatus.Output.CompressedBytes) &&
         ((pCurrent->Status.Output.Bytes != pNew->Status.Output.Bytes) ||
          (pCurrent->Status.Output.CompressedBytes != pNew->Status.Output.CompressedBytes))) {

        TCHAR szTemp[10];
        int q, r;

        if((pNew->Status.Output.CompressedBytes - m_BaseStatus.Output.CompressedBytes)) {
            double temp;

            temp = (double)(pNew->Status.Output.CompressedBytes -
                            m_BaseStatus.Output.CompressedBytes) /
                   (double)(pNew->Status.Output.Bytes - m_BaseStatus.Output.Bytes);
            q = (int)temp;
            r = (int)((temp - (double)q) * 100.0);

        } else {
            /*
             * Special case for 0 compressed bytes (compression turned off or counters reset).
             */
            q = 0;
            r = 0;
        }
        lstrnprintf(szTemp, 10, TEXT("%d.%02d"), q, r);

        /*
         * Only output if changed from previous.
         */
        if(lstrcmp(szTemp, m_szOCompressionRatio)) {
            lstrcpy(m_szOCompressionRatio, szTemp);
        	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO)->ShowWindow(SW_HIDE);
        	GetDlgItem(IDC_COMMON_OCOMPRESSIONRATIO2)->ShowWindow(SW_SHOW);
            SetDlgItemText(IDC_COMMON_OCOMPRESSIONRATIO2, szTemp);
        }
    }

}  // end CStatusDlg::SetInfoFields


void CStatusDlg::InitializeStatus()
{
    
	// Initialize structures and variables.
    memset( &m_WSInfo, 0xff, sizeof(m_WSInfo) );
    memset( &m_BaseStatus, 0, sizeof(m_BaseStatus) );
    m_IBytesPerFrame = m_OBytesPerFrame = INFINITE;
    lstrcpy(m_szICompressionRatio, TEXT("n/a"));
    lstrcpy(m_szOCompressionRatio, m_szICompressionRatio);

	// If this WinStation does not have a Reliable PD loaded,
	// set flag to skip those counters.
    PDPARAMS PdParams;
    ULONG ReturnLength;

    PdParams.SdClass = SdReliable;
    if (!WinStationQueryInformation(m_pWinStation->GetServer()->GetHandle(),
                                      m_pWinStation->GetLogonId(),
                                      WinStationPdParams,
                                      &PdParams, sizeof(PdParams),
                                      &ReturnLength ) ||
         (PdParams.SdClass != SdReliable) ) {
        m_bReliable = FALSE;
    } else {
        m_bReliable = TRUE;
    }

}  // end CStatusDlg::InitializeStatus

void CStatusDlg::OnCancel() 
{
	// TODO: Add extra cleanup here
    m_pWSStatusThread->ExitThread();	
	CDialog::OnCancel();
}

void CStatusDlg::OnResetcounters() 
{
	// TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
	
}

void CStatusDlg::OnClickedRefreshnow() 
{
	// TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//	return(0);
	
}


void CStatusDlg::PostNcDestroy()
{
	CDialog::PostNcDestroy();

	delete this;
}

BOOL CStatusDlg::PreTranslateMessage(MSG *pMsg)
{
    if ( IsDialogMessage(pMsg) )
        return(TRUE);
    else
        return( CDialog::PreTranslateMessage(pMsg) );

}  // end CStatusDlg::PreTranslateMessage


/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow


/*******************************************************************************
 *
 *  OnStatusStart - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *      NOTE: the derived class must override this function to process any
 *      PD-related fields as necessary, then call / return this function.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) returns the result of the OnStatusReady member function,
 *          which is always 0, indicating operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusStart( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call / return the OnStatusReady function to update the standard dialog
     * info fields.
     */
    return ( OnStatusReady( wParam, lParam ) );

}  // end CWSStatusDlg::OnStatusStart


/*******************************************************************************
 *
 *  OnStatusReady - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *      NOTE: the derived class must override this function to call it's
 *      override of the SetInfoFields function, which could then call / return
 *      this function or completely override all functionality contained here.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusReady( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Update dialog fields with information from the CWStatusThread's
     * WINSTATIONINFORMATION structure.
     */
    SetInfoFields( &m_WSInfo, &(m_pWSStatusThread->m_WSInfo) );

    /*
     * Set our working WSInfo structure to the new one and signal the thread
     * that we're done.
     */
    m_WSInfo = m_pWSStatusThread->m_WSInfo;
    m_pWSStatusThread->SignalConsumed();

    return(0);

}  // end CWSStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg dialog


CAsyncStatusDlg::CAsyncStatusDlg(CWinStation *pWinStation, CWnd* pParent /*=NULL*/)
	: CStatusDlg(pWinStation, CAsyncStatusDlg::IDD, pParent),
    m_hRedBrush(NULL),
    m_LEDToggleTimer(0)
{
	//{{AFX_DATA_INIT(CAsyncStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	    int i;

    /*
     * Initialize member variables, our local status storage,
     * and create a modeless dialog.
     */
//    m_LogonId = LogonId;
//	  m_bReadOnly = bReadOnly;
    InitializeStatus();

    /*
     * Create a solid RED brush for painting the 'LED's when 'on'.
     */
    VERIFY( m_hRedBrush = CreateSolidBrush(RGB(255,0,0)) );

    /*
     * Create the led objects (must do BEFORE dialog create).
     */
    for ( i = 0; i < NUM_LEDS; i++ )
        m_pLeds[i] = new CLed(m_hRedBrush);

    /*
     * Finally, create the modeless dialog.
     */
    VERIFY(CStatusDlg::Create(IDD_ASYNC_STATUS));
}


/*******************************************************************************
 *
 *  ~CAsyncStatusDlg - CAsyncStatusDlg destructor
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CDialog::~CDialog documentation)
 *
 ******************************************************************************/

CAsyncStatusDlg::~CAsyncStatusDlg()
{
    int i;

    /*
     * Zap our led objects.
     */
    for ( i = 0; i < NUM_LEDS; i++ )
      if ( m_pLeds[i] )
        delete m_pLeds[i];

}  // end CAsyncStatusDlg::~CAsyncStatusDlg


/*******************************************************************************
 *
 *  InitializeStatus - CAsyncStatusDlg member function: override
 *
 *      Special case reset of the LED states in the WINSTATIONINFORMATION
 *      status structure.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncStatusDlg::InitializeStatus()
{
    /*
     * Call the parent classes' InitializeStatus(), then reset the 'LED'
     * states to all 'off' & 'not toggled'.
     */
    CStatusDlg::InitializeStatus();
    m_WSInfo.Status.AsyncSignal = m_WSInfo.Status.AsyncSignalMask = 0;

}  // end CAsyncStatusDlg::InitializeStatus


/*******************************************************************************
 *
 *  SetInfoFields - CAsyncStatusDlg member function: override
 *
 *      Update the fields in the dialog with new data, if necessary.
 *
 *  ENTRY:
 *      pCurrent (input)
 *          points to WINSTATIONINFORMATION structure containing the current
 *          dialog data.
 *      pNew (input)
 *          points to WINSTATIONINFORMATION structure containing the new
 *          dialog data.
 *
 *  EXIT:
 *
 ******************************************************************************/

void
CAsyncStatusDlg::SetInfoFields( PWINSTATIONINFORMATION pCurrent,
                                PWINSTATIONINFORMATION pNew )
{
    BOOL    bSetTimer = FALSE;

    /*
     * Call the parent's SetInfoFields().
     */
    CStatusDlg::SetInfoFields( pCurrent, pNew );

    /*
     * Set new LED states if state change, or set up for quick toggle if
     * no state changed, but change(s) were detected since last query.
     */
    if ( (pCurrent->Status.AsyncSignal & MS_DTR_ON) !=
         (pNew->Status.AsyncSignal & MS_DTR_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_DTR;
        ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->
            Update(pNew->Status.AsyncSignal & MS_DTR_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_DTR ) {

        pCurrent->Status.AsyncSignal ^= MS_DTR_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RTS_ON) !=
         (pNew->Status.AsyncSignal & MS_RTS_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RTS;
        ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->
            Update(pNew->Status.AsyncSignal & MS_RTS_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RTS ) {

        pCurrent->Status.AsyncSignal ^= MS_RTS_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_CTS_ON) !=
         (pNew->Status.AsyncSignal & MS_CTS_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_CTS;
        ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->
            Update(pNew->Status.AsyncSignal & MS_CTS_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_CTS ) {

        pCurrent->Status.AsyncSignal ^= MS_CTS_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RLSD_ON) !=
         (pNew->Status.AsyncSignal & MS_RLSD_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RLSD;
        ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->
            Update(pNew->Status.AsyncSignal & MS_RLSD_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RLSD ) {

        pCurrent->Status.AsyncSignal ^= MS_RLSD_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_DSR_ON) !=
         (pNew->Status.AsyncSignal & MS_DSR_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_DSR;
        ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->
            Update(pNew->Status.AsyncSignal & MS_DSR_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_DSR ) {

        pCurrent->Status.AsyncSignal ^= MS_DSR_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->Toggle();

        bSetTimer = TRUE;
    }

    if ( (pCurrent->Status.AsyncSignal & MS_RING_ON) !=
         (pNew->Status.AsyncSignal & MS_RING_ON) ) {

        pNew->Status.AsyncSignalMask &= ~EV_RING;
        ((CLed *)GetDlgItem(IDC_ASYNC_RI))->
            Update(pNew->Status.AsyncSignal & MS_RING_ON);

    } else if ( pNew->Status.AsyncSignalMask & EV_RING ) {

        pCurrent->Status.AsyncSignal ^= MS_RING_ON;

        ((CLed *)GetDlgItem(IDC_ASYNC_RI))->Toggle();

        bSetTimer = TRUE;
    }

    /*
     * Create our led toggle timer if needed.
     */
    if ( bSetTimer && !m_LEDToggleTimer )
        m_LEDToggleTimer = SetTimer( IDD_ASYNC_STATUS,
                                     ASYNC_LED_TOGGLE_MSEC, NULL );

    /*
     * Set ASYNC-specific numeric fields if change.
     */
    if ( pCurrent->Status.Input.AsyncFramingError != pNew->Status.Input.AsyncFramingError )
        SetDlgItemInt( IDC_ASYNC_IFRAMING,
                       pNew->Status.Input.AsyncFramingError - m_BaseStatus.Input.AsyncFramingError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncFramingError != pNew->Status.Output.AsyncFramingError )
        SetDlgItemInt( IDC_ASYNC_OFRAMING,
                       pNew->Status.Output.AsyncFramingError - m_BaseStatus.Output.AsyncFramingError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncOverrunError != pNew->Status.Input.AsyncOverrunError )
        SetDlgItemInt( IDC_ASYNC_IOVERRUN,
                       pNew->Status.Input.AsyncOverrunError - m_BaseStatus.Input.AsyncOverrunError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncOverrunError != pNew->Status.Output.AsyncOverrunError )
        SetDlgItemInt( IDC_ASYNC_OOVERRUN,
                       pNew->Status.Output.AsyncOverrunError - m_BaseStatus.Output.AsyncOverrunError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncOverflowError != pNew->Status.Input.AsyncOverflowError )
        SetDlgItemInt( IDC_ASYNC_IOVERFLOW,
                       pNew->Status.Input.AsyncOverflowError - m_BaseStatus.Input.AsyncOverflowError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncOverflowError != pNew->Status.Output.AsyncOverflowError )
        SetDlgItemInt( IDC_ASYNC_OOVERFLOW,
                       pNew->Status.Output.AsyncOverflowError - m_BaseStatus.Output.AsyncOverflowError,
                       FALSE );

    if ( pCurrent->Status.Input.AsyncParityError != pNew->Status.Input.AsyncParityError )
        SetDlgItemInt( IDC_ASYNC_IPARITY,
                       pNew->Status.Input.AsyncParityError - m_BaseStatus.Input.AsyncParityError,
                       FALSE );
    if ( pCurrent->Status.Output.AsyncParityError != pNew->Status.Output.AsyncParityError )
        SetDlgItemInt( IDC_ASYNC_OPARITY,
                       pNew->Status.Output.AsyncParityError - m_BaseStatus.Output.AsyncParityError,
                       FALSE );

}  // end CAsyncStatusDlg::SetInfoFields


void CAsyncStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAsyncStatusDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAsyncStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CAsyncStatusDlg)
		ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
		ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
		ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
		ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
		ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
		ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
		ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	    ON_WM_TIMER()
		ON_WM_NCDESTROY()
	    ON_WM_HELPINFO()
		ON_COMMAND(ID_HELP,OnCommandHelp)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAsyncStatusDlg message handlers
/*******************************************************************************
 *
 *  OnInitDialog - CAsyncStatusDlg member function: command (override)
 *
 *      Performs async-specific dialog intialization.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CDialog::OnInitDialog documentation)
 *
 ******************************************************************************/
static int LedIds[NUM_LEDS] = {
    IDC_ASYNC_DTR,
    IDC_ASYNC_RTS,
    IDC_ASYNC_CTS,
    IDC_ASYNC_DSR,
    IDC_ASYNC_DCD,
    IDC_ASYNC_RI    };

BOOL CAsyncStatusDlg::OnInitDialog()
{
    int i;

    /*
     * Perform parent's OnInitDialog() first.
     */
    CStatusDlg::OnInitDialog();

    /*
     * Subclass the led controls and default to 'off'.
     */
    for ( i = 0; i < NUM_LEDS; i++ ) {
        m_pLeds[i]->Subclass( (CStatic *)GetDlgItem(LedIds[i]) );
        m_pLeds[i]->Update(0);
    }

    return(TRUE);

}  // end CAsyncStatusDlg::OnInitDialog

void CAsyncStatusDlg::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CAsyncStatusDlg::IDD + HID_BASE_RESOURCE);
	return;
}

/*******************************************************************************
 *
 *  OnStatusStart - CAsyncStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusStart( WPARAM wParam,
                                LPARAM lParam )
{
    /*
     * Fetch the PD-specific information from the CWStatusThread's PDCONFIG
     * structure and initialize dialog fields.
     */
    SetDlgItemText( IDC_ASYNC_DEVICE,
                    m_pWSStatusThread->m_PdConfig.Params.Async.DeviceName );
    SetDlgItemInt( IDC_ASYNC_BAUD,
                   m_pWSStatusThread->m_PdConfig.Params.Async.BaudRate,
                   FALSE );

    /*
     * Call / return our OnStatusReady() function.
     */
    return ( OnStatusReady( wParam, lParam ) );

}  // end CAsyncStatusDlg::OnStatusStart


/*******************************************************************************
 *
 *  OnStatusReady - CAsyncStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusReady( WPARAM wParam,
                                LPARAM lParam )
{
    /*
     * If the LED toggle timer is still active now, kill it and flag so.
     */
    if ( m_LEDToggleTimer ) {

        KillTimer(m_LEDToggleTimer);
        m_LEDToggleTimer = 0;
    }

    /*
     * Call / return the parent classes' OnStatusReady() function.
     */
    return (CStatusDlg::OnStatusReady( wParam, lParam ));

}  // end CAsyncStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnTimer - CAsyncStatusDlg member function: command (override)
 *
 *      Used for quick 'LED toggle'.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnTimer documentation)
 *
 ******************************************************************************/

void
CAsyncStatusDlg::OnTimer(UINT nIDEvent)
{
    /*
     * Process this timer event if it it our 'LED toggle' event.
     */
    if ( nIDEvent == m_LEDToggleTimer ) {

        /*
         * Toggle each led that is flagged as 'changed'.
         */
        if ( m_WSInfo.Status.AsyncSignalMask & EV_DTR )
            ((CLed *)GetDlgItem(IDC_ASYNC_DTR))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RTS )
            ((CLed *)GetDlgItem(IDC_ASYNC_RTS))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_CTS )
            ((CLed *)GetDlgItem(IDC_ASYNC_CTS))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RLSD )
            ((CLed *)GetDlgItem(IDC_ASYNC_DCD))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_DSR )
            ((CLed *)GetDlgItem(IDC_ASYNC_DSR))->Toggle();
		
        if ( m_WSInfo.Status.AsyncSignalMask & EV_RING )
            ((CLed *)GetDlgItem(IDC_ASYNC_RI))->Toggle();
		
        /*
         * Kill this timer event and indicate so.
         */
        KillTimer(m_LEDToggleTimer);
        m_LEDToggleTimer = 0;

    } else
        CDialog::OnTimer(nIDEvent);

}  // end CAsyncStatusDlg::OnTimer


/*******************************************************************************
 *
 *  OnNcDestroy - CAsyncStatusDlg member function: command
 *
 *      Clean up before deleting dialog object.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to CWnd::OnNcDestroy documentation)
 *
 ******************************************************************************/

void
CAsyncStatusDlg::OnNcDestroy()
{
    /*
     * Delete the red brush we made.
     */
    DeleteObject(m_hRedBrush);

    /*
     * If the LED toggle timer is still active, kill it.
     */
    if ( m_LEDToggleTimer )
        KillTimer(m_LEDToggleTimer);

    /*
     * Call parent after we've cleaned up.
     */
    CStatusDlg::OnNcDestroy();

}  // end CAsyncStatusDlg::OnNcDestroy

/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


void CAsyncStatusDlg::OnResetcounters() 
{
	// TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
	
}

void CAsyncStatusDlg::OnClickedRefreshnow() 
{
	// TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//	return(0);
	
}

void CAsyncStatusDlg::OnMoreinfo() 
{
	// TODO: Add your control notification handler code here
	CString ButtonText;

    if(m_bWeAreLittle)  {
         // We are now little size: go to big size.
        SetWindowPos(NULL, 0, 0, m_BigSize.cx, m_BigSize.cy,
                      SWP_NOMOVE | SWP_NOZORDER);

        ButtonText.LoadString(IDS_LESSINFO);
        SetDlgItemText(IDC_MOREINFO, ButtonText);

        m_bWeAreLittle = FALSE;

    } else {
        // We are now big size: go to little size.
        SetWindowPos( NULL, 0, 0, m_LittleSize.cx, m_LittleSize.cy,
                      SWP_NOMOVE | SWP_NOZORDER);

        ButtonText.LoadString(IDS_MOREINFO);
        SetDlgItemText(IDC_MOREINFO, ButtonText);

        m_bWeAreLittle = TRUE;
    }

}

/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CAsyncStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow


BOOL CAsyncStatusDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);			

}

/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg dialog


CNetworkStatusDlg::CNetworkStatusDlg(CWinStation *pWinStation, CWnd* pParent /*=NULL*/)
	: CStatusDlg(pWinStation, CNetworkStatusDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNetworkStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    InitializeStatus();

    VERIFY( CStatusDlg::Create(IDD_NETWORK_STATUS) );
}


void CNetworkStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNetworkStatusDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNetworkStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CNetworkStatusDlg)
	ON_MESSAGE(WM_STATUSSTART, OnStatusStart)
    ON_MESSAGE(WM_STATUSREADY, OnStatusReady)
    ON_MESSAGE(WM_STATUSABORT, OnStatusAbort)
    ON_MESSAGE(WM_STATUSREFRESHNOW, OnRefreshNow)
	ON_BN_CLICKED(IDC_RESETCOUNTERS, OnResetcounters)
	ON_BN_CLICKED(IDC_REFRESHNOW, OnClickedRefreshnow)
	ON_BN_CLICKED(IDC_MOREINFO, OnMoreinfo)
	ON_WM_HELPINFO()
	ON_COMMAND(ID_HELP,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNetworkStatusDlg message handlers
/*******************************************************************************
 *
 *  OnStatusStart - CNetworkStatusDlg member function: command
 *
 *      Process the WM_STATUSSTART message to initialize the 'static'
 *      PD-related fields.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusStart( WPARAM wParam,
                                  LPARAM lParam )
{
    DEVICENAME DeviceName;
    PDCONFIG3 PdConfig3;
    LONG Status;
    ULONG ByteCount;
    HANDLE hServer;

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    if(pDoc->IsInShutdown()) return 0;

    if(m_pWinStation->GetSdClass() == SdOemTransport) {
        CString LabelString;
        LabelString.LoadString(IDS_DEVICE);
        SetDlgItemText(IDC_LABEL, LabelString);

        ULONG Length;
        PDCONFIG PdConfig;

        if(Status = WinStationQueryInformation(m_pWinStation->GetServer()->GetHandle(),
                            m_pWinStation->GetLogonId(),
                            WinStationPd,
                            &PdConfig,
                            sizeof(PDCONFIG),
                            &Length)) {
                wcscpy(DeviceName, PdConfig.Params.OemTd.DeviceName);
        }
    } else {
        /*
        * Fetch the registry configuration for the PD specified in the
        * CWStatusThread's PDCONFIG structure and initialize dialog fields.
        */
        hServer = RegOpenServer(m_pWinStation->GetServer()->IsCurrentServer() ? NULL : m_pWinStation->GetServer()->GetName());

        PWDNAME pWdRegistryName = m_pWinStation->GetWdRegistryName();

        if (!pWdRegistryName || (Status = RegPdQuery(hServer, 
                                pWdRegistryName,
                                TRUE,
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &PdConfig3, sizeof(PDCONFIG3), &ByteCount)) ) {

            // We don't currently look at the registry names on remote servers.
            // If ICA is in use on the remote server and not on this server,
            // we won't have a registry name - try "wdica" and "icawd"
            if(m_pWinStation->IsICA()) {
                if(Status = RegPdQuery(hServer, 
                                TEXT("icawd"),
                                TRUE,
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &PdConfig3, sizeof(PDCONFIG3), &ByteCount) ) {
                
                    Status = RegPdQuery(hServer, 
                                    TEXT("wdica"),
                                    TRUE,
                                    m_pWSStatusThread->m_PdConfig.Create.PdName,
                                    &PdConfig3, sizeof(PDCONFIG3), &ByteCount);
                }
            } 
                
            if(Status) memset(&PdConfig3, 0, sizeof(PDCONFIG3));
        }

        ULONG Length = 0;
        PWSTR pLanAdapter = NULL;
        //
        // Try the new interface first (NT5 server ?)
        //
        if (WinStationGetLanAdapterName(m_pWinStation->GetServer()->GetHandle(),
                                m_pWSStatusThread->m_PdConfig.Params.Network.LanAdapter,
                                (lstrlen(m_pWSStatusThread->m_PdConfig.Create.PdName) + 1) * sizeof(WCHAR),
                                m_pWSStatusThread->m_PdConfig.Create.PdName,
                                &Length,
                                &pLanAdapter))
        {
            //NT5 Server
            SetDlgItemText( IDC_NETWORK_LANADAPTER, pLanAdapter );
            if(pLanAdapter)
            {
                WinStationFreeMemory(pLanAdapter);
            }
        }
        else
        {
            //
            //   Check the return code indicating that the interface is not available.
            //
            DWORD dwError = GetLastError();
            if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                //Error getting Name. 
                SetDlgItemText( IDC_NETWORK_LANADAPTER, GetUnknownString());
            }
            else    // maybe a Hydra 4 server ?
            {

                if (RegGetNetworkDeviceName(hServer, &PdConfig3, &(m_pWSStatusThread->m_PdConfig.Params),
                                             DeviceName, DEVICENAME_LENGTH +1 ) == ERROR_SUCCESS) 
                {
                    SetDlgItemText( IDC_NETWORK_LANADAPTER, DeviceName );
                    
                }
                else
                {
                    //Error
                    SetDlgItemText( IDC_NETWORK_LANADAPTER, GetUnknownString());
                }
            }
        }

        RegCloseServer(hServer);
    }

    /*
     * Call / return parent classes' OnStatusStart().
     */
    return ( CStatusDlg::OnStatusStart( wParam, lParam ) );

}  // end CNetworkStatusDlg::OnStatusStart


void CNetworkStatusDlg::OnResetcounters() 
{
    // TODO: Add your control notification handler code here
    m_bResetCounters = TRUE;
    OnClickedRefreshnow();
    
}

void CNetworkStatusDlg::OnClickedRefreshnow() 
{
    // TODO: Add your control notification handler code here
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

//  return(0);
    
}

void CNetworkStatusDlg::OnMoreinfo() 
{
    // TODO: Add your control notification handler code here
    
}
void CNetworkStatusDlg::OnCommandHelp(void)
{
    AfxGetApp()->WinHelp(CNetworkStatusDlg::IDD + HID_BASE_RESOURCE);
    return;
}


/*******************************************************************************
 *
 *  OnRefreshNow - CWSStatusDlg member function: command
 *
 *      Processes in response to main frame's WM_STATUSREFRESHNOW notification
 *      that the user has changed the status refresh options.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnRefreshNow( WPARAM wParam,
                            LPARAM lParam )
{
    /*
     * Tell the status thread to wake up now.
     */
    m_pWSStatusThread->SignalWakeUp();

    return(0);

}  // end CWSStatusDlg::OnRefreshNow

/*******************************************************************************
 *
 *  OnStatusReady - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSREADY message to update the dialog Info fields.
 *
 *      NOTE: the derived class must override this function to call it's
 *      override of the SetInfoFields function, which could then call / return
 *      this function or completely override all functionality contained here.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusReady( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Update dialog fields with information from the CWStatusThread's
     * WINSTATIONINFORMATION structure.
     */
    SetInfoFields( &m_WSInfo, &(m_pWSStatusThread->m_WSInfo) );

    /*
     * Set our working WSInfo structure to the new one and signal the thread
     * that we're done.
     */
    m_WSInfo = m_pWSStatusThread->m_WSInfo;
    m_pWSStatusThread->SignalConsumed();

    return(0);

}  // end CWSStatusDlg::OnStatusReady


/*******************************************************************************
 *
 *  OnStatusAbort - CWSStatusDlg member function: command
 *
 *      Process the WM_STATUSABORT message to exit the thread and dialog.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (LRESULT) always returns 0 to indicate operation complete.
 *
 ******************************************************************************/

LRESULT
CNetworkStatusDlg::OnStatusAbort( WPARAM wParam,
                             LPARAM lParam )
{
    /*
     * Call the OnCancel() member function to exit dialog and thread and
     * perform proper cleanup.
     */
    OnCancel();

    return(0);

}  // end CWSStatusDlg::OnStatusAbort


BOOL CNetworkStatusDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	// TODO: Add your message handler code here and/or call default
	//((CWinAdminApp*)AfxGetApp())->WinHelp(HID_BASE_CONTROL + pHelpInfo->iCtrlId, HELP_CONTEXTPOPUP);
	if(pHelpInfo->iContextType == HELPINFO_WINDOW) 
	{
		if(pHelpInfo->iCtrlId != IDC_STATIC)
		{
	         ::WinHelp((HWND)pHelpInfo->hItemHandle,ID_HELP_FILE,HELP_WM_HELP,(ULONG_PTR)(LPVOID)aMenuHelpIDs);
		}
	}

	return (TRUE);				
	
}


////////////////////////////////////////////////////////////////////////////////
CMyDialog::CMyDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CMyDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMyDialog)
	m_cstrServerName = _T("");
	//}}AFX_DATA_INIT
}


void CMyDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMyDialog)
    DDX_Text(pDX, IDC_EDIT_FINDSERVER, m_cstrServerName);
    DDV_MaxChars(pDX, m_cstrServerName, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMyDialog, CDialog)
	//{{AFX_MSG_MAP(CMyDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\domainpg.cpp ===
/*******************************************************************************
*
* domainpg.cpp
*
* implementations of the Domain info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\domainpg.cpp  $
*
*     Rev 1.2   19 Feb 1998 17:40:30   donm
*  removed latest extension DLL support
*
*     Rev 1.1   19 Jan 1998 16:47:36   donm
*  new ui behavior for domains and servers
*
*     Rev 1.0   03 Nov 1997 15:07:22   donm
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "domainpg.h"

#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
//USES_CONVERSION
static int _convert;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////////
// MESSAGE MAP: CDomainServersPage
//
IMPLEMENT_DYNCREATE(CDomainServersPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainServersPage, CFormView)
        //{{AFX_MSG_MAP(CDomainServersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVER_LIST, OnColumnclick)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_SERVER_LIST, OnServerItemChanged)
        ON_NOTIFY(NM_SETFOCUS, IDC_SERVER_LIST, OnSetfocusServerList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_SERVER_LIST, OnKillfocusServerList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainServersPage ctor
//
CDomainServersPage::CDomainServersPage()
        : CAdminPage(CDomainServersPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainServersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainServersPage ctor


/////////////////////////////
// F'N: CDomainServersPage dtor
//
CDomainServersPage::~CDomainServersPage()
{

}  // end CDomainServersPage dtor


////////////////////////////////////////
// F'N: CDomainServersPage::DoDataExchange
//
void CDomainServersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainServersPage)
        DDX_Control(pDX, IDC_SERVER_LIST, m_ServerList);
        //}}AFX_DATA_MAP

}  // end CDomainServersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainServersPage::AssertValid
//
void CDomainServersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainServersPage::AssertValid


//////////////////////////////
// F'N: CDomainServersPage::Dump
//
void CDomainServersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainServersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CDomainServersPage::OnSize
//
void CDomainServersPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_ServerList.GetSafeHwnd())
            m_ServerList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainServersPage::OnSize


static ColumnDef ServerColumns[] = {
        CD_SERVER,
        CD_TCPADDRESS,
        CD_IPXADDRESS,
        CD_NUM_SESSIONS
};

#define NUM_DOMAIN_SERVER_COLUMNS sizeof(ServerColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CDomainServersPage::OnInitialUpdate
//
void CDomainServersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_SERVER_COLUMNS; col++) {
                columnString.LoadString(ServerColumns[col].stringID);
                m_ServerList.InsertColumn(col, columnString, ServerColumns[col].format, ServerColumns[col].width, col);
        }

        m_CurrentSortColumn = SERVERS_COL_SERVER;

}  // end CDomainServersPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainServersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainServersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 4, 0);

        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
        m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
        m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);

        m_ImageList.SetOverlayImage(m_idxNotSign, 1);
        m_ImageList.SetOverlayImage(m_idxQuestion, 2);

        m_ServerList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainServersPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainServersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainServersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainServersPage::AddIconToImageList


//////////////////////////////
// F'N: CDomainServersPage::Reset
//
void CDomainServersPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayServers();

} // end CDomainServersPage::Reset


//////////////////////////////
// F'N: CDomainServersPage::AddServer
//
void CDomainServersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // We have to make sure the server isn't already in the list
        // Add the server to the list
        if(AddServerToList(pServer)) {
            // Tell the list to sort itself
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainServersPage::AddServer


//////////////////////////////
// F'N: CDomainServersPage::RemoveServer
//
void CDomainServersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();
        // Find out how many items in the list
        int ItemCount = m_ServerList.GetItemCount();

        // Go through the items are remove this server
        for(int item = 0; item < ItemCount; item++) {
                CServer *pListServer = (CServer*)m_ServerList.GetItemData(item);

                if(pListServer == pServer) {
                        m_ServerList.DeleteItem(item);
                        pServer->ClearAllSelected();
                        break;
                }
        }
        UnlockListControl();

}  // end CDomainServersPage::RemoveServer


//////////////////////////////
// F'N: CDomainServersPage::UpdateServer
//
void CDomainServersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        // If we aren't connected to the server anymore, remove it from the list control
        if(pServer->IsState(SS_NOT_CONNECTED)) {
                RemoveServer(pServer);
                return;
        }

        // If we just connected to this server, add it to the list control
        if(pServer->IsState(SS_GOOD)) {
                AddServer(pServer);
                return;
        }

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) {
                // Change the icon overlay
                USHORT NewState;
                // Change the icon/overlay for the server
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) NewState = STATE_NOT;
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(!pServer->IsState(SS_GOOD)) NewState = STATE_QUESTION;
                // If it is fine, we want to remove any overlays from the icon
                else NewState = STATE_NORMAL;

                // Set the tree item to the new state
                m_ServerList.SetItemState(item, NewState, 0x0F00);

                ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

                // TCP Address
                m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

                // IPX Address
                m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

                CString NumString;
                if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                        NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
                } else {
                        NumString.LoadString(IDS_NOT_APPLICABLE);
                }

                m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);
        }

        // Tell the list to sort itself
        if(m_CurrentSortColumn == SERVERS_COL_NUMWINSTATIONS
                || m_CurrentSortColumn == SERVERS_COL_TCPADDRESS
                || m_CurrentSortColumn == SERVERS_COL_IPXADDRESS)
                        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);

        UnlockListControl();

}  // end CDomainServersPage::UpdateServer


//////////////////////////////
// F'N: CDomainServersPage::AddServerToList
//
BOOL CDomainServersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        // If we aren't currently connected to the server, don't display it
        if(!pServer->IsState(SS_GOOD)) return FALSE;

        LockListControl();
        // Find the Server in the list
        LV_FINDINFO FindInfo;
        FindInfo.flags = LVFI_PARAM;
        FindInfo.lParam = (LPARAM)pServer;

        // Find the Server in our list
        int item = m_ServerList.FindItem(&FindInfo, -1);
        if(item != -1) return FALSE;

        //////////////////////
        // Fill in the columns
        //////////////////////
        // Name - put at the end of the list
        item = m_ServerList.InsertItem(m_ServerList.GetItemCount(), pServer->GetName(),
                                                                pServer->IsCurrentServer() ? m_idxCurrentServer : m_idxServer);

        // If the server isn't sane, put a not sign over the icon
        if(!pServer->IsServerSane()) m_ServerList.SetItemState(item, STATE_NOT, 0x0F00);
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(!pServer->IsState(SS_GOOD)) m_ServerList.SetItemState(item, STATE_QUESTION, 0x0F00);

        ExtServerInfo *pExtServerInfo = pServer->GetExtendedInfo();

        // TCP Address
        m_ServerList.SetItemText(item, SERVERS_COL_TCPADDRESS, pExtServerInfo->TcpAddress);

        // IPX Address
        m_ServerList.SetItemText(item, SERVERS_COL_IPXADDRESS, pExtServerInfo->IpxAddress);

        // Connected
        CString NumString;
        if(pExtServerInfo && (pExtServerInfo->Flags & ESF_WINFRAME)) {
                NumString.Format(TEXT("%lu"), pExtServerInfo->ServerTotalInUse);
        } else {
                NumString.LoadString(IDS_NOT_APPLICABLE);
        }

        m_ServerList.SetItemText(item, SERVERS_COL_NUMWINSTATIONS, NumString);

        m_ServerList.SetItemData(item, (DWORD_PTR)pServer);

        m_ServerList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

    return TRUE;

}  // end CDomainServersPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainServersPage::DisplayServers
//
void CDomainServersPage::DisplayServers()
{
        LockListControl();

        // Clear out the list control
        m_ServerList.DeleteAllItems();

        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

        // Get a pointer to the list of servers
        doc->LockServerList();
        CObList *pServerList = doc->GetServerList();

        // Iterate through the Server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }  // end while(pos)

        doc->UnlockServerList();

        UnlockListControl();

}  // end CDomainServersPage::DisplayServers


//////////////////////////////
// F'N: CDomainServersPage::OnServerItemChanged
//
void CDomainServersPage::OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here
        CServer *pServer = (CServer*)m_ServerList.GetItemData(pLV->iItem);

        if(pLV->uNewState & LVIS_SELECTED) {
                pServer->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                pServer->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainServersPage::OnServerItemChanged


//////////////////////////////
// F'N: CDomainServersPage::OnColumnclick
//
void CDomainServersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_SERVERS, &m_ServerList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainServersPage::OnColumnclick


//////////////////////////////
// F'N: CDomainServersPage::OnContextMenu
//
void CDomainServersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ServerList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ServerList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ServerList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ServerList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ServerList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_SERVER_POPUP);
        // set the temp selected item so that handler doesn't think
        // this came from the tree
        // Get a pointer to our document
        CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
        doc->SetTreeTemp(NULL, NODE_NONE);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainServersPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CDomainUsersPage
//
IMPLEMENT_DYNCREATE(CDomainUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainUsersPage, CFormView)
        //{{AFX_MSG_MAP(CDomainUsersPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_USER_LIST, OnKillfocusUserList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainUsersPage ctor
//
CDomainUsersPage::CDomainUsersPage()
        : CAdminPage(CDomainUsersPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainUsersPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainUsersPage ctor


/////////////////////////////
// F'N: CDomainUsersPage dtor
//
CDomainUsersPage::~CDomainUsersPage()
{
}  // end CDomainUsersPage dtor


////////////////////////////////////////
// F'N: CDomainUsersPage::DoDataExchange
//
void CDomainUsersPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainUsersPage)
        DDX_Control(pDX, IDC_USER_LIST, m_UserList);
        //}}AFX_DATA_MAP

}  // end CDomainUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainUsersPage::AssertValid
//
void CDomainUsersPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainUsersPage::AssertValid


//////////////////////////////
// F'N: CDomainUsersPage::Dump
//
void CDomainUsersPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CDomainUsersPage::OnSize
//
void CDomainUsersPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_UserList.GetSafeHwnd())
            m_UserList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainUsersPage::OnSize


static ColumnDef UserColumns[] = {
        CD_SERVER,
        CD_USER3,
        CD_SESSION,
        CD_ID,
        CD_STATE,
        CD_IDLETIME,
        CD_LOGONTIME,
};

#define NUM_DOMAIN_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CDomainUsersPage::OnInitialUpdate
//
void CDomainUsersPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_USER_COLUMNS; col++) {
                columnString.LoadString(UserColumns[col].stringID);
                m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_USERS_COL_SERVER;

}  // end CDomainUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CDomainUsersPage::OnUserItemChanged
//
void CDomainUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
                pWinStation->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
                pWinStation->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainUsersPage::OnUserItemChanged

/////////////////////////////////////
// F'N: CDomainUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainUsersPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 2, 0);

        m_idxUser = AddIconToImageList(IDI_USER);
        m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

        m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainUsersPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CDomainUsersPage::Reset
//
void CDomainUsersPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayUsers();

} // end CDomainUsersPage::Reset


//////////////////////////////
// F'N: CDomainUsersPage::AddServer
//
void CDomainUsersPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the server's users to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
   }

} // end CDomainUsersPage::AddServer


//////////////////////////////
// F'N: CDomainUsersPage::RemoveServer
//
void CDomainUsersPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_UserList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_UserList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

} // end CDomainUsersPage::RemoveServer


//////////////////////////////
// F'N: CDomainUsersPage::UpdateServer
//
void CDomainUsersPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainUsersPage::UpdateServer


//////////////////////////////
// F'N: CDomainUsersPage::UpdateWinStations
//
void CDomainUsersPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_UserList.FindItem(&FindInfo, -1);

                // If the WinStation is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
                        // Remove the WinStation from the list
                        m_UserList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // change the user name
                        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

                        // change the WinStation Name
                        // WinStation Name
                        if(pWinStation->GetName()[0])
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
                        }


                        // change the Connect State
                        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
                        // change the Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);
                        // change the Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';
                        // change the

                        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

                        if(m_CurrentSortColumn != AS_USERS_COL_ID)
                                bAnyChanged = TRUE;

                        continue;
                }

                // If the WinStation is not in the list but now has a user, add it to the list
                if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                        bAnyAdded = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CDomainUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CDomainUsersPage::AddUserToList
//
int CDomainUsersPage::AddUserToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;


        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////
        // Server - put at the end of the list
        int item = m_UserList.InsertItem(m_UserList.GetItemCount(), pServer->GetName(),
                pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

        // User
        m_UserList.SetItemText(item, AS_USERS_COL_USER, pWinStation->GetUserName());

        // WinStation Name
        if(pWinStation->GetName()[0])
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
            m_UserList.SetItemText(item, AS_USERS_COL_WINSTATION, NameString);
        }

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_UserList.SetItemText(item, AS_USERS_COL_ID, ColumnString);

        // Connect State
        m_UserList.SetItemText(item, AS_USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
        {
                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_UserList.SetItemText(item, AS_USERS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_UserList.SetItemText(item, AS_USERS_COL_LOGONTIME, LogonTimeString);

        // Attach a pointer to the CWinStation structure to the list item
        m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);
        
        //bug #191727
        //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CDomainUsersPage::AddUserToList


//////////////////////////////
// F'N: CDomainUsersPage::AddServerToList
//
BOOL CDomainUsersPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                // only show the WinStation if it has a user
                if(pWinStation->HasUser()) {
                        AddUserToList(pWinStation);
                }
        }  // end while(pos)

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CDomainUsersPage::AddServerToList


//////////////////////////////
// F'N: CDomainUsersPage::OnColumnclick
//
void CDomainUsersPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainUsersPage::OnColumnclick


//////////////////////////////
// F'N: CDomainUsersPage::OnContextMenu
//
void CDomainUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_UserList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_UserList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_UserList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                {
                    //
                    // ListView HitTest bug? return -1 but item display as selected.
                    // workaround for now, Al can fix this later
                    //
                    UINT iCount = m_UserList.GetItemCount( );
                    RECT rc;

                    for( Item = 0 ; Item < iCount ; Item++ )
                    {
                        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                            break;
                        }
                    }

                    if( Item >= iCount )
                    {
                        return;
                    }

                }

                //
                // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
                // manually set it to selected state
                //
                CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

                if( !pWinStation )
                    return;
    
                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    pWinStation->SetSelected();
                }
        }

        CMenu menu;
        menu.LoadMenu(IDR_USER_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainUsersPage::OnContextMenu


/////////////////////////////////////
// F'N: CDomainUsersPage::DisplayUsers
//
void CDomainUsersPage::DisplayUsers()
{
        LockListControl();

        // Clear out the list control
        m_UserList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos2 = pServerList->GetHeadPosition();

        while(pos2) {

                CServer *pServer = (CServer*)pServerList->GetNext(pos2);
                        AddServerToList(pServer);
        } // end while(pos2)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CDomainUsersPage::DisplayUsers

/////////////////////////////////////
// F'N: CDomainUsersPage::ClearSelections
//
void CDomainUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CDomainWinStationsPage
//
IMPLEMENT_DYNCREATE(CDomainWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainWinStationsPage, CFormView)
        //{{AFX_MSG_MAP(CDomainWinStationsPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_WINSTATION_LIST, OnKillfocusWinstationList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainWinStationsPage ctor
//
CDomainWinStationsPage::CDomainWinStationsPage()
        : CAdminPage(CDomainWinStationsPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainWinStationsPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainWinStationsPage ctor


/////////////////////////////
// F'N: CDomainWinStationsPage dtor
//
CDomainWinStationsPage::~CDomainWinStationsPage()
{

}  // end CDomainWinStationsPage dtor


////////////////////////////////////////
// F'N: CDomainWinStationsPage::DoDataExchange
//
void CDomainWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainWinStationsPage)
        DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
        //}}AFX_DATA_MAP

}  // end CDomainWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainWinStationsPage::AssertValid
//
void CDomainWinStationsPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainWinStationsPage::AssertValid


//////////////////////////////
// F'N: CDomainWinStationsPage::Dump
//
void CDomainWinStationsPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainWinStationsPage::Dump

#endif //_DEBUG


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnWinStationItemChanged
//
void CDomainWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
                pWinStation->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
                pWinStation->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainWinStationsPage::OnWinStationItemChanged


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnSize
//
void CDomainWinStationsPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_StationList.GetSafeHwnd())
            m_StationList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
        CD_SERVER,
        CD_SESSION2,
        CD_USER2,
        CD_ID,
        CD_STATE,
        CD_TYPE,
        CD_CLIENT_NAME,
        CD_IDLETIME,
        CD_LOGONTIME,
        CD_COMMENT
};

#define NUM_DOMAIN_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnInitialUpdate
//
void CDomainWinStationsPage::OnInitialUpdate()
{
        // Call the parent class
        CFormView::OnInitialUpdate();

        // builds the image list for the list control
        BuildImageList();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_WINS_COLUMNS; col++) {
                columnString.LoadString(WinsColumns[col].stringID);
                m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_WS_COL_SERVER;

}  // end CDomainWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainWinStationsPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 11, 0);

        m_idxBlank  = AddIconToImageList(IDI_BLANK);
        m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
        m_idxServer = AddIconToImageList(IDI_SERVER);
        m_idxConsole = AddIconToImageList(IDI_CONSOLE);
        m_idxNet = AddIconToImageList(IDI_NET);
        m_idxAsync = AddIconToImageList(IDI_ASYNC);
        m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
        m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
        m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
        m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
        m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);

        m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainWinStationsPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainWinStationsPage::AddIconToImageList


////////////////////////////////////////
// F'N: CDomainWinStationsPage::Reset
//
void CDomainWinStationsPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayStations();

}  // end CDomainWinStationsPage::Reset


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddServer
//
void CDomainWinStationsPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add server's WinStations to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainWinStationsPage::AddServer


////////////////////////////////////////
// F'N: CDomainWinStationsPage::RemoveServer
//
void CDomainWinStationsPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_StationList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(item-1);
                CServer *pListServer = pWinStation->GetServer();

                if(pListServer == pServer) {
                        m_StationList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CDomainWinStationsPage::RemoveServer


//////////////////////////////
// F'N: CDomainWinStationsPage::UpdateServer
//
void CDomainWinStationsPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainWinStationsPage::UpdateServer


////////////////////////////////////////
// F'N: CDomainWinStationsPage::UpdateWinStations
//
void CDomainWinStationsPage::UpdateWinStations(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the WinStations
        pServer->LockWinStationList();
        CObList *pWinStationList = pServer->GetWinStationList();

        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pWinStation;

                // Find the WinStation in our list
                int item = m_StationList.FindItem(&FindInfo, -1);

                // If the process is new and isn't currently in the list,
                // add it to the list
                if(pWinStation->IsNew() && item == -1) {

                        AddWinStationToList(pWinStation);
                        bAnyAdded = TRUE;
                        continue;
                }

                // If the WinStation is no longer current,
                // remove it from the list
                if(!pWinStation->IsCurrent() && item != -1) {
                        // Remove the WinStation from the list
                        m_StationList.DeleteItem(item);
                        pWinStation->ClearSelected();
                        continue;
                }

                // If the WinStation info has changed, change
                // it's info in our tree
                if(pWinStation->IsChanged() && item != -1) {
                        // Figure out which icon to use
                        int WhichIcon = m_idxBlank;
                        BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();

                        if(pWinStation->GetState() != State_Disconnected
                        && pWinStation->GetState() != State_Idle) {
                                switch(pWinStation->GetSdClass()) {
                                        case SdAsync:
                                                if(pWinStation->IsDirectAsync())
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                                else
                                                        WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                                break;

                                        case SdNetwork:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                                break;

                                        default:
                                                WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                        break;
                                }
                        }

                        m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

                        // WinStation Name
                        if(pWinStation->GetName()[0])
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
                        else {
                                CString NameString(" ");
                                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
                        }

                        // User
                        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

                        // Logon ID
                        CString ColumnString;
                        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
                        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

                        // Connect State
                        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

                        // Type
                        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

                        // Client Name
                        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

                        // Idle Time
                        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

                        ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

                        if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
                        {
                                ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
                        }
                        else wcscpy(IdleTimeString, TEXT("."));

                        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

                        // Logon Time
                        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
                        // We don't want to pass a 0 logon time to DateTimeString()
                        // It will blow up if the timezone is GMT
                        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                                pDoc->FixUnknownString(LogonTimeString);
                        }
                        else LogonTimeString[0] = '\0';

                        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

                        // Comment
                        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

                        if(m_CurrentSortColumn != AS_WS_COL_ID)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockWinStationList();

        if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

} // end CDomainWinStationsPage::UpdateWinStations


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddWinStationToList
//
int CDomainWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
        ASSERT(pWinStation);

        CServer *pServer = pWinStation->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        // Figure out which icon to use
        int WhichIcon = m_idxBlank;
        BOOL bCurrentWinStation = pWinStation->IsCurrentWinStation();

        if(pWinStation->GetState() != State_Disconnected
                && pWinStation->GetState() != State_Idle) {
                switch(pWinStation->GetSdClass()) {
                        case SdAsync:
                                if(pWinStation->IsDirectAsync())
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
                                else
                                        WhichIcon = bCurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
                                break;

                        case SdNetwork:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentNet : m_idxNet;
                                break;

                        default:
                                WhichIcon = bCurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
                                break;
                }
        }

        LockListControl();
        //////////////////////
        // Fill in the columns
        //////////////////////

        // Server Name
        int item = m_StationList.InsertItem(m_StationList.GetItemCount(), pServer->GetName(), WhichIcon);
        // WinStation Name
        if(pWinStation->GetName()[0])
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, pWinStation->GetName());
        else {
                CString NameString(" ");
                if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                m_StationList.SetItemText(item, AS_WS_COL_WINSTATION, NameString);
        }

        // User
        m_StationList.SetItemText(item, AS_WS_COL_USER, pWinStation->GetUserName());

        // Logon ID
        CString ColumnString;
        ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
        m_StationList.SetItemText(item, AS_WS_COL_ID, ColumnString);

        // Connect State
        m_StationList.SetItemText(item, AS_WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

        // Type
        m_StationList.SetItemText(item, AS_WS_COL_TYPE, pWinStation->GetWdName());

        // Client Name
        m_StationList.SetItemText(item, AS_WS_COL_CLIENTNAME, pWinStation->GetClientName());

        // Idle Time
        TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];
        if(pWinStation->GetState() == State_Active
                && pWinStation->GetLastInputTime().QuadPart <= pWinStation->GetCurrentTime().QuadPart)
        {
            LARGE_INTEGER DiffTime = CalculateDiffTime(pWinStation->GetLastInputTime(), pWinStation->GetCurrentTime());

            ULONG_PTR d_time = ( ULONG_PTR )DiffTime.QuadPart;
            ELAPSEDTIME IdleTime;
            // Calculate the days, hours, minutes, seconds since specified time.
            IdleTime.days = (USHORT)(d_time / 86400L); // days since
            d_time = d_time % 86400L;                  // seconds => partial day
            IdleTime.hours = (USHORT)(d_time / 3600L); // hours since
            d_time  = d_time % 3600L;                  // seconds => partial hour
            IdleTime.minutes = (USHORT)(d_time / 60L); // minutes since
            IdleTime.seconds = (USHORT)(d_time % 60L);// seconds remaining
            ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
            pWinStation->SetIdleTime(IdleTime);
        }
        else wcscpy(IdleTimeString, TEXT("."));

        m_StationList.SetItemText(item, AS_WS_COL_IDLETIME, IdleTimeString);

        // Logon Time
        TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
        // We don't want to pass a 0 logon time to DateTimeString()
        // It will blow up if the timezone is GMT
        if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
                DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
                pDoc->FixUnknownString(LogonTimeString);
        }
        else LogonTimeString[0] = '\0';

        m_StationList.SetItemText(item, AS_WS_COL_LOGONTIME, LogonTimeString);

        // Comment
        m_StationList.SetItemText(item, AS_WS_COL_COMMENT, pWinStation->GetComment());

        // Attach a pointer to the CWinStation structure to the list item
        m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

        //bug #191727
        //m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

        UnlockListControl();

        return item;

}  // end CDomainWinStationsPage::AddWinStationToList


////////////////////////////////////////
// F'N: CDomainWinStationsPage::AddServerToList
//
BOOL CDomainWinStationsPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        pServer->LockWinStationList();
        // Get a pointer to this server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();

        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();

        while(pos) {
                CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
                AddWinStationToList(pWinStation);
        }

        pServer->UnlockWinStationList();

    return TRUE;

}  // end CDomainWinStationsPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainWinStationsPage::DisplayStations
//
void CDomainWinStationsPage::DisplayStations()
{
        // Clear out the list control
        m_StationList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }
        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CDomainWinStationsPage::DisplayStations


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnColumnclick
//
void CDomainWinStationsPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainWinStationsPage::OnColumnclick


////////////////////////////////////////
// F'N: CDomainWinStationsPage::OnContextMenu
//
void CDomainWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_StationList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_StationList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_StationList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_WINSTATION_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainWinStationsPage::OnContextMenu

/////////////////////////////////////
// F'N: CDomainWinStationsPage::ClearSelections
//
void CDomainWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//////////////////////////////////
// MESSAGE MAP: CDomainProcessesPage
//
IMPLEMENT_DYNCREATE(CDomainProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainProcessesPage, CFormView)
        //{{AFX_MSG_MAP(CDomainProcessesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnclick)
        ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
        ON_WM_CONTEXTMENU()
        ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_PROCESS_LIST, OnKillfocusProcessList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CDomainProcessesPage ctor
//
CDomainProcessesPage::CDomainProcessesPage()
        : CAdminPage(CDomainProcessesPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainProcessesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainProcessesPage ctor


///////////////////////////////
// F'N: CDomainProcessesPage dtor
//
CDomainProcessesPage::~CDomainProcessesPage()
{
}  // end CDomainProcessesPage dtor


//////////////////////////////////////////
// F'N: CDomainProcessesPage::DoDataExchange
//
void CDomainProcessesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainProcessesPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
                DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
        //}}AFX_DATA_MAP

}  // end CDomainProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CDomainProcessesPage::AssertValid
//
void CDomainProcessesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainProcessesPage::AssertValid


////////////////////////////////
// F'N: CDomainProcessesPage::Dump
//
void CDomainProcessesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnSize
//
void CDomainProcessesPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_ProcessList.GetSafeHwnd())
            m_ProcessList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainProcessesPage::OnSize

static ColumnDef ProcColumns[] = {
        CD_SERVER,
        CD_USER,
        CD_SESSION,
        CD_PROC_ID,
        CD_PROC_PID,
        CD_PROC_IMAGE
};

#define NUM_DOMAIN_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnInitialUpdate
//
void CDomainProcessesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        // Add the column headings
        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_PROC_COLUMNS; col++) {
                columnString.LoadString(ProcColumns[col].stringID);
                m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_PROC_COL_SERVER;

}  // end CDomainProcessesPage::OnInitialUpdate


////////////////////////////////
// F'N: CDomainProcessesPage::Reset
//
void CDomainProcessesPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

        // We don't want to display processes until the user clicks
        // on the "Processes" tab
    m_pDomain = (CDomain*)pDomain;

}  // end CDomainProcessesPage::Reset


//////////////////////////////////////////
// F'N: CDomainProcessesPage::AddServer
//
void CDomainProcessesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's processes to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            LockListControl();
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
            UnlockListControl();
    }

}  // end CDomainProcessesPage::AddServer


//////////////////////////////////////////
// F'N: CDomainProcessesPage::RemoveServer
//
void CDomainProcessesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        LockListControl();

        int ItemCount = m_ProcessList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(item-1);
                CServer *pListServer = pProcess->GetServer();

                if(pListServer == pServer) {
                        m_ProcessList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

        UnlockListControl();

}  // end CDomainProcessesPage::RemoveServer


//////////////////////////////
// F'N: CDomainProcessesPage::UpdateServer
//
void CDomainProcessesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

} // end CDomainProcessesPage::UpdateServer


//////////////////////////////////////////
// F'N: CDomainProcessesPage::UpdateProcesses
//
void CDomainProcessesPage::UpdateProcesses(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        BOOL bAnyChanged = FALSE;
        BOOL bAnyAdded = FALSE;

        // Loop through the processes
        pServer->LockProcessList();
        CObList *pProcessList = pServer->GetProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                // If the process is new, add it to the list
                if(pProcess->IsNew()) {

                        if(AddProcessToList(pProcess) != -1)
                                bAnyAdded = TRUE;
                        continue;
                }

                LV_FINDINFO FindInfo;
                FindInfo.flags = LVFI_PARAM;
                FindInfo.lParam = (LPARAM)pProcess;

                // Find the Process in our list
                int item = m_ProcessList.FindItem(&FindInfo, -1);

                // If the process is no longer current,
                // remove it from the list
                if(!pProcess->IsCurrent() && item != -1) {
                        // Remove the Process from the list
                        m_ProcessList.DeleteItem(item);
                        pProcess->ClearSelected();
                }

                // If the process info has changed, change
                // it's info in our tree
                if(pProcess->IsChanged() && item != -1)
                {
                        // WinStation Name
                        CWinStation *pWinStation = pProcess->GetWinStation();
                        if(pWinStation)
                        {
                                if(pWinStation->GetName()[0])
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                                else
                                {
                                        CString NameString(" ");
                                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                                        m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                                }
                        }

                        if(m_CurrentSortColumn == AS_PROC_COL_WINSTATION)
                                bAnyChanged = TRUE;
                }
        }

        pServer->UnlockProcessList();

        if(bAnyChanged || bAnyAdded) {
                LockListControl();
                SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
                UnlockListControl();
        }

}  // end CDomainProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CDomainProcessesPage::RemoveProcess
//
void CDomainProcessesPage::RemoveProcess(CProcess *pProcess)
{
        ASSERT(pProcess);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pProcess->GetServer()->GetDomain()) return;

        LockListControl();

        // Find out how many items in the list
        int ItemCount = m_ProcessList.GetItemCount();

        // Go through the items and remove this process
        for(int item = 0; item < ItemCount; item++) {
                CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);

                if(pListProcess == pProcess) {
                        m_ProcessList.DeleteItem(item);
                        break;
                }
        }

        UnlockListControl();
}


//////////////////////////////////////////
// F'N: CDomainProcessesPage::AddProcessToList
//
int CDomainProcessesPage::AddProcessToList(CProcess *pProcess)
{
        ASSERT(pProcess);

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
        CServer *pServer = pProcess->GetServer();

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return -1;

        LockListControl();
        // Server - put at end of list
        int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetServer()->GetName(), NULL);

        // User
        m_ProcessList.SetItemText(item, AS_PROC_COL_USER, pProcess->GetUserName());

        // WinStation Name
        CWinStation *pWinStation = pProcess->GetWinStation();
        if(pWinStation) {
                if(pWinStation->GetName()[0])
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, pWinStation->GetName());
                else {
                        CString NameString(" ");
                        if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
                        if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
                    m_ProcessList.SetItemText(item, AS_PROC_COL_WINSTATION, NameString);
                }
        }

        // ID
        CString ProcString;
        ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
        m_ProcessList.SetItemText(item, AS_PROC_COL_ID, ProcString);

        // PID
        ProcString.Format(TEXT("%lu"), pProcess->GetPID());
        m_ProcessList.SetItemText(item, AS_PROC_COL_PID, ProcString);

        // Image
        m_ProcessList.SetItemText(item, AS_PROC_COL_IMAGE, pProcess->GetImageName());
        m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

        m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_SELECTED | LVIS_FOCUSED );

        UnlockListControl();

        return item;

}  // end CDomainProcessesPage::AddProcessToList


////////////////////////////////
// F'N: CDomainProcessesPage::AddServerToList
//
BOOL CDomainProcessesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

        pServer->EnumerateProcesses();
        CObList *pProcessList = pServer->GetProcessList();
        pServer->LockProcessList();

        POSITION pos = pProcessList->GetHeadPosition();

        while(pos) {
                CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

                // If this is a 'system' process and we aren't currently showing them,
                // go to the next process
                if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
                        continue;

                // If this user is not an Admin, don't show him someone else's processes unless it
                // is a System process
                if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
                        continue;

                AddProcessToList(pProcess);
        }

        pServer->UnlockProcessList();

    return TRUE;

}  // end CDomainProcessesPage::AddServerToList


////////////////////////////////
// F'N: CDomainProcessesPage::DisplayProcesses
//
void CDomainProcessesPage::DisplayProcesses()
{
        CWaitCursor Nikki;

        LockListControl();

        // Clear out the list control
        m_ProcessList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {

                CServer *pServer = (CServer*)pServerList->GetNext(pos);

                if(pServer->IsServerSane()) {
                        AddServerToList(pServer);
                }  // end if(pServer->IsServerSane())

        } // end while(pos)

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

        UnlockListControl();

}  // end CDomainProcessesPage::DisplayProcesses


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnProcessItemChanged
//
void CDomainProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

        if(pLV->uNewState & LVIS_SELECTED) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->SetSelected();
        }

        if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
                CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
                pProcess->ClearSelected();
        }

        *pResult = 0;

}  // end CDomainProcessesPage::OnProcessItemChanged


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnColumnclick
//
void CDomainProcessesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        LockListControl();
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
        UnlockListControl();

        *pResult = 0;

}  // end CDomainProcessesPage::OnColumnclick


//////////////////////////////////////////
// F'N: CDomainProcessesPage::OnContextMenu
//
void CDomainProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen)
{
        // TODO: Add your message handler code here
        UINT flags;
        UINT Item;
        CPoint ptClient = ptScreen;
        ScreenToClient(&ptClient);

        // If we got here from the keyboard,
        if(ptScreen.x == -1 && ptScreen.y == -1) {

                UINT iCount = m_ProcessList.GetItemCount( );

                RECT rc;

                for( Item = 0 ; Item < iCount ; Item++ )
                {
                        if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                        {
                                m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

                                ptScreen.x = rc.left;

                                ptScreen.y = rc.bottom + 5;

                                ClientToScreen( &ptScreen );

                                break;
                        }
                }

                if(ptScreen.x == -1 && ptScreen.y == -1)
                {
                        return;
                }
                /*
                RECT rect;
                m_ProcessList.GetClientRect(&rect);
                ptScreen.x = (rect.right - rect.left) / 2;
                ptScreen.y = (rect.bottom - rect.top) / 2;
                ClientToScreen(&ptScreen);
                */
        }
        else {
                Item = m_ProcessList.HitTest(ptClient, &flags);
                if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
                        return;
        }

        CMenu menu;
        menu.LoadMenu(IDR_PROCESS_POPUP);
        menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
                        TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
        menu.DestroyMenu();

}  // end CDomainProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CDomainLicensesPage
//
IMPLEMENT_DYNCREATE(CDomainLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CDomainLicensesPage, CFormView)
        //{{AFX_MSG_MAP(CDomainLicensesPage)
        ON_WM_SIZE()
        ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnclick)
        ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
        //ON_NOTIFY(NM_KILLFOCUS, IDC_LICENSE_LIST, OnKillfocusLicenseList)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CDomainLicensesPage ctor
//
CDomainLicensesPage::CDomainLicensesPage()
        : CAdminPage(CDomainLicensesPage::IDD)
{
        //{{AFX_DATA_INIT(CDomainLicensesPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_pDomain = NULL;
    m_bSortAscending = TRUE;

}  // end CDomainLicensesPage ctor


/////////////////////////////
// F'N: CDomainLicensesPage dtor
//
CDomainLicensesPage::~CDomainLicensesPage()
{

}  // end CDomainLicensesPage dtor


////////////////////////////////////////
// F'N: CDomainLicensesPage::DoDataExchange
//
void CDomainLicensesPage::DoDataExchange(CDataExchange* pDX)
{
        CFormView::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDomainLicensesPage)
        DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
        //}}AFX_DATA_MAP

}  // end CDomainLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CDomainLicensesPage::AssertValid
//
void CDomainLicensesPage::AssertValid() const
{
        CFormView::AssertValid();

}  // end CDomainLicensesPage::AssertValid


//////////////////////////////
// F'N: CDomainLicensesPage::Dump
//
void CDomainLicensesPage::Dump(CDumpContext& dc) const
{
        CFormView::Dump(dc);

}  // end CDomainLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////////////
// F'N: CDomainLicensesPage::OnSize
//
void CDomainLicensesPage::OnSize(UINT nType, int cx, int cy)
{
    RECT rect;
    GetClientRect(&rect);

    rect.top += LIST_TOP_OFFSET;

    if(m_LicenseList.GetSafeHwnd())
            m_LicenseList.MoveWindow(&rect, TRUE);

    // CFormView::OnSize(nType, cx, cy);

}  // end CDomainLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
        CD_SERVER,
        CD_LICENSE_DESC,
        CD_LICENSE_REG,
        CD_USERCOUNT,
        CD_POOLCOUNT,
        CD_LICENSE_NUM,
};

#define NUM_DOMAIN_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////////////
// F'N: CDomainLicensesPage::OnInitialUpdate
//
void CDomainLicensesPage::OnInitialUpdate()
{
        CFormView::OnInitialUpdate();

        BuildImageList();               // builds the image list for the list control

        CString columnString;

        for(int col = 0; col < NUM_DOMAIN_LICENSE_COLUMNS; col++) {
                columnString.LoadString(LicenseColumns[col].stringID);
                m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
        }

        m_CurrentSortColumn = AS_LICENSE_COL_SERVER;

}  // end CDomainLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CDomainLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CDomainLicensesPage::BuildImageList()
{
        m_ImageList.Create(16, 16, TRUE, 5, 0);

        m_idxBase = AddIconToImageList(IDI_BASE);
        m_idxBump = AddIconToImageList(IDI_BUMP);
        m_idxEnabler = AddIconToImageList(IDI_ENABLER);
        m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);

        m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CDomainLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CDomainLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CDomainLicensesPage::AddIconToImageList(int iconID)
{
        HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
        return m_ImageList.Add(hIcon);

}  // end CDomainLicensesPage::AddIconToImageList


/////////////////////////////////////
// F'N: CDomainLicensesPage::Reset
//
void CDomainLicensesPage::Reset(void *pDomain)
{
        ASSERT(pDomain);

    m_pDomain = (CDomain*)pDomain;
        DisplayLicenses();

}  // end CDomainLicensesPage::Reset


/////////////////////////////////////
// F'N: CDomainLicensesPage::AddServer
//
void CDomainLicensesPage::AddServer(CServer *pServer)
{
        ASSERT(pServer);

        // Add the Server's licenses to the list
        if(AddServerToList(pServer)) {
            // Sort the list
            SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);
    }

}  // end F'N: CDomainLicensesPage::AddServer


/////////////////////////////////////
// F'N: CDomainLicensesPage::RemoveServer
//
void CDomainLicensesPage::RemoveServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        int ItemCount = m_LicenseList.GetItemCount();

        // We need to go through the list backward so that we can remove
        // more than one item without the item numbers getting messed up
        for(int item = ItemCount; item; item--) {
                CLicense *pLicense = (CLicense*)m_LicenseList.GetItemData(item-1);
                CServer *pListServer = pLicense->GetServer();

                if(pListServer == pServer) {
                        m_LicenseList.DeleteItem(item-1);
                        pServer->ClearAllSelected();
                }
        }

}  // end CDomainLicensesPage::RemoveServer


//////////////////////////////
// F'N: CDomainLicensesPage::UpdateServer
//
void CDomainLicensesPage::UpdateServer(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return;

        if(pServer->IsState(SS_DISCONNECTING))
                RemoveServer(pServer);

        if(pServer->IsState(SS_GOOD))
                AddServer(pServer);

} // end CDomainLicensesPage::UpdateServer


/////////////////////////////////////
// F'N: CDomainLicensesPage::AddServerToList
//
BOOL CDomainLicensesPage::AddServerToList(CServer *pServer)
{
        ASSERT(pServer);

    // If the server isn't in the current domain, there's nothing to do
    if(m_pDomain != pServer->GetDomain()) return FALSE;

        int item;

        pServer->LockLicenseList();

        // Get a pointer to the Server's list of licenses
        CObList *pLicenseList = pServer->GetLicenseList();

        // Iterate through the License list
        POSITION pos = pLicenseList->GetHeadPosition();

        while(pos) {
                CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

                //////////////////////
                // Fill in the columns
                //////////////////////
                int WhichIcon;

                switch(pLicense->GetClass()) {
                        case LicenseBase:
                                WhichIcon = m_idxBase;
                                break;
                        case LicenseBump:
                                WhichIcon = m_idxBump;
                                break;
                        case LicenseEnabler:
                                WhichIcon = m_idxEnabler;
                                break;
                        case LicenseUnknown:
                                WhichIcon = m_idxUnknown;
                                break;
                }

                // Server Name
                item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pServer->GetName(), WhichIcon);

                // Description
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_DESCRIPTION, pLicense->GetDescription());

                // Registered
                CString RegString;
                RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_REGISTERED, RegString);

                BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
                        && pLicense->GetTotalCount() == 4095
                        && pServer->GetCTXVersionNum() == 0x00000040);

                // User (Total) Count
                CString CountString;
                if(bUnlimited)
                        CountString.LoadString(IDS_UNLIMITED);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());

                m_LicenseList.SetItemText(item, AS_LICENSE_COL_USERCOUNT, CountString);

                // Pool Count
                if(bUnlimited)
                        CountString.LoadString(IDS_NOT_APPLICABLE);
                else
                        CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_POOLCOUNT, CountString);

                // License Number
                m_LicenseList.SetItemText(item, AS_LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

                m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
        }  // end while(pos)

        m_LicenseList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
        
        pServer->UnlockLicenseList();

    return TRUE;

}  // end CDomainLicensesPage::AddServerToList


/////////////////////////////////////
// F'N: CDomainLicensesPage::DisplayLicenses
//
void CDomainLicensesPage::DisplayLicenses()
{
        // Clear out the list control
        m_LicenseList.DeleteAllItems();

        // Get a pointer to the document's list of servers
        CObList* pServerList = ((CWinAdminDoc*)GetDocument())->GetServerList();

        ((CWinAdminDoc*)GetDocument())->LockServerList();
        // Iterate through the server list
        POSITION pos = pServerList->GetHeadPosition();

        while(pos) {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                AddServerToList(pServer);
        }

        ((CWinAdminDoc*)GetDocument())->UnlockServerList();

}  // end CDomainLicensesPage::DisplayLicenses


/////////////////////////////////////
// F'N: CDomainLicensesPage::OnColumnclick
//
void CDomainLicensesPage::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult)
{
        NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
        // TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

        m_CurrentSortColumn = pNMListView->iSubItem;
        SortByColumn(VIEW_DOMAIN, PAGE_DOMAIN_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

        *pResult = 0;

}  // end CDomainLicensesPage::OnColumnclick


void CDomainUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainUsersPage::OnSetfocusUserList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;       
}

void CDomainProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainWinStationsPage::OnSetfocusWinstationList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainServersPage::OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainServersPage::OnSetfocusServerList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ServerList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CDomainLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    ODS( L"CDomainLicensesPage::OnSetfocusLicenseList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}


void CDomainUsersPage::OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_UserList.Invalidate( );
}

void CDomainProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ProcessList.Invalidate( );
}

void CDomainWinStationsPage::OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_StationList.Invalidate( );
}

void CDomainServersPage::OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ServerList.Invalidate( );
}

void CDomainLicensesPage::OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_LicenseList.Invalidate( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\domain.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domain.cpp
*
* implementation of the CDomain class
*
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "dialogs.h"
#include <malloc.h>                     // for alloca used by Unicode conversion macros
#include <mfc42\afxconv.h>           // for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define MIN_MAJOR_VERSION 4
#define MIN_MINOR_VERSION 0



//////////////////////////////////////////////////////////////////////////////////////////
//
//      CDomain Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////

CDomain::CDomain(TCHAR *name)
{
    m_Flags = 0;
    m_PreviousState = DS_NONE;
    m_State = DS_NONE;
    m_hTreeItem = NULL;
    wcscpy(m_Name, name);
    m_pBackgroundThread = NULL;    
}


CDomain::~CDomain()
{
        if(m_State == DS_ENUMERATING) StopEnumerating();

}


void CDomain::SetState(DOMAIN_STATE state)
{
        // remember the previous state
        m_PreviousState = m_State;

        m_State = state;

        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
        if(p && ::IsWindow(p->GetSafeHwnd())) {
                p->SendMessage(WM_ADMIN_UPDATE_DOMAIN, 0, (LPARAM)this);
        }
}


BOOL CDomain::StartEnumerating()
{
    BOOL bResult = FALSE;
    
    LockBackgroundThread();
    
    if( m_State == DS_ENUMERATING || m_State == DS_STOPPED_ENUMERATING )
    {
        UnlockBackgroundThread( );

        return FALSE;
    }

        // Fire off the background thread for this domain
    
    if( m_pBackgroundThread == NULL )
    {
        DomainProcInfo *pProcInfo = new DomainProcInfo;
        
        if( pProcInfo != NULL )
        {
            pProcInfo->pDomain = this;
            pProcInfo->pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
            m_BackgroundContinue = TRUE;
            m_pBackgroundThread = AfxBeginThread((AFX_THREADPROC)CDomain::BackgroundThreadProc,
                                                 pProcInfo,
                                                 0,
                                                 CREATE_SUSPENDED,
                                                 NULL );

            if( m_pBackgroundThread == NULL )
            {
                ODS( L"CDomain!StartEnumerating AfxBeginThread failed running low on resources\n" );

                delete pProcInfo;

                return FALSE;
            }

            m_pBackgroundThread->m_bAutoDelete = FALSE;

            if (m_pBackgroundThread->ResumeThread() <= 1)
            {
                bResult = TRUE;
            }
        }
    }
    
    UnlockBackgroundThread();
    
    return TRUE;
}


void CDomain::StopEnumerating()
{
    // Tell the background thread to terminate and
    // wait for it to do so.
    LockBackgroundThread();

    if(m_pBackgroundThread)
    {
        CWinThread *pBackgroundThread = m_pBackgroundThread;
        HANDLE hThread = m_pBackgroundThread->m_hThread;
        
        // Clear the pointer before releasing the lock
        m_pBackgroundThread = NULL;
        
        ClearBackgroundContinue( );

        UnlockBackgroundThread();
        
        // Wait for the thread's death
        if(WaitForSingleObject(hThread, 1000) == WAIT_TIMEOUT)
        {
            TerminateThread(hThread, 0);
        }

        WaitForSingleObject(hThread, INFINITE);
        
        // delete the CWinThread object
        delete pBackgroundThread;
    }
    else
    {
        UnlockBackgroundThread();
    }
    
    
    SetState(DS_STOPPED_ENUMERATING);

    DBGMSG( L"%s stopped enumerating\n" , GetName( ) );
}


USHORT Buflength(LPWSTR buf)
{
        LPWSTR p = buf;
        USHORT length = 0;

        while(*p) {
                USHORT plength = wcslen(p) + 1;
                length += plength;
                p += plength;
        }

        return length;

}       // end Buflength


LPWSTR ConcatenateBuffers(LPWSTR buf1, LPWSTR buf2)
{
        // Make sure both buffer pointers are valid
        if(!buf1 && !buf2) return NULL;
        if(buf1 && !buf2) return buf1;
        if(!buf1 && buf2) return buf2;

        // figure out how big a buffer we'll need
        USHORT buf1Length = Buflength(buf1);
        USHORT buf2Length = Buflength(buf2);
        USHORT bufsize = buf1Length + buf2Length + 1;
        // allocate a buffer
        LPWSTR pBuffer = (LPWSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, bufsize * sizeof(WCHAR));
    // If we can't allocate a buffer, free the second buffer and
    // return the pointer to the first of the two buffers
    if(!pBuffer) {
        LocalFree(buf2);
        return(buf1);
    }

        LPWSTR p = pBuffer;
        // copy the contents of the first buffer into the new buffer
        memcpy((char*)p, (char*)buf1, buf1Length * sizeof(WCHAR));
        p += buf1Length;
        // copy the contents of the second buffer into the new buffer
        memcpy((char*)p, (char*)buf2, buf2Length * sizeof(WCHAR));

        LocalFree(buf1);
        LocalFree(buf2);

        return pBuffer;

}       // end ConcatenateBuffers

void CDomain::CreateServers(LPWSTR pBuffer, LPVOID _pDoc)
{    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)_pDoc;
    CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
    
    LPWSTR pTemp = pBuffer;
    
    // Loop through all the WinFrame servers that we found
    while(*pTemp)
    {
        // The server's name is in pTemp
        // Find the server in our list
        CServer *pServer = pDoc->FindServerByName(pTemp);
        // If the server is in our list, set the flag to say we found it
        if(pServer)
        {
            pServer->SetBackgroundFound();

            if( pServer->GetTreeItem( ) == NULL )
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
                
                p->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pServer);
            }

        }
        else
        {
            // We don't want to add the current Server again
            if( lstrcmpi( pTemp , pApp->GetCurrentServerName() ) )
            {
                // Create a new server object
                CServer *pNewServer = new CServer(this, pTemp, FALSE, pDoc->ShouldConnect(pTemp));
                
                if(pNewServer != NULL )
                {
                    // Add the server object to our linked list
                    pDoc->AddServer(pNewServer);
                    
                    // Set the flag to say we found it
                    pNewServer->SetBackgroundFound();
                    
                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
                    
                    if(p && ::IsWindow(p->GetSafeHwnd()))
                    {
                        p->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pNewServer);                        
                        
                    }
                }
            }
        }
        // Go to the next server in the buffer
        pTemp += (wcslen(pTemp) + 1);
    } // end while (*pTemp)
    
}

/////////////////////////////////////////////////////////////////////////////
// CDomain::BackgroundThreadProc
//
// Static member function for background thread
// Looks for servers appearing and disappearing
// Called with AfxBeginThread
// Thread terminates when function returns
//
UINT CDomain::BackgroundThreadProc(LPVOID bg)
{
    // We need a pointer to the document so we can make
    // calls to member functions
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((DomainProcInfo*)bg)->pDoc;
    CDomain *pDomain = ((DomainProcInfo*)bg)->pDomain;
    delete bg;
    
    CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
    
    // We want to keep track of whether or not we've enumerated - so
    // that we can update the tree when we're done
    BOOL bNotified = FALSE;
    
    // We can't send messages to the view until they're ready
    // v-nicbd  RESOLVED  In case we are exiting tsadmin, we are waiting uselessly here
    //          - 500ms lapsed is negligible in UI
    while( !pDoc->AreAllViewsReady() )
    {
        Sleep(500);
    }
    
    // Don't do this until the views are ready!
    pDomain->SetState(DS_INITIAL_ENUMERATION);
    
    // If there is an extension DLL loaded, we will allow it to enumerate
    // additional servers
    LPFNEXENUMERATEPROC EnumerateProc = pApp->GetExtEnumerationProc();
    
    // The first time we enumerate servers, we want the CServer object
    // to put the server in the views when it has enough info.
    // On subsequent enumerations, we will add the server to the views
    // here.
    BOOL bSubsequent = FALSE;
    
    while(pDomain->ShouldBackgroundContinue())
    {
        
        BOOL Enumerated = FALSE;
        
        CObList TempServerList;
        
        DBGMSGx( L"CDomain!BackgroundThreadProc %s still going thread %d\n" , pDomain->GetName( ) , GetCurrentThreadId( ) );        
        
        // Loop through all the servers and turn off the flag
        // that tells this thread that he found it on this pass
        pDoc->LockServerList();
        CObList *pServerList = pDoc->GetServerList();
        
        POSITION pos = pServerList->GetHeadPosition();
        
        while(pos)
        {
            POSITION pos2 = pos;
            
            CServer *pServer = (CServer*)pServerList->GetNext(pos);
            
            if(pServer->GetDomain() == pDomain)
            {
                pServer->ClearBackgroundFound();
                
                // We want to remove a server if we could see it
                // the last time we enumerated servers
                // NOTE: This should not cause any problems
                //       The views should no longer have items pointing
                //       to this server at this point
                //
                // Move the server object to a temporary list.
                // This is so that we can unlock the server list before
                // we call the destructor on a CServer object since the
                // destructor will end up calling SetState() which does
                // a SendMessage.  This is not good to do with the list
                // locked.
                
                if(pServer->IsServerInactive() && !pServer->IsCurrentServer())
                {                    
                    pServer = (CServer*)pServerList->GetAt(pos2);
                    // Remove it from the server list
                    DBGMSG( L"Adding %s to temp list to destroy\n" , pServer->GetName( ) );
                    
                    pServerList->RemoveAt(pos2);
                    // Add it to our temporary list
                    TempServerList.AddTail(pServer);
                }
            }
        }
        
        pDoc->UnlockServerList();
        
        // do a first loop to signal the servers' background threads that they must stop
        pos = TempServerList.GetHeadPosition();
        while(pos)
        {
            CServer *pServer = (CServer*)TempServerList.GetNext(pos);
            
            DBGMSG( L"Clearing %s backgrnd cont\n", pServer->GetName() );
            
            pServer->ClearBackgroundContinue();
        }
        // do a second loop to disconnect and delete the servers
        pos = TempServerList.GetHeadPosition();
        
        while(pos)
        {
            CServer *pServer = (CServer*)TempServerList.GetNext(pos);
            
            DBGMSG( L"Disconnecting and deleteing %s now!!!\n", pServer->GetName( ) );
            
            pServer->Disconnect( );
            
            delete pServer;
            
            ODS( L"gone.\n" );
        }
        
        TempServerList.RemoveAll();
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            return 0;
        }
        
        // Get all the Servers now (we already got the current server)
        LPWSTR pBuffer = NULL;
        
        // Find all WinFrame servers in the domain
        pBuffer = pDomain->EnumHydraServers(/*pDomain->GetName(),*/ MIN_MAJOR_VERSION, MIN_MINOR_VERSION);
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            if(pBuffer) LocalFree(pBuffer);
            return 0;
        }
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            if(pBuffer) LocalFree(pBuffer);
            return 0;
        }
        
        if(pBuffer) {
            Enumerated = TRUE;
            
            pDomain->CreateServers(pBuffer, (LPVOID)pDoc);
            
            LocalFree(pBuffer);
        }       // end if(pBuffer)
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue()) return 0;
        
        if(!bNotified) {
            pDomain->SetState(DS_ENUMERATING);
            bNotified = TRUE;
        }
        
        // If there is an extension DLL loaded, allow it to enumerate additional servers
        LPWSTR pExtBuffer = NULL;
        
        if(EnumerateProc) {
            pExtBuffer = (*EnumerateProc)(pDomain->GetName());
        }
        
        // If the extension DLL found servers, concatenate the two buffers
        // The ConcatenateBuffers function will delete both buffers and return a
        // pointer to the new buffer
        if(pExtBuffer) {
            Enumerated = TRUE;
            pDomain->CreateServers(pExtBuffer, (LPVOID)pDoc);
            LocalFree(pExtBuffer);
        }
        
        // Make sure we don't have to quit
        if(!pDomain->ShouldBackgroundContinue())
        {
            return 0;
        }
        
        if(Enumerated)
        {
            // Mark the current server as found
            CServer *pCurrentServer = pDoc->GetCurrentServer();
            if(pCurrentServer) pCurrentServer->SetBackgroundFound();
            // Go through the list of servers and see which ones don't have
            // the flag set saying that we found it
            CObList TempList;
            
            pDoc->LockServerList();
            pServerList = pDoc->GetServerList();
            
            pos = pServerList->GetHeadPosition();
            
            while(pos)
            {
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                
                if(pServer->GetDomain() == pDomain)
                {
                    // we check to see if this server has been initially inserted to our server list
                    // manually. If so we don't want it inserted to our templist for deletion.
                    if( !pServer->IsManualFind() &&
                        ( !pServer->IsBackgroundFound() || 
                        pServer->HasLostConnection() ||
                        !pServer->IsServerSane() ) )
                    {
                        DBGMSG( L"Removing %s background not found or lost connection\n" , pServer->GetName( ) );
                        // Set the flag to say that this server is inactive
                        pServer->SetServerInactive();
                        // Add it to our temporary list
                        TempList.AddTail(pServer);
                    }
                }
            }
            
            pDoc->UnlockServerList();
            
            pos = TempList.GetHeadPosition();
            
            CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
            
            while(pos)
            {
                CServer *pServer = (CServer*)TempList.GetNext(pos);
                // Send a message to the mainframe to remove the server
                if(p && ::IsWindow(p->GetSafeHwnd()))
                {
                    DBGMSG( L"CDomain!Bkthrd removing %s temped threads from treeview & view\n" , pServer->GetName( ) );
                    
                    // clean up old node
                    if( pServer->GetTreeItemFromFav( ) != NULL )
                    {
                        // we cannot keep a favnode around if a server node is being deleted
                        // massive AV's will occurr.  So a quick fix is to remove the favnode 
                        // if it exists and create a new server node and mark it as manually
                        // found.  This will prevent this server node from being removed in 
                        // case NetEnumServer fails to pick up this server
                        p->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , TRUE , ( LPARAM )pServer );                   
                        
                        CServer *ptServer = new CServer( pDomain , pServer->GetName( ) , FALSE , FALSE );
                        
                        if( ptServer != NULL )
                        {
                            ptServer->SetManualFind( );
                            
                            pDoc->AddServer(ptServer);
                            
                            p->SendMessage(WM_ADMIN_ADDSERVERTOFAV , 0 , (LPARAM)ptServer);
                        }
                    }
                    
                    p->SendMessage(WM_ADMIN_REMOVE_SERVER, TRUE, (LPARAM)pServer);       
                }
            }
            
            TempList.RemoveAll();
            
        } // end if(Enumerated)
        
        // We don't want to do this constantly, it eats up processor cycles to enumerate servers
        // so we'll now let the user refresh these servers manually
        // Document destructor will signal the event to wake us up if he
        // wants us to quit
        pDomain->m_WakeUpEvent.Lock( INFINITE );
        
        bSubsequent = TRUE;
    }   // end while(1)
    
    return 0;
    
}       // end CDomain::BackgroundThreadProc



/*******************************************************************************
 *
 *      EnumHydraServers - Hydra helper function (taken from utildll and modified
 *      to be used along with a version check.
 *
 *      Enumerate the Hydra servers on the network by Domain
 *      Returns all the servers whose version is >= the version passed.
 *
 *  ENTRY:
 *      pDomain (input)
 *          Specifies the domain to enumerate; NULL for current domain.
 *      verMajor (input)
 *          specifies the Major version to check for.
 *      verMinor (input)
 *          specifies the minor version to check for.
 *
 *  EXIT:
 *      (LPTSTR) Points to LocalAlloced buffer containing results of the
 *               enumeration, in multi-string format, if sucessful; NULL if
 *               error.  The caller must perform a LocalFree of this buffer
 *               when done.  If error (NULL), the error code is set for
 *               retrieval by GetLastError();
 *
 ******************************************************************************/
LPWSTR CDomain::EnumHydraServers( /*LPWSTR pDomain,*/ DWORD verMajor, DWORD verMinor )

{
    PSERVER_INFO_101 pInfo = NULL;
    DWORD dwByteCount, dwIndex, TotalEntries;
    DWORD AvailCount = 0;
    LPWSTR pTemp, pBuffer = NULL;

    /*
     * Enumerate all WF servers on the specified domain.
     */
    if ( NetServerEnum ( NULL,
                         101,
                         (LPBYTE *)&pInfo,
                         (DWORD) -1,
                         &AvailCount,
                         &TotalEntries,
                         SV_TYPE_TERMINALSERVER,
                         m_Name, /*pDomain,*/
                         NULL ) ||
         !AvailCount )
        goto done;

    //
    // Traverse list of the servers that match the major and minor versions'criteria
    // and calculate the total byte count for list of
    // servers that will be returned.
    //
    for( dwByteCount = dwIndex = 0; dwIndex < AvailCount; dwIndex++ )
    {
        if( ((pInfo[dwIndex].sv101_version_major & MAJOR_VERSION_MASK) >=
            verMajor) && (pInfo[dwIndex].sv101_version_minor >= verMinor) )
        {
            dwByteCount += (wcslen(pInfo[dwIndex].sv101_name) + 1) * 2;
        }
    }

    dwByteCount += 2;   // for ending null

    /*
     * Allocate memory.
     */
    if( (pBuffer = (LPWSTR)LocalAlloc(LPTR, dwByteCount)) == NULL )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto done;
    }

    /*
     * Traverse list again and copy servers to buffer.
     */
    for( pTemp = pBuffer, dwIndex = 0; dwIndex < AvailCount; dwIndex++ )
    {
        if( ((pInfo[dwIndex].sv101_version_major & MAJOR_VERSION_MASK) >=
            verMajor) && (pInfo[dwIndex].sv101_version_minor >= verMinor) )
        {
            // MS Bug 1821
            if ( wcslen(pInfo[dwIndex].sv101_name) != 0 )
            {
                wcscpy(pTemp, pInfo[dwIndex].sv101_name);

                pTemp += (wcslen(pInfo[dwIndex].sv101_name) + 1);
            }
        }
    }
    *pTemp = L'\0';     // ending null
    
done:
    if( AvailCount && pInfo )
    {
        NetApiBufferFree( pInfo );
    }
    
    return(pBuffer);
    
}  // end CDomain::EnumHydraServers


/////////////////////////////////////////////////////////////////////////////
// CDomain::DisconnectAllServers
//
// Disconnect from all servers in this Domain
//
void CDomain::DisconnectAllServers()
{
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CObList *pServerList = pDoc->GetServerList();

    CString AString;
        CDialog dlgWait;
        dlgWait.Create(IDD_SHUTDOWN, NULL);


        pDoc->LockServerList();

    ODS( L"TSADMIN:CDomain::DisconnectAllServers about to disconnect all connected servers\n" );

    // Do a first loop to signal the server background threads that they must stop
        POSITION pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is in the domain and connected, tell the server background thread to stop
                if(pServer->GetDomain() == this
                        && pServer->GetState() != SS_NOT_CONNECTED) {
            pServer->ClearBackgroundContinue();
        }
        }
    // do a second loop to disconnect the servers
        pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is in the domain and connected, disconnect from it
                if ((pServer->GetDomain() == this) && (pServer->GetState() != SS_NOT_CONNECTED)) {
                        AString.Format(IDS_DISCONNECTING, pServer->GetName());
                        dlgWait.SetDlgItemText(IDC_SHUTDOWN_MSG, AString);

                        // Tell the server to connect
                pServer->Disconnect();
                }
        }

    //
    // tell domain not to connect to any more servers
    //


        pDoc->UnlockServerList();

        dlgWait.PostMessage(WM_CLOSE);

}       // end CDomain::DisconnectAllServers


/////////////////////////////////////////////////////////////////////////////
// CDomain::ConnectAllServers
//
// Connect to all servers in this Domain
//
void CDomain::ConnectAllServers()
{
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        CObList *pServerList = pDoc->GetServerList();

        pDoc->LockServerList();

        POSITION pos = pServerList->GetHeadPosition();
        while(pos) {
                // Get a pointer to the server
                CServer *pServer = (CServer*)pServerList->GetNext(pos);
                // If this Server is int the domain and not connected, connect to it
                if(pServer->GetDomain() == this
                        && pServer->IsState(SS_NOT_CONNECTED)) {
                // Tell the server to connect
                    pServer->Connect();
                }
        }

        pDoc->UnlockServerList();

}       // end CDomain::ConnectAllServers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\domainpg.h ===
/*******************************************************************************
*
* domainpg.h
*
* - declarations for the Domain info pages
* - the Domain info pages are all CFormView derivatives
* based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\domainpg.h  $
*  
*     Rev 1.1   19 Jan 1998 16:47:40   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.0   03 Nov 1997 15:07:28   donm
*  Initial revision.
*  
*  
*******************************************************************************/


#ifndef _DOMAINPAGES_H
#define _DOMAINPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"


//////////////////////////
// CLASS: CDomainServersPage
//
class CDomainServersPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainServersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainServersPage)

// Form Data
public:
	//{{AFX_DATA(CDomainServersPage)
	enum { IDD = IDD_ALL_SERVER_SERVERS };
	CListCtrl	m_ServerList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxServer;		// index of Server image
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxNotSign;		// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayServers();			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainServersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainServersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainServersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnServerItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusServerList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainServersPage


//////////////////////////
// CLASS: CDomainUsersPage
//
class CDomainUsersPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainUsersPage)

// Form Data
public:
	//{{AFX_DATA(CDomainUsersPage)
	enum { IDD = IDD_ALL_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers();			
	virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainUsersPage


//////////////////////////
// CLASS: CDomainWinStationsPage
//
class CDomainWinStationsPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CDomainWinStationsPage)
	enum { IDD = IDD_ALL_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:
    
protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
    virtual void ClearSelections();
protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateWinStations(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations();			
    virtual void Reset(void *);
	BOOL AddServerToList(CServer *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainWinStationsPage


////////////////////////////
// CLASS: CDomainProcessesPage
//
class CDomainProcessesPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CDomainProcessesPage)
	enum { IDD = IDD_ALL_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);
	void UpdateProcesses(CServer *pServer);
	void RemoveProcess(CProcess *pProcess);

private:
	virtual void Reset(void *);
	void DisplayProcesses();			
	BOOL AddServerToList(CServer *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainProcessesPage


//////////////////////////
// CLASS: CDomainLicensesPage
//
class CDomainLicensesPage : public CAdminPage
{
friend class CDomainView;

protected:
	CDomainLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CDomainLicencesPage)
	enum { IDD = IDD_DOMAIN_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image

private:
    CDomain *m_pDomain;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

protected:
	void AddServer(CServer *pServer);
	void RemoveServer(CServer *pServer);
	void UpdateServer(CServer *pServer);

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	virtual void Reset(void*);
	BOOL AddServerToList(CServer *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CDomainLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainLicensesPage


#endif  // _DOMAINPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\domainvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domainvw.h
*
* declarations for the CDomainView class
*
*  
*******************************************************************************/

#ifndef _DOMAINVIEW_H
#define _DOMAINVIEW_H

#include "domainpg.h"

const int NUMBER_OF_DOMAIN_PAGES = 5;


////////////////////
// CLASS: CDomainView
//
class CDomainView : public CAdminView
{
friend class CRightPane;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;

		
protected:
	CDomainView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CDomainView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_DOMAIN_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CDomainView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	// Generated message map functions
protected:
	//{{AFX_MSG(CDomainView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CDomainView

#endif  // _DOMAINVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\led.h ===
/*******************************************************************************
*
* led.h
*
* interface of CLed class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Butch Davis
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\LED.H  $
*  
*     Rev 1.0   30 Jul 1997 17:11:38   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef LED_INCLUDED
////////////////////////////////////////////////////////////////////////////////
// CLed class
//
class CLed : public CStatic
{

/*
 * Member variables.
 */
	//{{AFX_DATA(CLed)
	//}}AFX_DATA
private:
    HBRUSH          m_hBrush;
    BOOL            m_bOn;

/* 
 * Implementation.
 */
public:
	CLed( HBRUSH hBrush );

/*
 * Operations.
 */
public:
    void Subclass( CStatic *pStatic );
    void Update(int nOn);
    void Toggle();

/*
 * Message map / commands.
 */
protected:
	//{{AFX_MSG(CLed)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end CLed class interface 
////////////////////////////////////////////////////////////////////////////////
#endif  // LED_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\domainvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* domainvw.cpp
*
* implementation of the CDomainView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "domainvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


PageDef CDomainView::pages[] = {
	{ NULL, RUNTIME_CLASS( CDomainServersPage ),    IDS_TAB_SERVERS,     PAGE_DOMAIN_SERVERS,	PF_PICASSO_ONLY},
	{ NULL, RUNTIME_CLASS( CDomainUsersPage ),      IDS_TAB_USERS,       PAGE_DOMAIN_USERS,		NULL           },
	{ NULL, RUNTIME_CLASS( CDomainWinStationsPage ),IDS_TAB_WINSTATIONS, PAGE_DOMAIN_WINSTATIONS,NULL           },
	{ NULL, RUNTIME_CLASS( CDomainProcessesPage ),  IDS_TAB_PROCESSES,   PAGE_DOMAIN_PROCESSES,	NULL           },
	{ NULL, RUNTIME_CLASS( CDomainLicensesPage ),   IDS_TAB_LICENSES,    PAGE_DOMAIN_LICENSES,	PF_PICASSO_ONLY}    
};


//////////////////////////
// MESSAGE MAP: CDomainView
//
IMPLEMENT_DYNCREATE(CDomainView, CView)

BEGIN_MESSAGE_MAP(CDomainView, CView)
	//{{AFX_MSG_MAP(CDomainView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_WA_SERVER_CHANGEPAGE, OnChangePage)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_DOMAIN_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
END_MESSAGE_MAP()


///////////////////////
// F'N: CDomainView ctor
//
CDomainView::CDomainView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_DOMAIN_USERS;

}  // end CDomainView ctor


///////////////////////
// F'N: CDomainView dtor
//
CDomainView::~CDomainView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CDomainView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CDomainView::AssertValid
//
void CDomainView::AssertValid() const
{
	CView::AssertValid();

}  // end CDomainView::AssertValid


////////////////////////
// F'N: CDomainView::Dump
//
void CDomainView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CDomainView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CDomainView::OnCreate
//
int CDomainView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CDomainView::OnCreate


///////////////////////////////////
// F'N: CDomainView::OnInitialUpdate
//
//
void CDomainView::OnInitialUpdate() 
{
    // Determine whether we are running under Picasso
    BOOL bPicasso = ((CWinAdminApp*)AfxGetApp())->IsPicasso();

    // create the Tabs
    m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
    m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_DOMAIN_TABS);


    m_pTabFont = new CFont;
    if(m_pTabFont) {
        m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
        m_pTabs->SetFont(m_pTabFont, TRUE);
    }

    TCHAR szTemp[40];
    CString tabString;

    int index = 0;
    for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
        // If the page is shown under Picasso only and we're not running
        // under Picasso, skip to the next one
        if((pages[i].flags & PF_PICASSO_ONLY) && !bPicasso) continue;
        tabString.LoadString(pages[i].tabStringID);
        lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
        AddTab(index, szTemp, i);
        pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
        pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
        GetDocument()->AddView(pages[i].m_pPage);
        index++;
    }

    m_pTabs->SetCurSel(0);	

    m_CurrPage = bPicasso ? PAGE_DOMAIN_SERVERS : PAGE_DOMAIN_USERS;

	// post a changepage msg to display the page for the currently selected tab
//	PostMessage(WM_WA_SERVER_CHANGEPAGE);

}  // end CDomainView::OnInitialUpdate


//////////////////////////
// F'N: CDomainView::OnSize
//
// 
//
void CDomainView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the Tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}

}  // end CDomainView::OnSize


//////////////////////////
// F'N: CDomainView::OnDraw
//
// - the CDomainView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CDomainView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CDomainView::OnDraw


/////////////////////////
// F'N: CDomainView::Reset
//
// - 'resets' the view
//
void CDomainView::Reset(void *p)
{
	CWaitCursor Nikki;
	SendMessage(WM_WA_SERVER_CHANGEPAGE);	// ???	Post

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// This is necessary until we update on the fly
	for(int i = 0; i < NUMBER_OF_DOMAIN_PAGES; i++) {
		if(pages[i].m_pPage)
			pages[i].m_pPage->Reset(p);
	}

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CDomainView::Reset


//////////////////////////
// F'N: CDomainView::AddTab
//
void CDomainView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CDomainView::AddTab


////////////////////////////////
// F'N: CDomainView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
// If wParam is set, sets the focus to the page. This is currently
// only done when the user clicks on a tab
//
LRESULT CDomainView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
				
	// switch to the appropriate view
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(index);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();
	if(wParam) pages[index].m_pPage->SetFocus();

	// Clear out the selected flags for each server
	// Get a pointer to our document
	CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();

	// Get a pointer to the list of servers
	doc->LockServerList();
	CObList *pServerList = doc->GetServerList();

	// Iterate through the Server list
	POSITION pos = pServerList->GetHeadPosition();

	while(pos) {
		CServer *pServer = (CServer*)pServerList->GetNext(pos);
		pServer->ClearAllSelected();
	}

	doc->UnlockServerList();

	// If the new page is the processes page, we want to display the processes now
	if(index == PAGE_DOMAIN_PROCESSES) ((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CDomainView::OnChangeview


void CDomainView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage(0L, NULL);
	*pResult = 0;

}  // end CDomainView::OnTabSelChange


LRESULT CDomainView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->AddServer((CServer*)lParam);
	}		
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->AddServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->AddServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->AddServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->AddServer((CServer*)lParam);
    }
	
	return 0;

}  // end CDomainView::OnAdminAddServer


LRESULT CDomainView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->RemoveServer((CServer*)lParam);
	}
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->RemoveServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->RemoveServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->RemoveServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->RemoveServer((CServer*)lParam);
    }

	return 0;

}  // end CDomainView::OnAdminRemoveServer


LRESULT CDomainView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage) {
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);
	}
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->UpdateServer((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->UpdateServer((CServer*)lParam);
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->UpdateServer((CServer*)lParam);

    if(pages[PAGE_DOMAIN_LICENSES].m_pPage) {
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->UpdateServer((CServer*)lParam);
    }

	return 0;

}  // end CDomainView::OnAdminUpdateServer


LRESULT CDomainView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->UpdateProcesses((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateProcesses


LRESULT CDomainView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CDomainView::OnAdminRemoveProcess


LRESULT CDomainView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	((CDomainProcessesPage*)pages[PAGE_DOMAIN_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CDomainView::OnAdminRedisplayProcesses


LRESULT CDomainView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CDomainUsersPage*)pages[PAGE_DOMAIN_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CDomainWinStationsPage*)pages[PAGE_DOMAIN_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateWinStations


LRESULT CDomainView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_DOMAIN_SERVERS].m_pPage)
		((CDomainServersPage*)pages[PAGE_DOMAIN_SERVERS].m_pPage)->UpdateServer((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminUpdateServerInfo
 

LRESULT CDomainView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
    if(pages[PAGE_DOMAIN_LICENSES].m_pPage)
        ((CDomainLicensesPage*)pages[PAGE_DOMAIN_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CDomainView::OnAdminRedisplayLicenses

LRESULT CDomainView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CDomainView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CDomainView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CDomainView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CDomainView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CDomainView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CDomainView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\mainfrm.cpp ===
/*******************************************************************************
*
* mainfrm.cpp
*
* implementation of the CMainFrame class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "afxcview.h"
#include "winadmin.h"
#include "admindoc.h"
#include "treeview.h"
#include "rtpane.h"
#include "dialogs.h"
#include "htmlhelp.h"
#include "mainfrm.h"
#include <winsock2.h>

#include <dsrole.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef _STRESS_BUILD
DWORD RunStress( PVOID pv );
DWORD RunStressLite( PVOID pv );
BOOL g_fWaitForAllServersToDisconnect = 1;
#endif

INT_PTR CALLBACK FWarnDlg( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp );
/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_MESSAGE(WM_ADMIN_CHANGEVIEW, OnAdminChangeView) 
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
	ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
	ON_MESSAGE(WM_ADMIN_UPDATE_DOMAIN, OnAdminUpdateDomain)
    ON_MESSAGE(WM_ADMIN_ADD_DOMAIN, OnAdminAddDomain)
	ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
    ON_MESSAGE(WM_FORCE_TREEVIEW_FOCUS , OnForceTreeViewFocus )

    ON_MESSAGE( WM_ADMIN_ADDSERVERTOFAV , OnAdminAddServerToFavorites )
    ON_MESSAGE( WM_ADMIN_REMOVESERVERFROMFAV , OnAdminRemoveServerFromFavs )
    ON_MESSAGE( WM_ADMIN_GET_TV_STATES , OnAdminGetTVStates )
    ON_MESSAGE( WM_ADMIN_UPDATE_TVSTATE , OnAdminUpdateTVStates )

	ON_COMMAND(IDM_EXPAND_ALL, OnExpandAll)
	ON_COMMAND(IDM_REFRESH, OnRefresh)
	ON_COMMAND(IDM_CONNECT, OnConnect)
	ON_COMMAND(IDM_DISCONNECT, OnDisconnect)
	ON_COMMAND(IDM_MESSAGE, OnSendMessage)
	ON_COMMAND(IDM_SHADOW, OnShadow)
	ON_COMMAND(IDM_RESET, OnReset)
	ON_COMMAND(IDM_STATUS, OnStatus)
	ON_COMMAND(IDTM_CONNECT, OnTreeConnect)
	ON_COMMAND(IDTM_DISCONNECT, OnTreeDisconnect)
	ON_COMMAND(IDTM_MESSAGE, OnTreeSendMessage)
	ON_COMMAND(IDTM_SHADOW, OnTreeShadow)
	ON_COMMAND(IDTM_RESET, OnTreeReset)
	ON_COMMAND(IDTM_STATUS, OnTreeStatus)
	ON_COMMAND(IDM_LOGOFF, OnLogoff)
	ON_COMMAND(IDM_TERMINATE, OnTerminate)
	ON_COMMAND(IDM_PREFERENCES, OnPreferences)
	ON_COMMAND(IDM_COLLAPSE_ALL, OnCollapseAll)
	ON_COMMAND(IDM_COLLAPSE_TOSERVERS, OnCollapseToServers)
    ON_COMMAND(IDM_COLLAPSE_TODOMAINS, OnCollapseToDomains)
	ON_COMMAND(IDM_SHOW_SYSTEM_PROCESSES, OnShowSystemProcesses)
    ON_COMMAND(IDM_SERVER_CONNECT, OnServerConnect)
    ON_COMMAND(IDM_SERVER_DISCONNECT, OnServerDisconnect)

    ON_COMMAND( IDTM_DOMAIN_FIND_SERVER , OnFindServer )

    ON_COMMAND(IDM_SERVER_ADDTOFAV , OnAddToFavorites )
    ON_COMMAND(IDM_SERVER_REMOVEFAV , OnRemoveFromFavs )
    ON_COMMAND( IDM_ALLSERVERS_EMPTYFAVORITES , OnEmptyFavorites )


	ON_COMMAND(IDTM_DOMAIN_CONNECT_ALL, OnTreeDomainConnectAllServers)
	ON_COMMAND(IDTM_DOMAIN_DISCONNECT_ALL, OnTreeDomainDisconnectAllServers)
	ON_COMMAND(IDTM_DOMAIN_FIND_SERVERS, OnTreeDomainFindServers)
	ON_COMMAND(IDM_DOMAIN_CONNECT_ALL, OnDomainConnectAllServers)
	ON_COMMAND(IDM_DOMAIN_DISCONNECT_ALL, OnDomainDisconnectAllServers)
	ON_COMMAND(IDM_ALLSERVERS_CONNECT, OnAllServersConnect)
	ON_COMMAND(IDM_ALLSERVERS_DISCONNECT, OnAllServersDisconnect)
	ON_COMMAND(IDM_ALLSERVERS_FIND, OnAllServersFind)
	ON_UPDATE_COMMAND_UI(IDM_CONNECT, OnUpdateConnect)
	ON_UPDATE_COMMAND_UI(IDM_DISCONNECT, OnUpdateDisconnect)
	ON_UPDATE_COMMAND_UI(IDM_LOGOFF, OnUpdateLogoff)
	ON_UPDATE_COMMAND_UI(IDM_MESSAGE, OnUpdateMessage)
	ON_UPDATE_COMMAND_UI(IDM_RESET, OnUpdateReset)
	ON_UPDATE_COMMAND_UI(IDM_SHADOW, OnUpdateShadow)
	ON_UPDATE_COMMAND_UI(IDM_STATUS, OnUpdateStatus)
	ON_UPDATE_COMMAND_UI(IDM_TERMINATE, OnUpdateTerminate)
    ON_UPDATE_COMMAND_UI(IDM_SERVER_CONNECT, OnUpdateServerConnect)
    ON_UPDATE_COMMAND_UI(IDM_SERVER_DISCONNECT, OnUpdateServerDisconnect)

    ON_UPDATE_COMMAND_UI( IDM_SERVER_ADDTOFAV , OnUpdateServerAddToFavorite )
    ON_UPDATE_COMMAND_UI( IDM_SERVER_REMOVEFAV , OnUpdateServerRemoveFromFavorite )

	ON_UPDATE_COMMAND_UI(IDTM_CONNECT, OnUpdateTreeConnect)
	ON_UPDATE_COMMAND_UI(IDTM_DISCONNECT, OnUpdateTreeDisconnect)
	ON_UPDATE_COMMAND_UI(IDTM_MESSAGE, OnUpdateTreeMessage)
	ON_UPDATE_COMMAND_UI(IDTM_RESET, OnUpdateTreeReset)
	ON_UPDATE_COMMAND_UI(IDTM_SHADOW, OnUpdateTreeShadow)
	ON_UPDATE_COMMAND_UI(IDTM_STATUS, OnUpdateTreeStatus)
	ON_UPDATE_COMMAND_UI(IDM_SHOW_SYSTEM_PROCESSES, OnUpdateShowSystemProcesses)
	ON_UPDATE_COMMAND_UI_RANGE(IDM_DOMAIN_CONNECT_ALL, IDM_DOMAIN_DISCONNECT_ALL, OnUpdateDomainMenu)
	ON_UPDATE_COMMAND_UI_RANGE(IDTM_DOMAIN_CONNECT_ALL, IDTM_DOMAIN_DISCONNECT_ALL, OnUpdateDomainPopupMenu)
	ON_UPDATE_COMMAND_UI(IDTM_DOMAIN_FIND_SERVERS, OnUpdateDomainPopupFind)
	ON_UPDATE_COMMAND_UI(IDM_REFRESH, OnUpdateRefresh)

    ON_UPDATE_COMMAND_UI( IDM_ALLSERVERS_EMPTYFAVORITES , OnUpdateEmptyFavs )

    ON_COMMAND( ID_TAB , OnTab )
    ON_COMMAND( ID_SHIFTTAB , OnShiftTab )
    ON_COMMAND( ID_CTRLTAB , OnCtrlTab )
    ON_COMMAND( ID_CTRLSHIFTTAB , OnCtrlShiftTab )
    ON_COMMAND( ID_NEXTPANE , OnNextPane )
    ON_COMMAND( ID_PREVPANE , OnNextPane )
    ON_COMMAND( ID_DELKEY , OnDelFavNode )
#ifdef _STRESS_BUILD
    ON_COMMAND( IDM_ALLSERVERS_FAVALLADD , OnAddAllServersToFavorites )
    ON_COMMAND( IDM_ALLSERVERS_RUNSTRESS , OnRunStress )
    ON_COMMAND( IDM_ALLSERVERS_RUNSTRESSLITE, OnRunStressLite )
#endif
    ON_WM_CLOSE()	
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, OnHtmlHelp)
	ON_COMMAND(ID_HELP, OnHtmlHelp)
//	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
//	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
    
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	m_pLeftPane = NULL;
	m_pRightPane = NULL;
}


CMainFrame::~CMainFrame()
{

}

void CMainFrame::OnHtmlHelp()
{
	TCHAR * pTsAdminHelp = L"ts_adm_topnode.htm";
	HtmlHelp(AfxGetMainWnd()->m_hWnd,L"TSAdmin.Chm",HH_DISPLAY_TOPIC,(DWORD_PTR)pTsAdminHelp);
}


/*LRESULT CMainFrame::OnHelp(WPARAM wParam, LPARAM lParam)
{
	CFrameWnd::WinHelp(0L, HELP_FINDER);
	return TRUE;
}
*/

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
//		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
//		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// If there is an extension DLL, call it's startup function
	LPFNEXSTARTUPPROC StartupProc = ((CWinAdminApp*)AfxGetApp())->GetExtStartupProc();
	if(StartupProc) {
		(*StartupProc)(this->GetSafeHwnd());
	}

    DWORD dwTid;

    HANDLE hThread = CreateThread( NULL , 0 , ( LPTHREAD_START_ROUTINE  )CMainFrame::InitWarningThread,  GetSafeHwnd() , 0 , &dwTid );

    CloseHandle( hThread );


	return 0;
}  // end CMainFrame::OnCreate


BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
{
	BOOL rtn;

	rtn  = m_wndSplitter.CreateStatic(this, 1, 2);
#ifdef PUBLISHED_APPS
	if(((CWinAdminApp*)AfxGetApp())->IsPicasso()) {
		rtn |= m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CLeftPane),
										CSize(((CWinAdminApp *)AfxGetApp())->GetTreeWidth(), 300), pContext);
	} else 	{
#else
    {
#endif
		rtn |= m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CAdminTreeView),
										CSize(((CWinAdminApp *)AfxGetApp())->GetTreeWidth(), 300), pContext);
	}

	rtn |= m_wndSplitter.CreateView(0, 1, RUNTIME_CLASS(CRightPane),
									CSize(0, 0), pContext);

	m_pLeftPane = m_wndSplitter.GetPane(0, 0);
	m_pRightPane = m_wndSplitter.GetPane(0, 1);

   	return rtn;
}  // end CMainFrame::OnCreateClient


BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.x = 3;
	cs.y = 3;
	cs.cx = 635;
	cs.cy = 444;
   
	return CFrameWnd::PreCreateWindow(cs);
}  // end CMainFrame::PreCreateWindow


/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}


void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG


/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/////////////////////////////////////                                          
// F'N: CMainFrame::OnAdminChangeView                                            
//                                                                             
// - handles the custom message WM_ADMIN_CHANGEVIEW                              
// - this message is sent to the mainframe by CAdminTreeView when a new tree      
//   item is selected                                                          
// - lParam holds the info structure for the newly selected tree node          
//   and is handed along to CRightPane as the lParam of another                
//   WM_WA_CHANGEVIEW message, which CRightPane then handles as it            
//   sees fit                                                                  
//                                                                             
LRESULT CMainFrame::OnAdminChangeView(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the right pane to change his view
	m_pRightPane->SendMessage(WM_ADMIN_CHANGEVIEW, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminChangeView   


/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddServer
//  
LRESULT CMainFrame::OnAdminAddServer(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to add server
	m_pLeftPane->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);  
    
	// tell the right pane to add server
	m_pRightPane->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);  
	
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminAddServer

/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveServer
//                                  
// wParam - TRUE if server disappeared, FALSE if via Server Filtering
// lParam - CServer to remove
LRESULT CMainFrame::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)              
{     
	ASSERT(lParam);

    ODS( L"CMainFrame!OnAdminRemoveServer\n" );

#if 0
	if(wParam) {
		// Is this the currently selected server?
		CWinAdminDoc *doc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
		if((CObject*)lParam == doc->GetCurrentSelectedNode()) {
			CString TitleString;
			CString MessageString;

			TitleString.LoadString(AFX_IDS_APP_TITLE);
			MessageString.Format(IDS_SERVER_DISAPPEARED, ((CServer*)lParam)->GetName());
			MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);
		}
	}
#endif
	// tell the tree view to remove server
	m_pLeftPane->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);  

	// tell the right pane to remove server
	m_pRightPane->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRemoveServer

//----------------------------------------------------------------------------
LRESULT CMainFrame::OnAdminAddServerToFavorites( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminAddServerToFavorites\n" );

    m_pLeftPane->SendMessage( WM_ADMIN_ADDSERVERTOFAV , wp , lp );

    return 0;
}

LRESULT CMainFrame::OnAdminRemoveServerFromFavs( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminRemoveServerFromFavs\n" );

    return m_pLeftPane->SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , wp , lp );
}

/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateServer
//                                  
LRESULT CMainFrame::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to update server
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);  

	// tell the right pane to update server
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateServer


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateProcesses
//                                  
LRESULT CMainFrame::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// tell the right pane to update processes
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_PROCESSES, wParam, lParam);  
    
	return 0;                                                                  

}  // end CMainFrame::OnAdminUpdateProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveProcess
//                                  
LRESULT CMainFrame::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// tell the right pane to remove a process
	m_pRightPane->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);  
    
	return 0;                                                                  

}  // end CMainFrame::OnAdminUpdateProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddWinStation
//  
LRESULT CMainFrame::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to add a WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_ADD_WINSTATION, wParam, lParam);  
	
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminAddWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateWinStation
//  
LRESULT CMainFrame::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)              
{      
	ASSERT(lParam);

	// tell the tree view to update WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_WINSTATION, wParam, lParam);  
    
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateWinStations
//  
LRESULT CMainFrame::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to update WinStations
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateWinStations


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRemoveWinStation
//  
LRESULT CMainFrame::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to remove a WinStation
	m_pLeftPane->SendMessage(WM_ADMIN_REMOVE_WINSTATION, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRemoveWinStation


/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateDomain
//  
LRESULT CMainFrame::OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the tree view to update the domain
	m_pLeftPane->SendMessage(WM_ADMIN_UPDATE_DOMAIN, wParam, lParam);  

	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateDomain

/////////////////////////////////////
// F'N: CMainFrame::OnAdminAddDomain
//  
LRESULT CMainFrame::OnAdminAddDomain(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	return m_pLeftPane->SendMessage(WM_ADMIN_ADD_DOMAIN, wParam, lParam);  

}  // end CMainFrame::OnAdminAddDomain

/////////////////////////////////////
// F'N: CMainFrame::OnAdminUpdateServerInfo
//                                  
LRESULT CMainFrame::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to update server info
	m_pRightPane->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminUpdateServerInfo


/////////////////////////////////////
// F'N: CMainFrame::OnAdminRedisplayLicenses
//                                  
LRESULT CMainFrame::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)              
{   
	ASSERT(lParam);

	// tell the right pane to redisplay licenses
	m_pRightPane->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);  
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminRedisplayLicenses


/////////////////////////////////////
// F'N: CMainFrame::OnAdminViewsReady
//                                  
LRESULT CMainFrame::OnAdminViewsReady(WPARAM wParam, LPARAM lParam)              
{   
	// tell the left pane that all views are ready
	m_pLeftPane->SendMessage(WM_ADMIN_VIEWS_READY, wParam, lParam);      
                                                                            
	return 0;                                                                  
                                                                               
}  // end CMainFrame::OnAdminViewsReady


/////////////////////////////////////
// F'N: CMainFrame::OnExpandAll
//                                  
void CMainFrame::OnExpandAll() 
{
	// tell the tree view to expand all
	m_pLeftPane->SendMessage(WM_ADMIN_EXPANDALL, 0, 0);  
                                                                               	
}  // end CMainFrame::OnExpandAll


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseAll
//                                  
void CMainFrame::OnCollapseAll() 
{
	// tell the tree view to collapse all
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSEALL, 0, 0);  
	
}  // end CMainFrame::OnCollapseAll


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseToServers
//                                  
void CMainFrame::OnCollapseToServers() 
{
	// tell the tree view to collapse to servers
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSETOSERVERS, 0, 0);  
	
}  // end CMainFrame::OnCollapseToServers


/////////////////////////////////////
// F'N: CMainFrame::OnCollapseToDomains
//                                  
void CMainFrame::OnCollapseToDomains() 
{
	// tell the tree view to collapse to domains
	m_pLeftPane->SendMessage(WM_ADMIN_COLLAPSETODOMAINS, 0, 0);  
	
}  // end CMainFrame::OnCollapseToDomains


/////////////////////////////////////
// F'N: CMainFrame::OnRefresh
//                                  
void CMainFrame::OnRefresh() 
{
	// tell the document to do a refresh
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->Refresh();

}  // end CMainFrame::OnRefresh


/////////////////////////////////////
// F'N: CMainFrame::OnConnect
//                                  
void CMainFrame::OnConnect() 
{
	// We don't ask for confirmation, should we?    

	CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	int view = pDoc->GetCurrentView();
	int page = pDoc->GetCurrentPage();

   // tell the document
	BOOL user = FALSE;
	if((view == VIEW_SERVER && page == PAGE_USERS)
		|| (view == VIEW_ALL_SERVERS && page == PAGE_AS_USERS)
		|| (view == VIEW_DOMAIN && page == PAGE_DOMAIN_USERS))
		user = TRUE;

	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectWinStation(FALSE, user);
   
}  // end CMainFrame::OnConnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeConnect
//                                  
void CMainFrame::OnTreeConnect() 
{    
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectWinStation(TRUE, FALSE);
   
}  // end CMainFrame::OnTreeConnect


/////////////////////////////////////
// F'N: CMainFrame::OnDisconnect
//                                  
void CMainFrame::OnDisconnect() 
{   
	DisconnectHelper(FALSE);

}	// end CMainFrame::OnDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDisconnect
//                                  
void CMainFrame::OnTreeDisconnect() 
{   
	DisconnectHelper(TRUE);

}	// end CMainFrame::OnTreeDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDisconnect
//                                  
void CMainFrame::DisconnectHelper(BOOL bTree)
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_DISCONNECT);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}
	}

	// tell the document
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DisconnectWinStation(bTree);

}  // end CMainFrame::DisconnectHelper


/////////////////////////////////////
// F'N: CMainFrame::OnSendMessage
//                                  
void CMainFrame::OnSendMessage() 
{
	SendMessageHelper(FALSE);

}	// end CMainFrame::OnSendMessage


/////////////////////////////////////
// F'N: CMainFrame::OnTreeSendMessage
//                                  
void CMainFrame::OnTreeSendMessage() 
{
	SendMessageHelper(TRUE);

}	// end CMainFrame::OnTreeSendMessage


/////////////////////////////////////
// F'N: CMainFrame::SendMessageHelper
//                                  
void CMainFrame::SendMessageHelper(BOOL bTree)
{
	CSendMessageDlg dlg;	//AfxGetMainWnd());

	if(dlg.DoModal() != IDOK || !(*dlg.m_szMessage))
		return;

	MessageParms *pParms = new MessageParms;
	wcscpy(pParms->MessageTitle, dlg.m_szTitle);
	wcscpy(pParms->MessageBody, dlg.m_szMessage);

	// tell the document
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SendWinStationMessage(bTree, pParms);
   
}  // end CMainFrame::SendMessageHelper


/////////////////////////////////////
// F'N: CMainFrame::OnShadow
//                                  
void CMainFrame::OnShadow() 
{
	// tell the document to Shadow the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ShadowWinStation(FALSE);

}  // end CMainFrame::OnShadow


/////////////////////////////////////
// F'N: CMainFrame::OnTreeShadow
//                                  
void CMainFrame::OnTreeShadow() 
{
	// tell the document to Shadow the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ShadowWinStation(TRUE);

}  // end CMainFrame::OnTreeShadow


/////////////////////////////////////
// F'N: CMainFrame::OnReset
//                                  
void CMainFrame::OnReset() 
{
	ResetHelper(FALSE);

}	// end CMainFrame::OnReset


/////////////////////////////////////
// F'N: CMainFrame::OnTreeReset
//                                  
void CMainFrame::OnTreeReset() 
{
	ResetHelper(TRUE);

}	// end CMainFrame::OnTreeReset


/////////////////////////////////////
// F'N: CMainFrame::ResetHelper
//                                  
void CMainFrame::ResetHelper(BOOL bTree)
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_RESET);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}	
	}
	
	// tell the document to reset the WinStation(s)
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ResetWinStation(bTree, TRUE);	

}  // end CMainFrame::ResetHelper


/////////////////////////////////////
// F'N: CMainFrame::OnStatus
//                                  
void CMainFrame::OnStatus() 
{
	// tell the document to reset the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->StatusWinStation(FALSE);

}  // end CMainFrame::OnStatus


/////////////////////////////////////
// F'N: CMainFrame::OnTreeStatus
//                                  
void CMainFrame::OnTreeStatus() 
{
	// tell the document to reset the WinStation(s)
   ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->StatusWinStation(TRUE);

}  // end CMainFrame::OnTreeStatus


/////////////////////////////////////
// F'N: CMainFrame::OnLogoff
//                                  
void CMainFrame::OnLogoff() 
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_LOGOFF);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}		
	}

	// tell the document to reset the WinStation(s)
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ResetWinStation(FALSE, TRUE);

}  // end CMainFrame::OnLogoff


/////////////////////////////////////
// F'N: CMainFrame::OnTerminate
//                                  
void CMainFrame::OnTerminate() 
{
	CString TitleString;
	CString MessageString;

	// Only bother the user if Confirmation is set
	if(((CWinAdminApp*)AfxGetApp())->AskConfirmation()) {

		TitleString.LoadString(AFX_IDS_APP_TITLE);
		MessageString.LoadString(IDS_WARN_TERMINATE);

		if(IDOK != MessageBox(MessageString, TitleString, MB_ICONEXCLAMATION | MB_OKCANCEL)) {
			return;
		}		
	}

	// tell the document to terminate the processes
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TerminateProcess();

}  // end CMainFrame::OnTerminate


/////////////////////////////////////
// F'N: CMainFrame::OnServerConnect
//                                  
void CMainFrame::OnServerConnect() 
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerConnect();

}  // end CMainFrame::OnServerConnect

//------------------------------------------------------------
void CMainFrame::OnAddToFavorites( )
{
    // ok try following me
    // I'm going to call a method in CWinAdminDoc to determine the current server
    // and view.  This will then be forwarded back here via sendmsg and then
    // towards the treeview. 

    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerAddToFavorites( TRUE );
}

//=-----------------------------------------------------------
void CMainFrame::OnRemoveFromFavs( )
{
    ODS( L"CMainFrame::OnRemoveFromFavs\n" );
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerAddToFavorites( FALSE );
}

/////////////////////////////////////
// F'N: CMainFrame::OnServerDisconnect
//                                  
void CMainFrame::OnServerDisconnect() 
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ServerDisconnect();

}  // end CMainFrame::OnServerDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainConnectAllServers
//                                  
void CMainFrame::OnTreeDomainConnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TempDomainConnectAllServers();

}	// end CMainFrame::OnTreeDomainConnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainDisconnectAllServers
//                                  
void CMainFrame::OnTreeDomainDisconnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->TempDomainDisconnectAllServers();

}	// end CMainFrame::OnTreeDomainDisconnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnTreeDomainFindServers
//                                  
void CMainFrame::OnTreeDomainFindServers()
{
    // tell the document to find servers in the domain
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DomainFindServers();

}	// end CMainFrame::OnTreeDomainFindServers


/////////////////////////////////////
// F'N: CMainFrame::OnDomainConnectAllServers
//                                  
void CMainFrame::OnDomainConnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CurrentDomainConnectAllServers();

}	// end CMainFrame::OnDomainConnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnDomainDisconnectAllServers
//                                  
void CMainFrame::OnDomainDisconnectAllServers()
{
    // tell the document to connect to the server(s)
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CurrentDomainDisconnectAllServers();

}	// end CMainFrame::OnDomainDisconnectAllServers


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersConnect
//                                  
void CMainFrame::OnAllServersConnect()
{
    // tell the document to connect to all servers
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->ConnectToAllServers();

}	// end CMainFrame::OnAllServersConnect


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersDisconnect
//                                  
void CMainFrame::OnAllServersDisconnect()
{
    // tell the document to disconnect from all servers
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->DisconnectFromAllServers();

}	// end CMainFrame::OnAllServersDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnAllServersFind
//                                  
void CMainFrame::OnAllServersFind()
{
    // tell the document to find all servers in all domains
    ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->FindAllServers();

}	// end CMainFrame::OnAllServersFind


/////////////////////////////////////
// F'N: CMainFrame::OnPreferences
//                                  
void CMainFrame::OnPreferences() 
{
	CPreferencesDlg dlg;

	dlg.DoModal();

}  // end CMainFrame::OnPreferences


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateConnect
//                                  
void CMainFrame::OnUpdateConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanConnect());	

}  // end CMainFrame::OnUpdateConnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDisconnect
//                                  
void CMainFrame::OnUpdateDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanDisconnect());	

}  // end CMainFrame::OnUpdateDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateLogoff
//                                  
void CMainFrame::OnUpdateLogoff(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanLogoff());	

}  // end CMainFrame::OnUpdateLogoff


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateMessage
//                                  
void CMainFrame::OnUpdateMessage(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanSendMessage());		

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateRefresh
//                                  
void CMainFrame::OnUpdateRefresh(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanRefresh());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateReset
//                                  
void CMainFrame::OnUpdateReset(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanReset());	

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateShadow
//                                  
void CMainFrame::OnUpdateShadow(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanShadow());		

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateStatus
//                                  
void CMainFrame::OnUpdateStatus(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanStatus());	

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTerminate
//                                  
void CMainFrame::OnUpdateTerminate(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTerminate());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateServerConnect
//                                  
void CMainFrame::OnUpdateServerConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanServerConnect());

}


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateServerDisconnect
//                                  
void CMainFrame::OnUpdateServerDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanServerDisconnect());

}


void CMainFrame::OnUpdateServerAddToFavorite( CCmdUI *pCmdUI )
{
    pCmdUI->Enable( !( ( CWinAdminDoc* )( ( CWinAdminApp* )AfxGetApp() )->GetDocument() )->IsAlreadyFavorite() );
}

void CMainFrame::OnUpdateServerRemoveFromFavorite( CCmdUI *pCmdUI )
{
    pCmdUI->Enable( ( ( CWinAdminDoc* )( ( CWinAdminApp* )AfxGetApp() )->GetDocument() )->IsAlreadyFavorite() );
}
/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeConnect
//                                  
void CMainFrame::OnUpdateTreeConnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempConnect());	

}  // end CMainFrame::OnUpdateTreeConnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeDisconnect
//                                  
void CMainFrame::OnUpdateTreeDisconnect(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDisconnect());	

}  // end CMainFrame::OnUpdateTreeDisconnect


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeMessage
//                                  
void CMainFrame::OnUpdateTreeMessage(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempSendMessage());		

} // end CMainFrame::OnUpdateTreeMessage


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeReset
//                                  
void CMainFrame::OnUpdateTreeReset(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempReset());	

}	// end CMainFrame::OnUpdateTreeReset


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeShadow
//                                  
void CMainFrame::OnUpdateTreeShadow(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempShadow());		

}	// end CMainFrame::OnUpdateTreeShadow


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateTreeStatus
//                                  
void CMainFrame::OnUpdateTreeStatus(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempStatus());	

}	// end CMainFrame::OnUpdateTreeStatus


/////////////////////////////////////
// F'N: CMainFrame::OnShowSystemProcesses
//                                  
void CMainFrame::OnShowSystemProcesses() 
{
	int state = ((CWinAdminApp*)AfxGetApp())->ShowSystemProcesses();
	((CWinAdminApp*)AfxGetApp())->SetShowSystemProcesses(state^1);	

	// tell the right pane to redisplay processes
	m_pRightPane->SendMessage(WM_ADMIN_REDISPLAY_PROCESSES, 0, 0);  

}  // end CMainFrame::OnShowSystemProcesses()


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateShowSystemProcesses
//                                  
void CMainFrame::OnUpdateShowSystemProcesses(CCmdUI* pCmdUI) 
{
	pCmdUI->SetCheck(((CWinAdminApp*)AfxGetApp())->ShowSystemProcesses());		

}  // end CMainFrame::OnUpdateShowSystemProcesses


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainPopupMenu
//                                  
void CMainFrame::OnUpdateDomainPopupMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDomainConnect());

}	// end CMainFrame::OnUpdateDomainPopupMenu


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainPopupFind
//                                  
void CMainFrame::OnUpdateDomainPopupFind(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanTempDomainFindServers());

}	// end CMainFrame::OnUpdateDomainPopupFind


/////////////////////////////////////
// F'N: CMainFrame::OnUpdateDomainMenu
//                                  
void CMainFrame::OnUpdateDomainMenu(CCmdUI* pCmdUI)
{
	pCmdUI->Enable(((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->CanDomainConnect());

}	// end CMainFrame::OnUpdateDomainMenu


/////////////////////////////////////
// F'N: CMainFrame::OnClose
//                                  
void CMainFrame::OnClose() 
{
	GetWindowPlacement(&((CWinAdminApp*)AfxGetApp())->m_Placement);	

	RECT rect;
	m_pLeftPane->GetWindowRect(&rect);   
	((CWinAdminApp*)AfxGetApp())->SetTreeWidth(rect.right-rect.left);

	CFrameWnd::OnClose();

}  // end CMainFrame::OnClose


/////////////////////////////////////
// F'N: CMainFrame::ActivateFrame
//                                  
void CMainFrame::ActivateFrame(int nCmdShow) 
{
	// TODO: Add your specialized code here and/or call the base class
    WINDOWPLACEMENT *pPlacement =
                        ((CWinAdminApp *)AfxGetApp())->GetPlacement();

    if ( pPlacement->length == -1 ) {

        /*
         * This is the first time that this is called, set the window
         * placement and show state to the previously saved state.
         */
        pPlacement->length = sizeof(WINDOWPLACEMENT);

        /*
         * If we have a previously saved placement state: set it.
         */
        if ( pPlacement->rcNormalPosition.right != -1 ) {

            if ( nCmdShow != SW_SHOWNORMAL )
                pPlacement->showCmd = nCmdShow;
            else
                nCmdShow = pPlacement->showCmd;

            SetWindowPlacement(pPlacement);
        }
    }

    /*
     * Perform the parent classes' ActivateFrame().
     */
    CFrameWnd::ActivateFrame(nCmdShow);

}	// end CMainFrame::ActivateFrame

//---------------------------------------------------------------------------
// bugid352062
// Splash message for people who hate to RTFM
//---------------------------------------------------------------------------
void CMainFrame::InitWarningThread( PVOID *pvParam )
{
    // display messagebox
    HWND hwnd = ( HWND )pvParam;
    DWORD dwSessionId;

    if( ProcessIdToSessionId( GetCurrentProcessId( ) , &dwSessionId ) )
    {
        if( dwSessionId == WTSGetActiveConsoleSessionId() )
        {
            // check if we are to show the dialog box
            // a) if the key does not exist show the dialog
            // b) if the key exist and the value is zero show the dialog
            
            HKEY hKey;

            DWORD dwStatus = RegOpenKeyEx( HKEY_CURRENT_USER , TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN" ) , 0 , KEY_READ , &hKey );

            if( dwStatus == ERROR_SUCCESS )
            {
                DWORD dwData = 0;

                DWORD dwSizeofData;

                dwSizeofData = sizeof( DWORD );

                RegQueryValueEx( hKey , TEXT( "DisableConsoleWarning" ) , 0 , NULL , ( LPBYTE )&dwData , &dwSizeofData );

                RegCloseKey( hKey );

                if( dwData != 0 )
                {
                    return;
                }
            }

            ::DialogBox( NULL , MAKEINTRESOURCE( IDD_DIALOG_FEATUREWARN ) , hwnd , FWarnDlg );             
        }
    } 
}

//---------------------------------------------------------------------------
// Sets regkey DisableConsoleWarning
//---------------------------------------------------------------------------
INT_PTR CALLBACK FWarnDlg( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        {
            HICON hIcon = LoadIcon( NULL , IDI_INFORMATION );
                        
            SendMessage( GetDlgItem( hwnd , IDC_FWICON ) , STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon );

            // center dialog

            RECT rParent;
            RECT rMe;

            GetWindowRect( GetParent( hwnd ) , &rParent );
            GetWindowRect( hwnd , &rMe );

            int xDelta , yDelta;

            xDelta = ( ( rParent.right - rParent.left ) - ( rMe.right - rMe.left ) ) / 2;

            if( xDelta < 0 )
            {
                xDelta = 0;
            }

            yDelta = ( ( rParent.bottom - rParent.top ) - ( rMe.bottom - rMe.top ) ) / 2;

            if( yDelta < 0 )
            {
                yDelta = 0;
            }

            SetWindowPos( hwnd , NULL ,  rParent.left + xDelta , rParent.top + yDelta , 0 , 0 , SWP_NOSIZE );
        }

    case WM_COMMAND:

        if( LOWORD( wp ) == IDOK )
        {
            // check the button and save the settings
            HKEY hKey;

            DWORD dwDisp;

            DWORD dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER , TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN" ) , 
                                             0 , NULL , 0 , KEY_ALL_ACCESS , NULL , &hKey , &dwDisp );

            if( dwStatus == ERROR_SUCCESS )
            {
                DWORD dwBool = 0;

                if( IsDlgButtonChecked( hwnd , IDC_CHECK_NOMORE ) == BST_CHECKED )
                {
                    dwBool = ( DWORD )-1;
                }

                RegSetValueEx( hKey , TEXT( "DisableConsoleWarning" ), 0 , REG_DWORD , ( LPBYTE )&dwBool , sizeof( dwBool ) );

                RegCloseKey( hKey );
            }

            // HKCU\Software\Microsoft\Windows NT\CurrentVersion\Terminal Server\TSADMIN\DisableConsoleWarning (REG_DWORD)
            EndDialog( hwnd , 0 );
        }
    }

    return 0;
}

//=----------------------------------------------------------------------------------------------
void CMainFrame::OnTab( )
{
    ODS( L"CMainFrame::OnTab received\n");

    // pre tabbing
    // set this state so that we can distinguish how the tabs received focus
    // we can rule out the tab key

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    pDoc->SetOnTabFlag( );

    m_pRightPane->SendMessage( WM_ADMIN_TABBED_VIEW , 0 , 0 );

    pDoc->ResetOnTabFlag( );

    // end tabbing
 
}

//=----------------------------------------------------------------------------------------------
void CMainFrame::OnShiftTab( )
{
    ODS( L"CMainFrame::OnShiftTab received\n" );

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    pDoc->SetOnTabFlag( );

    m_pRightPane->SendMessage( WM_ADMIN_SHIFTTABBED_VIEW , 0 , 0 );

    pDoc->ResetOnTabFlag( );
}

//=----------------------------------------------------------------------------------------------
//= this message is sent from the right pane item in the view
//
LRESULT CMainFrame::OnForceTreeViewFocus( WPARAM wp , LPARAM lp )
{
    m_pLeftPane->SetFocus( );

    return 0;
}

//=----------------------------------------------------------------------------------------------
// this is to rotate around the tabs and treeview
//
void CMainFrame::OnCtrlTab( )
{
    ODS( L"CMainFrame::OnCtrlTab received\n" );
    
    m_pRightPane->SendMessage( WM_ADMIN_CTRLTABBED_VIEW , 0 , 0 );
}

//=----------------------------------------------------------------------------------------------
// this is to rotate around the tabs and treeview in the "other" direction
//
void CMainFrame::OnCtrlShiftTab( )
{
    ODS( L"CMainFrame::OnCtrlShiftTab\n" );

    m_pRightPane->SendMessage( WM_ADMIN_CTRLSHIFTTABBED_VIEW , 0 , 0 );
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnNextPane( )
{
    ODS( L"CMainFrame::OnNextPane\n" );
    
    m_pRightPane->SendMessage( WM_ADMIN_NEXTPANE_VIEW , 0 , 0 );
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnDelFavNode( )
{
    ODS( L"CMainFrame::OnDelFavNode\n" );

    m_pLeftPane->SendMessage( WM_ADMIN_DELTREE_NODE , 0 , 0 );
}

//This will find the server with the given name
//and place the cursor on it. The server may be
//added to the list if it's not already there
bool CMainFrame::LocateServer(LPCTSTR sServerName)
{
    TCHAR szServerName[ 256 ];
    CString cstrTitle;
    CString cstrMsg;
    
    // Make sure a string (server name) was passed in
    // check for null and an empty string    
    if ((sServerName == NULL) || (sServerName[0] == L'\0'))
        return FALSE;
    
    CWaitCursor wait;

    DBGMSG( L"Server to connect to is %s\n" , sServerName );

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    // resolve name
    // check to see if its an ipv4 address

    lstrcpyn( szServerName , sServerName, sizeof(szServerName) / sizeof(TCHAR) );

    WSADATA wsaData;
    if( WSAStartup( 0x202 , &wsaData ) == 0 )
    {
        char szAnsiServerName[ 256 ];
        WideCharToMultiByte( CP_OEMCP ,
                             0 ,
                             szServerName,
                             -1,
                             szAnsiServerName , 
                             sizeof( szAnsiServerName ),
                             NULL , 
                             NULL );


        int nAddr = 0;
        nAddr = inet_addr( szAnsiServerName );

        // if this is a valid ipv4 address then lets get the host name
        // otherwise lets fall through and see if its a valid server name

        if( nAddr != 0 && nAddr != INADDR_NONE )
        {
            ODS( L"Server name is IPV4\n" );

            struct hostent *pHostEnt;
            pHostEnt = gethostbyaddr( ( char * )&nAddr , 4 , AF_INET );

            if( pHostEnt != NULL )
            {
                DWORD dwSize;
        
                TCHAR szDnsServerName[ 256 ];
                MultiByteToWideChar( CP_OEMCP ,
                                     0 ,
                                     pHostEnt->h_name ,
                                     -1,
                                     szDnsServerName,
                                     sizeof( szDnsServerName ) / sizeof( TCHAR ) );

                dwSize = sizeof( szServerName ) / sizeof( TCHAR );

                DnsHostnameToComputerName( szDnsServerName , szServerName , &dwSize );

            }
            else
            {
                // there was an error ( ip addr was probably not valid )
                // display error                    
                cstrTitle.LoadString( AFX_IDS_APP_TITLE );
                cstrMsg.LoadString( IDS_NO_SERVER );

                MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION );                    

                WSACleanup();                    

                return FALSE;
            }

        }

        WSACleanup();
    }
   

    CServer *pServer = pDoc->FindServerByName( szServerName );


    if( pServer == NULL )
    {
        TCHAR szDomainName[ 256 ];

        // this means that the server is not in the list            
        // let's find out what domain this server belongs to
        DBGMSG( L"%s could not be found in the server list\n" , szServerName );

        // Verify it's a terminal server we can connect to.
        HANDLE hTerminalServer = NULL;

        hTerminalServer = WinStationOpenServer( szServerName );

        if( hTerminalServer == NULL )
        {
            DBGMSG( L"WinstationOpenServer failed with %d\n" , GetLastError( ) );
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            cstrMsg.LoadString( IDS_NO_SERVER );
            MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION ); 
            return false;
        }

        WinStationCloseServer( hTerminalServer );


        DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDsRPDIB = NULL;

        DWORD dwStatus = DsRoleGetPrimaryDomainInformation( 
                            szServerName ,
                            DsRolePrimaryDomainInfoBasic,
                            ( PBYTE * )&pDsRPDIB );

        DBGMSG( L"DsRoleGetPrimaryDomainInformation returned 0x%x\n" , dwStatus );

        
        if( dwStatus == ERROR_SUCCESS && pDsRPDIB != NULL )
        {
            lstrcpyn( szDomainName , pDsRPDIB->DomainNameFlat, sizeof(szDomainName) / sizeof(TCHAR) );

            DsRoleFreeMemory( pDsRPDIB );
        }

        if( dwStatus != ERROR_SUCCESS )
        {
            // otherwise the server probably does not exist or its on 
            // a non-trusted domain
            LPTSTR pBuffer = NULL;
 
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            // cstrMsg.LoadString( IDS_NO_SERVER );
            
            ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,                                          //ignored
                    dwStatus    ,                                //message ID
                    MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ), //message language
                    (LPTSTR)&pBuffer,                              //address of buffer pointer
                    0,                                             //minimum buffer size
                    NULL );

            if( pBuffer != NULL )
            {                
                cstrMsg.Format( IDS_NOSERVER_REASON , pBuffer );

                LocalFree( pBuffer );
            }
            else
            {
                cstrMsg.Format( IDS_NOSERVER_REASON , TEXT("" ) );
            }
            
            MessageBox( cstrMsg , cstrTitle , MB_OK | MB_ICONINFORMATION );
            return false;
        }
        else
        {
            // find the domain

            BOOL bFound = FALSE;

            CObList *pDomainList = pDoc->GetDomainList();

            POSITION pos = pDomainList->GetHeadPosition();
             
             while( pos )
             {
                 CDomain *pDomain = ( CDomain* )pDomainList->GetNext( pos );

                 if( lstrcmpi( pDomain->GetName( ) , szDomainName ) == 0 )
                 {
                     bFound = TRUE;

                     CServer *pNewServer = new CServer( pDomain , szServerName , FALSE , FALSE );

                     if( pNewServer == NULL )
                     {
                         break;
                     }

                     pNewServer->SetManualFind();
                     // add server to list
                     pDoc->AddServer( pNewServer );

                     SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pNewServer );

                     m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pNewServer ); 
                     
                     break;                        
                 }                     
             }
             if( !bFound )
             {
                 CDomain *pDomain = new CDomain( szDomainName );
                 
                 if( pDomain == NULL )
                     return false;

                 pDoc->AddDomain( pDomain );
                 
                 m_pLeftPane->SendMessage( WM_ADMIN_ADD_DOMAIN , (WPARAM)NULL , ( LPARAM )pDomain );

                 CServer *pNewServer = new CServer( pDomain , szServerName , FALSE , FALSE );

                 if( pNewServer == NULL )
                     return false;

                 pNewServer->SetManualFind();
                 // add server to list
                 pDoc->AddServer( pNewServer );

                 SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pNewServer );

                 m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pNewServer ); 
             }
        }
    }
    else
    {
        // scroll to server
        DBGMSG( L"Server %s is in the list\n",szServerName );

        if( pServer->IsState(SS_DISCONNECTING) )
        {
            TCHAR buf[ 256 ];
            ODS( L"but it's gone away so we're not jumping to server\n" );
            cstrTitle.LoadString( AFX_IDS_APP_TITLE );
            cstrMsg.LoadString( IDS_CURRENT_DISCON );

            wsprintf( buf , cstrMsg , szServerName );
            MessageBox( buf , cstrTitle , MB_OK | MB_ICONINFORMATION );

            return false;
        }

        if( pServer->GetTreeItem( ) == NULL )
        {
            ODS( L"this server has no association to the tree add it now\n" );

            SendMessage( WM_ADMIN_ADD_SERVER , ( WPARAM )TVI_SORT , ( LPARAM )pServer );
        }

        m_pLeftPane->SendMessage( WM_ADMIN_GOTO_SERVER , 0 , ( LPARAM )pServer );  
    }   

    return true;
}

//=-----------------------------------------------------------------------------------------
void CMainFrame::OnFindServer( )
{
    CMyDialog dlg;

    if( dlg.DoModal( ) == IDOK )
    {
        if (LocateServer(dlg.m_cstrServerName));
            m_pLeftPane->SendMessage(WM_ADMIN_CONNECT_TO_SERVER, 0, 0);
    }

    m_pLeftPane->SendMessage(WM_ADMIN_FORCE_SEL_CHANGE, 0, 0); 
}

//=-----------------------------------------------------------------
LRESULT CMainFrame::OnAdminGetTVStates( WPARAM wp , LPARAM lp )
{
    ODS( L"CMainFrame::OnAdminGetTVStates\n" );
    return m_pLeftPane->SendMessage( WM_ADMIN_GET_TV_STATES , 0 , 0 );
}

//=-----------------------------------------------------------------
LRESULT CMainFrame::OnAdminUpdateTVStates( WPARAM , LPARAM )
{
    ODS( L"CMainFrame::OnAdminUpdateTVStates\n" );
    return m_pLeftPane->SendMessage( WM_ADMIN_UPDATE_TVSTATE , 0 , 0 );
}

//=-----------------------------------------------------------------
void CMainFrame::OnEmptyFavorites(  )
{
    ODS( L"CMainFrame!OnEmptyFavorites\n" );

    m_pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 0 , 0 );   

}

void CMainFrame::OnUpdateEmptyFavs( CCmdUI* pCmdUI )
{
    BOOL b = ( BOOL )m_pLeftPane->SendMessage( WM_ISFAVLISTEMPTY , 0 , 0 );

    pCmdUI->Enable( !b );
}
//=-----------------------------------------------------------------
#ifdef _STRESS_BUILD
void CMainFrame::OnAddAllServersToFavorites( )
{
    ODS( L"!OnAddAllServersToFavorites -- if you're seeing this you're running a special stress build\n" );
    
    // loop through every server and add to fav's
    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    CObList *pServerList = pDoc->GetServerList();
    
    POSITION pos = pServerList->GetHeadPosition();

    while( pos )
    {
        CServer *pServer = ( CServer* )pServerList->GetNext( pos );

        if( pServer != NULL &&
            !pServer->IsState( SS_DISCONNECTING ) &&
            pServer->GetTreeItemFromFav() == NULL )
        {
            m_pLeftPane->SendMessage( WM_ADMIN_ADDSERVERTOFAV , 0 , ( LPARAM )pServer );
        }
    }
}


//=-----------------------------------------------------------------
void CMainFrame::OnRunStress( )
{
    ODS( L"OnRunStress! Stress starting...\n" );

    AfxBeginThread((AFX_THREADPROC)RunStress , ( PVOID )m_pLeftPane );

}

//=-----------------------------------------------------------------
void CMainFrame::OnRunStressLite( )
{
    ODS( L"OnRunStressLite! Stress lite starting...\n" );

    AfxBeginThread((AFX_THREADPROC)RunStressLite , ( PVOID )m_pLeftPane );

}

//=-----------------------------------------------------------------
DWORD RunStressLite( PVOID pv )
{
    CWnd *pLeftPane = ( CWnd * )pv;

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    CObList *pDomainList = pDoc->GetDomainList();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    // get all domains to start enumerating

    pDoc->FindAllServers( );
    
    int nStress = 0;
    
    while( 1 )
    {
    
        DBGMSG( L"Stress lite run #%d\n" , nStress );

        Sleep( 2 * 1000 * 60 );

        // add all servers to favorites

        ODS( L"STRES RUN! Adding all servers to favorites\n" );

        p->SendMessage(  WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_FAVALLADD ,  ( LPARAM )p->GetSafeHwnd( ) );

        pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // wait 1 minutes

        Sleep( 1 * 1000 * 60 );

        // remove all servers from favorites
        ODS( L"STRESS RUN! emptying favorites\n" );

        pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 1 , 0 ); 

        nStress++;

        // start over ( no end );
    }


}

//=-----------------------------------------------------------------
DWORD RunStress( PVOID pv )
{
    CWnd *pLeftPane = ( CWnd * )pv;

    CWinAdminDoc* pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
    
    CObList *pDomainList = pDoc->GetDomainList();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

        
    // select each domain connect to each domain

    POSITION pos = pDomainList->GetHeadPosition();

    while( pos )
    {
        // Get a pointer to the domain

        CDomain *pDomain = (CDomain*)pDomainList->GetNext(pos);

        // If this domain isn't currently enumerating servers, tell it to

        if( !pDomain->GetThreadPointer( ) )
        {           
            // refresh server
            if( lstrcmpi( pDomain->GetName( ) , L"ASIA" ) == 0 ||
                lstrcmpi( pDomain->GetName( ) , L"HAIFA" ) == 0 )            
            {
                DBGMSG( L"STRESS RUN! Enumerating %s\n", pDomain->GetName( ) );
                
                pDomain->StartEnumerating();
            }
        }

    }
    
    while( 1 )
    {
        // wait a half a second.

        Sleep( 1 * 10 * 1000 );

        // pLeftPane->SendMessage( WM_ADMIN_COLLAPSEALL , 0 , 0 );

        // connect to them all

        ODS( L"\nSTRESS RUN! Connecting to all servers\n\n" );
        
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_CONNECT,( LPARAM )p->GetSafeHwnd( ) );
        // pDoc->ConnectToAllServers();

        Sleep( 1 * 30 * 1000 );

        // pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // disconnect them all

        ODS( L"\nSTRESS RUN! Disconnecting from all servers\n\n" );

        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_DISCONNECT,( LPARAM )p->GetSafeHwnd( ) );

        // pDoc->DisconnectFromAllServers( );

        ODS( L"\nSTRESS RUN! waiting for completion\n\n" );

        while( g_fWaitForAllServersToDisconnect );

        ODS( L"\nSTRESS RUN! done completing\n\n" );

        // pLeftPane->SendMessage( WM_ADMIN_COLLAPSEALL , 0 , 0 );

        // add all to favorites

        ODS( L"\nSTRESS RUN! Adding all servers to favorites\n\n" );

        p->SendMessage(  WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_FAVALLADD ,  ( LPARAM )p->GetSafeHwnd( ) );

        // pLeftPane->SendMessage( WM_ADMIN_EXPANDALL , 0 , 0 );

        // connect to them all

        Sleep( 1 * 60 * 1000 );

        ODS( L"\nSTRESS RUN! Connecting phase 2 to all servers\n\n" );
 
        // pDoc->ConnectToAllServers();
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_CONNECT,( LPARAM )p->GetSafeHwnd( ) );

        Sleep( 1 * 30 * 1000 );

        ODS( L"\nSTRESS RUN! Disconnecting phase 2 from all servers\n\n" );

        // pDoc->DisconnectFromAllServers( );
        p->SendMessage( WM_COMMAND , ( WPARAM )IDM_ALLSERVERS_DISCONNECT,( LPARAM )p->GetSafeHwnd( ) );

        while( g_fWaitForAllServersToDisconnect );

        // remove from favs

        ODS( L"STRESS RUN! emptying favorites\n" );

        pLeftPane->SendMessage( IDM_ALLSERVERS_EMPTYFAVORITES , 1 , 0 ); 
    }
     
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\mainfrm.h ===
/*******************************************************************************
*
* mainfrm.h
*
* interface of the CMainFrame class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
*******************************************************************************/


class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

   CWnd *m_pLeftPane;
   CWnd *m_pRightPane;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void ActivateFrame(int nCmdShow = -1);
	//}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    static void InitWarningThread( PVOID *pvParam );

private:
    void DisconnectHelper(BOOL bTree);
    void SendMessageHelper(BOOL bTree);
    void ResetHelper(BOOL bTree);
    bool LocateServer(LPCTSTR sServerName);
	
protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnAdminChangeView(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveWinStation(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateDomain(WPARAM, LPARAM);
    afx_msg LRESULT OnAdminAddDomain(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddApplication(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAddAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtRemoveAppServer(WPARAM, LPARAM);
	afx_msg LRESULT OnExtAppChanged(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminViewsReady(WPARAM, LPARAM);
    afx_msg LRESULT OnAdminAddServerToFavorites( WPARAM , LPARAM );
    afx_msg LRESULT OnForceTreeViewFocus( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminRemoveServerFromFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminGetTVStates( WPARAM wp , LPARAM lp );
    afx_msg LRESULT OnAdminUpdateTVStates( WPARAM , LPARAM );


	//afx_msg LRESULT OnHelp(WPARAM, LPARAM);
	afx_msg void OnExpandAll();
	afx_msg void OnRefresh();
	afx_msg void OnConnect();
	afx_msg void OnTreeConnect();
	afx_msg void OnDisconnect();
	afx_msg void OnTreeDisconnect();
	afx_msg void OnSendMessage();
	afx_msg void OnTreeSendMessage();
	afx_msg void OnShadow();
	afx_msg void OnTreeShadow();
	afx_msg void OnReset();
	afx_msg void OnTreeReset();
	afx_msg void OnStatus();
	afx_msg void OnTreeStatus();
	afx_msg void OnLogoff();
	afx_msg void OnTerminate();
	afx_msg void OnPreferences();
	afx_msg void OnCollapseAll();
	afx_msg void OnCollapseToServers();
    afx_msg void OnCollapseToDomains();
    afx_msg void OnServerConnect();
    afx_msg void OnServerDisconnect();
	afx_msg void OnTreeDomainConnectAllServers();
	afx_msg void OnTreeDomainDisconnectAllServers();
	afx_msg void OnTreeDomainFindServers();
	afx_msg void OnDomainConnectAllServers();
	afx_msg void OnDomainDisconnectAllServers();
	afx_msg void OnAllServersConnect();
	afx_msg void OnAllServersDisconnect();
	afx_msg void OnAllServersFind();
	afx_msg void OnUpdateConnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateLogoff(CCmdUI* pCmdUI);
	afx_msg void OnUpdateMessage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateReset(CCmdUI* pCmdUI);
	afx_msg void OnUpdateShadow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateStatus(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTerminate(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeConnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeMessage(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeReset(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeShadow(CCmdUI* pCmdUI);
	afx_msg void OnUpdateTreeStatus(CCmdUI* pCmdUI);
	afx_msg void OnShowSystemProcesses();
	afx_msg void OnUpdateShowSystemProcesses(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerAddToFavorite( CCmdUI * );
    afx_msg void OnUpdateServerRemoveFromFavorite( CCmdUI * );
    
	afx_msg void OnClose();
	afx_msg void OnHtmlHelp();
	afx_msg void OnUpdateRefresh(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerConnect(CCmdUI* pCmdUI);
    afx_msg void OnUpdateServerDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDomainPopupMenu(CCmdUI* pCmdUI);
	afx_msg void OnUpdateDomainPopupFind(CCmdUI* pCmdUI);	
	afx_msg void OnUpdateDomainMenu(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEmptyFavs( CCmdUI* pCmdUI );
    afx_msg void OnAddToFavorites();
    afx_msg void OnTab( );
    afx_msg void OnShiftTab();
    afx_msg void OnCtrlTab( );
    afx_msg void OnCtrlShiftTab( );
    afx_msg void OnNextPane( );
    afx_msg void OnRemoveFromFavs( );
    afx_msg void OnFindServer( );
    afx_msg void OnDelFavNode( );
    afx_msg void OnEmptyFavorites( );

    #ifdef _STRESS_BUILD
    afx_msg void OnAddAllServersToFavorites( );
    afx_msg void OnRunStress( );
    afx_msg void OnRunStressLite( );
    #endif
    
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\msgview.cpp ===
/*******************************************************************************
*
* msgview.cpp
*
* implementation of the CMessageView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\msgview.cpp  $
*  
*     Rev 1.2   03 Nov 1997 15:27:18   donm
*  update
*  
*     Rev 1.1   15 Oct 1997 21:47:22   donm
*  update
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "msgview.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CMessageView
//
IMPLEMENT_DYNCREATE(CMessageView, CView)

BEGIN_MESSAGE_MAP(CMessageView, CView)
	//{{AFX_MSG_MAP(CMessageView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////
// F'N: CMessageView ctor
//
CMessageView::CMessageView()
{
	m_pMessagePage = NULL;
	
}  // end CMessageView ctor


///////////////////////
// F'N: CMessageView dtor
//
CMessageView::~CMessageView()
{

}  // end CMessageView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CMessageView::AssertValid
//
void CMessageView::AssertValid() const
{
	CView::AssertValid();

}  // end CMessageView::AssertValid


////////////////////////
// F'N: CMessageView::Dump
//
void CMessageView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CMessageView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CMessageView::OnCreate
//
int CMessageView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CMessageView::OnCreate


///////////////////////////////////
// F'N: CMessageView::OnInitialUpdate
//
//
void CMessageView::OnInitialUpdate() 
{
	m_pMessagePage = new CMessagePage;
    if(!m_pMessagePage) return;

	m_pMessagePage->Create(NULL, NULL, WS_CHILD | WS_VISIBLE, CRect(0, 0, 0, 0), this, 0, NULL);
	GetDocument()->AddView(m_pMessagePage);		

}  // end CMessageView::OnInitialUpdate


//////////////////////////
// F'N: CMessageView::OnSize
//
// - size the pages to fill the entire view
//
void CMessageView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	if(m_pMessagePage && m_pMessagePage->GetSafeHwnd())
	  m_pMessagePage->MoveWindow(&rect, TRUE);

}  // end CMessageView::OnSize


//////////////////////////
// F'N: CMessageView::OnDraw
//
//
void CMessageView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CMessageView::OnDraw


/////////////////////////
// F'N: CMessageView::Reset
//
//
void CMessageView::Reset(void *p)
{
	if(m_pMessagePage) m_pMessagePage->Reset(p);

//	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

}  // end CMessageView::Reset


////////////////////////////////
// MESSAGE MAP: CMessagePage
//
IMPLEMENT_DYNCREATE(CMessagePage, CFormView)

BEGIN_MESSAGE_MAP(CMessagePage, CFormView)
	//{{AFX_MSG_MAP(CMessagePage)
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CMessagePage ctor
//
CMessagePage::CMessagePage()
	: CAdminPage(CMessagePage::IDD)
{
	//{{AFX_DATA_INIT(CMessagePage)
	//}}AFX_DATA_INIT

}  // end CMessagePage ctor


/////////////////////////////
// F'N: CMessagePage dtor
//
CMessagePage::~CMessagePage()
{
}  // end CMessagePage dtor


////////////////////////////////////////
// F'N: CMessagePage::DoDataExchange
//
void CMessagePage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMessagePage)
	
	//}}AFX_DATA_MAP

}  // end CMessagePage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CMessagePage::AssertValid
//
void CMessagePage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CMessagePage::AssertValid


//////////////////////////////
// F'N: CMessagePage::Dump
//
void CMessagePage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CMessagePage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CMessagePage::OnInitialUpdate
//
void CMessagePage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

}  // end CMessagePage::OnInitialUpdate


//////////////////////////////
// F'N: CMessagePage::OnSize
//
void CMessagePage::OnSize(UINT nType, int cx, int cy) 
{
    RECT rect;
	GetClientRect(&rect);

	MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CMessagePage::OnSize


//////////////////////////////
// F'N: CMessagePage::Reset
//
void CMessagePage::Reset(void *p)
{
	CString string;
	string.LoadString((WORD)p);
	SetDlgItemText(IDC_MESSAGE, string);
	
}  // end CMessagePage::Reset
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\procs.h ===
/*******************************************************************************
*
* procs.h
*
* declaration of ProcEnumerateProcesses
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\PROCS.H  $
*
*     Rev 1.0   30 Jul 1997 17:12:06   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _PROCS_H
#define _PROCS_H

#include <allproc.h>

typedef struct _ENUMTOKEN
{
    ULONG       Current;
    ULONG       NumberOfProcesses;
    union
    {
        PTS_ALL_PROCESSES_INFO  ProcessArray;
        PBYTE                   pProcessBuffer;
    };
    BOOLEAN     bGAP;
}
ENUMTOKEN, *PENUMTOKEN;

BOOL WINAPI ProcEnumerateProcesses( HANDLE hServer,
                                    PENUMTOKEN pEnumToken,
                                    LPTSTR pImageName,
                                    PULONG pLogonId,
                                    PULONG pPID,
                                    PSID *ppSID );

#define MAX_PROCESSNAME 18

#endif // _PROCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\msgview.h ===
/*******************************************************************************
*
* msgvw.h
*
* - header for the CMessageView class
* - implementation can be found in msgvw.cpp
*
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\msgview.h  $
*  
*     Rev 1.1   15 Oct 1997 21:47:26   donm
*  update
*******************************************************************************/

//////////////////////
// FILE: 
//
//
#ifndef _MSGVIEW_H
#define _MSGVIEW_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

class CMessagePage;

//////////////////////
// CLASS: CMessageView
//
// View that display a message centered in it
// This replaces CBusyServerView, CBadServerView, CBadWinStationView, and CListenerView
//
class CMessageView : public CAdminView
{
friend class CRightPane;

protected:
	CMessageView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CMessageView)

// Attributes
protected:

private:
   WORD m_wMessageID;
//   CString m_MessageString;
//   CFont m_MessageFont;
   CMessagePage *m_pMessagePage;

// Operations
protected:
	void Reset(void *message);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessageView)
	// Overrides
public:
	virtual void OnInitialUpdate();
protected:
	virtual void OnDraw(CDC* pDC);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMessageView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CMessageView)
		// NOTE - the ClassWizard will add and remove member functions here.
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CMessageView


//////////////////////////
// CLASS: CMessagePage
//
class CMessagePage : public CAdminPage
{
friend class CMessageView;

protected:
	CMessagePage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CMessagePage)

// Form Data
public:
	//{{AFX_DATA(CApplicationInfoPage)
	enum { IDD = IDD_MESSAGE_PAGE };
	//}}AFX_DATA

// Attributes
public:

protected:

private:

// Operations
public:

private:
	void Reset(void *pMsg);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMessagePage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMessagePage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
	//{{AFX_MSG(CMessagePage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CMessagePage

#endif  // _MSGVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\procs.cpp ===
/*******************************************************************************
*
* procs.cpp
*
* implementation of ProcEnumerateProcesses function
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   BillG  $  Don Messerli
*
* $Log:   X:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\PROCS.CPP  $
*
*     Rev 1.1   02 Dec 1997 16:30:10   BillG
*  alpha update
*
*     Rev 1.0   30 Jul 1997 17:12:02   butchd
*  Initial revision.
*
*******************************************************************************/


#ifndef UNICODE
#define UNICODE
#endif
//#ifndef _X86_
//#define _X86_
//#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <ntlsa.h>
#include <ntsam.h>
#include <windows.h>
#include <lmaccess.h>
#include <lmserver.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <winsta.h>

#include <procs.h>


#define MAX_PROCESSNAME 18


VOID
FetchProcessIDAndImageName(PTS_SYS_PROCESS_INFORMATION ProcessInfo,
                           PULONG pPID,
                           LPTSTR pImageName)
{
    int i;
    TCHAR ImageName[MAX_PROCESSNAME+1];
    //
    // Set the PID.
    //
    *pPID = (ULONG)(ULONG_PTR)(ProcessInfo->UniqueProcessId);


    //
    //  Fetch and convert counted UNICODE string into a NULL
    //  terminated UNICODE string.
    //
    if( !ProcessInfo->ImageName.Length == 0 )
    {
        wcsncpy( ImageName,
                 ProcessInfo->ImageName.Buffer,
                 min(MAX_PROCESSNAME, ProcessInfo->ImageName.Length/2));
    }

    ImageName[min(MAX_PROCESSNAME, ProcessInfo->ImageName.Length/2)] = 0;


    /*
     * We're UNICODE: simply copy the converted ImageName buffer
     * into the m_PLObject->m_ImageName field.
     */
    lstrcpy(pImageName, ImageName);

    _wcslwr(pImageName);

}

/*******************************************************************************
 *
 *  EnumerateProcesses - WinFrame helper function
 *
 *  Enumerate all processes in system, passing back one with each call to this
 *  routine.
 *
 *
 * ENTRY:
 *    hServer:
 *      handle of the aimed server
 *    pEnumToken
 *      pointer to the current token
 *    pImageName (output)
 *       Points to a buffer to store process name in.  NOTE: this buffer is expected
 *       to be at least MAX_PROCESSNAME+1 characters in size.
 *    pLogonId (output)
 *       Points to variable to store process LogonId in.
 *    pPID (output)
 *       Points to variable to store process PID in.
 *    ppSID (output)
 *       Points to a pointer which is set to point to the process' SID on exit.
 *
 * EXIT:
 *    TRUE - information for the next process in the system has been placed into
 *          the referenced PLObject and pSID variables.
 *    FALSE - if the enumeration is done, GetLastError() will contain the
 *              ERROR_NO_MORE_ITEMS error code.  If another (true error) is
 *              encountered, that code will be set.
 *
 ******************************************************************************/


BOOL WINAPI
ProcEnumerateProcesses( HANDLE hServer,
                        PENUMTOKEN pEnumToken,
                        LPTSTR pImageName,
                        PULONG pLogonId,
                        PULONG pPID,
                        PSID *ppSID )
{
    int i;
    PTS_SYS_PROCESS_INFORMATION ProcessInfo;
    PCITRIX_PROCESS_INFORMATION CitrixInfo;

    if ((pEnumToken == NULL)
        || (pImageName == NULL)
        || (pLogonId == NULL)
        || (pPID == NULL)
        || (ppSID == NULL)
        )
    {
        return FALSE;
    }

    /*
     * Check for done with enumeration.
     */
    if ( pEnumToken->Current == (ULONG)-1 ) {

        SetLastError(ERROR_NO_MORE_ITEMS);

        if (pEnumToken->bGAP == TRUE)    // we used the GAP (GetAllProcesses) interface
        {
            //
            // Free ProcessArray and all child pointers allocated by the client stub.
            //
            WinStationFreeGAPMemory(GAP_LEVEL_BASIC,
                                    pEnumToken->ProcessArray,
                                    pEnumToken->NumberOfProcesses);
            pEnumToken->ProcessArray = NULL;
            pEnumToken->NumberOfProcesses = 0;

            return(FALSE);
        }
        else    // we used the old Hydra 4 interface
        {
            WinStationFreeMemory(pEnumToken->pProcessBuffer);
            pEnumToken->pProcessBuffer = NULL;
            return(FALSE);
        }
    }

    /*
     * Check for beginning enumeration.
     */
    if ( pEnumToken->Current == 0 ) {

        //
        // Try the new interface first (NT5 server ?)
        //
        if (WinStationGetAllProcesses( hServer,
                                       GAP_LEVEL_BASIC,
                                       &(pEnumToken->NumberOfProcesses),
                                       (PVOID *)&(pEnumToken->ProcessArray) ) )
        {
            pEnumToken->bGAP = TRUE;
        }
        else
        {
            //
            //   Check the return code indicating that the interface is not available.
            //
            DWORD dwError = GetLastError();
            if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
            {
                    pEnumToken->pProcessBuffer = NULL;
                return(FALSE);
            }
            else    // maybe a Hydra 4 server ?
            {

                if ( WinStationEnumerateProcesses( hServer,
                                                   (PVOID *)&(pEnumToken->pProcessBuffer)))
                {
                    pEnumToken->bGAP = FALSE;
                }
                else
                {
                                DWORD error = GetLastError();
                        if(pEnumToken->pProcessBuffer != NULL)
                    {
                        WinStationFreeMemory(pEnumToken->pProcessBuffer);
                            pEnumToken->pProcessBuffer = NULL;
                    }
                    return(FALSE);
                        }
            }
        }
    }

    if (pEnumToken->bGAP == TRUE)
    {
        ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)((pEnumToken->ProcessArray)[pEnumToken->Current].pTsProcessInfo);

        FetchProcessIDAndImageName(ProcessInfo,pPID,pImageName);

        //
        // Set the SessionId
        //
        *pLogonId = ProcessInfo->SessionId;

        //
        //  set the SID
        //
        *ppSID = (pEnumToken->ProcessArray)[pEnumToken->Current].pSid;

        (pEnumToken->Current)++;

        if ( (pEnumToken->Current) >= (pEnumToken->NumberOfProcesses) )
        {
            pEnumToken->Current = (ULONG)-1;    // sets the end of enumeration
        }
    }
    else
    {

        /*
         * Parse and store the next process' information.
         */

        ProcessInfo = (PTS_SYS_PROCESS_INFORMATION)
                            &(((PUCHAR)(pEnumToken->pProcessBuffer))[pEnumToken->Current]);

        FetchProcessIDAndImageName(ProcessInfo,pPID,pImageName);

        /*
         * Point to the CITRIX_INFORMATION which follows the Threads
         */
        CitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                     (((PUCHAR)ProcessInfo) +
                      SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                      (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)ProcessInfo->NumberOfThreads));

        /*
         * Fetch the LogonId and point to this SID for the primary
         * thread to use (copy).
         */
        if( CitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {

            *pLogonId = CitrixInfo->LogonId;
            *ppSID = CitrixInfo->ProcessSid;

        } else {

            *pLogonId = (ULONG)(-1);
            *ppSID = NULL;
       }

        /*
         * Increment the total offset count for next call.  If this is the
         * last process, set the offset to -1 so that next call will indicate
         * the end of the enumeration.
         */
        if ( ProcessInfo->NextEntryOffset != 0 )
            (pEnumToken->Current) += ProcessInfo->NextEntryOffset;
        else
            pEnumToken->Current = (ULONG)-1;
    }
    return(TRUE);

}  // end EnumerateProcesses
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\resource.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winadmin.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_WINADMTYPE                  129
#define IDI_SERVER                      131
#define IDD_SERVER_WINSTATIONS          132
#define IDD_SERVER_PROCESSES            133
#define IDI_BLANK                       134
#define IDD_SERVER_USERS                134
#define IDI_CONSOLE                     135
#define IDD_SERVER_LICENSES             135
#define IDD_DIALOG_FEATUREWARN          136
#define IDI_NET                         138
#define IDI_WORLD                       143
#define IDI_USER                        146
#define IDI_ENABLER                     149
#define IDI_QUESTIONMARK                151
#define IDI_REDSLASH                    152
#define IDD_WINSTATION_INFO             153
#define IDD_WINSTATION_PROCESSES        154
#define IDD_PREFERENCES                 156
#define IDD_SERVER_INFO                 157
#define IDI_NOTSIGN                     160
#define IDI_BASE                        161
#define IDI_BUMP                        162
#define IDI_UNKNOWN                     163
#define IDI_CHECK                       169
#define IDI_CURRENT_SERVER              170
#define IDI_CURRENT_USER                171
#define IDI_CURRENT_CONSOLE             172
#define IDI_CURRENT_NET                 173
#define IDI_ASYNC                       174
#define IDI_CURRENT_ASYNC               175
#define IDR_WINSTATION_POPUP            176
#define IDI_DIRECT_ASYNC                177
#define IDI_CURRENT_DIRECT_ASYNC        178
#define IDR_WINSTATION_TREE_POPUP       179
#define IDR_USER_POPUP                  180
#define IDR_PROCESS_POPUP               181
#define IDD_SHUTDOWN                    183
#define IDI_APPS                        185
#define IDI_GENERIC_APP                 186
#define IDI_APP_USER                    188
#define IDI_GLOBALGROUP                 189
#define IDI_LOCALGROUP                  190
#define IDI_DOMAIN                      191
#define IDI_CURRENT_DOMAIN              192
#define IDR_SERVER_POPUP                203
#define IDI_DOMAIN_NOT_CONNECTED        205
#define IDI_SERVER_NOT_CONNECTED        206
#define IDI_EXPLICIT                    209
#define IDI_ANONYMOUS                   210
#define IDB_APP_USERS                   211
#define IDR_DOMAIN_POPUP                212
#define IDR_ALLSERVERS_POPUP            213
#define IDD_DIALOG_SHADOWWARN           214
#define IDC_FWICON                      215
#define IDC_CHECK_NOMORE                216
#define IDD_SHADOWSTART                 240
#define IDC_SHADOWSTART_HOTKEY          241
#define IDC_SHADOWSTART_SHIFT           242
#define IDC_SHADOWSTART_CTRL            243
#define IDC_SHADOWSTART_ALT             244
#define IDD_MESSAGE                     250
#define IDC_MESSAGE_TITLE               251
#define IDC_MESSAGE_MESSAGE             252
#define IDD_DIALOG_FINDSERVER           253
#define IDC_EDIT_FINDSERVER             254
#define IDC_COMMON_USERNAME             300
#define IDC_COMMON_WINSTATIONNAME       301
#define IDC_COMMON_IBYTES               302
#define IDC_COMMON_OBYTES               303
#define IDC_COMMON_IFRAMES              304
#define IDC_COMMON_OFRAMES              305
#define IDC_COMMON_IBYTESPERFRAME       306
#define IDC_COMMON_OBYTESPERFRAME       307
#define IDC_COMMON_IFRAMEERRORS         308
#define IDC_COMMON_OFRAMEERRORS         309
#define IDC_COMMON_IPERCENTFRAMEERRORS  310
#define IDC_COMMON_OPERCENTFRAMEERRORS  311
#define IDC_COMMON_ITIMEOUTERRORS       312
#define IDC_COMMON_OTIMEOUTERRORS       313
#define IDC_COMMON_ICOMPRESSIONRATIO    314
#define IDC_COMMON_OCOMPRESSIONRATIO    315
#define IDC_REFRESHNOW                  320
#define IDC_RESETCOUNTERS               321
#define IDC_MOREINFO                    322
#define IDD_ASYNC_STATUS                350
#define IDC_ASYNC_DEVICE                351
#define IDC_ASYNC_BAUD                  352
#define IDC_ASYNC_DTR                   353
#define IDC_ASYNC_RTS                   354
#define IDC_ASYNC_CTS                   355
#define IDC_ASYNC_DSR                   356
#define IDC_ASYNC_DCD                   357
#define IDC_ASYNC_RI                    358
#define IDC_ASYNC_IFRAMING              359
#define IDC_ASYNC_IOVERRUN              360
#define IDC_ASYNC_IOVERFLOW             361
#define IDC_ASYNC_IPARITY               362
#define IDC_ASYNC_OFRAMING              363
#define IDC_ASYNC_OOVERRUN              364
#define IDC_ASYNC_OOVERFLOW             365
#define IDC_ASYNC_OPARITY               366
#define IDD_NETWORK_STATUS              370
#define IDC_NETWORK_LANADAPTER          371
#define IDC_NASI_PORTNAME               391
#define IDC_COMMON_IPERCENTFRAMEERRORS2 392
#define IDC_COMMON_OPERCENTFRAMEERRORS2 393
#define IDC_COMMON_ICOMPRESSIONRATIO2   394
#define IDC_COMMON_OCOMPRESSIONRATIO2   395
#define IDC_PRESS_NUMKEYPAD             396
#define IDC_PRESS_KEY                   397
#define IDD_CONNECT_PASSWORD            440
#define IDL_CPDLG_PROMPT                441
#define IDD_ALL_SERVER_LICENSES         441
#define IDC_CPDLG_PASSWORD              442
#define IDD_ALL_SERVER_PROCESSES        442
#define IDD_ALL_SERVER_USERS            443
#define IDD_ALL_SERVER_WINSTATIONS      444
#define IDD_ALL_SERVER_SERVERS          445
#define IDD_LISTENER                    447
#define IDD_WINSTATION_NOINFO           448
#define IDD_WINSTATION_CACHE            450
#define IDD_MESSAGE_PAGE                457
#define IDD_DOMAIN_LICENSES             458
#define IDD_WINSTATION_MODULES          461
#define IDS_NO_SERVER                   462
#define IDS_NOSERVER_REASON             463
#define IDS_CURRENT_DISCON              464
#define IDC_WINSTATION_LIST             1000
#define IDC_USER_LIST                   1001
#define IDC_LICENSE_LIST                1002
#define IDC_WINSTATION_PROCESS_LIST     1005
#define IDC_WINSTATION_MODULE_LIST      1006
#define IDC_PREFERENCES_PROC_MANUAL     1007
#define IDC_PREFERENCES_PROC_EVERY      1008
#define IDC_PREFERENCES_PROC_SECONDS    1009
#define IDC_PREFERENCES_PROC_SPIN       1010
#define IDC_PREFERENCES_STATUS_MANUAL   1011
#define IDC_PREFERENCES_STATUS_EVERY    1012
#define IDC_PREFERENCES_STATUS_SECONDS  1013
#define IDC_PREFERENCES_STATUS_SPIN     1014
#define IDC_PREFERENCES_CONFIRM         1015
#define IDC_PREFERENCES_SAVE            1016
#define IDC_PREFERENCES_HELP            1017
#define IDC_WS_INFO_USERNAME            1018
#define IDC_WS_INFO_CLIENTNAME          1019
#define IDC_WS_INFO_BUILD               1020
#define IDC_WS_INFO_DIR                 1021
#define IDC_WS_INFO_SERVER_BUFFERS      1022
#define IDC_WS_INFO_ADDRESS             1023
#define IDC_WS_INFO_PRODUCT_ID          1024
#define IDC_WS_INFO_CLIENT_BUFFERS      1025
#define IDC_WS_INFO_MODEM_NAME          1026
#define IDC_SERVER_LIST                 1028
#define IDC_WSINFO_HELP                 1035
#define IDC_WS_INFO_CLIENT_LICENSE      1036
#define IDC_WS_INFO_SERIAL_NUMBER       1038
#define IDC_PROCESS_LIST                1040
#define IDC_CITRIX_VERSION              1042
#define IDC_CITRIX_BUILD                1043
#define IDC_SERVICE_PACK                1045
#define IDC_HOTFIX_LIST                 1046
#define IDC_INSTALL_DATE                1047
#define IDC_LOCAL_INSTALLED             1050
#define IDC_LOCAL_INUSE                 1051
#define IDC_LOCAL_AVAILABLE             1052
#define IDC_POOL_INSTALLED              1053
#define IDC_POOL_INUSE                  1054
#define IDC_POOL_AVAILABLE              1055
#define IDC_WS_INFO_COLOR_DEPTH         1056
#define IDC_WS_INFO_RESOLUTION          1057
#define IDC_XXX                         1058
#define IDC_WS_INFO_CACHE               1059
#define IDC_TOTAL_INSTALLED             1060
#define IDC_TOTAL_INUSE                 1061
#define IDC_TOTAL_AVAILABLE             1062
#define IDC_BITMAP_SIZE                 1063
#define IDC_BITMAP_MINIMUM              1064
#define IDC_BITMAP_SIG_LEVEL            1065
#define IDC_TRACE                       1066
#define IDC_TCP_LOAD                    1068
#define IDC_IPX_LOAD                    1069
#define IDC_NETBIOS_LOAD                1070
#define IDC_TCP_LABEL                   1071
#define IDC_IPX_LABEL                   1072
#define IDC_NETBIOS_LABEL               1073
#define IDC_LABEL                       1076
#define IDC_SHUTDOWN_MSG                1077
#define IDC_HOTFIX_LABEL                1078
#define IDC_PRODUCT_NAME                1079
#define IDC_PRODUCT_VERSION             1080
#define IDC_LOAD_BALANCING_GROUP        1081
#define IDC_APPLICATION_SERVER_LIST     1082
#define IDC_APPLICATION_USER_LIST       1083
#define IDC_APPSERVER_USER_LIST         1085
#define IDC_APPLICATION_SECURITY_LIST   1086
#define IDC_MESSAGE                     1087
#define IDC_APP_TYPE                    1088
#define IDC_HIDE_TITLE_BAR              1089
#define IDC_APPUSERS_LABEL              1090
#define IDC_PREFERENCES_PERSISTENT      1091
#define IDC_MAXIMIZE_WINDOW             1092
#define IDC_ENCRYPTION_LEVEL            1093
#define IDC_APPLICATION_LIST            1094
#define IDC_APP_LIST                    1095
#define IDC_SERVER_TABS                 2001
#define IDC_WINSTATION_TABS             2002
#define IDC_ALL_SERVERS_TABS            2002
#define IDC_TREE_TABS                   2002
#define IDC_HOTFIX_LABEL2               2003
#define IDC_ALL_APPLICATION_TABS        2003
#define IDC_DOMAIN_TABS                 2004
#define IDV_BLANKVIEW                   3001
#define IDV_ALLSERVERSVIEW              3002
#define IDV_SERVERVIEW                  3003
#define IDV_WINSTATIONVIEW              3004
#define IDV_BADSERVERVIEW               3009
#define IDP_SERVER_WINSTATIONSPAGE      4001
#define IDP_SERVER_PROCESSESPAGE        4002
#define IDP_SERVER_USERSPAGE            4003
#define IDP_SERVER_LICENSESPAGE         4004
#define IDP_WINSTATION_INFOPAGE         4005
#define IDP_WINSTATION_PROCESSESPAGE    4006
#define IDP_SERVER_INFOPAGE             4007
#define IDP_ALL_SERVERS_SERVERSPAGE     4008
#define IDP_ALL_SERVERS_USERSPAGE       4009
#define IDP_ALL_SERVERS_LICENSESPAGE    4010
#define IDP_ALL_SERVERS_PROCESSESPAGE   4011
#define IDP_ALL_SERVERS_WINSTATIONSPAGE 4012
#define IDP_WINSTATION_NOINFOPAGE       4015
#define IDP_WINSTATION_CACHEPAGE        4017
#define IDP_WINSTATION_DISCINFOPAGE     4018
#define IDP_LISTENER                    4019
#define WM_ADMIN_TABBED_VIEW            4050
#define WM_FORCE_TREEVIEW_FOCUS         4051
#define WM_ADMIN_SHIFTTABBED_VIEW       4052
#define WM_ADMIN_CTRLTABBED_VIEW        4053
#define WM_ADMIN_CTRLSHIFTTABBED_VIEW   4054
#define WM_ADMIN_NEXTPANE_VIEW          4055
#define WM_ADMIN_CHANGEVIEW             5000
#define WM_ADMIN_EXPANDALL              5001
#define WM_WA_SERVER_CHANGEPAGE         5002
#define WM_ADMIN_COLLAPSEALL            5004
#define WM_ADMIN_COLLAPSETOSERVERS      5005
#define WM_STATUSABORT                  5006
#define WM_STATUSSTART                  5007
#define WM_STATUSREADY                  5008
#define WM_STATUSREFRESHNOW             5009
#define WM_ADMIN_ADD_SERVER             5010
#define WM_ADMIN_REMOVE_SERVER          5011
#define WM_ADMIN_UPDATE_SERVER          5012
#define WM_ADMIN_ADD_WINSTATION         5013
#define WM_ADMIN_REMOVE_WINSTATION      5014
#define WM_ADMIN_UPDATE_WINSTATION      5015
#define WM_ADMIN_UPDATE_PROCESSES       5016
#define WM_ISFAVLISTEMPTY               5017
#define WM_ADMIN_REDISPLAY_PROCESSES    5019
#define WM_ADMIN_UPDATE_SERVER_INFO     5020
#define WM_ADMIN_REDISPLAY_LICENSES     5021
#define WM_ADMIN_UPDATE_WINSTATIONS     5022
#define WM_ADMIN_REMOVE_PROCESS         5023
#define WM_ADMIN_ADD_APPLICATION        5024
#define WM_ADMIN_COLLAPSETODOMAINS      5025
#define WM_ADMIN_UPDATE_DOMAIN          5026
#define WM_ADMIN_VIEWS_READY            5027
#define WM_ADMIN_COLLAPSETOAPPS         5028
#define WM_ADMIN_ADDSERVERTOFAV         5029
#define WM_ADMIN_REMOVESERVERFROMFAV    5030
#define WM_ADMIN_GOTO_SERVER            5031
#define WM_ADMIN_DELTREE_NODE           5032
#define WM_ADMIN_GET_TV_STATES          5033
#define WM_ADMIN_UPDATE_TVSTATE         5034
#define WM_ADMIN_ADD_DOMAIN             5035
#define WM_ADMIN_CONNECT_TO_SERVER      5036
#define WM_ADMIN_FORCE_SEL_CHANGE       5037

#define IDM_REFRESH                     32771
#define IDM_CONNECT                     32772
#define IDM_DISCONNECT                  32773
#define IDM_MESSAGE                     32774
#define IDM_SHADOW                      32775
#define IDM_RESET                       32776
#define IDM_STATUS                      32777
#define IDM_LOGOFF                      32778
#define IDM_TERMINATE                   32779
#define IDM_EXPAND_ALL                  32780
#define IDM_PREFERENCES                 32799
#define IDM_COLLAPSE_ALL                32800
#define IDM_COLLAPSE_TOSERVERS          32801
#define IDM_SHOW_SYSTEM_PROCESSES       32803
#define IDM_COLLAPSE_TODOMAINS          32808

#define IDM_SERVER_ADDTOFAV             32809

#define IDM_SERVER_CONNECT              32810
#define IDM_SERVER_DISCONNECT           32811
#define IDTM_CONNECT                    32812
#define IDTM_DISCONNECT                 32813
#define IDTM_MESSAGE                    32814
#define IDTM_SHADOW                     32815
#define IDTM_RESET                      32816
#define IDTM_STATUS                     32817
#define IDTM_DOMAIN_CONNECT_ALL         32818
#define IDTM_DOMAIN_DISCONNECT_ALL      32819
#define IDTM_DOMAIN_FIND_SERVERS        32820
#define IDTM_ALLSERVERS_CONNECT         32821
#define IDTM_ALLSERVERS_DISCONNECT      32822
#define IDTM_ALLSERVERS_FIND            32823
#define IDM_ALLSERVERS_FIND             32824
#define IDM_ALLSERVERS_CONNECT          32825
#define IDM_ALLSERVERS_DISCONNECT       32826
#define IDM_DOMAIN_FIND_SERVERS         32829
#define IDM_DOMAIN_CONNECT_ALL          32830
#define IDM_DOMAIN_DISCONNECT_ALL       32831

#define IDTM_DOMAIN_FIND_SERVER         32832
#define IDM_ALLSERVERS_EMPTYFAVORITES   32833 

#define ID_CTRLTAB                      32834
#define ID_SHIFTTAB                     32835
#define ID_TAB                          32836
#define ID_CTRLSHIFTTAB                 32900
#define IDM_COLLAPSE_TOAPPS             33000
#define IDS_TREEROOT                    61204
#define IDS_TAB_PROPERTIES              61205
#define IDS_TAB_SECURITY                61206
#define IDS_TAB_CLIENT_SETTINGS         61207
#define IDS_TAB_WINSTATIONS             61208
#define IDS_TAB_PROCESSES               61209
#define IDS_TAB_INFO                    61210
#define IDS_TAB_INFORMATION             61210
#define IDS_COL_WINSTATION              61211
#define IDS_COL_USER                    61212
#define IDS_COL_ID                      61213
#define IDS_COL_TYPE                    61214
#define IDS_COL_COMMENT                 61215
#define IDS_COL_STATE                   61216
#define IDS_COL_IDLETIME                61217
#define IDS_COL_LOGONTIME               61218
#define IDS_TAB_SERVERS                 61219
#define IDS_TAB_USERS                   61220
#define IDS_TAB_LICENSES                61222
#define IDS_COL_CLIENT_NAME             61223
#define IDS_COL_LICENSE_NUMBER          61224
#define IDS_COL_LICENSE_DESC            61225
#define IDS_COL_LOCALCOUNT              61226
#define IDS_COL_USERCOUNT               61226
#define IDS_COL_POOLCOUNT               61227
#define IDS_COL_TOTALCOUNT              61228
#define IDS_COL_PID                     61229
#define IDS_COL_IMAGE                   61230
#define IDS_COL_FILENAME                61231
#define IDS_COL_FILEDATETIME            61232
#define IDS_COL_SIZE                    61233
#define IDS_COL_VERSIONS                61234
#define IDS_DEFAULT_MESSAGE_TITLE       61235
#define IDS_WARN_DISCONNECT             61236
#define IDS_WARN_RESET                  61237
#define IDS_WARN_LOGOFF                 61238
#define IDS_PWDDLG_USER                 61239
#define IDS_PWDDLG_WINSTATION           61240
#define IDS_REFRESH_RANGE               61241
#define IDS_DISCONNECTED                61242
#define IDS_COL_SERVER                  61243
#define IDS_IDLE                        61244
#define IDS_COL_TCPADDRESS              61248
#define IDS_COL_IPXADDRESS              61249
#define IDS_COL_NUM_WINSTATIONS         61250
#define IDS_SYSTEM_CONSOLE_NAME         61252
#define IDS_STATUS_FORMAT               61253
#define IDS_WARN_TERMINATE              61254
#define IDS_SERVER_DISAPPEARED          61255
#define IDS_COL_HOTFIX                  61256
#define IDS_COL_INSTALLED_BY            61257
#define IDS_COL_INSTALLED_ON            61258
#define IDS_CLIENT_CACHE                61259
#define IDS_CLIENT_RESOLUTION           61260
#define IDS_ERR_USER_LOGOFF             61261
#define IDS_ERR_MESSAGE                 61262
#define IDS_ERR_DISCONNECT              61263
#define IDS_ERR_RESET                   61264
#define IDS_ERR_CONNECT                 61265
#define IDS_ERR_SHADOW                  61266
#define IDS_ERR_SHADOW_DISABLED         61267
#define IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON 61268
#define IDS_TAB_CACHE                   61269
#define IDS_NONE                        61270
#define IDS_MOREINFO                    61271
#define IDS_LESSINFO                    61272
#define IDS_NO_LOAD_LICENSE             61273
#define IDS_COL_LICENSE_REGISTERED      61274
#define IDS_YES                         61275
#define IDS_NO                          61276
#define IDS_NOT_APPLICABLE              61277
#define IDS_DEVICE                      61278
#define IDS_EMBEDDED                    61279
#define IDS_DISCONNECTING               61280
#define IDS_SHUTDOWN_BGTHREAD           61281
#define IDS_SHUTDOWN_PROCTHREAD         61282
#define IDS_SHUTDOWN_PREFS              61283
#define IDS_SHUTDOWN_NOTIFY             61284
#define IDS_DONE                        61285
#define IDS_LISTENER                    61286
#define IDS_NO_LICENSE_PRIVILEGES       61287
#define IDS_PRODUCT_VERSION             61288
#define IDS_NO_EXTENSION_DLL            61289
#define IDS_NOT_AUTHENTICATED           61295
#define IDS_GATHERING_SERVER_INFO       61296
#define IDS_LISTENER_MSG                61297
#define IDS_INACTIVE_MSG                61298
#define IDS_PUBLISHED_APPS              61299
#define IDS_COL_COMMAND_LINE            61300
#define IDS_COL_WORKING_DIR             61301
#define IDS_COL_TCP_LOAD                61302
#define IDS_COL_IPX_LOAD                61303
#define IDS_COL_NETBIOS_LOAD            61304
#define IDS_EXPLICIT                    61305
#define IDS_ANONYMOUS                   61306
#define IDS_COL_USER_GROUP              61307
#define IDS_COL_USER_TYPE               61308
#define IDS_SYSTEM_IDLE_PROCESS         61309
#define IDS_SHUTDOWN_DOMAINTHREADS      61310
#define IDS_DOMAIN_FINDING_SERVERS      61311
#define IDS_CLICK_TO_CONNECT            61312
#define IDS_UNLIMITED                   61313
#define IDS_COLLAPSE_TODOMAINS          61319
#define IDS_TAB_MODULES                 61321
#define IDS_BUFFERS_FORMAT              61322
#define IDS_ERROR_NOT_TS                61323
#define IDS_CANNOT_TERMINATE            61324
#define ID_HELP1                        61325
#define IDS_CONNQ                       61326
#define ID_ENTER                        61327
#define ID_NEXTPANE                     61328
#define ID_PREVPANE                     61329
#define IDS_THISCOMPUTER                61330
#define IDS_FAVSERVERS                  61333
#define IDM_SERVER_REMOVEFAV            61334
#define ID_DELKEY                       61335
#define IDS_DOMAIN_DBLCLK_MSG           61336
#define IDM_ALLSERVERS_FAVALLADD        61337
#define IDM_ALLSERVERS_RUNSTRESS        61338
#define IDM_ALLSERVERS_RUNSTRESSLITE    61339
#define IDS_EMPTYFOLDER                 61340




// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        215
#define _APS_NEXT_COMMAND_VALUE         32837
#define _APS_NEXT_CONTROL_VALUE         1097
#define _APS_NEXT_SYMED_VALUE           174
#endif
#endif


//
// MUI localized strings for
// start menu, etc. DO NOT CHANGE THESE VALUES
// without updating tsoc.inx
//
#define IDS_TSADMIN_STARTMENU_NAME                10000
#define IDS_TSADMIN_STARTMENU_TIP                 10001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\rtpane.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* rtpane.cpp
*
* implementation of the CRightPane class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "rtpane.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


////////////////////////////
// MESSAGE MAP: CRightPane
//
IMPLEMENT_DYNCREATE(CRightPane, CView)

BEGIN_MESSAGE_MAP(CRightPane, CView)
	//{{AFX_MSG_MAP(CRightPane)
	ON_WM_SIZE()
	ON_MESSAGE(WM_ADMIN_CHANGEVIEW, OnAdminChangeView)
	ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
	ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE(WM_ADMIN_TABBED_VIEW , OnTabbedView)
    ON_MESSAGE(WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbedView )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbedView )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbedView )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
    ON_WM_SETFOCUS()    
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


RightPaneView CRightPane::views[NUMBER_OF_VIEWS] = {
	{ NULL, RUNTIME_CLASS( CBlankView ) },
	{ NULL, RUNTIME_CLASS( CAllServersView ) },
    { NULL, RUNTIME_CLASS( CDomainView ) },
	{ NULL, RUNTIME_CLASS( CServerView ) },
	{ NULL, RUNTIME_CLASS( CMessageView ) },
	{ NULL, RUNTIME_CLASS( CWinStationView ) },
};


/////////////////////////
// CRightPane ctor
//
// - the view pointers are initially set to NULL
// - the default view type is BLANK
//
CRightPane::CRightPane()
{
	m_CurrViewType = VIEW_BLANK;

}  // end CRightPane ctor


////////////////////////////
// CRightPane::OnDraw
//
void CRightPane::OnDraw(CDC* pDC)
{
   

}  // end CRightPane::OnDraw


/////////////////////////
// CRightPane dtor
//
CRightPane::~CRightPane()
{
}  // end CRightPane ctor


#ifdef _DEBUG
/////////////////////////////////
// CRightPane::AssertValid
//
void CRightPane::AssertValid() const
{
	CView::AssertValid();

}  // end CView::AssertValid


//////////////////////////
// CRightPane::Dump
//
void CRightPane::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CRightPane::Dump

#endif //_DEBUG


/////////////////////////////////////
// CRightPane::OnInitialUpdate
//
// - each of the default view objects is created
// - the CBlankView object is initially the 'active' view in the right pane
//
void CRightPane::OnInitialUpdate() 
{
	CView::OnInitialUpdate();
	
	CFrameWnd* pMainWnd = (CFrameWnd*)AfxGetMainWnd();
	CWinAdminDoc* pDoc = (CWinAdminDoc*)pMainWnd->GetActiveDocument();

	for(int vw = 0; vw < NUMBER_OF_VIEWS; vw++) {
		views[vw].m_pView = (CAdminView*)views[vw].m_pRuntimeClass->CreateObject();
      views[vw].m_pView->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, vw);
		pDoc->AddView(views[vw].m_pView);
	}

	pDoc->UpdateAllViews(NULL);
	
}  // end CRightPane::OnInitialUpdate


////////////////////////////
// CRightPane::OnSize
//
// - currently all views are sized to fit the view, whether they are 'active'
//   or not... this may change to sizing only the view that is 'active' if
//   it significantly impacts performance
//
void CRightPane::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	for(int i = 0; i < NUMBER_OF_VIEWS; i++) {
		if(views[i].m_pView && views[i].m_pView->GetSafeHwnd())
			views[i].m_pView->MoveWindow(&rect, TRUE);
	}

	CView::OnSize(nType, cx, cy);

}  // end CRightPane::OnSize


/////////////////////////////////////
// CRightPane::OnAdminChangeView
//
// - if the new view type is different from the current
//   view type, the new view type is made 'active', reset, and invalidated
// - if the new view type is the same as the current
//   view type, the current view is simply reset using the new
//   object pointer and then invalidated
//
//	lParam contains pointer to CTreeNode of current item in tree
//  wParam is TRUE if message caused by user clicking on tree item
//
LRESULT CRightPane::OnAdminChangeView(WPARAM wParam, LPARAM lParam)
{	
	CTreeNode* pNode = (CTreeNode*)lParam;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_CHANGING);

    ODS( L"CRightPane::OnAdminChangeView\n" );

    if( pNode == NULL )
    {
        ODS( L"CRightPane!OnAdminChangeView pNode invalid\n" );

        return 0;
    }

	void *resetParam = pNode->GetTreeObject();

	VIEW newView = VIEW_BLANK;

	switch(pNode->GetNodeType()) {

        case NODE_THIS_COMP: // FALL THROUGH
        case NODE_FAV_LIST:
            resetParam = pNode;
            newView = VIEW_ALL_SERVERS;            
            break;


		case NODE_ALL_SERVERS:
			newView = VIEW_ALL_SERVERS;            
            ODS( L"CRightPane::OnAdminChangeView = VIEW_ALL_SERVERS\n" );
			break;

        case NODE_DOMAIN:
			{
				CDomain *pDomain = (CDomain*)pNode->GetTreeObject();
				// If we haven't fired off a background thread for this
				// domain yet, do it now
				if(!pDomain->GetThreadPointer()) {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
                    // todo change message to let the user know that a dblclk action is required to
                    // start the enumeration process.
					resetParam = (void*)IDS_DOMAIN_DBLCLK_MSG;
					// pDomain->StartEnumerating();
				}
				else if(pDomain->IsState(DS_INITIAL_ENUMERATION))
				{
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void*)IDS_DOMAIN_FINDING_SERVERS;
				}
                else
                {
                    newView = VIEW_DOMAIN;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_DOMAIN\n" );
                }
			}
            break;

		case NODE_SERVER:
			{
                CServer *pServer = (CServer*)pNode->GetTreeObject();
                if(pServer->GetThreadHandle() == NULL) {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->GetThreadPointer\n" );
					// If we just disconnected from this server, we don't
					// want to reconnect
					if( ( pServer->IsState( SS_NOT_CONNECTED ) || pServer->IsPreviousState(SS_DISCONNECTING) ) && !wParam)
                    {
						resetParam = (void*)IDS_CLICK_TO_CONNECT;
					}
                    else
                    {
						resetParam = (void*)IDS_GATHERING_SERVER_INFO;
						pServer->Connect();
					}
                }
				else if(!pServer->IsServerSane())
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->IsServerSane\n" );
					resetParam = (void*)IDS_NOT_AUTHENTICATED;
				}
				else if(!pServer->IsState(SS_GOOD))
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE !pServer->IsState(SS_GOOD)\n" );
					resetParam = (void*)IDS_GATHERING_SERVER_INFO;
				}
				else
                {
                    newView = VIEW_SERVER;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_SERVER default\n" );
                }
			}
			break;

		case NODE_WINSTATION:
			{
				CWinStation *pWinStation = (CWinStation*)pNode->GetTreeObject();
				if(pWinStation->IsConnected() || pWinStation->IsState(State_Disconnected) ||
					pWinStation->IsState(State_Shadow))
                {
					newView = VIEW_WINSTATION;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_WINSTATION\n" );
                }
				else if(pWinStation->IsState(State_Listen))
                {
					newView = VIEW_MESSAGE;
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void *)IDS_LISTENER_MSG;
				}
				else
                {
					newView = VIEW_MESSAGE;	
                    ODS( L"CRightPane::OnAdminChangeView = VIEW_MESSAGE\n" );
					resetParam = (void *)IDS_INACTIVE_MSG;
				}
			}
			break;
	}

	if(m_CurrViewType != newView)
    {
        //views[newView].m_pView->Reset(resetParam);
		views[m_CurrViewType].m_pView->ModifyStyle(WS_VISIBLE, WS_DISABLED);	 
		m_CurrViewType = newView;
		
		views[newView].m_pView->ModifyStyle(WS_DISABLED, WS_VISIBLE);
		views[newView].m_pView->Reset(resetParam);
		views[newView].m_pView->Invalidate();
	}
    else
    {
		views[newView].m_pView->Reset(resetParam);  
	}


	((CWinAdminDoc*)GetDocument())->SetCurrentView(newView);
	
	return 0;

}  // end CRightPane::OnAdminChangeView


/////////////////////////////////////
// CRightPane::OnAdminAddServer
//
LRESULT CRightPane::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{	
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers"
	// or "Domain" is the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_ADD_SERVER, wParam, lParam);

	return 0;

}  // end CRightPane::OnAdminAddServer


/////////////////////////////////////
// CRightPane::OnAdminRemoveServer
//
LRESULT CRightPane::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// ODS( L"CRightPane::OnAdminRemoveServer\n" );
    // We only want to send this along if "All Listed Servers" or "Domain"
	// is the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
    {
        // ODS( L"view is ALL_SERVERS OR DOMAIN\n" );
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_SERVER, wParam, lParam);
    }

	return 0;

}  // end CRightPane::OnAdminRemoveServer


/////////////////////////////////////
// CRightPane::OnAdminUpdateServer
//
LRESULT CRightPane::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers" or Domain
	// the current view
    
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN)
    {        
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_SERVER, wParam, lParam);
    }
      
	return 0;

}  // end CRightPane::OnAdminUpdateServer


/////////////////////////////////////
// CRightPane::OnAdminUpdateProcesses
//
LRESULT CRightPane::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {
		case VIEW_ALL_SERVERS:
			bSendMessage = TRUE;
			break;

		case VIEW_DOMAIN:
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;

		case VIEW_WINSTATION:
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_PROCESSES, wParam, lParam);
	}

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateProcesses


/////////////////////////////////////
// CRightPane::OnAdminRemoveProcess
//
LRESULT CRightPane::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	// We only want to send this along if "All Listed Servers", VIEW_DOMAIN, or VIEW_SERVER is
	// the current view
	if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN || m_CurrViewType == VIEW_WINSTATION) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);
		return 0;
	}

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	if(m_CurrViewType == VIEW_SERVER && ((CServer*)((CProcess*)lParam)->GetServer() == (CServer*)pCurrentSelectedNode))
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REMOVE_PROCESS, wParam, lParam);

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateProcesses


/////////////////////////////////////
// CRightPane::OnAdminRedisplayProcesses
//
LRESULT CRightPane::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

    void *pCurrentSelectedNode = NULL;

    if(m_CurrViewType == VIEW_ALL_SERVERS || m_CurrViewType == VIEW_DOMAIN
			|| m_CurrViewType == VIEW_SERVER || m_CurrViewType == VIEW_WINSTATION)
    {
        if( m_CurrViewType == VIEW_ALL_SERVERS )
        {
            pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();
        }

		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_REDISPLAY_PROCESSES, ( WPARAM )m_CurrViewType , ( LPARAM )pCurrentSelectedNode );
    }

   return 0;                                                                  

}  // end CRightPane::OnAdminRedisplayProcesses


/////////////////////////////////////
// CRightPane::OnAdminUpdateWinStations
//
LRESULT CRightPane::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);
	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {

		case VIEW_ALL_SERVERS:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_ALL_SERVERS\n" );
            bSendMessage = TRUE;
            break;
        case VIEW_DOMAIN:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_DOMAIN\n" );
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_SERVER\n" );
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
        
		case VIEW_WINSTATION:
            ODS( L"CRightPane::OnAdminUpdateWinStations -- VIEW_WINSTATION\n" );
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, wParam, lParam);
	}

	return 0;                                                                  

}  // end CRightPane::OnAdminUpdateWinStations


/////////////////////////////////////
// CRightPane::OnAdminUpdateServerInfo
//
LRESULT CRightPane::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	BOOL bSendMessage = FALSE;

	void *pCurrentSelectedNode = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode();

	switch(m_CurrViewType) {
		case VIEW_DOMAIN:
			if((CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;
		
		case VIEW_SERVER:
			if((void*)lParam == pCurrentSelectedNode)
				bSendMessage = TRUE;
			break;

		case VIEW_WINSTATION:
			if((CServer*)lParam == (CServer*)((CWinStation*)pCurrentSelectedNode)->GetServer())
				bSendMessage = TRUE;
			break;
	}		
	
	if(bSendMessage) {
		views[m_CurrViewType].m_pView->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, wParam, lParam);
	}

	return 0;

}  // end CRightPane::OnAdminUpdateServerInfo


/////////////////////////////////////
// CRightPane::OnAdminRedisplayLicenses
//
LRESULT CRightPane::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
	ASSERT(lParam);

	if(m_CurrViewType == VIEW_ALL_SERVERS)
      views[VIEW_ALL_SERVERS].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

    else if(m_CurrViewType == VIEW_DOMAIN && (CDomain*)((CServer*)lParam)->GetDomain() == (CDomain*)((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode())
		views[VIEW_DOMAIN].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

	else if(m_CurrViewType == VIEW_SERVER && (CServer*)lParam == (CServer*)((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetCurrentSelectedNode())
		views[VIEW_SERVER].m_pView->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, wParam, lParam);

	return 0;

}  // end CRightPane::OnAdminRedisplayLicenses


/////////////////////////////////////
// CRightPane::OnSetFocus
//
void CRightPane::OnSetFocus(CWnd* pOldWnd) 
{
	CView::OnSetFocus(pOldWnd);
	
	views[m_CurrViewType].m_pView->SetFocus();
	
}   // end CRightPane::OnSetFocus

LRESULT CRightPane::OnTabbedView(WPARAM wParam, LPARAM lParam)
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_TABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnShiftTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_SHIFTTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnCtrlTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_CTRLTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnCtrlShiftTabbedView( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_CTRLSHIFTTABBED_VIEW , 0 , 0 );
}

LRESULT CRightPane::OnNextPane( WPARAM , LPARAM )
{
    return views[ m_CurrViewType ].m_pView->SendMessage( WM_ADMIN_NEXTPANE_VIEW , 0 , 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\rtpane.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* rtpane.h
*
* - declarations for the CRightPane class
* - the RightPane class is a public CView derivative that maintains
*   one of each of the default view type objects, swapping them
*   in and out of it's space as necessary (actually the views are
*   disabled/hidden and enabled/shown, but you get the idea...)
*
*******************************************************************************/

#ifndef _RIGHTPANE_H
#define _RIGHTPANE_H

#include "blankvw.h"	// CBlankView
#include "allsrvvw.h"	// CAllServersView
#include "domainvw.h"   // CDomainView
#include "servervw.h"	// CServerView
#include "winsvw.h"		// CWinStationView
#include "msgview.h"    // CMessageView

const int NUMBER_OF_VIEWS = 6;

typedef struct _rpview {
	CAdminView *m_pView;
	CRuntimeClass *m_pRuntimeClass;
} RightPaneView;


//////////////////////
// CLASS: CRightPane
//
class CRightPane : public CView
{
protected:
	CRightPane();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CRightPane)

// Attributes
protected:
   
	VIEW m_CurrViewType;	// keeps track of currently 'active' view in the right pane
   static RightPaneView views[NUMBER_OF_VIEWS];

// Operations
public:
	VIEW GetCurrentViewType() { return m_CurrViewType; }

protected:
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRightPane)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CRightPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CRightPane)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg LRESULT OnAdminChangeView(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminAddServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServer(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM, LPARAM);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM, LPARAM);
    afx_msg LRESULT OnTabbedView(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnShiftTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbedView( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    //}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CRightPane

#endif  // _RIGHTPANE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\servpgs.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servpgs.cpp
*
* implementations for the server info pages
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "servpgs.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////
// MESSAGE MAP: CUsersPage
//
IMPLEMENT_DYNCREATE(CUsersPage, CFormView)

BEGIN_MESSAGE_MAP(CUsersPage, CFormView)
	//{{AFX_MSG_MAP(CUsersPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_USER_LIST, OnUserItemChanged)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_USER_LIST, OnColumnClick)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_USER_LIST, OnSetfocusUserList)
   	//ON_NOTIFY(NM_KILLFOCUS, IDC_USER_LIST, OnKillfocusUserList)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


IMPLEMENT_DYNCREATE(CAdminPage, CFormView)

CAdminPage::CAdminPage(UINT id)
   : CFormView(id)
{

}

CAdminPage::CAdminPage()
	: CFormView((UINT)0)
{

}

/////////////////////////////
// F'N: CUsersPage ctor
//
CUsersPage::CUsersPage()
	: CAdminPage(CUsersPage::IDD)
{
	//{{AFX_DATA_INIT(CUsersPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CUsersPage ctor


/////////////////////////////
// F'N: CUsersPage dtor
//
CUsersPage::~CUsersPage()
{

}  // end CUsersPage dtor


////////////////////////////////////////
// F'N: CUsersPage::DoDataExchange
//
void CUsersPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CUsersPage)
	DDX_Control(pDX, IDC_USER_LIST, m_UserList);
	//}}AFX_DATA_MAP

}  // end CUsersPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CUsersPage::AssertValid
//
void CUsersPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CUsersPage::AssertValid


//////////////////////////////
// F'N: CUsersPage::Dump
//
void CUsersPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CUsersPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CUsersPage::OnSize
//
void CUsersPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_UserList.GetSafeHwnd())
		m_UserList.MoveWindow(&rect, TRUE);

	//CFormView::OnSize(nType, cx, cy);

}  // end CUsersPage::OnSize


static ColumnDef UserColumns[] = {
	CD_USER3,
	CD_SESSION,
	CD_ID,
	CD_STATE,
	CD_IDLETIME,
	CD_LOGONTIME
};

#define NUM_USER_COLUMNS sizeof(UserColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CUsersPage::OnInitialUpdate
//
void CUsersPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_USER_COLUMNS; col++) {
		columnString.LoadString(UserColumns[col].stringID);
		m_UserList.InsertColumn(col, columnString, UserColumns[col].format, UserColumns[col].width, col);
	}

	m_CurrentSortColumn = USERS_COL_USER;

}  // end CUsersPage::OnInitialUpdate


//////////////////////////////
// F'N: CUsersPage::OnUserItemChanged
//
void CUsersPage::OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
	
	if(pLV->uNewState & LVIS_SELECTED) {
		CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
		pWinStation->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(pLV->iItem);
		pWinStation->ClearSelected();
	}

	*pResult = 0;

}  // end CUsersPage::OnUserItemChanged

/////////////////////////////////////
// F'N: CUsersPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CUsersPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 2, 0);

	m_idxUser = AddIconToImageList(IDI_USER);
	m_idxCurrentUser  = AddIconToImageList(IDI_CURRENT_USER);

	m_UserList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CUsersPage::BuildImageList


/////////////////////////////////////////
// F'N: CUsersPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CUsersPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CUsersPage::AddIconToImageList


//////////////////////////////
// F'N: CUsersPage::Reset
//
void CUsersPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayUsers();

}  // end CUsersPage::Reset


//////////////////////////////
// F'N: CUsersPage::UpdateWinStations
//
void CUsersPage::UpdateWinStations(CServer *pServer)
{
	if(pServer != m_pServer) return;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	// Loop through the WinStations
	m_pServer->LockWinStationList();
	CObList *pWinStationList = m_pServer->GetWinStationList();

	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pWinStation;

		// Find the WinStation in our list
		int item = m_UserList.FindItem(&FindInfo, -1);

		// If the process is new and isn't currently in the list,
		// add it to the list
		if(pWinStation->IsNew() && pWinStation->HasUser() && item == -1) {

			AddUserToList(pWinStation);
			bAnyAdded = TRUE;
			continue;
		}

		// If the WinStation is no longer current or no longer has a user,
		// remove it from the list
		if((!pWinStation->IsCurrent() || !pWinStation->HasUser()) && item != -1) {
			// Remove the WinStation from the list
			m_UserList.DeleteItem(item);
			pWinStation->ClearSelected();
			continue;
		}

		// If the WinStation info has changed, change
		// it's info in our tree
		if(pWinStation->IsChanged() && item != -1) {
			// change the user name
			m_UserList.SetItemText(item, USERS_COL_USER, pWinStation->GetUserName());
			// change the WinStation Name

			// WinStation Name
			if(pWinStation->GetName()[0])
			    m_UserList.SetItemText(item, USERS_COL_WINSTATION, pWinStation->GetName());
			else {
				CString NameString(" ");
				if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
				if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
			    m_UserList.SetItemText(item, USERS_COL_WINSTATION, NameString);
			}

			// change the Connect State
			m_UserList.SetItemText(item, USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));
			// change the Idle Time
			TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

			ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

			if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
			{
				ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
			}
			else wcscpy(IdleTimeString, TEXT("."));

			m_UserList.SetItemText(item, USERS_COL_IDLETIME, IdleTimeString);
			// change the Logon Time
			TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
			// We don't want to pass a 0 logon time to DateTimeString()
			// It will blow up if the timezone is GMT
			if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
				DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
				pDoc->FixUnknownString(LogonTimeString);
			}
			else LogonTimeString[0] = '\0';
			// change the 

			m_UserList.SetItemText(item, USERS_COL_LOGONTIME, LogonTimeString);

			if(m_CurrentSortColumn != USERS_COL_ID)
				bAnyChanged = TRUE;

			continue;
		}

		// If the WinStation is not in the list but now has a user, add it to the list
		if(item == -1 && pWinStation->IsCurrent() && pWinStation->HasUser()) {
			AddUserToList(pWinStation);
			bAnyAdded = TRUE;
		}
	}

	m_pServer->UnlockWinStationList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);

}  // end CUsersPage::UpdateWinStations


//////////////////////////////
// F'N: CUsersPage::AddUserToList
//
int CUsersPage::AddUserToList(CWinStation *pWinStation)
{
    int item = -1;

    if( pWinStation != NULL )
    {
	    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	    LockListControl();
	    //////////////////////
	    // Fill in the columns
	    //////////////////////
	    
	    // User - put at the end of the list
	    item = m_UserList.InsertItem(m_UserList.GetItemCount(), pWinStation->GetUserName(), 
		    pWinStation->IsCurrentUser() ? m_idxCurrentUser : m_idxUser);

	    // WinStation Name
	    if(pWinStation->GetName()[0])
	        m_UserList.SetItemText(item, USERS_COL_WINSTATION, pWinStation->GetName());
	    else {
		    CString NameString(" ");
		    if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
		    if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
	        m_UserList.SetItemText(item, USERS_COL_WINSTATION, NameString);
	    }

	    // Logon ID
	    CString ColumnString;
	    ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
	    m_UserList.SetItemText(item, USERS_COL_ID, ColumnString);

	    // Connect State
	    m_UserList.SetItemText(item, USERS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

	    // Idle Time
	    TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

	    ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

	    if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
	    {
		    ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
	    }
	    else wcscpy(IdleTimeString, TEXT("."));

	    m_UserList.SetItemText(item, USERS_COL_IDLETIME, IdleTimeString);

	    // Logon Time
	    TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
	    // We don't want to pass a 0 logon time to DateTimeString()
	    // It will blow up if the timezone is GMT
	    if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
		    DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
		    pDoc->FixUnknownString(LogonTimeString);
	    }
	    else LogonTimeString[0] = '\0';

	    m_UserList.SetItemText(item, USERS_COL_LOGONTIME, LogonTimeString);

	    // Attach a pointer to the CWinStation structure to the list item
	    m_UserList.SetItemData(item, (DWORD_PTR)pWinStation);

        // m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	    UnlockListControl();
    }

	return item;

}  // end CUsersPage::AddUserToList


/////////////////////////////////////
// F'N: CUsersPage::DisplayUsers
//
void CUsersPage::DisplayUsers()
{
	LockListControl();

	// Clear out the list control
	m_UserList.DeleteAllItems();

	m_pServer->LockWinStationList();
	// Get a pointer to this server's list of WinStations
	CObList *pWinStationList = m_pServer->GetWinStationList();

	// Iterate through the WinStation list
	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		// only show the WinStation if it has a user
		if(pWinStation->HasUser()) {
			AddUserToList(pWinStation);
		}
	}	// end while(pos)

    //bug #191727
    //m_UserList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	m_pServer->UnlockWinStationList();

	UnlockListControl();

}  // end CUsersPage::DisplayUsers


//////////////////////////////
// F'N: CUsersPage::OnColumnClick
//
void CUsersPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    
    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_USERS, &m_UserList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CUsersPage::OnColumnClick


//////////////////////////////
// F'N: CUsersPage::OnContextMenu
//
void CUsersPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_UserList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_UserList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
			/*
		m_UserList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_UserList.HitTest(ptClient, &flags);
        if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
        {
            //
            // ListView HitTest bug? return -1 but item display as selected.
            // workaround for now, Al can fix this later
            //
            UINT iCount = m_UserList.GetItemCount( );
            RECT rc;

            for( Item = 0 ; Item < iCount ; Item++ )
            {
                if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
                {
                    break;
                }
            }

            if( Item >= iCount )
            {
                return;
            }

        }

        //
        // NM_RCLICK (WM_NOTIFY) then WM_CNTEXTMENU but no NM_ITEMCHANGED message
        // manually set it to selected state
        //
        CWinStation *pWinStation = (CWinStation*)m_UserList.GetItemData(Item);

        if( !pWinStation )
            return;

        if( m_UserList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
        {
            pWinStation->SetSelected();
        }
	}

	CMenu menu;
	menu.LoadMenu(IDR_USER_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CUsersPage::OnContextMenu

/////////////////////////////////////
// F'N: CUsersPage::ClearSelections
//
void CUsersPage::ClearSelections()
{
    
    if(m_UserList.m_hWnd != NULL)
    {
        POSITION pos = m_UserList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_UserList.GetNextSelectedItem(pos);
            m_UserList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

////////////////////////////////
// MESSAGE MAP: CServerWinStationsPage
//
IMPLEMENT_DYNCREATE(CServerWinStationsPage, CFormView)

BEGIN_MESSAGE_MAP(CServerWinStationsPage, CFormView)
	//{{AFX_MSG_MAP(CServerWinStationsPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_LIST, OnWinStationItemChanged)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_LIST, OnColumnClick)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_LIST, OnSetfocusWinstationList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_WINSTATION_LIST, OnKillfocusWinstationList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerWinStationsPage ctor
//
CServerWinStationsPage::CServerWinStationsPage()
	: CAdminPage(CServerWinStationsPage::IDD)
{
	//{{AFX_DATA_INIT(CServerWinStationsPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerWinStationsPage ctor


/////////////////////////////
// F'N: CServerWinStationsPage dtor
//
CServerWinStationsPage::~CServerWinStationsPage()
{

}  // end CServerWinStationsPage dtor


////////////////////////////////////////
// F'N: CServerWinStationsPage::DoDataExchange
//
void CServerWinStationsPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerWinStationsPage)
	DDX_Control(pDX, IDC_WINSTATION_LIST, m_StationList);
	//}}AFX_DATA_MAP

}  // end CServerWinStationsPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerWinStationsPage::AssertValid
//
void CServerWinStationsPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerWinStationsPage::AssertValid


//////////////////////////////
// F'N: CServerWinStationsPage::Dump
//
void CServerWinStationsPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerWinStationsPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CServerWinStationsPage::OnWinStationItemChanged
//
void CServerWinStationsPage::OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

	if(pLV->uNewState & LVIS_SELECTED) {
		CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
		pWinStation->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CWinStation *pWinStation = (CWinStation*)m_StationList.GetItemData(pLV->iItem);
		pWinStation->ClearSelected();
	}

	*pResult = 0;

}  // end CServerWinStationsPage::OnWinStationItemChanged


//////////////////////////////
// F'N: CServerWinStationsPage::OnSize
//
void CServerWinStationsPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_StationList.GetSafeHwnd())
		m_StationList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerWinStationsPage::OnSize


static ColumnDef WinsColumns[] = {
	CD_SESSION2,
	CD_USER2,
	CD_ID,
	CD_STATE,
	CD_TYPE,
	CD_CLIENT_NAME,
	CD_IDLETIME,
	CD_LOGONTIME,
	CD_COMMENT
};

#define NUM_WINS_COLUMNS sizeof(WinsColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CServerWinStationsPage::OnInitialUpdate
//
void CServerWinStationsPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	// builds the image list for the list control
	BuildImageList();		

	// Add the column headings
	CString columnString;

	for(int col = 0; col < NUM_WINS_COLUMNS; col++) {
		columnString.LoadString(WinsColumns[col].stringID);
		m_StationList.InsertColumn(col, columnString, WinsColumns[col].format, WinsColumns[col].width, col);
	}
	m_CurrentSortColumn = WS_COL_WINSTATION;


}  // end CServerWinStationsPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CServerWinStationsPage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CServerWinStationsPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 11, 0);

	m_idxBlank  = AddIconToImageList(IDI_BLANK);
	m_idxCitrix = AddIconToImageList(IDR_MAINFRAME);
	m_idxServer = AddIconToImageList(IDI_SERVER);
	m_idxConsole = AddIconToImageList(IDI_CONSOLE);
	m_idxNet = AddIconToImageList(IDI_NET);
	m_idxAsync = AddIconToImageList(IDI_ASYNC);
	m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
	m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
	m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
	m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
	m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);
	
	m_StationList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CServerWinStationsPage::BuildImageList


/////////////////////////////////////////
// F'N: CServerWinStationsPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CServerWinStationsPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CServerWinStationsPage::AddIconToImageList


//////////////////////////////
// F'N: CServerWinStationsPage::Reset
//
void CServerWinStationsPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayStations();

}  // end CServerWinStationsPage::Reset


//////////////////////////////
// F'N: CServerWinStationsPage::UpdateWinStations
//
void CServerWinStationsPage::UpdateWinStations(CServer *pServer)
{
	if(pServer != m_pServer) return;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	// Loop through the WinStations
	m_pServer->LockWinStationList();
	CObList *pWinStationList = m_pServer->GetWinStationList();

	POSITION pos = pWinStationList->GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pWinStation;

		// Find the WinStation in our list
		int item = m_StationList.FindItem(&FindInfo, -1);

		// If the process is new and not currently in the list,
		// add it to the list
		if(pWinStation->IsNew() && item == -1) {

			AddWinStationToList(pWinStation);
			bAnyAdded = TRUE;
			continue;
		}


		// If the WinStation is no longer current,
		// remove it from the list
		if(!pWinStation->IsCurrent() && item != -1) {
			// Remove the WinStation from the list
			m_StationList.DeleteItem(item);
			pWinStation->ClearSelected();
			continue;
		}

		// If the WinStation info has changed, change
		// it's info in our tree
		if(pWinStation->IsChanged() && item != -1) {

			// Figure out which icon to use
			int WhichIcon = m_idxBlank;
			BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
					
			if(pWinStation->GetState() != State_Disconnected 
			&& pWinStation->GetState() != State_Idle) {
				switch(pWinStation->GetSdClass()) {
					case SdAsync:
						if(pWinStation->IsDirectAsync())
							WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
						else
							WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
						break;

					case SdNetwork:
						WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
						break;

					default:
						WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
					break;
				}
			}

			m_StationList.SetItem(item, 0, LVIF_IMAGE, 0, WhichIcon, 0, 0, 0L);

			// WinStation Name
			if(pWinStation->GetName()[0])
				m_StationList.SetItemText(item, WS_COL_WINSTATION, pWinStation->GetName());
			else {
				CString NameString(" ");
				if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
				if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
				m_StationList.SetItemText(item, WS_COL_WINSTATION, NameString);
			}

			// User
			m_StationList.SetItemText(item, WS_COL_USER, pWinStation->GetUserName());

			// Logon ID
			CString ColumnString;
			ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
			m_StationList.SetItemText(item, WS_COL_ID, ColumnString);

			// Connect State
			m_StationList.SetItemText(item, WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

			// Type
			m_StationList.SetItemText(item, WS_COL_TYPE, pWinStation->GetWdName());

			// Client Name
			m_StationList.SetItemText(item, WS_COL_CLIENTNAME, pWinStation->GetClientName());

			// Idle Time
			TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

			ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

			if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
			{
				ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
			}
			else wcscpy(IdleTimeString, TEXT("."));

			m_StationList.SetItemText(item, WS_COL_IDLETIME, IdleTimeString);
	
			// Logon Time
			TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
			// We don't want to pass a 0 logon time to DateTimeString()
			// It will blow up if the timezone is GMT
			if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
				DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
				pDoc->FixUnknownString(LogonTimeString);
			}
			else LogonTimeString[0] = '\0';

			m_StationList.SetItemText(item, WS_COL_LOGONTIME, LogonTimeString);

			// Comment
			m_StationList.SetItemText(item, WS_COL_COMMENT, pWinStation->GetComment());

			if(m_CurrentSortColumn != WS_COL_ID)
				bAnyChanged = TRUE;
		}
	}

	m_pServer->UnlockWinStationList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

}


//////////////////////////////
// F'N: CServerWinStationsPage::AddWinStationToList
//
int CServerWinStationsPage::AddWinStationToList(CWinStation *pWinStation)
{
	CServer *pServer = pWinStation->GetServer();

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	// Figure out which icon to use
	int WhichIcon = m_idxBlank;
	BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
					
	if(pWinStation->GetState() != State_Disconnected 
		&& pWinStation->GetState() != State_Idle) {
		switch(pWinStation->GetSdClass()) {
			case SdAsync:
				if(pWinStation->IsDirectAsync())
					WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
				else
					WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
				break;
	
			case SdNetwork:
				WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
				break;

			default:
				WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
				break;
		}
	}

	//////////////////////
	// Fill in the columns
	//////////////////////
	LockListControl();

	int item;
	// WinStation Name
	if(pWinStation->GetName()[0])
		item = m_StationList.InsertItem(m_StationList.GetItemCount(), pWinStation->GetName(), WhichIcon);
	else {
		CString NameString(" ");
		if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
		if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
		item = m_StationList.InsertItem(m_StationList.GetItemCount(), NameString, WhichIcon);
	}

	// User
	m_StationList.SetItemText(item, WS_COL_USER, pWinStation->GetUserName());

	// Logon ID
	CString ColumnString;
	ColumnString.Format(TEXT("%lu"), pWinStation->GetLogonId());
	m_StationList.SetItemText(item, WS_COL_ID, ColumnString);

	// Connect State
	m_StationList.SetItemText(item, WS_COL_STATE, StrConnectState(pWinStation->GetState(), FALSE));

	// Type
	m_StationList.SetItemText(item, WS_COL_TYPE, pWinStation->GetWdName());

	// Client Name
	m_StationList.SetItemText(item, WS_COL_CLIENTNAME, pWinStation->GetClientName());

	// Idle Time
	TCHAR IdleTimeString[MAX_ELAPSED_TIME_LENGTH];

	ELAPSEDTIME IdleTime = pWinStation->GetIdleTime();

	if(IdleTime.days || IdleTime.hours || IdleTime.minutes || IdleTime.seconds)
	{
		ElapsedTimeString( &IdleTime, FALSE, IdleTimeString);
	}
	else wcscpy(IdleTimeString, TEXT("."));

	m_StationList.SetItemText(item, WS_COL_IDLETIME, IdleTimeString);

	// Logon Time
	TCHAR LogonTimeString[MAX_DATE_TIME_LENGTH];
	// We don't want to pass a 0 logon time to DateTimeString()
	// It will blow up if the timezone is GMT
	if(pWinStation->GetState() == State_Active && pWinStation->GetLogonTime().QuadPart) {
		DateTimeString(&(pWinStation->GetLogonTime()), LogonTimeString);
		pDoc->FixUnknownString(LogonTimeString);
	}
	else LogonTimeString[0] = '\0';

	m_StationList.SetItemText(item, WS_COL_LOGONTIME, LogonTimeString);

	// Comment
	m_StationList.SetItemText(item, WS_COL_COMMENT, pWinStation->GetComment());

	// Attach a pointer to the CWinStation structure to the list item
	m_StationList.SetItemData(item, (DWORD_PTR)pWinStation);

    // m_StationList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	UnlockListControl();
	return item;

}  // end CServerWinStationsPage::AddWinStationToList


/////////////////////////////////////
// F'N: CServerWinStationsPage::DisplayStations
//
void CServerWinStationsPage::DisplayStations()
{
	LockListControl();

	// Clear out the list control
	m_StationList.DeleteAllItems();

	m_pServer->LockWinStationList();
	// Get a pointer to this server's list of WinStations
	CObList *pWinStationList = m_pServer->GetWinStationList();

	// Iterate through the WinStation list
	POSITION pos2 = pWinStationList->GetHeadPosition();

	while(pos2) {
		CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos2);

		AddWinStationToList(pWinStation);
	}
    
    //bug #191727
    //m_StationList.SetItemState( m_StationList.GetItemCount() - 1 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

    // We don't want the same order as the tree list, but an alphabetical order instead
	SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);

	m_pServer->UnlockWinStationList();

	UnlockListControl();

}  // end CServerWinStationsPage::DisplayStations


//////////////////////////////
// F'N: CServerWinStationsPage::OnColumnClick
//
void CServerWinStationsPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_WINSTATIONS, &m_StationList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CServerWinStationsPage::OnColumnClick


//////////////////////////////
// F'N: CServerWinStationsPage::OnContextMenu
//
void CServerWinStationsPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_StationList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_StationList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_StationList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		/*
		RECT rect;
		m_StationList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_StationList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_WINSTATION_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerWinStationsPage::OnContextMenu

/////////////////////////////////////
// F'N: CServerWinStationsPage::ClearSelections
//
void CServerWinStationsPage::ClearSelections()
{
    
    if(m_StationList.m_hWnd != NULL)
    {
        POSITION pos = m_StationList.GetFirstSelectedItemPosition();
        while (pos)
        {
            int nItem = m_StationList.GetNextSelectedItem(pos);
            m_StationList.SetItemState(nItem,0,LVIS_SELECTED);
        }
    }
}

//////////////////////////////////
// MESSAGE MAP: CServerProcessesPage
//
IMPLEMENT_DYNCREATE(CServerProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CServerProcessesPage, CFormView)
	//{{AFX_MSG_MAP(CServerProcessesPage)
		ON_WM_SIZE()
		ON_NOTIFY(LVN_COLUMNCLICK, IDC_PROCESS_LIST, OnColumnClick)
		ON_NOTIFY(LVN_ITEMCHANGED, IDC_PROCESS_LIST, OnProcessItemChanged)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_PROCESS_LIST, OnSetfocusProcessList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_PROCESS_LIST, OnKillfocusProcessList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////
// F'N: CServerProcessesPage ctor
//
CServerProcessesPage::CServerProcessesPage()
	: CAdminPage(CServerProcessesPage::IDD)
{
	//{{AFX_DATA_INIT(CServerProcessesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerProcessesPage ctor


///////////////////////////////
// F'N: CServerProcessesPage dtor
//
CServerProcessesPage::~CServerProcessesPage()
{

}  // end CServerProcessesPage dtor


//////////////////////////////////////////
// F'N: CServerProcessesPage::DoDataExchange
//
void CServerProcessesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerProcessesPage)
	DDX_Control(pDX, IDC_PROCESS_LIST, m_ProcessList);
	//}}AFX_DATA_MAP

}  // end CServerProcessesPage::DoDataExchange


#ifdef _DEBUG
///////////////////////////////////////
// F'N: CServerProcessesPage::AssertValid
//
void CServerProcessesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerProcessesPage::AssertValid


////////////////////////////////
// F'N: CServerProcessesPage::Dump
//
void CServerProcessesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerProcessesPage::Dump

#endif //_DEBUG


///////////////////////////////
// F'N: CServerProcessesPage::Reset
//
void CServerProcessesPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	m_pServer->EnumerateProcesses();
	DisplayProcesses();

}  // end CServerProcessesPage::Reset


///////////////////////////////
// F'N: CServerProcessesPage::OnSize
//
void CServerProcessesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_ProcessList.GetSafeHwnd())
		m_ProcessList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerProcessesPage::OnSize


static ColumnDef ProcColumns[] = {
	CD_USER,
	CD_SESSION,
	CD_PROC_ID,
	CD_PROC_PID,
	CD_PROC_IMAGE
};

#define NUM_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

///////////////////////////////
// F'N: CServerProcessesPage::OnInitialUpdate
//
void CServerProcessesPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	// Add the column headings
	CString columnString;

	for(int col = 0; col < NUM_PROC_COLUMNS; col++) {
		columnString.LoadString(ProcColumns[col].stringID);
		m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
	}

	m_CurrentSortColumn = PROC_COL_USER;

}  // end CServerProcessesPage::OnInitialUpdate


///////////////////////////////
// F'N: CServerProcessesPage::UpdateProcesses
//
void CServerProcessesPage::UpdateProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	LockListControl();

	// Loop through the processes
	m_pServer->LockProcessList();
	CObList *pProcessList = m_pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes unless it
		// is a System process
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
			continue;

		// If the process is new, add it to the list
		if(pProcess->IsNew()) {

			AddProcessToList(pProcess);
			bAnyAdded = TRUE;
			continue;
		}

		LV_FINDINFO FindInfo;
		FindInfo.flags = LVFI_PARAM;
		FindInfo.lParam = (LPARAM)pProcess;

		// Find the Process in our list
		int item = m_ProcessList.FindItem(&FindInfo, -1);

		// If the process is no longer current,
		// remove it from the list
		if(!pProcess->IsCurrent() && item != -1) {
			// Remove the Process from the list
			m_ProcessList.DeleteItem(item);
			pProcess->ClearSelected();
		}

   		// If the process info has changed, change
		// it's info in our tree
		if(pProcess->IsChanged() && item != -1) 
		{
			// WinStation Name
			CWinStation *pWinStation = pProcess->GetWinStation();
			if(pWinStation)
			{
				if(pWinStation->GetName()[0])
					m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, pWinStation->GetName());
				else
				{
					CString NameString(" ");
					if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
					if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
					m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, NameString);
				}
			}

			if(m_CurrentSortColumn == PROC_COL_WINSTATION)
				bAnyChanged = TRUE;
		}
	}

	m_pServer->UnlockProcessList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	UnlockListControl();

}  // end CServerProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CServerProcessesPage::RemoveProcess
//
void CServerProcessesPage::RemoveProcess(CProcess *pProcess)
{
	ASSERT(pProcess);

    // If the server isn't the server the process is running on,
	// there's nothing to do        
    if(m_pServer != pProcess->GetServer()) return;

	LockListControl();

	// Find out how many items in the list
	int ItemCount = m_ProcessList.GetItemCount();

	// Go through the items and remove this process
	for(int item = 0; item < ItemCount; item++) {
		CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);
		
		if(pListProcess == pProcess) {
			m_ProcessList.DeleteItem(item);
			break;
		}
	}

	UnlockListControl();
}

///////////////////////////////
// F'N: CServerProcessesPage::AddProcessToList
//
int CServerProcessesPage::AddProcessToList(CProcess *pProcess)
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	LockListControl();
	// User - put at the end of the list
	int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), pProcess->GetUserName(), NULL);

	// WinStation Name
	CWinStation *pWinStation = pProcess->GetWinStation();
	if(pWinStation) {
		if(pWinStation->GetName()[0])
		    m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, pWinStation->GetName());
		else {
			CString NameString(" ");
			if(pWinStation->GetState() == State_Disconnected) NameString.LoadString(IDS_DISCONNECTED);
			if(pWinStation->GetState() == State_Idle) NameString.LoadString(IDS_IDLE);
		    m_ProcessList.SetItemText(item, PROC_COL_WINSTATION, NameString);
		}
	}
	
	// ID
	CString ProcString;
	ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
	m_ProcessList.SetItemText(item, PROC_COL_ID, ProcString);

	// PID
	ProcString.Format(TEXT("%lu"), pProcess->GetPID());
	m_ProcessList.SetItemText(item, PROC_COL_PID, ProcString);

	// Image
	m_ProcessList.SetItemText(item, PROC_COL_IMAGE, pProcess->GetImageName());

	m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);

    // m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );

	UnlockListControl();

	return item;

}  // end CServerProcessesPage::AddProcessToList


///////////////////////////////
// F'N: CServerProcessesPage::DisplayProcesses
//
void CServerProcessesPage::DisplayProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	LockListControl();

	// Clear out the list control
	m_ProcessList.DeleteAllItems();

	m_pServer->LockProcessList();
	CObList *pProcessList = m_pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes unless it is
		// a System process
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers() && !pProcess->IsSystemProcess())
			continue;

		AddProcessToList(pProcess);
	}

    m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
	
	m_pServer->UnlockProcessList();

	SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	UnlockListControl();

}  // end CServerProcessesPage::DisplayProcesses


///////////////////////////////
// F'N: CServerProcessesPage::OnProcessItemChanged
//
void CServerProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;

	if(pLV->uNewState & LVIS_SELECTED) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->ClearSelected();
	}

	*pResult = 0;

}  // end CServerProcessesPage::OnProcessItemChanged


///////////////////////////////
// F'N: CServerProcessesPage::OnColumnClick
//
void CServerProcessesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	LockListControl();
	SortByColumn(VIEW_SERVER, PAGE_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);
	UnlockListControl();

	*pResult = 0;

}  // end CServerProcessesPage::OnColumnClick


//////////////////////////////
// F'N: CServerProcessesPage::OnContextMenu
//
void CServerProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_ProcessList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		
		/*
		RECT rect;
		m_ProcessList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_ProcessList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_PROCESS_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerProcessesPage::OnContextMenu


////////////////////////////////
// MESSAGE MAP: CServerLicensesPage
//
IMPLEMENT_DYNCREATE(CServerLicensesPage, CFormView)

BEGIN_MESSAGE_MAP(CServerLicensesPage, CFormView)
	//{{AFX_MSG_MAP(CServerLicensesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_LICENSE_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_LICENSE_LIST, OnSetfocusLicenseList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_LICENSE_LIST, OnKillfocusLicenseList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerLicensesPage ctor
//
CServerLicensesPage::CServerLicensesPage()
	: CAdminPage(CServerLicensesPage::IDD)
{
	//{{AFX_DATA_INIT(CServerLicensesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CServerLicensesPage ctor


/////////////////////////////
// F'N: CServerLicensesPage dtor
//
CServerLicensesPage::~CServerLicensesPage()
{
}  // end CServerLicensesPage dtor


////////////////////////////////////////
// F'N: CServerLicensesPage::DoDataExchange
//
void CServerLicensesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerLicensesPage)
	DDX_Control(pDX, IDC_LICENSE_LIST, m_LicenseList);
	//}}AFX_DATA_MAP

}  // end CServerLicensesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerLicensesPage::AssertValid
//
void CServerLicensesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerLicensesPage::AssertValid


//////////////////////////////
// F'N: CServerLicensesPage::Dump
//
void CServerLicensesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerLicensesPage::Dump
#endif //_DEBUG


/////////////////////////////
// F'N: CServerLicensesPage::OnSize
//
void CServerLicensesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetWindowRect(&rect);

	CWnd *pWnd = GetDlgItem(IDC_LOCAL_AVAILABLE);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);
	if(m_LicenseList.GetSafeHwnd())
		m_LicenseList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);
}  // end CServerLicensesPage::OnSize


static ColumnDef LicenseColumns[] = {
	CD_LICENSE_DESC,
	CD_LICENSE_REG,
	CD_USERCOUNT,
	CD_POOLCOUNT,
	CD_LICENSE_NUM
};

#define NUM_LICENSE_COLUMNS sizeof(LicenseColumns)/sizeof(ColumnDef)

/////////////////////////////
// F'N: CServerLicensesPage::OnInitialUpdate
//
void CServerLicensesPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;

	for(int col = 0; col < NUM_LICENSE_COLUMNS; col++) {
		columnString.LoadString(LicenseColumns[col].stringID);
		m_LicenseList.InsertColumn(col, columnString, LicenseColumns[col].format, LicenseColumns[col].width, col);
	}

	m_CurrentSortColumn = LICENSE_COL_DESCRIPTION;

}  // end CServerLicensesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CServerLicensePage::BuildImageList
//
// - calls m_ImageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CServerLicensesPage::BuildImageList()
{
	m_ImageList.Create(16, 16, TRUE, 5, 0);

	m_idxBase = AddIconToImageList(IDI_BASE);
	m_idxBump = AddIconToImageList(IDI_BUMP);
	m_idxEnabler = AddIconToImageList(IDI_ENABLER);
	m_idxUnknown = AddIconToImageList(IDI_UNKNOWN);
	m_idxBlank = AddIconToImageList(IDI_BLANK);

	m_LicenseList.SetImageList(&m_ImageList, LVSIL_SMALL);

}  // end CServerLicensesPage::BuildImageList


/////////////////////////////////////////
// F'N: CServerLicensesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_ImageList, and returns
//   the newly-added icon's index in the image list
//
int CServerLicensesPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_ImageList.Add(hIcon);

}  // end CServerLicensesPage::AddIconToImageList


/////////////////////////////
// F'N: CServerLicensesPage::Reset
//
void CServerLicensesPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	DisplayLicenseCounts();
	DisplayLicenses();

}  // end CServerLicensesPage::Reset


/////////////////////////////////////
// F'N: CServerLicensesPage::DisplayLicenseCounts
//
void CServerLicensesPage::DisplayLicenseCounts()
{
	// Fill in the static text fields
	CString LicenseString;

	if(m_pServer->IsWinFrame()) {
		// If the user is not an admin, the values are garbage (show N/A)
		CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
		if(!((CWinAdminApp*)AfxGetApp())->IsUserAdmin()) {
			LicenseString.LoadString(IDS_NOT_APPLICABLE);
			SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);        
			SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);
			SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
			SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
			SetDlgItemText(IDC_POOL_INUSE, LicenseString);
			SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
			SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
			SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
			SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);
		} else {
			ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
			if(pExtServerInfo) {
				BOOL bUnlimited = FALSE;
				if((pExtServerInfo->Flags & ESF_UNLIMITED_LICENSES) > 0) {
					bUnlimited = TRUE;
				}

				if(bUnlimited)
					LicenseString.LoadString(IDS_UNLIMITED);
				else
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalInstalled);
				SetDlgItemText(IDC_LOCAL_INSTALLED, LicenseString);
				LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalInUse);
				SetDlgItemText(IDC_LOCAL_INUSE, LicenseString);

				if(bUnlimited) {
					LicenseString.LoadString(IDS_UNLIMITED);
					SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
					SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
					SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);

					LicenseString.LoadString(IDS_NOT_APPLICABLE);
					SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
					SetDlgItemText(IDC_POOL_INUSE, LicenseString);
					SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
					
				} else {
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerLocalAvailable);
					SetDlgItemText(IDC_LOCAL_AVAILABLE, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolInstalled);
					SetDlgItemText(IDC_POOL_INSTALLED, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolInUse);
					SetDlgItemText(IDC_POOL_INUSE, LicenseString);
					LicenseString.Format(TEXT("%lu"), pExtServerInfo->ServerPoolAvailable);
					SetDlgItemText(IDC_POOL_AVAILABLE, LicenseString);
					LicenseString.Format(TEXT("%lu"), 
						pExtServerInfo->ServerPoolInstalled + pExtServerInfo->ServerLocalInstalled);
					SetDlgItemText(IDC_TOTAL_INSTALLED, LicenseString);
					LicenseString.Format(TEXT("%lu"), 
						pExtServerInfo->ServerPoolAvailable + pExtServerInfo->ServerLocalAvailable);
					SetDlgItemText(IDC_TOTAL_AVAILABLE, LicenseString);
				}

				LicenseString.Format(TEXT("%lu"), 
					pExtServerInfo->ServerPoolInUse + pExtServerInfo->ServerLocalInUse);
				SetDlgItemText(IDC_TOTAL_INUSE, LicenseString);
			}
		}
	}

}  // end CServerLicensesPage::DisplayLicenseCounts()


/////////////////////////////////////
// F'N: CServerLicensesPage::DisplayLicenses
//
void CServerLicensesPage::DisplayLicenses()
{
	// Clear out the list control
	m_LicenseList.DeleteAllItems();

	if(m_pServer->IsWinFrame()) {
		ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_NO_LICENSE_PRIVILEGES) > 0)) {
    		CString AString;
	    	AString.LoadString(IDS_NO_LICENSE_PRIVILEGES);
		    m_LicenseList.InsertItem(0, AString, m_idxBlank);
		    return;
	    }
    }

	m_pServer->LockLicenseList();
	// Get a pointer to this server's list of Licenses
	CObList *pLicenseList = m_pServer->GetLicenseList();

	// Iterate through the License list
	POSITION pos = pLicenseList->GetHeadPosition();

	while(pos) {
		CLicense *pLicense = (CLicense*)pLicenseList->GetNext(pos);

		//////////////////////
		// Fill in the columns
		//////////////////////
		int WhichIcon;

		switch(pLicense->GetClass()) {
			case LicenseBase:
				WhichIcon = m_idxBase;
				break;
			case LicenseBump:
				WhichIcon = m_idxBump;
				break;
			case LicenseEnabler:
				WhichIcon = m_idxEnabler;
				break;
			case LicenseUnknown:
				WhichIcon = m_idxUnknown;
				break;
		}

		// License Description
		int item = m_LicenseList.InsertItem(m_LicenseList.GetItemCount(), pLicense->GetDescription(), WhichIcon);

		// Registered
		CString RegString;
		RegString.LoadString(pLicense->IsRegistered() ? IDS_YES : IDS_NO);
		m_LicenseList.SetItemText(item, LICENSE_COL_REGISTERED, RegString);

		BOOL bUnlimited = (pLicense->GetClass() == LicenseBase
			&& pLicense->GetTotalCount() == 4095
			&& m_pServer->GetCTXVersionNum() == 0x00000040);

		// User (Total)  Count
		CString CountString;
		if(bUnlimited)
			CountString.LoadString(IDS_UNLIMITED);
		else
			CountString.Format(TEXT("%lu"), pLicense->GetTotalCount());
		m_LicenseList.SetItemText(item, LICENSE_COL_USERCOUNT, CountString);

		// Pool Count
		if(bUnlimited)
			CountString.LoadString(IDS_NOT_APPLICABLE);
		else
			CountString.Format(TEXT("%lu"), pLicense->GetPoolCount());
		m_LicenseList.SetItemText(item, LICENSE_COL_POOLCOUNT, CountString);

		// License Number
		m_LicenseList.SetItemText(item, LICENSE_COL_NUMBER, pLicense->GetLicenseNumber());

		m_LicenseList.SetItemData(item, (DWORD_PTR)pLicense);
	}	// end while(pos)

	m_pServer->UnlockLicenseList();

}  // end CServerLicensesPage::DisplayLicenses


/////////////////////////////
// F'N: CServerLicensesPage::OnColumnClick
//
void CServerLicensesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_SERVER, PAGE_LICENSES, &m_LicenseList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CServerLicensesPage::OnColumnClick


////////////////////////////////
// MESSAGE MAP: CServerInfoPage
//
IMPLEMENT_DYNCREATE(CServerInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CServerInfoPage, CFormView)
	//{{AFX_MSG_MAP(CServerInfoPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_HOTFIX_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_HOTFIX_LIST, OnSetfocusHotfixList)
    //ON_NOTIFY(NM_KILLFOCUS, IDC_HOTFIX_LIST, OnKillfocusHotfixList)
	ON_COMMAND(ID_HELP1, OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CServerInfoPage ctor
//
CServerInfoPage::CServerInfoPage()
	: CAdminPage(CServerInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CServerInfoPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pServer = NULL;
    m_bSortAscending = TRUE;

}  // end CUsersPage ctor


/////////////////////////////
// F'N: CServerInfoPage dtor
//
CServerInfoPage::~CServerInfoPage()
{

}  // end CServerInfoPage dtor


////////////////////////////////////////
// F'N: CServerInfoPage::DoDataExchange
//
void CServerInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerInfoPage)
	DDX_Control(pDX, IDC_HOTFIX_LIST, m_HotfixList);	
	//}}AFX_DATA_MAP

}  // end CServerInfoPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CServerInfoPage::AssertValid
//
void CServerInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CServerInfoPage::AssertValid


//////////////////////////////
// F'N: CServerInfoPage::Dump
//
void CServerInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CServerInfoPage::Dump

#endif //_DEBUG


/////////////////////////////
// F'N: CServerInfoPage::OnSize
//
void CServerInfoPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetWindowRect(&rect);

	int control = IDC_HOTFIX_LABEL;
	
	if(m_pServer && m_pServer->IsWinFrame()) control = IDC_HOTFIX_LABEL2;

	CWnd *pWnd = GetDlgItem(control);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);

	if(m_HotfixList.GetSafeHwnd())
		m_HotfixList.MoveWindow(&rect, TRUE);

	// CFormView::OnSize(nType, cx, cy);

}  // end CServerInfoPage::OnSize


/////////////////////////////
// F'N: CServerInfoPage::OnCommandHelp
//
void CServerInfoPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CServerInfoPage::IDD + HID_BASE_RESOURCE);

} // CServerInfoPage::OnCommandHelp


static ColumnDef HotfixColumns[] = {
	CD_HOTFIX,
	CD_INSTALLED_BY,
	CD_INSTALLED_ON
};

#define NUM_HOTFIX_COLUMNS sizeof(HotfixColumns)/sizeof(ColumnDef)

/////////////////////////////
// F'N: CServerInfoPage::OnInitialUpdate
//
void CServerInfoPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();

	CString columnString;

	for(int col = 0; col < NUM_HOTFIX_COLUMNS; col++) {
		columnString.LoadString(HotfixColumns[col].stringID);
		m_HotfixList.InsertColumn(col, columnString, HotfixColumns[col].format, HotfixColumns[col].width, col);
	}

	m_CurrentSortColumn = HOTFIX_COL_NAME;

}  // end CServerInfoPage::OnInitialUpdate


/////////////////////////////
// F'N: CServerInfoPage::BuildImageList
//
void CServerInfoPage::BuildImageList()
{
	m_StateImageList.Create(16, 16, TRUE, 1, 0);
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(IDI_NOTSIGN));
	m_StateImageList.Add(hIcon);

    if( hIcon != NULL )
    {
        m_HotfixList.SetImageList(&m_StateImageList, LVSIL_STATE);
    }

}  // end CServerInfoPage::BuildImageList


/////////////////////////////
// F'N: CServerInfoPage::Reset
//
void CServerInfoPage::Reset(void *pServer)
{
	m_pServer = (CServer*)pServer;
	int control = IDC_HOTFIX_LABEL;
	// If the server is a WinFrame server,
	// we want to show the load balancing stuff and
	// make the hotfix list smaller
	if(m_pServer && m_pServer->IsWinFrame()) {
		GetDlgItem(IDC_LOAD_BALANCING_GROUP)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_IPX_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_HOTFIX_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_HOTFIX_LABEL2)->ShowWindow(SW_SHOW);
		control = IDC_HOTFIX_LABEL2;
	} else {
		GetDlgItem(IDC_LOAD_BALANCING_GROUP)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_IPX_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_HIDE);
		GetDlgItem(IDC_HOTFIX_LABEL)->ShowWindow(SW_SHOW);
		GetDlgItem(IDC_HOTFIX_LABEL2)->ShowWindow(SW_HIDE);
	}

	// Resize the list control
	RECT rect;
	GetWindowRect(&rect);

	CWnd *pWnd = GetDlgItem(control);
	if(pWnd) {
		RECT rect2;
		pWnd->GetWindowRect(&rect2);
		rect.top = rect2.bottom + 5;
	}

	ScreenToClient(&rect);

	if(m_HotfixList.GetSafeHwnd())
		m_HotfixList.MoveWindow(&rect, TRUE);

	Invalidate();

	DisplayInfo();

}  // end CServerInfoPage::Reset


/////////////////////////////
// F'N: CServerInfoPage::OnColumnClick
//
void CServerInfoPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_SERVER, PAGE_INFO, &m_HotfixList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

} // end CServerInfoPage::OnColumnClick

void CServerInfoPage::TSAdminDateTimeString(
    LONG   InstallDate,
    LPTSTR TimeString,
    BOOL   LongDate
    )
{
    // 
    // buffer is wide enough
    CTime tmpTime((time_t) InstallDate);
    SYSTEMTIME stime;       

    // Why not use GetAsSystemTime method ?

	stime.wYear =   (WORD)tmpTime.GetYear( ) ;
	stime.wMonth =  (WORD)tmpTime.GetMonth( ) ;
	stime.wDayOfWeek = (WORD)tmpTime.GetDayOfWeek( ) ;
	stime.wDay =    (WORD)tmpTime.GetDay( ) ;
	stime.wHour =   (WORD)tmpTime.GetHour( ) ;
	stime.wMinute = (WORD)tmpTime.GetMinute( ) ;
	stime.wSecond = (WORD)tmpTime.GetSecond( ) ;

    LPTSTR lpTimeStr;	
    int nLen;			

	//Get DateFormat
    nLen = GetDateFormat(
			LOCALE_USER_DEFAULT,
			LongDate ? DATE_LONGDATE : DATE_SHORTDATE,
			&stime,
			NULL,
			NULL,
			0);
	lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));

    if( lpTimeStr != NULL )
    {
	    nLen = GetDateFormat(
			    LOCALE_USER_DEFAULT,
			    LongDate ? DATE_LONGDATE : DATE_SHORTDATE,
			    &stime,
			    NULL,
			    lpTimeStr,
			    nLen);
	    wcscpy(TimeString, lpTimeStr);
	    wcscat(TimeString, L" ");	
	    GlobalFree(lpTimeStr);
        lpTimeStr = NULL;
		    
	    //Get Time Format
	    nLen = GetTimeFormat(
			    LOCALE_USER_DEFAULT,
			    NULL,
			    &stime,
			    NULL,
			    NULL,
			    0);
	    lpTimeStr = (LPTSTR) GlobalAlloc(GPTR, (nLen + 1) * sizeof(TCHAR));

        if( lpTimeStr != NULL )
        {
	        nLen = GetTimeFormat(
			        LOCALE_USER_DEFAULT,
			        NULL,
			        &stime,
			        NULL,
			        lpTimeStr,
			        nLen);
	        wcscat(TimeString, lpTimeStr);
	        GlobalFree(lpTimeStr);
        }
    }
}

#define PST 60*60*8

/////////////////////////////////////
// F'N: CServerInfoPage::DisplayInfo
//
void CServerInfoPage::DisplayInfo()
{
	m_HotfixList.DeleteAllItems();

	if(!m_pServer->IsRegistryInfoValid()) {
		if(!m_pServer->BuildRegistryInfo()) return;
	}

	CString InfoString, FormatString;

    FormatString.LoadString(IDS_PRODUCT_VERSION);

    if (m_pServer->GetMSVersionNum() < 5)
    {
	    SetDlgItemText(IDC_PRODUCT_NAME, m_pServer->GetCTXProductName());
	    InfoString.Format( FormatString,
                           m_pServer->GetMSVersion(),
		                   m_pServer->GetCTXBuild() );
    }
    else
    {
	    SetDlgItemText(IDC_PRODUCT_NAME, m_pServer->GetMSProductName());
	    InfoString.Format( FormatString,
                           m_pServer->GetMSVersion(),
		                   m_pServer->GetMSBuild() );
    }

	SetDlgItemText(IDC_PRODUCT_VERSION, InfoString);

	LONG InstallDate = (LONG)m_pServer->GetInstallDate();

    if (InstallDate != 0xFFFFFFFF)
    {
        // The install date in the registry appears to be saved in
        // Pacific Standard Time.  Subtract the difference between the
        // current time zone and PST from the install date
        InstallDate -= (PST - _timezone);

        TCHAR TimeString[MAX_DATE_TIME_LENGTH];

        TSAdminDateTimeString(InstallDate, TimeString);

        SetDlgItemText(IDC_INSTALL_DATE, TimeString);
    }
	SetDlgItemText(IDC_SERVICE_PACK, m_pServer->GetServicePackLevel());

	if(m_pServer->IsWinFrame()) {
		ExtServerInfo *pExtServerInfo = m_pServer->GetExtendedInfo();
		if(pExtServerInfo && ((pExtServerInfo->Flags & ESF_LOAD_BALANCING) > 0)) {
			GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_SHOW);
			GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_SHOW);

			CString LoadLevelString;
			if(pExtServerInfo->TcpLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->TcpLoadLevel);
			SetDlgItemText(IDC_TCP_LOAD, LoadLevelString);

			if(pExtServerInfo->IpxLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->IpxLoadLevel);
			SetDlgItemText(IDC_IPX_LOAD, LoadLevelString);

			if(pExtServerInfo->NetbiosLoadLevel == 0xFFFFFFFF) {
				LoadLevelString.LoadString(IDS_NOT_APPLICABLE);
			}
			else LoadLevelString.Format(TEXT("%lu"), pExtServerInfo->NetbiosLoadLevel);
			SetDlgItemText(IDC_NETBIOS_LOAD, LoadLevelString);
		} else {
			GetDlgItem(IDC_TCP_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_IPX_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_NETBIOS_LABEL)->ShowWindow(SW_HIDE);
			GetDlgItem(IDC_TCP_LOAD)->ShowWindow(SW_HIDE);
			CString NoString;
			NoString.LoadString(IDS_NO_LOAD_LICENSE);
			SetDlgItemText(IDC_IPX_LOAD, NoString);
			GetDlgItem(IDC_NETBIOS_LOAD)->ShowWindow(SW_HIDE);
		}
	}

	// Get a pointer to this Server's list of Hotfixes
	CObList *pHotfixList = m_pServer->GetHotfixList();

	// Iterate through the Hotfix list
	POSITION pos = pHotfixList->GetHeadPosition();

	while(pos) {
		CHotfix *pHotfix = (CHotfix*)pHotfixList->GetNext(pos);

		//////////////////////
		// Fill in the columns
		//////////////////////
			
		// Hotfix Name - put at the end of the list
		int item = m_HotfixList.InsertItem(m_HotfixList.GetItemCount(), pHotfix->m_Name, NULL);

		// If this hotfix is not marked as Valid, put a not-sign next to it's name
		if(!pHotfix->m_Valid) 
			m_HotfixList.SetItemState(item, 0x1000, 0xF000);

		// Installed by
		m_HotfixList.SetItemText(item, HOTFIX_COL_INSTALLEDBY, pHotfix->m_InstalledBy);

		// Installed on
        if (pHotfix->m_InstalledOn != 0xFFFFFFFF)
        {

            TCHAR TimeString[MAX_DATE_TIME_LENGTH];

            TSAdminDateTimeString(pHotfix->m_InstalledOn, TimeString);

            if (TimeString != NULL)     
            {
		        m_HotfixList.SetItemText(item, HOTFIX_COL_INSTALLEDON, TimeString);
            }
        }

		m_HotfixList.SetItemData(item, (DWORD_PTR)pHotfix);
	}

}  // end CServerInfoPage::DisplayInfo


void CUsersPage::OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"CUsersPage::OnSetfocusUserListt\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_UserList.Invalidate();

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerWinStationsPage::OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    ODS( L"CServerWinStationsPage::OnSetfocusWinstationList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_StationList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}


void CServerProcessesPage::OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"CServerProcessesPage::OnSetfocusProcessList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerLicensesPage::OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"CServerLicensesPage::OnSetfocusLicenseList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_LicenseList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerInfoPage::OnSetfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	ODS( L"ServerInfoPage::OnSetfocusHotfixList\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_HotfixList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CServerInfoPage::OnKillfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_HotfixList.Invalidate( );

    *pResult = 0;
}

void CUsersPage::OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_UserList.Invalidate( );
}

void CServerWinStationsPage::OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_StationList.Invalidate( );
}

void CServerProcessesPage::OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult)
{
    *pResult = 0;

    m_ProcessList.Invalidate( );
}

void CServerLicensesPage::OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    *pResult = 0;

    m_LicenseList.Invalidate( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\server.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* server.cpp
*
* implementation of the CServer class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"

#include "admindoc.h"
#include "dialogs.h"

#include <malloc.h>			// for alloca used by Unicode conversion macros
#include <afxconv.h>		// for Unicode conversion macros
static int _convert;

#include <winsta.h>
#include <regapi.h>
#include "..\..\inc\utilsub.h"

#include "procs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////////////////////////////////////////////////////////////////////
//
//	CServer Member Functions
//
//////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// CServer::CServer
//
// Constructor for the server class
CServer::CServer(CDomain *pDomain, TCHAR *name, BOOL bFoundLater, BOOL bConnect)
{
    ASSERT(name);

    m_ServerFlags = ULONG(0);
    m_pDomain = pDomain;
    if(bFoundLater) SetFoundLater();	
    //m_State = SS_NONE;
    m_PreviousState = SS_NONE;
    m_hTreeItem = NULL;
    m_hThisServer = NULL;
    m_hFavTree = NULL;
    m_bThreadAlive = FALSE;
    m_pExtensionInfo = NULL;
    m_pExtServerInfo = NULL;
    m_pRegistryInfo = NULL;
    m_fManualFind = FALSE;
    m_hBackgroundThread = NULL;
    
    // Don't call SetState because we don't want to send a message to the views
    m_State = SS_NOT_CONNECTED;

    // save off the server name
    lstrcpyn(m_Name, name, sizeof(m_Name) / sizeof(TCHAR));

    // Dummy up an ExtServerInfo structure
    // This is to make it easier for code that tries
    // to access this structure before the extension DLL
    // has provided it
    m_pExtServerInfo = ((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->GetDefaultExtServerInfo();

    if(bConnect) Connect();

}	// end CServer::CServer


/////////////////////////////////////////////////////////////////////////////
// CServer::~CServer
//
// Destructor for the server class
CServer::~CServer()
{
	// Disconnect();  
    m_hTreeItem = NULL;
    m_hFavTree = NULL;
    m_hThisServer = NULL;

}	// end CServer::~CServer


/////////////////////////////////////////////////////////////////////////////
// CServer::RemoveWinStationProcesses
//
// remove all the processes for a given WinStation
void CServer::RemoveWinStationProcesses(CWinStation *pWinStation)
{
	ASSERT(pWinStation);

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	CObList TempList;

	LockProcessList();
	
	POSITION pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(pProcess->GetWinStation() == pWinStation) {
			// Add the process to our temporary list
			TempList.AddTail(pProcess);
			// Remove the process from the list of processes
			pProcess = (CProcess*)m_ProcessList.GetAt(pos2);
			m_ProcessList.RemoveAt(pos2);
		}
	}
			
	UnlockProcessList();
	
	pos = TempList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;

		CProcess *pProcess = (CProcess*)TempList.GetNext(pos);

		// Send a message to remove the Process from the view
		CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
		if(p && ::IsWindow(p->GetSafeHwnd())) {
			p->SendMessage(WM_ADMIN_REMOVE_PROCESS, 0, (LPARAM)pProcess);
		}
		delete pProcess;

	}

	TempList.RemoveAll();

}	// end CServer::RemoveWinStationProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::ClearAllSelected
//
// Clears the WAF_SELECTED bit in all of this server's lists
//
void CServer::ClearAllSelected()
{
	// Clear the WinStation list WAF_SELECTED flags
	// Iterate through the WinStation list
    LockWinStationList( );

	POSITION pos = m_WinStationList.GetHeadPosition();

	while(pos) {
		CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
		pWinStation->ClearSelected();
	}

    m_NumWinStationsSelected = 0;

    UnlockWinStationList( );

	
    LockProcessList();
	// Clear the Process list PF_SELECTED flags
	// Iterate through the Process list
	pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		pProcess->ClearSelected();
	}

	m_NumProcessesSelected = 0;

    UnlockProcessList( );

}	// end CServer::ClearAllSelected


static TCHAR szMicrosoftKey[] = TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion");
static TCHAR szInstallDate[] = TEXT("InstallDate");
static TCHAR szCSDVersion[] = TEXT("CSDVersion");
static TCHAR szCurrentVersion[] = TEXT("CurrentVersion");
static TCHAR szCurrentBuildNumber[] = TEXT("CurrentBuildNumber");
static TCHAR szCurrentProductName[] = TEXT("ProductName");
static TCHAR szHotfixKey[] = TEXT("HOTFIX");
static TCHAR szValid[] = TEXT("Valid");
static TCHAR szInstalledOn[] = TEXT("Installed On");
static TCHAR szInstalledBy[] = TEXT("Installed By");
#define REG_CONTROL_CITRIX	REG_CONTROL L"\\Citrix"

/////////////////////////////////////////////////////////////////////////////
// CServer::BuildRegistryInfo
//
// Go out and fill in the registry info structure
BOOL CServer::BuildRegistryInfo()
{
	DWORD dwType, dwSize;
	HKEY hKeyServer;
	HKEY hKey;

	if(!IsServerSane()) return FALSE;

	m_pRegistryInfo = new ServerRegistryInfo;
	if(!m_pRegistryInfo) return FALSE;
    memset(m_pRegistryInfo, 0, sizeof(ServerRegistryInfo));

	TCHAR Buffer[128];
	Buffer[0] = TEXT('\\');
	Buffer[1] = TEXT('\\');
	Buffer[2] = TEXT('\0');
	lstrcpyn(Buffer+2, m_Name, sizeof(Buffer) / sizeof(TCHAR) - lstrlen(Buffer));

    /*
     *  Connect to the server's registry
     *  (avoid using RPC when the server is the local machine.)
     */

    if(RegConnectRegistry(IsCurrentServer() ? NULL : Buffer, HKEY_LOCAL_MACHINE, &hKeyServer) != ERROR_SUCCESS)
        return FALSE;

    /*
     * Fetch MS information.
     */
	if(RegOpenKeyEx(hKeyServer, szMicrosoftKey, 0,	KEY_READ, &hKey) != ERROR_SUCCESS) {
		RegCloseKey(hKeyServer);
		return FALSE;
	}

	dwSize = sizeof(m_pRegistryInfo->InstallDate);
	if(RegQueryValueEx(hKey, szInstallDate, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->InstallDate,
					&dwSize) != ERROR_SUCCESS) {
        m_pRegistryInfo->InstallDate = 0xFFFFFFFF;
	}

    // REMARK: we should check the returned codes for every RegQueryValueEx
	dwSize = sizeof(m_pRegistryInfo->ServicePackLevel);
	RegQueryValueEx(hKey, szCSDVersion, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->ServicePackLevel, &dwSize);
	
	dwSize = sizeof(m_pRegistryInfo->MSVersion);
	RegQueryValueEx(hKey, szCurrentVersion, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSVersion, &dwSize);
	
	m_pRegistryInfo->MSVersionNum = _wtol(m_pRegistryInfo->MSVersion);

	dwSize = sizeof(m_pRegistryInfo->MSBuild);
	RegQueryValueEx(hKey, szCurrentBuildNumber, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSBuild, &dwSize);
	
	dwSize = sizeof(m_pRegistryInfo->MSProductName);
	RegQueryValueEx(hKey, szCurrentProductName, NULL, &dwType, (LPBYTE)&m_pRegistryInfo->MSProductName, &dwSize);
	
	HKEY hKeyHotfix;

	if(RegOpenKeyEx(hKey, szHotfixKey, 0, KEY_READ, &hKeyHotfix) == ERROR_SUCCESS) {
		DWORD Index = 0;
		FILETIME LastWriteTime;
		dwSize = sizeof(Buffer) / sizeof( TCHAR );
		while(RegEnumKeyEx(hKeyHotfix, Index, Buffer, &dwSize, NULL, NULL, NULL,
			&LastWriteTime) == ERROR_SUCCESS) {
			HKEY hKeySingleHotfix;
			if(RegOpenKeyEx(hKeyHotfix, Buffer, 0, KEY_READ, &hKeySingleHotfix) == ERROR_SUCCESS) {
				// Create a CHotFix object
				CHotfix *pHotfix = new CHotfix;

                if(pHotfix) {
				    // Copy the Hotfix name
				    // Get rid of the WF: if it's there
				    if(wcsncmp(Buffer, TEXT("WF:"), 3) == 0) {
					    lstrcpyn(pHotfix->m_Name, &Buffer[3], sizeof(pHotfix->m_Name) / sizeof(TCHAR));
				    }
				    else lstrcpyn(pHotfix->m_Name, Buffer, sizeof(pHotfix->m_Name) / sizeof(TCHAR));

				    // Get the Valid entry
				    dwSize = sizeof(&pHotfix->m_Valid);
				    if(RegQueryValueEx(hKeySingleHotfix, szValid, NULL, &dwType, (LPBYTE)&pHotfix->m_Valid,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_Valid = 0L;
				    }

				    // Get the Installed On entry			
				    dwSize = sizeof(&pHotfix->m_InstalledOn);
				    if(RegQueryValueEx(hKeySingleHotfix, szInstalledOn, NULL, &dwType, (LPBYTE)&pHotfix->m_InstalledOn,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_InstalledOn = 0xFFFFFFFF;
				    }

				    // Get the Installed By entry
				    dwSize = sizeof(pHotfix->m_InstalledBy);
				    if(RegQueryValueEx(hKeySingleHotfix, szInstalledBy, NULL, &dwType, (LPBYTE)pHotfix->m_InstalledBy,
					    	&dwSize) != ERROR_SUCCESS) {
					    pHotfix->m_InstalledBy[0] = '\0';
				    }

				    pHotfix->m_pServer = this;

				    m_HotfixList.AddTail(pHotfix);

				    RegCloseKey(hKeySingleHotfix);
			    }
            }

		    dwSize = sizeof(Buffer) / sizeof( TCHAR );
			Index++;
		}

		RegCloseKey(hKeyHotfix);
	}

	RegCloseKey(hKey);

    if (m_pRegistryInfo->MSVersionNum < 5)   // only for TS 4.0
    {
        /*
         * Fetch Citrix information.
         */
	    // Look in the new location
	    LONG result = RegOpenKeyEx(hKeyServer, REG_CONTROL_TSERVER, 0, KEY_READ, &hKey);

	    if(result != ERROR_SUCCESS) {
		    // Look in the old location
		    result = RegOpenKeyEx(hKeyServer, REG_CONTROL_CITRIX, 0, KEY_READ, &hKey);	
	    }

	    if(result != ERROR_SUCCESS) {
	        RegCloseKey(hKeyServer);
		    return FALSE;
	    }

	    dwSize = sizeof(m_pRegistryInfo->CTXProductName);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTNAME, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXProductName, &dwSize);
	
	    dwSize = sizeof(m_pRegistryInfo->CTXVersion);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTVERSION, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXVersion, &dwSize);

	    m_pRegistryInfo->CTXVersionNum = wcstol(m_pRegistryInfo->CTXVersion, NULL, 16);

	    dwSize = sizeof(m_pRegistryInfo->CTXBuild);
	    RegQueryValueEx(hKey, REG_CITRIX_PRODUCTBUILD, NULL, &dwType, (LPBYTE)m_pRegistryInfo->CTXBuild, &dwSize);

        RegCloseKey(hKey);

    }
    else    // for NT 5.0 and beyond, do not query the registry
    {
        //REMARK: we should get rid of all this.
        wcscpy(m_pRegistryInfo->CTXProductName, m_pRegistryInfo->MSProductName);
        wcscpy(m_pRegistryInfo->CTXVersion, m_pRegistryInfo->MSVersion);
    	m_pRegistryInfo->CTXVersionNum = m_pRegistryInfo->MSVersionNum;
        wcscpy(m_pRegistryInfo->CTXBuild, m_pRegistryInfo->MSBuild);
    }

	RegCloseKey(hKeyServer);

	// Set the flag to say the info is valid
	SetRegistryInfoValid();

	return TRUE;

}	// end CServer::BuildRegistryInfo

/////////////////////////////////////////////////////////////////////////////
// CServer::AddWinStation
//
// Add a WinStation to the Server's WinStationList in
// sorted order
// NOTE: The list should be NOT be locked by the caller
//
void CServer::AddWinStation(CWinStation *pNewWinStation)
{
    ASSERT(pNewWinStation);

	LockWinStationList();

    ODS( L"CServer!AddWinStation\n" );

	BOOLEAN bAdded = FALSE;
	POSITION pos, oldpos;
	int Index;

	// Traverse the WinStationList and insert this new WinStation,
	// keeping the list sorted by Sort Order, then Protocol.
    for(Index = 0, pos = m_WinStationList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);

        if((pWinStation->GetSortOrder() > pNewWinStation->GetSortOrder())
			|| ((pWinStation->GetSortOrder() == pNewWinStation->GetSortOrder()) &&
			(pWinStation->GetSdClass() > pNewWinStation->GetSdClass()))) {
            // The new object belongs before the current list object.
            m_WinStationList.InsertBefore(oldpos, pNewWinStation);
			bAdded = TRUE;
            break;
        }
    }

    // If we haven't yet added the WinStation, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_WinStationList.AddTail(pNewWinStation);
	}

	UnlockWinStationList();

}  // end CServer::AddWinStation


/////////////////////////////////////////////////////////////////////////////
// CServer::Connect
//
// Connect to the server
//
BOOL CServer::Connect()
{	
    ServerProcInfo * pProcInfo = NULL;
    BOOL             bResult   = FALSE;
    
    m_NumProcessesSelected   = 0;
    m_NumWinStationsSelected = 0;
    m_pExtServerInfo         = NULL;
    

    if(m_State != SS_NOT_CONNECTED )
    {        
        return FALSE;
    }
    
    // Fire off the background thread for this server 
    LockThreadAlive();

    if(m_hBackgroundThread == NULL) 
    {        
        pProcInfo = new ServerProcInfo;
        if (pProcInfo == NULL)
        {
            UnlockThreadAlive();
            return FALSE;
        }

        pProcInfo->pServer = this;
        pProcInfo->pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

        m_BackgroundContinue = TRUE;
        m_bThreadAlive = FALSE;

        // Start the background thread
        DWORD dwThreadID;
        m_hBackgroundThread = CreateThread(NULL,
                                           0,
                                           CServer::BackgroundThreadProc,     
                                           pProcInfo,
                                           0,
                                           &dwThreadID);
        if (m_hBackgroundThread == NULL)
        {
            ODS( L"CServer!Connect possibly low resources no thread created\n" );
            delete pProcInfo;
            UnlockThreadAlive();
            return FALSE;
        }

         bResult = TRUE;
    }
    
    UnlockThreadAlive();
    
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CServer::Disconnect
//
// Disconnect from the server
//
void CServer::Disconnect()
{
    ULONG WSEventFlags;

    // not a good idea for an ods
    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

    SetState(SS_DISCONNECTING);

    // If there is an extension DLL, let it cleanup anything it added to this Server
    LPFNEXSERVERCLEANUPPROC CleanupProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerCleanupProc();
    if(CleanupProc && m_pExtensionInfo) 
    {
        (*CleanupProc)(m_pExtensionInfo);
        m_pExtensionInfo = NULL;
    }

	// Tell the background thread to terminate and wait for it to do so.
	ClearBackgroundContinue();

    // Make sure the thread is still running
    if (m_bThreadAlive)
    {
        // Force him out of waiting for an event if he is
        if (IsHandleGood())
        {
            ODS(L"TSADMIN:CServer::Disconnect Handle is good flush events\n");
            WinStationWaitSystemEvent(m_Handle, WEVENT_FLUSH, &WSEventFlags);
        }

        // If this server object is waiting for RPC to timeout, kill thread
        if (m_PreviousState == SS_NOT_CONNECTED)
        {
            ODS(L"TSADMIN:CServer::Disconnect Previous state not connected termthread\n");

            if (WaitForSingleObject(m_hBackgroundThread , 100) == WAIT_TIMEOUT)
            {
                TerminateThread(m_hBackgroundThread, 0);
            }
        }

        // For all other threads, wait a second and then kill it
        else if (WaitForSingleObject(m_hBackgroundThread , 1000) == WAIT_TIMEOUT)
        {
            ODS( L"TSADMIN CServer!Disconnect prevstate was !not_connected termthread\n" );
            TerminateThread(m_hBackgroundThread, 0);
        }

        WaitForSingleObject(m_hBackgroundThread, INFINITE);

        ODS( L"TSADMIN:CServer::Disconnect delete CWinThread Object m_bThread == TRUE\n" );
    }

    // we're done with our background thread so we can close the handle
    CloseHandle(m_hBackgroundThread);
    m_hBackgroundThread = NULL;

    if (IsHandleGood())
    { 
        ODS( L"TSADMIN:CServer::Disconnect WinStationCloseServer\n" );
        WinStationCloseServer(m_Handle);
        m_Handle = NULL;
    }

    LockWinStationList();

    CObList TempList;

    // Iterate through the WinStation list
    // Move all the WinStations to a temporary list so that
    // we don't have to have the WinStationList locked while
    // sending the WM_ADMIN_REMOVE_WINSTATION message to the views.

    POSITION pos = m_WinStationList.GetHeadPosition();

    while (pos)
    {
        CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
        TempList.AddTail(pWinStation);		
    }

    m_WinStationList.RemoveAll();

    UnlockWinStationList();

    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

    pos = TempList.GetHeadPosition();

    while (pos)
    {
        CWinStation *pWinStation = (CWinStation*)TempList.GetNext(pos);

        if (p && ::IsWindow(p->GetSafeHwnd()))
        { 
            ODS( L"TSADMIN:CServer::Disconnect Remove WinStation\n" );
            p->SendMessage(WM_ADMIN_REMOVE_WINSTATION, 0, (LPARAM)pWinStation);		
        }
    }

    TempList.RemoveAll();

    LockProcessList();

    pos = m_ProcessList.GetHeadPosition();

    while (pos)
    {
        CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
        ODS( L"TSADMIN:CServer::Disconnect Delete process\n" );
        delete pProcess;
    }

    m_ProcessList.RemoveAll();

    UnlockProcessList();

    LockLicenseList();

    pos = m_LicenseList.GetHeadPosition();

    while (pos)
    {
        CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);
        ODS( L"TSADMIN:CServer::Disconnect remove license\n" );
        delete pLicense;
    }

    m_LicenseList.RemoveAll();

    UnlockLicenseList();

    //

    pos = m_UserSidList.GetHeadPosition();

    while (pos)
    {
        CUserSid *pUserSid = (CUserSid*)m_UserSidList.GetNext(pos);
        ODS( L"TSADMIN:CServer::Disconnect remove sids\n" );
        delete pUserSid;
    }

    m_UserSidList.RemoveAll();

    pos = m_HotfixList.GetHeadPosition();

    while (pos)
    {
        CHotfix *pHotfix = (CHotfix*)m_HotfixList.GetNext(pos);
        ODS( L"TSADMIN:CServer::Disconnect Remove hotfixes\n" );
        delete pHotfix;
    }

    m_HotfixList.RemoveAll();

    if (m_pRegistryInfo)
    {
        delete m_pRegistryInfo;
        ODS( L"TSADMIN:CServer::Disconnect delete reginfo\n" );
        m_pRegistryInfo = NULL;
    }

    // ODS( L"TSADMIN:CServer::Disconnect Set state not connected\n" );

    SetState(SS_NOT_CONNECTED);
}

/////////////////////////////////////////////////////////////////////////////
// CServer::DoDetail
//
// Go get detailed information about this server
//
void CServer::DoDetail()
{
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

	SetState(SS_GETTING_INFO);

	ULONG Entries;
	PLOGONID pLogonId;

	if(!ShouldBackgroundContinue()) return;

    // We need to access the registry information for the server
    // at this time because we must not administer WF 2.00 servers
    // (RPC structures are incompatible).  If we cannot access the
    // server's registry, or the multi-user version is 2.00, we bail
    // from this server.
    if ( !BuildRegistryInfo() || (GetCTXVersionNum() == 0x200) || (GetCTXVersionNum() == 0) )
    {
		ClearHandleGood();
		SetLostConnection();
		SetState(SS_BAD);

        ODS( L"CServer::DoDetail - Setting to lost connection\n" );

		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();
		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd())) pFrameWnd->SendMessage(WM_ADMIN_REMOVE_SERVER, 0, (LPARAM)this);
		ClearBackgroundContinue();
		return;
    }

	// Find all the WinStations
    BOOL fWinEnum;

    fWinEnum = WinStationEnumerate(m_Handle, &pLogonId, &Entries);

    DBGMSG( L"CServer!DoDetail WinEnum last reported error 0x%x\n", GetLastError( ) );

	if(!fWinEnum )
    {
        
		ClearHandleGood();
		SetLostConnection();
		SetState(SS_BAD);
		ClearBackgroundContinue();
		return;
	}

	if(!ShouldBackgroundContinue()) {
		if(pLogonId) WinStationFreeMemory(pLogonId);
		return;
	}

	// Get information about the WinStations
	if(pLogonId)
    {
		for(ULONG i = 0; i < Entries; i++)
        {
            // Create a new WinStation object
			CWinStation *pWinStation = new CWinStation(this, &pLogonId[i]);
            if(pWinStation)
            {
                // If the queries weren't successful, ignore this WinStation
			    if(!pWinStation->QueriesSuccessful())
                {
                    ODS( L"CServer::DoDetail!QueriesSuccessful failed\n" );
    				delete pWinStation;
	    		}
                else
                {
		    		AddWinStation(pWinStation);
			    	pWinStation->SetNew();
			    }
            }

			if( !ShouldBackgroundContinue() )
            {
				if(pLogonId) WinStationFreeMemory(pLogonId);
				return;
			}
		}

		WinStationFreeMemory(pLogonId);
	}

	if(!ShouldBackgroundContinue()) return;

	// If there is an extension DLL loaded, allow it to add it's own info for this Server
	LPFNEXSERVERINITPROC InitProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerInitProc();
	if(InitProc) {
		m_pExtensionInfo = (*InitProc)(m_Name, m_Handle);
      if(m_pExtensionInfo) {
         LPFNEXGETSERVERINFOPROC GetInfoProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetServerInfoProc();
         if(GetInfoProc) {
            m_pExtServerInfo = (*GetInfoProc)(m_pExtensionInfo);
			// If this server is running WinFrame or Picasso, set flag
			if(m_pExtServerInfo->Flags & ESF_WINFRAME) SetWinFrame();
         }
      }
	}

	QueryLicenses();

	SetState(SS_GOOD);

	// Send a message to the views to tell it the state of this
	// server has changed
	CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();
	if(p && ::IsWindow(p->GetSafeHwnd())) { 
		p->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, 0, (LPARAM)this);
		p->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, 0, (LPARAM)this);
	}

}  // end CServer::DoDetail


/////////////////////////////////////////////////////////////////////////////
// CServer::FindProcessByPID
//
// returns a pointer to a CProcess from m_ProcessList given a PID
CProcess* CServer::FindProcessByPID(ULONG Pid)
{
	LockProcessList();
		
	POSITION pos = m_ProcessList.GetHeadPosition();
			
	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(pProcess->GetPID() == Pid) {
			UnlockProcessList();
			return pProcess;
		}
	}

	UnlockProcessList();

	return NULL;

}	// end CServer::FindProcessByPID


/////////////////////////////////////////////////////////////////////////////
// CServer::EnumerateProcesses
//
// Enumerate this server's processes
BOOL CServer::EnumerateProcesses()
{
    ENUMTOKEN EnumToken;
	ULONG PID;
	ULONG LogonId;
	TCHAR ImageName[MAX_PROCESSNAME+1];
	PSID pSID;
    
    EnumToken.Current = 0;
    EnumToken.NumberOfProcesses = 0;
    EnumToken.ProcessArray = NULL;
    EnumToken.bGAP = TRUE;

	if(!IsHandleGood()) return 0;

	CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();
	
	LockProcessList();

	// Loop processes through and turn off current flag and new flag
	// Delete any processes that aren't current
	POSITION pos = m_ProcessList.GetHeadPosition();
	while(pos) {
		POSITION pos2 = pos;
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		if(!pProcess->IsCurrent()) {
			pProcess = (CProcess*)m_ProcessList.GetAt(pos2);
			m_ProcessList.RemoveAt(pos2);
			delete pProcess;
		} else {
			pProcess->ClearCurrent();
			pProcess->ClearNew();
			pProcess->ClearChanged();	// !
		}
	}

	UnlockProcessList();

	// Should we quit?
	if(!pDoc->ShouldProcessContinue()) {
		return FALSE;
	}

	while(ProcEnumerateProcesses(m_Handle,  
                                 &EnumToken, 
                                 ImageName,
                                 &LogonId, 
                                 &PID, 
                                 &pSID )) {

		CProcess *pProcess = new CProcess(PID, 
                                          LogonId, 
                                          this,
										  pSID, 
                                          FindWinStationById(LogonId), 
                                          ImageName);
        
        if(pProcess) {                                        
		    // If this process is in the list, we need to see if it has changed
		    CProcess *pOldProcess = FindProcessByPID(PID);
		    if(pOldProcess && pProcess->GetWinStation()) {
			    // Flag the process as current
			    pOldProcess->SetCurrent();
			    // Update any info that has changed
			    pOldProcess->Update(pProcess);
			    // We don't need this process object anymore
			    delete pProcess;
		    }
		    // It is a new process, add it to the list
		    else if(pProcess->GetWinStation()) { 
			    pProcess->SetNew();
			    LockProcessList();
			    m_ProcessList.AddTail(pProcess);
			    UnlockProcessList();
		    }
		    // This process doesn't have a WinStation, delete it
		    else {
			    delete pProcess;
		    }
        }

		// Should we quit?
		if(!pDoc->ShouldProcessContinue()) {
			// We have to call this one last time with an offset of -1 to
			// make the function free up the memory allocated by the client side stub.

			EnumToken.Current = (ULONG)-1;
			ProcEnumerateProcesses(m_Handle,  
                                   &EnumToken, 
                                   ImageName,
                                   &LogonId, 
                                   &PID, 
                                   &pSID );

			return FALSE;
		}
	}

	return TRUE;

}	// end CServer::EnumerateProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::ClearProcesses
//
// Clear out the list of processes
void CServer::ClearProcesses()
{
	LockProcessList();
	POSITION pos = m_ProcessList.GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetNext(pos);
		delete pProcess;
	}

	m_ProcessList.RemoveAll();
	UnlockProcessList();

}	// end CServer::ClearProcesses


/////////////////////////////////////////////////////////////////////////////
// CServer::FindWinStationById
//
CWinStation* CServer::FindWinStationById(ULONG Id)
{
	LockWinStationList();
		
	POSITION pos = m_WinStationList.GetHeadPosition();
			
	while(pos) {
		CWinStation *pWinStation = (CWinStation*)m_WinStationList.GetNext(pos);
		if(pWinStation->GetLogonId() == Id) {
			UnlockWinStationList();
			return pWinStation;
		}
	}

	UnlockWinStationList();

	return NULL;

}	// end CServer::FindWinStationById


/////////////////////////////////////////////////////////////////////////////
// CServer::BackgroundThreadProc
//
DWORD WINAPI
CServer::BackgroundThreadProc(LPVOID pParam)
{
	ASSERT(pParam);
    ODS( L"CServer::BackgroundThreadProc\n" );

	// We need a pointer to the document so we can make
	// calls to member functions
	CWinAdminDoc *pDoc = (CWinAdminDoc*)((ServerProcInfo*)pParam)->pDoc;
	CServer *pServer = ((ServerProcInfo*)pParam)->pServer;

	HANDLE hServer;

	delete (ServerProcInfo*)pParam;

	// Make sure we don't have to quit
    if(!pServer->ShouldBackgroundContinue()) {
        return 0;
    }

	pServer->SetThreadAlive();

    // In case the server is disconnected we wait uselessly here
	while(!pDoc->AreAllViewsReady()) Sleep(500);    

	// Make sure we don't have to quit
    if(!pServer->ShouldBackgroundContinue())
    {
		pServer->ClearThreadAlive();
        return 0;
    }

	if(!pServer->IsCurrentServer())
    {
		// open the server and save the handle
		hServer = WinStationOpenServer(pServer->GetName());
		pServer->SetHandle(hServer);

		// Make sure we don't have to quit
        if(!pServer->ShouldBackgroundContinue())
        {
			pServer->ClearThreadAlive();

            return 0;
        }
		if(hServer == NULL)
        {
			DWORD Error = GetLastError();

            DBGMSG( L"CServer!BackgroundThreadProc WinStationOpenServer failed with 0x%x\n", Error );

			if(Error == RPC_S_SERVER_UNAVAILABLE)
            {
				pServer->ClearBackgroundFound();
				pServer->SetLostConnection();
                pServer->ClearManualFind( );
				
                CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();              

				if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
                    ODS( L"Server backgrnd thread declares this server RPC_S_SERVER_UNAVAILABLE\n" );                    
                }                
            }

            pServer->SetState(SS_BAD);
            
            pServer->ClearThreadAlive();
            
            return 0;
        }
        
        pServer->SetHandleGood();
        pServer->SetState(SS_OPENED);
		
    }
    else
    {
        hServer = SERVERNAME_CURRENT;
        pServer->SetHandle(SERVERNAME_CURRENT);
        pServer->SetHandleGood();
        pServer->SetState(SS_OPENED);
	}

    
	// Make sure we don't have to quit
	if(!pServer->ShouldBackgroundContinue()) {
		pServer->ClearThreadAlive();
		return 0;
	}

	// If we found this server after initial enum,
	// we need to add it to the views now

    CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

	if(pServer->WasFoundLater())
    {        
        if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
        {
            pFrameWnd->SendMessage(WM_ADMIN_ADD_SERVER, ( WPARAM )TVI_SORT, (LPARAM)pServer);
        }
    }
    
	// Make sure we don't have to quit
	if(!pServer->ShouldBackgroundContinue()) {
		pServer->ClearThreadAlive();
		return 0;
	}
	
	pServer->DoDetail();
	
	// Now go into our loop waiting for WinStation Events
	while(1) {
		ULONG WSEventFlags;
		ULONG Entries;
		PLOGONID pLogonId;

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			pServer->ClearThreadAlive();
			return 0;
		}

		// Wait for the browser to tell us something happened

		if(!WinStationWaitSystemEvent(hServer, WEVENT_ALL, &WSEventFlags))
        {
			if(GetLastError() != ERROR_OPERATION_ABORTED)
            {
                ODS( L"CServer::BackgroundThreadProc ERROR_OPERATION_ABORTED\n" );
                
				pServer->ClearHandleGood();
                pServer->SetState(SS_BAD);
				pServer->SetLostConnection();
                pServer->ClearThreadAlive();
                pServer->ClearManualFind();

                return 1;
			}
		}

        ODS( L"CServer::BackgroundThreadProc -- some system event has taken place\n" );

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			pServer->ClearThreadAlive();
            ODS( L"CServer::BackgroundThreadProc -* backgrnd thread should not continue\n" );
			return 0;
		}

		// Loop through this Server's WinStations and clear the current flag
		pServer->LockWinStationList();
		CObList *pWinStationList = pServer->GetWinStationList();
		POSITION pos = pWinStationList->GetHeadPosition();
		while(pos) {
			CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
			pWinStation->ClearCurrent();
			pWinStation->ClearNew();
			pWinStation->ClearChanged();
		}
		
		pServer->UnlockWinStationList();

		// Find all the WinStations
        BOOL fWinEnum = WinStationEnumerate(hServer, &pLogonId, &Entries);

        DBGMSG( L"CServer!BackgroundThread WinEnum last reported error 0x%x\n", GetLastError( ) );

		if(!fWinEnum )
        {
            ODS( L"CServer!BackgroundThread -- server is no longer valid\n" );

			pServer->ClearHandleGood();

			pServer->SetLostConnection();
			pServer->SetState(SS_BAD);
			pServer->ClearThreadAlive();
            pServer->ClearManualFind( );
			return 1;
		}
		
		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue()) {
			if(pLogonId) WinStationFreeMemory(pLogonId);
			pServer->ClearThreadAlive();
            ODS( L"CServer!BackgroundThreadProc -# backgrnd thread should not continue\n" );
			return 0;
		}

		if(pLogonId)
        {
            // Get information about the WinStations
			for(ULONG i = 0; i < Entries; i++)
            {
                // Look for this WinStation in the list
				CWinStation *pWinStation = pServer->FindWinStationById(pLogonId[i].LogonId);
				if(pWinStation)
                {
                    // Mark this WinStation as current
					pWinStation->SetCurrent();

					// We found the WinStation in the list
					// Create a new CWinStation object - he will get his information
					CWinStation *pTempWinStation = new CWinStation(pServer, &pLogonId[i]);

                    if(pTempWinStation)
                    {
                        // If any information has changed, send a message to update the views
					    if(pWinStation->Update(pTempWinStation))
                        {
                            CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

	    					if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                            {
                                pFrameWnd->SendMessage(WM_ADMIN_UPDATE_WINSTATION, 0, (LPARAM)pWinStation);
                            }

		    			}

			    		// We don't need the temporary CWinStation object anymore
				    	delete pTempWinStation;
                    }
				}
                else
                {
                    // We didn't find it in our list
					// We don't want to add it to our list if the WinStation is down
					if(pLogonId[i].State != State_Down && pLogonId[i].State != State_Init)
                    {
                        // Create a new CWinStation object
						CWinStation *pNewWinStation = new CWinStation(pServer, &pLogonId[i]);
                        if(pNewWinStation)
                        {
                            pServer->AddWinStation(pNewWinStation);
						    pNewWinStation->SetNew();
						    CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

						    if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                            {
                                pFrameWnd->SendMessage(WM_ADMIN_ADD_WINSTATION, 0, (LPARAM)pNewWinStation);
                            }

                        }
				    }
				}
			}

			WinStationFreeMemory(pLogonId);

			// Send a message to the views to update their WinStations
			CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

			if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
            {
                pFrameWnd->SendMessage(WM_ADMIN_UPDATE_WINSTATIONS, 0, (LPARAM)pServer);
            }


			// Loop through the WinStations for this server and move
			// any that aren't current to a temporary list
			CObList TempList;

			pServer->LockWinStationList();
			CObList *pWinStationList = pServer->GetWinStationList();
			POSITION pos = pWinStationList->GetHeadPosition();
			while(pos)
            {
				POSITION pos2 = pos;
				CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
				if(!pWinStation->IsCurrent())
                {
					// Add the WinStation to our temporary list
					TempList.AddTail(pWinStation);
					// Remove the WinStation from the list of WinStations
					pWinStation = (CWinStation*)pWinStationList->GetAt(pos2);
					pWinStationList->RemoveAt(pos2);
				}
			}
			
			pServer->UnlockWinStationList();

			pos = TempList.GetHeadPosition();
			while(pos)
            {
				POSITION pos2 = pos;

				CWinStation *pWinStation = (CWinStation*)TempList.GetNext(pos);

				// Send a message to remove the WinStation from the tree view
				CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

                if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
					pFrameWnd->SendMessage(WM_ADMIN_REMOVE_WINSTATION, 0, (LPARAM)pWinStation);
				}
		
				delete pWinStation;
			}

			TempList.RemoveAll();

		}  // end if(pLogonId)

		// If there is an extension DLL loaded, allow it to update info for this Server
		LPFNEXSERVEREVENTPROC EventProc = ((CWinAdminApp*)AfxGetApp())->GetExtServerEventProc();
		if(EventProc) {
			// Returns TRUE if anything changed
			if((*EventProc)(pServer->GetExtensionInfo(), WSEventFlags)) {
				pServer->QueryLicenses();

				CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

				if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
                {
                    pFrameWnd->SendMessage(WM_ADMIN_REDISPLAY_LICENSES, 0, (LPARAM)pServer);
                }

			}
		}

		// Tell the Server view to show the new load and license counts
		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();

		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd())) 
        {
            pFrameWnd->SendMessage(WM_ADMIN_UPDATE_SERVER_INFO, 0, (LPARAM)pServer);
        }

		// Make sure we don't have to quit
		if(!pServer->ShouldBackgroundContinue())
        {
			pServer->ClearThreadAlive();
            ODS( L"CServer::BackgroundThreadProc -@ backgrnd thread should not continue\n" );
			return 0;
		}

	}  // end while(1)

}	// end CServer::BackgroundThreadProc


/////////////////////////////////////////////////////////////////////////////
// CServer::QueryLicenses
//
void CServer::QueryLicenses()
{
	ULONG NumLicenses;
	ExtLicenseInfo *pExtLicenseInfo = NULL;

	// If there is an extension DLL loaded, get this server's list of licenses
	LPFNEXGETSERVERLICENSESPROC LicenseProc = ((CWinAdminApp*)AfxGetApp())->GetExtGetServerLicensesProc();
	if(LicenseProc && m_pExtensionInfo) {

		LockLicenseList();

		// Iterate through the License list
		POSITION pos = m_LicenseList.GetHeadPosition();

		while(pos) {
			CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);
			delete pLicense;
		}
	
		m_LicenseList.RemoveAll();

		UnlockLicenseList();

		pExtLicenseInfo = (*LicenseProc)(m_pExtensionInfo, &NumLicenses);
		
		if(pExtLicenseInfo) {
			ExtLicenseInfo *pExtLicense = pExtLicenseInfo;

			for(ULONG lic = 0; lic < NumLicenses; lic++) {
				CLicense *pLicense = new CLicense(this, pExtLicense);
                if(pLicense) {
				    AddLicense(pLicense);
                }
			    pExtLicense++;
                
			}
	
			// Get the extension DLL's function to free the license info
			LPFNEXFREESERVERLICENSESPROC LicenseFreeProc = ((CWinAdminApp*)AfxGetApp())->GetExtFreeServerLicensesProc();
			if(LicenseFreeProc) {
				(*LicenseFreeProc)(pExtLicenseInfo);
			} else {
				TRACE0("WAExGetServerLicenses exists without WAExFreeServerLicenseInfo\n");
				ASSERT(0);
			}
		}
	}

}	// end CServer::QueryLicenses


/////////////////////////////////////////////////////////////////////////////
// CServer::AddLicense
//
// Add a License to the Server's LicenseList in
// sorted order
// NOTE: The list should be NOT be locked by the caller
//
void CServer::AddLicense(CLicense *pNewLicense)
{
    ASSERT(pNewLicense);

	LockLicenseList();

	BOOLEAN bAdded = FALSE;
	POSITION pos, oldpos;
	int Index;

	// Traverse the LicenseList and insert this new License,
	// keeping the list sorted by Class, then Name.
    for(Index = 0, pos = m_LicenseList.GetHeadPosition(); pos != NULL; Index++) {
        oldpos = pos;
        CLicense *pLicense = (CLicense*)m_LicenseList.GetNext(pos);

        if((pLicense->GetClass() > pNewLicense->GetClass())
			|| ((pLicense->GetClass() == pNewLicense->GetClass()) &&
            lstrcmpi(pLicense->GetSerialNumber(), pNewLicense->GetSerialNumber()) > 0)) {

            // The new object belongs before the current list object.
            m_LicenseList.InsertBefore(oldpos, pNewLicense);
			bAdded = TRUE;
            break;
        }
    }

    // If we haven't yet added the License, add it now to the tail
    // of the list.
    if(!bAdded) {
        m_LicenseList.AddTail(pNewLicense);
	}

	UnlockLicenseList();

}  // end CServer::AddLicense


/////////////////////////////////////////////////////////////////////////////
// CServer::SetState
//
void CServer::SetState(SERVER_STATE State)
{
	m_PreviousState = m_State; 

	m_State = State;

	if(m_State != m_PreviousState)
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();

		CFrameWnd *pFrameWnd = (CFrameWnd*)pDoc->GetMainWnd();
                
		if(pFrameWnd && ::IsWindow(pFrameWnd->GetSafeHwnd()))
        {
            pFrameWnd->SendMessage(WM_ADMIN_UPDATE_SERVER, 0, (LPARAM)this);
        }
	}

}	// end CServer::SetState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\servpgs.h ===
/*******************************************************************************
*
* servpgs.h
*
* - declarations for the Server info pages
* - the server info pages are all CFormView derivatives
*   based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\servpgs.h  $
*  
*     Rev 1.2   03 Nov 1997 15:30:16   donm
*  added descending sort
*  
*     Rev 1.1   13 Oct 1997 18:39:42   donm
*  update
*  
*     Rev 1.0   30 Jul 1997 17:12:32   butchd
*  Initial revision.
*  
*******************************************************************************/

#ifndef _SERVERPAGES_H
#define _SERVERPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

//////////////////////////
// CLASS: CUsersPage
//
class CUsersPage : public CAdminPage
{
friend class CServerView;

protected:
	CUsersPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CUsersPage)

// Form Data
public:
	//{{AFX_DATA(CUsersPage)
	enum { IDD = IDD_SERVER_USERS };
	CListCtrl	m_UserList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxUser;			// index of User image
	int m_idxCurrentUser;	// index of Current User image

private:
	CServer* m_pServer;		// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateWinStations(CServer *pServer);
    virtual void ClearSelections();
private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayUsers();			
	virtual void Reset(void *pServer);
	int AddUserToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUsersPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CUsersPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CUsersPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUserItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusUserList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CUsersPage

//////////////////////////
// CLASS: CServerWinStationsPage
//
class CServerWinStationsPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerWinStationsPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerWinStationsPage)

// Form Data
public:
	//{{AFX_DATA(CServerWinStationsPage)
	enum { IDD = IDD_SERVER_WINSTATIONS };
	CListCtrl	m_StationList;
	//}}AFX_DATA

// Attributes
public:
    
protected:
	CImageList m_ImageList;	// image list associated with the tree control

	int m_idxBlank;			// index of Blank image
	int m_idxCitrix;		// index of Citrix image
	int m_idxServer;		// index of Server image 
	int m_idxConsole;		// index of Console image
	int m_idxNet;			// index of Net image
	int m_idxAsync;			// index of Async image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateWinStations(CServer *pServer);
    virtual void ClearSelections();
private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayStations();			
	virtual void Reset(void *pServer);
	int AddWinStationToList(CWinStation *pWinStation);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerWinStationsPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerWinStationsPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerWinStationsPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnWinStationItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusWinstationList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerWinStationsPage

////////////////////////////
// CLASS: CServerProcessesPage
//
class CServerProcessesPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CServerProcessesPage)
	enum { IDD = IDD_SERVER_PROCESSES };
	CListCtrl	m_ProcessList;
	//}}AFX_DATA

// Attributes
public:

private:
	CServer *m_pServer;
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	CCriticalSection m_ListControlCriticalSection;

// Operations
public:
	void UpdateProcesses();
	void RemoveProcess(CProcess *pProcess);

private:
	void DisplayProcesses();			
	virtual void Reset(void *pServer);
	int AddProcessToList(CProcess *pProcess);
	void LockListControl() { m_ListControlCriticalSection.Lock(); }
	void UnlockListControl() { m_ListControlCriticalSection.Unlock(); }

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusProcessList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerProcessesPage


//////////////////////////
// CLASS: CServerLicensesPage
//
class CServerLicensesPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerLicensesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerLicensesPage)

// Form Data
public:
	//{{AFX_DATA(CServerLicencesPage)
	enum { IDD = IDD_SERVER_LICENSES };
	CListCtrl	m_LicenseList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_ImageList;	// image list associated with the tree control
	
	int m_idxBase;		// index of Base image
	int m_idxBump;		// index of Bump image
	int m_idxEnabler;	// index of Enabler image 
	int m_idxUnknown;	// index of Unknown image
	int m_idxBlank;		// index of Blank image

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayLicenses();			
	void DisplayLicenseCounts();
	virtual void Reset(void *pServer);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerLicensesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerLicensesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerLicensesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusLicenseList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerLicensesPage


//////////////////////////
// CLASS: CServerInfoPage
//
class CServerInfoPage : public CAdminPage
{
friend class CServerView;

protected:
	CServerInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerInfoPage)

// Form Data
public:
	//{{AFX_DATA(CServerInfoPage)
	enum { IDD = IDD_SERVER_INFO };
	CListCtrl	m_HotfixList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_StateImageList; 

	int m_idxNotSign;	// index of Not Sign image (for non-valid hotfixes - state)

private:
	CServer* m_pServer;	// pointer to current server's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:

private:
	void DisplayInfo();
	virtual void Reset(void *pServer);
	void BuildImageList();			// builds the image list;
        void TSAdminDateTimeString(LONG InstallDate, LPTSTR TimeString, BOOL LongDate=FALSE);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerInfoPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CServerInfoPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillfocusHotfixList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerInfoPage


#endif  // _SERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#include <lm.h>
#include <dsgetdc.h>


#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#ifdef DBG

extern bool g_fDebug;

#define ODS( x ) \
    if( g_fDebug ) OutputDebugString( x );\

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[260]; \
    if( g_fDebug ){ \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }\
    }\

#define DBGMSGx( x , y , z ) \
    {\
    TCHAR tchErr[ 260 ]; \
    if( g_fDebug ){ \
    wsprintf( tchErr , x , y , z ); \
    ODS( tchErr ); \
    }\
    }\

#else
#define ODS
#define DBGMSG
#define DBGMSGx
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
// stdafx.cpp : source file that includes just the standard includes
//	WinAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\servervw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.cpp
*
* implementation of the CServerView class
*
*
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "servervw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CServerView
//
IMPLEMENT_DYNCREATE(CServerView, CView)

BEGIN_MESSAGE_MAP(CServerView, CView)
	//{{AFX_MSG_MAP(CServerView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_SERVER_TABS, OnTabSelChange)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_MESSAGE(WM_ADMIN_UPDATE_SERVER_INFO, OnAdminUpdateServerInfo)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_LICENSES, OnAdminRedisplayLicenses)
	ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATIONS, OnAdminUpdateWinStations)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )
END_MESSAGE_MAP()

PageDef CServerView::pages[NUMBER_OF_PAGES] = {
	{ NULL, RUNTIME_CLASS( CUsersPage ),				IDS_TAB_USERS,		PAGE_USERS,			NULL },
	{ NULL, RUNTIME_CLASS( CServerWinStationsPage ),	IDS_TAB_WINSTATIONS,PAGE_WINSTATIONS,	NULL },
	{ NULL, RUNTIME_CLASS( CServerProcessesPage ),		IDS_TAB_PROCESSES,	PAGE_PROCESSES,		NULL },
	{ NULL, RUNTIME_CLASS( CServerLicensesPage ),		IDS_TAB_LICENSES,	PAGE_LICENSES,		PF_PICASSO_ONLY }
	// { NULL, RUNTIME_CLASS( CServerInfoPage ),			IDS_TAB_INFORMATION,PAGE_INFO,			NULL }
};


///////////////////////
// F'N: CServerView ctor
//
CServerView::CServerView()
{
	m_pTabs = NULL;
	m_pTabFont = NULL;
	m_pServer = NULL;	

	m_CurrPage = PAGE_USERS;

}  // end CServerView ctor


///////////////////////
// F'N: CServerView dtor
//
CServerView::~CServerView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CServerView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CServerView::AssertValid
//
void CServerView::AssertValid() const
{
	CView::AssertValid();

}  // end CServerView::AssertValid


////////////////////////
// F'N: CServerView::Dump
//
void CServerView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CServerView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CServerView::OnCreate
//
int CServerView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CServerView::OnCreate


///////////////////////////////////
// F'N: CServerView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CServerView::OnInitialUpdate() 
{
    // create the CServerTabs
    m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
    m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_SERVER_TABS);

    m_pTabFont = new CFont;
    if(m_pTabFont) {
        m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
        m_pTabs->SetFont(m_pTabFont, TRUE);
    }

    TCHAR szTemp[40];
    CString tabString;

    int index = 0;
    for(int i = 0; i < NUMBER_OF_PAGES; i++) {
        // If the page is shown under Picasso only and we're not running
        // under Picasso, skip to the next one
        if((pages[i].flags & PF_PICASSO_ONLY) && !((CWinAdminApp*)AfxGetApp())->IsPicasso()) continue;
        tabString.LoadString(pages[i].tabStringID);
        lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
        AddTab(index, szTemp, i);
        pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
        pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);

        GetDocument()->AddView(pages[i].m_pPage);
        index++;
    }

    m_pTabs->SetCurSel(0);	

    m_CurrPage = PAGE_USERS;
    ((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_USERS);

    OnChangePage(NULL, NULL);

}  // end CServerView::OnInitialUpdate


//////////////////////////
// F'N: CServerView::OnSize
//
// - size the pages to fill the entire view
//
void CServerView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the CServerTabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CServerView::OnSize


//////////////////////////
// F'N: CServerView::OnDraw
//
// - the CServerView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CServerView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CServerView::OnDraw


/////////////////////////
// F'N: CServerView::Reset
//
// - 'resets' the view by taking a pointer to a CServer object and filling in 
//   the various property pages with info appropriate to that server
//
void CServerView::Reset(void *pServer)
{
    ((CServer*)pServer)->ClearAllSelected();

    m_pServer = (CServer*)pServer;

    if(((CWinAdminApp*)AfxGetApp())->IsPicasso())
    {
        int PreviousTab = m_pTabs->GetCurSel();

        BOOLEAN bWinFrame = ((CServer*)pServer)->IsWinFrame();
        // Delete all the tabs
        m_pTabs->DeleteAllItems();

        // If this server isn't a WinFrame server, the current page might not be
        // applicable
        int CurrentPage = m_CurrPage;
        if(!bWinFrame && CurrentPage == PAGE_LICENSES)
        {
            CurrentPage = PAGE_INFO;
        }
		
        // create tabs only for pages we want to show for this server
        int index = 0;
        TCHAR szTemp[40];
        CString tabString;
        int CurrentTab = 0;

        for(int i = 0; i < NUMBER_OF_PAGES; i++)
        {	
            if((pages[i].flags & PF_PICASSO_ONLY) && !bWinFrame)
            {
                continue;
            }

            tabString.LoadString(pages[i].tabStringID);

            lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));

            AddTab(index, szTemp, i);

            if(pages[i].page == CurrentPage)
            {
                CurrentTab = index;
            }

            index++;
        }
				
        m_pTabs->SetCurSel(CurrentTab);
        if(PreviousTab == CurrentTab && CurrentPage != m_CurrPage)
            OnChangePage(NULL, NULL);
    }

    ((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);

    // Reset pages
    for(int i = 0; i < NUMBER_OF_PAGES; i++)
    {       
        if(pages[i].m_pPage != NULL )
        {
            pages[i].m_pPage->Reset((CServer*)pServer);
        }   
    }

}  // end CServerView::Reset


//////////////////////////
// F'N: CServerView::AddTab
//
void CServerView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CServerView::AddTab


////////////////////////////////
// F'N: CServerView::OnChangePage
//
// - changes to a new server page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
LRESULT CServerView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int tab = m_pTabs->GetCurSel();
	TC_ITEM tc;
	tc.mask = TCIF_PARAM;
	m_pTabs->GetItem(tab, &tc);
	int index = (int)tc.lParam;
						
	// hide the current page
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);
    pages[m_CurrPage].m_pPage->ClearSelections();

	m_CurrPage = index;
	((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);
	// show the new page
	pages[index].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[index].m_pPage->ScrollToPosition(CPoint(0,0));
	pages[index].m_pPage->Invalidate();	

	if(m_pServer) m_pServer->ClearAllSelected();

	return 0;

}  // end CServerView::OnChangeview

void CServerView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage( 0 , 0 );
	*pResult = 0;

}  // end CServerView::OnTabSelChange


LRESULT CServerView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->UpdateProcesses();

	return 0;

}  // end CServerView::OnAdminUpdateProcesses


LRESULT CServerView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->DisplayProcesses();

	return 0;

}  // end CServerView::OnAdminRedisplayProcesses


LRESULT CServerView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
	((CServerProcessesPage*)pages[PAGE_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CServerView::OnAdminRemoveProcess


LRESULT CServerView::OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam)
{
	((CUsersPage*)pages[PAGE_USERS].m_pPage)->UpdateWinStations((CServer*)lParam);
	((CServerWinStationsPage*)pages[PAGE_WINSTATIONS].m_pPage)->UpdateWinStations((CServer*)lParam);

	return 0;
}  // end CServerView::OnAdminUpdateWinStations


LRESULT CServerView::OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam)
{
/*	((CServerInfoPage*)pages[PAGE_INFO].m_pPage)->DisplayInfo(); */

	if(pages[PAGE_LICENSES].m_pPage)
		((CServerLicensesPage*)pages[PAGE_LICENSES].m_pPage)->DisplayLicenseCounts();


   return 0;

}  // end CServerView::OnAdminUpdateServerInfo


LRESULT CServerView::OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam)
{
	if(pages[PAGE_LICENSES].m_pPage)
		((CServerLicensesPage*)pages[PAGE_LICENSES].m_pPage)->Reset((CServer*)lParam);

	return 0;

}  // end CServerView::OnAdminRedisplayLicenses

LRESULT CServerView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CServerView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            // 
            // treeview should've started off with initial focus
            // we should 
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );
                m_pTabs->SetCurFocus( nTab );
                
                pDoc->RegisterLastFocus( TAB_CTRL );
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                // set focus to item in page
                pages[ m_CurrPage ].m_pPage->SetFocus( );
                pDoc->RegisterLastFocus( PAGED_ITEM );
            }
            else
            {
                ODS( L"from item to treeview\n" );
                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CServerView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:

                ODS( L"going back from tree to paged item\n" );

                pages[ m_CurrPage ].m_pPage->SetFocus( );

                pDoc->RegisterLastFocus( PAGED_ITEM );

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CServerView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CServerView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CServerView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CServerView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\servervw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* servervw.h
*
* declarations for the CServerView class
*
*  
*******************************************************************************/

#ifndef _SERVERVIEW_H
#define _SERVERVIEW_H

#include "servpgs.h"

const int NUMBER_OF_PAGES = 4;


////////////////////
// CLASS: CServerView
//
class CServerView : public CAdminView
{
friend class CRightPane;
friend class CAdminPage;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;


	CServer* m_pServer;	// pointer to current server's info
		
protected:
	CServerView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CServerView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_PAGES];

// Operations
public:
	int GetCurrentPage() { return m_CurrPage; }
protected:
	virtual void Reset(void *pServer);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServerView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CServerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    // Generated message map functions
protected:
	//{{AFX_MSG(CServerView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg LRESULT OnAdminUpdateServerInfo(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayLicenses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateWinStations(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CServerView

#endif  // _SERVERVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\threads.h ===
/*******************************************************************************
*
* threads.h
*
* declarations of the thread classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   butchd  $  Don Messerli
*
* $Log:   M:\NT\PRIVATE\UTILS\CITRIX\WINUTILS\WINADMIN\VCS\THREADS.H  $
*  
*     Rev 1.0   30 Jul 1997 17:12:48   butchd
*  Initial revision.
*
*******************************************************************************/

////////////////////////////////////////////////////////////////////////////////
// CThread class
//
class CThread
{

/*
 * Member variables.
 */
protected:
    HANDLE m_hThread;
    DWORD m_dwThreadID;

/*
 * Implementation
 */
public:
    virtual ~CThread();
//    void* operator new(size_t nSize);
//    void operator delete(void* p);
protected:
    CThread();
    static DWORD __stdcall ThreadEntryPoint(LPVOID lpParam);
    virtual DWORD RunThread() = 0;

/*
 * Operations: primary thread
 */
public:
    HANDLE CreateThread( DWORD cbStack = 0,
                         DWORD fdwCreate = 0 );

};  // end CThread class interface
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread structures, defines, and typedefs
//
#define MAX_STATUS_SEMAPHORE_COUNT 1
#define MAX_SLEEP_COUNT 10


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread class
//
class CWSStatusThread : public CThread
{

/*
 * Member variables.
 */
public:
    ULONG m_LogonId;
	HANDLE m_hServer;
    HWND m_hDlg;
    WINSTATIONINFORMATION m_WSInfo;
    PDCONFIG m_PdConfig;
protected:
    HANDLE m_hWakeUp;
    HANDLE m_hConsumed;
    BOOL m_bExit;

/*
 * Implementation
 */
public:
    CWSStatusThread();
protected:
    virtual ~CWSStatusThread();
    virtual DWORD RunThread();

/*
 * Operations: primary thread.
 */
public:
    void SignalWakeUp();
    void SignalConsumed();
    void ExitThread();

/*
 * Operations: secondary thread.
 */
protected:
    BOOL WSPdQuery();
    BOOL WSInfoQuery();

};  // end CWSStatusThread class interface
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\threads.cpp ===
/*******************************************************************************
*
* threads.cpp
*
* implementation of threads classes
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\winadmin\VCS\threads.cpp  $
*  
*     Rev 1.1   26 Aug 1997 19:15:14   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:12:44   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "threads.h"
#include "led.h"

////////////////////////////////////////////////////////////////////////////////
// CThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CThread - CThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::CThread()
{
    m_hThread = NULL;
    m_dwThreadID = 0;

}  // end CThread::CThread


/*******************************************************************************
 *
 *  ~CThread - CThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CThread::~CThread()
{
}  // end CThread::~CThread


/*******************************************************************************
 *
 *  operator new - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
#if 0
void *
CThread::operator new(size_t nSize)
{
    return( ::malloc(nSize) );

}  // end CThread::operator new
#endif

/*******************************************************************************
 *
 *  operator delete - CThread operator override
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/
#if 0
void
CThread::operator delete(void *p)
{
    ::free(p);

}  // end CThread::operator delete
#endif

////////////////////////////////////////////////////////////////////////////////
// CThread operations: primary thread

/*******************************************************************************
 *
 *  CreateThread - CThread implementation function
 *
 *      Class wrapper for the Win32 CreateThread API.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

HANDLE
CThread::CreateThread( DWORD cbStack,
                       DWORD fdwCreate )
{
    /*
     * Simple wrapper for Win32 CreateThread API.
     */
    return( m_hThread = ::CreateThread( NULL, cbStack, ThreadEntryPoint,
            (LPVOID)this, fdwCreate, &m_dwThreadID ) );

}  // end CThread::CreateThread


////////////////////////////////////////////////////////////////////////////////
// CThread operations: secondary thread

/*******************************************************************************
 *
 *  ThreadEntryPoint - CThread implementation function
 *                     (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

DWORD __stdcall
CThread::ThreadEntryPoint(LPVOID lpParam)
{
    CThread *pThread;
    DWORD dwResult;

    /* 
     * (lpParam is actually the 'this' pointer)
     */
    pThread = (CThread*)lpParam;
    VERIFY(pThread != NULL);

    /*
     * Run the thread.
     */
    dwResult = pThread->RunThread();

    /*
     * Return the result.
     */    
    return(dwResult);

}  // end CThread::ThreadEntryPoint
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread class construction / destruction, implementation

/*******************************************************************************
 *
 *  CWSStatusThread - CWSStatusThread constructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CWSStatusThread::CWSStatusThread()
{
    /*
     * Create the semaphore when the CWSStatusThread object is created and
     * initialize the m_bExit and m_bResetCounter flags to FALSE.
     */
    VERIFY( m_hWakeUp = CreateSemaphore( NULL, 0,
                                         MAX_STATUS_SEMAPHORE_COUNT,
                                         NULL ) );
    VERIFY( m_hConsumed = CreateSemaphore( NULL, 0,
                                           MAX_STATUS_SEMAPHORE_COUNT,
                                           NULL ) );
    m_bExit = FALSE;

}  // end CWSStatusThread::CWSStatusThread


/*******************************************************************************
 *
 *  ~CWSStatusThread - CWSStatusThread destructor
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

CWSStatusThread::~CWSStatusThread()
{
    /*
     * Close the semaphores when the CWSStatusThread object is destroyed.
     */
    VERIFY( CloseHandle(m_hWakeUp) );
    VERIFY( CloseHandle(m_hConsumed) );

}  // end CWSStatusThread::~CWSStatusThread


/*******************************************************************************
 *
 *  RunThread - CWSStatusThread secondary thread main function loop
 *              (SECONDARY THREAD)
 *
 *  ENTRY:
 *  EXIT:
 *      (DWORD) exit status for the secondary thread.
 *
 ******************************************************************************/

DWORD
CWSStatusThread::RunThread()
{
    /* 
     * Query for PD and WinStation information to initialize dialog with.
     */
    if ( !WSPdQuery() || !WSInfoQuery() ) {

        /*
         * We can't query the WinStation information: tell the primary
         * thread that we've aborted, and exit this thread.
         */
        PostMessage(m_hDlg, WM_STATUSABORT, 0, 0);
        return(1);

    } else {

        /*
         * Tell the primary thread (modeless dialog window) that we've
         * got the initial information.
         */
        PostMessage(m_hDlg, WM_STATUSSTART, 0, 0);
        WaitForSingleObject(m_hConsumed, INFINITE);

        /* 
         * Always check for exit request each time we wake up and exit
         * the thread if the exit flag is set.
         */
        if ( m_bExit )
            return(0);
    }

    /*
     * Loop till exit requested.
     */
    for ( ; ; ) {

        /* 
         * Block the thread until time to refresh or we're woken up.
         */
        WaitForSingleObject( m_hWakeUp, ((CWinAdminApp*)AfxGetApp())->GetStatusRefreshTime());
        if ( m_bExit )
            return(0);

        /* 
         * Query for WinStation information.
         */
        if ( !WSInfoQuery() || (m_WSInfo.ConnectState == State_Disconnected) ) {

            /*
             * Either we can't query the WinStation or it has become
             * disconnected: tell the primary thread that we've aborted,
             * and exit this thread.
             */
            PostMessage(m_hDlg, WM_STATUSABORT, 0, 0);
            return(1);

        } else {

            /*
             * Tell the dialog that we've got some new query information.
             */
            PostMessage(m_hDlg, WM_STATUSREADY, 0, 0);
            WaitForSingleObject(m_hConsumed, INFINITE);
            if ( m_bExit )
                return(0);
        }
    }

}  // end CWSStatusThread::RunThread


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread operations: primary thread

/*******************************************************************************
 *
 *  SignalWakeUp - CWSStatusThread member function: public operation
 *
 *      Release the m_hWakeUp semaphore to start another status query.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::SignalWakeUp()
{
    ReleaseSemaphore(m_hWakeUp, 1, NULL);

}  // end CWSStatusThread::SignalWakeUp


/*******************************************************************************
 *
 *  SignalConsumed - CWSStatusThread member function: public operation
 *
 *      Release the m_hConsumed semaphore to allow secondary thread to continue
 *      running.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::SignalConsumed()
{
    ReleaseSemaphore( m_hConsumed, 1, NULL );

}  // end CWSStatusThread::SignalConsumed


/*******************************************************************************
 *
 *  ExitThread - CWSStatusThread member function: public operation
 *
 *      Tell the secondary thread to exit and cleanup after.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CWSStatusThread::ExitThread()
{
    DWORD dwReturnCode;
    int i;
    CWaitCursor Nikki;

    /*
     * If the thread was not created properly, just delete object and return.
     */
    if ( !m_hThread ) {
        delete this;
        return;
    }

    /*
     * Set the m_bExit flag to TRUE and bump both the consumed and wake up
     * semaphores to cause RunThread() (the thread's main instructon loop)
     * to exit.
     */
    m_bExit = TRUE;
    SignalWakeUp();
    SignalConsumed();

    /*
     * Wait a while for the thread to exit.
     */
    for ( i = 0, GetExitCodeThread( m_hThread, &dwReturnCode );
          (i < MAX_SLEEP_COUNT) && (dwReturnCode == STILL_ACTIVE); i++ ) {

        Sleep(100);
        GetExitCodeThread( m_hThread, &dwReturnCode );
    }

    /*
     * If the thread has still not exited, terminate it.
     */
    if ( dwReturnCode == STILL_ACTIVE ) {

        TerminateThread( m_hThread, 1 );

#ifdef _DEBUG
//    TRACE2( "WSSTATUS: Forced Terminate of thread monitoring LogonID %lu after %u 100msec exit waits.\n",
//            m_LogonId, MAX_SLEEP_COUNT );
#endif

    }

    /*
     * Close the thread handle and delete this CWSStatusThread object
     */
    VERIFY( CloseHandle(m_hThread) );
    delete this;

}  // end CWSStatusThread::ExitThread


////////////////////////////////////////////////////////////////////////////////
// CWSStatusThread operations: secondary thread

/*******************************************************************************
 *
 *  WSPdQuery - CWSStatusThread member function: private operation
 *              (SECONDARY THREAD)
 *
 *      Query the Pd information for the WinStation object referenced by
 *      the m_LogonId member variable.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if query was sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWSStatusThread::WSPdQuery()
{
	ULONG ReturnLength;

	/*
	 * Query the PD information.
	 */
	memset( &m_PdConfig, 0, sizeof(PDCONFIG) );
	if ( !WinStationQueryInformation(	m_hServer,
													m_LogonId,
													WinStationPd,
													&m_PdConfig, sizeof(PDCONFIG),
													&ReturnLength ) )
		goto BadWSQueryInfo;

	if(!WinStationQueryInformation(m_hServer,
											m_LogonId,
											WinStationPd,
											&m_PdConfig, sizeof(PDCONFIG),
											&ReturnLength ) )
		goto BadWSQueryInfo;

	return(TRUE);

 /*--------------------------------------
 * Error clean-up and return...
 */
BadWSQueryInfo:
    return(FALSE);

}  // end CWSStatusThread::WSPdQuery


/*******************************************************************************
 *
 *  WSInfoQuery - CWSStatusThread member function: private operation
 *                (SECONDARY THREAD)
 *
 *      Query the WinStation information for the WinStation object referenced
 *      by the m_LogonId member variable.
 *
 *  ENTRY:
 *
 *  EXIT:
 *      (BOOL) TRUE if query was sucessful; FALSE otherwise.
 *
 ******************************************************************************/

BOOL
CWSStatusThread::WSInfoQuery()
{
    ULONG ReturnLength;

    /*
     * Query the WinStation information.
     */
	TRACE0(">>> CWSStatusThread::WSInfoQuery WinStationQueryInformation\n");
    if ( !WinStationQueryInformation( m_hServer,
                                      m_LogonId,
                                      WinStationInformation,
                                      &m_WSInfo, sizeof(WINSTATIONINFORMATION),
                                      &ReturnLength ) )
        goto BadWSQueryInfo;
	TRACE0("<<< CWSStatusThread::WSInfoQuery WinStationQueryInformation (success)\n");

    return(TRUE);

/*--------------------------------------
 * Error clean-up and return...
 */
BadWSQueryInfo:
	TRACE0("<<< CWSStatusThread::WSInfoQuery WinStationQueryInformation (error)\n");
    return(FALSE);

}  // end CWSStatusThread::WSInfoQuery


///////////////////////////////////////////////////////////////////////////////
// CLed class construction / destruction, implementation

/*******************************************************************************
 *
 *  CLed - CLed constructor
 *
 *  ENTRY:
 *      hBrush (input)
 *          Brush to paint window with.
 *  EXIT:
 *      (Refer to MFC CStatic::CStatic documentation)
 *
 ******************************************************************************/

CLed::CLed( HBRUSH hBrush ) 
    : CStatic(),
      m_hBrush(hBrush)
{
	//{{AFX_DATA_INIT(CLed)
	//}}AFX_DATA_INIT

}  // end CLed::CLed


////////////////////////////////////////////////////////////////////////////////
//  CLed operations

/*******************************************************************************
 *
 *  Subclass - CLed member function: public operation
 *
 *      Subclass the specified object to our special blip object.
 *
 *  ENTRY:
 *      pStatic (input)
 *          Points to CStatic object to subclass.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Subclass( CStatic *pStatic )
{
    SubclassWindow(pStatic->m_hWnd);

}  // end CLed::Subclass


/*******************************************************************************
 *
 *  Update - CLed member function: public operation
 *
 *      Update the LED to 'on' or 'off' state.
 *
 *  ENTRY:
 *      nOn (input)
 *          nonzero to set 'on' state; zero for 'off' state.
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Update( int nOn )
{
    m_bOn = nOn ? TRUE : FALSE;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Update


/*******************************************************************************
 *
 *  Toggle - CLed member function: public operation
 *
 *      Toggle the LED's on/off state.
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

void
CLed::Toggle()
{
    m_bOn = !m_bOn;
    InvalidateRect(NULL);
    UpdateWindow();

}  // end CLed::Toggle


////////////////////////////////////////////////////////////////////////////////
// CLed message map

BEGIN_MESSAGE_MAP(CLed, CStatic)
	//{{AFX_MSG_MAP(CLed)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////////////////
//  CLed commands


/*******************************************************************************
 *
 *  OnPaint - CLed member function: public operation
 *
 *      Paint the led with its brush for 'on' state.
 *
 *  ENTRY:
 *  EXIT:
 *      (Refer to MFC CWnd::OnPaint documentation)
 *
 ******************************************************************************/

void
CLed::OnPaint() 
{
    RECT rect;
    CPaintDC dc(this);
    CBrush brush;

    GetClientRect(&rect);

#ifdef USING_3DCONTROLS
    (rect.right)--;
    (rect.bottom)--;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(GRAY_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right)++;
    (rect.bottom)++;
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)) );

    (rect.top)++;
    (rect.left)++;
    (rect.right) -= 2;
    (rect.bottom) -= 2;
#else
    dc.FrameRect( &rect, brush.FromHandle((HBRUSH)GetStockObject(BLACK_BRUSH)) );
    (rect.top)++;
    (rect.left)++;
    (rect.right)--;
    (rect.bottom)--;
#endif
    dc.FillRect( &rect,
                 brush.FromHandle(
                    m_bOn ?
                        m_hBrush :
                        (HBRUSH)GetStockObject(LTGRAY_BRUSH)) );

}  // end CLed::OnPaint
////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winadmin.h ===
/*******************************************************************************
*
* winadmin.h
*
* main header file for the WINADMIN application
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winadmin.h  $
*
*     Rev 1.12   25 Apr 1998 13:43:14   donm
*  MS 2167: try to use proper Wd from registry
*
*     Rev 1.11   19 Feb 1998 17:42:52   donm
*  removed latest extension DLL support
*
*     Rev 1.9   19 Jan 1998 16:49:28   donm
*  new ui behavior for domains and servers
*
*     Rev 1.8   03 Nov 1997 15:28:02   donm
*  added Domains
*
*     Rev 1.7   22 Oct 1997 21:09:10   donm
*  update
*
*     Rev 1.6   17 Oct 1997 18:07:28   donm
*  update
*
*     Rev 1.5   15 Oct 1997 19:52:48   donm
*  update
*
*     Rev 1.4   13 Oct 1997 23:07:14   donm
*  update
*
*     Rev 1.3   13 Oct 1997 22:20:02   donm
*  update
*
*     Rev 1.2   26 Aug 1997 19:16:24   donm
*  bug fixes/changes from WinFrame 1.7
*
*     Rev 1.1   31 Jul 1997 16:52:52   butchd
*  update
*
*     Rev 1.0   30 Jul 1997 17:13:12   butchd
*  Initial revision.
*
*******************************************************************************/

#ifndef _WINADMIN_H
#define _WINADMIN_H

#ifndef __AFXWIN_H__
        #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include <afxmt.h>
#include <winsta.h>
#include <time.h>
#include <utildll.h>
#include "waextend.h"

// Classes defined in this file
class CTreeNode;
class CWinStation;
class CModule;
class CLicense;
class CServer;
class CWinAdminApp;
class CProcess;
class CHotFix;
class CDomain;
class CWd;

// Server icon overlay states
const USHORT STATE_NORMAL = 0x0000;
const USHORT STATE_NOT = 0x0100;
const USHORT STATE_QUESTION = 0x0200;

const USHORT MSG_TITLE_LENGTH = 64;
const USHORT MSG_MESSAGE_LENGTH = 256;

const USHORT LIST_TOP_OFFSET = 4;

const int KBDSHIFT      = 0x01;
const int KBDCTRL       = 0x02;
const int KBDALT        = 0x04;


enum VIEW {
    VIEW_BLANK,
    VIEW_ALL_SERVERS,
    VIEW_DOMAIN,
    VIEW_SERVER,
    VIEW_MESSAGE,
    VIEW_WINSTATION,
    VIEW_CHANGING
    };

const int PAGE_CHANGING = 0xFFFF;

enum AS_PAGE {
// All Servers Pages
    PAGE_AS_SERVERS,
    PAGE_AS_USERS,
    PAGE_AS_WINSTATIONS,
    PAGE_AS_PROCESSES,
    PAGE_AS_LICENSES
};

enum DOMAIN_PAGE {
    PAGE_DOMAIN_SERVERS,
    PAGE_DOMAIN_USERS,
    PAGE_DOMAIN_WINSTATIONS,
    PAGE_DOMAIN_PROCESSES,
    PAGE_DOMAIN_LICENSES
};

enum SERVER_PAGE {
// Server Pages
    PAGE_USERS,
    PAGE_WINSTATIONS,
    PAGE_PROCESSES,
    PAGE_LICENSES,
    PAGE_INFO
};

enum WINS_PAGE {
// WinStation Pages
    PAGE_WS_PROCESSES,
    PAGE_WS_INFO,
    PAGE_WS_MODULES,
    PAGE_WS_CACHE,
    PAGE_WS_NO_INFO
};

// The column enums have to be here so that colsort.cpp can get to them
// Server User's columns
enum USERSCOLUMNS {
    USERS_COL_USER,
    USERS_COL_WINSTATION,
    USERS_COL_ID,
    USERS_COL_STATE,
    USERS_COL_IDLETIME,
    USERS_COL_LOGONTIME
};

// Server WinStation's columns
enum STATIONCOLUMNS {
    WS_COL_WINSTATION,
    WS_COL_USER,
    WS_COL_ID,
    WS_COL_STATE,
    WS_COL_TYPE,
    WS_COL_CLIENTNAME,
    WS_COL_IDLETIME,
    WS_COL_LOGONTIME,
    WS_COL_COMMENT
};

// Server Processes' columns
enum PROCESSCOLUMNS {
    PROC_COL_USER,
    PROC_COL_WINSTATION,
    PROC_COL_ID,
    PROC_COL_PID,
    PROC_COL_IMAGE
};

// Server Licenses' columns
enum LICENSECOLUMNS {
    LICENSE_COL_DESCRIPTION,
    LICENSE_COL_REGISTERED,
    LICENSE_COL_USERCOUNT,
    LICENSE_COL_POOLCOUNT,
    LICENSE_COL_NUMBER
};

// Server Hotfix columns
enum HOTFIXCOLUMNS {
    HOTFIX_COL_NAME,
    HOTFIX_COL_INSTALLEDBY,
    HOTFIX_COL_INSTALLEDON
};

// WinStation Processes columns
enum WS_PROCESSCOLUMNS {
    WS_PROC_COL_ID,
    WS_PROC_COL_PID,
    WS_PROC_COL_IMAGE
};

// WinStation Modules columns
enum MODULESCOLUMNS {
    MODULES_COL_FILENAME,
    MODULES_COL_FILEDATETIME,
    MODULES_COL_SIZE,
    MODULES_COL_VERSIONS
};

// All Server Servers columns
enum SERVERSCOLUMNS {
    SERVERS_COL_SERVER,
    SERVERS_COL_TCPADDRESS,
    SERVERS_COL_IPXADDRESS,
    SERVERS_COL_NUMWINSTATIONS
};

// All Server Users columns
enum AS_USERS_COLUMNS {
    AS_USERS_COL_SERVER,
    AS_USERS_COL_USER,
    AS_USERS_COL_WINSTATION,
    AS_USERS_COL_ID,
    AS_USERS_COL_STATE,
    AS_USERS_COL_IDLETIME,
    AS_USERS_COL_LOGONTIME
};

// All Server WinStations columns
enum AS_STATIONCOLUMNS {
    AS_WS_COL_SERVER,
    AS_WS_COL_WINSTATION,
    AS_WS_COL_USER,
    AS_WS_COL_ID,
    AS_WS_COL_STATE,
    AS_WS_COL_TYPE,
    AS_WS_COL_CLIENTNAME,
    AS_WS_COL_IDLETIME,
    AS_WS_COL_LOGONTIME,
    AS_WS_COL_COMMENT
};

// All Server Processes columns
enum AS_PROCESSCOLUMNS {
    AS_PROC_COL_SERVER,
    AS_PROC_COL_USER,
    AS_PROC_COL_WINSTATION,
    AS_PROC_COL_ID,
    AS_PROC_COL_PID,
    AS_PROC_COL_IMAGE
};

// All Server Licenses columns
enum AS_LICENSECOLUMNS {
    AS_LICENSE_COL_SERVER,
    AS_LICENSE_COL_DESCRIPTION,
    AS_LICENSE_COL_REGISTERED,
    AS_LICENSE_COL_USERCOUNT,
    AS_LICENSE_COL_POOLCOUNT,
    AS_LICENSE_COL_NUMBER
};

// in colsort.cpp
void SortByColumn(int View, int Page, CListCtrl *list, int ColumnNumber, BOOL bAscending);

// Extension Startup Function
typedef void (WINAPI *LPFNEXSTARTUPPROC) (HWND);
// Extension Shutdown Function
typedef void (WINAPI *LPFNEXSHUTDOWNPROC) (void);
// Extension Server Enumerate Function
typedef LPWSTR (WINAPI *LPFNEXENUMERATEPROC) (LPWSTR);
// Extension WinStation Init Function
typedef void* (WINAPI *LPFNEXWINSTATIONINITPROC) (HANDLE, ULONG);
// Extension WinStation Additional Info Function
typedef void (WINAPI *LPFNEXWINSTATIONINFOPROC) (void*, int);
// Extension WinStation Cleanup Function
typedef void (WINAPI *LPFNEXWINSTATIONCLEANUPPROC) (void*);
// Extension Server Init Function
typedef void* (WINAPI *LPFNEXSERVERINITPROC) (TCHAR*, HANDLE);
// Extension Server Cleanup Function
typedef void (WINAPI *LPFNEXSERVERCLEANUPPROC) (void*);
// Extension Server Event Function
typedef BOOL (WINAPI *LPFNEXSERVEREVENTPROC) (void*, ULONG);
// Extension Get Server Info
typedef ExtServerInfo* (WINAPI *LPFNEXGETSERVERINFOPROC) (void *);
// Extension Get Server License Info
typedef ExtLicenseInfo* (WINAPI *LPFNEXGETSERVERLICENSESPROC) (void*, ULONG*);
// Extension Get Global Info
typedef ExtGlobalInfo* (WINAPI *LPFNEXGETGLOBALINFOPROC) (void);
// Extension Get WinStation Info
typedef ExtWinStationInfo* (WINAPI *LPFNEXGETWINSTATIONINFOPROC) (void *);
// Extension Get WinStation Modules
typedef ExtModuleInfo* (WINAPI *LPFNEXGETWINSTATIONMODULESPROC) (void*, ULONG*);
// Extension Free Server License Info
typedef void (WINAPI *LPFNEXFREESERVERLICENSESPROC) (ExtLicenseInfo*);
// Extension Free WinStation Modules
typedef void (WINAPI *LPFNEXFREEWINSTATIONMODULESPROC) (ExtModuleInfo*);

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp:
// See WinAdmin.cpp for the implementation of this class
//
class CWinAdminApp : public CWinApp
{
public:
    // constructor
    CWinAdminApp();
    // Returns the Current User Name
    TCHAR *GetCurrentUserName() { return m_CurrentUserName; }
    // Returns the Current WinStation Name
    PWINSTATIONNAME GetCurrentWinStationName() { return m_CurrentWinStationName; }
    // Returns the Current Server Name
    TCHAR *GetCurrentServerName() { return m_CurrentServerName; }
    // Returns the Current Logon Id
    ULONG GetCurrentLogonId() { return m_CurrentLogonId; }
    // Returns the Current WinStation Flags
    ULONG GetCurrentWSFlags() { return m_CurrentWSFlags; }
    // Returns TRUE if the current user has Admin privileges?
    BOOL IsUserAdmin() { return m_Admin; }
    // Returns TRUE if we are running under Picasso
    BOOL IsPicasso() { return m_Picasso; }
    // Returns TRUE if we should show system processes
    BOOL ShowSystemProcesses() { return m_ShowSystemProcesses; }
    // Sets the show system processes variable
    void SetShowSystemProcesses(BOOL show) { m_ShowSystemProcesses = show; }
    // Returns TRUE if we should ask user for confirmation of Actions
    BOOL AskConfirmation() { return m_Confirmation; }
    // Sets the confirmation variable
    void SetConfirmation(BOOL conf) { m_Confirmation = conf; }
    // Returms TRUE if we should save the preferences upon exit
    BOOL SavePreferences() { return m_SavePreferences; }
    // Sets the save preferences variable
    void SetSavePreferences(BOOL pref) { m_SavePreferences = pref; }
    // Returns the Process List Refresh Time
    UINT GetProcessListRefreshTime() { return m_ProcessListRefreshTime; }
    // Sets the Process List Refresh Time
    void SetProcessListRefreshTime(UINT pt) { m_ProcessListRefreshTime = pt; }
    // Returns the Status Dialog Refresh Time
    UINT GetStatusRefreshTime() { return m_StatusRefreshTime; }
    // Sets the Status Dialog Refresh Time
    void SetStatusRefreshTime(UINT st) { m_StatusRefreshTime = st; }
    // Returns a pointer to the document
    CDocument *GetDocument() { return m_Document; }
    // Sets the m_Document variable
    void SetDocument(CDocument *doc) { m_Document = doc; }
    // Should we Show All Servers - based on menu item toggle
    BOOL GetShowAllServers() { return m_ShowAllServers; }
    // Set the Show All Servers variable
    void SetShowAllServers(BOOL sa) { m_ShowAllServers = sa; }
    // Returns the value of shadow hotkey key
    int GetShadowHotkeyKey() { return m_ShadowHotkeyKey; }
    // Sets the value of shadow hotkey key
    void SetShadowHotkeyKey(int key) { m_ShadowHotkeyKey = key; }
    // Returns the value of shadow hotkey shift state
    DWORD GetShadowHotkeyShift() { return m_ShadowHotkeyShift; }
    // Sets the value of shadow hotkey shift state
    void SetShadowHotkeyShift(DWORD shift) { m_ShadowHotkeyShift = shift; }
    // Get the tree width
    int GetTreeWidth() { return m_TreeWidth; }
    // Set the tree width
    void SetTreeWidth(int width) { m_TreeWidth = width; }
    // Get the window placement
    WINDOWPLACEMENT *GetPlacement() { return &m_Placement; }

    // Returns the address of the extension DLL's startup function
    LPFNEXSTARTUPPROC GetExtStartupProc() { return m_lpfnWAExStart; }
    // Returns the address of the extension DLL's shutdown function
    LPFNEXSHUTDOWNPROC GetExtShutdownProc() { return m_lpfnWAExEnd; }
    // Returns the address of the extension DLL's server enumeration function
    LPFNEXENUMERATEPROC GetExtEnumerationProc() { return m_lpfnWAExServerEnumerate; }
    // Returns the address of the extension DLL's WinStation Init function
    LPFNEXWINSTATIONINITPROC GetExtWinStationInitProc() { return m_lpfnWAExWinStationInit; }
    // Returns the address of the extension DLL's WinStation Info function
    LPFNEXWINSTATIONINFOPROC GetExtWinStationInfoProc() { return m_lpfnWAExWinStationInfo; }
    // Returns the address of the extension DLL's WinStation Cleanup function
    LPFNEXWINSTATIONCLEANUPPROC GetExtWinStationCleanupProc() { return m_lpfnWAExWinStationCleanup; }
    // Returns the address of the extension DLL's Server Init function
    LPFNEXSERVERINITPROC GetExtServerInitProc() { return m_lpfnWAExServerInit; }
    // Returns the address of the extension DLL's Server Cleanup function
    LPFNEXSERVERCLEANUPPROC GetExtServerCleanupProc() { return m_lpfnWAExServerCleanup; }
    // Returns the address of the extension DLL's Get Server Info function
    LPFNEXGETSERVERINFOPROC GetExtGetServerInfoProc() { return m_lpfnWAExGetServerInfo; }
    // Returns the address of the extension DLL's Get Server License Info function
    LPFNEXGETSERVERLICENSESPROC GetExtGetServerLicensesProc() { return m_lpfnWAExGetServerLicenses; }
    // Returns the address of the extension DLL's Server Event function
    LPFNEXSERVEREVENTPROC GetExtServerEventProc() { return m_lpfnWAExServerEvent; }
    // Returns the address of the extension DLL's Get Global Info function
    LPFNEXGETGLOBALINFOPROC GetExtGetGlobalInfoProc() { return m_lpfnWAExGetGlobalInfo; }
    // Returns the address of the extension DLL's Get WinStation Info Function
    LPFNEXGETWINSTATIONINFOPROC GetExtGetWinStationInfoProc() { return m_lpfnWAExGetWinStationInfo; }
    // Returns the address of the extension DLL's Get WinStation Module Info function
    LPFNEXGETWINSTATIONMODULESPROC GetExtGetWinStationModulesProc() { return m_lpfnWAExGetWinStationModules; }
    // Returns the address of the extension DLL's Free Server License Info function
    LPFNEXFREESERVERLICENSESPROC GetExtFreeServerLicensesProc() { return m_lpfnWAExFreeServerLicenses; }
    // Returns the address of the extension DLL's Free WinStation Modules function
    LPFNEXFREEWINSTATIONMODULESPROC GetExtFreeWinStationModulesProc() { return m_lpfnWAExFreeWinStationModules; }

    void BeginOutstandingThread() { ::InterlockedIncrement(&m_OutstandingThreads); }
    void EndOutstandingThread()     { ::InterlockedDecrement(&m_OutstandingThreads); }

    // make this guy public for speed ?
    TCHAR m_szSystemConsole[WINSTATIONNAME_LENGTH+1];
    // make this guy public so the MainFrm can get at it
    WINDOWPLACEMENT m_Placement;

private:
    void ReadPreferences();
    void WritePreferences();
    BOOL IsBrowserRunning();
    LONG m_OutstandingThreads;      // the number of outstanding threads
    TCHAR m_CurrentUserName[USERNAME_LENGTH+1];
    WINSTATIONNAME m_CurrentWinStationName;
    TCHAR m_CurrentServerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG m_CurrentLogonId;
    ULONG m_CurrentWSFlags;
    BOOL m_Admin;                           // does the user have Admin privileges?
    BOOL m_Picasso;                 // are we running under Picasso?
    UINT m_ShowSystemProcesses;
    UINT m_ShowAllServers;
    int m_ShadowHotkeyKey;
    DWORD m_ShadowHotkeyShift;
    int m_TreeWidth;
    HINSTANCE m_hExtensionDLL;      // handle to the extension DLL if loaded

    // functions in the extension DLL
    LPFNEXSTARTUPPROC m_lpfnWAExStart;
    LPFNEXSHUTDOWNPROC m_lpfnWAExEnd;
    LPFNEXENUMERATEPROC m_lpfnWAExServerEnumerate;
    LPFNEXWINSTATIONINITPROC m_lpfnWAExWinStationInit;
    LPFNEXWINSTATIONINFOPROC m_lpfnWAExWinStationInfo;
    LPFNEXWINSTATIONCLEANUPPROC m_lpfnWAExWinStationCleanup;
    LPFNEXSERVERINITPROC m_lpfnWAExServerInit;
    LPFNEXSERVERCLEANUPPROC m_lpfnWAExServerCleanup;
    LPFNEXGETSERVERINFOPROC m_lpfnWAExGetServerInfo;
    LPFNEXGETSERVERLICENSESPROC m_lpfnWAExGetServerLicenses;
    LPFNEXSERVEREVENTPROC m_lpfnWAExServerEvent;
    LPFNEXGETGLOBALINFOPROC m_lpfnWAExGetGlobalInfo;
    LPFNEXGETWINSTATIONINFOPROC m_lpfnWAExGetWinStationInfo;
    LPFNEXGETWINSTATIONMODULESPROC m_lpfnWAExGetWinStationModules;
    LPFNEXFREESERVERLICENSESPROC m_lpfnWAExFreeServerLicenses;
    LPFNEXFREEWINSTATIONMODULESPROC m_lpfnWAExFreeWinStationModules;

    // user preferences
    UINT m_Confirmation;            // ask user for confirmation
    UINT m_SavePreferences;         // save preferences upon exit
    UINT m_ProcessListRefreshTime;
    UINT m_StatusRefreshTime;

    CDocument *m_Document;

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWinAdminApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CWinAdminApp)
    afx_msg void OnAppAbout();
            // NOTE - the ClassWizard will add and remove member functions here.
            //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

enum NODETYPE {
    NODE_ALL_SERVERS,
    NODE_DOMAIN,
    NODE_SERVER,
    NODE_WINSTATION,
    NODE_PUBLISHED_APPS,
    NODE_APPLICATION,
    NODE_APP_SERVER,

    NODE_FAV_LIST,
    NODE_THIS_COMP,
    NODE_NONE
};

class CNodeType : public CObject
{
public:
    CNodeType( NODETYPE m )
    {
        m_nodetype = m;
    }

    ~CNodeType()
    {
        ODS( L"CNodeType I'm going away\n" );
    }

    NODETYPE m_nodetype;
};

class CTreeNode : public CObject
{
public:
    // constructor
    CTreeNode(NODETYPE NodeType, CObject* pObject) { m_NodeType = NodeType; m_pTreeObject = pObject; }
    // Returns the node type
    NODETYPE GetNodeType() { return m_NodeType; }
    // Returns the object pointed to by this node
    CObject *GetTreeObject() { return m_pTreeObject; }
    // Returns the sort order stored in the object
    ULONG GetSortOrder() { return m_SortOrder; }
    // Sets the sort order stored with the object
    void SetSortOrder(ULONG order) { m_SortOrder = order; }

    virtual ~CTreeNode( )
    {
        if( m_NodeType == NODE_FAV_LIST ||  m_NodeType == NODE_THIS_COMP )
        {
            if( m_pTreeObject != NULL )
            {
                delete m_pTreeObject;
            }
            
        }            
    }

private:
    NODETYPE m_NodeType;
    CObject* m_pTreeObject;
    ULONG m_SortOrder;
};

// structure passed to the Server's BackgroundThreadProc
typedef struct _ServerProcInfo {
    CDocument *pDoc;
    CServer *pServer;
} ServerProcInfo;

// structure for storing User SID
class CUserSid : public CObject
{
public:
    USHORT m_SidCrc;
    TCHAR m_UserName[USERNAME_LENGTH+1];
};

// Information we get from the registry of the server
typedef struct _ServerRegistryInfo {
    ULONG InstallDate;
    TCHAR ServicePackLevel[128];
    TCHAR MSVersion[128];
    DWORD MSVersionNum;
    TCHAR MSBuild[128];
    TCHAR MSProductName[128];
    TCHAR CTXProductName[128];
    TCHAR CTXVersion[128];
    DWORD CTXVersionNum;
    TCHAR CTXBuild[128];
} ServerRegistryInfo;


class CHotfix : public CObject
{
public:
    TCHAR m_Name[10];
    TCHAR m_InstalledBy[USERNAME_LENGTH + 1];
    ULONG m_InstalledOn;
    ULONG m_Valid;
    CServer *m_pServer;
};

typedef struct _EncLevel {
    WORD StringID;
    DWORD RegistryValue;
    WORD Flags;
} EncryptionLevel;

typedef LONG (WINAPI *LPFNEXTENCRYPTIONLEVELSPROC) (WDNAME *pWdName, EncryptionLevel **);

class CWd : public CObject
{
public:
    // constructor
    CWd(PWDCONFIG2 pWdConfig, PWDNAME pRegistryName);
    // destructor
    ~CWd();

    BOOL GetEncryptionLevelString(DWORD Value, CString *pString);
    TCHAR *GetName() { return m_WdName; }
    TCHAR *GetRegistryName() { return m_RegistryName; }

private:
    HINSTANCE   m_hExtensionDLL;
    WDNAME m_WdName;
    WDNAME m_RegistryName;
    LPFNEXTENCRYPTIONLEVELSPROC m_lpfnExtEncryptionLevels;
    EncryptionLevel *m_pEncryptionLevels;
    LONG m_NumEncryptionLevels;
};

// structure passed to a Domain's background thread process
typedef struct _DomainProcInfo {
    LPVOID pDoc;
    CDomain *pDomain;
} DomainProcInfo;

// Flags for CDomain objects
const ULONG DF_CURRENT_DOMAIN           = 0x00000001;

// States of CDomain objects
enum DOMAIN_STATE {
    DS_NONE,                                // seed value for m_State and m_PreviousState
    DS_NOT_ENUMERATING,             // not enumerating (m_pBackgroundThread == NULL)
    DS_INITIAL_ENUMERATION, // enumerating servers for the first time
    DS_ENUMERATING,                 // enumerating
    DS_STOPPED_ENUMERATING, // no longer enumerating
};

class CDomain : public CObject
{
public:
    // constructor
    CDomain(TCHAR *name);
    // destructor
    ~CDomain();

    TCHAR *GetName() { return m_Name; }

    // Returns the state of this domain object
    DOMAIN_STATE GetState() { return m_State; }
    // Sets the state of this domain object
    void SetState(DOMAIN_STATE State);
    // Returns the previous state of this domain object
    DOMAIN_STATE GetPreviousState() { return m_PreviousState; }
    // Returns TRUE if m_State is set to a given state
    BOOLEAN IsState(DOMAIN_STATE State) { return (m_State == State); }
    // Returns TRUE if m_PreviousState is set to a given state
    BOOLEAN IsPreviousState(DOMAIN_STATE State) { return (m_PreviousState == State); }

    // Returns the tree item handle
    HTREEITEM GetTreeItem() { return m_hTreeItem; }
    // Sets the tree item handle
    void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }

    BOOLEAN IsCurrentDomain() { return (m_Flags & DF_CURRENT_DOMAIN) > 0; }
    void SetCurrentDomain() { m_Flags |= DF_CURRENT_DOMAIN; }
    void ClearCurrentDomain() { m_Flags &= ~DF_CURRENT_DOMAIN; }

    BOOL StartEnumerating();
    void StopEnumerating();
    void SetEnumEvent() { if(m_pBackgroundThread) m_WakeUpEvent.SetEvent(); }

    void LockBackgroundThread() { m_ThreadCriticalSection.Lock(); }
    void UnlockBackgroundThread() { m_ThreadCriticalSection.Unlock(); }

    // returns TRUE as long as the background thread should keep running
    BOOL ShouldBackgroundContinue() { return m_BackgroundContinue; }

    void ClearBackgroundContinue() { m_BackgroundContinue = FALSE; }

    // Returns the pointer to the domain's background thread
    CWinThread *GetThreadPointer() { return m_pBackgroundThread; }

    LPWSTR EnumHydraServers( /*LPWSTR pDomain,*/ DWORD verMajor, DWORD verMinor );

    void CreateServers(LPWSTR pBuffer, LPVOID pDoc);

    // Connect to all servers in this Domain
    void ConnectAllServers();

    // Disconnect from all servers in this Domain
    void DisconnectAllServers();

private:

    // the state of the domain object
    DOMAIN_STATE m_State;
    DOMAIN_STATE m_PreviousState;
    
    // the name of the domain
    TCHAR m_Name[50];
    HTREEITEM m_hTreeItem;

    // Background thread to update document when servers
    // appear and disapper
    // Called with AfxBeginThread
    static UINT BackgroundThreadProc(LPVOID);
    CWinThread *m_pBackgroundThread;
    BOOL m_BackgroundContinue;
    
    // Event to wakeup background thread so that
    // he can exit (WaitForSingleEvent instead of Sleep)
    CEvent m_WakeUpEvent;
    
    // Critical section to protect accesses to m_pBackgroundThread
    CCriticalSection m_ThreadCriticalSection;

    ULONG m_Flags;

};


// Flags for CServer objects
const ULONG SF_BACKGROUND_FOUND     = 0x00000001;
const ULONG SF_SERVER_INACTIVE      = 0x00000002;
const ULONG SF_REGISTRY_INFO        = 0x00000004;
const ULONG SF_HANDLE_GOOD          = 0x00000008;
const ULONG SF_SELECTED             = 0x00000010;
const ULONG SF_UNDEFINED_0040       = 0x00000020;
const ULONG SF_UNDEFINED_0080       = 0x00000040;
const ULONG SF_LOST_CONNECTION      = 0x00000080;
const ULONG SF_FOUND_LATER          = 0x00000100;
const ULONG SF_WINFRAME             = 0x00000200;
const ULONG SF_CONNECTED            = 0x00000400;

// How many times we will let a load level query timeout
// before we set it to N/A
const USHORT MAX_LL_TIMEOUTS = 10;

// States of CServer objects
enum SERVER_STATE {
    SS_NONE,                        // seed value for m_State and m_PreviousState
    SS_NOT_CONNECTED,       // not connected yet or disconnected
    SS_OPENED,                      // opened RPC connection
    SS_GETTING_INFO,        // getting information about the server
    SS_GOOD,                        // server information is good
    SS_DISCONNECTING,       // in the process of disconnecting
    SS_BAD                          // could not open the server
};


class CServer : public CObject
{
public:

    // constructor
    CServer(CDomain *pDomain, TCHAR *name, BOOL bFoundLater, BOOL bConnect);        // FoundLater is TRUE if found as new server after initial server enum
    // destructor
    ~CServer();

    // Functions to check,set,and clear m_ServerFlags
    BOOLEAN IsServerSane() { return (m_State != SS_BAD); }

    BOOLEAN IsManualFind( ) { return m_fManualFind; }
    void SetManualFind( ) { m_fManualFind = TRUE; }
    void ClearManualFind( ) { m_fManualFind = FALSE; }

    BOOLEAN IsBackgroundFound() { return (m_ServerFlags & SF_BACKGROUND_FOUND) > 0; }
    void SetBackgroundFound() { m_ServerFlags |= SF_BACKGROUND_FOUND; }
    void ClearBackgroundFound() { m_ServerFlags &= ~SF_BACKGROUND_FOUND; }

    BOOLEAN IsServerInactive() { return (m_ServerFlags & SF_SERVER_INACTIVE) > 0; }
    void SetServerInactive() { m_ServerFlags |= SF_SERVER_INACTIVE;  m_BackgroundContinue = FALSE; }
    void ClearServerInactive() { m_ServerFlags &= ~SF_SERVER_INACTIVE; }
    BOOLEAN IsServerActive() { return (m_ServerFlags & SF_SERVER_INACTIVE) == 0; }

    BOOLEAN IsRegistryInfoValid() { return (m_ServerFlags & SF_REGISTRY_INFO) > 0; }
    void SetRegistryInfoValid() { m_ServerFlags |= SF_REGISTRY_INFO; }
    void ClearRegistryInfoValid() { m_ServerFlags &= ~SF_REGISTRY_INFO; }

    BOOLEAN IsHandleGood() { return (m_ServerFlags & SF_HANDLE_GOOD) > 0; }
    void SetHandleGood() { m_ServerFlags |= SF_HANDLE_GOOD; }
    void ClearHandleGood() { m_ServerFlags &= ~SF_HANDLE_GOOD; }

    BOOLEAN IsSelected() { return (m_ServerFlags & SF_SELECTED) > 0; }
    void SetSelected() { m_ServerFlags |= SF_SELECTED; }
    void ClearSelected() { m_ServerFlags &= ~SF_SELECTED; }

    BOOLEAN HasLostConnection() { return (m_ServerFlags & SF_LOST_CONNECTION) > 0; }
    void SetLostConnection() { m_ServerFlags |= SF_LOST_CONNECTION; }
    void ClearLostConnection() { m_ServerFlags &= ~SF_LOST_CONNECTION; }

    BOOLEAN WasFoundLater() { return (m_ServerFlags & SF_FOUND_LATER) > 0; }
    void SetFoundLater() { m_ServerFlags |= SF_FOUND_LATER; }
    void ClearFoundLater() { m_ServerFlags &= ~SF_FOUND_LATER; }

    BOOLEAN IsWinFrame() { return (m_ServerFlags & SF_WINFRAME) > 0; }
    void SetWinFrame() { m_ServerFlags |= SF_WINFRAME; }
    void ClearWinFrame() { m_ServerFlags &= ~SF_WINFRAME; }

    // Returns the state of this server object
    SERVER_STATE GetState() { return m_State; }
    // Sets the state of this server object
    void SetState(SERVER_STATE State);
    // Returns the previous state of this server object
    SERVER_STATE GetPreviousState() { return m_PreviousState; }
    // Returns TRUE if m_State is set to a given state
    BOOLEAN IsState(SERVER_STATE State) { return (m_State == State); }
    // Returns TRUE if m_PreviousState is set to a given state
    BOOLEAN IsPreviousState(SERVER_STATE State) { return (m_PreviousState == State); }
    // Add a WinStation to WinStationList in sorted order
    void AddWinStation(CWinStation *pWinStation);
    // Returns a pointer to the WinStation linked list
    CObList *GetWinStationList() { return &m_WinStationList; }
    // Locks the WinStation linked list
    void LockWinStationList() { m_WinStationListCriticalSection.Lock(); }
    // Unlocks the WinStation linked list
    void UnlockWinStationList() { m_WinStationListCriticalSection.Unlock(); }

    void LockThreadAlive() { m_ThreadCriticalSection.Lock(); }
    void UnlockThreadAlive() { m_ThreadCriticalSection.Unlock(); }
    void SetThreadAlive() { LockThreadAlive(); m_bThreadAlive = TRUE; UnlockThreadAlive(); }
    void ClearThreadAlive() { LockThreadAlive(); m_bThreadAlive = FALSE; UnlockThreadAlive(); }

    // Returns a pointer to the Process linked list
    CObList *GetProcessList() { return &m_ProcessList; }
    // Locks the Process linked list
    void LockProcessList() { m_ProcessListCriticalSection.Lock(); }
    // Unlocks the Process linked list
    void UnlockProcessList() { m_ProcessListCriticalSection.Unlock(); }

    // Returns a pointer to the License linked list
    CObList *GetLicenseList() { return &m_LicenseList; }
    // Locks the License linked list
    void LockLicenseList() { m_LicenseListCriticalSection.Lock(); }
    // Unlocks the License linked list
    void UnlockLicenseList() { m_LicenseListCriticalSection.Unlock(); }

    // Returns a pointer to the User Sid linked list
    CObList *GetUserSidList() { return &m_UserSidList; }
    // Returns a pointer to the Hotfix linked list
    CObList *GetHotfixList() { return &m_HotfixList; }
    // Get the server's handle
    HANDLE GetHandle() { return m_Handle; }
    // Set the handle
    void SetHandle(HANDLE hIn) { m_Handle = hIn; }
    // Go get detailed information about the server
    void DoDetail();
    // Get this server's addresses from the browser
    void QueryAddresses();
    // Enumerate this server's processes
    BOOL EnumerateProcesses();
    // Clear out the list of processes
    void ClearProcesses();
    // Get the name of the server
    TCHAR *GetName() { return m_Name; }
    // Returns TRUE if this is the server that the app is being run from
    BOOL IsCurrentServer() { return (lstrcmpi(m_Name, ((CWinAdminApp*)AfxGetApp())->GetCurrentServerName()) == 0); }
    // Clears the WAF_SELECTED bit in all of this server's lists
    void ClearAllSelected();
    // returns TRUE as long as the background thread should keep running
    BOOL ShouldBackgroundContinue() { return m_BackgroundContinue; }
    // turns off the background continue boolean
    void ClearBackgroundContinue() { m_BackgroundContinue = FALSE; }
    // returns a pointer to a CWinStation from m_WinStationList
    CWinStation *FindWinStationById(ULONG Id);
    // returns a pointer to a CProcess from m_ProcessList given a PID
    CProcess *FindProcessByPID(ULONG Pid);
    // returns the number of connected WinStations
    ULONG GetNumWinStations() { return m_NumWinStations; }
    // Sets the number of connected WinStations
    void SetNumWinStations(ULONG num) { m_NumWinStations = num; }
    // Go out and fill in the registry info structure
    BOOL BuildRegistryInfo();
    // Returns the Install Date
    ULONG GetInstallDate() { return m_pRegistryInfo->InstallDate; }
    // Returns the Service Pack Level
    TCHAR *GetServicePackLevel() { return m_pRegistryInfo->ServicePackLevel; }
    // Returns the handle to this server's tree item
    TCHAR *GetMSVersion() { return m_pRegistryInfo->MSVersion; }
    // Returns the MS product version number (binary)
    DWORD GetMSVersionNum() { return m_pRegistryInfo->MSVersionNum; }
    // Returns the MS product build
    TCHAR *GetMSBuild() { return m_pRegistryInfo->MSBuild; }
    // Returns the MS product name
    TCHAR *GetMSProductName() { return m_pRegistryInfo->MSProductName; }
    // Returns the 'Citrix' product name
    TCHAR *GetCTXProductName() { return m_pRegistryInfo->CTXProductName; }
    // Returns the 'Citrix' product version
    TCHAR *GetCTXVersion() { return m_pRegistryInfo->CTXVersion; }
    // Returns the 'Citrix' product version number (binary)
    DWORD GetCTXVersionNum() { return m_pRegistryInfo->CTXVersionNum; }
    // Returns the 'Citrix' product build
    TCHAR *GetCTXBuild() { return m_pRegistryInfo->CTXBuild; }
   
    // Sets the pointer to the info from the extension DLL
    void SetExtensionInfo(void *p) { m_pExtensionInfo = p; }
    // Returns the pointer to the info from the extension DLL
    void *GetExtensionInfo() { return m_pExtensionInfo; }
    // Returns a pointer to the info from the extension DLL
    ExtServerInfo *GetExtendedInfo() { return m_pExtServerInfo; }

    // Manipulate the number selected counts
    UINT GetNumWinStationsSelected() { return m_NumWinStationsSelected; }
    UINT GetNumProcessesSelected() { return m_NumProcessesSelected; }
    void IncrementNumWinStationsSelected() { m_NumWinStationsSelected++; }
    void IncrementNumProcessesSelected() { m_NumProcessesSelected++; }
    void DecrementNumWinStationsSelected() { if(m_NumWinStationsSelected) m_NumWinStationsSelected--; }
    void DecrementNumProcessesSelected() { if(m_NumProcessesSelected) m_NumProcessesSelected--; }

    void RemoveWinStationProcesses(CWinStation *pWinStation); // remove all the processes for a given WinStation
    void QueryLicenses();
    CDomain *GetDomain() { return m_pDomain; }
    // Returns the pointer to the server's background thread
    HANDLE GetThreadHandle() { return m_hBackgroundThread; }
    BOOL Connect();
    void Disconnect();
    
    // Returns the tree item handle
    HTREEITEM GetTreeItem() { return m_hTreeItem; }
    HTREEITEM GetTreeItemFromFav( ) { return m_hFavTree; }
    HTREEITEM GetTreeItemFromThisComputer( ) { return m_hThisServer; }

    // Sets the tree item handle
    void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
    void SetTreeItemForFav( HTREEITEM handle ) { m_hFavTree = handle; }
    void SetTreeItemForThisComputer( HTREEITEM handle ) { m_hThisServer = handle; }


private:
    void AddLicense(CLicense *pNewLicense);

    // the state of the server object
    SERVER_STATE m_State;
    SERVER_STATE m_PreviousState;
    // the name of the server
    TCHAR m_Name[50];
    // Number of WinStations (store here for sorting)
    ULONG m_NumWinStations;
    // Handle to the tree item for this server in the tree view
    HTREEITEM m_hThisServer;
    HTREEITEM m_hTreeItem;
    HTREEITEM m_hFavTree;
    // Which domain this server is in
    CDomain *m_pDomain;

    // handle from WinStationOpenServer
    HANDLE m_Handle;

    CObList m_WinStationList;
    CCriticalSection m_WinStationListCriticalSection;

    CObList m_ProcessList;
    CCriticalSection m_ProcessListCriticalSection;

    CObList m_LicenseList;
    CCriticalSection m_LicenseListCriticalSection;

    CObList m_UserSidList;
    CObList m_HotfixList;

    // Pointer to registry info structure
    ServerRegistryInfo *m_pRegistryInfo;

    // Background thread to update document when WinStations
    // appear, disappear, and change state
    // Called with CreateThread
    static DWORD WINAPI BackgroundThreadProc(LPVOID);
    HANDLE m_hBackgroundThread;
    BOOL m_BackgroundContinue;
    // We need a critical section to wrap accesses to m_bThreadAlive
    CCriticalSection m_ThreadCriticalSection;
    BOOL m_bThreadAlive;

    // Keep track of how many of each thing are selected
    UINT m_NumWinStationsSelected;
    UINT m_NumProcessesSelected;

    ULONG m_ServerFlags;

    BOOLEAN m_fManualFind;

    // Pointer to information stored by the extension DLL
    void *m_pExtensionInfo;
    // Pointer to extended info from the extension DLL
    ExtServerInfo *m_pExtServerInfo;
};


class CLicense : public CObject
{
public:
    // constructor
    CLicense(CServer *pServer, ExtLicenseInfo *pLicenseInfo);
    // Return the serial number (what we sort on)
    TCHAR *GetSerialNumber() { return m_RegSerialNumber; }
    // Return the license number (what we display)
    TCHAR *GetLicenseNumber() { return m_LicenseNumber; }
    // Return the license class
    LICENSECLASS GetClass() { return m_Class; }
    // Return the description
    TCHAR *GetDescription() { return m_Description; }
    // Return the local count
    ULONG GetLocalCount() { return ((m_PoolCount == 0xFFFFFFFF) ? m_LicenseCount : m_LicenseCount - m_PoolCount); }
    // Return the pooled count
    ULONG GetPoolCount() { return ((m_PoolCount == 0xFFFFFFFF) ? 0 : m_PoolCount); }
    // Return the total count
    ULONG GetTotalCount() { return m_LicenseCount; }
    // Return TRUE if this license is registers
    BOOLEAN IsRegistered() { return((m_Flags & ELF_REGISTERED) > 0); }
    // Return TRUE if pooling is enabled
    BOOLEAN IsPoolingEnabled() { return(m_PoolCount != 0xFFFFFFFF); }
    // Returns a pointer to the server this license is for
    CServer *GetServer() { return m_pServer; }

private:
    LICENSECLASS m_Class;
    ULONG m_LicenseCount;
    ULONG m_PoolLicenseCount;
    WCHAR m_RegSerialNumber[26];
    WCHAR m_LicenseNumber[36];
    WCHAR m_Description[65];
    ULONG m_Flags;
    ULONG m_PoolCount;
    CServer *m_pServer;
    };


typedef struct _MessageParms {
        TCHAR MessageTitle[MSG_TITLE_LENGTH + 1];
        TCHAR MessageBody[MSG_MESSAGE_LENGTH + 1];
        CWinStation* pWinStation;
        BOOL bActionOnCurrentSelection;
} MessageParms;


typedef struct _ResetParms {
        CWinStation *pWinStation;
        BOOL bReset;    // TRUE if reset, FALSE if logoff
        BOOL bActionOnCurrentSelection;
} ResetParms;

typedef struct _DisconnectParms {
        HANDLE hServer;
        ULONG  ulLogonId;
        BOOL   bActionOnCurrentSelection;
} DisconnectParms;


// Flags for CWinStation objects
const ULONG WF_SELECTED                 = 0x00000001;
const ULONG WF_CAN_BE_SHADOWED          = 0x00000002;
const ULONG WF_DIRECT_ASYNC             = 0x00000004;
const ULONG WF_CURRENT                  = 0x00000008;
const ULONG WF_HAS_USER                 = 0x00000010;
const ULONG WF_ADDITIONAL_DONE          = 0x00000020;
const ULONG WF_QUERIES_SUCCESSFUL       = 0x00000040;
const ULONG WF_CHANGED                  = 0x00000080;   // Changed during last enumeration
const ULONG WF_NEW                      = 0x00000100;   // New this enumeration


class CWinStation : public CObject
{
public:
    // constructor
    CWinStation(CServer *pServer, PLOGONID pLogonId);
    // destructor
    ~CWinStation();
    // Updates this WinStation with new data from another CWinStation
    BOOL Update(CWinStation *pWinStation);
    // Returns a pointer to this guy's server
    CServer *GetServer() { return m_pServer; }
    // Returns the logon Id
    ULONG GetLogonId() { return m_LogonId; }
    // Returns the name of the WinStation
    PWINSTATIONNAME GetName() { return m_Name; }
    // Sets the name
    void SetName(PWINSTATIONNAME name) { wcscpy(m_Name, name); }
    // Returns the state
    WINSTATIONSTATECLASS GetState() { return m_State; }
    // Sets the state
    void SetState(WINSTATIONSTATECLASS state) { m_State = state; }
    // Returns TRUE if m_State is set to a given state
    BOOLEAN IsState(WINSTATIONSTATECLASS state) { return (m_State == state); }    
    // Returns the sort order
    ULONG GetSortOrder() { return m_SortOrder; }
    // Sets the sort order
    void SetSortOrder(ULONG sort) { m_SortOrder = sort; }
    // Returns the comment
    TCHAR *GetComment() { return m_Comment; }
    // Sets the comment
    void SetComment(TCHAR *comment) { wcscpy(m_Comment, comment); }
    // Returns the user name
    TCHAR *GetUserName() { return m_UserName; }
    // Sets the user name
    void SetUserName(TCHAR *name) { wcscpy(m_UserName, name); }
    // Returns the SdClass
    SDCLASS GetSdClass() { return m_SdClass; }
    // Sets the SdClass
    void SetSdClass(SDCLASS pd) { m_SdClass = pd; }
    // Returns the Logon Time
    LARGE_INTEGER GetLogonTime() { return m_LogonTime; }
    // Sets the Logon Time
    void SetLogonTime(LARGE_INTEGER t) { m_LogonTime = t; }
    // Returns the Last Input Time
    LARGE_INTEGER GetLastInputTime() { return m_LastInputTime; }
    // Sets the Last Input Time
    void SetLastInputTime(LARGE_INTEGER t) { m_LastInputTime = t; }
    // Returns the Current Time
    LARGE_INTEGER GetCurrentTime() { return m_CurrentTime; }
    // Set the Current Time
    void SetCurrentTime(LARGE_INTEGER t) { m_CurrentTime = t; }
    // Returns the IdleTime
    ELAPSEDTIME GetIdleTime() { return m_IdleTime; }
    // Sets the IdleTime variable
    void SetIdleTime(ELAPSEDTIME it) { m_IdleTime = it; }
    // Returns the WdName
    PWDNAME GetWdName() { return m_WdName; }
    // Sets the WdName
    void SetWdName(PWDNAME wdname) { wcscpy(m_WdName, wdname); }
    // Returns the Wd Structure
    CWd *GetWd() { return m_pWd; }
    // Sets the Wd Structure
    void SetWd(CWd *pwd) { m_pWd = pwd; }
    // Returns the PdName
    PPDNAME GetPdName() { return m_PdName; }
    // Returns the Client Name
    TCHAR *GetClientName() { return m_ClientName; }
    // Sets the Client Name
    void SetClientName(TCHAR *name) { wcscpy(m_ClientName, name); }
    //returns the client digital product id
            TCHAR* GetClientDigProductId() { return m_clientDigProductId; }
    //sets the client digital product id
    void SetClientDigProductId( TCHAR* prodid) { wcscpy(m_clientDigProductId, prodid); }
    // Returns the Client Build Number
    ULONG GetClientBuildNumber() { return m_ClientBuildNumber; }
    // Returns the Client Directory
    TCHAR *GetClientDir() { return m_ClientDir; }
    // Returns the Modem Name
    TCHAR *GetModemName() { return m_ModemName; }
    // Returns the Client License
    TCHAR *GetClientLicense() { return m_ClientLicense; }
    // Returns the Client Product Id
    USHORT GetClientProductId() { return m_ClientProductId; }
    // Returns the Client Serial Number
    ULONG GetClientSerialNumber() { return m_ClientSerialNumber; }
    // Returns the Client Address
    TCHAR *GetClientAddress() { return m_ClientAddress; }
    // Returns the number of host buffers
    USHORT GetHostBuffers() { return m_HostBuffers; }
    // Returns the number of client buffers
    USHORT GetClientBuffers() { return m_ClientBuffers; }
    // Returns the buffer length
    USHORT GetBufferLength() { return m_BufferLength; }
    // Gets additional information about the WinStation
    void QueryAdditionalInformation();
    // Shadow this WinStation
    void Shadow();
    // connect to this WinStation
    void Connect(BOOL bUser);
    // show status dialog
    void ShowStatus();
    // Are there outstanding threads?
    BOOL HasOutstandingThreads() { return(m_OutstandingThreads > 0); }
    // Is this WinStation down?
    BOOL IsDown() { return(m_State == State_Down || m_State == State_Init); }
    // Is this WinStation connected?
    BOOL IsConnected() { return(m_State == State_Connected || m_State == State_Active); }
    // Is this WinStation disconnected?
    BOOL IsDisconnected() { return(m_State == State_Disconnected); }
    // Is this WinStation active?
    BOOL IsActive() { return(m_State == State_Active); }
    // Is this WinStation idle?
    BOOL IsIdle() { return(m_State == State_Idle); }
    // Is this WinStation a listener?
    BOOL IsListener() { return(m_State == State_Listen); }
    // Is this the system console
    BOOL IsSystemConsole() { return(0 == lstrcmpi(m_Name, ((CWinAdminApp*)AfxGetApp())->m_szSystemConsole)); }
    // Returns TRUE if this WinStation is on the current server
    BOOL IsOnCurrentServer() { return m_pServer->IsCurrentServer(); }
    // Returns TRUE if the current user is logged in on this WinStation
    BOOL IsCurrentUser() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }
    //BOOL IsCurrentUser() { return(m_pServer->IsCurrentServer() && (lstrcmpi(m_UserName, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName()) == 0)); }
    // Returns TRUE if this is the current WinStation
    BOOL IsCurrentWinStation() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }
    // Returns the handle to this WinStations's tree item
    HTREEITEM GetTreeItem() { return m_hTreeItem; }
    HTREEITEM GetTreeItemFromFav( ) { return m_hFavTree; }
    HTREEITEM GetTreeItemFromThisComputer( ) { return m_hTreeThisComputer; }
    // Sets the tree item handle
    void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
    void SetTreeItemForFav( HTREEITEM handle ) { m_hFavTree = handle; }
    void SetTreeItemForThisComputer( HTREEITEM handle ) { m_hTreeThisComputer = handle; }
    // Returns the number of colors
    TCHAR *GetColors() { return m_Colors; }
    // Returns the vertical resolution
    USHORT GetVRes() { return m_VRes; }
    // Returns the horizontal resolution
    USHORT GetHRes() { return m_HRes; }
    // Returns the protocol
    USHORT GetProtocolType() { return m_ProtocolType; }
    // Returns the encryption level
    BYTE GetEncryptionLevel() { return m_EncryptionLevel; }
    // Sets the encryption level
    void SetEncryptionLevel(BYTE level) { m_EncryptionLevel = level; }

    // Fills in the CString with the description of the Encryption level
    BOOL GetEncryptionLevelString(CString *pString) {
        if(m_pWd) {
            return m_pWd->GetEncryptionLevelString(m_EncryptionLevel, pString);
        }
        else return FALSE;
    }

    // Returns the name of the Wd in the registry
    TCHAR *GetWdRegistryName() { return (m_pWd) ? m_pWd->GetRegistryName() : NULL; }

    // Returns the time of the last update to this WinStation's data
    clock_t GetLastUpdateClock() { return m_LastUpdateClock; }
    void SetLastUpdateClock() { m_LastUpdateClock = clock(); }

    // Is this an ICA WinStation?
    BOOL IsICA() { return(m_ProtocolType == PROTOCOL_ICA); }

    // Can this WinStation be shadowed
    BOOL CanBeShadowed() { return((m_WinStationFlags & WF_CAN_BE_SHADOWED) > 0); }
    void SetCanBeShadowed() { m_WinStationFlags |= WF_CAN_BE_SHADOWED; }
    void ClearCanBeShadowed() { m_WinStationFlags &= ~WF_CAN_BE_SHADOWED; }

    BOOLEAN IsDirectAsync() { return (m_WinStationFlags & WF_DIRECT_ASYNC) > 0; }
    void SetDirectAsync() { m_WinStationFlags |= WF_DIRECT_ASYNC; }
    void ClearDirectAsync() { m_WinStationFlags &= ~WF_DIRECT_ASYNC; }

    BOOLEAN IsCurrent() { return (m_WinStationFlags & WF_CURRENT) > 0; }
    void SetCurrent() { m_WinStationFlags |= WF_CURRENT; }
    void ClearCurrent() { m_WinStationFlags &= ~WF_CURRENT; }

    BOOLEAN IsChanged() { return (m_WinStationFlags & WF_CHANGED) > 0; }
    void SetChanged() { m_WinStationFlags |= WF_CHANGED; }
    void ClearChanged() { m_WinStationFlags &= ~WF_CHANGED; }

    BOOLEAN IsNew() { return (m_WinStationFlags & WF_NEW) > 0; }
    void SetNew() { m_WinStationFlags |= WF_NEW; }
    void ClearNew() { m_WinStationFlags &= ~WF_NEW; }

    BOOLEAN IsSelected() { return (m_WinStationFlags & WF_SELECTED) > 0; }
    void SetSelected() 
    { 
        if (!IsSelected()) 
        { 
            m_WinStationFlags |= WF_SELECTED; 
            m_pServer->IncrementNumWinStationsSelected(); 
        } 
    }
    
    void ClearSelected() 
    { 
        if (IsSelected()) 
        {
            m_WinStationFlags &= ~WF_SELECTED; 
            m_pServer->DecrementNumWinStationsSelected(); 
        }
    }

    BOOLEAN HasUser() { return (m_WinStationFlags & WF_HAS_USER) > 0; }
    void SetHasUser() { m_WinStationFlags |= WF_HAS_USER; }
    void ClearHasUser() { m_WinStationFlags &= ~WF_HAS_USER; }

    BOOLEAN AdditionalDone() { return (m_WinStationFlags & WF_ADDITIONAL_DONE) > 0; }
    void SetAdditionalDone() { m_WinStationFlags |= WF_ADDITIONAL_DONE; }
    void ClearAdditionalDone() { m_WinStationFlags &= ~WF_ADDITIONAL_DONE; }

    BOOL QueriesSuccessful() { return (m_WinStationFlags & WF_QUERIES_SUCCESSFUL) > 0; }
    void SetQueriesSuccessful() { m_WinStationFlags |= WF_QUERIES_SUCCESSFUL; }
    void ClearQueriesSuccessful() { m_WinStationFlags &= ~WF_QUERIES_SUCCESSFUL; }

    // Sets the pointer to the info from the extension DLL
    void SetExtensionInfo(void *p) { m_pExtensionInfo = p; }
    // Returns the pointer to the info from the extension DLL
    void *GetExtensionInfo() { return m_pExtensionInfo; }
    // Sets the pointer to the info from the extension DLL
    void SetExtendedInfo(ExtWinStationInfo *p) { m_pExtWinStationInfo = p; }
    // Returns a pointer to the info from the extension DLL
    ExtWinStationInfo *GetExtendedInfo() { return m_pExtWinStationInfo; }
    // Returns a pointer to the module info from the extension DLL
    ExtModuleInfo *GetExtModuleInfo() { return m_pExtModuleInfo; }
    // Sets the pointer to the module info from the extension DLL
    void SetExtModuleInfo(ExtModuleInfo *m) { m_pExtModuleInfo = m; }
    // Returns the number of modules
    ULONG GetNumModules() { return m_NumModules; }

    void BeginOutstandingThread() {
        ::InterlockedIncrement(&m_OutstandingThreads);
        //((CWinAdminApp*)AfxGetApp())->BeginOutStandingThread());
    }

    void EndOutstandingThread()     {
        ::InterlockedDecrement(&m_OutstandingThreads);
        //((CWinAdminApp*)AfxGetApp())->EndOutStandingThread());
    }

    // static member function to send a message to a WinStation
    // Called with AfxBeginThread
    static UINT SendMessage(LPVOID);
    // static member function to disconnect a WinStation
    // Called with AfxBeginThread
    static UINT Disconnect(LPVOID);
    // static member function to reset a WinStation
    // Called with AfxBeginThread
    static UINT Reset(LPVOID);

private:
    CServer* m_pServer;
    CWd* m_pWd;
    ULONG m_LogonId;
    WINSTATIONNAME m_Name;
    WINSTATIONSTATECLASS m_State;
    ULONG m_SortOrder;
    TCHAR m_Comment[WINSTATIONCOMMENT_LENGTH + 1];
    TCHAR m_UserName[USERNAME_LENGTH + 1];
    SDCLASS m_SdClass;
    LARGE_INTEGER m_LogonTime;
    LARGE_INTEGER m_LastInputTime;
    LARGE_INTEGER m_CurrentTime;
    ELAPSEDTIME m_IdleTime;
    WDNAME m_WdName;
    PDNAME m_PdName;
    TCHAR m_ClientName[CLIENTNAME_LENGTH + 1];
    ULONG m_ClientBuildNumber;
    TCHAR m_ClientDir[DIRECTORY_LENGTH + 1];
    TCHAR m_ModemName[256];
    TCHAR m_ClientLicense[CLIENTLICENSE_LENGTH + 1];
    USHORT m_ClientProductId;
    ULONG m_ClientSerialNumber;
    TCHAR m_ClientAddress[CLIENTADDRESS_LENGTH + 1];
    USHORT m_HostBuffers;
    USHORT m_ClientBuffers;
    USHORT m_BufferLength;
    LONG m_OutstandingThreads;      // the number of outstanding threads

    HTREEITEM m_hTreeItem;          // tree item for this WinStation in the servers tree view
    HTREEITEM m_hFavTree;
    HTREEITEM m_hTreeThisComputer;
    USHORT m_VRes;                          // Vertical resolution
    USHORT m_HRes;                          // Horizontal resolution
    TCHAR m_Colors[4];                      // Number of colors (as an ASCII string)
    clock_t m_LastUpdateClock;      // Tick count when we last update this WinStation's info
    USHORT m_ProtocolType;      // Protocol - PROTOCOL_ICA or PROTOCOL_RDP
    BYTE m_EncryptionLevel;         // security level of encryption pd

    ULONG m_WinStationFlags;

    // Pointer to information stored by the extension DLL
    void *m_pExtensionInfo;
    ExtWinStationInfo *m_pExtWinStationInfo;
    ExtModuleInfo *m_pExtModuleInfo;
    ULONG m_NumModules;
    TCHAR m_clientDigProductId[CLIENT_PRODUCT_ID_LENGTH];
    };

// Process flags
const ULONG PF_SYSTEM           = 0x00000001;
const ULONG PF_SELECTED         = 0x00000002;
const ULONG PF_TERMINATING      = 0x00000004;   // Currently trying to terminate it
const ULONG PF_CHANGED          = 0x00000008;   // Changed during last enumeration
const ULONG PF_CURRENT          = 0x00000010;   // Still active during last enumeration
const ULONG PF_NEW              = 0x00000020;   // New this enumeration

class CProcess : public CObject
{
public:
    // Constructor
    CProcess(ULONG PID,
            ULONG LogonId,
            CServer *pServer,
            PSID pSID,
            CWinStation *pWinStation,
            TCHAR *ImageName);
    
    // Destructor
    ~CProcess();

    // Updates a process with new information from another process
    BOOL Update(CProcess *pProcess);
    // Returns a pointer to the server that this Process if running on
    CServer *GetServer() { return m_pServer; }
    // Sets the Server
    void SetServer(CServer *pServer) { m_pServer = pServer; }
    // Returns a pointer to the WinStation that owns this process
    CWinStation *GetWinStation() { return m_pWinStation; }
    // Sets the Winstation
    void SetWinStation(CWinStation *pWinStation) { m_pWinStation = pWinStation; }
    // Returns the PID of this process
    ULONG GetPID() { return m_PID; }

    // Returns the LogonId for this process
    ULONG GetLogonId() { return m_LogonId; }
    // Returns a pointer to the image name
    TCHAR *GetImageName() { return m_ImageName; }
    // Returns a pointer to the user name
    TCHAR *GetUserName() { return m_UserName; }
    // Returns TRUE if this process belongs to the current user
    // BOOL IsCurrentUsers() { return (m_pServer->IsCurrentServer()
    //                                                         && wcscmp(m_UserName, ((CWinAdminApp*)AfxGetApp())->GetCurrentUserName())==0); }

    BOOL IsCurrentUsers() { return(m_pServer->IsCurrentServer() && m_LogonId == ((CWinAdminApp*)AfxGetApp())->GetCurrentLogonId()); }


    BOOLEAN IsSystemProcess() { return (m_Flags & PF_SYSTEM) > 0; }
    void SetSystemProcess() { m_Flags |= PF_SYSTEM; }
    void ClearSystemProcess() { m_Flags &= ~PF_SYSTEM; }

    BOOLEAN IsSelected() { return (m_Flags & PF_SELECTED) > 0; }
    void SetSelected() { m_Flags |= PF_SELECTED; m_pServer->IncrementNumProcessesSelected(); }
    void ClearSelected() { m_Flags &= ~PF_SELECTED; m_pServer->DecrementNumProcessesSelected(); }

    BOOLEAN IsTerminating() { return (m_Flags & PF_TERMINATING) > 0; }
    void SetTerminating() { m_Flags |= PF_TERMINATING; }
    void ClearTerminating() { m_Flags &= ~PF_TERMINATING; }

    BOOLEAN IsCurrent() { return (m_Flags & PF_CURRENT) > 0; }
    void SetCurrent() { m_Flags |= PF_CURRENT; }
    void ClearCurrent() { m_Flags &= ~PF_CURRENT; }

    BOOLEAN IsChanged() { return (m_Flags & PF_CHANGED) > 0; }
    void SetChanged() { m_Flags |= PF_CHANGED; }
    void ClearChanged() { m_Flags &= ~PF_CHANGED; }

    BOOLEAN IsNew() { return (m_Flags & PF_NEW) > 0; }
    void SetNew() { m_Flags |= PF_NEW; }
    void ClearNew() { m_Flags &= ~PF_NEW; }

private:
    // Determine whether or not this is a system process
    BOOL QuerySystemProcess();
    // Determine which user owns a process
    void DetermineProcessUser(PSID pSid);

    ULONG m_PID;
    ULONG m_LogonId;
    USHORT m_SidCrc;
    TCHAR * m_ImageName;
    TCHAR m_UserName[USERNAME_LENGTH+1];
    CServer *m_pServer;
    CWinStation *m_pWinStation;
    ULONG m_Flags;
};

class CAdminView : public CView
{
public:
        virtual void Reset(void *) { }
        virtual LRESULT OnTabbed( WPARAM , LPARAM ){ return 0;}
};

//=------------------------------------------------
class CMyTabCtrl : public CTabCtrl
{    
public:
    CMyTabCtrl()
    {
        
    }
protected:
    afx_msg void OnSetFocus( CWnd* );
    DECLARE_MESSAGE_MAP()
};
//=------------------------------------------------

class CAdminPage : public CFormView
{
friend class CServerView;
friend class CWinStationView;
friend class CAllServersView;
friend class CDomainView;

public:
   CAdminPage(UINT nIDTemplate);
   CAdminPage();
   DECLARE_DYNCREATE(CAdminPage)

   virtual void Reset(void *) { }
   virtual void ClearSelections() { }
};


typedef struct _columndefs {
        UINT stringID;
        int format;
   int width;
} ColumnDef;

// Commonly used column definitions
#define CD_SERVER               {       IDS_COL_SERVER,                 LVCFMT_LEFT,    115             }
#define CD_USER                 {       IDS_COL_USER,                   LVCFMT_LEFT,    100     }
#define CD_USER2                {       IDS_COL_USER,                   LVCFMT_LEFT,    80              }
#define CD_USER3                {       IDS_COL_USER,                   LVCFMT_LEFT,    90              }
#define CD_SESSION              {       IDS_COL_WINSTATION,             LVCFMT_LEFT,    80              }
#define CD_SESSION2             {       IDS_COL_WINSTATION,             LVCFMT_LEFT,    100     }
#define CD_ID                   {       IDS_COL_ID,                             LVCFMT_RIGHT,   30              }
#define CD_STATE                {       IDS_COL_STATE,                  LVCFMT_LEFT,    50              }
#define CD_TYPE                 {       IDS_COL_TYPE,                   LVCFMT_LEFT,    80              }
#define CD_CLIENT_NAME  {       IDS_COL_CLIENT_NAME,    LVCFMT_LEFT,    80              }
#define CD_IDLETIME             {       IDS_COL_IDLETIME,               LVCFMT_RIGHT,   80              }
#define CD_LOGONTIME    {       IDS_COL_LOGONTIME,              LVCFMT_LEFT,    90              }
#define CD_COMMENT              {       IDS_COL_COMMENT,                LVCFMT_LEFT,    200             }
// Server Columns
#define CD_TCPADDRESS   {       IDS_COL_TCPADDRESS,             LVCFMT_LEFT,    90              }
#define CD_IPXADDRESS   {       IDS_COL_IPXADDRESS,             LVCFMT_LEFT,    110             }
#define CD_NUM_SESSIONS {       IDS_COL_NUM_WINSTATIONS, LVCFMT_RIGHT,  70              }
// License Columns
#define CD_LICENSE_DESC {       IDS_COL_LICENSE_DESC,   LVCFMT_LEFT,    200             }
#define CD_LICENSE_REG  {       IDS_COL_LICENSE_REGISTERED,             LVCFMT_CENTER,  80      }
#define CD_USERCOUNT    {       IDS_COL_USERCOUNT,      LVCFMT_RIGHT,   80              }
#define CD_POOLCOUNT    {       IDS_COL_POOLCOUNT,      LVCFMT_RIGHT,   80              }
#define CD_LICENSE_NUM  {       IDS_COL_LICENSE_NUMBER, LVCFMT_LEFT,    240             }
// Process Columns
#define CD_PROC_ID      {       IDS_COL_ID,                             LVCFMT_RIGHT,   30              }
#define CD_PROC_PID     {       IDS_COL_PID,                    LVCFMT_RIGHT,   50              }
#define CD_PROC_IMAGE   {       IDS_COL_IMAGE,                  LVCFMT_LEFT,    100             }
// Hotfix Columns
#define CD_HOTFIX               {       IDS_COL_HOTFIX,                 LVCFMT_LEFT,    90              }
#define CD_INSTALLED_BY {       IDS_COL_INSTALLED_BY,   LVCFMT_LEFT,    90              }
#define CD_INSTALLED_ON {       IDS_COL_INSTALLED_ON,   LVCFMT_LEFT,    150             }


// Definitions of PageDef flags
const UINT PF_PICASSO_ONLY = 0x0001;
const UINT PF_NO_TAB = 0x0002;

typedef struct _pagedef {
   CAdminPage *m_pPage;
   CRuntimeClass *m_pRuntimeClass;
   UINT tabStringID;
   int page;
   UINT flags;
} PageDef;
//defines for help

//=================================================================================

#define ID_HELP_FILE L"tsadmin.hlp"

//==================================================================================
#define HIDC_SHADOWSTART_HOTKEY                 0x500F1
#define HIDC_SHADOWSTART_SHIFT                  0x500F2
#define HIDC_SHADOWSTART_CTRL                   0x500F3
#define HIDC_SHADOWSTART_ALT                    0x500F4
#define HIDC_MESSAGE_TITLE                      0x500FB
#define HIDC_MESSAGE_MESSAGE                    0x500FC
#define HIDC_COMMON_USERNAME                    0x5012C
#define HIDC_COMMON_WINSTATIONNAME              0x5012D
#define HIDC_COMMON_IBYTES                      0x5012E
#define HIDC_COMMON_OBYTES                      0x5012F
#define HIDC_COMMON_IFRAMES                     0x50130
#define HIDC_COMMON_OFRAMES                     0x50131
#define HIDC_COMMON_IBYTESPERFRAME              0x50132
#define HIDC_COMMON_OBYTESPERFRAME              0x50133
#define HIDC_COMMON_IFRAMEERRORS                0x50134
#define HIDC_COMMON_OFRAMEERRORS                0x50135
#define HIDC_COMMON_IPERCENTFRAMEERRORS         0x50136
#define HIDC_COMMON_OPERCENTFRAMEERRORS         0x50137
#define HIDC_COMMON_ITIMEOUTERRORS              0x50138
#define HIDC_COMMON_OTIMEOUTERRORS              0x50139
#define HIDC_COMMON_ICOMPRESSIONRATIO           0x5013A
#define HIDC_COMMON_OCOMPRESSIONRATIO           0x5013B
#define HIDC_REFRESHNOW                         0x50140
#define HIDC_RESETCOUNTERS                      0x50141
#define HIDC_MOREINFO                           0x50142
#define HIDC_ASYNC_DEVICE                       0x5015F
#define HIDC_ASYNC_BAUD                         0x50160
#define HIDC_ASYNC_DTR                          0x50161
#define HIDC_ASYNC_RTS                          0x50162
#define HIDC_ASYNC_CTS                          0x50163
#define HIDC_ASYNC_DSR                          0x50164
#define HIDC_ASYNC_DCD                          0x50165
#define HIDC_ASYNC_RI                           0x50166
#define HIDC_ASYNC_IFRAMING                     0x50167
#define HIDC_ASYNC_IOVERRUN                     0x50168
#define HIDC_ASYNC_IOVERFLOW                    0x50169
#define HIDC_ASYNC_IPARITY                      0x5016A
#define HIDC_ASYNC_OFRAMING                     0x5016B
#define HIDC_ASYNC_OOVERRUN                     0x5016C
#define HIDC_ASYNC_OOVERFLOW                    0x5016D
#define HIDC_ASYNC_OPARITY                      0x5016E
#define HIDC_NETWORK_LANADAPTER                 0x50173
#define HIDC_PREFERENCES_PROC_MANUAL            0x503EF
#define HIDC_PREFERENCES_PROC_EVERY             0x503F0
#define HIDC_PREFERENCES_PROC_SECONDS           0x503F1
#define HIDC_PREFERENCES_STATUS_MANUAL          0x503F3
#define HIDC_PREFERENCES_STATUS_EVERY           0x503F4
#define HIDC_PREFERENCES_STATUS_SECONDS         0x503F5
#define HIDC_PREFERENCES_CONFIRM                0x503F7
#define HIDC_PREFERENCES_SAVE                   0x503F8
#define HIDC_PREFERENCES_REMEMBER                       0X50443

#define HIDD_SERVER_WINSTATIONS                 0x20084
#define HIDD_SERVER_PROCESSES                   0x20085
#define HIDD_SERVER_USERS                       0x20086
#define HIDD_SERVER_LICENSES                    0x20087
#define HIDD_WINSTATION_INFO                    0x20099
#define HIDD_WINSTATION_PROCESSES               0x2009A
#define HIDD_PREFERENCES                        0x2009C
#define HIDD_SERVER_INFO                        0x2009D
#define HIDD_MESSAGE                            0x200FA
#define HIDD_ASYNC_STATUS                       0x2015E
#define HIDD_NETWORK_STATUS                     0x20172
#define HIDD_CONNECT_PASSWORD                   0x201B8
#define HIDD_ALL_SERVER_PROCESSES               0x201BA
#define HIDD_ALL_SERVER_USERS                   0x201BB
#define HIDD_ALL_SERVER_SESSIONS                0x201BC
#define HIDD_BAD_SERVER                         0x201BE
#define HIDD_LISTENER                           0x201BF
#define HIDD_WINSTATION_NOINFO                  0x201C0
#define HIDD_BUSY_SERVER                        0x201C1
#define HIDD_WINSTATION_CACHE                   0x201C2
#define HIDD_BAD_WINSTATION                     0x201C3

//==========================================================================================




//Global variable for help

static const DWORD aMenuHelpIDs[] =
{
    IDC_MESSAGE_TITLE, HIDC_MESSAGE_TITLE,
    IDC_MESSAGE_MESSAGE,HIDC_MESSAGE_MESSAGE,
    IDC_SHADOWSTART_HOTKEY,HIDC_SHADOWSTART_HOTKEY,
    IDC_SHADOWSTART_SHIFT ,HIDC_SHADOWSTART_SHIFT,
    IDC_SHADOWSTART_CTRL ,HIDC_SHADOWSTART_CTRL,
    IDC_SHADOWSTART_ALT ,HIDC_SHADOWSTART_ALT,
    IDC_COMMON_USERNAME ,HIDC_COMMON_USERNAME,
    IDC_COMMON_WINSTATIONNAME  ,HIDC_COMMON_WINSTATIONNAME,
    IDC_COMMON_IBYTES,HIDC_COMMON_IBYTES,
    IDC_COMMON_OBYTES  ,HIDC_COMMON_OBYTES,
    IDC_COMMON_IFRAMES ,HIDC_COMMON_IFRAMES,
    IDC_COMMON_OFRAMES ,HIDC_COMMON_OFRAMES,
    IDC_COMMON_IBYTESPERFRAME ,HIDC_COMMON_IBYTESPERFRAME,
    IDC_COMMON_OBYTESPERFRAME ,HIDC_COMMON_OBYTESPERFRAME,
    IDC_COMMON_IFRAMEERRORS  ,HIDC_COMMON_IFRAMEERRORS,
    IDC_COMMON_OFRAMEERRORS ,HIDC_COMMON_OFRAMEERRORS,
    IDC_COMMON_IPERCENTFRAMEERRORS ,HIDC_COMMON_IPERCENTFRAMEERRORS,
    IDC_COMMON_OPERCENTFRAMEERRORS ,HIDC_COMMON_OPERCENTFRAMEERRORS,
    IDC_COMMON_ITIMEOUTERRORS ,HIDC_COMMON_ITIMEOUTERRORS,
    IDC_COMMON_OTIMEOUTERRORS,HIDC_COMMON_OTIMEOUTERRORS,
    IDC_COMMON_ICOMPRESSIONRATIO ,HIDC_COMMON_ICOMPRESSIONRATIO,
    IDC_COMMON_OCOMPRESSIONRATIO ,HIDC_COMMON_OCOMPRESSIONRATIO,
    IDC_REFRESHNOW ,HIDC_REFRESHNOW,
    IDC_RESETCOUNTERS,HIDC_RESETCOUNTERS,
    IDC_MOREINFO,HIDC_MOREINFO,
    IDC_ASYNC_DEVICE,  HIDC_ASYNC_DEVICE ,
    IDC_ASYNC_BAUD  ,HIDC_ASYNC_BAUD  ,
    IDC_ASYNC_DTR ,  HIDC_ASYNC_DTR ,
    IDC_ASYNC_RTS  , HIDC_ASYNC_RTS  ,
    IDC_ASYNC_CTS  ,  HIDC_ASYNC_CTS  ,
    IDC_ASYNC_DSR ,  HIDC_ASYNC_DSR    ,
    IDC_ASYNC_DCD  , HIDC_ASYNC_DCD     ,
    IDC_ASYNC_RI  ,  HIDC_ASYNC_RI       ,
    IDC_ASYNC_IFRAMING ,  HIDC_ASYNC_IFRAMING  ,
    IDC_ASYNC_IOVERRUN , HIDC_ASYNC_IOVERRUN    ,
    IDC_ASYNC_IOVERFLOW ,    HIDC_ASYNC_IOVERFLOW,
    IDC_ASYNC_IPARITY  , HIDC_ASYNC_IPARITY       ,
    IDC_ASYNC_OFRAMING ,   HIDC_ASYNC_OFRAMING     ,
    IDC_ASYNC_OOVERRUN ,   HIDC_ASYNC_OOVERRUN      ,
    IDC_ASYNC_OOVERFLOW ,  HIDC_ASYNC_OOVERFLOW      ,
    IDC_ASYNC_OPARITY    ,  HIDC_ASYNC_OPARITY        ,
    IDC_NETWORK_LANADAPTER,     HIDC_NETWORK_LANADAPTER,
    IDC_PREFERENCES_PROC_MANUAL ,HIDC_PREFERENCES_PROC_MANUAL ,
    IDC_PREFERENCES_PROC_EVERY   , HIDC_PREFERENCES_PROC_EVERY ,
    IDC_PREFERENCES_PROC_SECONDS  , HIDC_PREFERENCES_PROC_SECONDS,
    IDC_PREFERENCES_STATUS_MANUAL  ,  HIDC_PREFERENCES_STATUS_MANUAL,
    IDC_PREFERENCES_STATUS_EVERY    , HIDC_PREFERENCES_STATUS_EVERY,
    IDC_PREFERENCES_STATUS_SECONDS   ,  HIDC_PREFERENCES_STATUS_SECONDS ,
    IDC_PREFERENCES_STATUS_SECONDS    ,HIDC_PREFERENCES_STATUS_SECONDS   ,
    IDC_PREFERENCES_CONFIRM     ,HIDC_PREFERENCES_CONFIRM           ,
    IDD_WINSTATION_NOINFO,HIDD_WINSTATION_NOINFO,
    IDC_PREFERENCES_SAVE , HIDC_PREFERENCES_SAVE,
    IDC_PREFERENCES_PERSISTENT ,HIDC_PREFERENCES_REMEMBER,
};

/////////////////////////////////////////////////////////////////////////////
#endif // _WINADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\treeview.cpp ===
/*******************************************************************************
*
* treeview.cpp
*
* implementation of the CAdminTreeView class
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\treeview.cpp  $
*  
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include "admindoc.h"
#include "treeview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern DWORD g_dwTreeViewExpandedStates;

#define DISPLAY_NAME_SIZE   128

/////////////////////////////
// MESSAGE MAP: CAdminTreeView
//
IMPLEMENT_DYNCREATE(CAdminTreeView, CBaseTreeView)

BEGIN_MESSAGE_MAP(CAdminTreeView, CBaseTreeView)
//{{AFX_MSG_MAP(CAdminTreeView)
ON_MESSAGE(WM_ADMIN_ADD_SERVER, OnAdminAddServer)
ON_MESSAGE(WM_ADMIN_REMOVE_SERVER, OnAdminRemoveServer)
ON_MESSAGE(WM_ADMIN_UPDATE_SERVER, OnAdminUpdateServer)
ON_MESSAGE(WM_ADMIN_ADD_WINSTATION, OnAdminAddWinStation)
ON_MESSAGE(WM_ADMIN_UPDATE_WINSTATION, OnAdminUpdateWinStation)
ON_MESSAGE(WM_ADMIN_REMOVE_WINSTATION, OnAdminRemoveWinStation)
ON_MESSAGE(WM_ADMIN_UPDATE_DOMAIN, OnAdminUpdateDomain)
ON_MESSAGE(WM_ADMIN_ADD_DOMAIN, OnAdminAddDomain)
ON_MESSAGE(WM_ADMIN_VIEWS_READY, OnAdminViewsReady)
ON_MESSAGE( WM_ADMIN_ADDSERVERTOFAV , OnAdminAddServerToFavs )
ON_MESSAGE( WM_ADMIN_REMOVESERVERFROMFAV , OnAdminRemoveServerFromFavs )
ON_MESSAGE( WM_ADMIN_GOTO_SERVER , OnAdminGotoServer )
ON_MESSAGE( WM_ADMIN_DELTREE_NODE , OnAdminDelFavServer )
ON_MESSAGE( WM_ADMIN_GET_TV_STATES , OnGetTVStates )
ON_MESSAGE( WM_ADMIN_UPDATE_TVSTATE , OnUpdateTVState )
ON_MESSAGE( IDM_ALLSERVERS_EMPTYFAVORITES , OnEmptyFavorites )
ON_MESSAGE( WM_ISFAVLISTEMPTY , OnIsFavListEmpty )
ON_MESSAGE( WM_ADMIN_CONNECT_TO_SERVER, OnAdminConnectToServer )
ON_MESSAGE( WM_ADMIN_FORCE_SEL_CHANGE, OnAdminForceSelChange )
ON_WM_CONTEXTMENU()

/*
ON_WM_LBUTTONUP( )
ON_WM_MOUSEMOVE( )
ON_WM_TIMER( )
ON_NOTIFY( TVN_BEGINDRAG , AFX_IDW_PANE_FIRST , OnBeginDrag )
*/


ON_NOTIFY( NM_RCLICK , AFX_IDW_PANE_FIRST , OnRClick )

ON_WM_LBUTTONDBLCLK()
ON_COMMAND( ID_ENTER , OnEnterKey )
ON_WM_SETFOCUS( )

//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////
// F'N: CAdminTreeView ctor
//
CAdminTreeView::CAdminTreeView()
{
    m_pimgDragList = NULL;
    m_hDragItem = NULL;
    
}  // end CAdminTreeView ctor


//////////////////////////
// F'N: CAdminTreeView dtor
//
CAdminTreeView::~CAdminTreeView()
{
    
}  // end CAdminTreeView dtor

#ifdef _DEBUG
//////////////////////////////////
// F'N: CAdminTreeView::AssertValid
//
void CAdminTreeView::AssertValid() const
{
    CBaseTreeView::AssertValid();	  
    
}  // end CAdminTreeView::AssertValid


///////////////////////////
// F'N: CAdminTreeView::Dump
//
void CAdminTreeView::Dump(CDumpContext& dc) const
{
    CBaseTreeView::Dump(dc);
    
}  // end CAdminTreeView::Dump
#endif


/////////////////////////////////////
// F'N: CAdminTreeView::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the CTreeCtrl
//
void CAdminTreeView::BuildImageList()
{
    m_ImageList.Create(16, 16, TRUE, 19, 0);
    
    m_idxBlank  = AddIconToImageList(IDI_BLANK);
    m_idxCitrix = AddIconToImageList(IDI_WORLD);
    m_idxServer = AddIconToImageList(IDI_SERVER);
    m_idxConsole = AddIconToImageList(IDI_CONSOLE);
    m_idxNet = AddIconToImageList(IDI_NET);
    m_idxNotSign = AddIconToImageList(IDI_NOTSIGN);
    m_idxQuestion = AddIconToImageList(IDI_QUESTIONMARK);
    m_idxUser = AddIconToImageList(IDI_USER);
    m_idxAsync = AddIconToImageList(IDI_ASYNC);
    m_idxCurrentServer = AddIconToImageList(IDI_CURRENT_SERVER);
    m_idxCurrentNet = AddIconToImageList(IDI_CURRENT_NET);
    m_idxCurrentConsole = AddIconToImageList(IDI_CURRENT_CONSOLE);
    m_idxCurrentAsync = AddIconToImageList(IDI_CURRENT_ASYNC);
    m_idxDirectAsync = AddIconToImageList(IDI_DIRECT_ASYNC);
    m_idxCurrentDirectAsync = AddIconToImageList(IDI_CURRENT_DIRECT_ASYNC);
    m_idxDomain = AddIconToImageList(IDI_DOMAIN);
    m_idxCurrentDomain = AddIconToImageList(IDI_CURRENT_DOMAIN);
    m_idxDomainNotConnected = AddIconToImageList(IDI_DOMAIN_NOT_CONNECTED);
    m_idxServerNotConnected = AddIconToImageList(IDI_SERVER_NOT_CONNECTED);
    
    // Overlay for Servers we can't talk to
    m_ImageList.SetOverlayImage(m_idxNotSign, 1);
    // Overlay for Servers we are currently gathering information about
    m_ImageList.SetOverlayImage(m_idxQuestion, 2);
    
    GetTreeCtrl().SetImageList(&m_ImageList, TVSIL_NORMAL);
    
}  // end CAdminTreeView::BuildImageList


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineWinStationText
//
//	determines the appropriate text to display for
//	a WinStation in the tree
//
void CAdminTreeView::DetermineWinStationText(CWinStation *pWinStation, TCHAR *NameToDisplay)
{
    ASSERT(pWinStation);
    ASSERT(NameToDisplay);
    
    CString NameString;
    const TCHAR *pState = StrConnectState(pWinStation->GetState(), FALSE);
    
    switch(pWinStation->GetState()) {
    case State_Active:			// user logged on to WinStation
    case State_Connected:		// WinStation connected to client
    case State_ConnectQuery:	// in the process of connecting to client
    case State_Shadow:          // shadowing another WinStation
        if(wcslen(pWinStation->GetUserName())) {
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pWinStation->GetUserName());
            lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        }
        else
        {
            if( pWinStation->GetState() == State_ConnectQuery )
            {
                CString ConnQ;
                ConnQ.LoadString( IDS_CONNQ );
                
                lstrcpyn(NameToDisplay , ConnQ, DISPLAY_NAME_SIZE);
            }
            else
            {
                lstrcpyn(NameToDisplay, pWinStation->GetName(), DISPLAY_NAME_SIZE);
            }
        }
        break;
    case State_Disconnected:	// WinStation logged on without client
        if(wcslen(pWinStation->GetUserName())) {
            NameString.Format(TEXT("%s (%s)"), pState, pWinStation->GetUserName());
        }
        else NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
        lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        break;
    case State_Idle:			// waiting for client to connect
        if(pWinStation->GetServer()->GetCTXVersionNum() < 0x200) {
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), pState);
            lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        } else {
            NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
            lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        }
        break;
    case State_Down:			// WinStation is down due to error
        NameString.Format(TEXT("%s (%lu)"), pState, pWinStation->GetLogonId());
        lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        break;
    case State_Listen:			// WinStation is listening for connection
        {
            CString ListenString;
            ListenString.LoadString(IDS_LISTENER);
            NameString.Format(TEXT("%s (%s)"), pWinStation->GetName(), ListenString);
            lstrcpyn(NameToDisplay, NameString, DISPLAY_NAME_SIZE);
        }
        break;
    case State_Reset:			// WinStation is being reset
    case State_Init:			// WinStation in initialization
        lstrcpyn(NameToDisplay, pWinStation->GetName(), DISPLAY_NAME_SIZE);
        break;
    }
    
}  // end CAdminTreeView::DetermineWinStationText


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineWinStationIcon
//
//	determines which icon to display for a WinStation
//	in the tree
//
int CAdminTreeView::DetermineWinStationIcon(CWinStation *pWinStation)
{
    ASSERT(pWinStation);
    
    int WhichIcon = m_idxBlank;
    BOOL CurrentWinStation = pWinStation->IsCurrentWinStation();
    
    if(pWinStation->GetState() != State_Disconnected 
        && pWinStation->GetState() != State_Idle) {
        switch(pWinStation->GetSdClass()) {
        case SdAsync:
            if(pWinStation->IsDirectAsync())
                WhichIcon = CurrentWinStation ? m_idxCurrentDirectAsync : m_idxDirectAsync;
            else
                WhichIcon = CurrentWinStation ? m_idxCurrentAsync : m_idxAsync;
            break;
            
        case SdNetwork:
            WhichIcon = CurrentWinStation ? m_idxCurrentNet : m_idxNet;
            break;
            
        default:
            WhichIcon = CurrentWinStation ? m_idxCurrentConsole : m_idxConsole;
            break;
        }
    }
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineWinStationIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineDomainIcon
//
//	determines which icon to display for a Domain
//	in the tree
//
int CAdminTreeView::DetermineDomainIcon(CDomain *pDomain)
{
    ASSERT(pDomain);
    
    int WhichIcon = m_idxDomain;
    
    if(pDomain->IsCurrentDomain()) return m_idxCurrentDomain;
    
    if(pDomain->GetState() != DS_ENUMERATING && pDomain->GetState() != DS_INITIAL_ENUMERATION)
        WhichIcon = m_idxDomainNotConnected;
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineDomainIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::DetermineServerIcon
//
//	determines which icon to display for a Server
//	in the tree
//
int CAdminTreeView::DetermineServerIcon(CServer *pServer)
{
    ASSERT(pServer);
    
    int WhichIcon = m_idxServer;
    
    // Is this the current server?
    if(pServer->IsCurrentServer()) {
        if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
            WhichIcon = m_idxServerNotConnected;
        else
            WhichIcon = m_idxCurrentServer;
    } else {  // not the current server
        if(pServer->IsState(SS_NONE) || pServer->IsState(SS_NOT_CONNECTED))
            WhichIcon = m_idxServerNotConnected;
    }
    
    return WhichIcon;
    
}  // end CAdminTreeView::DetermineServerIcon


/////////////////////////////////////////
// F'N: CAdminTreeView::AddServerChildren
//
//	Adds the WinStations attached to a given Server
//	to the tree
//
void CAdminTreeView::AddServerChildren(HTREEITEM hServer, CServer *pServer  , NODETYPE nt)
{
    ASSERT(hServer);
    ASSERT(pServer);
    
    if(pServer->IsServerSane()) {
        
        LockTreeControl();
        
        HTREEITEM hLastNode = hServer;
        
        pServer->LockWinStationList();
        
        // Get a pointer to the server's list of WinStations
        CObList *pWinStationList = pServer->GetWinStationList();
        
        // Iterate through the WinStation list
        POSITION pos = pWinStationList->GetHeadPosition();
        
        while(pos)
        {
            CWinStation *pWinStation = (CWinStation*)pWinStationList->GetNext(pos);
            
            // Figure out which icon to use
            int WhichIcon = DetermineWinStationIcon(pWinStation);
            
            // Figure out what text to display
            TCHAR NameToDisplay[DISPLAY_NAME_SIZE];
            DetermineWinStationText(pWinStation, NameToDisplay);
            
            CTreeNode *pNode = new CTreeNode(NODE_WINSTATION, pWinStation);
            
            if( pNode != NULL )
            {
                pNode->SetSortOrder(pWinStation->GetSortOrder());
                
                hLastNode = AddItemToTree(hServer, NameToDisplay, hLastNode, WhichIcon, (LPARAM)pNode);
                
                if( hLastNode == NULL )
                {
                    delete pNode;
                }
            }
            
            // The WinStation wants to know his tree item handle
            
            if( nt == NODE_FAV_LIST )
            {
                pWinStation->SetTreeItemForFav(hLastNode);
            }
            else if( nt == NODE_SERVER )
            {
                pWinStation->SetTreeItem(hLastNode);
            }
            else if( nt == NODE_THIS_COMP )
            {
                pWinStation->SetTreeItemForThisComputer( hLastNode );
            }
        }
        
        pServer->UnlockWinStationList();
        
        UnlockTreeControl();
        
    }  // end if(pServer->IsServerSane())
    
    
}  // end CAdminTreeView::AddServerChildren


/////////////////////////////////////////
// F'N: CAdminTreeView::AddDomainToTree
//
//	Adds a domain to the tree
//
HTREEITEM CAdminTreeView::AddDomainToTree(CDomain *pDomain)
{
    ASSERT(pDomain);
    
    LockTreeControl();
    
    HTREEITEM hDomain = NULL;
    
    // this points to this computer root
    HTREEITEM hR2 = GetTreeCtrl().GetRootItem();
    
    // this points to favorite list
    hR2 = GetTreeCtrl().GetNextItem( hR2 , TVGN_NEXT );
    
    // this points to All servers
    HTREEITEM hRoot = GetTreeCtrl().GetNextItem( hR2 , TVGN_NEXT );
    // Add the domain to the tree
    // Create a CTreeNode object with info about this tree node
    CTreeNode* pNode = new CTreeNode(NODE_DOMAIN, pDomain);
    if(pNode) {
        hDomain = AddItemToTree(hRoot, pDomain->GetName(), TVI_SORT, DetermineDomainIcon(pDomain), (LPARAM)pNode);
        if(!hDomain) delete pNode;
        // Change the icon/overlay for the domain
        if(pDomain->GetState() == DS_INITIAL_ENUMERATION) 
            GetTreeCtrl().SetItemState(hDomain, STATE_QUESTION, 0x0F00);
        
        // The domain wants to know his tree item handle
        pDomain->SetTreeItem(hDomain);
    }
    
    UnlockTreeControl();
    
    return(hDomain);
    
}	// end CAdminTreeView::AddDomainToTree


//////////////////////////////////
// F'N: CAdminTreeView::OnAdminViewsReady
//
LRESULT CAdminTreeView::OnAdminViewsReady(WPARAM wParam, LPARAM lParam)
{
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    // We want to remember the tree item of the current server for later
    HTREEITEM hCurrentServer = NULL;
    
    HTREEITEM hThisComputerRootItem = NULL;
    HTREEITEM hThisComputer = NULL;
    HTREEITEM hFavRoot = NULL;
    
    // add enum for fav node
    CString cstrThisComputer;
    CString cstrFavSrv;
    
    CNodeType *pNodeType = new CNodeType( NODE_THIS_COMP );
    
    // ok to pass in null
    
    CTreeNode *pThisComp = new CTreeNode( NODE_THIS_COMP , pNodeType );
    
    if( pThisComp != NULL )
    {
        cstrThisComputer.LoadString( IDS_THISCOMPUTER );
        
        hThisComputerRootItem = AddItemToTree( NULL , cstrThisComputer , TVI_ROOT , m_idxDomain , ( LPARAM )pThisComp );
    }
    
    // ok to overrun
    
    pNodeType = new CNodeType( NODE_FAV_LIST );
    
    // it's ok to pass null here
    
    CTreeNode *pFavNode = new CTreeNode( NODE_FAV_LIST , pNodeType );
    
    if( pFavNode != NULL )
    {
        cstrFavSrv.LoadString( IDS_FAVSERVERS );
        
        hFavRoot = AddItemToTree( NULL , cstrFavSrv , TVI_ROOT , m_idxCitrix, ( LPARAM )pFavNode );
    }
    
    // add the root to the tree
    CString citrix;
    citrix.LoadString(IDS_TREEROOT);
    CTreeNode* pRootNode = new CTreeNode(NODE_ALL_SERVERS, NULL);
    if(!pRootNode) {
        UnlockTreeControl();
        return 0;
    }
    
    HTREEITEM hRoot = AddItemToTree(NULL, citrix, TVI_ROOT, m_idxCitrix, (LPARAM)pRootNode);   
    
    if(!hRoot) delete pRootNode;
    
    // set up some 'placeholder'-style vars
    HTREEITEM hCurrParent     = hRoot;
    HTREEITEM hLastConnection = hRoot;
    HTREEITEM hLastNode       = hRoot;
    HTREEITEM hDomain = NULL;
    
    // Get a pointer to the list of domains
    CObList *pDomainList = doc->GetDomainList();
    POSITION dpos = pDomainList->GetHeadPosition();
    
    while(dpos) {
        CDomain *pDomain = (CDomain*)pDomainList->GetNext(dpos);
        AddDomainToTree(pDomain);
    }
    
    // Get a pointer to the list of servers
    doc->LockServerList();
    CObList *pServerList = doc->GetServerList();
    
    // Iterate through the server list
    POSITION pos = pServerList->GetHeadPosition();
    
    CServer *pCurrentServer;
    
    while(pos) {
        // Go to the next server in the list
        CServer *pServer = (CServer*)pServerList->GetNext(pos);
        
        if( pServer == NULL )
        {
            continue;
        }
        
        // If this Server's domain isn't in the tree, add it
        CDomain *pDomain = pServer->GetDomain();
        if(pDomain != NULL )
        {
            hDomain = pDomain->GetTreeItem();
            ASSERT(hDomain);
        }
        else
        {
            // server is not in a domain
            hDomain = hRoot;
        }
        
        // Add the server to the tree
        // Create a CTreeNode object with info about this tree node
        CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
        if(pNode) {
            
            if( !pServer->IsCurrentServer() )
            {
                // If the server is the current server, use a different icon
                hLastConnection = AddItemToTree(hDomain, 
                    pServer->GetName(), 
                    hLastConnection,
                    DetermineServerIcon(pServer), 
                    (LPARAM)pNode);
                if(!hLastConnection) delete pNode;
                // The server wants to know his tree item handle
                pServer->SetTreeItem(hLastConnection);
                // If the server isn't sane, put a not sign over the icon
                if(!pServer->IsServerSane()) GetTreeCtrl().SetItemState(hLastConnection, STATE_NOT, 0x0F00);
                // If we aren't done getting all the information about this server,
                // put a question mark over the icon
                else if(pServer->IsState(SS_GETTING_INFO)) GetTreeCtrl().SetItemState(hLastConnection, STATE_QUESTION, 0x0F00);
                
                AddServerChildren(hLastConnection, pServer , NODE_SERVER );
            }
            
            // Remember if this is the current server
            else
            {
                hCurrentServer = hLastConnection;
                
                /* Add this item under the this computer root */
                
                hThisComputer = AddItemToTree( hThisComputerRootItem ,
                    pServer->GetName() ,
                    TVI_FIRST ,
                    DetermineServerIcon(pServer),
                    (LPARAM)pNode );
                
                CTreeNode* pItem = new CTreeNode(NODE_SERVER, pServer);
                
                // uncomment this line if you want this computer to be part of the domain tree list
                /*
                hLastConnection = AddItemToTree( hDomain, 
                pServer->GetName(), 
                hLastConnection,
                DetermineServerIcon(pServer), 
                (LPARAM)pItem);
                */
                
                pServer->SetTreeItemForThisComputer( hThisComputer );
                
                // uncomment this line if you want this computer to be part of the domain tree list
                // pServer->SetTreeItem( hLastConnection );
                
                if( !pServer->IsServerSane() )
                {
                    GetTreeCtrl().SetItemState(hThisComputer, STATE_NOT, 0x0F00);
                    // uncomment this line if you want this computer to be part of the domain tree list
                    // GetTreeCtrl().SetItemState(hLastConnection, STATE_NOT, 0x0F00);
                }                    
                
                // uncomment this line if you want this computer to be part of the domain tree list
                // AddServerChildren( hLastConnection, pServer , NODE_SERVER );
                
                AddServerChildren( hThisComputer , pServer , NODE_SERVER );                
            }
            
        }
    }  // end while(pos)
    
    doc->UnlockServerList();
    
    // We want to show the main server in this computer node
    
    //GetTreeCtrl().Expand(hRoot, TVE_EXPAND);
    
    GetTreeCtrl().Expand( hThisComputerRootItem , TVE_COLLAPSE );
    
    /*
    LRESULT lResult = 0xc0;
    // We want to default to having the current server being the
    // currently selected item in the tree and be expanded
    
      if( hThisComputerRootItem != NULL && ( g_dwTreeViewExpandedStates & TV_THISCOMP ) )
      {
      if( hThisComputer != NULL )
      {
		    GetTreeCtrl().SelectItem(hThisComputer);
            GetTreeCtrl().Expand(hThisComputer, TVE_EXPAND);
            // GetTreeCtrl().Expand(hDomain, TVE_EXPAND);        
            //lResult = 0xc0;
            OnSelChange( NULL , &lResult );
            }
            }
            
              if( hFavRoot != NULL && ( g_dwTreeViewExpandedStates & TV_FAVS ) )
              {
              GetTreeCtrl().SelectItem( hFavRoot );
              GetTreeCtrl().Expand( hFavRoot , TVE_EXPAND );
              OnSelChange( NULL , &lResult );
              }
              
                if( hRoot != NULL && ( g_dwTreeViewExpandedStates & TV_ALLSERVERS ) )
                {
                GetTreeCtrl().SelectItem( hRoot );
                GetTreeCtrl().Expand( hRoot , TVE_EXPAND );
                OnSelChange( NULL , &lResult );
                }
                
    */
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminViewsReady


////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddServer
//
//	Message Handler to add a Server to the tree
//	Pointer to CServer to add is in lParam
//
LRESULT CAdminTreeView::OnAdminAddServer(WPARAM wParam, LPARAM lParam)
{      
    ASSERT(lParam);
    
    CServer *pServer = (CServer*)lParam;
    
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // If this Server's domain isn't in the tree, add it
    HTREEITEM hDomain = NULL;
    CDomain *pDomain = pServer->GetDomain();
    if(pDomain) {
        hDomain = pDomain->GetTreeItem();
        ASSERT(hDomain);
    } else {
        // server is not in a domain
        hDomain = tree.GetRootItem();
    }
    
    // First make sure the server isn't already in the tree
    // Get the first server under the domain
    HTREEITEM hItem = tree.GetNextItem(hDomain, TVGN_CHILD);
    while(hItem) {
        // Get the data attached to the tree item
        CTreeNode *node = (CTreeNode*)tree.GetItemData(hItem);
        if(node) {
            // Is this the server we want to add
            CServer *pNewServer = (CServer*)node->GetTreeObject();
            if(pNewServer == (CServer*)lParam) {
                UnlockTreeControl();
                return 0;
            }
        }
        hItem = tree.GetNextItem(hItem, TVGN_NEXT);
    }
    
    // Add the server to the tree
    // Create a CTreeNode object with info about this tree node
    CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
    if(pNode)
    {
        // If the server is the current server, use a different icon
        
        HTREEITEM hServer = AddItemToTree(hDomain, pServer->GetName(), (HTREEITEM)wParam,
            DetermineServerIcon(pServer), (LPARAM)pNode);
        if( !hServer )
        {
            delete pNode;
        }
        // The server wants to know his tree item handle
        pServer->SetTreeItem(hServer);
        // If the server isn't sane, put a not sign over the icon
        if( !pServer->IsServerSane() )
        {
            tree.SetItemState(hServer, STATE_NOT, 0x0F00);
        }
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if(pServer->IsState(SS_GETTING_INFO))
        {
            tree.SetItemState(hServer, STATE_QUESTION, 0x0F00);
        }
        
        AddServerChildren(hServer, pServer , NODE_SERVER );
    }
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminAddServer

//----------------------------------------------------------------------
// ok if you traced me to here you are almost there
// 1) now we need to update the server item and place it under the favorites
// folder
// 2) inform the server child items that it will have a new parent
//
LRESULT CAdminTreeView::OnAdminAddServerToFavs( WPARAM wp , LPARAM lp )
{
    CServer *pServer = ( CServer* )lp;
    
    if( pServer == NULL )
    {
        ODS( L"CAdminTreeView::OnAdminAddServerToFavs invalid arg\n");
        return ( LRESULT )-1;
    }
    
    LockTreeControl( );
    
    if( pServer->IsServerInactive() || pServer->IsState( SS_DISCONNECTING ) )
    {
        UnlockTreeControl( );
        
        return 0;
    }
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    HTREEITEM hFavs = GetTreeCtrl().GetRootItem( );
    HTREEITEM hItem;
    
    hFavs = tree.GetNextItem( hFavs , TVGN_NEXT );
    
    hItem = tree.GetNextItem( hFavs , TVGN_CHILD );
    
    
    // check for duplicate entry
    
    while( hItem != NULL )
    {
        // Get the data attached to the tree item
        CTreeNode *pTreenode = (CTreeNode*)tree.GetItemData( hItem );
        
        if( pTreenode != NULL )
        {
            // Is this the server we want to add
            CServer *pSvr = (CServer*)pTreenode->GetTreeObject();
            
            if( pSvr == pServer )
            {
                UnlockTreeControl();
                
                return 0;
            }
        }
        
        hItem = tree.GetNextItem(hItem, TVGN_NEXT);
    }
    
    CTreeNode* pNode = new CTreeNode(NODE_SERVER, pServer);
    
    if( pNode != NULL )
    {
        HTREEITEM hServer = AddItemToTree( hFavs,
            pServer->GetName(),
            TVI_SORT,
            DetermineServerIcon(pServer),
            (LPARAM)pNode);
        
        
        if( hServer == NULL )
        {
            delete pNode;
        }
        
        // The server wants to know his tree item handle
        pServer->SetTreeItemForFav( hServer );
        
        // If the server isn't sane, put a not sign over the icon
        if( !pServer->IsServerSane() )
        {
            tree.SetItemState(hServer, STATE_NOT, 0x0F00);
        }
        // If we aren't done getting all the information about this server,
        // put a question mark over the icon
        else if( pServer->IsState( SS_GETTING_INFO ) )
        {
            tree.SetItemState(hServer, STATE_QUESTION, 0x0F00);
        }
        
        AddServerChildren( hServer , pServer , NODE_FAV_LIST );
    }
    
    UnlockTreeControl();
    
    tree.Invalidate( );
    
    return 0;
}
//=----------------------------------------------------------------------------------
LRESULT CAdminTreeView::OnAdminRemoveServerFromFavs( WPARAM wp , LPARAM lp )
{        
    LockTreeControl();
    
    CServer *pServer = ( CServer* )lp;
    
    DBGMSG( L"CAdminTreeView::OnAdminRemoveServerFromFavs -- %s\n" , pServer->GetName( ) );
    
    HTREEITEM hFavServer = pServer->GetTreeItemFromFav();
    
#ifdef _STRESS_BUILD
    DBGMSG( L"Handle to hFavServer 0x%x\n" , hFavServer );
#endif
    
    if( hFavServer == NULL )
    {
        UnlockTreeControl();
        
        return 0;
    }	
    
    // Get the data attached to this tree node
    
    
    CTreeNode *pNode = (CTreeNode*)GetTreeCtrl().GetItemData( hFavServer );
    
    if( pNode != NULL && pNode->GetNodeType( ) == NODE_SERVER )
    {
        // Is this the server we want to update
        CServer *pTreeServer = ( CServer* )pNode->GetTreeObject();
        
        if( pTreeServer != pServer)
        {
            UnlockTreeControl();
            return 0;
        }
    }
    else
    {
        UnlockTreeControl();
        
        return 0;
    }
    
    // Loop through it's children and delete their data
    
    pServer->LockWinStationList( );
    
    HTREEITEM hChild = GetTreeCtrl().GetNextItem( hFavServer , TVGN_CHILD );
    
    while( hChild != NULL )
    {
        CTreeNode *pChildNode = ( CTreeNode* )GetTreeCtrl().GetItemData( hChild );
        
        if( pChildNode != NULL && pChildNode->GetNodeType( ) == NODE_WINSTATION )
        {
            // Tell the WinStation it is no longer in the tree
            CWinStation *pWinStation = ( CWinStation* )pChildNode->GetTreeObject();
            
            if( pWinStation != NULL )
            {
                pWinStation->SetTreeItemForFav(NULL);
            }
            
            delete pChildNode;
        }
        
        hChild = GetTreeCtrl().GetNextItem( hChild , TVGN_NEXT );
    }
    
    // Delete the data attached to the tree item
    delete pNode;
    
    // Let the server know he is no longer in the tree
    pServer->SetTreeItemForFav(NULL);
    
    GetTreeCtrl().DeleteItem( hFavServer );
    
    pServer->UnlockWinStationList( );
    
    UnlockTreeControl();
    
    return 0;
}
////////////////////////////////
// F'N: CAdminTreeView::OnAdminRemoveServer
//
//	Message Handler to remove a Server from the tree
//	Pointer to CServer of server to remove is in lParam
//
LRESULT CAdminTreeView::OnAdminRemoveServer(WPARAM wParam, LPARAM lParam)              
{   
    ASSERT(lParam);
    
    CServer *pServer = (CServer*)lParam;
    
    HTREEITEM hServer = pServer->GetTreeItem();
    if(!hServer) return 0;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);
    if(node) {
        // Is this the server we want to update
        CServer *pTreeServer = (CServer*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeServer != pServer) {
            UnlockTreeControl();
            return 0;
        }
    }
    else {
        UnlockTreeControl();
        return 0;
    }
    
    // Loop through it's children and delete their data
    HTREEITEM hChild = GetTreeCtrl().GetNextItem(hServer, TVGN_CHILD);
    while(hChild) {
        CTreeNode *ChildNode = (CTreeNode*)GetTreeCtrl().GetItemData(hChild);
        if(ChildNode) {
            // Tell the WinStation it is no longer in the tree
            CWinStation *pWinStation = (CWinStation*)ChildNode->GetTreeObject();
            if(pWinStation) 
                pWinStation->SetTreeItem(NULL);
            delete ChildNode;
        }
        hChild = GetTreeCtrl().GetNextItem(hChild, TVGN_NEXT);
    }
    
    // Delete the data attached to the tree item
    delete node;
    // Let the server know he is no longer in the tree
    pServer->SetTreeItem(NULL);
    // Remove the server from the tree
    // This SHOULD remove all it's children
    GetTreeCtrl().DeleteItem(hServer);
    
    
    // TODO
    // if this means that CServer does not exist we need to remove this from the favorite list
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminRemoveServer


   /*=--------------------------------------------------------------------------------------
   OnAdminUpdateServer
   
     Message handler to update a Server in the tree
     Pointer to CServer to update is in lParam
     
       Updates server item in favorites folder
       and if server item is this computer it gets updated as well.
       
*=------------------------------------------------------------------------------------*/
LRESULT CAdminTreeView::OnAdminUpdateServer(WPARAM wParam, LPARAM lParam)
{      
    ASSERT(lParam);
    
    LockTreeControl( );
    // If favorite folders is expanded don't forget to update the tree item
    
    CServer *pServer = (CServer*)lParam;
    
    HTREEITEM hServer = pServer->GetTreeItem();
    
    if( hServer != NULL )
    {
        UpdateServerTreeNodeState( hServer , pServer , NODE_SERVER );
    }
    
    hServer = pServer->GetTreeItemFromFav( );
    
    if( hServer != NULL )
    {
        UpdateServerTreeNodeState( hServer , pServer , NODE_FAV_LIST );
    }
    
    hServer = pServer->GetTreeItemFromThisComputer( );
    
    if( hServer != NULL )
    {        
        UpdateServerTreeNodeState( hServer , pServer , NODE_THIS_COMP );
    }
    
    UnlockTreeControl( );
    
    return 0;
}

/*=--------------------------------------------------------------------------------------

  UpdateServerTreeNodeState
  
    hServer -- tree item that needs updating
    pServer -- server object
    
*=------------------------------------------------------------------------------------*/
LRESULT CAdminTreeView::UpdateServerTreeNodeState( HTREEITEM hServer , CServer *pServer , NODETYPE  nt )
{
    LockTreeControl( );
    
    if( hServer == NULL )
    {
        UnlockTreeControl( );
        
        return 0;
    }
    
    // Get the data attached to this tree node
    
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hServer);
    if( node != NULL && node->GetNodeType( ) == NODE_SERVER  )
    {
        // Is this the server we want to update
        CServer *pTreeServer = (CServer*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeServer != pServer) 
        {
            UnlockTreeControl();
            
            return 0;
        }
        
    }
    else
    {
        UnlockTreeControl();
        
        return 0;
    }
    
    UINT NewState;
    // Remember the previous state
    UINT PreviousState = GetTreeCtrl().GetItemState(hServer, 0x0F00);
    // Change the icon/overlay for the server
    // If the server isn't sane, put a not sign over the icon
    if(!pServer->IsServerSane()) NewState = STATE_NOT;
    // If we aren't done getting all the information about this server,
    // put a question mark over the icon
    else if(pServer->IsState(SS_GETTING_INFO)) NewState = STATE_QUESTION;
    // If it is fine, we want to remove any overlays from the icon
    else NewState = STATE_NORMAL;
    
    // Set the tree item to the new state
    GetTreeCtrl().SetItemState(hServer, NewState, 0x0F00);
    
    // If this Server was not opened and now is GOOD,
    // add it's children to the tree
    if(PreviousState != STATE_NORMAL && pServer->IsState(SS_GOOD)) {
        int ServerIcon = DetermineServerIcon(pServer);
        GetTreeCtrl().SetItemImage(hServer, ServerIcon, ServerIcon);
        AddServerChildren(hServer, pServer , nt );
        // If this server is the server the user is sitting at and is
        // the currently selected tree item, expand it
        if(hServer == GetTreeCtrl().GetSelectedItem() && pServer->IsCurrentServer()) {
            GetTreeCtrl().Expand(hServer, TVE_EXPAND);
        }
    }
    else if(pServer->GetPreviousState() == SS_DISCONNECTING && pServer->IsState(SS_NOT_CONNECTED)) {
        int ServerIcon = DetermineServerIcon(pServer);
        GetTreeCtrl().SetItemImage(hServer, ServerIcon, ServerIcon);
    }
    
    // If we changed the state of this server and it is the currently
    // selected node in the tree, we need to send a message to change
    // the view
    if(NewState != PreviousState && hServer == GetTreeCtrl().GetSelectedItem()) {
        ForceSelChange();
    }
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminUpdateServer


LRESULT CAdminTreeView::OnAdminAddWinStation(WPARAM wParam, LPARAM lParam)
{
    ASSERT(lParam);
    
    ODS( L"**CAdminTreeView::OnAdminAddWinStation\n" );
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    
    // Get the HTREEITEM of the Server this WinStation is attached to
    // TODO:
    // update the server item in the favorite list
    
    HTREEITEM hServer = pWinStation->GetServer()->GetTreeItem();
    
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_NONE );
    }
    
    hServer = pWinStation->GetServer( )->GetTreeItemFromFav( );
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_FAV_LIST );
    }
    
    hServer = pWinStation->GetServer( )->GetTreeItemFromThisComputer( );
    
    if( hServer != NULL )
    {
        AddWinStation( pWinStation , hServer , ( BOOL )wParam , NODE_THIS_COMP );
    }
    
    return 0;
}

////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddWinStation
//
//	Message handler to add a WinStation to the tree
//	lParam = pointer to CWinStation to add
//	wParam is TRUE if this is replacing a WinStation that was currently selected
//
LRESULT CAdminTreeView::AddWinStation( CWinStation * pWinStation , HTREEITEM hServer , BOOL bSel , NODETYPE nt )
{   	
    ODS( L"**CAdminTreeView::AddWinStation\n" );
    
    HTREEITEM hWinStation;
    
    LockTreeControl();
    
    // Figure out which icon to use
    int WhichIcon = DetermineWinStationIcon(pWinStation);
    
    // Figure out what text to display
    TCHAR NameToDisplay[DISPLAY_NAME_SIZE];			
    DetermineWinStationText(pWinStation, NameToDisplay);
    
    CTreeNode *pNode = new CTreeNode(NODE_WINSTATION, pWinStation);
    if(pNode) {
        pNode->SetSortOrder(pWinStation->GetSortOrder());
        
        // We have to insert this WinStation in sorted order
        // Get the first WinStation item attached to this server
        HTREEITEM hChild = GetTreeCtrl().GetNextItem(hServer, TVGN_CHILD);
        HTREEITEM hLastChild = TVI_FIRST;
        BOOL bAdded = FALSE;
        
        while(hChild)
        {
            CTreeNode *ChildNode = (CTreeNode*)GetTreeCtrl().GetItemData(hChild);
            if(ChildNode)
            {
                // Does it belong before this tree node?
                CWinStation *pTreeWinStation = (CWinStation*)ChildNode->GetTreeObject();
                if((pTreeWinStation->GetSortOrder() > pWinStation->GetSortOrder())
                    || ((pTreeWinStation->GetSortOrder() == pWinStation->GetSortOrder()) &&
                    (pTreeWinStation->GetSdClass() > pWinStation->GetSdClass())))
                {
                    hWinStation = AddItemToTree(hServer, NameToDisplay, hLastChild, WhichIcon, (LPARAM)pNode);
                    
                    if(!hWinStation)
                    {
                        delete pNode;
                    }
                    
                    // The WinStation wants to know his tree item handle
                    
                    if( nt == NODE_FAV_LIST )
                    {
                        pWinStation->SetTreeItemForFav( hWinStation );
                    }
                    else if( nt == NODE_THIS_COMP )
                    {
                        pWinStation->SetTreeItemForThisComputer( hWinStation );
                    }
                    else
                    {
                        pWinStation->SetTreeItem(hWinStation);
                    }
                    
                    bAdded = TRUE;
                    break;
                }
            }
            hLastChild = hChild;
            hChild = GetTreeCtrl().GetNextItem(hChild, TVGN_NEXT);
        }
        
        // If we didn't add it yet, add it at the end
        if(!bAdded)
        {
            hWinStation = AddItemToTree(hServer, NameToDisplay, hLastChild, WhichIcon, (LPARAM)pNode);
            
            if( hWinStation == NULL )
            {
                delete pNode;
            }
            
            // The WinStation wants to know his tree item handle
            if( nt == NODE_FAV_LIST )
            {
                pWinStation->SetTreeItemForFav( hWinStation );
            }
            else if( nt == NODE_THIS_COMP )
            {
                pWinStation->SetTreeItemForThisComputer( hWinStation );
            }
            else
            {
                pWinStation->SetTreeItem(hWinStation);
            }
            
        }
        
        // If this is replacing a WinStation in the tree that was the currently selected
        // tree item, make this new item in the tree the currently selected item
        if( bSel ) {
            GetTreeCtrl().SelectItem(hWinStation);
        }
    }
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminAddWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminUpdateWinStation
//
//	Message handler to update a WinStation in the tree
//	lParam = pointer to CWinStation to update
//

LRESULT CAdminTreeView::OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam)
{
    ODS( L"CAdminTreeView::OnAdminUpdateWinStation\n" );
    
    ASSERT(lParam);
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    
    HTREEITEM hWinStation = pWinStation->GetTreeItem();
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    hWinStation = pWinStation->GetTreeItemFromFav( );
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    hWinStation = pWinStation->GetTreeItemFromThisComputer( );
    
    if( hWinStation != NULL )
    {
        UpdateWinStation( hWinStation , pWinStation );
    }
    
    return 0;
}



LRESULT CAdminTreeView::UpdateWinStation( HTREEITEM hWinStation , CWinStation *pWinStation )
{      
    ODS( L"CAdminTreeView::UpdateWinStation\n" );
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hWinStation);
    if(node) {
        // Is this the WinStation we want to update
        CWinStation *pTreeWinStation = (CWinStation*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeWinStation != pWinStation) {
            UnlockTreeControl();
            return 0;
        }
    } else {
        UnlockTreeControl();
        return 0;
    }
    
    // If the sort order of this WinStation has changed,
    // we have to remove it from the tree and add it back in
    if(node->GetSortOrder() != pWinStation->GetSortOrder())
    {
        OnAdminRemoveWinStation( 0 , ( LPARAM )pWinStation );
        
        /*GetTreeCtrl().DeleteItem(hWinStation);
        
          pWinStation->SetTreeItem(NULL);
        */
        
        OnAdminAddWinStation((GetTreeCtrl().GetSelectedItem() == hWinStation), ( LPARAM )pWinStation );
        
        UnlockTreeControl();
        return 0;
    }
    
    int WhichIcon = DetermineWinStationIcon(pWinStation);
    GetTreeCtrl().SetItemImage(hWinStation, WhichIcon, WhichIcon);
    
    TCHAR NameToDisplay[DISPLAY_NAME_SIZE];			
    DetermineWinStationText(pWinStation, NameToDisplay);
    GetTreeCtrl().SetItemText(hWinStation, NameToDisplay);
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminUpdateWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminRemoveWinStation
//
//	Message handler to remove a WinStation from the tree
//	lParam = pointer to CWinStation to remove
LRESULT CAdminTreeView::OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam)
{   
    ODS( L"CAdminTreeView::OnAdminRemoveWinStation\n" );
    
    ASSERT(lParam);
    
    //TODO:
    // remove winstaion from favorite list
    
    CWinStation *pWinStation = (CWinStation*)lParam;
    
    HTREEITEM hWinStation;
    
    hWinStation = pWinStation->GetTreeItem();
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItem( NULL );
    }
    
    hWinStation = pWinStation->GetTreeItemFromFav( );
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItemForFav( NULL );
    }
    
    hWinStation = pWinStation->GetTreeItemFromThisComputer( );
    
    if( hWinStation != NULL )
    {
        RemoveWinstation( hWinStation , pWinStation );
        
        pWinStation->SetTreeItemForThisComputer( NULL );
    }
    
    return 0;
    
}

LRESULT CAdminTreeView::RemoveWinstation( HTREEITEM hWinStation , CWinStation *pWinStation )
{
    BOOL CurrentInTree = FALSE;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = ( CTreeNode * )GetTreeCtrl().GetItemData(hWinStation);
    
    if( node != NULL )
    {
        // Is this the WinStation we want to update
        CWinStation *pTreeWinStation = (CWinStation*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeWinStation != pWinStation)
        {
            UnlockTreeControl();
            return 0;
        }
    }
    else
    {
        UnlockTreeControl();
        return 0;
    }
    
    // Delete the data attached to the tree item
    delete node;
    // Let the WinStation know he is no longer in the tree
    
    // Is this WinStation currently selected in the tree?
    CurrentInTree = ( GetTreeCtrl().GetSelectedItem() == hWinStation );
    
    // Remove the WinStation from the tree
    GetTreeCtrl().DeleteItem( hWinStation );
    
    // If this WinStation is the currently selected node in the tree,
    // make it not so
    // This may not be necessary!
    if( CurrentInTree )
    {
        ((CWinAdminDoc*)GetDocument())->SetCurrentView(VIEW_CHANGING);
    }
    
    UnlockTreeControl();
    
    return 0;
    
}  // end CAdminTreeView::OnAdminRemoveWinStation


////////////////////////////////
// F'N: CAdminTreeView::OnAdminUpdateDomain
//
//	Message handler to update a Domain in the tree
//	Pointer to CDomain to update is in lParam
//
LRESULT CAdminTreeView::OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam)
{   
    ASSERT(lParam);
    
    CDomain *pDomain = (CDomain*)lParam;
    
    HTREEITEM hDomain = pDomain->GetTreeItem();
    if(!hDomain) return 0;
    
    LockTreeControl();
    
    // Get the data attached to this tree node
    CTreeNode *node = (CTreeNode*)GetTreeCtrl().GetItemData(hDomain);
    if(node) {
        // Is this the domain we want to update
        CDomain *pTreeDomain = (CDomain*)node->GetTreeObject();
        // Make sure the tree node is correct
        if(pTreeDomain != pDomain) {
            UnlockTreeControl();
            return 0;
        }
    } else {
        UnlockTreeControl();
        return 0;
    }
    
    UINT NewState;
    // Remember the previous state
    UINT PreviousState = GetTreeCtrl().GetItemState(hDomain, 0x0F00);
    // Change the icon/overlay for the domain
    if(pDomain->GetState() == DS_INITIAL_ENUMERATION) NewState = STATE_QUESTION;
    // If it is fine, we want to remove any overlays from the icon
    else NewState = STATE_NORMAL;
    
    // Set the tree item to the new state
    GetTreeCtrl().SetItemState(hDomain, NewState, 0x0F00);
    
    // If the new state is STATE_NORMAL, change the icon
    if(NewState == STATE_NORMAL) {
        int DomainIcon = DetermineDomainIcon(pDomain);
        GetTreeCtrl().SetItemImage(hDomain, DomainIcon, DomainIcon);			
    }
    
    // If we changed the state of this domain and it is the currently
    // selected node in the tree, we need to send a message to change
    // the view
    if(NewState != PreviousState && hDomain == GetTreeCtrl().GetSelectedItem()) {
        ForceSelChange();
    }
    
    if(pDomain->GetState() == DS_ENUMERATING) GetTreeCtrl().Expand(hDomain, TVE_EXPAND);
    
    UnlockTreeControl();
    
    return 0;                                                                  
    
}  // end CAdminTreeView::OnAdminUpdateDomain

////////////////////////////////
// F'N: CAdminTreeView::OnAdminAddDomain
//
//	Message handler to update a Domain in the tree
//	Pointer to CDomain to update is in lParam
//
LRESULT CAdminTreeView::OnAdminAddDomain(WPARAM wParam, LPARAM lParam)
{   
    ASSERT(lParam);
    
    if(lParam)
    {
        CDomain *pDomain = (CDomain*)lParam;
        return (LRESULT)AddDomainToTree(pDomain);
    }

    return 0;

} // end CAdminTreeView::OnAdminAddDomain

////////////////////////////////
// F'N: CAdminTreeView::OnContextMenu
//
//	Message handler called when user wants a context menu
//	This happens when the user clicks the right mouse button,
//	presses Shift-F10, or presses the menu key on a Windows keyboard
//
void CAdminTreeView::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // TODO: Add your message handler code here
    HTREEITEM hItem;
    CPoint ptClient = ptScreen;
    ScreenToClient(&ptClient);
    
    // If we got here from the keyboard,
    if(ptScreen.x == -1 && ptScreen.y == -1) {
        hItem = tree.GetSelectedItem();
        
        RECT rect;
        tree.GetItemRect(hItem, &rect, TRUE);
        
        ptScreen.x = rect.left + (rect.right -  rect.left)/2;
        ptScreen.y = rect.top + (rect.bottom - rect.top)/2;
        
        tree.ClientToScreen(&ptScreen);
        
    }
    else {
        // we shouldn't get here from the mouse
        // but sometimes we do, so handle it gracefully
        UnlockTreeControl();
        return;
    }
    
    // Pop-up the menu for WinStations
    CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
    ((CWinAdminDoc*)GetDocument())->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));
    
    if(pNode) {
        CMenu menu;
        UINT nIDResource = 0;
        
        switch(pNode->GetNodeType()) {
        case NODE_ALL_SERVERS:
            nIDResource = IDR_ALLSERVERS_POPUP;
            break;
            
        case NODE_DOMAIN:
            nIDResource = IDR_DOMAIN_POPUP;
            break;
            
        case NODE_SERVER:
            nIDResource = IDR_SERVER_POPUP;
            break;
            
        case NODE_WINSTATION:
            nIDResource = IDR_WINSTATION_TREE_POPUP;
            break;
        }
        
        if(nIDResource)
        {
            if(menu.LoadMenu(nIDResource))
            {
                CMenu *pMenu = menu.GetSubMenu(0);
                
                pMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
            }
        }
        
    } // end if(pNode)
    
    UnlockTreeControl();
    
} // end CAdminTreeView::OnContextMenu


////////////////////////////////
// F'N: CAdminTreeView::OnRClick
//
// The Tree Common Control sends a WM_NOTIFY of NM_RCLICK when
// the user presses the right mouse button in the tree
//
void CAdminTreeView::OnRClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPoint ptScreen(::GetMessagePos());
    
    LockTreeControl();
    
    // Get a pointer to our document
    CWinAdminDoc *doc = (CWinAdminDoc*)GetDocument();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // TODO: Add your message handler code here
    UINT flags;
    HTREEITEM hItem;
    CPoint ptClient = ptScreen;
    ScreenToClient(&ptClient);
    
    hItem = tree.HitTest(ptClient, &flags);
    if((NULL == hItem) || !(TVHT_ONITEM & flags)) {
        UnlockTreeControl();
        return;
    }
    
    // Pop-up the menu
    CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
    ((CWinAdminDoc*)GetDocument())->SetTreeTemp(pNode->GetTreeObject(), (pNode->GetNodeType()));
    
    if(pNode) {
        CMenu menu;
        UINT nIDResource = 0;
        
        tree.SelectItem( hItem );
        
        switch(pNode->GetNodeType()) {
        case NODE_ALL_SERVERS:
            nIDResource = IDR_ALLSERVERS_POPUP;
            break;
            
        case NODE_DOMAIN:
            nIDResource = IDR_DOMAIN_POPUP;
            break;
            
        case NODE_SERVER:
            nIDResource = IDR_SERVER_POPUP;
            break;
            
        case NODE_WINSTATION:
            nIDResource = IDR_WINSTATION_TREE_POPUP;
            break;
        }
        
        if(menu.LoadMenu( nIDResource ) )
        {
            CMenu *pMenu = menu.GetSubMenu(0);
            
            if( pMenu != NULL )
            {               
                pMenu->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
            }
        }
        
        
    } // end if(pNode)
    
    UnlockTreeControl();
    
}	// end CAdminTreeView::OnRClick



//A false result means the server is disconnected
BOOL CAdminTreeView::ConnectToServer(CTreeCtrl* tree, HTREEITEM* hItem)
{
    CTreeNode *pNode = (CTreeNode*)tree->GetItemData(*hItem);
    
    if(pNode != NULL && *hItem == tree->GetSelectedItem() )
    {
        if( pNode->GetNodeType() == NODE_SERVER)
        {
            // Is this server in the "just disconnected" state
            CServer *pServer = (CServer*)pNode->GetTreeObject();
            // If both previous state and state are SS_NOT_CONNECTED,
            // we know the user just disconnected from this server
            if(pServer != NULL)
            {
                if(pServer->IsState(SS_NOT_CONNECTED) ||
                   pServer->IsState(SS_BAD))
                return false;
            }
            else
                return false;
        }
        else if( pNode->GetNodeType( ) == NODE_DOMAIN )
        {
            CDomain *pDomain = ( CDomain * )pNode->GetTreeObject( );
            
            if( pDomain != NULL && pDomain->GetThreadPointer() == NULL )
                pDomain->StartEnumerating();                
        }
    }

    return true;
}

////////////////////////////////
// F'N: CAdminTreeView::OnLButtonDown
//
void CAdminTreeView::OnLButtonDblClk(UINT nFlags, CPoint ptClient) 
{
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    UINT flags;
    
    // Figure out what they clicked on
    HTREEITEM hItem = tree.HitTest(ptClient, &flags);
    if((NULL != hItem) && (TVHT_ONITEM & flags)) 
    {
        if (!ConnectToServer(&tree, &hItem))
        {
            LRESULT Result = 0xc0;
            OnSelChange(NULL, &Result);
        }
    }

    UnlockTreeControl();
    
    CTreeView::OnLButtonDblClk(nFlags, ptClient);
}


LRESULT CAdminTreeView::OnAdminConnectToServer( WPARAM wp , LPARAM lp )
{
    OnEnterKey();
    return 0;
}

LRESULT CAdminTreeView::OnAdminForceSelChange( WPARAM wp , LPARAM lp )
{
    ForceSelChange();
    return 0;
}


void CAdminTreeView::OnEnterKey( )
{
    LockTreeControl();
    
    CTreeCtrl &tree = GetTreeCtrl();
    
    // Figure out what's selected
    HTREEITEM hItem = tree.GetSelectedItem( );
    
    if (!ConnectToServer(&tree, &hItem))
    {
        LRESULT Result = 0xc0;
        OnSelChange(NULL, &Result);
    }

    UnlockTreeControl();
}

void CAdminTreeView::OnSetFocus( CWnd *pOld )
{
    CWnd::OnSetFocus( pOld );
    
    CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();
    
    pDoc->RegisterLastFocus( TREE_VIEW );
    
}

//=---------------------------------------------------------------------------------------
// wp is the node type to expand on
// this computer
// favorite item
// domain item

LRESULT CAdminTreeView::OnAdminGotoServer( WPARAM wp , LPARAM lp )
{
    // todo use wp correctly
    
    CServer *pServer = ( CServer * )lp;
    
    if( pServer == NULL )
    {
        ODS( L"CAdminTreeView::OnAdminGotoServer invalid server arg\n" );
        return 0 ;
    }
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeItem = pServer->GetTreeItem( );
    
    if( hTreeItem != NULL )
    {
        ODS( L"CAdminTreeView!OnAdminGotoServer - Server treeitem was found\n" );
        
        tree.SelectItem(hTreeItem);
        
        tree.Expand(hTreeItem, TVE_EXPAND);
    }
    
    UnlockTreeControl( );
    
    return 0;
}

//=---------------------------------------------------------------------------------------
// wp and lp not used
//
LRESULT CAdminTreeView::OnAdminDelFavServer( WPARAM wp , LPARAM lp )
{
    // get the current treenode
    // determine if its a fav folder or if its parent a fav folder
    // if so get the server and kill it
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeItem = tree.GetSelectedItem();
    
    do
    {
        if( hTreeItem == NULL )
        {
            break;
        }
        
        HTREEITEM hTreeRoot = tree.GetRootItem( );
        
        if( hTreeRoot == NULL )
        {
            break;
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {
            break;
        }
        
        
        if( hTreeFavRoot == hTreeItem )
        {
            // not a cool thing here ignore
            break;
        }
        
        hTreeRoot = tree.GetNextItem( hTreeItem , TVGN_PARENT );
        
        if( hTreeFavRoot == hTreeRoot )
        {
            // yes we're talking about a fav node that the user wants to delete
            
            CTreeNode *pNode = ( CTreeNode* )tree.GetItemData( hTreeItem );
            
            if( pNode != NULL && pNode->GetNodeType() == NODE_SERVER )
            {                
                CServer *pServer = ( CServer* )pNode->GetTreeObject();
                
                // sanity check
                if( pServer != NULL && pServer->GetTreeItemFromFav() == hTreeItem )
                {
                    OnAdminRemoveServerFromFavs( 0 , ( LPARAM )pServer );
                }
            }
        }
        
        
    }while( 0 );
    
    UnlockTreeControl( );
    
    return 0;
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnGetTVStates( WPARAM ,  LPARAM )
{
    ODS( L"CAdminTreeView::OnGetTVStates\n" );
    
    DWORD dwStates = 0;
    
    // find out the tri-states
    HTREEITEM hRoot;
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    
    hRoot = tree.GetRootItem( ); // this computer
    
    if( hRoot != NULL )
    {
        if( tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates = TV_THISCOMP;
        }
        
        hRoot = tree.GetNextItem( hRoot , TVGN_NEXT ); // favorites
        
        if( hRoot != NULL && tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates |= TV_FAVS;
        }
        
        hRoot = tree.GetNextItem( hRoot , TVGN_NEXT ); // all servers
        
        if( hRoot != NULL && tree.GetItemState( hRoot , TVIS_EXPANDED ) & TVIS_EXPANDED  )
        {
            dwStates |= TV_ALLSERVERS;
        }
    }
    
    UnlockTreeControl( );
    
    return ( LRESULT )dwStates;
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnUpdateTVState( WPARAM , LPARAM )
{
    LRESULT lResult = 0xc0;
    HTREEITEM hThisComputerRootItem = GetTreeCtrl().GetRootItem( );
    HTREEITEM hFavRoot = GetTreeCtrl().GetNextItem( hThisComputerRootItem , TVGN_NEXT );
    HTREEITEM hRoot = GetTreeCtrl().GetNextItem( hFavRoot , TVGN_NEXT );
    // We want to default to having the current server being the
    // currently selected item in the tree and be expanded
    
    if( hThisComputerRootItem != NULL && ( g_dwTreeViewExpandedStates & TV_THISCOMP ) )
    {
        HTREEITEM hThisComputer = GetTreeCtrl().GetNextItem( hThisComputerRootItem , TVGN_CHILD );
        
        if( hThisComputer != NULL )
        {
            GetTreeCtrl().SelectItem(hThisComputer);
            GetTreeCtrl().Expand(hThisComputer, TVE_EXPAND);
            // GetTreeCtrl().Expand(hDomain, TVE_EXPAND);        
            //lResult = 0xc0;
            OnSelChange( NULL , &lResult );
        }
    }
    
    if( hFavRoot != NULL && ( g_dwTreeViewExpandedStates & TV_FAVS ) )
    {
        GetTreeCtrl().SelectItem( hFavRoot );
        GetTreeCtrl().Expand( hFavRoot , TVE_EXPAND );
        OnSelChange( NULL , &lResult );
    }
    
    if( hRoot != NULL && ( g_dwTreeViewExpandedStates & TV_ALLSERVERS ) )
    {
        GetTreeCtrl().SelectItem( hRoot );
        GetTreeCtrl().Expand( hRoot , TVE_EXPAND );
        OnSelChange( NULL , &lResult );
    }
    
    return 0;
}

//=-------------------------------------------------------------
void CAdminTreeView::OnBeginDrag( NMHDR *pNMHDR , LRESULT *pResult )
{
    ODS( L"CAdminTreeView::OnBeginDrag\n" );
    
    RECT rc;
    
    NMTREEVIEW *pTV = ( NMTREEVIEW * )pNMHDR;
    
    if( pTV != NULL )
    {
        
        if( m_pimgDragList != NULL )
        {
            // this should never happen
            ODS( L"There is a possible leak CAdminTreeView!OnBeginDrag\n" );
            
            delete m_pimgDragList;
            
            m_pimgDragList = NULL;
        }
        
        if( pTV->itemNew.hItem != NULL )
        {
            m_pimgDragList = GetTreeCtrl().CreateDragImage( pTV->itemNew.hItem );
        }
        
        if( m_pimgDragList != NULL )
        {            
            GetTreeCtrl().GetItemRect( pTV->itemNew.hItem , &rc , FALSE );
            
            CPoint cp( pTV->ptDrag.x - rc.left , pTV->ptDrag.y - rc.top );
            
            /*
            HCURSOR  hCursor = ::LoadCursor( NULL, IDC_CROSS );
            
              ICONINFO iconinfo;
              
                ::GetIconInfo( ( HICON )hCursor , &iconinfo );
            */
            
            
            m_pimgDragList->BeginDrag( 0 , CPoint( 0 , 0 ) );            
            
            /*
            cp.x -= iconinfo.xHotspot;
            cp.y -= iconinfo.yHotspot;
            
              m_pimgDragList->SetDragCursorImage(  0 , cp );
            */
            
            m_pimgDragList->DragEnter( &GetTreeCtrl( ) , cp );
            
            SetCapture();
            
            // this is for us to check when we're not in the client area
            m_nTimer = SetTimer( 1 , 50 , NULL );
            
            //ShowCursor( FALSE );
            
            m_hDragItem = pTV->itemNew.hItem;
            
            
        }
    }
    
    *pResult = 0;
}

//=-------------------------------------------------------------
void CAdminTreeView::OnTimer( UINT nIDEvent )
{
    UINT uflags;
    
    POINT pt;
    
    CTreeCtrl &cTree = GetTreeCtrl( );
    
    GetCursorPos(&pt);
    
    cTree.ScreenToClient( &pt );
    
    if( m_nTimer == 0 )
    {
        return;
    }
    
    HTREEITEM hItem;
    
    HTREEITEM hTreeItem = cTree.HitTest( CPoint( pt.x , pt.y ) , &uflags );
    
    if( uflags & TVHT_ABOVE )
    {
        ODS( L"scrolling up...\n" );
        
        hItem = cTree.GetFirstVisibleItem( );
        
        hItem = cTree.GetNextItem( hItem , TVGN_PREVIOUSVISIBLE  );
        
        if( hItem != NULL )
        {
            cTree.Invalidate( );
            
            cTree.EnsureVisible( hItem );
        }
        
    }
    else if( uflags & TVHT_BELOW )
    {
        ODS( L"scrolling down...\n" );
        
        hItem = cTree.GetFirstVisibleItem( );
        
        hItem = cTree.GetNextItem( hItem , TVGN_NEXT );
        
        if( hItem != NULL )
        {
            cTree.EnsureVisible( hItem );
        }
        
    }
    
}

//=-------------------------------------------------------------
void CAdminTreeView::OnLButtonUp( UINT uFlags , CPoint cp )
{
    ODS( L"CAdminTreeView::OnLButtonUp\n" );
    
    if( m_hDragItem != NULL && m_pimgDragList != NULL )
    {
        m_pimgDragList->DragLeave( &GetTreeCtrl( ) );
        
        m_pimgDragList->EndDrag( );
        
        m_pimgDragList->DeleteImageList( );
        
        delete m_pimgDragList;
        
        m_pimgDragList = NULL;
        
        KillTimer( m_nTimer );
        
        m_nTimer = 0;
        
        ReleaseCapture( );
        
        Invalidate( );
        
        // ShowCursor( TRUE );
    }
}


//=-------------------------------------------------------------        
void CAdminTreeView::OnMouseMove( UINT uFlags , CPoint cp )
{
    if( m_pimgDragList != NULL )
    {
        UINT uflags;
        
        HTREEITEM hTreeItem = GetTreeCtrl( ).HitTest( cp , &uflags );
        
        if( hTreeItem != GetTreeCtrl( ).GetDropHilightItem( ) )
        {
            ODS( L"CAdminTreeView::OnMouseMove NOT!!\n");
            m_pimgDragList->DragLeave( &GetTreeCtrl( ) );
            
            GetTreeCtrl( ).SelectDropTarget( NULL );
            GetTreeCtrl( ).SelectDropTarget( hTreeItem );
            
            m_pimgDragList->DragEnter( &GetTreeCtrl( ) , cp );
        }
        else
        {
            m_pimgDragList->DragMove( cp );
        }
    }
}

//=-------------------------------------------------------------
LRESULT CAdminTreeView::OnEmptyFavorites( WPARAM wp, LPARAM )
{
    ODS( L"CAdminTreeView!OnEmptyFavorites\n" );
    
    // check to see if there are any items in the view
    
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    int nRet;
    
    HTREEITEM hTreeRoot = tree.GetRootItem( );
    
    do
    {
        if( hTreeRoot == NULL )
        {
            break;    
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {
            break;
        }
        
        HTREEITEM hItem = tree.GetNextItem( hTreeFavRoot , TVGN_CHILD );
        
        if( hItem == NULL )
        {
            break;
        }
        
        // warn the user about losing the entire favorite list
        
        CString cstrMsg;
        CString cstrTitle;
        
        cstrMsg.LoadString( IDS_EMPTYFOLDER );
        cstrTitle.LoadString( AFX_IDS_APP_TITLE );
        
        
        
#ifdef _STRESS_BUILD
        if( ( BOOL )wp != TRUE )
        {
#endif
            
            
            nRet = MessageBox( cstrMsg ,
                cstrTitle ,
                MB_YESNO | MB_ICONINFORMATION );
            
#ifdef _STRESS_BUILD
        }
        else
        {
            nRet = IDYES;
        }
#endif
        
        
        if( nRet == IDYES )
        {
            // loop through every item and remove the item
            HTREEITEM hNextItem = hItem;
            
            while( hItem != NULL )
            {
                CTreeNode *pNode = (CTreeNode*)tree.GetItemData(hItem);
                
                hNextItem = tree.GetNextItem( hItem , TVGN_NEXT );
                
                if( pNode != NULL )
                {
                    // Is it the same item as is selected
                    if( pNode->GetNodeType() == NODE_SERVER )
                    {                    
                        CServer *pServer = (CServer*)pNode->GetTreeObject();
                        
                        // skip this server if its being disconnected
                        
                        if( !pServer->IsState( SS_DISCONNECTING ) )
                        {
                            SendMessage( WM_ADMIN_REMOVESERVERFROMFAV , 0 , ( LPARAM )pServer );
                        }
                    }
                }
                
                hItem = hNextItem;                
            }
        }
        
    }while( 0 );
    
    UnlockTreeControl( );
    
    
    return 0;
}

//=----------------------------------------------------------------
LRESULT CAdminTreeView::OnIsFavListEmpty( WPARAM wp , LPARAM lp )
{
    LockTreeControl( );
    
    CTreeCtrl &tree = GetTreeCtrl( );
    
    HTREEITEM hTreeRoot = tree.GetRootItem( );
    
    BOOL bEmpty = TRUE;
    
    do
    {
        if( hTreeRoot == NULL )
        {            
            break;    
        }
        
        // get fav folder
        
        HTREEITEM hTreeFavRoot =  tree.GetNextItem( hTreeRoot , TVGN_NEXT );
        
        if( hTreeFavRoot == NULL )
        {            
            break;
        }
        
        HTREEITEM hItem = tree.GetNextItem( hTreeFavRoot , TVGN_CHILD );
        
        if( hItem == NULL )
        {
            break;
        }
        
        bEmpty = FALSE;
        
    } while( 0 );
    
    UnlockTreeControl( );
    
    return ( LRESULT )bEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\treeview.h ===
/*******************************************************************************
*
* treeview.h
*
* - declarations for the CAdminTreeView class
* - the CAdminTreeView class lives in the left pane of the mainframe's splitter
* - derived from CTreeView
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\treeview.h  $
*  
*     Rev 1.6   19 Feb 1998 17:42:36   donm
*  removed latest extension DLL support
*  
*     Rev 1.4   19 Jan 1998 16:49:24   donm
*  new ui behavior for domains and servers
*  
*     Rev 1.3   03 Nov 1997 15:21:42   donm
*  added Domains
*  
*     Rev 1.2   13 Oct 1997 18:42:02   donm
*  update
*  
*     Rev 1.9   29 Jul 1997 10:11:48   butchd
*  update
*  
*     Rev 1.8   14 Mar 1997 17:13:24   donm
*  update
*  
*     Rev 1.7   11 Mar 1997 17:26:10   donm
*  update
*  
*     Rev 1.6   26 Feb 1997 15:29:34   donm
*  update
*  
*     Rev 1.5   14 Feb 1997 08:57:46   donm
*  update
*  
*     Rev 1.4   04 Feb 1997 18:13:58   donm
*  update
*  
*     Rev 1.3   03 Feb 1997 16:35:40   donm
*  update
*  
*     Rev 1.2   29 Jan 1997 18:39:02   donm
*  update
*******************************************************************************/

#ifndef _TREEVIEW_H
#define _TREEVIEW_H

#include "afxcview.h"
#include "basetree.h"

///////////////////////
// CLASS: CAdminTreeView
//
class CAdminTreeView : public CBaseTreeView
{
friend class CTreeTabCtrl;
friend class CLeftPane;

protected:
	CAdminTreeView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CAdminTreeView)

// Attributes
protected:
	int m_idxBlank;		// index of Blank icon image
	int m_idxCitrix;	// index of Citrix icon image
	int m_idxServer;	// index of Server icon image 
	int m_idxConsole;	// index of Console icon image
	int m_idxNet;		// index of Net icon image
	int m_idxNotSign;	// index of Not Sign overlay (for non-sane servers)
	int m_idxQuestion;	// index of Question Mark overlay (for non-opened servers)
	int m_idxUser;		// index of User icon image
	int m_idxAsync;		// index of Async icon image (modem)
	int m_idxCurrentServer;	// index of Current Server image
	int m_idxCurrentNet;	// index of Current Net image
	int m_idxCurrentConsole;// index of Current Console image
	int m_idxCurrentAsync;	// index of Current Async image
	int m_idxDirectAsync;	// index of Direct Async image
	int m_idxCurrentDirectAsync; // index of Current Direct Async image
    int m_idxDomain;        // index of Domain image
    int m_idxCurrentDomain; // index of Current Domain image
	int m_idxDomainNotConnected;  // index of Domain Not Connected image
	int m_idxServerNotConnected;  // index of Server Not Connected image
    
    CImageList *m_pimgDragList;
    HTREEITEM m_hDragItem;
    UINT_PTR m_nTimer;

// Operations
public:

protected:

private:
    // Builds the image list
    virtual void BuildImageList();			
	
    // Add the WinStations attached to a particular Server
    void AddServerChildren(HTREEITEM hServer, CServer *pServer , NODETYPE );
    // Add a Domain to the tree
    HTREEITEM AddDomainToTree(CDomain *pDomain);
    // Determines what text to use for a WinStation in the tree
    void DetermineWinStationText(CWinStation *pWinStation, TCHAR *text);
    // Determines which icon to use for a WinStation in the tree
    int DetermineWinStationIcon(CWinStation *pWinStation);
    // Determine which icon to use for a Domain in the tree
    int DetermineDomainIcon(CDomain *pDomain);
    // Determine which icon to use for a Server in the tree
    int DetermineServerIcon(CServer *pServer);
    BOOL ConnectToServer(CTreeCtrl* tree, HTREEITEM* hItem);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAdminTreeView)
    public:
//	virtual void OnInitialUpdate();
    protected:
//	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
//	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CAdminTreeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    LRESULT UpdateServerTreeNodeState( HTREEITEM , CServer * , NODETYPE );
    LRESULT RemoveWinstation( HTREEITEM , CWinStation * );
    LRESULT UpdateWinStation( HTREEITEM , CWinStation * );
    LRESULT AddWinStation( CWinStation * , HTREEITEM , BOOL , NODETYPE );

	// Generated message map functions
protected:
	//{{AFX_MSG(CAdminTreeView)
    afx_msg LRESULT OnAdminAddServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminRemoveServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminUpdateServer(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminAddWinStation(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminUpdateWinStation(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminRemoveWinStation(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminUpdateDomain(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminAddDomain(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminViewsReady(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnAdminAddServerToFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminRemoveServerFromFavs( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminGotoServer( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminDelFavServer( WPARAM , LPARAM );
    afx_msg LRESULT OnGetTVStates( WPARAM ,  LPARAM );
    afx_msg LRESULT OnUpdateTVState( WPARAM , LPARAM );
    afx_msg LRESULT OnEmptyFavorites( WPARAM , LPARAM );
    afx_msg LRESULT OnIsFavListEmpty( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminConnectToServer( WPARAM , LPARAM );
    afx_msg LRESULT OnAdminForceSelChange( WPARAM , LPARAM );



    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnRClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);    
    afx_msg void OnEnterKey( );
    afx_msg void OnSetFocus( CWnd *pOld );
    afx_msg void OnBeginDrag(  NMHDR * , LRESULT * );
    afx_msg void OnLButtonUp( UINT , CPoint );
    afx_msg void OnMouseMove( UINT , CPoint );
    afx_msg void OnTimer( UINT nIDEvent );



	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CAdminTreeView

#endif  // _TREEVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\waextend.h ===
/*******************************************************************************
*
* waextend.h
*
* Declarations for structures passed between WinAdmin and ADMINEX.DLL
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   unknown  $  Don Messerli
*
* $Log:   R:\nt\private\utils\citrix\winutils\tsadmin\vcs\waextend.h  $
*  
*     Rev 1.5   22 Feb 1998 15:53:34   unknown
*  Removed winframe.h dependency
*  
*     Rev 1.4   16 Feb 1998 16:02:54   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.1   22 Oct 1997 21:56:54   donm
*  update
*  
*     Rev 1.0   15 Oct 1997 19:19:58   donm
*  Initial revision.
*  
*******************************************************************************/


#ifndef _WAEXTEND_H
#define _WAEXTEND_H

class CAppServer;

// Messages sent by the extension DLL
#define EXT_MESSAGE_BASE			WM_USER + 1000
	
#define WM_EXT_ADD_APPLICATION		EXT_MESSAGE_BASE
#define WM_EXT_ADD_APP_SERVER       EXT_MESSAGE_BASE + 1
#define WM_EXT_APP_CHANGED			EXT_MESSAGE_BASE + 2
#define WM_EXT_REMOVE_APPLICATION   EXT_MESSAGE_BASE + 3
#define WM_EXT_REMOVE_APP_SERVER    EXT_MESSAGE_BASE + 4

// Flags for ExtServerInfo
const ULONG ESF_WINFRAME = 0x0001;			// Server is running Picasso or WinFrame 1.7
const ULONG ESF_LOAD_BALANCING = 0x0002;	// Server is load balancing
const ULONG ESF_NO_LICENSE_PRIVILEGES = 0x0004;	// User doesn't have privileges to enumerate licenses
const ULONG ESF_UNLIMITED_LICENSES = 0x0008;	// Server has an unlimited user license installed

// Information about a Server
// For the All Server Servers Page
typedef struct _ExtServerInfo {
	// TCP/IP Address of the server as an ASCII string
	TCHAR TcpAddress[50];
	// Raw TCP/IP Address of the server
	ULONG RawTcpAddress;
	// IPX Address of the server
	TCHAR IpxAddress[50];
	ULONG TcpLoadLevel;
	ULONG IpxLoadLevel;
	ULONG NetbiosLoadLevel;
	// License Counts
	ULONG ServerPoolInstalled;
    ULONG ServerPoolInUse;
    ULONG ServerPoolAvailable;
    ULONG ServerLocalInstalled;
    ULONG ServerLocalInUse;
    ULONG ServerLocalAvailable;
    ULONG ServerTotalInstalled;
    ULONG ServerTotalInUse;
    ULONG ServerTotalAvailable;
    ULONG NetworkPoolInstalled;
    ULONG NetworkPoolInUse;
    ULONG NetworkPoolAvailable;
    ULONG NetworkLocalInstalled;
    ULONG NetworkLocalInUse;
    ULONG NetworkLocalAvailable;
    ULONG NetworkTotalInstalled;
    ULONG NetworkTotalInUse;
    ULONG NetworkTotalAvailable;
	// Flags
	ULONG Flags;
} ExtServerInfo;

// Flags for ExtWinStationInfo


// WinStation Extra Info
typedef struct _ExtWinStationInfo {
	ULONG CacheTiny;
	ULONG CacheLowMem;
	ULONG CacheXms;
	ULONG CacheDASD;
	ULONG DimCacheSize;
	ULONG DimBitmapMin;
	ULONG DimSignatureLevel;
	// Flags
	ULONG Flags;
} ExtWinStationInfo;

// Global Extra Info
typedef struct _ExtGlobalInfo {
	// License Counts
    ULONG NetworkPoolInstalled;
    ULONG NetworkPoolInUse;
    ULONG NetworkPoolAvailable;
    ULONG NetworkLocalInstalled;
    ULONG NetworkLocalInUse;
    ULONG NetworkLocalAvailable;
    ULONG NetworkTotalInstalled;
    ULONG NetworkTotalInUse;
    ULONG NetworkTotalAvailable;
} ExtGlobalInfo;

typedef enum _LICENSECLASS {
    LicenseBase,
    LicenseBump,
    LicenseEnabler,
    LicenseUnknown
} LICENSECLASS;

const ULONG ELF_POOLING = 0x0001;
const ULONG ELF_REGISTERED = 0x0002;

typedef struct _ExtLicenseInfo {
	LICENSECLASS Class;
	ULONG PoolLicenseCount;
	ULONG LicenseCount;
	WCHAR RegSerialNumber[26];
	WCHAR LicenseNumber[36];
	WCHAR Description[65];
	ULONG Flags;
} ExtLicenseInfo;

typedef struct _ExtModuleInfo {
	USHORT Date;
	USHORT Time;
	ULONG Size;
	BYTE LowVersion;
	BYTE HighVersion;
	TCHAR Name[13];
} ExtModuleInfo;

typedef struct _ExtAddTreeNode {
	CObject *pObject;
	CObject *pParent;
	HTREEITEM hParent;
	TCHAR Name[256];
} ExtAddTreeNode;

enum AATYPE {
	AAT_USER,
	AAT_LOCAL_GROUP,
	AAT_GLOBAL_GROUP
};


// Published App flags					
const ULONG AF_QUERYSUCCESS				= 0x00000001;
const ULONG AF_ANONYMOUS				= 0x00000002;
const ULONG AF_INHERIT_CLIENT_SIZE		= 0x00000004;
const ULONG AF_INHERIT_CLIENT_COLORS	= 0x00000008;
const ULONG AF_HIDE_TITLE_BAR			= 0x00000010;
const ULONG AF_MAXIMIZE					= 0x00000020;
const ULONG AF_CURRENT                  = 0x00000040;

// A mask to use to clear all flags set with data from the APPCONFIG structure
const ULONG AF_CONFIG_MASK = AF_ANONYMOUS  | AF_INHERIT_CLIENT_SIZE | AF_INHERIT_CLIENT_COLORS
							 | AF_HIDE_TITLE_BAR | AF_MAXIMIZE;

// Published Application States (for m_State)
enum APP_STATE {
	PAS_NONE,
	PAS_GETTING_INFORMATION,
	PAS_GOOD
};

// Flags that get sent in wParam of WM_EXT_APP_CHANGED message
// telling what has changed
const WPARAM ACF_STATE		= 0x0001;
const WPARAM ACF_CONFIG		= 0x0002;
const WPARAM ACF_ALLOWED 	= 0x0004;

// Published App Window Color Values
const ULONG APP_16_COLOR	= 0x0001;
const ULONG APP_256_COLOR	= 0x0002;
const ULONG APP_64K_COLOR	= 0x0004;
const ULONG APP_16M_COLOR	= 0x0008;

class CPublishedApp : public CObject
{
public:
	// Constructor
	CPublishedApp(TCHAR *name);
	// Destructor
	~CPublishedApp();
	// Query Servers
	void QueryServers();
	// Update with new information
	BOOL Update();
	// Returns the name of the published app
	TCHAR *GetName() { return m_Name; }
	// Returns the handle to this app's tree item
	HTREEITEM GetTreeItem() { return m_hTreeItem; }
	// Sets the tree item handle
	void SetTreeItem(HTREEITEM handle) { m_hTreeItem = handle; }
	// Returns a pointer to this app's server list
	CObList *GetServerList() { return &m_ServerList; }
	// Locks the server list
	void LockServerList() { m_ServerListCriticalSection.Lock(); }
	// Unlock the server list
	void UnlockServerList() { m_ServerListCriticalSection.Unlock(); }
	// Locks the allowed user list
	void LockAllowedUserList() { m_AllowedUserListCriticalSection.Lock(); }
	// Unlock the allowed user list
	void UnlockAllowedUserList() { m_AllowedUserListCriticalSection.Unlock(); }
	// Returns a pointer to this app's allowed user list
	CObList *GetAllowedUserList() { return &m_AllowedUserList; }
	// returns a pointer to a given CAppServer object if it is in our list
	CAppServer *FindServerByName(TCHAR *pServerName);
	// Returns TRUE if we successfully queried this application
	BOOLEAN WasQuerySuccessful() { return (m_Flags & AF_QUERYSUCCESS) > 0; }
	// Sets the query success flag
	void SetQuerySuccess() { m_Flags |= AF_QUERYSUCCESS; }
    // Returns TRUE if current flag is set
    BOOLEAN IsCurrent() { return (m_Flags & AF_CURRENT) > 0; }
    // Sets the current flag
    void SetCurrent() { m_Flags |= AF_CURRENT; }
    // Clears the current flag
    void ClearCurrent() { m_Flags &= ~AF_CURRENT; }
	// Returns TRUE if application is anonymous
	BOOLEAN IsAnonymous() { return (m_Flags & AF_ANONYMOUS) > 0; }
	// Returns TRUE if application inherits client size
	BOOLEAN InheritsClientSize() { return (m_Flags & AF_INHERIT_CLIENT_SIZE) > 0; }
	// Returns TRUE if application inherits client color
	BOOLEAN InheritsClientColors() { return (m_Flags & AF_INHERIT_CLIENT_COLORS) > 0; }
	// Returns TRUE if application wants title bar hidden
	BOOLEAN IsTitleBarHidden() { return (m_Flags & AF_HIDE_TITLE_BAR) > 0; }
	// Returns TRUE if the application wants to be maximized
	BOOLEAN IsMaximize() { return (m_Flags & AF_MAXIMIZE) > 0; }
	// Returns the Window Scale
	ULONG GetWindowScale() { return m_WindowScale; }
	// Returns the Window Width
	ULONG GetWindowWidth() { return m_WindowWidth; }
	// Returns the Window Height
	ULONG GetWindowHeight() { return m_WindowHeight; }
	// Returns the Window Color
	ULONG GetWindowColor() { return m_WindowColor; }
	// Returns the State
	APP_STATE GetState() { return m_State; }
	// Sets the State
	void SetState(APP_STATE state) { m_State = state; }
	// Checks the State
	BOOLEAN IsState(APP_STATE state) { return(m_State == state); }

private:
	void RemoveAppServer(CAppServer *pAppServer);

	static UINT BackgroundThreadProc(LPVOID);
	CWinThread *m_pBackgroundThread;
	BOOL m_BackgroundContinue;

	// Name of the published application
	TCHAR m_Name[256];
	// Handle to the tree item for this app in the tree view
	HTREEITEM m_hTreeItem;
	// List of application's server
	CObList m_ServerList;
	// Critical section for locking the server list
	CCriticalSection m_ServerListCriticalSection;
	// Critical section for locking the allowed user list
	CCriticalSection m_AllowedUserListCriticalSection;
	// List of application's allowed users
	CObList m_AllowedUserList;
	// State
	APP_STATE m_State;

	ULONG m_WindowScale;
	ULONG m_WindowWidth;
	ULONG m_WindowHeight;
	ULONG m_WindowColor;

	ULONG m_AppConfigCRC;
	ULONG m_SrvAppConfigCRC;
	ULONG m_UserAndGroupListCRC;

	// Flags
	ULONG m_Flags;
};

// AppServer flags
const ULONG ASF_NOT_RESPONDING = 0x00000001;
const ULONG ASF_UPDATE_PENDING = 0x00000002;
const ULONG ASF_ACCESS_DENIED =  0x00000004;
const ULONG ASF_IS_CURRENT_SERVER = 0x00000008;
const ULONG ASF_CURRENT = 0x00000010;

class CAppServer : public CObject
{
public:
	// Constructor
	CAppServer(PVOID pConfig, CPublishedApp *pPublishedApp);
	// Destructor
	~CAppServer();
	// Returns TRUE if this is the server that the app is being run from
	BOOL IsCurrentServer() { return ((m_Flags & ASF_IS_CURRENT_SERVER) > 0); }
	// Returns the Published App this server is associated with
	CPublishedApp *GetPublishedApp() { return m_pPublishedApp; }
	// Returns the name of the server
	TCHAR *GetName() { return m_Name; }
	// Returns the Initial Program
	TCHAR *GetInitialProgram() { return m_InitialProgram; }
	// Returns the Working Directory
	TCHAR *GetWorkDirectory() { return m_WorkDirectory; }
	// Sets the tree item
	void SetTreeItem(HTREEITEM h) { m_hTreeItem = h; }
	// Gets the tree item
	HTREEITEM GetTreeItem() { return m_hTreeItem; }
	// Sets the current flag
	void SetCurrent() { m_Flags |= ASF_CURRENT; }
	// Is the current flag set?
	BOOL IsCurrent() { return ((m_Flags & ASF_CURRENT) > 0); }
	// Clears the current flag
	void ClearCurrent() { m_Flags &= ~ASF_CURRENT; }
	// Has the configuration for this AppServer changed
	BOOL HasConfigChanged(PVOID);

private:
	CPublishedApp *m_pPublishedApp;
	TCHAR m_Name[20];
	TCHAR m_InitialProgram[257];
	TCHAR m_WorkDirectory[257];
	HTREEITEM m_hTreeItem;
	ULONG m_Flags;
};

class CAppAllowed : public CObject
{
public:
	// constructor
	CAppAllowed(TCHAR *name, AATYPE type) { wcscpy(m_Name, name);  m_Type = type; }
	AATYPE GetType() { return m_Type; }

	TCHAR m_Name[257];

private:
	AATYPE m_Type;
};

#endif  // _WAEXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winadmin.cpp ===
/*******************************************************************************
*
* winadmin.cpp
*
* Defines the class behaviors for the application.
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winadmin.cpp  $
*
*     Rev 1.6   19 Feb 1998 17:42:44   donm
*  removed latest extension DLL support
*
*     Rev 1.4   05 Nov 1997 14:31:02   donm
*  update
*
*     Rev 1.3   13 Oct 1997 22:19:42   donm
*  update
*
*     Rev 1.0   30 Jul 1997 17:13:08   butchd
*  Initial revision.
*
*******************************************************************************/

#include "stdafx.h"
#include "winadmin.h"
#include <regapi.h>

#include "mainfrm.h"
#include "admindoc.h"
#include "treeview.h"
#include "rtpane.h"
#include "blankvw.h"
#include "winsvw.h"
#include "servervw.h"
#include <winsvc.h>

#ifdef DBG
bool g_fDebug = false;
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//BOOL AreWeRunningTerminalServices(void);

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp

BEGIN_MESSAGE_MAP(CWinAdminApp, CWinApp)
        //{{AFX_MSG_MAP(CWinAdminApp)
        ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
                // NOTE - the ClassWizard will add and remove mapping macros here.
                //    DO NOT EDIT what you see in these blocks of generated code!
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp construction

CWinAdminApp::CWinAdminApp()
{
        // TODO: add construction code here,
        // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWinAdminApp object

CWinAdminApp theApp;

static TCHAR szExtensionDLLName[] = TEXT("ADMINEX.DLL");
static TCHAR szICABrowserServiceName[] = TEXT("ICABrowser");
static CHAR szStart[] = "WAExStart";
static CHAR szEnd[] = "WAExEnd";
static CHAR szServerEnumerate[] = "WAExServerEnumerate";
static CHAR szWinStationInit[] = "WAExWinStationInit";
static CHAR szWinStationInfo[] = "WAExWinStationInfo";
static CHAR szWinStationCleanup[] = "WAExWinStationCleanup";
static CHAR szServerInit[] = "WAExServerInit";
static CHAR szServerCleanup[] = "WAExServerCleanup";
static CHAR szGetServerInfo[] = "WAExGetServerInfo";
static CHAR szServerEvent[] = "WAExServerEvent";
static CHAR szGetGlobalInfo[] = "WAExGetGlobalInfo";
static CHAR szGetServerLicenses[] = "WAExGetServerLicenses";
static CHAR szGetWinStationInfo[] = "WAExGetWinStationInfo";
static CHAR szGetWinStationModules[] = "WAExGetWinStationModules";
static CHAR szFreeServerLicenses[] = "WAExFreeServerLicenses";
static CHAR szFreeWinStationModules[] = "WAExFreeWinStationModules";


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp initialization
//
BOOL CWinAdminApp::InitInstance()
{
    
#ifdef DBG

    // to avoid excessive debug spewage delete this key on checked builds

    HKEY hKey;

    LONG lStatus;
    DWORD dwDebugValue;
    DWORD dwSize = sizeof( DWORD );

    
    
    lStatus = RegOpenKeyEx( HKEY_CURRENT_USER,
        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\TSADMIN",
        0 ,
        KEY_READ,
        &hKey );

    if( lStatus == ERROR_SUCCESS )
    {
        lStatus = RegQueryValueEx( hKey ,
            L"Debug",
            NULL,
            NULL,
            ( LPBYTE )&dwDebugValue,
            &dwSize );

        if( lStatus == ERROR_SUCCESS )
        {
            if( dwDebugValue != 0 )
            {
                g_fDebug = true;
            }
        }

        RegCloseKey( hKey );
    }       

#endif
    
    
    // Read the preferences from the registry
    ReadPreferences();
    
    // Check to see if this user is an Admin
    m_Admin = TestUserForAdmin(FALSE);
    
    // Set pointers to extension DLL's procedures to NULL
    m_lpfnWAExStart = NULL;
    m_lpfnWAExEnd = NULL;
    m_lpfnWAExServerEnumerate = NULL;
    m_lpfnWAExWinStationInit = NULL;
    m_lpfnWAExWinStationCleanup = NULL;
    m_lpfnWAExServerInit = NULL;
    m_lpfnWAExServerCleanup = NULL;
    m_lpfnWAExGetServerInfo = NULL;
    m_lpfnWAExGetGlobalInfo = NULL;
    m_lpfnWAExGetServerLicenses = NULL;
    m_lpfnWAExGetWinStationInfo = NULL;
    m_lpfnWAExGetWinStationModules = NULL;
    m_lpfnWAExFreeServerLicenses = NULL;
    m_lpfnWAExFreeWinStationModules = NULL;
    
    // Check to see if we are running under Picasso
    m_Picasso = FALSE;
    
    if(IsBrowserRunning()) {
        // Attempt to load our extension DLL
        m_hExtensionDLL = LoadLibrary(szExtensionDLLName);
        if(m_hExtensionDLL) {
            // Get all the addresses of the procedures
            m_lpfnWAExStart = (LPFNEXSTARTUPPROC)::GetProcAddress(m_hExtensionDLL, szStart);
            m_lpfnWAExEnd = (LPFNEXSHUTDOWNPROC)::GetProcAddress(m_hExtensionDLL, szEnd);
            m_lpfnWAExServerEnumerate = (LPFNEXENUMERATEPROC)::GetProcAddress(m_hExtensionDLL, szServerEnumerate);
            m_lpfnWAExWinStationInit = (LPFNEXWINSTATIONINITPROC)::GetProcAddress(m_hExtensionDLL, szWinStationInit);
            m_lpfnWAExWinStationInfo = (LPFNEXWINSTATIONINFOPROC)::GetProcAddress(m_hExtensionDLL, szWinStationInfo);
            m_lpfnWAExWinStationCleanup = (LPFNEXWINSTATIONCLEANUPPROC)::GetProcAddress(m_hExtensionDLL, szWinStationCleanup);
            m_lpfnWAExServerInit = (LPFNEXSERVERINITPROC)::GetProcAddress(m_hExtensionDLL, szServerInit);
            m_lpfnWAExServerCleanup = (LPFNEXSERVERCLEANUPPROC)::GetProcAddress(m_hExtensionDLL, szServerCleanup);
            m_lpfnWAExGetServerInfo = (LPFNEXGETSERVERINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetServerInfo);
            m_lpfnWAExServerEvent = (LPFNEXSERVEREVENTPROC)::GetProcAddress(m_hExtensionDLL, szServerEvent);
            m_lpfnWAExGetGlobalInfo = (LPFNEXGETGLOBALINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetGlobalInfo);
            m_lpfnWAExGetServerLicenses = (LPFNEXGETSERVERLICENSESPROC)::GetProcAddress(m_hExtensionDLL, szGetServerLicenses);
            m_lpfnWAExGetWinStationInfo = (LPFNEXGETWINSTATIONINFOPROC)::GetProcAddress(m_hExtensionDLL, szGetWinStationInfo);
            m_lpfnWAExGetWinStationModules = (LPFNEXGETWINSTATIONMODULESPROC)::GetProcAddress(m_hExtensionDLL, szGetWinStationModules);
            m_lpfnWAExFreeServerLicenses = (LPFNEXFREESERVERLICENSESPROC)::GetProcAddress(m_hExtensionDLL, szFreeServerLicenses);
            m_lpfnWAExFreeWinStationModules = (LPFNEXFREEWINSTATIONMODULESPROC)::GetProcAddress(m_hExtensionDLL, szFreeWinStationModules);
            
            m_Picasso = TRUE;
        } else {
            // Picasso is running, but we couldn't load the extension DLL.
            // Tell the user that added functionality will not be available
            CString MessageString;
            CString TitleString;
            TitleString.LoadString(AFX_IDS_APP_TITLE);
            MessageString.LoadString(IDS_NO_EXTENSION_DLL);
            ::MessageBox(NULL, MessageString, TitleString, MB_ICONEXCLAMATION | MB_OK);
        }
    }
    
    // Get information about the WinStation we are running from
    QueryCurrentWinStation(m_CurrentWinStationName, m_CurrentUserName,
        &m_CurrentLogonId, &m_CurrentWSFlags);
    
    // Load the system console string for rapid comparison in various
    // refresh cycles.
    lstrcpy( m_szSystemConsole , L"Console" );
    /*
    LoadString( m_hInstance, IDS_SYSTEM_CONSOLE_NAME,
    m_szSystemConsole, WINSTATIONNAME_LENGTH );
    */
    
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.
    
#ifdef _AFXDLL
    Enable3dControls();                     // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();       // Call this when linking to MFC statically
#endif
    
    //      LoadStdProfileSettings();  // Load standard INI file options (including MRU)
    
    // Get the current server name
    DWORD cchBuffer = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerName(m_CurrentServerName, &cchBuffer)) {
        DWORD Error = GetLastError();
    }
    
    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.
    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CWinAdminDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        m_Picasso ? RUNTIME_CLASS(CBaseTreeView) : RUNTIME_CLASS(CAdminTreeView));
    AddDocTemplate(pDocTemplate);
    
    // Command lines switches are not used therefore we are commenting the
    // following code out to resolve BUG 536006

    // Parse command line for standard shell commands, DDE, file open
    //CCommandLineInfo cmdInfo;
    //ParseCommandLine(cmdInfo);
    
    // Dispatch commands specified on the command line
    //if (!ProcessShellCommand(cmdInfo))
    //    return FALSE;
	
    // Since ProcessShellCommand is not being used, we still need to start our app
    // the following code is taken from ProcessShellCommand MFC code
    if (!AfxGetApp()->OnCmdMsg(ID_FILE_NEW, 0, NULL, NULL))
			OnFileNew();
	
    if (m_pMainWnd == NULL)
			return FALSE;

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::ExitInstance
//
int CWinAdminApp::ExitInstance()
{
        // write out the preferences
        WritePreferences();

        // if we loaded the extension DLL, unload it
        if(m_hExtensionDLL) FreeLibrary(m_hExtensionDLL);

        return 0;
}

static TCHAR szWinAdminAppKey[] = REG_SOFTWARE_TSERVER TEXT("\\TSADMIN");
static TCHAR szPlacement[] = TEXT("Placement");
static TCHAR szPlacementFormat[] = TEXT("%u,%u,%d,%d,%d,%d,%d,%d,%d,%d");
static TCHAR szConfirmation[] = TEXT("Confirmation");
static TCHAR szSaveSettings[] = TEXT("SaveSettingsOnExit");
static TCHAR szShowSystemProcesses[] = TEXT("ShowSystemProcesses");
static TCHAR szShowAllServers[] = TEXT("ShowAllServers");
static TCHAR szListRefreshTime[] = TEXT("ListRefreshTime");
static TCHAR szStatusRefreshTime[] = TEXT("StatusRefreshTime");
static TCHAR szShadowHotkeyKey[] = TEXT("ShadowHotkeyKey");
static TCHAR szShadowHotkeyShift[] = TEXT("ShadowHotkeyShift");
static TCHAR szTreeWidth[] = TEXT("TreeWidth");


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::ReadPreferences
//
void CWinAdminApp::ReadPreferences()
{
        HKEY hKeyWinAdmin;
        DWORD dwType, cbData, dwValue;
        TCHAR szValue[128];

        // Set default values for everything
        m_Confirmation = 1;
        m_SavePreferences = 1;
        m_ProcessListRefreshTime = 5000;
        m_StatusRefreshTime = 1000;
        m_ShowSystemProcesses = TRUE;
        m_ShowAllServers = FALSE;
        m_ShadowHotkeyKey = VK_MULTIPLY;
        m_ShadowHotkeyShift = KBDCTRL;
   m_TreeWidth = 200;
        m_Placement.rcNormalPosition.right = -1;

        // Open registry key for our application
        DWORD Disposition;
        if(RegCreateKeyEx(HKEY_CURRENT_USER, szWinAdminAppKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_READ, NULL, &hKeyWinAdmin, &Disposition) != ERROR_SUCCESS) return;

        // Read the previous WINDOWPLACEMENT.
        cbData = sizeof(szValue);
        if((RegQueryValueEx(hKeyWinAdmin, szPlacement, NULL, &dwType,
                (LPBYTE)szValue, &cbData) != ERROR_SUCCESS) ||
                !(*szValue) ||
                (swscanf( szValue, szPlacementFormat,
                   &m_Placement.flags, &m_Placement.showCmd,
                   &m_Placement.ptMinPosition.x, &m_Placement.ptMinPosition.y,
                   &m_Placement.ptMaxPosition.x, &m_Placement.ptMaxPosition.y,
                   &m_Placement.rcNormalPosition.left,
                   &m_Placement.rcNormalPosition.top,
                   &m_Placement.rcNormalPosition.right,
                   &m_Placement.rcNormalPosition.bottom ) != 10) ) {
                // Flag to use the default window placement.
                m_Placement.rcNormalPosition.right = -1;
        }

        /*
         * Flag for initial showing of main window in our override of
         * CFrameWnd::ActivateFrame() (in our CMainFrame class).
         */
        m_Placement.length = (UINT)-1;

        // Read the Confirmation flag
        cbData = sizeof(m_Confirmation);
        if(RegQueryValueEx(hKeyWinAdmin, szConfirmation, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_Confirmation = dwValue;
        }

        // Read the Save Preferences flag
        cbData = sizeof(m_SavePreferences);
        if(RegQueryValueEx(hKeyWinAdmin, szSaveSettings, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_SavePreferences = dwValue;
        }

        // Read the Show System Processes flag
        cbData = sizeof(m_ShowSystemProcesses);
        if(RegQueryValueEx(hKeyWinAdmin, szShowSystemProcesses, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShowSystemProcesses = dwValue;
        }
#if 0
        // Read the Show All Servers flag
        cbData = sizeof(m_ShowAllServers);
        if(RegQueryValueEx(hKeyWinAdmin, szShowAllServers, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShowAllServers = dwValue;
        }
#endif
        // Read the Process List Refresh Time
        cbData = sizeof(m_ProcessListRefreshTime);
        if(RegQueryValueEx(hKeyWinAdmin, szListRefreshTime, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ProcessListRefreshTime = dwValue;
        }

        // Read the Status Dialog Refresh Time
        cbData = sizeof(m_StatusRefreshTime);
        if(RegQueryValueEx(hKeyWinAdmin, szStatusRefreshTime, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_StatusRefreshTime = dwValue;
        }

        // Read the Shadow Hotkey Key
        cbData = sizeof(m_ShadowHotkeyKey);
        if(RegQueryValueEx(hKeyWinAdmin, szShadowHotkeyKey, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShadowHotkeyKey = dwValue;
        }

        // Read the Shadow Hotkey Shift
        cbData = sizeof(m_ShadowHotkeyShift);
        if(RegQueryValueEx(hKeyWinAdmin, szShadowHotkeyShift, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_ShadowHotkeyShift = dwValue;
        }

        // CPR 1698: (Upgrade check for SouthBeach build 129 WINADMIN saved
        // profile).  If the m_nShadowHotkeyKey is VK_ESCAPE (no longer allowed),
        // set the hotkey to CTRL-* (the new default).
        if(m_ShadowHotkeyKey == VK_ESCAPE) {
                m_ShadowHotkeyKey = VK_MULTIPLY;
                m_ShadowHotkeyShift = KBDCTRL;
        }

        // Read the Tree Width
        cbData = sizeof(m_TreeWidth);
        if(RegQueryValueEx(hKeyWinAdmin, szTreeWidth, NULL, &dwType, (LPBYTE)&dwValue,
                                        &cbData) == ERROR_SUCCESS) {
                m_TreeWidth = dwValue;
        }

        RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminApp::ReadPreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::WritePreferences
//
void CWinAdminApp::WritePreferences()
{
        HKEY hKeyWinAdmin;
        DWORD dwValue;
        TCHAR szValue[128];

        // Open registry key for our application
        DWORD Disposition;
        if(RegCreateKeyEx(HKEY_CURRENT_USER, szWinAdminAppKey, 0, TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_WRITE, NULL, &hKeyWinAdmin, &Disposition) != ERROR_SUCCESS) return;

        // Always write the Save Settings on Exit entry
        dwValue = m_SavePreferences;
        RegSetValueEx(hKeyWinAdmin, szSaveSettings, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));


        // If the user didn't want to save settings, we're done
        if(!m_SavePreferences) {
                RegCloseKey(hKeyWinAdmin);
                return;
        }

        // Write the WINDOWPLACEMENT
        m_Placement.flags = 0;
//      if(m_pMainWnd->IsZoomed())
//              m_Placement.flags |= WPF_RESTORETOMAXIMIZED;

        wsprintf(szValue, szPlacementFormat, m_Placement.flags, m_Placement.showCmd,
                m_Placement.ptMinPosition.x, m_Placement.ptMinPosition.y,
                m_Placement.ptMaxPosition.x, m_Placement.ptMaxPosition.y,
                m_Placement.rcNormalPosition.left,
                m_Placement.rcNormalPosition.top,
                m_Placement.rcNormalPosition.right,
                m_Placement.rcNormalPosition.bottom);

        RegSetValueEx(hKeyWinAdmin, szPlacement, 0, REG_SZ,
                (LPBYTE)szValue, (lstrlen(szValue) + 1) * sizeof(TCHAR));

        // Write the Confirmation flag
        dwValue = m_Confirmation;
        RegSetValueEx(hKeyWinAdmin, szConfirmation, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Show System Processes flag
        dwValue = m_ShowSystemProcesses;
        RegSetValueEx(hKeyWinAdmin, szShowSystemProcesses, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Show All Servers flag
        dwValue = m_ShowAllServers;
        RegSetValueEx(hKeyWinAdmin, szShowAllServers, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Process List Refresh Time
        dwValue = m_ProcessListRefreshTime;
        RegSetValueEx(hKeyWinAdmin, szListRefreshTime, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Status Dialog Refresh Time
        dwValue = m_StatusRefreshTime;
        RegSetValueEx(hKeyWinAdmin, szStatusRefreshTime, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Shadow Hotkey Key
        dwValue = m_ShadowHotkeyKey;
        RegSetValueEx(hKeyWinAdmin, szShadowHotkeyKey, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Shadow Hotkey Shift state
        dwValue = m_ShadowHotkeyShift;
        RegSetValueEx(hKeyWinAdmin, szShadowHotkeyShift, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Write the Tree Width
        dwValue = m_TreeWidth;
        RegSetValueEx(hKeyWinAdmin, szTreeWidth, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

        // Close the registry key
        RegCloseKey(hKeyWinAdmin);

}       // end CWinAdminApp::WritePreferences


/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp::IsBrowserRunning
//
BOOL CWinAdminApp::IsBrowserRunning()
{
        SC_HANDLE managerHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        SC_HANDLE serviceHandle = OpenService(managerHandle, szICABrowserServiceName, SERVICE_QUERY_STATUS);

        SERVICE_STATUS serviceStatus;
        QueryServiceStatus(serviceHandle, (LPSERVICE_STATUS)&serviceStatus);

        CloseServiceHandle(serviceHandle);
        CloseServiceHandle(managerHandle);

        if(serviceStatus.dwCurrentState != SERVICE_RUNNING) return FALSE;
        else return TRUE;

}  // end CWinAdminApp::IsBrowserRunning


/*******************************************************************************
 *
 *  OnAppAbout - CWinAdminApp member function: command
 *
 *      Display the about box dialog (uses Shell32 generic About dialog).
 *
 *  ENTRY:
 *  EXIT:
 *
 ******************************************************************************/

// Typedef for the ShellAbout function
typedef void (WINAPI *LPFNSHELLABOUT)(HWND, LPCTSTR, LPCTSTR, HICON);

void CWinAdminApp::OnAppAbout()
{
    HMODULE    hMod;
    LPFNSHELLABOUT lpfn;

    if ( hMod = ::LoadLibrary( TEXT("SHELL32") ) )
    {
        if (lpfn = (LPFNSHELLABOUT)::GetProcAddress( hMod,
#ifdef UNICODE
                                                     "ShellAboutW"
#else
                                                     "ShellAboutA"
#endif // UNICODE
                                                            ))
        {
        (*lpfn)( m_pMainWnd->m_hWnd, (LPCTSTR)m_pszAppName,
                 (LPCTSTR)TEXT(""), LoadIcon(IDR_MAINFRAME) );
        }
        ::FreeLibrary(hMod);
    }
    else
    {
        ::MessageBeep( MB_ICONEXCLAMATION );
    }

}  // end CWinadminApp::OnAppAbout

/*******************************************************************************
 *
 *  AreWeRunningTerminalServices
 *
 *      Check if we are running terminal server
 *
 *  ENTRY:
 *
 *  EXIT: BOOL: True if we are running Terminal Services False if we
 *              are not running Terminal Services
 *
 *
 ******************************************************************************/
/*
BOOL AreWeRunningTerminalServices(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );

    return VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        );
}
*/

/////////////////////////////////////////////////////////////////////////////
// CWinAdminApp commands


//=---------------------------------------------------------
BEGIN_MESSAGE_MAP( CMyTabCtrl , CTabCtrl )
    ON_WM_SETFOCUS( )
END_MESSAGE_MAP( )

void CMyTabCtrl::OnSetFocus( CWnd *pOldWnd )
{
    ODS( L"CMyTabCtrl::OnSetFocus\n" );

    CWinAdminDoc *pDoc = (CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument();        

    if( pDoc != NULL )
    {
        ODS( L"\tTabctrl has focus\n" );

        pDoc->RegisterLastFocus( TAB_CTRL );
    }

    CTabCtrl::OnSetFocus( pOldWnd );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winspgs.cpp ===
/*******************************************************************************
*
* winspgs.cpp
*
* implementations for the WinStation info pages
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winspgs.cpp  $
*  
*     Rev 1.5   25 Apr 1998 14:32:24   donm
*  removed hardcoded 'bytes'
*  
*     Rev 1.4   16 Feb 1998 16:03:32   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.3   03 Nov 1997 15:18:36   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:39:04   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:15:50   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:13:38   butchd
*  Initial revision.
*  
*******************************************************************************/

#include "stdafx.h"
#include "afxpriv.h"
#include "winadmin.h"
#include "admindoc.h"
#include "winspgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////
// MESSAGE MAP: CWinStationInfoPage
//
IMPLEMENT_DYNCREATE(CWinStationInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationInfoPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationInfoPage)
    //ON_WM_SETFOCUS( )
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP1,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationInfoPage ctor
//
CWinStationInfoPage::CWinStationInfoPage()
	: CAdminPage(CWinStationInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationInfoPage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;

}  // end CWinStationInfoPage ctor

/*
void CWinStationInfoPage::OnSetFocus( )
{

  */
/////////////////////////////
// F'N: CWinStationInfoPage dtor
//
CWinStationInfoPage::~CWinStationInfoPage()
{

}  // end CWinStationInfoPage dtor


////////////////////////////////////////
// F'N: CWinStationInfoPage::DoDataExchange
//
void CWinStationInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationInfoPage)
	//}}AFX_DATA_MAP

}  // end CWinStationInfoPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationInfoPage::AssertValid
//
void CWinStationInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationInfoPage::AssertValid


//////////////////////////////
// F'N: CWinStationInfoPage::Dump
//
void CWinStationInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationInfoPage::Dump

#endif //_DEBUG

//////////////////////////////
// F'N: CWinStationInfoPage::OnCommandHelp
//
void CWinStationInfoPage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CWinStationInfoPage::IDD + HID_BASE_RESOURCE);
}  // end CWinStationInfoPage::OnCommandHelp

//////////////////////////////
// F'N: CWinStationInfoPage::OnInitialUpdate
//
void CWinStationInfoPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();    

}  // end CWinStationInfoPage::OnInitialUpdate


//////////////////////////////
// F'N: CWinStationInfoPage::OnSize
//
void CWinStationInfoPage::OnSize(UINT nType, int cx, int cy) 
{

	//CFormView::OnSize(nType, cx, cy);
    

}  // end CWinStationInfoPage::OnSize


//////////////////////////////
// F'N: CWinStationInfoPage::Reset
//
void CWinStationInfoPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayInfo();

}  // end CWinStationInfoPage::Reset


/////////////////////////////////////
// F'N: CWinStationInfoPage::DisplayInfo
//
//
void CWinStationInfoPage::DisplayInfo()
{
	// We don't want to display info for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	SetDlgItemText(IDC_WS_INFO_USERNAME, m_pWinStation->GetUserName());
	SetDlgItemText(IDC_WS_INFO_CLIENTNAME, m_pWinStation->GetClientName());

	CString BuildString;
	BuildString.Format(TEXT("%lu"), m_pWinStation->GetClientBuildNumber());
	SetDlgItemText(IDC_WS_INFO_BUILD, BuildString);

	SetDlgItemText(IDC_WS_INFO_DIR, m_pWinStation->GetClientDir());

	CString IDString;
	IDString.Format(TEXT("%u"), m_pWinStation->GetClientProductId());
	SetDlgItemText(IDC_WS_INFO_PRODUCT_ID, IDString);

	IDString.Format(TEXT("%lu"), m_pWinStation->GetClientSerialNumber());
	SetDlgItemText(IDC_WS_INFO_SERIAL_NUMBER, IDString);

	SetDlgItemText(IDC_WS_INFO_ADDRESS, m_pWinStation->GetClientAddress());

	CString BufferString;
	CString FormatString;
	FormatString.LoadString(IDS_BUFFERS_FORMAT);
	
	BufferString.Format(FormatString, m_pWinStation->GetHostBuffers(), m_pWinStation->GetBufferLength());
	SetDlgItemText(IDC_WS_INFO_SERVER_BUFFERS, BufferString);

	BufferString.Format(FormatString, m_pWinStation->GetClientBuffers(), m_pWinStation->GetBufferLength());
	SetDlgItemText(IDC_WS_INFO_CLIENT_BUFFERS, BufferString);

	SetDlgItemText(IDC_WS_INFO_MODEM_NAME, m_pWinStation->GetModemName());
	SetDlgItemText(IDC_WS_INFO_CLIENT_LICENSE, m_pWinStation->GetClientLicense());

	SetDlgItemText(IDC_WS_INFO_COLOR_DEPTH, m_pWinStation->GetColors());

	IDString.Format(IDS_CLIENT_RESOLUTION, m_pWinStation->GetHRes(), m_pWinStation->GetVRes());
	SetDlgItemText(IDC_WS_INFO_RESOLUTION, IDString);

	if(!m_pWinStation->GetEncryptionLevelString(&BuildString)) {
		BuildString.LoadString(IDS_NOT_APPLICABLE);
	}

	SetDlgItemText(IDC_ENCRYPTION_LEVEL, BuildString);
    

}  // end CWinStationInfoPage::DisplayInfo


////////////////////////////////
// MESSAGE MAP: CWinStationNoInfoPage
//
IMPLEMENT_DYNCREATE(CWinStationNoInfoPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationNoInfoPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationNoInfoPage)
    ON_WM_SIZE( )
    ON_WM_SETFOCUS( )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//=---------------------------------------------------
void CWinStationNoInfoPage::OnSetFocus( CWnd * pOld )
{
    ODS( L"CWinStationNoInfoPage::OnSetFocus\n" );

    CWnd::OnSetFocus( pOld );
}

/////////////////////////////
// F'N: CWinStationNoInfoPage ctor
//
CWinStationNoInfoPage::CWinStationNoInfoPage()
	: CAdminPage(CWinStationNoInfoPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationNoInfoPage)
	//}}AFX_DATA_INIT

}  // end CWinStationNoInfoPage ctor

void CWinStationNoInfoPage::OnSize( UINT nType, int cx, int cy) 
{
    //eat it.
}

/////////////////////////////
// F'N: CWinStationNoInfoPage dtor
//
CWinStationNoInfoPage::~CWinStationNoInfoPage()
{
}  // end CWinStationNoInfoPage dtor


////////////////////////////////////////
// F'N: CWinStationNoInfoPage::DoDataExchange
//
void CWinStationNoInfoPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationNoInfoPage)
	//}}AFX_DATA_MAP

}  // end CWinStationNoInfoPage::DoDataExchange

#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationNoInfoPage::AssertValid
//
void CWinStationNoInfoPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationNoInfoPage::AssertValid


//////////////////////////////
// F'N: CWinStationNoInfoPage::Dump
//
void CWinStationNoInfoPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationNoInfoPage::Dump

#endif //_DEBUG


////////////////////////////////
// MESSAGE MAP: CWinStationModulesPage
//
IMPLEMENT_DYNCREATE(CWinStationModulesPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationModulesPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationModulesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_MODULE_LIST, OnColumnClick)
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_MODULE_LIST, OnSetfocusModuleList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationModulesPage ctor
//
CWinStationModulesPage::CWinStationModulesPage()
	: CAdminPage(CWinStationModulesPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationModulesPage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;
    m_bSortAscending = TRUE;
	m_pExtModuleInfo = NULL;

}  // end CWinStationModulesPage ctor


/////////////////////////////
// F'N: CWinStationModulesPage dtor
//
CWinStationModulesPage::~CWinStationModulesPage()
{
	if(m_pExtModuleInfo) delete[] m_pExtModuleInfo;

}  // end CWinStationModulesPage dtor


////////////////////////////////////////
// F'N: CWinStationModulesPage::DoDataExchange
//
void CWinStationModulesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationModulesPage)
	DDX_Control(pDX, IDC_WINSTATION_MODULE_LIST, m_ModuleList);	
	//}}AFX_DATA_MAP

}  // end CWinStationModulesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationModulesPage::AssertValid
//
void CWinStationModulesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationModulesPage::AssertValid


//////////////////////////////
// F'N: CWinStationModulesPage::Dump
//
void CWinStationModulesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationModulesPage::Dump

#endif //_DEBUG


static ColumnDef ModuleColumns[] = {
{	IDS_COL_FILENAME,				LVCFMT_LEFT,	150 },
{	IDS_COL_FILEDATETIME,			LVCFMT_LEFT,	100 },
{	IDS_COL_SIZE,					LVCFMT_RIGHT,	100 },
{	IDS_COL_VERSIONS,				LVCFMT_RIGHT,	60	}
};

#define NUM_MODULE_COLUMNS sizeof(ModuleColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CWinStationModulesPage::OnInitialUpdate
//
void CWinStationModulesPage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

	BuildImageList();		// builds the image list for the list control

	CString columnString;
	for(int col = 0; col < NUM_MODULE_COLUMNS; col++) {
		columnString.LoadString(ModuleColumns[col].stringID);
		m_ModuleList.InsertColumn(col, columnString, ModuleColumns[col].format, ModuleColumns[col].width, col);
	}

	m_CurrentSortColumn = MODULES_COL_FILENAME;

}  // end CWinStationModulesPage::OnInitialUpdate


/////////////////////////////////////
// F'N: CWinStationModulesPage::BuildImageList
//
// - calls m_imageList.Create(..) to create the image list
// - calls AddIconToImageList(..) to add the icons themselves and save
//   off their indices
// - attaches the image list to the list ctrl
//
void CWinStationModulesPage::BuildImageList()
{
	m_imageList.Create(16, 16, TRUE, 1, 0);

	m_idxBlank  = AddIconToImageList(IDI_BLANK);
	
	m_ModuleList.SetImageList(&m_imageList, LVSIL_SMALL);

}  // end CWinStationModulesPage::BuildImageList


/////////////////////////////////////////
// F'N: CWinStationModulesPage::AddIconToImageList
//
// - loads the appropriate icon, adds it to m_imageList, and returns
//   the newly-added icon's index in the image list
//
int CWinStationModulesPage::AddIconToImageList(int iconID)
{
	HICON hIcon = ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(iconID));
	return m_imageList.Add(hIcon);

}  // end CWinStationModulesPage::AddIconToImageList


//////////////////////////////
// F'N: CWinStationModulesPage::OnColumnClick
//
void CWinStationModulesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_WINSTATION, PAGE_WS_MODULES, &m_ModuleList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CWinStationModulesPage::OnColumnClick


//////////////////////////////
// F'N: CWinStationModulesPage::OnSetfocusModuleList
//
void CWinStationModulesPage::OnSetfocusModuleList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_ModuleList.Invalidate();	
	*pResult = 0;

}	// end CWinStationModulesPage::OnSetfocusModuleList


//////////////////////////////
// F'N: CWinStationModulesPage::OnSize
//
void CWinStationModulesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	if(m_ModuleList.GetSafeHwnd())
		m_ModuleList.MoveWindow(&rect, TRUE);

	//CFormView::OnSize(nType, cx, cy);

}  // end CWinStationModulesPage::OnSize


//////////////////////////////
// F'N: CWinStationModulesPage::Reset
//
void CWinStationModulesPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	if(m_pExtModuleInfo) delete[] m_pExtModuleInfo;
	m_pExtModuleInfo = NULL;

	DisplayModules();

}  // end CWinStationModulesPage::Reset


/////////////////////////////////////
// F'N: CWinStationModulesPage::DisplayModules
//
//
void CWinStationModulesPage::DisplayModules()
{
	// We don't want to display modules for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	// Clear out the list control
	m_ModuleList.DeleteAllItems();

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	// If this is an ICA WinStation, display the module information
	if(m_pWinStation->GetExtendedInfo()) {
		ExtModuleInfo *pExtModuleInfo = m_pWinStation->GetExtModuleInfo();
		if(pExtModuleInfo) {
			ULONG NumModules = m_pWinStation->GetNumModules();
			ExtModuleInfo *pModule = pExtModuleInfo;

			for(ULONG module = 0; module < NumModules; module++) {
				// Filename - put at the end of the list
				int item = m_ModuleList.InsertItem(m_ModuleList.GetItemCount(), pModule->Name, m_idxBlank);

				// File date and time
				FILETIME fTime;
				TCHAR szDateTime[MAX_DATE_TIME_LENGTH];
				if(!DosDateTimeToFileTime(pModule->Date, pModule->Time, &fTime))
					wcscpy(szDateTime, TEXT("              "));
				else
					DateTimeString((LARGE_INTEGER *)&fTime, szDateTime);

				m_ModuleList.SetItemText(item, MODULES_COL_FILEDATETIME, szDateTime);

				// File size
				CString SizeString;
				if(pModule->Size) SizeString.Format(TEXT("%lu"), pModule->Size);
				else SizeString.LoadString(IDS_EMBEDDED);
				m_ModuleList.SetItemText(item, MODULES_COL_SIZE, SizeString);

				// Versions
				CString VersionString;
				VersionString.Format(TEXT("%u - %u"), pModule->LowVersion, pModule->HighVersion);
				m_ModuleList.SetItemText(item, MODULES_COL_VERSIONS, VersionString);

				m_ModuleList.SetItemData(item, (DWORD_PTR)pModule);
				pModule++;
			}
		}		
	}

}  // end CWinStationModulesPage::DisplayModules


////////////////////////////////
// MESSAGE MAP: CWinStationProcessesPage
//
IMPLEMENT_DYNCREATE(CWinStationProcessesPage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationProcessesPage, CFormView)
	//{{AFX_MSG_MAP(CWinStationProcessesPage)
	ON_WM_SIZE()
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_WINSTATION_PROCESS_LIST, OnColumnClick)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_WINSTATION_PROCESS_LIST, OnProcessItemChanged)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY(NM_SETFOCUS, IDC_WINSTATION_PROCESS_LIST, OnSetfocusWinstationProcessList)
    // ON_NOTIFY(NM_KILLFOCUS , IDC_WINSTATION_PROCESS_LIST , OnKillFocusWinstationProcessList )
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////
// F'N: CWinStationProcessesPage ctor
//
CWinStationProcessesPage::CWinStationProcessesPage()
	: CAdminPage(CWinStationProcessesPage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationProcessesPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;
    m_bSortAscending = TRUE;

}  // end CWinStationProcessesPage ctor


/////////////////////////////
// F'N: CWinStationProcessesPage dtor
//
CWinStationProcessesPage::~CWinStationProcessesPage()
{
}  // end CWinStationProcessesPage dtor


////////////////////////////////////////
// F'N: CWinStationProcessesPage::DoDataExchange
//
void CWinStationProcessesPage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationProcessesPage)
	DDX_Control(pDX, IDC_WINSTATION_PROCESS_LIST, m_ProcessList);
	//}}AFX_DATA_MAP

}  // end CWinStationProcessesPage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationProcessesPage::AssertValid
//
void CWinStationProcessesPage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationProcessesPage::AssertValid


//////////////////////////////
// F'N: CWinStationProcessesPage::Dump
//
void CWinStationProcessesPage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationProcessesPage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CWinStationProcessesPage::OnSize
//
void CWinStationProcessesPage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

    

	rect.top += LIST_TOP_OFFSET;

	if(m_ProcessList.GetSafeHwnd())
		m_ProcessList.MoveWindow(&rect, TRUE);

    //CFormView::OnSize(nType, cx, cy);

	

}  // end CWinStationProcessesPage::OnSize


static ColumnDef ProcColumns[] = {
    CD_PROC_ID,
    CD_PROC_PID,
    CD_PROC_IMAGE
};

#define NUM_PROC_COLUMNS sizeof(ProcColumns)/sizeof(ColumnDef)

//////////////////////////////
// F'N: CWinStationProcessesPage::OnInitialUpdate
//
void CWinStationProcessesPage::OnInitialUpdate() 
{
	// Call the parent class
	CFormView::OnInitialUpdate();

	CString columnString;

	for(int col = 0; col < NUM_PROC_COLUMNS; col++) {
		columnString.LoadString(ProcColumns[col].stringID);
		m_ProcessList.InsertColumn(col, columnString, ProcColumns[col].format, ProcColumns[col].width, col);
	}

	m_CurrentSortColumn = WS_PROC_COL_ID;

	// This is a major kludge!!!!
	// This is the last view created
	// We want to tell the document that all the
	// views have been created.
	// This is to allow background threads to start
	// doing their thing.
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SetMainWnd(AfxGetMainWnd());
	((CWinAdminDoc*)((CWinAdminApp*)AfxGetApp())->GetDocument())->SetAllViewsReady();

}  // end CWinStationProcessesPage::OnInitialUpdate


//////////////////////////////
// F'N: CWinStationProcessesPage::Reset
//
void CWinStationProcessesPage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayProcesses();

}  // end CWinStationProcessesPage::Reset


//////////////////////////////
// F'N: CWinStationProcessesPage::UpdateProcesses
//
void CWinStationProcessesPage::UpdateProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();
	BOOL bAnyChanged = FALSE;
	BOOL bAnyAdded = FALSE;

	CServer *pServer = m_pWinStation->GetServer();

	// Loop through the processes
	pServer->LockProcessList();
	CObList *pProcessList = pServer->GetProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers())
			continue;

		// We only want to show process for this WinStation
		if(pProcess->GetLogonId() == m_pWinStation->GetLogonId()) {
			// If the process is new, add it to the list
			if(pProcess->IsNew()) {
				AddProcessToList(pProcess);
				bAnyAdded = TRUE;
				continue;
			}

			LV_FINDINFO FindInfo;
			FindInfo.flags = LVFI_PARAM;
			FindInfo.lParam = (LPARAM)pProcess;

			// Find the Process in our list
			int item = m_ProcessList.FindItem(&FindInfo, -1);

			// If the process is no longer current,
			// remove it from the list
			if(!pProcess->IsCurrent() && item != -1) {
				// Remove the Process from the list
				m_ProcessList.DeleteItem(item);
			}
		}
	}

	pServer->UnlockProcessList();

	if(bAnyChanged || bAnyAdded) SortByColumn(VIEW_WINSTATION, PAGE_WS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

}  // end CWinStationProcessesPage::UpdateProcesses


//////////////////////////////////////////
// F'N: CWinStationProcessesPage::RemoveProcess
//
void CWinStationProcessesPage::RemoveProcess(CProcess *pProcess)
{
	// Find out how many items in the list
	int ItemCount = m_ProcessList.GetItemCount();

	// Go through the items and remove this process
	for(int item = 0; item < ItemCount; item++) {
		CProcess *pListProcess = (CProcess*)m_ProcessList.GetItemData(item);
		
		if(pListProcess == pProcess) {
			m_ProcessList.DeleteItem(item);
			break;
		}
	}

}   // end CWinStationProcessPage::RemoveProcess


//////////////////////////////
// F'N: CWinStationProcessesPage::AddProcessToList
//
int CWinStationProcessesPage::AddProcessToList(CProcess *pProcess)
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	// ID
	CString ProcString;
	ProcString.Format(TEXT("%lu"), pProcess->GetLogonId());
	int item = m_ProcessList.InsertItem(m_ProcessList.GetItemCount(), ProcString, NULL);

	// PID
	ProcString.Format(TEXT("%lu"), pProcess->GetPID());
	m_ProcessList.SetItemText(item, WS_PROC_COL_PID, ProcString);

	// Image
	m_ProcessList.SetItemText(item, WS_PROC_COL_IMAGE, pProcess->GetImageName());

	m_ProcessList.SetItemData(item, (DWORD_PTR)pProcess);
	
	return item;

}  // end CWinStationProcessesPage::AddProcessToList


/////////////////////////////////////
// F'N: CWinStationProcessesPage::DisplayProcesses
//
void CWinStationProcessesPage::DisplayProcesses()
{
	CWinAdminApp *pApp = (CWinAdminApp*)AfxGetApp();

	// Clear out the list control
	m_ProcessList.DeleteAllItems();

	CServer *pServer = m_pWinStation->GetServer();

	pServer->EnumerateProcesses();
	CObList *pProcessList = pServer->GetProcessList();
	pServer->LockProcessList();

	POSITION pos = pProcessList->GetHeadPosition();

	while(pos) {
		CProcess *pProcess = (CProcess*)pProcessList->GetNext(pos);

		// If this is a 'system' process and we aren't currently showing them,
		// go to the next process
		if(pProcess->IsSystemProcess() && !pApp->ShowSystemProcesses())
			continue;

		// If this user is not an Admin, don't show him someone else's processes
		if(!pApp->IsUserAdmin() && !pProcess->IsCurrentUsers())
			continue;

		// We only want to show process for this WinStation
		if(pProcess->GetLogonId() == m_pWinStation->GetLogonId()) {
	
			AddProcessToList(pProcess);
		}
	}

    m_ProcessList.SetItemState( 0 , LVIS_FOCUSED | LVIS_SELECTED , LVIS_FOCUSED | LVIS_SELECTED );
	
	pServer->UnlockProcessList();
	
}  // end CWinStationProcessesPage::DisplayProcesses


//////////////////////////////
// F'N: CWinStationProcessesPage::OnProcessItemChanged
//
void CWinStationProcessesPage::OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW *pLV = (NM_LISTVIEW*)pNMHDR;
	
	if(pLV->uNewState & LVIS_SELECTED) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->SetSelected();
	}
	
	if(pLV->uOldState & LVIS_SELECTED && !(pLV->uNewState & LVIS_SELECTED)) {
		CProcess *pProcess = (CProcess*)m_ProcessList.GetItemData(pLV->iItem);
		pProcess->ClearSelected();
	}

	*pResult = 0;

}  // end CWinStationProcessesPage::OnProcessItemChanged


//////////////////////////////
// F'N: CWinStationProcessesPage::OnColumnClick
//
void CWinStationProcessesPage::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here

    // If the sort column hasn't changed, flip the ascending mode.
    if(m_CurrentSortColumn == pNMListView->iSubItem)
        m_bSortAscending = !m_bSortAscending;
    else    // New sort column, start in ascending mode
        m_bSortAscending = TRUE;

	m_CurrentSortColumn = pNMListView->iSubItem;
	SortByColumn(VIEW_WINSTATION, PAGE_WS_PROCESSES, &m_ProcessList, m_CurrentSortColumn, m_bSortAscending);

	*pResult = 0;

}  // end CWinStationProcessesPage::OnColumnClick


//////////////////////////////
// F'N: CWinStationProcessesPage::OnContextMenu
//
void CWinStationProcessesPage::OnContextMenu(CWnd* pWnd, CPoint ptScreen) 
{
	// TODO: Add your message handler code here
	UINT flags;
	UINT Item;
	CPoint ptClient = ptScreen;
	ScreenToClient(&ptClient);

	// If we got here from the keyboard,
	if(ptScreen.x == -1 && ptScreen.y == -1) {
		
		UINT iCount = m_ProcessList.GetItemCount( );
		
		RECT rc;

		for( Item = 0 ; Item < iCount ; Item++ )
		{
			if( m_ProcessList.GetItemState( Item , LVIS_SELECTED ) == LVIS_SELECTED )
			{
				m_ProcessList.GetItemRect( Item , &rc , LVIR_ICON );

				ptScreen.x = rc.left;

				ptScreen.y = rc.bottom + 5;

				ClientToScreen( &ptScreen );

				break;
			}
		}

		if(ptScreen.x == -1 && ptScreen.y == -1) 
		{
			return;
		}
		/*
		RECT rect;
		m_ProcessList.GetClientRect(&rect);
		ptScreen.x = (rect.right - rect.left) / 2;
		ptScreen.y = (rect.bottom - rect.top) / 2;
		ClientToScreen(&ptScreen);
		*/
	}
	else {
		Item = m_ProcessList.HitTest(ptClient, &flags);
		if((Item == 0xFFFFFFFF) || !(flags & LVHT_ONITEM))
			return;
	}

	CMenu menu;
	menu.LoadMenu(IDR_PROCESS_POPUP);
	menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON |
			TPM_RIGHTBUTTON, ptScreen.x, ptScreen.y, AfxGetMainWnd());
	menu.DestroyMenu();
	
}  // end CServerProcessesPage::OnContextMenu


void CWinStationProcessesPage::OnSetfocusWinstationProcessList(NMHDR* pNMHDR, LRESULT* pResult) 
{	
    ODS( L"CWinStationProcessesPage::OnSetfocusWinstationProcessList\n");

	CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

    m_ProcessList.Invalidate( );

    pDoc->RegisterLastFocus( PAGED_ITEM );

    *pResult = 0;
}

void CWinStationProcessesPage::OnKillFocusWinstationProcessList( NMHDR* , LRESULT* pResult) 
{
    m_ProcessList.Invalidate( );

    *pResult = 0;
}


////////////////////////////////
// MESSAGE MAP: CWinStationCachePage
//
IMPLEMENT_DYNCREATE(CWinStationCachePage, CFormView)

BEGIN_MESSAGE_MAP(CWinStationCachePage, CFormView)
	//{{AFX_MSG_MAP(CWinStationCachePage)
	ON_WM_SIZE()
	ON_COMMAND(ID_HELP1,OnCommandHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////
// F'N: CWinStationCachePage ctor
//
CWinStationCachePage::CWinStationCachePage()
	: CAdminPage(CWinStationCachePage::IDD)
{
	//{{AFX_DATA_INIT(CWinStationCachePage)
	//}}AFX_DATA_INIT

    m_pWinStation = NULL;

}  // end CWinStationCachePage ctor


/////////////////////////////
// F'N: CWinStationCachePage dtor
//
CWinStationCachePage::~CWinStationCachePage()
{
}  // end CWinStationCachePage dtor


////////////////////////////////////////
// F'N: CWinStationCachePage::DoDataExchange
//
void CWinStationCachePage::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWinStationCachePage)
	//}}AFX_DATA_MAP

}  // end CWinStationCachePage::DoDataExchange


#ifdef _DEBUG
/////////////////////////////////////
// F'N: CWinStationCachePage::AssertValid
//
void CWinStationCachePage::AssertValid() const
{
	CFormView::AssertValid();

}  // end CWinStationCachePage::AssertValid


//////////////////////////////
// F'N: CWinStationCachePage::Dump
//
void CWinStationCachePage::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);

}  // end CWinStationCachePage::Dump

#endif //_DEBUG


//////////////////////////////
// F'N: CWinStationCachePage::OnInitialUpdate
//
void CWinStationCachePage::OnInitialUpdate() 
{
	CFormView::OnInitialUpdate();

}  // end CWinStationCachePage::OnInitialUpdate

//////////////////////////////
// F'N: CWinStationCachePage::OnCommandHelp
//
void CWinStationCachePage::OnCommandHelp(void)
{
	AfxGetApp()->WinHelp(CWinStationCachePage::IDD + HID_BASE_RESOURCE);
 
}  // end CWinStationCachePage::OnCommandHelp

//////////////////////////////
// F'N: CWinStationCachePage::OnSize
//
void CWinStationCachePage::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;
	GetClientRect(&rect);

	rect.top += LIST_TOP_OFFSET;

	// CFormView::OnSize(nType, cx, cy);
}  // end CWinStationCachePage::OnSize


//////////////////////////////
// F'N: CWinStationCachePage::Reset
//
void CWinStationCachePage::Reset(void *pWinStation)
{
	m_pWinStation = (CWinStation*)pWinStation;
	DisplayCache();

}  // end CWinStationCachePage::Reset


/////////////////////////////////////
// F'N: CWinStationCachePage::DisplayCache
//
//
void CWinStationCachePage::DisplayCache()
{
	// We don't want to display info for the console
	// Even though this page is not shown for the console,
	// Reset() is still called and therefore, so is this function
	if(m_pWinStation->IsSystemConsole()) return;

	if(!m_pWinStation->AdditionalDone()) m_pWinStation->QueryAdditionalInformation();

	ExtWinStationInfo *pExtWinStationInfo = m_pWinStation->GetExtendedInfo();

	if(pExtWinStationInfo)
	{
		CString IDString;
		IDString.Format(IDS_CLIENT_CACHE, 
			(pExtWinStationInfo->CacheTiny + pExtWinStationInfo->CacheLowMem) / 1024,
			pExtWinStationInfo->CacheTiny / 1024,
			pExtWinStationInfo->CacheXms / 1024,
			pExtWinStationInfo->CacheDASD / 1024);

		SetDlgItemText(IDC_WS_INFO_CACHE, IDString);

		// divide by 1024 to get Megabytes
		FLOAT DimCacheSize = (FLOAT)(pExtWinStationInfo->DimCacheSize / 1024);
		// If it is more than a Gigabyte, we need to divide by 1024 again
		if(DimCacheSize > 1024*1024) {
			IDString.Format(TEXT("%3.2fGB"), DimCacheSize / (1024*1024));
		}
		else if(DimCacheSize > 1024) {
			IDString.Format(TEXT("%3.2fMB"), DimCacheSize / 1024);
		}
		else if(DimCacheSize) {
			IDString.Format(TEXT("%fKB"), DimCacheSize);
		}
		else IDString.LoadString(IDS_NONE);

		SetDlgItemText(IDC_BITMAP_SIZE, IDString);

		IDString.Format(TEXT("%luK"), pExtWinStationInfo->DimBitmapMin / 1024);
		SetDlgItemText(IDC_BITMAP_MINIMUM, IDString);
	
		IDString.Format(TEXT("%lu"), pExtWinStationInfo->DimSignatureLevel);
		SetDlgItemText(IDC_BITMAP_SIG_LEVEL, IDString);
	}

}  // end CWinStationCachePage::DisplayCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winspgs.h ===
/*******************************************************************************
*
* winspgs.h
*
* - declarations for the WinStation info pages
* - the server info pages are all CFormView derivatives
*   based on dialog templates
*
* copyright notice: Copyright 1997, Citrix Systems Inc.
* Copyright (c) 1998 - 1999 Microsoft Corporation
*
* $Author:   donm  $  Don Messerli
*
* $Log:   N:\nt\private\utils\citrix\winutils\tsadmin\VCS\winspgs.h  $
*  
*     Rev 1.4   16 Feb 1998 16:03:40   donm
*  modifications to support pICAsso extension
*  
*     Rev 1.3   03 Nov 1997 15:18:38   donm
*  Added descending sort
*  
*     Rev 1.2   13 Oct 1997 18:39:08   donm
*  update
*  
*     Rev 1.1   26 Aug 1997 19:15:54   donm
*  bug fixes/changes from WinFrame 1.7
*  
*     Rev 1.0   30 Jul 1997 17:13:42   butchd
*  Initial revision.
*  
*******************************************************************************/

#ifndef _WINSTATIONPAGES_H
#define _WINSTATIONPAGES_H

#include "Resource.h"
#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "winadmin.h"

//////////////////////////
// CLASS: CWinStationInfoPage
//
class CWinStationInfoPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationInfoPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationInfoPage)
	enum { IDD = IDD_WINSTATION_INFO };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info

// Operations
public:

private:
	void DisplayInfo();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationInfoPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationInfoPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationInfoPage


//////////////////////////
// CLASS: CWinStationModulesPage
//
class CWinStationModulesPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationModulesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationModulesPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationModulesPage)
	enum { IDD = IDD_WINSTATION_MODULES };
	CListCtrl	m_ModuleList;
	//}}AFX_DATA

// Attributes
public:

protected:
	CImageList m_imageList;	// image list associated with the tree control

	int m_idxBlank;		// index of Blank image
	int m_idxArrow;		// index of Arrow image

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;
	ExtModuleInfo *m_pExtModuleInfo;

// Operations
public:

private:
	int  AddIconToImageList(int);	// adds an icon's image to the image list and returns the image's index
	void BuildImageList();			// builds the image list;
	void DisplayModules();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationModulesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationModulesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationModulesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetfocusModuleList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationModulesPage


//////////////////////////
// CLASS: CWinStationNoInfoPage
//
class CWinStationNoInfoPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationNoInfoPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationNoInfoPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationInfoPage)
	enum { IDD = IDD_WINSTATION_NOINFO };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	
// Operations
public:

private:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationInfoPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationNoInfoPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationNoInfoPage)
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnSetFocus( CWnd * );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationNoInfoPage


//////////////////////////
// CLASS: CWinStationProcessesPage
//
class CWinStationProcessesPage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationProcessesPage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationProcessesPage)

// Form Data
public:
	//{{AFX_DATA(CWinStationProcessesPage)
	enum { IDD = IDD_WINSTATION_PROCESSES };
	CListCtrl	m_ProcessList;
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info
	int m_CurrentSortColumn;
    BOOL m_bSortAscending;

// Operations
public:
	void UpdateProcesses();
	void RemoveProcess(CProcess *pProcess);

private:
	void DisplayProcesses();			
	virtual void Reset(void *pWinStation);
	int AddProcessToList(CProcess *pProcess);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationProcessesPage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationProcessesPage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationProcessesPage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnProcessItemChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSetfocusWinstationProcessList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnKillFocusWinstationProcessList( NMHDR* pNMHDR, LRESULT* pResult );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationProcessesPage


//////////////////////////
// CLASS: CWinStationCachePage
//
class CWinStationCachePage : public CAdminPage
{
friend class CWinStationView;

protected:
	CWinStationCachePage();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationCachePage)

// Form Data
public:
	//{{AFX_DATA(CWinStationCachePage)
	enum { IDD = IDD_WINSTATION_CACHE };
	//}}AFX_DATA

// Attributes
public:

protected:

private:
	CWinStation* m_pWinStation;	// pointer to current WinStation's info

// Operations
public:

private:
	void DisplayCache();			
	virtual void Reset(void *pWinStation);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationCachePage)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationCachePage();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CWinStationCachePage)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnCommandHelp(void);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationCachePage

#endif  // _SERVERPAGES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winsvw.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* winsvw.cpp
*
* implementation of the CWinStationView class
*
*  
*******************************************************************************/

#include "stdafx.h"
#include "resource.h"
#include "winsvw.h"
#include "admindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//////////////////////////
// MESSAGE MAP: CWinStationView
//
IMPLEMENT_DYNCREATE(CWinStationView, CView)

BEGIN_MESSAGE_MAP(CWinStationView, CView)
	//{{AFX_MSG_MAP(CWinStationView)
	ON_WM_SIZE()
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	ON_MESSAGE(WM_ADMIN_UPDATE_PROCESSES, OnAdminUpdateProcesses)
	ON_MESSAGE(WM_ADMIN_REMOVE_PROCESS, OnAdminRemoveProcess)
	ON_MESSAGE(WM_ADMIN_REDISPLAY_PROCESSES, OnAdminRedisplayProcesses)
	ON_NOTIFY(TCN_SELCHANGE, IDC_WINSTATION_TABS, OnTabSelChange)
    ON_MESSAGE( WM_ADMIN_TABBED_VIEW , OnTabbed )
    ON_MESSAGE( WM_ADMIN_SHIFTTABBED_VIEW , OnShiftTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLTABBED_VIEW , OnCtrlTabbed )
    ON_MESSAGE( WM_ADMIN_CTRLSHIFTTABBED_VIEW , OnCtrlShiftTabbed )
    ON_MESSAGE( WM_ADMIN_NEXTPANE_VIEW , OnNextPane )

END_MESSAGE_MAP()


PageDef CWinStationView::pages[NUMBER_OF_WINS_PAGES] = {
	{ NULL, RUNTIME_CLASS( CWinStationProcessesPage ),	IDS_TAB_PROCESSES,	PAGE_WS_PROCESSES,	NULL },
	{ NULL, RUNTIME_CLASS( CWinStationInfoPage ),		IDS_TAB_INFORMATION,PAGE_WS_INFO,		NULL },
	{ NULL, RUNTIME_CLASS( CWinStationModulesPage ),	IDS_TAB_MODULES,	PAGE_WS_MODULES,	PF_PICASSO_ONLY },
	{ NULL, RUNTIME_CLASS( CWinStationCachePage ),		IDS_TAB_CACHE,		PAGE_WS_CACHE,		PF_PICASSO_ONLY },
	{ NULL, RUNTIME_CLASS( CWinStationNoInfoPage ),		0,					PAGE_WS_NO_INFO,	PF_NO_TAB },
};


///////////////////////
// F'N: CWinStationView ctor
//
CWinStationView::CWinStationView()
{
	m_pTabs       = NULL;
	m_pTabFont    = NULL;

	m_CurrPage = PAGE_WS_PROCESSES;

}  // end CWinStationView ctor


///////////////////////
// F'N: CWinStationView dtor
//
CWinStationView::~CWinStationView()
{
	if(m_pTabs)    delete m_pTabs;
	if(m_pTabFont) delete m_pTabFont;

}  // end CWinStationView dtor


#ifdef _DEBUG
///////////////////////////////
// F'N: CWinStationView::AssertValid
//
void CWinStationView::AssertValid() const
{
	CView::AssertValid();

}  // end CWinStationView::AssertValid


////////////////////////
// F'N: CWinStationView::Dump
//
void CWinStationView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);

}  // end CWinStationView::Dump

#endif //_DEBUG


////////////////////////////
// F'N: CWinStationView::OnCreate
//
int CWinStationView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CView::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;

}  // end CWinStationView::OnCreate


///////////////////////////////////
// F'N: CWinStationView::OnInitialUpdate
//
// - pointers to the pages of the sheet are obtained
//
void CWinStationView::OnInitialUpdate() 
{
    // create the tab control
    m_pTabs = new CMyTabCtrl;
    if(!m_pTabs) return;
    m_pTabs->Create(WS_CHILD | WS_VISIBLE | WS_TABSTOP, CRect(0,0,0,0), this, IDC_WINSTATION_TABS);

    m_pTabFont = new CFont;
    if(m_pTabFont) {
        m_pTabFont->CreateStockObject(DEFAULT_GUI_FONT);
        m_pTabs->SetFont(m_pTabFont, TRUE);
    }

    TCHAR szTemp[40];
    CString tabString;
    int index = 0;
	for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
		// If the page is shown under Picasso only and we're not running
		// under Picasso, skip to the next one
        if((pages[i].flags & PF_PICASSO_ONLY) && !((CWinAdminApp*)AfxGetApp())->IsPicasso()) continue;
        if(!(pages[i].flags & PF_NO_TAB)) {
            tabString.LoadString(pages[i].tabStringID);
            lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
            AddTab(index, szTemp, i);
            index++;
        }
        pages[i].m_pPage = (CAdminPage*)pages[i].m_pRuntimeClass->CreateObject();
        pages[i].m_pPage->Create(NULL, NULL, WS_CHILD, CRect(0, 0, 0, 0), this, i, NULL);
        GetDocument()->AddView(pages[i].m_pPage);		
	}

    m_pTabs->SetCurSel(0);

    m_CurrPage = PAGE_WS_PROCESSES;
    ((CWinAdminDoc*)GetDocument())->SetCurrentPage(PAGE_WS_PROCESSES);
	
    OnChangePage(NULL, NULL);
	
}  // end CWinStationView::OnInitialUpdate


//////////////////////////
// F'N: CWinStationView::OnSize
//
// - size the pages to fill the entire view
//
void CWinStationView::OnSize(UINT nType, int cx, int cy) 
{
	RECT rect;

	GetClientRect(&rect);
	if(m_pTabs->GetSafeHwnd())  {			// make sure the tabs object is valid
		m_pTabs->MoveWindow(&rect, TRUE);	// size the tabs

		// for the next part (sizing of pages), we might want to add a member var
		// that keeps track of which page/tab is current... this way we could
		// only actually do a redraw (MoveWindow second parm == TRUE) for the
		// guy who is currently visible--DJM
	
		// we want to size the pages, too
		m_pTabs->AdjustRect(FALSE, &rect);

      for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
         if(pages[i].m_pPage && pages[i].m_pPage->GetSafeHwnd())
            pages[i].m_pPage->MoveWindow(&rect, TRUE);
      }
	}
}  // end CWinStationView::OnSize


//////////////////////////
// F'N: CWinStationView::OnDraw
//
// - the CWinStationView and it's pages draw themselves, so there isn't anything
//   to do here...
//
void CWinStationView::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here

}  // end CWinStationView::OnDraw


/////////////////////////
// F'N: CWinStationView::Reset
//
// - 'resets' the view by taking a pointer to a CWinStation object and filling in 
//   the various property pages with info appropriate to that WinStation
//
void CWinStationView::Reset(void *pWinStation)
{
    if(!((CWinStation*)pWinStation)->AdditionalDone()) ((CWinStation*)pWinStation)->QueryAdditionalInformation();

    for(int i = 0; i < NUMBER_OF_WINS_PAGES; i++) {
        if(pages[i].m_pPage)
            pages[i].m_pPage->Reset((CWinStation*)pWinStation);
    }

    if(((CWinAdminApp*)AfxGetApp())->IsPicasso()) {

        if((((CWinStation*)pWinStation)->GetState() == State_Disconnected
            || !((CWinStation*)pWinStation)->GetExtendedInfo()) 
            && !((CWinStation*)pWinStation)->IsSystemConsole()) {
            // Delete the 'Cache' tab
            m_pTabs->DeleteItem(3);
            // Delete the 'Modules' tab
            m_pTabs->DeleteItem(2);
            // If the 'Cache' tab was current, make the 'Processes' tab current
            if(m_pTabs->GetCurSel() == 0xFFFFFFFF) {
	            m_pTabs->SetCurSel(0);
	            OnChangePage(0,0);
			}
        } else if(m_pTabs->GetItemCount() == 2) {
            TCHAR szTemp[40];
            CString tabString;
            tabString.LoadString(IDS_TAB_MODULES);
            lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
            AddTab(2, szTemp, 2);
            tabString.LoadString(IDS_TAB_CACHE);
            lstrcpyn(szTemp, tabString, sizeof(szTemp) / sizeof(TCHAR));
            AddTab(3, szTemp, 3);
        }
    }

    ((CWinAdminDoc*)GetDocument())->SetCurrentPage(m_CurrPage);
    // We want to fake a ChangePage if we are on page 1 or page 2
    if(m_pTabs->GetCurSel() > 0)
        OnChangePage(0,0);

}  // end CWinStationView::Reset


//////////////////////////
// F'N: CWinStationView::AddTab
//
void CWinStationView::AddTab(int index, TCHAR* text, ULONG pageindex)
{
	TC_ITEM tc;
	tc.mask = TCIF_TEXT | TCIF_PARAM;
	tc.pszText = text;
	tc.lParam = pageindex;

	m_pTabs->InsertItem(index, &tc);

}  // end CWinStationView::AddTab


////////////////////////////////
// F'N: CWinStationView::OnChangePage
//
// - changes to a new WinStation page based on currently selected tab
// - OnChangePage needs to force recalculation of scroll bars!!!--DJM
//
LRESULT CWinStationView::OnChangePage(WPARAM wParam, LPARAM lParam)
{
	// find out which tab is now selected
	int index = m_pTabs->GetCurSel();
	int newpage = index;

	CWinStation *pWinStation = 
		(CWinStation*)((CWinAdminDoc*)GetDocument())->GetCurrentSelectedNode();

	if(index != PAGE_WS_PROCESSES && pWinStation->IsSystemConsole()) {
		newpage = PAGE_WS_NO_INFO;
	}

	// hide the current page
	pages[m_CurrPage].m_pPage->ModifyStyle(WS_VISIBLE, WS_DISABLED);	 

	m_CurrPage = newpage;

    if( pages[ newpage ].flags != PF_NO_TAB )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        pDoc->RegisterLastFocus( TAB_CTRL );
    }

	((CWinAdminDoc*)GetDocument())->SetCurrentPage(newpage);
	// show the new page
	pages[newpage].m_pPage->ModifyStyle(WS_DISABLED, WS_VISIBLE);
	pages[newpage].m_pPage->ScrollToPosition(CPoint(0,0));
    
	pages[newpage].m_pPage->Invalidate();
//    pages[newpage].m_pPage->SetFocus();
	

	return 0;

}  // end CWinStationView::OnChangeview


//////////////////////////
// F'N: CWinStationView::OnTabSelChange
//
void CWinStationView::OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnChangePage( 0, 0);
	*pResult = 0;

}  // end CWinStationView::OnTabSelChange


//////////////////////////
// F'N: CWinStationView::OnAdminUpdateProcesses
//
LRESULT CWinStationView::OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam)
{
   ((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->UpdateProcesses();	

	return 0;

}  // end CWinStationView::OnAdminUpdateProcesses


//////////////////////////
// F'N: CWinStationView::OnAdminRemoveProcess
//
LRESULT CWinStationView::OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam)
{
   ((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->RemoveProcess((CProcess*)lParam);

	return 0;

}  // end CWinStationView::OnAdminRemoveProcess


//////////////////////////
// F'N: CWinStationView::OnAdminRedisplayProcesses
//
LRESULT CWinStationView::OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam)
{
	((CWinStationProcessesPage*)pages[PAGE_WS_PROCESSES].m_pPage)->DisplayProcesses();	

	return 0;

}  // end CWinStationView::OnAdminRedisplayProcesses



LRESULT CWinStationView::OnTabbed( WPARAM wp , LPARAM lp )
{
    ODS( L"CWinStationView::OnTabbed " );
    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );
            
            
            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                int nTab = m_pTabs->GetCurSel();
                
                m_pTabs->SetFocus( );

                m_pTabs->SetCurFocus( nTab );
                
                if( pages[ m_CurrPage ].flags == PF_NO_TAB )
                {
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
                else
                {
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
            }
            else if( nFocus == TAB_CTRL )
            {
                ODS( L"from tab to item\n" );
                
                // set focus to item in page

                if( pages[ m_CurrPage ].flags == PF_NO_TAB )
                {
                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );                    
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );

                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                ODS( L"from item to treeview\n" );

                // set focus back to treeview

                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );
            }

            pDoc->SetPrevFocus( nFocus );
        }


    }

    return 0;
}

//=-------------------------------------------------------------------------
// OnShiftTabbed is called when the user wants to go back one 
// this code is duplicated in all view classes
LRESULT CWinStationView::OnShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnShiftTabbed " );

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            switch( nFocus )
            {
            case TREE_VIEW:                

                if( pages[ m_CurrPage].flags == PF_NO_TAB )
                {
                    ODS( L"going back from tree to noinfo tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    ODS( L"going back from tree to paged item\n" );
                    pages[ m_CurrPage ].m_pPage->SetFocus( );

                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }

                break;
            case TAB_CTRL:
                {
                    ODS( L"going back from tab to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );
                }
                break;
            case PAGED_ITEM:
                {
                    ODS( L"going back from paged item to tab\n" );

                    int nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                break;
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}

//=-------------------------------------------------------------------------
// ctrl + tab works the same as tab but because of our unorthodox ui
// when under a tab control it will cycle over the tabs and back to the treeview
//
LRESULT CWinStationView::OnCtrlTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnCtrlTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );

                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    m_pTabs->SetCurSel( 0 );
                    
                    OnChangePage( 0 , 0 );

                    nTab = 0;
                }

                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nTab );
                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab >= nMaxTab - 1 )
                {
                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                else
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab + 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab + 1 );

                }
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}


//=----------------------------------------------------------------------------
// same as OnCtrlTab but we focus on moving in the other direction
// tree_view to last tab -- current tab to ct - 1
//
LRESULT CWinStationView::OnCtrlShiftTabbed( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnCtrlShiftTabbed " );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            if( nFocus == TREE_VIEW )
            {
                ODS( L"from tree to tab\n" );
                
                nMaxTab = m_pTabs->GetItemCount( );
                
                m_pTabs->SetCurSel( nMaxTab - 1 );
                
                OnChangePage( 0 , 0 );
                
                m_pTabs->SetFocus( );
                
                m_pTabs->SetCurFocus( nMaxTab - 1 );                
                
                pDoc->RegisterLastFocus( TAB_CTRL );

            }
            else
            {                
                nTab = m_pTabs->GetCurSel();
                nMaxTab = m_pTabs->GetItemCount( );

                if( nTab > 0 )
                {
                    ODS( L" ...next tab...\n" );

                    m_pTabs->SetCurSel( nTab - 1 );

                    OnChangePage( 0 , 0 );

                    m_pTabs->SetFocus( );

                    m_pTabs->SetCurFocus( nTab - 1 );
                }
                else
                {

                    ODS( L"...back to treeview\n" );

                    CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                    p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                    pDoc->RegisterLastFocus( TREE_VIEW );


                }
                
            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;   
}

//=----------------------------------------------------------------------------
// When the user hits F6 we need to switch between pains
LRESULT CWinStationView::OnNextPane( WPARAM , LPARAM )
{
    ODS( L"CWinStationView::OnNextPane\n" );
    int nTab;
    int nMaxTab;

    if( m_pTabs != NULL )
    {
        CWinAdminDoc *pDoc = (CWinAdminDoc*)GetDocument();

        if( pDoc != NULL )
        {
            FOCUS_STATE nFocus = pDoc->GetLastRegisteredFocus( );

            FOCUS_STATE nPrevFocus = pDoc->GetPrevFocus( );

            if( nFocus == TREE_VIEW )
            {
                if( nPrevFocus == TAB_CTRL )
                {
                    nTab = m_pTabs->GetCurSel();
                
                    m_pTabs->SetFocus( );
                    m_pTabs->SetCurFocus( nTab );
                
                    pDoc->RegisterLastFocus( TAB_CTRL );
                }
                else
                {
                    pages[ m_CurrPage ].m_pPage->SetFocus( );
                    
                    pDoc->RegisterLastFocus( PAGED_ITEM );
                }
            }
            else
            {
                CFrameWnd *p = (CFrameWnd*)pDoc->GetMainWnd();

                p->SendMessage( WM_FORCE_TREEVIEW_FOCUS , 0 , 0 );

                pDoc->RegisterLastFocus( TREE_VIEW );

            }

            pDoc->SetPrevFocus( nFocus );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\admtools\winutils\tsadmin\winsvw.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation
/*******************************************************************************
*
* winsvw.h
*
* declarations for the CWinStationView class
*
*  
*******************************************************************************/

#ifndef _WINSTATIONVIEW_H
#define _WINSTATIONVIEW_H

#include "winspgs.h"

const int NUMBER_OF_WINS_PAGES = 5;


////////////////////
// CLASS: CWinStationView
//
class CWinStationView : public CAdminView
{
friend class CRightPane;

private:
	CTabCtrl*	m_pTabs;
	CFont*      m_pTabFont;

	int m_CurrPage;

protected:
	CWinStationView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CWinStationView)

// Attributes
public:

protected:
   static PageDef pages[NUMBER_OF_WINS_PAGES];

// Operations
protected:
	virtual void Reset(void *pWinStation);

	void AddTab(int index, TCHAR* text, ULONG pageindex);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWinStationView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CWinStationView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

    
	// Generated message map functions
protected:
	//{{AFX_MSG(CWinStationView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg LRESULT OnChangePage(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminUpdateProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRemoveProcess(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnAdminRedisplayProcesses(WPARAM wParam, LPARAM lParam);
	afx_msg void OnTabSelChange(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg LRESULT OnTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnCtrlShiftTabbed( WPARAM , LPARAM );
    afx_msg LRESULT OnNextPane( WPARAM , LPARAM );
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};  // end class CWinStationView

#endif  // _WINSTATIONVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\apisub\apisub.c ===
/*******************************************************************************
*
* apisub.c
*
* RegApi helpers and convertion routines
*
* Copyright Microsoft Corporation, 1998
*
*
*******************************************************************************/

/*
 *  Includes
 */
#include <windows.h>
#include <stdio.h>
#include <winstaw.h>
#include <regapi.h>
#include <ntsecapi.h>


/*
 * General purpose UNICODE <==> ANSI functions
 */
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );

/*
 * Reg Create helpers
 */
LONG SetNumValue( BOOLEAN, HKEY, LPWSTR, DWORD );
LONG SetNumValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, DWORD );
LONG SetStringValue( BOOLEAN, HKEY, LPWSTR, LPWSTR );
LONG SetStringValueEx( BOOLEAN, HKEY, LPWSTR, DWORD, LPWSTR );
DWORD SetStringInLSA( LPWSTR, LPWSTR );

/*
 * Reg Query helpers
 */
DWORD GetNumValue( HKEY, LPWSTR, DWORD );
DWORD GetNumValueEx( HKEY, LPWSTR, DWORD, DWORD );
LONG GetStringValue( HKEY, LPWSTR, LPWSTR, LPWSTR, DWORD );
LONG GetStringValueEx( HKEY, LPWSTR, DWORD, LPWSTR, LPWSTR, DWORD );
DWORD GetStringFromLSA( LPWSTR, LPWSTR, DWORD );


/*
 * LSA helpers
 */
void     InitLsaString(LPWSTR String, PLSA_UNICODE_STRING lusString);
NTSTATUS GetLSAPolicyHandle(DWORD , PLSA_HANDLE );

/*
 * Pd conversion helpers.
 */
VOID PdConfigU2A( PPDCONFIGA, PPDCONFIGW );
VOID PdConfigA2U( PPDCONFIGW, PPDCONFIGA );
VOID PdConfig2U2A( PPDCONFIG2A, PPDCONFIG2W );
VOID PdConfig2A2U( PPDCONFIG2W, PPDCONFIG2A );
VOID PdConfig3U2A( PPDCONFIG3A, PPDCONFIG3W );
VOID PdConfig3A2U( PPDCONFIG3W, PPDCONFIG3A );
VOID PdParamsU2A( PPDPARAMSA, PPDPARAMSW );
VOID PdParamsA2U( PPDPARAMSW, PPDPARAMSA );
VOID AsyncConfigU2A ( PASYNCCONFIGA, PASYNCCONFIGW );
VOID AsyncConfigA2U ( PASYNCCONFIGW, PASYNCCONFIGA );
VOID NetworkConfigU2A ( PNETWORKCONFIGA, PNETWORKCONFIGW );
VOID NetworkConfigA2U ( PNETWORKCONFIGW, PNETWORKCONFIGA );
VOID NasiConfigU2A ( PNASICONFIGA, PNASICONFIGW );
VOID NasiConfigA2U ( PNASICONFIGW, PNASICONFIGA );
VOID OemTdConfigU2A ( POEMTDCONFIGA, POEMTDCONFIGW );
VOID OemTdConfigA2U ( POEMTDCONFIGW, POEMTDCONFIGA );

/*
 * WinStation conversion helpers (regapi).
 */
VOID WinStationCreateU2A( PWINSTATIONCREATEA, PWINSTATIONCREATEW );
VOID WinStationCreateA2U( PWINSTATIONCREATEW, PWINSTATIONCREATEA );
VOID WinStationConfigU2A( PWINSTATIONCONFIGA, PWINSTATIONCONFIGW );
VOID WinStationConfigA2U( PWINSTATIONCONFIGW, PWINSTATIONCONFIGA );
VOID UserConfigU2A( PUSERCONFIGA, PUSERCONFIGW );
VOID UserConfigA2U( PUSERCONFIGW, PUSERCONFIGA );

/*
 * WinStation conversion helpers (winstapi).
 */
VOID WinStationPrinterU2A( PWINSTATIONPRINTERA, PWINSTATIONPRINTERW );
VOID WinStationPrinterA2U( PWINSTATIONPRINTERW, PWINSTATIONPRINTERA );
VOID WinStationInformationU2A( PWINSTATIONINFORMATIONA,
                               PWINSTATIONINFORMATIONW );
VOID WinStationInformationA2U( PWINSTATIONINFORMATIONW,
                               PWINSTATIONINFORMATIONA );
VOID WinStationClientU2A( PWINSTATIONCLIENTA, PWINSTATIONCLIENTW );
VOID WinStationProductIdU2A( PWINSTATIONPRODIDA, PWINSTATIONPRODIDW );

/*
 * Wd conversion helpers.
 */
VOID WdConfigU2A( PWDCONFIGA, PWDCONFIGW );
VOID WdConfigA2U( PWDCONFIGW, PWDCONFIGA );

/*
 * Cd conversion helpers.
 */
VOID CdConfigU2A( PCDCONFIGA, PCDCONFIGW );
VOID CdConfigA2U( PCDCONFIGW, PCDCONFIGA );

/*
 *  procedures used (not defined here)
 */
VOID RtlUnicodeToMultiByteN( LPSTR, ULONG, PULONG, LPWSTR, ULONG );
VOID RtlMultiByteToUnicodeN( LPWSTR, ULONG, PULONG, LPSTR, ULONG );


/*******************************************************************************
 *
 *  UnicodeToAnsi
 *
 *     convert a UNICODE (WCHAR) string into an ANSI (CHAR) string
 *
 * ENTRY:
 *
 *    pAnsiString (output)
 *       buffer to place ANSI string into
 *    lAnsiMax (input)
 *       maximum number of BYTES to write into pAnsiString (sizeof the
 *       pAnsiString buffer)
 *    pUnicodeString (input)
 *       UNICODE string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UnicodeToAnsi( CHAR * pAnsiString,
               ULONG lAnsiMax,
               WCHAR * pUnicodeString )
{
    ULONG ByteCount;

    RtlUnicodeToMultiByteN( pAnsiString, lAnsiMax, &ByteCount,
                            pUnicodeString,
                            ((wcslen(pUnicodeString) + 1) << 1) );
}


/*******************************************************************************
 *
 *  AnsiToUnicode
 *
 *     convert an ANSI (CHAR) string into a UNICODE (WCHAR) string
 *
 * ENTRY:
 *
 *    pUnicodeString (output)
 *       buffer to place UNICODE string into
 *    lUnicodeMax (input)
 *       maximum number of BYTES to write into pUnicodeString (sizeof the
 *       pUnicodeString buffer).
 *    pAnsiString (input)
 *       ANSI string to convert
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AnsiToUnicode( WCHAR * pUnicodeString,
               ULONG lUnicodeMax,
               CHAR * pAnsiString )
{
    ULONG ByteCount;

    RtlMultiByteToUnicodeN( pUnicodeString, lUnicodeMax, &ByteCount,
                            pAnsiString, (strlen(pAnsiString) + 1) );
}


/*******************************************************************************
 *
 *  SetNumValue
 *
 *     Set numeric (DWORD) value in registry
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    status from RegDeleteValue or RegSetValueEx
 *
 ******************************************************************************/

LONG
SetNumValue( BOOLEAN bSetValue,
             HKEY Handle,
             LPWSTR ValueName,
             DWORD ValueData )
{
    if ( bSetValue )
        return( RegSetValueEx( Handle, ValueName, 0, REG_DWORD,
                               (BYTE *)&ValueData, sizeof(DWORD) ) );
    else
        return( RegDeleteValue( Handle, ValueName ) );
}


/*******************************************************************************
 *
 *  SetNumValueEx
 *
 *     Set numeric (DWORD) value in registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    Index (input)
 *       Index of value (array index)
 *    ValueData (input)
 *       data (DWORD) for registry value to set
 *
 * EXIT:
 *    status from SetNumValue
 *
 ******************************************************************************/

LONG
SetNumValueEx( BOOLEAN bSetValue,
               HKEY Handle,
               LPWSTR ValueName,
               DWORD Index,
               DWORD ValueData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( SetNumValue( bSetValue, Handle, Name, ValueData ) );
}


/*******************************************************************************
 *
 *  SetStringValue
 *
 *     Set string value in registry
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    pValueData (input)
 *       data (string) for registry value to set
 *
 * EXIT:
 *    status from RegDeleteValue or RegSetValueEx
 *
 ******************************************************************************/

LONG
SetStringValue( BOOLEAN bSetValue,
                HKEY Handle,
                LPWSTR ValueName,
                LPWSTR pValueData )
{
    if ( bSetValue )
        return( RegSetValueEx( Handle, ValueName, 0, REG_SZ,
                               (BYTE *)pValueData, (wcslen(pValueData)+1)<<1 ) );
    else
        return( RegDeleteValue( Handle, ValueName ) );
}


/*******************************************************************************
 *
 *  SetStringValueEx
 *
 *     Set string value in registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    bSetValue (input)
 *       TRUE to set value; FALSE to delete from registry
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to set
 *    Index (input)
 *       Index of value (array index)
 *    pValueData (input)
 *       data (string) for registry value to set
 *
 * EXIT:
 *    status from SetStringValue
 *
 ******************************************************************************/

LONG
SetStringValueEx( BOOLEAN bSetValue,
                  HKEY Handle,
                  LPWSTR ValueName,
                  DWORD Index,
                  LPWSTR pValueData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( SetStringValue( bSetValue, Handle, Name, pValueData ) );
}


/*******************************************************************************
 *
 *  SetStringInLSA
 *
 *     Set password in LSA secret
 *
 * ENTRY:
 *
 *    pwszString (input)
 *       password (string) secret to be stored in LSA, it's ok if this is NULL
 *
 * EXIT:
 *    status from LsaStorePrivateData
 *
 ******************************************************************************/

DWORD 
SetStringInLSA(LPWSTR pwszStringKeyName, LPWSTR pwszString)
{
    LSA_HANDLE         hLSAPolicy = NULL;
    LSA_UNICODE_STRING lusName;
    LSA_UNICODE_STRING lusSecret;
    NTSTATUS           ntsResult;
    

    // Get the policy handle
    ntsResult  = GetLSAPolicyHandle(POLICY_CREATE_SECRET, &hLSAPolicy);
    if (ntsResult != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    // Create UNICODE string for the secret key name
    InitLsaString(pwszStringKeyName, &lusName);

    // Create UNICODE string for the secret
    InitLsaString(pwszString, &lusSecret);

    // Store the secret in LSA
    ntsResult = LsaStorePrivateData(hLSAPolicy, &lusName, &lusSecret);


Cleanup:
    // close lsa handle
    if (hLSAPolicy != NULL)
        LsaClose(hLSAPolicy);

    // Convert NTSTATUS result to Windows error code
    return LsaNtStatusToWinError(ntsResult);
}


/*******************************************************************************
 *
 *  InitLsaString
 *
 *     Initialize LSA unicode string.
 *
 * ENTRY:
 *
 *     String : (IN) String to initialize LsaString.
 *     lusString (IN/OUT): Pointer to LSA_UNICODE_STRING to be initialized.
 *
 * EXIT:
 *    status from LsaStorePrivateData
 *
 ******************************************************************************/

void
InitLsaString(LPWSTR String, PLSA_UNICODE_STRING lusString)
{
    // Create UNICODE string for the passed in string   
    if (String == NULL)
    {
        lusString->Buffer = NULL;
        lusString->Length = 0;
        lusString->MaximumLength = 0;
    }
    else
    {
        lusString->Buffer = String;
        lusString->Length = wcslen(String) * sizeof(WCHAR);
        lusString->MaximumLength = lusString->Length + (2 * sizeof(WCHAR));
    }
}

/*******************************************************************************
 *
 *  GetLSAPolicyHandle
 *
 *     Create/return a LSA policy handle.
 *
 * ENTRY:
 *
 *     ServerName : Name of server, refer to LsaOpenPolicy().
 *     DesiredAccess : Desired access level, refer to LsaOpenPolicy().
 *     PolicyHandle : Return PLSA_HANDLE.
 *
 * EXIT:
 *    ERROR_SUCCESS or  LSA error code
 *
 ******************************************************************************/

NTSTATUS
GetLSAPolicyHandle(DWORD dwDesiredAccess, PLSA_HANDLE phLSAPolicy)
{
    NTSTATUS              ntsResult;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    
    // Open handle to the Policy object for the local system
    ntsResult = LsaOpenPolicy(NULL,
                              &ObjectAttributes,
                              dwDesiredAccess,
                              phLSAPolicy);
    
    return ntsResult;
}


/*******************************************************************************
 *
 *  GetStringFromLSA
 *
 *     Get password secret from LSA
 *
 * ENTRY:
 *
 *    pwszString (output)
 *       string stored in LSA
 *    DWORD dwBuffLen (in)
 *       length of passed in buffer size
 *
 * EXIT:
 *    status from LsaRetrievePrivateData
 *
 ******************************************************************************/

DWORD 
GetStringFromLSA(LPWSTR pwszStringKeyName, LPWSTR pwszString, DWORD dwBuffLen)
{
    LSA_HANDLE          hLSAPolicy = NULL;
    LSA_UNICODE_STRING  lusName;
    PLSA_UNICODE_STRING plusSecret = NULL;
    NTSTATUS            ntsResult;
    DWORD               dwStatus = S_OK;

    // Get the policy handle
    ntsResult = GetLSAPolicyHandle(POLICY_GET_PRIVATE_INFORMATION, &hLSAPolicy);
    if (ntsResult != ERROR_SUCCESS)
    {
        // Convert result to a window status
        dwStatus = LsaNtStatusToWinError(ntsResult);
        goto Cleanup;
    }

    // Create UNICODE string for the secret key name
    InitLsaString(pwszStringKeyName, &lusName);

    // Retrieve the secret from LSA
    ntsResult = LsaRetrievePrivateData(hLSAPolicy, &lusName, &plusSecret);
    if (ntsResult != ERROR_SUCCESS)
    {
        // Convert result to a window status
        dwStatus = LsaNtStatusToWinError(ntsResult);
        goto Cleanup;
    }
     
    // It's possible the return string is NULL (this means there is no
    // current value) so we'll set the return string to NULL and leave
    if (plusSecret == NULL)
    {
        pwszString = NULL;
        goto Cleanup;
    }

    // Make sure the size of buffer is large enough
    if (dwBuffLen > (plusSecret->Length / sizeof(WCHAR)))
    {
        dwBuffLen = plusSecret->Length / sizeof(WCHAR);
    }

    // Copy over the password to the output buffer and null terminate it
    wcsncpy(pwszString, plusSecret->Buffer, dwBuffLen);
    pwszString[dwBuffLen] = L'\0';


Cleanup:
    if (plusSecret != NULL)
        LsaFreeMemory(plusSecret);

    // close lsa handle
    if (hLSAPolicy != NULL)
        LsaClose(hLSAPolicy);

    return dwStatus;
}


/*******************************************************************************
 *
 *  GetNumValue
 *
 *     get numeric (DWORD) value from registry
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *
 * EXIT:
 *    registry value (DWORD)
 *
 ******************************************************************************/

DWORD
GetNumValue( HKEY Handle,
             LPWSTR ValueName,
             DWORD DefaultData )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueData;
    DWORD ValueSize = sizeof(DWORD);

    Status = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                              (LPBYTE) &ValueData, &ValueSize );
    if ( Status != ERROR_SUCCESS )
        ValueData = DefaultData;

    return( ValueData );
}


/*******************************************************************************
 *
 *  GetNumValueEx
 *
 *     get numeric (DWORD) value from registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    Index (input)
 *       Index of value (array index)
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *
 * EXIT:
 *    registry value (DWORD)
 *
 ******************************************************************************/

DWORD
GetNumValueEx( HKEY Handle,
               LPWSTR ValueName,
               DWORD Index,
               DWORD DefaultData )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( GetNumValue( Handle, Name, DefaultData ) );
}


/*******************************************************************************
 *
 *  GetStringValue
 *
 *     get string value from registry
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *    pValueData (output)
 *       pointer to buffer to store returned string
 *    MaxValueSize (input)
 *       max length of pValueData buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

LONG
GetStringValue( HKEY Handle,
                LPWSTR ValueName,
                LPWSTR DefaultData,
                LPWSTR pValueData,
                DWORD MaxValueSize )
{
    LONG Status;
    DWORD ValueType;
    DWORD ValueSize = MaxValueSize << 1;

    Status = RegQueryValueEx( Handle, ValueName, NULL, &ValueType,
                              (LPBYTE) pValueData, &ValueSize );
    if ( Status != ERROR_SUCCESS || ValueSize == sizeof(UNICODE_NULL) ) {
        if ( DefaultData )
            wcscpy( pValueData, DefaultData );
        else
            pValueData[0] = 0;
    } else {
        if ( ValueType != REG_SZ ) {
            pValueData[0] = 0;
            return( ERROR_INVALID_DATATYPE );
        }
    }
    return( ERROR_SUCCESS );
}


/*******************************************************************************
 *
 *  GetStringValueEx
 *
 *     get string value from registry  (for use with arrays)
 *
 * ENTRY:
 *
 *    Handle (input)
 *       registry handle
 *    ValueName (input)
 *       name of registry value to query
 *    Index (input)
 *       Index of value (array index)
 *    DefaultData (input)
 *       default value to return if registry value name does not exist
 *    pValueData (output)
 *       pointer to buffer to store returned string
 *    MaxValueSize (input)
 *       max length of pValueData buffer
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

LONG
GetStringValueEx( HKEY Handle,
                  LPWSTR ValueName,
                  DWORD Index,
                  LPWSTR DefaultData,
                  LPWSTR pValueData,
                  DWORD MaxValueSize )
{
    WCHAR Name[MAX_REGKEYWORD];

    if ( Index > 0 )
        swprintf( Name, L"%s%u", ValueName, Index );
    else
        wcscpy( Name, ValueName );

    return( GetStringValue( Handle, Name, DefaultData, pValueData, MaxValueSize ) );
}


/*******************************************************************************
 *
 *  PdConfigU2A (UNICODE to ANSI)
 *
 *    copies PDCONFIGW elements to PDCONFIGA elements
 *
 * ENTRY:
 *    pPdConfigA (output)
 *       points to PDCONFIGA structure to copy to
 *
 *    pPdConfigW (input)
 *       points to PDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfigU2A( PPDCONFIGA pPdConfigA,
              PPDCONFIGW pPdConfigW )
{
    PdConfig2U2A( &(pPdConfigA->Create), &(pPdConfigW->Create) );
    PdParamsU2A( &(pPdConfigA->Params), &(pPdConfigW->Params) );
}


/*******************************************************************************
 *
 *  PdConfigA2U (ANSI to UNICODE)
 *
 *    copies PDCONFIGA elements to PDCONFIGW elements
 *
 * ENTRY:
 *    pPdConfigW (output)
 *       points to PDCONFIGW structure to copy to
 *
 *    pPdConfigA (input)
 *       points to PDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfigA2U( PPDCONFIGW pPdConfigW,
              PPDCONFIGA pPdConfigA )
{
    PdConfig2A2U( &(pPdConfigW->Create), &(pPdConfigA->Create) );
    PdParamsA2U( &(pPdConfigW->Params), &(pPdConfigA->Params) );
}


/*******************************************************************************
 *
 *  PdConfig2U2A (UNICODE to ANSI)
 *
 *    copies PDCONFIG2W elements to PDCONFIG2A elements
 *
 * ENTRY:
 *    pPdConfig2A (output)
 *       points to PDCONFIG2A structure to copy to
 *
 *    pPdConfig2W (input)
 *       points to PDCONFIG2W structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig2U2A( PPDCONFIG2A pPdConfig2A,
               PPDCONFIG2W pPdConfig2W )
{
    UnicodeToAnsi( pPdConfig2A->PdName,
                   sizeof(pPdConfig2A->PdName),
                   pPdConfig2W->PdName );

    pPdConfig2A->SdClass = pPdConfig2W->SdClass;

    UnicodeToAnsi( pPdConfig2A->PdDLL,
                   sizeof(pPdConfig2A->PdDLL),
                   pPdConfig2W->PdDLL );

    pPdConfig2A->PdFlag  = pPdConfig2W->PdFlag;

    pPdConfig2A->OutBufLength = pPdConfig2W->OutBufLength;
    pPdConfig2A->OutBufCount = pPdConfig2W->OutBufCount;
    pPdConfig2A->OutBufDelay = pPdConfig2W->OutBufDelay;
    pPdConfig2A->InteractiveDelay = pPdConfig2W->InteractiveDelay;
    pPdConfig2A->PortNumber  = pPdConfig2W->PortNumber;
    pPdConfig2A->KeepAliveTimeout = pPdConfig2W->KeepAliveTimeout;
}


/*******************************************************************************
 *
 *  PdConfig2A2U (ANSI to UNICODE)
 *
 *    copies PDCONFIG2A elements to PDCONFIG2W elements
 *
 * ENTRY:
 *    pPdConfig2W (output)
 *       points to PDCONFIG2W structure to copy to
 *
 *    pPdConfig2A (input)
 *       points to PDCONFIG2A structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig2A2U( PPDCONFIG2W pPdConfig2W,
               PPDCONFIG2A pPdConfig2A )
{
    AnsiToUnicode( pPdConfig2W->PdName,
                   sizeof(pPdConfig2W->PdName),
                   pPdConfig2A->PdName );

    pPdConfig2W->SdClass = pPdConfig2A->SdClass;

    AnsiToUnicode( pPdConfig2W->PdDLL,
                   sizeof(pPdConfig2W->PdDLL),
                   pPdConfig2A->PdDLL );

    pPdConfig2W->PdFlag  = pPdConfig2A->PdFlag;

    pPdConfig2W->OutBufLength = pPdConfig2A->OutBufLength;
    pPdConfig2W->OutBufCount = pPdConfig2A->OutBufCount;
    pPdConfig2W->OutBufDelay = pPdConfig2A->OutBufDelay;
    pPdConfig2W->InteractiveDelay = pPdConfig2A->InteractiveDelay;
    pPdConfig2W->PortNumber  = pPdConfig2A->PortNumber;
    pPdConfig2W->KeepAliveTimeout  = pPdConfig2A->KeepAliveTimeout;
}


/*******************************************************************************
 *
 *  PdConfig3U2A (UNICODE to ANSI)
 *
 *    copies PDCONFIG3W elements to PDCONFIG3A elements
 *
 * ENTRY:
 *    pPdConfig3A (output)
 *       points to PDCONFIG3A structure to copy to
 *
 *    pPdConfig3W (input)
 *       points to PDCONFIG3W structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig3U2A( PPDCONFIG3A pPdConfig3A,
               PPDCONFIG3W pPdConfig3W )
{
    PdConfig2U2A( &(pPdConfig3A->Data), &(pPdConfig3W->Data) );

    UnicodeToAnsi( pPdConfig3A->ServiceName,
                   sizeof(pPdConfig3A->ServiceName),
                   pPdConfig3W->ServiceName );

    UnicodeToAnsi( pPdConfig3A->ConfigDLL,
                   sizeof(pPdConfig3A->ConfigDLL),
                   pPdConfig3W->ConfigDLL );
}


/*******************************************************************************
 *
 *  PdConfig3A2U (ANSI to UNICODE)
 *
 *    copies PDCONFIG3A elements to PDCONFIG3W elements
 *
 * ENTRY:
 *    pPdConfig3W (output)
 *       points to PDCONFIG3W structure to copy to
 *
 *    pPdConfig3A (input)
 *       points to PDCONFIG3A structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdConfig3A2U( PPDCONFIG3W pPdConfig3W,
               PPDCONFIG3A pPdConfig3A )
{
    PdConfig2A2U( &(pPdConfig3W->Data), &(pPdConfig3A->Data) );

    AnsiToUnicode( pPdConfig3W->ServiceName,
                   sizeof(pPdConfig3W->ServiceName),
                   pPdConfig3A->ServiceName );

    AnsiToUnicode( pPdConfig3W->ConfigDLL,
                   sizeof(pPdConfig3W->ConfigDLL),
                   pPdConfig3A->ConfigDLL );
}


/*******************************************************************************
 *
 *  PdParamsU2A (UNICODE to ANSI)
 *
 *    copies PDPARAMSW elements to PDPARAMSA elements
 *
 * ENTRY:
 *    pPdParamsA (output)
 *       points to PDPARAMSA structure to copy to
 *
 *    pPdParamsW (input)
 *       points to PDPARAMSW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdParamsU2A( PPDPARAMSA pPdParamsA,
              PPDPARAMSW pPdParamsW )
{
    pPdParamsA->SdClass = pPdParamsW->SdClass;

    switch ( pPdParamsW->SdClass ) {

        case SdNetwork:
            NetworkConfigU2A( &(pPdParamsA->Network), &(pPdParamsW->Network) );
            break;

        case SdNasi:
            NasiConfigU2A( &(pPdParamsA->Nasi), &(pPdParamsW->Nasi) );
            break;

        case SdAsync:
            AsyncConfigU2A( &(pPdParamsA->Async), &(pPdParamsW->Async) );
            break;

        case SdOemTransport:
            OemTdConfigU2A( &(pPdParamsA->OemTd), &(pPdParamsW->OemTd) );
            break;
    }
}


/*******************************************************************************
 *
 *  PdParamsA2U (ANSI to UNICODE)
 *
 *    copies PDPARAMSA elements to PDPARAMSW elements
 *
 * ENTRY:
 *    pPdParamsW (output)
 *       points to PDPARAMSW structure to copy to
 *
 *    pPdParamsA (input)
 *       points to PDPARAMSA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
PdParamsA2U( PPDPARAMSW pPdParamsW,
              PPDPARAMSA pPdParamsA )
{
    pPdParamsW->SdClass = pPdParamsA->SdClass;

    switch ( pPdParamsA->SdClass ) {

        case SdNetwork:
            NetworkConfigA2U( &(pPdParamsW->Network), &(pPdParamsA->Network) );
            break;

        case SdNasi:
            NasiConfigA2U( &(pPdParamsW->Nasi), &(pPdParamsA->Nasi) );
            break;

        case SdAsync:
            AsyncConfigA2U( &(pPdParamsW->Async), &(pPdParamsA->Async) );
            break;

        case SdOemTransport:
            OemTdConfigA2U( &(pPdParamsW->OemTd), &(pPdParamsA->OemTd) );
            break;
    }
}


/*******************************************************************************
 *
 *  NetworkConfigU2A (UNICODE to ANSI)
 *
 *    copies NETWORKCONFIGW elements to NETWORKCONFIGA elements
 *
 * ENTRY:
 *    pNetworkConfigA (output)
 *       points to NETWORKCONFIGA structure to copy to
 *
 *    pNetworkConfigW (input)
 *       points to NETWORKCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NetworkConfigU2A( PNETWORKCONFIGA pNetworkConfigA,
                  PNETWORKCONFIGW pNetworkConfigW )
{
    pNetworkConfigA->LanAdapter = pNetworkConfigW->LanAdapter;

    UnicodeToAnsi( pNetworkConfigA->NetworkName,
                   sizeof(pNetworkConfigA->NetworkName),
                   pNetworkConfigW->NetworkName );

    pNetworkConfigA->Flags = pNetworkConfigW->Flags;
}


/*******************************************************************************
 *
 *  NetworkConfigA2U (ANSI to UNICODE)
 *
 *    copies NETWORKCONFIGA elements to NETWORKCONFIGW elements
 *
 * ENTRY:
 *    pNetworkConfigW (output)
 *       points to NETWORKCONFIGW structure to copy to
 *
 *    pNetworkConfigW (input)
 *       points to NETWORKCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NetworkConfigA2U( PNETWORKCONFIGW pNetworkConfigW,
                  PNETWORKCONFIGA pNetworkConfigA )
{
    pNetworkConfigW->LanAdapter = pNetworkConfigA->LanAdapter;

    AnsiToUnicode( pNetworkConfigW->NetworkName,
                   sizeof(pNetworkConfigW->NetworkName),
                   pNetworkConfigA->NetworkName );

    pNetworkConfigW->Flags = pNetworkConfigA->Flags;
}


/*******************************************************************************
 *
 *  AsyncConfigU2A (UNICODE to ANSI)
 *
 *    copies ASYNCCONFIGW elements to ASYNCCONFIGA elements
 *
 * ENTRY:
 *    pAsyncConfigA (output)
 *       points to ASYNCCONFIGA structure to copy to
 *
 *    pAsyncConfigW (input)
 *       points to ASYNCCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AsyncConfigU2A( PASYNCCONFIGA pAsyncConfigA,
                PASYNCCONFIGW pAsyncConfigW )
{
    UnicodeToAnsi( pAsyncConfigA->DeviceName,
                   sizeof(pAsyncConfigA->DeviceName),
                   pAsyncConfigW->DeviceName );

    UnicodeToAnsi( pAsyncConfigA->ModemName,
                   sizeof(pAsyncConfigA->ModemName),
                   pAsyncConfigW->ModemName );

    pAsyncConfigA->BaudRate = pAsyncConfigW->BaudRate;
    pAsyncConfigA->Parity = pAsyncConfigW->Parity;
    pAsyncConfigA->StopBits = pAsyncConfigW->StopBits;
    pAsyncConfigA->ByteSize = pAsyncConfigW->ByteSize;
    pAsyncConfigA->fEnableDsrSensitivity = pAsyncConfigW->fEnableDsrSensitivity;
    pAsyncConfigA->fConnectionDriver = pAsyncConfigW->fConnectionDriver;

    pAsyncConfigA->FlowControl = pAsyncConfigW->FlowControl;

    pAsyncConfigA->Connect = pAsyncConfigW->Connect;
}


/*******************************************************************************
 *
 *  AsyncConfigA2U (ANSI to UNICODE)
 *
 *    copies ASYNCCONFIGA elements to ASYNCCONFIGW elements
 *
 * ENTRY:
 *    pAsyncConfigW (output)
 *       points to ASYNCCONFIGW structure to copy to
 *
 *    pAsyncConfigA (input)
 *       points to ASYNCCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
AsyncConfigA2U( PASYNCCONFIGW pAsyncConfigW,
                PASYNCCONFIGA pAsyncConfigA )
{
    AnsiToUnicode( pAsyncConfigW->DeviceName,
                   sizeof(pAsyncConfigW->DeviceName),
                   pAsyncConfigA->DeviceName );

    AnsiToUnicode( pAsyncConfigW->ModemName,
                   sizeof(pAsyncConfigW->ModemName),
                   pAsyncConfigA->ModemName );

    pAsyncConfigW->BaudRate = pAsyncConfigA->BaudRate;
    pAsyncConfigW->Parity = pAsyncConfigA->Parity;
    pAsyncConfigW->StopBits = pAsyncConfigA->StopBits;
    pAsyncConfigW->ByteSize = pAsyncConfigA->ByteSize;
    pAsyncConfigW->fEnableDsrSensitivity = pAsyncConfigA->fEnableDsrSensitivity;

    pAsyncConfigW->FlowControl = pAsyncConfigA->FlowControl;

    pAsyncConfigW->Connect = pAsyncConfigA->Connect;
}


/*******************************************************************************
 *
 *  NasiConfigU2A (UNICODE to ANSI)
 *
 *    copies NASICONFIGW elements to NASICONFIGA elements
 *
 * ENTRY:
 *    pNasiConfigA (output)
 *       points to NASICONFIGA structure to copy to
 *
 *    pNasiConfigW (input)
 *       points to NASICONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NasiConfigU2A( PNASICONFIGA pNasiConfigA,
                PNASICONFIGW pNasiConfigW )
{
    UnicodeToAnsi( pNasiConfigA->SpecificName,
                   sizeof(pNasiConfigA->SpecificName),
                   pNasiConfigW->SpecificName );
    UnicodeToAnsi( pNasiConfigA->UserName,
                   sizeof(pNasiConfigA->UserName),
                   pNasiConfigW->UserName );
    UnicodeToAnsi( pNasiConfigA->PassWord,
                   sizeof(pNasiConfigA->PassWord),
                   pNasiConfigW->PassWord );
    UnicodeToAnsi( pNasiConfigA->SessionName,
                   sizeof(pNasiConfigA->SessionName),
                   pNasiConfigW->SessionName );
    UnicodeToAnsi( pNasiConfigA->FileServer,
                   sizeof(pNasiConfigA->FileServer),
                   pNasiConfigW->FileServer );

    pNasiConfigA->GlobalSession = pNasiConfigW->GlobalSession;
}


/*******************************************************************************
 *
 *  NasiConfigA2U (ANSI to UNICODE)
 *
 *    copies NASICONFIGA elements to NASICONFIGW elements
 *
 * ENTRY:
 *    pNasiConfigW (output)
 *       points to NASICONFIGW structure to copy to
 *
 *    pNasiConfigA (input)
 *       points to NASICONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
NasiConfigA2U( PNASICONFIGW pNasiConfigW,
               PNASICONFIGA pNasiConfigA )
{
    AnsiToUnicode( pNasiConfigW->SpecificName,
                   sizeof(pNasiConfigW->SpecificName),
                   pNasiConfigA->SpecificName );
    AnsiToUnicode( pNasiConfigW->UserName,
                   sizeof(pNasiConfigW->UserName),
                   pNasiConfigA->UserName );
    AnsiToUnicode( pNasiConfigW->PassWord,
                   sizeof(pNasiConfigW->PassWord),
                   pNasiConfigA->PassWord );
    AnsiToUnicode( pNasiConfigW->SessionName,
                   sizeof(pNasiConfigW->SessionName),
                   pNasiConfigA->SessionName );
    AnsiToUnicode( pNasiConfigW->FileServer,
                   sizeof(pNasiConfigW->FileServer),
                   pNasiConfigA->FileServer );

    pNasiConfigW->GlobalSession = pNasiConfigA->GlobalSession;
}


/*******************************************************************************
 *
 *  OemTdConfigU2A (UNICODE to ANSI)
 *
 *    copies OEMTDCONFIGW elements to OEMTDCONFIGA elements
 *
 * ENTRY:
 *    pOemTdConfigA (output)
 *       points to OEMTDCONFIGA structure to copy to
 *
 *    pOemTdConfigW (input)
 *       points to OEMTDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
OemTdConfigU2A( POEMTDCONFIGA pOemTdConfigA,
                POEMTDCONFIGW pOemTdConfigW )
{
    pOemTdConfigA->Adapter = pOemTdConfigW->Adapter;

    UnicodeToAnsi( pOemTdConfigA->DeviceName,
                   sizeof(pOemTdConfigA->DeviceName),
                   pOemTdConfigW->DeviceName );

    pOemTdConfigA->Flags = pOemTdConfigW->Flags;
}


/*******************************************************************************
 *
 *  OemTdConfigA2U (ANSI to Unicode)
 *
 *    copies OEMTDCONFIGA elements to OEMTDCONFIGW elements
 *
 * ENTRY:
 *    pOemTdConfigW (output)
 *       points to OEMTDCONFIGW structure to copy to
 *
 *    pOemTdConfigA (input)
 *       points to OEMTDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
OemTdConfigA2U( POEMTDCONFIGW pOemTdConfigW,
                POEMTDCONFIGA pOemTdConfigA )
{
    pOemTdConfigW->Adapter = pOemTdConfigA->Adapter;

    AnsiToUnicode( pOemTdConfigW->DeviceName,
                   sizeof(pOemTdConfigW->DeviceName),
                   pOemTdConfigA->DeviceName );

    pOemTdConfigW->Flags = pOemTdConfigA->Flags;
}


/*******************************************************************************
 *
 *  WdConfigU2A (UNICODE to ANSI)
 *
 *    copies WDCONFIGW elements to WDCONFIGA elements
 *
 * ENTRY:
 *    pWdConfigA (output)
 *       points to WDCONFIGA structure to copy to
 *
 *    pWdConfigW (input)
 *       points to WDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WdConfigU2A( PWDCONFIGA pWdConfigA,
             PWDCONFIGW pWdConfigW )
{
    UnicodeToAnsi( pWdConfigA->WdName,
                   sizeof(pWdConfigA->WdName),
                   pWdConfigW->WdName );

    UnicodeToAnsi( pWdConfigA->WdDLL,
                   sizeof(pWdConfigA->WdDLL),
                   pWdConfigW->WdDLL );

    UnicodeToAnsi( pWdConfigA->WsxDLL,
                   sizeof(pWdConfigA->WsxDLL),
                   pWdConfigW->WsxDLL );

    pWdConfigA->WdFlag = pWdConfigW->WdFlag;

    pWdConfigA->WdInputBufferLength = pWdConfigW->WdInputBufferLength;

    UnicodeToAnsi( pWdConfigA->CfgDLL,
                   sizeof(pWdConfigA->CfgDLL),
                   pWdConfigW->CfgDLL );

    UnicodeToAnsi( pWdConfigA->WdPrefix,
                   sizeof(pWdConfigA->WdPrefix),
                   pWdConfigW->WdPrefix );

}


/*******************************************************************************
 *
 *  WdConfigA2U (ANSI to UNICODE)
 *
 *    copies WDCONFIGA elements to WDCONFIGW elements
 *
 * ENTRY:
 *    pWdConfigW (output)
 *       points to WDCONFIGW structure to copy to
 *
 *    pWdConfigA (input)
 *       points to WDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WdConfigA2U( PWDCONFIGW pWdConfigW,
             PWDCONFIGA pWdConfigA )
{
    AnsiToUnicode( pWdConfigW->WdName,
                   sizeof(pWdConfigW->WdName),
                   pWdConfigA->WdName );

    AnsiToUnicode( pWdConfigW->WdDLL,
                   sizeof(pWdConfigW->WdDLL),
                   pWdConfigA->WdDLL );

    AnsiToUnicode( pWdConfigW->WsxDLL,
                   sizeof(pWdConfigW->WsxDLL),
                   pWdConfigA->WsxDLL );

    pWdConfigW->WdFlag = pWdConfigA->WdFlag;

    pWdConfigW->WdInputBufferLength = pWdConfigA->WdInputBufferLength;

     AnsiToUnicode( pWdConfigW->CfgDLL,
                   sizeof(pWdConfigW->CfgDLL),
                   pWdConfigA->CfgDLL );

     AnsiToUnicode( pWdConfigW->WdPrefix,
                    sizeof(pWdConfigW->WdPrefix),
                    pWdConfigA->WdPrefix );

}


/*******************************************************************************
 *
 *  CdConfigU2A (UNICODE to ANSI)
 *
 *    copies CDCONFIGW elements to CDCONFIGA elements
 *
 * ENTRY:
 *    pCdConfigA (output)
 *       points to CDCONFIGA structure to copy to
 *
 *    pCdConfigW (input)
 *       points to CDCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
CdConfigU2A( PCDCONFIGA pCdConfigA,
             PCDCONFIGW pCdConfigW )
{
    pCdConfigA->CdClass = pCdConfigW->CdClass;

    UnicodeToAnsi( pCdConfigA->CdName,
                   sizeof(pCdConfigA->CdName),
                   pCdConfigW->CdName );

    UnicodeToAnsi( pCdConfigA->CdDLL,
                   sizeof(pCdConfigA->CdDLL),
                   pCdConfigW->CdDLL );

    pCdConfigA->CdFlag = pCdConfigW->CdFlag;
}


/*******************************************************************************
 *
 *  CdConfigA2U (ANSI to UNICODE)
 *
 *    copies CDCONFIGA elements to CDCONFIGW elements
 *
 * ENTRY:
 *    pCdConfigW (output)
 *       points to CDCONFIGW structure to copy to
 *
 *    pCdConfigA (input)
 *       points to CDCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
CdConfigA2U( PCDCONFIGW pCdConfigW,
             PCDCONFIGA pCdConfigA )
{
    pCdConfigW->CdClass = pCdConfigA->CdClass;

    AnsiToUnicode( pCdConfigW->CdName,
                   sizeof(pCdConfigW->CdName),
                   pCdConfigA->CdName );

    AnsiToUnicode( pCdConfigW->CdDLL,
                   sizeof(pCdConfigW->CdDLL),
                   pCdConfigA->CdDLL );

    pCdConfigW->CdFlag = pCdConfigA->CdFlag;
}


/*******************************************************************************
 *
 *  WinStationCreateU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCREATEW elements to WINSTATIONCREATEA elements
 *
 * ENTRY:
 *    pWinStationCreateA (output)
 *       points to WINSTATIONCREATEA structure to copy to
 *
 *    pWinStationCreateW (input)
 *       points to WINSTATIONCREATEW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationCreateU2A( PWINSTATIONCREATEA pWinStationCreateA,
                     PWINSTATIONCREATEW pWinStationCreateW )
{
    pWinStationCreateA->fEnableWinStation = pWinStationCreateW->fEnableWinStation;
    pWinStationCreateA->MaxInstanceCount = pWinStationCreateW->MaxInstanceCount;
}


/*******************************************************************************
 *
 *  WinStationCreateA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONCREATEA elements to WINSTATIONCREATEW elements
 *
 * ENTRY:
 *    pWinStationCreateW (output)
 *       points to WINSTATIONCREATEW structure to copy to
 *
 *    pWinStationCreateA (input)
 *       points to WINSTATIONCREATEA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationCreateA2U( PWINSTATIONCREATEW pWinStationCreateW,
                     PWINSTATIONCREATEA pWinStationCreateA )
{
    pWinStationCreateW->fEnableWinStation = pWinStationCreateA->fEnableWinStation;
    pWinStationCreateW->MaxInstanceCount = pWinStationCreateA->MaxInstanceCount;
}


/*******************************************************************************
 *
 *  WinStationConfigU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCONFIGW elements to WINSTATIONCONFIGA elements
 *
 * ENTRY:
 *    pWinStationConfigA (output)
 *       points to WINSTATIONCONFIGA structure to copy to
 *
 *    pWinStationConfigW (input)
 *       points to WINSTATIONCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationConfigU2A( PWINSTATIONCONFIGA pWinStationConfigA,
                     PWINSTATIONCONFIGW pWinStationConfigW )
{
    UnicodeToAnsi( pWinStationConfigA->Comment,
                   sizeof(pWinStationConfigA->Comment),
                   pWinStationConfigW->Comment );

    UserConfigU2A( &(pWinStationConfigA->User),
                   &(pWinStationConfigW->User) );

    RtlCopyMemory( pWinStationConfigA->OEMId,
                   pWinStationConfigW->OEMId,
                   sizeof(pWinStationConfigW->OEMId) );
}


/*******************************************************************************
 *
 *  WinStationConfigA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONCONFIGA elements to WINSTATIONCONFIGW elements
 *
 * ENTRY:
 *    pWinStationConfigW (output)
 *       points to WINSTATIONCONFIGW structure to copy to
 *
 *    pWinStationConfigA (input)
 *       points to WINSTATIONCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationConfigA2U( PWINSTATIONCONFIGW pWinStationConfigW,
                     PWINSTATIONCONFIGA pWinStationConfigA )
{
    AnsiToUnicode( pWinStationConfigW->Comment,
                   sizeof(pWinStationConfigW->Comment),
                   pWinStationConfigA->Comment );

    UserConfigA2U( &(pWinStationConfigW->User),
                   &(pWinStationConfigA->User) );

    RtlCopyMemory( pWinStationConfigW->OEMId,
                   pWinStationConfigA->OEMId,
                   sizeof(pWinStationConfigA->OEMId) );
}


/*******************************************************************************
 *
 *  UserConfigU2A (UNICODE to ANSI)
 *
 *    copies USERCONFIGW elements to USERCONFIGA elements
 *
 * ENTRY:
 *    pUserConfigA (output)
 *       points to USERCONFIGA structure to copy to
 *
 *    pUserConfigW (input)
 *       points to USERCONFIGW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UserConfigU2A( PUSERCONFIGA pUserConfigA,
               PUSERCONFIGW pUserConfigW )
{
    pUserConfigA->fInheritAutoLogon            = pUserConfigW->fInheritAutoLogon;
    pUserConfigA->fInheritResetBroken          = pUserConfigW->fInheritResetBroken;
    pUserConfigA->fInheritReconnectSame        = pUserConfigW->fInheritReconnectSame;
    pUserConfigA->fInheritInitialProgram       = pUserConfigW->fInheritInitialProgram;
    pUserConfigA->fInheritCallback             = pUserConfigW->fInheritCallback;
    pUserConfigA->fInheritCallbackNumber       = pUserConfigW->fInheritCallbackNumber;
    pUserConfigA->fInheritShadow               = pUserConfigW->fInheritShadow;
    pUserConfigA->fInheritMaxSessionTime       = pUserConfigW->fInheritMaxSessionTime;
    pUserConfigA->fInheritMaxDisconnectionTime = pUserConfigW->fInheritMaxDisconnectionTime;
    pUserConfigA->fInheritMaxIdleTime          = pUserConfigW->fInheritMaxIdleTime;
    pUserConfigA->fInheritAutoClient           = pUserConfigW->fInheritAutoClient;
    pUserConfigA->fInheritSecurity             = pUserConfigW->fInheritSecurity;

    pUserConfigA->fPromptForPassword = pUserConfigW->fPromptForPassword;
    pUserConfigA->fResetBroken       = pUserConfigW->fResetBroken;
    pUserConfigA->fReconnectSame     = pUserConfigW->fReconnectSame;
    pUserConfigA->fLogonDisabled     = pUserConfigW->fLogonDisabled;
    pUserConfigA->fWallPaperDisabled = pUserConfigW->fWallPaperDisabled;
    pUserConfigA->fAutoClientDrives  = pUserConfigW->fAutoClientDrives;
    pUserConfigA->fAutoClientLpts    = pUserConfigW->fAutoClientLpts;
    pUserConfigA->fForceClientLptDef = pUserConfigW->fForceClientLptDef;
    pUserConfigA->fDisableEncryption = pUserConfigW->fDisableEncryption;
    pUserConfigA->fHomeDirectoryMapRoot = pUserConfigW->fHomeDirectoryMapRoot;
    pUserConfigA->fUseDefaultGina    = pUserConfigW->fUseDefaultGina;
    pUserConfigA->fCursorBlinkDisabled = pUserConfigW->fCursorBlinkDisabled;

    pUserConfigA->fDisableCpm = pUserConfigW->fDisableCpm;
    pUserConfigA->fDisableCdm = pUserConfigW->fDisableCdm;
    pUserConfigA->fDisableCcm = pUserConfigW->fDisableCcm;
    pUserConfigA->fDisableLPT = pUserConfigW->fDisableLPT;
    pUserConfigA->fDisableClip = pUserConfigW->fDisableClip;
    pUserConfigA->fDisableExe = pUserConfigW->fDisableExe;
    pUserConfigA->fDisableCam = pUserConfigW->fDisableCam;

    UnicodeToAnsi( pUserConfigA->UserName,
                   sizeof(pUserConfigA->UserName),
                   pUserConfigW->UserName );

    UnicodeToAnsi( pUserConfigA->Domain,
                   sizeof(pUserConfigA->Domain),
                   pUserConfigW->Domain );

    UnicodeToAnsi( pUserConfigA->Password,
                   sizeof(pUserConfigA->Password),
                   pUserConfigW->Password );

    UnicodeToAnsi( pUserConfigA->WorkDirectory,
                   sizeof(pUserConfigA->WorkDirectory),
                   pUserConfigW->WorkDirectory );

    UnicodeToAnsi( pUserConfigA->InitialProgram,
                   sizeof(pUserConfigA->InitialProgram),
                   pUserConfigW->InitialProgram );

    UnicodeToAnsi( pUserConfigA->CallbackNumber,
                   sizeof(pUserConfigA->CallbackNumber),
                   pUserConfigW->CallbackNumber );

    pUserConfigA->Callback             = pUserConfigW->Callback;
    pUserConfigA->Shadow               = pUserConfigW->Shadow;
    pUserConfigA->MaxConnectionTime    = pUserConfigW->MaxConnectionTime;
    pUserConfigA->MaxDisconnectionTime = pUserConfigW->MaxDisconnectionTime;
    pUserConfigA->MaxIdleTime          = pUserConfigW->MaxIdleTime;
    pUserConfigA->KeyboardLayout       = pUserConfigW->KeyboardLayout;
    pUserConfigA->MinEncryptionLevel   = pUserConfigW->MinEncryptionLevel;

    UnicodeToAnsi( pUserConfigA->WFProfilePath,
                   sizeof(pUserConfigA->WFProfilePath),
                   pUserConfigW->WFProfilePath );

    UnicodeToAnsi( pUserConfigA->WFHomeDir,
                   sizeof(pUserConfigA->WFHomeDir),
                   pUserConfigW->WFHomeDir );

    UnicodeToAnsi( pUserConfigA->WFHomeDirDrive,
                   sizeof(pUserConfigA->WFHomeDirDrive),
                   pUserConfigW->WFHomeDirDrive );

}


/*******************************************************************************
 *
 *  UserConfigA2U (ANSI to UNICODE)
 *
 *    copies USERCONFIGA elements to USERCONFIGW elements
 *
 * ENTRY:
 *    pUserConfigW (output)
 *       points to USERCONFIGW structure to copy to
 *
 *    pUserConfigA (input)
 *       points to USERCONFIGA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
UserConfigA2U( PUSERCONFIGW pUserConfigW,
               PUSERCONFIGA pUserConfigA )
{
    pUserConfigW->fInheritAutoLogon            = pUserConfigA->fInheritAutoLogon;
    pUserConfigW->fInheritResetBroken          = pUserConfigA->fInheritResetBroken;
    pUserConfigW->fInheritReconnectSame        = pUserConfigA->fInheritReconnectSame;
    pUserConfigW->fInheritInitialProgram       = pUserConfigA->fInheritInitialProgram;
    pUserConfigW->fInheritCallback             = pUserConfigA->fInheritCallback;
    pUserConfigW->fInheritCallbackNumber       = pUserConfigA->fInheritCallbackNumber;
    pUserConfigW->fInheritShadow               = pUserConfigA->fInheritShadow;
    pUserConfigW->fInheritMaxSessionTime       = pUserConfigA->fInheritMaxSessionTime;
    pUserConfigW->fInheritMaxDisconnectionTime = pUserConfigA->fInheritMaxDisconnectionTime;
    pUserConfigW->fInheritMaxIdleTime          = pUserConfigA->fInheritMaxIdleTime;
    pUserConfigW->fInheritAutoClient           = pUserConfigA->fInheritAutoClient;
    pUserConfigW->fInheritSecurity             = pUserConfigA->fInheritSecurity;

    pUserConfigW->fPromptForPassword = pUserConfigA->fPromptForPassword;
    pUserConfigW->fResetBroken       = pUserConfigA->fResetBroken;
    pUserConfigW->fReconnectSame     = pUserConfigA->fReconnectSame;
    pUserConfigW->fLogonDisabled     = pUserConfigA->fLogonDisabled;
    pUserConfigW->fWallPaperDisabled = pUserConfigA->fWallPaperDisabled;
    pUserConfigW->fAutoClientDrives  = pUserConfigA->fAutoClientDrives;
    pUserConfigW->fAutoClientLpts    = pUserConfigA->fAutoClientLpts;
    pUserConfigW->fForceClientLptDef = pUserConfigA->fForceClientLptDef;
    pUserConfigW->fDisableEncryption = pUserConfigA->fDisableEncryption;
    pUserConfigW->fHomeDirectoryMapRoot = pUserConfigA->fHomeDirectoryMapRoot;
    pUserConfigW->fUseDefaultGina    = pUserConfigA->fUseDefaultGina;
    pUserConfigW->fCursorBlinkDisabled = pUserConfigA->fCursorBlinkDisabled;

    pUserConfigW->fDisableCpm = pUserConfigA->fDisableCpm;
    pUserConfigW->fDisableCdm = pUserConfigA->fDisableCdm;
    pUserConfigW->fDisableCcm = pUserConfigA->fDisableCcm;
    pUserConfigW->fDisableLPT = pUserConfigA->fDisableLPT;
    pUserConfigW->fDisableClip = pUserConfigA->fDisableClip;
    pUserConfigW->fDisableExe = pUserConfigA->fDisableExe;
    pUserConfigW->fDisableCam = pUserConfigA->fDisableCam;

    AnsiToUnicode( pUserConfigW->UserName,
                   sizeof(pUserConfigW->UserName),
                   pUserConfigA->UserName );

    AnsiToUnicode( pUserConfigW->Domain,
                   sizeof(pUserConfigW->Domain),
                   pUserConfigA->Domain );

    AnsiToUnicode( pUserConfigW->Password,
                   sizeof(pUserConfigW->Password),
                   pUserConfigA->Password );

    AnsiToUnicode( pUserConfigW->WorkDirectory,
                   sizeof(pUserConfigW->WorkDirectory),
                   pUserConfigA->WorkDirectory );

    AnsiToUnicode( pUserConfigW->InitialProgram,
                   sizeof(pUserConfigW->InitialProgram),
                   pUserConfigA->InitialProgram );

    AnsiToUnicode( pUserConfigW->CallbackNumber,
                   sizeof(pUserConfigW->CallbackNumber),
                   pUserConfigA->CallbackNumber );

    pUserConfigW->Callback             = pUserConfigA->Callback;
    pUserConfigW->Shadow               = pUserConfigA->Shadow;
    pUserConfigW->MaxConnectionTime    = pUserConfigA->MaxConnectionTime;
    pUserConfigW->MaxDisconnectionTime = pUserConfigA->MaxDisconnectionTime;
    pUserConfigW->MaxIdleTime          = pUserConfigA->MaxIdleTime;
    pUserConfigW->KeyboardLayout       = pUserConfigA->KeyboardLayout;
    pUserConfigW->MinEncryptionLevel   = pUserConfigA->MinEncryptionLevel;

    AnsiToUnicode( pUserConfigW->WFProfilePath,
                   sizeof(pUserConfigW->WFProfilePath),
                   pUserConfigA->WFProfilePath );

    AnsiToUnicode( pUserConfigW->WFHomeDir,
                   sizeof(pUserConfigW->WFHomeDir),
                   pUserConfigA->WFHomeDir );

    AnsiToUnicode( pUserConfigW->WFHomeDirDrive,
                   sizeof(pUserConfigW->WFHomeDirDrive),
                   pUserConfigA->WFHomeDirDrive );

}


/*******************************************************************************
 *
 *  WinStationPrinterU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONPRINTERW elements to WINSTATIONPRINTERA elements
 *
 * ENTRY:
 *    pWinStationPrinterA (output)
 *       points to WINSTATIONPRINTERA structure to copy to
 *
 *    pWinStationPrinterW (input)
 *       points to WINSTATIONPRINTERW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationPrinterU2A( PWINSTATIONPRINTERA pWinStationPrinterA,
                      PWINSTATIONPRINTERW pWinStationPrinterW )
{
    UnicodeToAnsi( pWinStationPrinterA->Lpt1,
                   sizeof(pWinStationPrinterA->Lpt1),
                   pWinStationPrinterW->Lpt1 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt2,
                   sizeof(pWinStationPrinterA->Lpt2),
                   pWinStationPrinterW->Lpt2 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt3,
                   sizeof(pWinStationPrinterA->Lpt3),
                   pWinStationPrinterW->Lpt3 );

    UnicodeToAnsi( pWinStationPrinterA->Lpt4,
                   sizeof(pWinStationPrinterA->Lpt4),
                   pWinStationPrinterW->Lpt4 );

}


/*******************************************************************************
 *
 *  WinStationPrinterA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONPRINTERA elements to WINSTATIONPRINTERW elements
 *
 * ENTRY:
 *    pWinStationPrinterW (output)
 *       points to WINSTATIONPRINTERW structure to copy to
 *
 *    pWinStationPrinterA (input)
 *       points to WINSTATIONPRINTERA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationPrinterA2U( PWINSTATIONPRINTERW pWinStationPrinterW,
                      PWINSTATIONPRINTERA pWinStationPrinterA )
{
    AnsiToUnicode( pWinStationPrinterW->Lpt1,
                   sizeof(pWinStationPrinterW->Lpt1),
                   pWinStationPrinterA->Lpt1 );

    AnsiToUnicode( pWinStationPrinterW->Lpt2,
                   sizeof(pWinStationPrinterW->Lpt2),
                   pWinStationPrinterA->Lpt2 );

    AnsiToUnicode( pWinStationPrinterW->Lpt3,
                   sizeof(pWinStationPrinterW->Lpt3),
                   pWinStationPrinterA->Lpt3 );

    AnsiToUnicode( pWinStationPrinterW->Lpt4,
                   sizeof(pWinStationPrinterW->Lpt4),
                   pWinStationPrinterA->Lpt4 );

}


/*******************************************************************************
 *
 *  WinStationInformationU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONINFORMATIONW elements to WINSTATIONINFORMATIONA elements
 *
 * ENTRY:
 *    pWinStationInformationA (output)
 *       points to WINSTATIONINFORMATIONA structure to copy to
 *
 *    pWinStationInformationW (input)
 *       points to WINSTATIONINFORMATIONW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationInformationU2A( PWINSTATIONINFORMATIONA pWinStationInformationA,
                          PWINSTATIONINFORMATIONW pWinStationInformationW )
{
    pWinStationInformationA->ConnectState = pWinStationInformationW->ConnectState;

    UnicodeToAnsi( pWinStationInformationA->WinStationName,
                   sizeof(pWinStationInformationA->WinStationName),
                   pWinStationInformationW->WinStationName );

    pWinStationInformationA->LogonId = pWinStationInformationW->LogonId;

    pWinStationInformationA->ConnectTime = pWinStationInformationW->ConnectTime;
    pWinStationInformationA->DisconnectTime = pWinStationInformationW->DisconnectTime;
    pWinStationInformationA->LastInputTime = pWinStationInformationW->LastInputTime;
    pWinStationInformationA->LogonTime = pWinStationInformationW->LogonTime;

    pWinStationInformationA->Status = pWinStationInformationW->Status;

    UnicodeToAnsi( pWinStationInformationA->Domain,
                   sizeof(pWinStationInformationA->Domain),
                   pWinStationInformationW->Domain );

    UnicodeToAnsi( pWinStationInformationA->UserName,
                   sizeof(pWinStationInformationA->UserName),
                   pWinStationInformationW->UserName );
}


/*******************************************************************************
 *
 *  WinStationInformationA2U (ANSI to UNICODE)
 *
 *    copies WINSTATIONINFORMATIONA elements to WINSTATIONINFORMATIONW elements
 *
 * ENTRY:
 *    pWinStationInformationW (output)
 *       points to WINSTATIONINFORMATIONW structure to copy to
 *
 *    pWinStationInformationA (input)
 *       points to WINSTATIONINFORMATIONA structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationInformationA2U( PWINSTATIONINFORMATIONW pWinStationInformationW,
                          PWINSTATIONINFORMATIONA pWinStationInformationA )
{
    pWinStationInformationW->ConnectState = pWinStationInformationA->ConnectState;

    AnsiToUnicode( pWinStationInformationW->WinStationName,
                   sizeof(pWinStationInformationW->WinStationName),
                   pWinStationInformationA->WinStationName );

    pWinStationInformationW->LogonId = pWinStationInformationA->LogonId;

    pWinStationInformationW->ConnectTime = pWinStationInformationA->ConnectTime;
    pWinStationInformationW->DisconnectTime = pWinStationInformationA->DisconnectTime;
    pWinStationInformationW->LastInputTime = pWinStationInformationA->LastInputTime;
    pWinStationInformationW->LogonTime = pWinStationInformationA->LogonTime;

    pWinStationInformationW->Status = pWinStationInformationA->Status;

    AnsiToUnicode( pWinStationInformationW->Domain,
                   sizeof(pWinStationInformationW->Domain),
                   pWinStationInformationA->Domain );

    AnsiToUnicode( pWinStationInformationW->UserName,
                   sizeof(pWinStationInformationW->UserName),
                   pWinStationInformationA->UserName );
}


/*******************************************************************************
 *
 *  WinStationClientU2A (UNICODE to ANSI)
 *
 *    copies WINSTATIONCLIENTW elements to WINSTATIONCLIENTA elements
 *
 * ENTRY:
 *    pWinStationClientA (output)
 *       points to WINSTATIONCLIENTA structure to copy to
 *
 *    pWinStationClientW (input)
 *       points to WINSTATIONCLIENTW structure to copy from
 *
 * EXIT:
 *    nothing (VOID)
 *
 ******************************************************************************/

VOID
WinStationClientU2A( PWINSTATIONCLIENTA pWinStationClientA,
                     PWINSTATIONCLIENTW pWinStationClientW )
{
    pWinStationClientA->fTextOnly          = pWinStationClientW->fTextOnly;
    pWinStationClientA->fDisableCtrlAltDel = pWinStationClientW->fDisableCtrlAltDel;

    UnicodeToAnsi( pWinStationClientA->ClientName,
                   sizeof(pWinStationClientA->ClientName),
                   pWinStationClientW->ClientName );

    UnicodeToAnsi( pWinStationClientA->Domain,
                   sizeof(pWinStationClientA->Domain),
                   pWinStationClientW->Domain );

    UnicodeToAnsi( pWinStationClientA->UserName,
                   sizeof(pWinStationClientA->UserName),
                   pWinStationClientW->UserName );

    UnicodeToAnsi( pWinStationClientA->Password,
                   sizeof(pWinStationClientA->Password),
                   pWinStationClientW->Password );

    UnicodeToAnsi( pWinStationClientA->WorkDirectory,
                   sizeof(pWinStationClientA->WorkDirectory),
                   pWinStationClientW->WorkDirectory );

    UnicodeToAnsi( pWinStationClientA->InitialProgram,
                   sizeof(pWinStationClientA->InitialProgram),
                   pWinStationClientW->InitialProgram );

    UnicodeToAnsi( pWinStationClientA->clientDigProductId, 
                                 sizeof( pWinStationClientA->clientDigProductId), 
                                 pWinStationClientW->clientDigProductId );

    pWinStationClientA->SerialNumber = pWinStationClientW->SerialNumber;

    pWinStationClientA->EncryptionLevel = pWinStationClientW->EncryptionLevel;


    UnicodeToAnsi( pWinStationClientA->ClientAddress,
                   sizeof(pWinStationClientA->ClientAddress),
                   pWinStationClientW->ClientAddress);

    pWinStationClientA->HRes = pWinStationClientW->HRes;

    pWinStationClientA->VRes = pWinStationClientW->VRes;

    pWinStationClientA->ColorDepth = pWinStationClientW->ColorDepth;

    pWinStationClientA->ProtocolType = pWinStationClientW->ProtocolType;

    pWinStationClientA->KeyboardLayout = pWinStationClientW->KeyboardLayout;

    UnicodeToAnsi( pWinStationClientA->ClientDirectory,
                   sizeof(pWinStationClientA->ClientDirectory),
                   pWinStationClientW->ClientDirectory);

    UnicodeToAnsi( pWinStationClientA->ClientLicense,
                   sizeof(pWinStationClientA->ClientLicense),
                   pWinStationClientW->ClientLicense);

    UnicodeToAnsi( pWinStationClientA->ClientModem,
                   sizeof(pWinStationClientA->ClientModem),
                   pWinStationClientW->ClientModem);

    pWinStationClientA->ClientBuildNumber = pWinStationClientW->ClientBuildNumber;

    pWinStationClientA->ClientHardwareId = pWinStationClientW->ClientHardwareId;

    pWinStationClientA->ClientProductId = pWinStationClientW->ClientProductId;

    pWinStationClientA->OutBufCountHost = pWinStationClientW->OutBufCountHost;

    pWinStationClientA->OutBufCountClient = pWinStationClientW->OutBufCountClient;

    pWinStationClientA->OutBufLength = pWinStationClientW->OutBufLength;
}


VOID WinStationProductIdU2A( PWINSTATIONPRODIDA pWinStationProdIdA, PWINSTATIONPRODIDW pWinStationProdIdW)
{
    UnicodeToAnsi( pWinStationProdIdA->DigProductId,
                   sizeof(pWinStationProdIdA->DigProductId),
                   pWinStationProdIdW->DigProductId);
    UnicodeToAnsi( pWinStationProdIdA->ClientDigProductId,
                   sizeof(pWinStationProdIdA->ClientDigProductId),
                   pWinStationProdIdW->ClientDigProductId);
    UnicodeToAnsi( pWinStationProdIdA->OuterMostDigProductId,
                   sizeof(pWinStationProdIdA->OuterMostDigProductId),
                   pWinStationProdIdW->OuterMostDigProductId);
    pWinStationProdIdA->curentSessionId = pWinStationProdIdW->curentSessionId;
    pWinStationProdIdA->ClientSessionId = pWinStationProdIdW->ClientSessionId;
    pWinStationProdIdA->OuterMostSessionId = pWinStationProdIdW->OuterMostSessionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\compress\adcg.h ===
/**INC+**********************************************************************/
/* Header:    adcg.h                                                        */
/*                                                                          */
/* Purpose:   Precompiled header                                            */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/*                                                                          */
/** Changes:
 * $Log:   Y:/logs/client/adcg.h_v  $
 * 
 *    Rev 1.4   03 Jul 1997 11:58:58   AK
 * SFR0000: Initial development completed
 * 
**/
/**INC-**********************************************************************/

#ifdef COMPRESS_USERMODE_LIB                    
#include <adcgbase.h>
#endif

#ifdef COMPRESS_KERNEL_LIB
#include <nt.h>
#include <ntrtl.h>
#include <ntdef.h>

#define FAR
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\win32com.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Win32 specific (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


SDK_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
CRT_LIB_PATH = $(BASEDIR)\public\sdk\lib\*
SDK_INC_PATH = $(BASEDIR)\public\sdk\inc
CRT_INC_PATH = $(SDK_INC_PATH)\crt

#
# Set common options
#

#
# Use Multi-threaded static library by default.
#
USE_LIBCMT = 1

#
# Insure that we will work on Win 95
#
#CHICAGO_PROJECT = 1
#CHICAGO_PRODUCT = 1

CBSTRING = -cbstring
P5_FDIV_FIX = /QIfdiv-
P5_0F_FIX = /QIf
C_INCREMENTAL_FLAG = /Gi- /Gm-
EH_FLAGS = /GX- /GR-
FRAME_PTR_ON = /Oy
FRAME_PTR_OFF = /Oy-
CL_TARGET_SPEC = /Yl$(TARGETNAME)

#
# Library files, referenced by <component>.inc file, eg client.inc
#
CLIENT_LIB_DLL = \
   $(SDK_LIB_PATH)\kernel32.lib \
   $(SDK_LIB_PATH)\advapi32.lib \
   $(SDK_LIB_PATH)\user32.lib   \
   $(SDK_LIB_PATH)\gdi32.lib    \
   $(SDK_LIB_PATH)\imagehlp.lib

CLIENT_LIB_EXE = \
    $(SDK_LIB_PATH)\wsock32.lib \
    $(SDK_LIB_PATH)\shell32.lib \
#    $(SDK_LIB_PATH)\netapi32.lib

#
# Additional compiler flags
#
WIN32_DEFINE = -DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
CLIENT_SECURITY = -DISSP_LEVEL=32
C_DEFINES  = $(C_DEFINES) -DWIN32 -D_WIN32 -DWIN_95_32_BIT
C_DEFS_UNICODE  = -DUNICODE -D_UNICODE

!IF "$(_PERF)" == "1"
C_DEFINES = $(C_DEFINES) -DPERF
!ENDIF

#
# Additional linker flags
#

#LINKER_FLAGS = $(LINKER_FLAGS) -map

#
# File name prefix for 32-bit
#
PLATFORM_PREFIX = n

C_DEFINES=$(C_DEFINES) -DOS_WIN32 -DOS_WINNT -DSECURITY_WIN32

#
# Setup MSC_OPTIMIZATION for debug and retail
#
!if "$(FREEBUILD)" == "0"
MSC_OPTIMIZATION=/Odi
!else
MSC_OPTIMIZATION=/Oxs
!endif

386_WARNING_LEVEL=/W3

!ifdef ICACAP_BUILD

MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Gh
PERFLIBS=$(SDK_LIB_PATH)\icap.lib
LINKLIBS=$(LINKLIBS) $(PERFLIBS)

!endif // ICACAP_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\newcommon.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Generic (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

#
# Disable perf by default.
# Set this to 1 to enable perf.
#
BUILD_PRF = 0

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN = 1

UMTYPE = windows

#
# Additional compiler flags
#
!  if defined(USE_UNICODE)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif

!if !$(FREEBUILD)
C_DEFINES = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif

#
# Prevent bldnt pulling in various libraries
#
LIBC_LIB =
NO_NTDLL = 1

#
# include files.
#
INCLUDES= \
   ..; \
   $(TERMSRV_ROOT)\inc; \
   $(TERMSRV_ROOT)\common\inc; \
   $(TERMSRV_ROOT)\common\license\inc; \
   $(TERMSRV_ROOT)\newclient\inc; \
!ifdef WIN16_BUILD
   $(PUBLIC_DS_INC_PATH)\crypto
!else
   $(DS_INC_PATH)\crypto
!endif

#
# Common compiler flags
#
C_DEFINES = $(C_DEFINES) -DSTRICT $(CLIENT_SECURITY)

MSC_WARNING_LEVEL= $(C_WARNINGS)
# Use /WX to change warnings into errors

!if "$(FREEBUILD)" == "1"
CLIENT_TRC_LIB=
!if "$(BUILD_PRF)"=="1"
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!else
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!endif
!else
DEBUG_DEFINE=DC_DEBUG
C_DEFINES=$(C_DEFINES) -DTRC_CL=0 -DTRC_CP -D$(DEBUG_DEFINE)
!endif

!if "$(BUILD_HIPROF)"=="1"
C_DEFINES=$(C_DEFINES) -DHIPROF
!endif

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(PROCESSOR_ARCHITECTURE)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!if "$(BUILD_HIPROF)"=="1"
LINKER_FLAGS = $(LINKER_FLAGS) -FIXED:NO
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\common.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    common.inc - Generic (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Madan Appiah - Sep. 5th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

#
# Disable perf by default.
# Set this to 1 to enable perf.
#
BUILD_PRF = 0

#
# Defining this allows windows.h to include other headers
#
NOT_LEAN_AND_MEAN = 1

UMTYPE = windows

#
# Additional compiler flags
#
!  if defined(USE_UNICODE)
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif

!if !$(FREEBUILD)
C_DEFINES = $(C_DEFINES) -D_DEBUG -DDEBUG
!endif

#
# Prevent bldnt pulling in various libraries
#
LIBC_LIB =
NO_NTDLL = 1

#
# include files.
#
INCLUDES= \
   ..; \
   $(TERMSRV_ROOT)\inc; \
   $(TERMSRV_ROOT)\common\inc; \
   $(TERMSRV_ROOT)\common\license\inc; \
   $(TERMSRV_ROOT)\client\inc; \
!ifdef WIN16_BUILD
   $(PUBLIC_DS_INC_PATH)\crypto
!else
   $(DS_INC_PATH)\crypto
!endif

#
# Common compiler flags
#
C_DEFINES = $(C_DEFINES) -DSTRICT $(CLIENT_SECURITY)

MSC_WARNING_LEVEL= $(C_WARNINGS)
# Use /WX to change warnings into errors

!if "$(FREEBUILD)" == "1"
CLIENT_TRC_LIB=
!if "$(BUILD_PRF)"=="1"
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!else
C_DEFINES=$(C_DEFINES) -DTRC_CL=5
!endif
!else
DEBUG_DEFINE=DC_DEBUG
C_DEFINES=$(C_DEFINES) -DTRC_CL=0 -DTRC_CP -D$(DEBUG_DEFINE)
!endif

!if "$(BUILD_HIPROF)"=="1"
C_DEFINES=$(C_DEFINES) -DHIPROF
!endif

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(PROCESSOR_ARCHITECTURE)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!if "$(BUILD_HIPROF)"=="1"
LINKER_FLAGS = $(LINKER_FLAGS) -FIXED:NO
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\wincecom.inc ===
!IF 0

Copyright (c) 1989-98  Microsoft Corporation

Module Name:

    wincecom.inc - Win32 specific (TShare Client) build definitions

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Adam Overton- Oct. 24th 1997

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!if ("$(WINCEDEBUG)" == "debug")
FREEBUILD=0
!else
FREEBUILD=1
!endif

BUILDINGFORCE=1

CDEFINES = $(CDEFINES) -DWINCE_GLOBAL_ALLOC_DEFINED

!if ("$(_TRACKER_ENABLE_)" != "")
CDEFINES = $(CDEFINES) -D_TRACKER_ENABLE_=$(_TRACKER_ENABLE_)
!endif

#
# Set common options
#


WINCEATL30=1
OS_WINCE=1

#
# Library files, referenced by <component>.inc file, eg client.inc
#
TARGETLIBS= $(TARGETLIBS) \
    $(SDK_LIB_PATH)\coredll.lib \
    ..\..\LIB\WINCE\$(_CPUINDPATH)\wsasync.lib \
    $(SDK_LIB_PATH)\winsock.lib

LIBPATH = $(LIBPATH);\
    $(SDKROOT)\public\common\sdk\lib\$(_TGTCPU)\$(WINCEDEBUG)\

#CLIENT_LIB_DLL = \
#   $(SDK_LIB_PATH)\kernel32.lib \
#   $(SDK_LIB_PATH)\advapi32.lib \
#   $(SDK_LIB_PATH)\user32.lib   \
#   $(SDK_LIB_PATH)\gdi32.lib    \
#   $(SDK_LIB_PATH)\imagehlp.lib

#CLIENT_LIB_EXE = \
#    $(SDK_LIB_PATH)\winsock.lib \
#    $(SDK_LIB_PATH)\shell32.lib

#
# Additional compiler flags
#
WIN32_DEFINE = -DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400
CLIENT_SECURITY = -DISSP_LEVEL=32
C_DEFINES  = $(C_DEFINES) -DWIN32 -D_WIN32 -DWIN_95_32_BIT
#C_DEFINES=$(C_DEFINES) -DUSE_LICENSE -DENFORCE_LICENSE
C_DEFS_UNICODE  = -DUNICODE -D_UNICODE

# DC_NO_UNALIGNED should be set for any processor which does not allow
# non-aligned memory access
!IF "$(_TGTCPUFAMILY)" != "x86"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF

!IF "$(_PERF)" == "1"
C_DEFINES = $(C_DEFINES) -DPERF
!ENDIF

#
# Additional linker flags
#

#LINKER_FLAGS = $(LINKER_FLAGS) -map

#
# File name prefix for 32-bit
#
PLATFORM_PREFIX = n

C_DEFINES=$(C_DEFINES) -DOS_WIN32 -DSECURITY_WIN32 -DOS_WINCE

#
# RC flags
#
RDEFINES=$(RDEFINES) -DOS_WINCE
!if "$(FREEBUILD)" == "0"
RDEFINES=$(RDEFINES) -DDC_DEBUG
!endif

#
# Setup MSC_OPTIMIZATION for debug and retail
#
#!if "$(FREEBUILD)" == "0"
#MSC_OPTIMIZATION=/Od
#!else
#MSC_OPTIMIZATION=/Oxs
#!endif

#386_WARNING_LEVEL=/W3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\compress\decompr.cpp ===
//************************************************************************
// compress.c
//
// Decompression code for MPPC compression. Compression code is on the
//     server, \nt\private\ntos\termsrv\rdp\rdpwd\compress.c.
//
// Copyright(c) Microsoft Corp., 1990-1999
//
// Revision history:
//   5/5/94    Created                     gurdeep
//   4/20/1999 Optimized for TS            jparsons, erikma
//   8/24/2000 Fixed bugs                  nadima
//************************************************************************

#include <adcg.h>

#include <stdio.h>
#include <stdlib.h>

#include <compress.h>

#ifdef COMPR_DEBUG

#ifdef DECOMPRESS_KERNEL_DEBUG
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <winsta.h>
#include <icadd.h>
#include <icaapi.h>
//Include all this stuff just to pickup icaapi.h

#define DbgComprPrint(_x_) DbgPrint _x_
#define DbgComprBreakOnDbg IcaBreakOnDebugger

#else //DECOMPRESS_KERNEL_DEBUG

_inline ULONG DbgUserPrint(TCHAR* Format, ...)
{
    va_list arglist;
    TCHAR Buffer[512];
    ULONG retval;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    retval = _vsntprintf(Buffer, sizeof(Buffer)/sizeof(Buffer[0]), 
                         Format, arglist);

    if (retval != -1) {
        OutputDebugString(Buffer);
        OutputDebugString(_T("\n"));
    }
    return retval;
}

#define DbgComprPrint(_x_) DbgUserPrint _x_
#define DbgComprBreakOnDbg DebugBreak
#endif //DECOMPRESS_KERNEL_DEBUG

#endif //COMPR_DEBUG

/* Bitptrs point to the current byte. The current bit (i.e. next bit to be
 * stored) is masked off by the bit entry. When this reaches zero, it is
 * reset to 0x80 and the next byte is set up. The bytes are filled MSBit
 * first. */

/* Starts the given bit pointer */
#define inbit_start(s) pbyte = s; bit = 16; byte=(*pbyte << 8) + *(pbyte+1); pbyte++;
#define inbit_end()      if (bit != 16) pbyte++;    

//
// Without the ROBUSTness fix, the code will try to prefetch
// a byte or more past then end of the input buffer which can
// cause problems in kernel mode.
//
// We fixed this by forcing kernel mode to allocate the input
// buffers with enough extra padding at the end so it's ok to
// read past the end. If someday this needs to be changed
// enable ROBUST_FIX, this _will_ slow down the algorithm.
//
//    TODO: if we define ROBUST_FIX_ENABLE flag we have to handle a couple
//    of more cases that this code does not take into account. For instance
//    if you are at the end of the buffer and you do an in_bit_16 you will overread.
//    The in_bit_next/in_bit_advance macros for the robust fix should return 
//    FALSE so the decompression fails in case we are at the end of the buffer
//    and we try to decompress further. As it is now the ROBUST_FIX macros will
//    not go past the end of the buffer but the in_bit_X (with X>7) will do.
//

#ifdef ROBUST_FIX_ENABLED
#define in_bit_next()    if (bit < 9) {            \
                            bit=16;                \
                            byte <<=8;             \
                            ++pbyte;               \
                            if(pbyte < inend) {    \
                                byte |= *(pbyte);  \
                            }                      \
                         }                         \


#define in_bit_advance() if (bit < 9) {            \
                            bit+=8;                \
                            byte <<=8;             \
                            ++pbyte;               \
                            if(pbyte < inend) {    \
                                byte |= *(pbyte);  \
                            }                      \
                         }

#else //ROBUST_FIX_ENABLED
#define in_bit_next()    if (bit < 9) {          \
                            bit=16;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }


#define in_bit_advance() if (bit < 9) {          \
                            bit+=8;              \
                            byte <<=8;           \
                            byte |= *(++pbyte);  \
                         }
#endif //ROBUST_FIX_ENABLED

/* Returns non-zero in bitset if the next bit in the stream is a 1. */
#define in_bit()     bit--; bitset = (byte >> bit) & 1; in_bit_next()


#define in_bits_2(w) bit-=2; w = (byte >> bit) & 0x03;\
                     in_bit_advance();

#define in_bits_3(w) bit-=3; w = (byte >> bit) & 0x07;\
                     in_bit_advance();

#define in_bits_4(w) bit-=4; w = (byte >> bit) & 0x0F;\
                     in_bit_advance();

#define in_bits_5(w) bit-=5; w = (byte >> bit) & 0x1F;\
                     in_bit_advance();

#define in_bits_6(w) bit-=6; w = (byte >> bit) & 0x3F;\
                     in_bit_advance();

#define in_bits_7(w) bit-=7; w = (byte >> bit) & 0x7F;\
                     in_bit_advance();

#define in_bits_8(w) bit-=8; w = (byte >> bit) & 0xFF;\
                     bit+=8; byte <<=8; byte |= *(++pbyte);


#define in_bits_9(w) bit-=9; w = (byte >> bit) & 0x1FF;          \
                     bit+=8; byte <<=8; byte |= *(++pbyte);      \
                     in_bit_advance();

#define in_bits_10(w) if (bit > 10) {                            \
                        bit-=10; w = (byte >> bit) & 0x3FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                     \
                        in_bits_2(bitset);                       \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }

#define in_bits_11(w) if (bit > 11) {                             \
                        bit-=11; w = (byte >> bit) & 0x7FF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                     \
                        in_bits_3(bitset);                         \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }


#define in_bits_12(w) if (bit > 12) {                             \
                        bit-=12; w = (byte >> bit) & 0xFFF;      \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                     \
                        in_bits_4(bitset);                         \
                        in_bits_8(w);                            \
                        w= w + (bitset << 8);                    \
                      }



#define in_bits_13(w)\
                       if (bit > 13) {                            \
                        bit-=13; w = (byte >> bit) & 0x1FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                     \
                        in_bits_5(bitset);                       \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }


#define in_bits_14(w)\
                      if (bit > 14) {                             \
                        bit-=14; w = (byte >> bit) & 0x3FFF;     \
                        bit+=8; byte <<=8; byte |= *(++pbyte);   \
                      } else {                                     \
                        in_bits_6(bitset);                         \
                        in_bits_8(w);                            \
                        w=w + (bitset << 8);                     \
                      }


#define in_bits_15(w)\
    if (bit > 15) {                             \
        bit -= 15; w = (byte >> bit) & 0x7FFF;     \
        bit += 8; byte <<= 8; byte |= *(++pbyte);   \
    } else {                                     \
        in_bits_7(bitset);                         \
        in_bits_8(w);                            \
        w = w + (bitset << 8);                     \
    }


// initrecvcontext()
//
//  Function:    Initialize RecvContext block
//
//  Parameters: IN  context -> connection decompress context
//
//  Callers of this API must allocate an object of the appropriate
//  type e.g RecvContext2_64K or RecvContext2_8K and set the
//  size field before casting to the generic type.
//
//  The cleanest way to do this would be for initrecvcontext
//  to alloc the context itself but since the code is shared
//  between client and server there is no clean way to do this.
//  (callback allocators are _not_ clean).
//
// Returns status
int initrecvcontext(RecvContext1 *context1,
                     RecvContext2_Generic *context2,
                     unsigned ComprType)
{
    context1->CurrentPtr = context2->History;
    if(ComprType == PACKET_COMPR_TYPE_64K)
    {
        if(context2->cbSize > HISTORY_SIZE_64K)
        {
            context2->cbHistorySize = HISTORY_SIZE_64K-1;
        }
        else
        {
            return FALSE;
        }
    }
    else if(ComprType == PACKET_COMPR_TYPE_8K)
    {
        if(context2->cbSize > HISTORY_SIZE_8K)
        {
            context2->cbHistorySize = HISTORY_SIZE_8K-1;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

#if COMPR_DEBUG
    //
    // Setup debug fences to detect context buffer overwrites
    //
    if (context2->cbHistorySize == (HISTORY_SIZE_64K-1))
    {
        ((RecvContext2_64K*)context2)->Debug16kFence = DEBUG_FENCE_16K_VALUE;
    }
    else if (context2->cbHistorySize == (HISTORY_SIZE_8K-1))
    {
        ((RecvContext2_8K*)context2)->Debug8kFence = DEBUG_FENCE_8K_VALUE;
    }
#endif

    memset(context2->History, 0, context2->cbHistorySize);
    return TRUE;
}


//* decompress()
//
//  Function:    de-compression function.
//
//  Parameters: IN     inbuf -> points to data to be uncompressed
//        IN     inlen -> length of data
//        IN     start -> flag indicating whether to start with a clean 
//               history buffer
//        OUT    output-> decompressed data
//        OUT    outlen-> lenght of decompressed data
//        IN     context -> connection decompress context
//
//  Returns:    TRUE  if decompress was successful
//              FALSE if it wasnt
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
int decompress(
        UCHAR FAR *inbuf,
        int inlen,
        int start,
        UCHAR FAR * FAR *output,
        int *outlen,
        RecvContext1 *context1,
        RecvContext2_Generic *context2,
        unsigned ComprType)
{
    UCHAR FAR *inend;                // When we know we're done decompressing
    UCHAR FAR *outstart;            // Remember where in dbuf we started
    UCHAR FAR *current;
    long  backptr = 0;            // Back pointer for copy items
    long  length;                // Where to copy from in dbuf
    UCHAR FAR *s1, FAR *s2;
    int   bitset;
    int   bit;
    int   byte;
    UCHAR FAR *pbyte;
    long HistorySize;  // 2^N - 1 for fast modulo arithmetic below.
    const long HistorySizes[2] = { HISTORY_SIZE_8K - 1, HISTORY_SIZE_64K - 1 };
    
    //
    // Important to validate the compression type otherwise we could overread
    // this HistroySizes array and then use a bogus size to validate further
    // down below
    //
    if (ComprType > PACKET_COMPR_TYPE_MAX) {
        return FALSE;
    }

    inend = inbuf + inlen;
    HistorySize = HistorySizes[ComprType];

    // Start out looking at the first bit, which tells us whether to restart
    // the history buffer.
    inbit_start(inbuf);
    if (!start)
        current = context1->CurrentPtr;
    else
        context1->CurrentPtr = current = context2->History;

    //
    // Save our starting position
    //
    outstart = current;

    //
    // Decompress until we run out of input
    //
    while (pbyte < inend) {

        //
        // Jump on what to do with these three bits.
        //
        in_bits_3(length);

        switch (length) {
            case 0:
                in_bits_5(length);
                goto LITERAL;

            case 1:
                in_bits_5(length);
                length += 32;
                goto LITERAL;

            case 2:
                in_bits_5(length);
                length += 64;
                goto LITERAL;

            case 3:
                in_bits_5(length);
                length += 96;
                goto LITERAL;

            case 4:
                in_bits_6(length);
                length += 128;
                goto LITERAL;

            case 5:
                in_bits_6(length);
                length += 192;
                goto LITERAL;

            case 6:
                if (ComprType == PACKET_COMPR_TYPE_64K) {
                    int foo;

                    // 16-bit offset
                    in_bits_8(foo);
                    in_bits_8(backptr);
                    backptr += (foo << 8) + 64 + 256 + 2048;
                }
                else {
                    in_bits_13 (backptr);  // 110 + 13 bit offset
                    backptr += 320;
                }
                break;

            case 7:
                in_bit();
                if (ComprType == PACKET_COMPR_TYPE_64K) {
                    if (!bitset) {
                        // 11-bit offset.
                        in_bits_11(backptr);
                        backptr += 64 + 256;
                    }
                    else {
                        in_bit();
                        if (!bitset) {
                            // 8-bit offset
                            in_bits_8(backptr);
                            backptr += 64;
                        }
                        else {
                            in_bits_6(backptr) ;
                        }
                    }
                }
                else {
                    if (!bitset) {
                        in_bits_8(backptr);
                        backptr+=64;
                    }
                    else {
                        in_bits_6(backptr);
                    }
                }
                break;
        }

        //
        // If we reach here, it's a copy item
        //

        in_bit() ;  // 1st length bit
        if (!bitset) {
            length = 3;
            goto DONE;
        }

        in_bit();  // 2nd length bit
        if (!bitset) {
            in_bits_2 (length);
            length += 4;
            goto DONE;
        }

        in_bit();  // 3rd length bit
        if (!bitset) {
            in_bits_3 (length);
            length += 8;
            goto DONE;
        }

        in_bit();  // 4th length bit
        if (!bitset) {
            in_bits_4 (length);
            length += 16;
            goto DONE;
        }

        in_bit();  // 5th length bit
        if (!bitset) {
            in_bits_5 (length);
            length += 32;
            goto DONE;
        }

        in_bit();  // 6th length bit
        if (!bitset) {
            in_bits_6 (length);
            length += 64;
            goto DONE;
        }

        in_bit();  // 7th length bit
        if (!bitset) {
            in_bits_7 (length);
            length += 128;
            goto DONE;
        }

        in_bit();  // 8th length bit
        if (!bitset) {
            in_bits_8 (length);
            length += 256;
            goto DONE;
        }

        in_bit();  // 9th length bit
        if (!bitset) {
            in_bits_9 (length);
            length += 512;
            goto DONE;
        }

        in_bit();  // 10th length bit
        if (!bitset) {
            in_bits_10 (length);
            length += 1024;
            goto DONE;
        }

        in_bit();  // 11th length bit
        if (!bitset) {
            in_bits_11 (length);
            length += 2048;
            goto DONE;
        }
        
        in_bit();  // 12th length bit
        if (!bitset) {
            in_bits_12 (length);
            length += 4096;
            goto DONE;
        }
        
        in_bit();  // 13th length bit
        if (!bitset) {
            in_bits_13(length);
            length += 8192;
            goto DONE;
        }
        
        in_bit();  // 14th length bit
        if (!bitset) {
            in_bits_14(length);
            length += 16384;
            goto DONE;
        }

        in_bit();  // 15th length bit
        if (!bitset) {
            in_bits_15(length);
            length += 32768;
            goto DONE;
        }


        return FALSE;

DONE:   
        // Turn the backptr into an index location
        s2 = context2->History + (((current - context2->History) - backptr) &
                HistorySize);
        s1 = current;
        current += length;

        // If we are past the end of the history this is a bad sign:
        // abort decompression. Note this pointer comparison likely will not
        // work in Win16 since FAR pointers are not comparable. HUGE pointers
        // are too expensive to use here.

        //
        //    We will also check the s2 pointer for overread. s2 will walk length 
        //    bytes and it could go outside the buffer.
        //    We DON'T check current, s2 for underflow for the simle reason 
        //    that the length can't be more then 64k and the context2 buffer
        //    can't be allocated in the last 64k of memory. 
        if ((current < (context2->History + context2->cbHistorySize)) &&
            ((s2+length) < context2->History + context2->cbHistorySize)) {
            // loop unrolled to handle length>backptr case
            *s1 = *s2;
            *(s1 + 1) = *(s2 + 1);
            s1 += 2;
            s2 += 2;
            length -= 2;

            // copy all the bytes
            while (length) {
                *s1++ = *s2++;
                length--;
            }

            // We have another copy item, and no literals
            continue;
        }
        else {
#if COMPR_DEBUG
            DbgComprPrint(("Decompression Error - invalid stream or overrun atack!\n"));

            DbgComprPrint(("context1 %p, context2 %p, current 0x%8.8x, outstart 0x%8.8x\n",
                     context1, context2, current, outstart));
            DbgComprPrint(("inbuf 0x%8.8x, inlength %d, start 0x%8.8x\n", 
                     inbuf, inlen, start));
            DbgComprPrint(("length 0x%x, s1 0x%x, s2 0x%x, bit 0x%x, byte 0x%x\n",
                           length, s1, s2, bit, byte));
#endif
            return FALSE;
        }


LITERAL:
        if (current < (context2->History + context2->cbHistorySize)) {
            // We have a literal
            *current++ = (UCHAR)length;
        }
        else {
            return FALSE;
        }
    } // while loop

    // End case:
    if ((bit == 16) && (pbyte == inend)) {

        if (current < (context2->History + context2->cbHistorySize)) {
            *current++ = *(pbyte - 1);
        }
        else {
            return FALSE;
        }
    }

#if COMPR_DEBUG
    //
    // This code will ONLY test 64K decompression contexts
    //
    if ((context2->cbHistorySize == (HISTORY_SIZE_64K-1)))
    {
        if ((DEBUG_FENCE_16K_VALUE !=
            ((RecvContext2_64K*)context2)->Debug16kFence))
        {
            DbgComprPrint(("Decompression (16K) Error (mail tsstress) - (overwrote fence)!\n"));
            DbgComprPrint(("context1 %p, context2 %p, current 0x%8.8x, outstart 0x%8.8x\n",
                     context1, context2, current, outstart));
            DbgComprPrint(("inbuf 0x%8.8x, inlength %d, start 0x%8.8x\n", 
                     inbuf, inlen, start));
            DbgComprPrint(("length 0x%x, s1 0x%x, s2 0x%x, bit 0x%x, byte 0x%x\n",
                           length, s1, s2, bit, byte));

            DbgComprBreakOnDbg();
        }
    }
    else if ((context2->cbHistorySize == (HISTORY_SIZE_8K-1)))
    {
        if ((DEBUG_FENCE_8K_VALUE !=
            ((RecvContext2_8K*)context2)->Debug8kFence))
        {
            DbgComprPrint(("Decompression (8K) Error (mail tsstress) - (overwrote fence)!\n"));
            DbgComprPrint(("context1 %p, context2 %p, current 0x%8.8x, outstart 0x%8.8x\n",
                     context1, context2, current, outstart));
            DbgComprPrint(("inbuf 0x%8.8x, inlength %d, start 0x%8.8x\n", 
                     inbuf, inlen, start));
            DbgComprPrint(("length 0x%x, s1 0x%x, s2 0x%x, bit 0x%x, byte 0x%x\n",
                           length, s1, s2, bit, byte));

            DbgComprBreakOnDbg();
        }
    }
#endif

    *outlen = (int)(current - outstart); // the length of decompressed data
    *output = context1->CurrentPtr;
    context1->CurrentPtr = current;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\adcgdefs.h ===
/**INC+**********************************************************************/
/* Header:  adcgdefs.h                                                      */
/*                                                                          */
/* Purpose: Optional defines used throughout the project                    */
/*                                                                          */
/* Copyright(C) Microsoft Corporation 1997                                  */
/*                                                                          */
/****************************************************************************/
/** Changes:
 * $Log:   Y:/logs/hydra/inc/tshare/adcgdefs.h_v  $
 *
 *    Rev 1.2   12 Sep 1997 10:45:20   NL
 * SFR1312: add kernel Security
 *
 *    Rev 1.1   02 Sep 1997 16:57:16   OBK
 * SFR1133: Put adcgdefs.h into NT tree
 *
 *    Rev 1.10   14 Aug 1997 13:53:40   KH
 * SFR1022: Split ANSI text enabling macro into 16 and 32 bit
 *
 *    Rev 1.9   11 Aug 1997 16:59:42   MR
 * SFR1133: Added USE_FULL_CA, USE_AWC
 *
 *    Rev 1.8   07 Aug 1997 14:33:48   MR
 * SFR1133: Persuade Wd to compile under C++
 *
 *    Rev 1.7   04 Aug 1997 18:59:38   JPB
 * SFR1171: Add build options to create exes that run with HiProf
 *
 *    Rev 1.6   24 Jul 1997 16:47:04   KH
 * SFR1033: Add DC_ANSI_TEXT_ORDERS
 *
 *    Rev 1.5   23 Jul 1997 19:03:40   JPB
 * SFR1032: Add Bitmap Caching support
 *
 *    Rev 1.4   23 Jul 1997 12:05:38   OBK
 * SFR1119: Add USE_HET and USE_DS
 *
 *    Rev 1.3   18 Jul 1997 11:26:42   AK
 * SFR1073: List legal #define flags for moans
 *
 *    Rev 1.2   17 Jul 1997 08:20:40   KH
 * SFR1022: Add SL_UNICODE_PROTOCOL
 *
 *    Rev 1.1   11 Jul 1997 12:46:34   MD
 * SFR1073: Add adcgdefs.h
**/
/**INC-**********************************************************************/
#ifndef _H_ADCGDEFS
#define _H_ADCGDEFS

/****************************************************************************/
/* This header contains a list of all the optional defines used throughout  */
/* the project.  To compile-in some optionally defined code, enable the     */
/* appropriate option here.  Note that:                                     */
/*                                                                          */
/*  - all defines must be declared and documented here.  This is enforced   */
/*    by moans.                                                             */
/*  - the list must be sorted alphabetically.  This makes it easy to spot   */
/*    duplicate defines.                                                    */
/****************************************************************************/

/****************************************************************************/
/* DC_ANSI_TEXT_ORDERS enables support for encoded text orders where the    */
/* characters are in ANSI format.                                           */
/****************************************************************************/
/*#undef DC_ANSI_TEXT_ORDERS*/
#define DC_ANSI_TEXT_ORDERS

/****************************************************************************/
/* DC_LATENCY enables the latency test code in UH and OP.  This code        */
/* generates a dummy key press (of the Ctrl key) whenever a large piece of  */
/* drawing is done.  This allows the client processing time for a single    */
/* key stroke to be accurately measured using a network sniffer (e.g.       */
/* NetMon).  In a typical situation Notepad is running in a remote session  */
/* (no other apps are running in the session) and the following occurs:     */
/*                                                                          */
/*  - Notepad has the focus on the client.                                  */
/*  - Press a key.                                                          */
/*  - Key-press is packaged by the client and sent on the wire.             */
/*  - Server interprets packet and injects the key-press.                   */
/*  - Notepad does some processing which results in a character being       */
/*    drawn on the screen.                                                  */
/*  - Server detects this drawing, packages it and sends it on the wire.    */
/*  - Client receives update packets and processes them.                    */
/*  - The drawing operation results in a dummy key-press being generated.   */
/*  - Dummy key-press is packaged by the client and sent on the wire.       */
/*                                                                          */
/* The time between the first update packet arriving and the dummy          */
/* key-press being sent is the total client processing time for a           */
/* key-press.                                                               */
/****************************************************************************/
#undef DC_LATENCY
/* #define DC_LATENCY */

/****************************************************************************/
/* DC_LOOPBACK enables the NL loopback testing code.  This stresses the     */
/* network layer by attempting to send a continual stream of packets with   */
/* incrementing size.  The equivalent code on the server detects loopback   */
/* packets and reflects them straight back to the client where they are     */
/* compared to ensure that they have not been corrupted by the round trip.  */
/****************************************************************************/
#undef DC_LOOPBACK
/* #define DC_LOOPBACK */

/****************************************************************************/
/* Code within DC_NLTEST is used solely for testing the network layer.  It  */
/* consists of:                                                             */
/*                                                                          */
/*  - a modification to TD_Recv so that it only ever tries to retrieve a    */
/*    single byte from WinSock regardless of the amount of data that the    */
/*    caller to TD_Recv asks for.  This stresses the common failure path    */
/*    within NL where processing of a packet has to be temporarily          */
/*    suspended until more data arrives.                                    */
/*  - random failure of NL_GetBuffer.  This stresses the whole of the       */
/*    client by simulating network layer back-pressure.                     */
/*                                                                          */
/****************************************************************************/
#undef DC_NLTEST
/* #define DC_NLTEST */

/****************************************************************************/
/* DC_SERVER_ORDERS_ONLY compiles the client using just the T.128 orders    */
/* that the server sends (i.e. removes unused T.128 orders).                */
/****************************************************************************/
/* #undef DC_SERVER_ORDERS_ONLY */
#define DC_SERVER_ORDERS_ONLY

/****************************************************************************/
/* Defining DC_PERF enables the timing code which enables the time spent    */
/* in several key functions to be easily determined.                        */
/****************************************************************************/
#undef DC_PERF
/* #define DC_PERF */

/****************************************************************************/
/* ENABLE_SECURITY compiles the Server with a preferred Security Package of */
/* "NTLM".  Undefining it compiles with "None".                             */
/****************************************************************************/
#undef ENABLE_SECURITY
/* #define ENABLE_SECURITY */

/****************************************************************************/
/* Defining SL_UNICODE_PROTOCOL enables code to send security package names */
/* in Unicode, rather than ANSI, format.                                    */
/****************************************************************************/
#undef SL_UNICODE_PROTOCOL
/* #define SL_UNICODE_PROTOCOL */

/****************************************************************************/
/* The following flags are defined elsewehere - for example in the build    */
/* scripts.  They are placed here to enable moans to detect legal defines - */
/* the moans use '/* FLAG:' to find these names.                            */
/*                                                                          */
/* FLAG: OS_WIN16                                                           */
/* - flag to indicate a Win16 build                                         */
/*                                                                          */
/* FLAG: OS_WIN32                                                           */
/* - flag to indicate a Win32 build                                         */
/*                                                                          */
/* FLAG: OS_WINDOWS                                                         */
/* - flag to indicate a Windows build                                       */
/*                                                                          */
/* FLAG: DC_DEBUG                                                           */
/* - flag to indicate a debug build                                         */
/*                                                                          */
/* FLAG: DC_DEFINE_GLOBAL_DATA                                              */
/* - used in aglobal.c to define global data                                */
/*                                                                          */
/* FLAG: UNICODE                                                            */
/* - Windows Unicode option                                                 */
/*                                                                          */
/* FLAG: HIPROF                                                             */
/* - HiProf profiler build                                                  */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* The following flags are used in the server code.                         */
/*                                                                          */
/* FLAG: ALLOW_SINGLE_APPS                                                  */
/* FLAG: CA_MULTIPLE_CLIENTS                                                */
/* FLAG: CH_NO_COUNT                                                        */
/* FLAG: COMP_STATS                                                         */
/* FLAG: COMPRESS_CACHED_BITMAPS                                            */
/* FLAG: DC_BIGEND                                                          */
/* FLAG: DC_FIXED_CODE_MODULE                                               */
/* FLAG: DC_INCLUDE_DATA                                                    */
/* FLAG: DC_INCL_PROTOTYPES                                                 */
/* FLAG: DC_INCL_TYPEDEFS                                                   */
/* FLAG: DC_INIT_DATA                                                       */
/* FLAG: DC_NO_UNALIGNED                                                    */
/* FLAG: DDINT3                                                             */
/* FLAG: DEBUG_EVICTION_LIST                                                */
/* FLAG: DIAGNOSE_BOUNDS                                                    */
/* FLAG: DITHER_MONO_CURSORS                                                */
/* FLAG: DLL_COREP                                                          */
/* FLAG: DLL_DISP                                                           */
/* FLAG: DLL_WD                                                             */
/* FLAG: GIN_ACCEPT_INVITES                                                 */
/* FLAG: HYDRA                                                              */
/* FLAG: NOT_SERVICE                                                        */
/* FLAG: ORDER_TRACE                                                        */
/* FLAG: QUERY_THROUGHPUT                                                   */
/* FLAG: RC_INVOKED                                                         */
/* FLAG: REMOVE_LINEAR                                                      */
/* FLAG: SBC_PERF                                                           */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: SNI_ASSERT                                                         */
/* FLAG: TRC_ENABLE_ALT                                                     */
/* FLAG: TRC_ENABLE_DBG                                                     */
/* FLAG: TRC_ENABLE_NRM                                                     */
/* FLAG: TRC_GROUP                                                          */
/* FLAG: TRC_TEST_LEVEL                                                     */
/* FLAG: USE_AWC                                                            */
/* FLAG: USE_DS                                                             */
/* FLAG: USE_EL                                                             */
/* FLAG: USE_FULL_CA                                                        */
/* FLAG: USE_HET                                                            */
/* FLAG: USE_SWL                                                            */
/* FLAG: V1_COMPRESSION                                                     */
/* FLAG: VER_APPSERV                                                        */
/* FLAG: VER_CPP                                                            */
/*                                                                          */
/* FLAG: __cplusplus                                                        */
/* FLAG: far                                                                */
/* FLAG: pTRCWd                                                             */
/*                                                                          */
/****************************************************************************/

#endif /* _H_ADCGDEFS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\compress\compr.cpp ===
//************************************************************************
// compress.c
//
// Code for MPPC compression. Decompression code is on the client,
//     \nt\private\tsext\client\core\compress.c.
//
// Copyright(c) Microsoft Corp., 1990-1999
//
//  Revision history:
//    5/5/94          Created            gurdeep
//    4/21/1999       Optimize for TS    jparsons, erikma
//************************************************************************

#include "adcg.h"
#pragma hdrstop

#define DLL_WD
#include <compress.h>


/*
    The key for the multiplicative hash function consists of 3 unsigned
    characters. They are composed (logically) by concatenating them i.e.
    the composed key = 2^16*c2 + 2^8*c2 + c3 and fits in 24 bits. The
    composed key is not actually computed here as we use the components
    to directly compute the hash function.

    The multiplicative hash function consists of taking the higher order
    N bits (corresponding to the log2 of the hash table size) above the 
    low-order 12 bits of the product key * Multiplier where:
        Multiplier = floor(A * pow(2.0, (double) w));
        double A = 0.6125423371;  (chosen according to Knuth vol 3 p. 512)
        w = 24 (the key's width in bits)
    The algorithm for this is in Cormen/Leiserson/Rivest.

    To do the multplication efficiently, the product c * Multiplier is
    precomputed and stored in lookup_array1 (for all 256 possible c's).
*/

#define MULTHASH1(c1,c2,c3) \
        ((lookup_array1[c1] + \
          (lookup_array1[c2] << 8) + \
          (lookup_array1[c3] << 16)) & 0x07fff000) >> 12

const unsigned long lookup_array1[256] = {
    0,          10276755,   20553510,   30830265,
    41107020,   51383775,   61660530,   71937285,
    82214040,   92490795,   102767550,  113044305,
    123321060,  133597815,  143874570,  154151325,
    164428080,  174704835,  184981590,  195258345,
    205535100,  215811855,  226088610,  236365365,
    246642120,  256918875,  267195630,  277472385,
    287749140,  298025895,  308302650,  318579405,
    328856160,  339132915,  349409670,  359686425,
    369963180,  380239935,  390516690,  400793445,
    411070200,  421346955,  431623710,  441900465,
    452177220,  462453975,  472730730,  483007485,
    493284240,  503560995,  513837750,  524114505,
    534391260,  544668015,  554944770,  565221525,
    575498280,  585775035,  596051790,  606328545,
    616605300,  626882055,  637158810,  647435565,
    657712320,  667989075,  678265830,  688542585,
    698819340,  709096095,  719372850,  729649605,
    739926360,  750203115,  760479870,  770756625,
    781033380,  791310135,  801586890,  811863645,
    822140400,  832417155,  842693910,  852970665,
    863247420,  873524175,  883800930,  894077685,
    904354440,  914631195,  924907950,  935184705,
    945461460,  955738215,  966014970,  976291725,
    986568480,  996845235,  1007121990, 1017398745,
    1027675500, 1037952255, 1048229010, 1058505765,
    1068782520, 1079059275, 1089336030, 1099612785,
    1109889540, 1120166295, 1130443050, 1140719805,
    1150996560, 1161273315, 1171550070, 1181826825,
    1192103580, 1202380335, 1212657090, 1222933845,
    1233210600, 1243487355, 1253764110, 1264040865,
    1274317620, 1284594375, 1294871130, 1305147885,
    1315424640, 1325701395, 1335978150, 1346254905,
    1356531660, 1366808415, 1377085170, 1387361925,
    1397638680, 1407915435, 1418192190, 1428468945,
    1438745700, 1449022455, 1459299210, 1469575965,
    1479852720, 1490129475, 1500406230, 1510682985,
    1520959740, 1531236495, 1541513250, 1551790005,
    1562066760, 1572343515, 1582620270, 1592897025,
    1603173780, 1613450535, 1623727290, 1634004045,
    1644280800, 1654557555, 1664834310, 1675111065,
    1685387820, 1695664575, 1705941330, 1716218085,
    1726494840, 1736771595, 1747048350, 1757325105,
    1767601860, 1777878615, 1788155370, 1798432125,
    1808708880, 1818985635, 1829262390, 1839539145,
    1849815900, 1860092655, 1870369410, 1880646165,
    1890922920, 1901199675, 1911476430, 1921753185,
    1932029940, 1942306695, 1952583450, 1962860205,
    1973136960, 1983413715, 1993690470, 2003967225,
    2014243980, 2024520735, 2034797490, 2045074245,
    2055351000, 2065627755, 2075904510, 2086181265,
    2096458020, 2106734775, 2117011530, 2127288285,
    2137565040, 2147841795, 2158118550, 2168395305,
    2178672060, 2188948815, 2199225570, 2209502325,
    2219779080, 2230055835, 2240332590, 2250609345,
    2260886100, 2271162855, 2281439610, 2291716365,
    2301993120, 2312269875, 2322546630, 2332823385,
    2343100140, 2353376895, 2363653650, 2373930405,
    2384207160, 2394483915, 2404760670, 2415037425,
    2425314180, 2435590935, 2445867690, 2456144445,
    2466421200, 2476697955, 2486974710, 2497251465,
    2507528220, 2517804975, 2528081730, 2538358485,
    2548635240, 2558911995, 2569188750, 2579465505,
    2589742260, 2600019015, 2610295770, 2620572525
};


// Bitstream output functions
//
// We keep a sequence of 16 bits in the variable "byte". The current bit
// pointer is kept in the "bit" variable, numbered from 1..16. We add bits
// from 16 towards 1; whenever we cross the boundary from bit 9 to bit 8
// we output the top 8 bits to the output stream (at *pbyte), shift the low
// 8 bits to the high location, and reset the "bit" variable to match the
// new insert location.
//
// 

/* Bitptrs point to the current byte. The current bit (i.e. next bit to be
 * stored) is masked off by the bit entry. When this reaches zero, it is
 * reset to 0x80 and the next byte is set up. The bytes are filled MSBit
 * first. */

/* Starts and sets the first byte to zero for the bitptr. */
#define bitptr_init(s)  pbyte = s; byte=0; bit = 16;

/* Sets up the byte part of the bitptr so that it is pointing to the byte after
 * the byte which had the last bit  put into it. */
#define bitptr_end() if (bit != 16) *pbyte++ = (UCHAR)(byte >> 8);

/* Goes to the next bit, and byte if necessary. */
#define bitptr_next()                  \
    if (bit < 10) {                    \
        *pbyte++ = (UCHAR)(byte >> 8); \
        byte <<= 8;                    \
        bit = 16;                      \
    } else                             \
        bit-- ;

/*  Advances to the next bit, and byte if necessary, readjusting the bit. */
#define bitptr_advance()               \
    if (bit < 9) {                     \
        *pbyte++ = (UCHAR)(byte >> 8); \
        bit+=8;                        \
        byte <<= 8;                    \
    }


/* BIT I/O FUNCTIONS *********************************************************/

/* These routines output most-significant-bit-first and the input will return
 * them MSB first, too. */

/* Outputs a one bit in the bit stream. */
#define out_bit_1() bit--; byte |= (1 << bit); bitptr_advance();
#define out_bit_0() bitptr_next();

#define out_bits_2(w) bit-=2; byte|=((w) << bit); bitptr_advance();
#define out_bits_3(w) bit-=3; byte|=((w) << bit); bitptr_advance();
#define out_bits_4(w) bit-=4; byte|=((w) << bit); bitptr_advance();
#define out_bits_5(w) bit-=5; byte|=((w) << bit); bitptr_advance();
#define out_bits_6(w) bit-=6; byte|=((w) << bit); bitptr_advance();
#define out_bits_7(w) bit-=7; byte|=((w) << bit); bitptr_advance();

#define out_bits_8(w) byte|=((w) << (bit-8)); *pbyte++=(UCHAR)(byte >> 8); byte <<= 8;


#define out_bits_9(w)                  \
    if (bit > 9) {                     \
        byte |= ((w) << (bit - 9));      \
        *pbyte++ = (UCHAR)(byte >> 8); \
        bit--;                         \
        byte <<= 8;                    \
    } else {                           \
        bit=16; byte |= (w);             \
        *pbyte++ = (UCHAR)(byte >> 8); \
        *pbyte++=(UCHAR)(byte); byte=0; \
    }


#define out_bits_10(w)             \
    if (bit > 10) {               \
        bit-=10; byte |= ((w) << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
    } else {                      \
        out_bits_2(((w) >> 8));       \
        out_bits_8(((w) & 0xFF));     \
    }

//
// Weird effect - if out_bits_9 used instead of out_bits_8,
// it's faster!  if (bit == 11) is faster than if (bit != 11).
//

#define out_bits_11(w)             \
    if (bit > 11) {               \
        bit-=11; byte |= ((w) << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
    } else {                      \
        if (bit == 11) {           \
            bit=16; byte |= (w);       \
            *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); byte=0; \
        } else {                   \
            bit=11-bit;              \
            byte|=((w) >> bit);        \
            *pbyte++=(UCHAR)(byte >> 8); *pbyte++=(UCHAR)(byte); \
            bit = 16-bit;              \
            byte=((w) << bit);         \
        }                          \
    }


#define out_bits_12(w)             \
    if (bit > 12) {               \
        bit-=12; byte |= ((w) << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
    } else {                      \
        out_bits_4(((w) >> 8));      \
        out_bits_8(((w) & 0xFF));    \
    }
    
#define out_bits_13(w)             \
    if (bit > 13) {               \
        bit-=13; byte |= ((w) << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
    } else {                      \
        out_bits_5(((w) >> 8));      \
        out_bits_8(((w) & 0xFF));    \
    }

#define out_bits_14(w)               \
    if (bit > 14) {               \
        bit-=14; byte |= ((w) << bit); *pbyte++ = (UCHAR)(byte >> 8); bit+=8; byte <<=8; \
    } else {                      \
        out_bits_6(((w) >> 8));       \
        out_bits_8(((w) & 0xFF));    \
    }

// For N in range 1..15
#define out_bits_N(N, w)               \
    if (bit > (N)) {                   \
        bit -= (N);                    \
        byte |= ((w) << bit);          \
        if (bit < 9) {                 \
            *pbyte++ = (UCHAR)(byte >> 8); \
            bit += 8;                  \
            byte <<= 8;                \
        }                              \
    }                                  \
    else if (bit < (N)) {              \
        bit = (N) - bit;               \
        byte |= ((w) >> bit);          \
        *pbyte++ = (UCHAR)(byte >> 8); \
        *pbyte++ = (UCHAR)(byte);      \
        bit = 16 - bit;                \
        byte = ((w) << bit);           \
    }                                  \
    else {                             \
        bit = 16; byte |= (w);         \
        *pbyte++ = (UCHAR)(byte >> 8); \
        if ((N) > 8) {                 \
            *pbyte++ = (UCHAR)(byte);  \
            byte <<= 8;                \
        }                              \
        byte = 0;                      \
    }


// compress()
//
//  Function:    Main compression function.
//
//  Parameters:
//        IN    CurrentBuffer -> points to data to compress
//        OUT   CompOutBuffer -> points to buffer into which to compress data
//        IN    CurrentLength -> points to Length of data to compress
//        IN    context -> connection compress context
//
//  Returns:    Nothing
//
//  WARNING:    CODE IS HIGHLY OPTIMIZED FOR TIME.
//
UCHAR compress(
        UCHAR *CurrentBuffer,
        UCHAR *CompOutBuffer,
        ULONG *CurrentLength,
        SendContext *context)
{
    int    bit;
    int    byte;
    int    backptr;
    int    cbMatch;
    int    hashvalue;
    UCHAR  *matchptr;
    UCHAR  *pbyte;
    UCHAR  *historyptr;
    UCHAR  *currentptr;
    UCHAR  *endptr;
    UCHAR  hashchar1;
    UCHAR  hashchar2;
    UCHAR  hashchar3;
    int    literal;
    UCHAR  status;  // return flags
    unsigned ComprType;
    ULONG  HistorySize;
    UCHAR  *pEndOutBuf;

    // Will this packet fit at the end of the history buffer?
    // Note that for compatibility with Win16 client, we deliberately do not
    // use a few bytes at the end of the buffer. The Win16 client requires
    // using GlobalAlloc() to allocate more than 65535 bytes; rather than
    // endure the pain, we use 64K minus a bit, then use LocalAlloc to create
    // the block.
    if ((context->CurrentIndex + *CurrentLength) < (context->HistorySize - 3) &&
            (context->CurrentIndex != 0)) {
        status = 0;
    }
    else {
        context->CurrentIndex = 0;     // Index into the history
        status = PACKET_AT_FRONT;
    }

    // Start out the bit pointing output
    bitptr_init(CompOutBuffer);
    historyptr = context->History + context->CurrentIndex;
    currentptr = CurrentBuffer;
    endptr = currentptr + *CurrentLength - 1;
    pEndOutBuf = CompOutBuffer + *CurrentLength - 1;

    ComprType = context->ClientComprType;
    HistorySize = context->HistorySize;

    while (currentptr < (endptr - 2)) {
        *historyptr++ = hashchar1 = *currentptr++;
        hashchar2 = *currentptr;
        hashchar3 = *(currentptr + 1);
        hashvalue = MULTHASH1(hashchar1, hashchar2, hashchar3);

        matchptr = context->History  + context->HashTable[hashvalue];

        if (matchptr != (historyptr - 1))
            context->HashTable[hashvalue] = (USHORT)
                    (historyptr - context->History);

        if (context->ValidHistory < historyptr)
            context->ValidHistory = historyptr;

        if (matchptr != context->History &&
                *(matchptr - 1) == hashchar1 && *matchptr == hashchar2 &&
                *(matchptr + 1) == hashchar3 && matchptr != (historyptr - 1) &&
                matchptr != historyptr  &&
                (matchptr + 1) <= context->ValidHistory) {
            backptr = (int)((historyptr - matchptr) & (HistorySize - 1));

            *historyptr++ = hashchar2;  // copy the other 2 chars
            *historyptr++ = hashchar3;  // copy the other 2 chars
            currentptr += 2;
            cbMatch = 3;  // length of match
            matchptr += 2; // we have already matched 3

            while ((*matchptr == *currentptr) &&
                    (currentptr < endptr) &&
                    (matchptr <= context->ValidHistory)) {
                matchptr++ ;
                *historyptr++ = *currentptr++ ;
                cbMatch++ ;
            }

            // Make sure we're not going to overshoot the end of the output
            // buffer. At most we require 3 bytes for the backptr and
            // 4 bytes for the length.
            if ((pbyte + 7) <= pEndOutBuf) {
                // First output the backpointer
                if (ComprType == PACKET_COMPR_TYPE_64K) {
                    // 64K needs special processing here because the leading bit
                    // codes are different to correspond with the measured backptr
                    // distributions and to add an 11-bit optimization that cuts
                    // another couple of percentage points off the total
                    // compression.
                    if (backptr >= (64 + 256 + 2048)) {  // Most common (2.1E6)
                        backptr -= 64 + 256 + 2048;
                        out_bits_7((0x60000 + backptr) >> 12);  // 110 + 16 bits
                        out_bits_12(backptr);
                    }
                    else if (backptr >= (64 + 256)) {  // Less common (9.8E5)
                        backptr -= 64 + 256;
                        out_bits_7((0x7000 + backptr) >> 8);  // 1110 + 11 bits
                        out_bits_8(backptr);
                    }
                    else if (backptr >= 64) {  // Even less common (6.5E5)
                        backptr += (0x1E00 - 64);  // 11110 + 8 bits
                        out_bits_13(backptr);
                    } else {  // Least common (5.8E5)
                        backptr += 0x7c0;  // 11111 + 6 bits
                        out_bits_11(backptr);
                    }
                }
                else {
                    // Original handling for PACKET_COMPR_TYPE_8K.
                    if (backptr >= (64 + 256)) {
                        backptr -= 64 + 256;
                        out_bits_8((0xc000 + backptr) >> 8);  // 110 + 13 bits
                        out_bits_8(backptr);
                    }
                    else if (backptr >= 64) {
                        backptr += (0xE00 - 64);  // 1110 + 8 bits
                        out_bits_12(backptr);
                    }
                    else {
                        // 1111 + 6 bits
                        backptr += 0x3c0;
                        out_bits_10(backptr);
                    }
                }

                // Output the length of the match encoding.
                if (cbMatch == 3) {  // Most common by far.
                    out_bit_0();
                }
                else if (cbMatch < 8) {
                    out_bits_4(0x08 + cbMatch - 4);
                }
                else if (cbMatch < 16) {
                    out_bits_6(0x30 + cbMatch - 8);
                }
                else if (cbMatch < 32) {
                    out_bits_8(0xE0 + cbMatch - 16);
                }
                else if (cbMatch < 64) {
                    out_bits_4(0x0F);
                    out_bits_6(cbMatch - 32);
                }
                else if (cbMatch < 128) {
                    out_bits_5(0x1F);
                    out_bits_7(cbMatch - 64);
                }
                else if (cbMatch < 256) {
                    out_bits_6(0x3F);
                    out_bits_8(cbMatch - 128);
                }
                else if (cbMatch < 512) {
                    out_bits_7(0x7F);
                    out_bits_9(cbMatch - 256);
                }
                else if (cbMatch < 1024) {
                    out_bits_8(0xFF);
                    out_bits_10(cbMatch - 512);
                }
                else if (cbMatch < 2048) {
                    out_bits_9(0x1FF);
                    out_bits_11(cbMatch - 1024);
                }
                else if (cbMatch < 4096) {
                    out_bits_10(0x3FF);
                    out_bits_12(cbMatch - 2048);
                }
                else if (cbMatch < 8192) {
                    out_bits_11(0x7FF) ;
                    out_bits_13(cbMatch - 4096);
                }
                else if (cbMatch < 16384) {
                    out_bits_12(0xFFF);
                    out_bits_14(cbMatch - 8192);
                }
                else if (cbMatch < 32768) {
                    out_bits_13(0x1FFF);
                    out_bits_14(cbMatch - 16384);
                }
                else {  // 32768..65535
                    out_bits_14(0x3FFF);
                    out_bits_N(15, cbMatch - 32768);
                }
            }
            else {
                // We might overshoot the buffer. Fail the encoding.
                goto Expansion;
            }
        }
        else {  // encode a literal
            // Max literal output is 2 bytes, make sure we don't overrun the
            // output.
            if ((pbyte + 2) <= pEndOutBuf) {
                literal = hashchar1;
                if (literal & 0x80) {
                    literal += 0x80;
                    out_bits_9(literal);
                } else {
                    out_bits_8(literal);
                }
            }
            else {
                // Potential overrun, failure.
                goto Expansion;
            }
        }
    }  // while

    // Output any remaining chars as literals.
    while (currentptr <= endptr) {
        // Max literal output is 2 bytes, make sure we don't overrun the
        // output.
        if ((pbyte + 2) <= pEndOutBuf) {
            literal=*currentptr;
            if (literal & 0x80) {
                literal += 0x80;
                out_bits_9(literal);
            } else {
                out_bits_8(literal);
            }

            *historyptr++ = *currentptr++ ;
        }
        else {
            // Potential overrun, failure.
            goto Expansion;
        }
    }

    // Done. Finish out the last byte and output the compressed length and
    // flags.
    bitptr_end();
    *CurrentLength = (ULONG)(pbyte - CompOutBuffer);
    status |= PACKET_COMPRESSED | (UCHAR)ComprType;
    context->CurrentIndex = (int)(historyptr - context->History);
    return status;

Expansion:
    memset(context->History, 0, sizeof(context->History)) ;
    memset(context->HashTable, 0, sizeof(context->HashTable)) ;
    context->CurrentIndex = HistorySize + 1 ; // this forces a start over next time
    return PACKET_FLUSHED;
}


// initsendcontext()
//
//  Function:    Initialize SendContext block
//
//  Parameters: IN  context -> connection compress context
//
//  Returns:    Nothing
void initsendcontext(SendContext *context, unsigned ComprType)
{
    context->CurrentIndex = 0;     // Index into the history
    context->ValidHistory = 0 ;  // reset valid history
    context->ClientComprType = ComprType;
    if (ComprType >= PACKET_COMPR_TYPE_64K) {
        context->ClientComprType = PACKET_COMPR_TYPE_64K;
        context->HistorySize = HISTORY_SIZE_64K;
    }
    else {
        context->ClientComprType = PACKET_COMPR_TYPE_8K;
        context->HistorySize = HISTORY_SIZE_8K;
    }
    memset(context->HashTable, 0, sizeof(context->HashTable));
    memset(context->History, 0, sizeof(context->History));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\extypes.h ===
/*****************************************************************************\
*                                                                             *
* wtypes.h -    Extra Windows types, and definitions                          *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) 1985-1992, Microsoft Corp. All rights reserved. *
*                                                                             *
*******************************************************************************/

#ifndef __extypes_h__
#define __exwtypes_h__

#ifdef __cplusplus
extern "C" {                // Assume C declarations for C++
#endif


/****** Common pointer types ************************************************/

typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;


#ifdef __cplusplus
}
#endif


#endif // __extypes_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\common\inc\gcc.h ===
/*
 *	gcc.h
 *
 *	Abstract:
 *		This is the interface file for the GCC DLL.  This file defines all
 *		macros, types, and functions needed to use the GCC DLL, allowing GCC
 *		services to be accessed from user applications. 
 *
 *		An application requests services from GCC by making direct
 *		calls into the DLL (this includes T.124 requests and responses).  GCC
 *		sends information back to the application through a callback (this
 *		includes T.124 indications and confirms).  The callback for the node
 *		controller is specified in the call GCCInitialize, and the callback
 *		for a particular application service access point is specified in the 
 *		call GCCRegisterSAP.
 *
 *		During initialization, GCC allocates a timer in order to give itself
 *		a heartbeat. If zero is passed in here the owner application (the node 
 *		controller) must take the responsibility to call GCCHeartbeat.  Almost 
 *		all work is done by GCC during these clocks ticks. It is during these 
 *		clock ticks that GCC checks with MCS to see if there is any work to be 
 *		done.  It is also during these clock ticks that callbacks are made to 
 *		the user applications.  GCC will NEVER invoke a user callback during a 
 *		user request (allowing the user applications to not worry about 
 *		re-entrancy).  Since timer events are processed during the message 
 *		loop, the developer should be aware that long periods of time away 
 *		from the message loop will result in GCC "freezing" up.
 *
 *		Note that this is a "C" language interface in order to prevent any "C++"
 *		naming conflicts between different compiler manufacturers.  Therefore,
 *		if this file is included in a module that is being compiled with a "C++"
 *		compiler, it is necessary to use the following syntax:
 *
 *		extern "C"
 *		{
 *			#include "gcc.h"
 *		}
 *
 *		This disables C++ name mangling on the API entry points defined within
 *		this file.
 *
 *	Author:
 *		blp
 *
 *	Caveats:
 *		none
 */
#ifndef	_GCC_
#define	_GCC_


/*
 *	This section defines the valid return values from GCC function calls.  Do
 *	not confuse this return value with the Result and Reason values defined
 *	by T.124 (which are discussed later).  These values are returned directly
 *	from the call to the API entry point, letting you know whether or not the
 *	request for service was successfully invoked.  The Result and Reason
 *	codes are issued as part of an indication or confirm which occurs
 *	asynchronously to the call that causes it.
 *
 *	All GCC function calls return type GCCError.  Its valid values are as
 *	follows:
 *
 *	GCC_NO_ERROR
 *		This means that the request was successfully invoked.  It does NOT
 *		mean that the service has been successfully completed.  Remember that
 *		all GCC calls are non-blocking.  This means that each request call
 *		begins the process, and if necessary, a subsequent indication or
 *		confirm will result.  By convention, if ANY GCC call returns a value
 *		other than this, something went wrong.  Note that this value should
 *		also be returned to GCC during a callback if the application processes
 *		the callback successfully.
 *
 *	GCC_NOT_INITIALIZED
 *		The application has attempted to use GCC services before GCC has been
 *		initialized.  It is necessary for the node controller (or whatever
 *		application is serving as the node controller), to initialize GCC before
 *		it is called upon to perform any services.
 *
 *	GCC_ALREADY_INITIALIZED
 *		The application has attempted to initialize GCC when it is already
 *		initialized.
 *
 *	GCC_ALLOCATION_FAILURE
 *		This indicates a fatal resource error inside GCC.  It usually results
 *		in the automatic termination of the affected conference.
 *
 *	GCC_NO_SUCH_APPLICATION	
 *		This indicates that the Application SAP handle passed in was invalid.
 *
 *	GCC_INVALID_CONFERENCE
 *		This indicates that an illegal conference ID was passed in.
 *
 *	GCC_CONFERENCE_ALREADY_EXISTS
 *		The Conference specified in the request or response is already in
 *		existence.
 *
 *	GCC_NO_TRANSPORT_STACKS
 *		This indicates that MCS did not load any transport stacks during
 *		initialization.  This is not necessarily an error.  MCS can still
 *		be used in a local only manner.  Transport stacks can also be loaded
 *		after initialization using the call MCSLoadTransport.  
 *
 *	GCC_INVALID_ADDRESS_PREFIX
 *		The called address parameter in a request such as 
 *		GCCConferenceCreateRequest does not	contain a recognized prefix.  MCS 
 *		relies on the prefix to know which transport stack to invoke.
 *
 *	GCC_INVALID_TRANSPORT
 *		The dynamic load of a transport stack failed either because the DLL
 *		could not be found, or because it did not export at least one entry
 *		point that MCS requires.
 *
 *	GCC_FAILURE_CREATING_PACKET
 *		This is a FATAL error which means that for some reason the 
 *		communications packet generated due to a request could not be created.
 *		This typically flags a problem with the ASN.1 toolkit.
 *
 *	GCC_QUERY_REQUEST_OUTSTANDING
 *		This error indicates that all the domains that set aside for querying
 *		are used up by other outstanding query request.
 *
 *	GCC_INVALID_QUERY_TAG
 *		The query response tag specified in the query response is not valid.
 *
 *	GCC_FAILURE_CREATING_DOMAIN
 *		Many requests such as GCCConferenceCreateRequest require that an MCS
 *		domain be created.  If the request to MCS fails this will be returned.
 *
 *	GCC_CONFERENCE_NOT_ESTABLISHED
 *		If a request is made to a conference before it is established, this
 *		error value will be returned.
 *
 *	GCC_INVALID_PASSWORD
 *		The password passed in the request is not valid.  This usually means
 *		that a numeric string needs to be specified.
 *		
 *	GCC_INVALID_MCS_USER_ID
 *		All MCS User IDs must have a value greater than 1000.
 *
 *	GCC_INVALID_JOIN_RESPONSE_TAG
 *		The join response tag specified in the join response is not valid.
 *		
 *	GCC_TRANSPORT_ALREADY_LOADED
 *		This occurs if the transport specified in the GCCLoadTransport call has
 *		already been loaded.
 *	
 *	GCC_TRANSPORT_BUSY
 *		The transport is too busy to process the specified request.
 *
 *	GCC_TRANSPORT_NOT_READY
 *		Request was made to a transport before it was ready to process it.
 *
 *	GCC_DOMAIN_PARAMETERS_UNACCEPTABLE
 *		The specified domain parameters do not fit within the range allowable
 *		by GCC and MCS.
 *
 *	GCC_APP_NOT_ENROLLED
 *		Occurs if a request is made by an Application Protocol Entity to a
 *		conference before the "APE" is enrolled.
 *
 *	GCC_NO_GIVE_RESPONSE_PENDING
 *		This will occur if a conductor Give Request is issued before a 
 *		previously pending conductor Give Response has been processed.
 *
 *	GCC_BAD_NETWORK_ADDRESS_TYPE
 *		An illegal network address type was passed in.  Valid types are	
 *		GCC_AGGREGATED_CHANNEL_ADDRESS, GCC_TRANSPORT_CONNECTION_ADDRESS and
 *		GCC_NONSTANDARD_NETWORK_ADDRESS.
 *
 *	GCC_BAD_OBJECT_KEY
 *		The object key passed in is invalid.
 *
 *	GCC_INVALID_CONFERENCE_NAME
 *		The conference name passed in is not a valid conference name.
 *
 *	GCC_INVALID_CONFERENCE_MODIFIER
 *		The conference modifier passed in is not a valid conference name.
 *
 *	GCC_BAD_SESSION_KEY
 *		The session key passed in was not valid.
 *				  
 *	GCC_BAD_CAPABILITY_ID
 *		The capability ID passed into the request is not valid.
 *
 *	GCC_BAD_REGISTRY_KEY
 *		The registry key passed into the request is not valid.
 *
 *	GCC_BAD_NUMBER_OF_APES
 *		Zero was passed in for the number of APEs in the invoke request. Zero
 *		is illegal here.
 *
 *	GCC_BAD_NUMBER_OF_HANDLES
 *		A number < 1 or	> 1024 was passed into the allocate handle request.
 *		  
 *	GCC_ALREADY_REGISTERED
 *		The user application attempting to register itself has already 
 *		registered.
 *			  
 *	GCC_APPLICATION_NOT_REGISTERED	  
 *		The user application attempting to make a request to GCC has not 
 *		registered itself with GCC.
 *
 *	GCC_BAD_CONNECTION_HANDLE_POINTER
 *		A NULL connection handle pointer was passed in.
 * 
 *	GCC_INVALID_NODE_TYPE
 *		A node type value other than GCC_TERMINAL, GCC_MULTIPORT_TERMINAL or
 *		GCC_MCU was passed in.
 *
 *	GCC_INVALID_ASYMMETRY_INDICATOR
 *		An asymetry type other than GCC_ASYMMETRY_CALLER, GCC_ASYMMETRY_CALLED
 *		or GCC_ASYMMETRY_UNKNOWN was passed into the request.
 *	
 *	GCC_INVALID_NODE_PROPERTIES
 *		A node property other than GCC_PERIPHERAL_DEVICE, GCC_MANAGEMENT_DEVICE,
 *		GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE or	
 *		GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT was passed into the request.
 *		
 *	GCC_BAD_USER_DATA
 *		The user data list passed into the request was not valid.
 *				  
 *	GCC_BAD_NETWORK_ADDRESS
 *		There was something wrong with the actual network address portion of
 *		the passed in network address.
 *
 *	GCC_INVALID_ADD_RESPONSE_TAG
 *		The add response tag passed in the response does not match any add
 *		response tag passed back in the add indication.
 *			  
 *	GCC_BAD_ADDING_NODE
 *		You can not request that the adding node be the node where the add
 *		request is being issued.
 *				  
 *	GCC_FAILURE_ATTACHING_TO_MCS
 *		Request failed because GCC could not create a user attachment to MCS.
 *	  
 *	GCC_INVALID_TRANSPORT_ADDRESS	  
 *		The transport address specified in the request (usually the called
 *		address) is not valid.  This will occur when the transport stack
 *		detects an illegal transport address.
 *
 *	GCC_INVALID_PARAMETER
 *		This indicates an illegal parameter is passed into the GCC function
 *		call.
 *
 *	GCC_COMMAND_NOT_SUPPORTED
 *		This indicates that the user application has attempted to invoke an
 *		GCC service that is not yet supported.
 *
 *	GCC_UNSUPPORTED_ERROR
 *		An error was returned from a request to MCS that is not recognized 
 *		by GCC.
 *
 *	GCC_TRANSMIT_BUFFER_FULL
 *		Request can not be processed because the transmit buffer is full.
 *		This usually indicates a problem with the shared memory portal in the
 *		Win32 client.
 *		
 *	GCC_INVALID_CHANNEL
 *		The channel ID passed into the request is not a valid MCS channel ID
 *		(zero is not valid).
 *
 *	GCC_INVALID_MODIFICATION_RIGHTS
 *		The modification rights passed in in not one of the enumerated types
 *		supported.
 *
 *	GCC_INVALID_REGISTRY_ITEM
 *		The registry item passed in is not one of the valid enumerated types.
 *
 *	GCC_INVALID_NODE_NAME
 *		The node name passed in is not valid.  Typically this means that it
 *		is to long.
 *
 *	GCC_INVALID_PARTICIPANT_NAME
 *		The participant name passed in is not valid.  Typically this means that 
 *		it is to long.
 *		
 *	GCC_INVALID_SITE_INFORMATION
 *		The site information passed in is not valid.  Typically this means that 
 *		it is to long.
 *
 *	GCC_INVALID_NON_COLLAPSED_CAP
 *		The non-collapsed capability passed in is not valid.  Typically this 
 *		means that it is to long.
 *
 *	GCC_INVALID_ALTERNATIVE_NODE_ID
 *		Alternative node IDs can only be two characters long.
 */
 
typedef	enum
{
	GCC_NO_ERROR				   		= 0,
	GCC_NOT_INITIALIZED			   		= 1,
	GCC_ALREADY_INITIALIZED		   		= 2,
	GCC_ALLOCATION_FAILURE		   		= 3,
	GCC_NO_SUCH_APPLICATION		   		= 4,
	GCC_INVALID_CONFERENCE		   		= 5,
	GCC_CONFERENCE_ALREADY_EXISTS  		= 6,	
	GCC_NO_TRANSPORT_STACKS		   		= 7,
	GCC_INVALID_ADDRESS_PREFIX	   		= 8,
	GCC_INVALID_TRANSPORT		   		= 9,
	GCC_FAILURE_CREATING_PACKET	   		= 10,
	GCC_QUERY_REQUEST_OUTSTANDING  		= 11,
	GCC_INVALID_QUERY_TAG			   	= 12,
	GCC_FAILURE_CREATING_DOMAIN	   		= 13,
	GCC_CONFERENCE_NOT_ESTABLISHED 		= 14,
	GCC_INVALID_PASSWORD		   		= 15,
	GCC_INVALID_MCS_USER_ID		   		= 16,
	GCC_INVALID_JOIN_RESPONSE_TAG  		= 17,
	GCC_TRANSPORT_ALREADY_LOADED   		= 18,
	GCC_TRANSPORT_BUSY					= 19,
	GCC_TRANSPORT_NOT_READY				= 20,
	GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	= 21,
	GCC_APP_NOT_ENROLLED				= 22,
	GCC_NO_GIVE_RESPONSE_PENDING		= 23,
	GCC_BAD_NETWORK_ADDRESS_TYPE		= 24,
	GCC_BAD_OBJECT_KEY					= 25,	    
	GCC_INVALID_CONFERENCE_NAME  		= 26,
	GCC_INVALID_CONFERENCE_MODIFIER 	= 27,
	GCC_BAD_SESSION_KEY					= 28,
	GCC_BAD_CAPABILITY_ID				= 29,
	GCC_BAD_REGISTRY_KEY				= 30,
	GCC_BAD_NUMBER_OF_APES				= 31,
	GCC_BAD_NUMBER_OF_HANDLES			= 32,
	GCC_ALREADY_REGISTERED				= 33,
	GCC_APPLICATION_NOT_REGISTERED		= 34,
	GCC_BAD_CONNECTION_HANDLE_POINTER	= 35,
	GCC_INVALID_NODE_TYPE				= 36,
	GCC_INVALID_ASYMMETRY_INDICATOR		= 37,
	GCC_INVALID_NODE_PROPERTIES			= 38,
	GCC_BAD_USER_DATA					= 39,
	GCC_BAD_NETWORK_ADDRESS				= 40,
	GCC_INVALID_ADD_RESPONSE_TAG		= 41,
	GCC_BAD_ADDING_NODE					= 42,
	GCC_FAILURE_ATTACHING_TO_MCS		= 43,
	GCC_INVALID_TRANSPORT_ADDRESS		= 44,
	GCC_INVALID_PARAMETER			   	= 45,
	GCC_COMMAND_NOT_SUPPORTED	   		= 46,
	GCC_UNSUPPORTED_ERROR		   		= 47,
	GCC_TRANSMIT_BUFFER_FULL			= 48,
	GCC_INVALID_CHANNEL					= 49,
	GCC_INVALID_MODIFICATION_RIGHTS		= 50,
	GCC_INVALID_REGISTRY_ITEM			= 51,
	GCC_INVALID_NODE_NAME				= 52,
	GCC_INVALID_PARTICIPANT_NAME		= 53,
	GCC_INVALID_SITE_INFORMATION		= 54,
	GCC_INVALID_NON_COLLAPSED_CAP		= 55,
	GCC_INVALID_ALTERNATIVE_NODE_ID		= 56,
	LAST_GCC_ERROR						= GCC_INVALID_ALTERNATIVE_NODE_ID
}GCCError;
typedef	GCCError FAR *		PGCCError;


/************************************************************************
*																		*
*					Generally Used Typedefs								*
*																		*
*************************************************************************/

/*
**	GCCReason
**		When GCC issues an indication to a user application, it often includes a
**		reason parameter informing the user of why the activity is occurring.
*/
typedef	enum
{
	GCC_REASON_USER_INITIATED					= 0,
	GCC_REASON_UNKNOWN							= 1,
	GCC_REASON_NORMAL_TERMINATION				= 2,
	GCC_REASON_TIMED_TERMINATION				= 3,
	GCC_REASON_NO_MORE_PARTICIPANTS				= 4,
	GCC_REASON_ERROR_TERMINATION				= 5,
	GCC_REASON_ERROR_LOW_RESOURCES				= 6,
	GCC_REASON_MCS_RESOURCE_FAILURE				= 7,
	GCC_REASON_PARENT_DISCONNECTED				= 8,
	GCC_REASON_CONDUCTOR_RELEASE				= 9,
	GCC_REASON_SYSTEM_RELEASE					= 10,
	GCC_REASON_NODE_EJECTED						= 11,
	GCC_REASON_HIGHER_NODE_DISCONNECTED 		= 12,
	GCC_REASON_HIGHER_NODE_EJECTED				= 13,
	GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE	= 14,
	LAST_GCC_REASON								= GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE
}GCCReason;

/*
**	GCCResult
**		When a user makes a request of GCC, GCC often responds with a result,
**		letting the user know whether or not the request succeeded.
*/
typedef	enum
{
	GCC_RESULT_SUCCESSFUL			   			= 0,
	GCC_RESULT_RESOURCES_UNAVAILABLE   			= 1,
	GCC_RESULT_INVALID_CONFERENCE	   			= 2,
	GCC_RESULT_INVALID_PASSWORD		   			= 3,
	GCC_RESULT_INVALID_CONVENER_PASSWORD		= 4,
	GCC_RESULT_SYMMETRY_BROKEN		   			= 5,
	GCC_RESULT_UNSPECIFIED_FAILURE	   			= 6,
	GCC_RESULT_NOT_CONVENER_NODE	   			= 7,
	GCC_RESULT_REGISTRY_FULL		   			= 8,
	GCC_RESULT_INDEX_ALREADY_OWNED 	   			= 9,
	GCC_RESULT_INCONSISTENT_TYPE 	   			= 10,
	GCC_RESULT_NO_HANDLES_AVAILABLE	   			= 11,
	GCC_RESULT_CONNECT_PROVIDER_FAILED 			= 12,
	GCC_RESULT_CONFERENCE_NOT_READY    			= 13,
	GCC_RESULT_USER_REJECTED		   			= 14,
	GCC_RESULT_ENTRY_DOES_NOT_EXIST    			= 15,
	GCC_RESULT_NOT_CONDUCTIBLE	   	   			= 16,
	GCC_RESULT_NOT_THE_CONDUCTOR	   			= 17,
	GCC_RESULT_NOT_IN_CONDUCTED_MODE   			= 18,
	GCC_RESULT_IN_CONDUCTED_MODE	   			= 19,
	GCC_RESULT_ALREADY_CONDUCTOR	   			= 20,
	GCC_RESULT_CHALLENGE_RESPONSE_REQUIRED		= 21,
	GCC_RESULT_INVALID_CHALLENGE_RESPONSE		= 22,
	GCC_RESULT_INVALID_REQUESTER				= 23,
	GCC_RESULT_ENTRY_ALREADY_EXISTS				= 24,	
	GCC_RESULT_INVALID_NODE						= 25,
	GCC_RESULT_INVALID_SESSION_KEY				= 26,
	GCC_RESULT_INVALID_CAPABILITY_ID			= 27,
	GCC_RESULT_INVALID_NUMBER_OF_HANDLES		= 28,	
	GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING		= 29,
	GCC_RESULT_INCOMPATIBLE_PROTOCOL			= 30,
	GCC_RESULT_CONFERENCE_ALREADY_LOCKED		= 31,
	GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED		= 32,
	GCC_RESULT_INVALID_NETWORK_TYPE				= 33,
	GCC_RESULT_INVALID_NETWORK_ADDRESS			= 34,
	GCC_RESULT_ADDED_NODE_BUSY					= 35,
	GCC_RESULT_NETWORK_BUSY						= 36,
	GCC_RESULT_NO_PORTS_AVAILABLE				= 37,
	GCC_RESULT_CONNECTION_UNSUCCESSFUL			= 38,
	GCC_RESULT_LOCKED_NOT_SUPPORTED    			= 39,
	GCC_RESULT_UNLOCK_NOT_SUPPORTED				= 40,
	GCC_RESULT_ADD_NOT_SUPPORTED				= 41,
	GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE	= 42,
	LAST_CGG_RESULT								= GCC_RESULT_DOMAIN_PARAMETERS_UNACCEPTABLE

}GCCResult;

/* 
** Macros for values of Booleans passed through the GCC API.
*/
#define		CONFERENCE_IS_LOCKED					TRUE
#define		CONFERENCE_IS_NOT_LOCKED				FALSE
#define		CONFERENCE_IS_LISTED					TRUE
#define		CONFERENCE_IS_NOT_LISTED				FALSE
#define		CONFERENCE_IS_CONDUCTIBLE				TRUE
#define		CONFERENCE_IS_NOT_CONDUCTIBLE			FALSE
#define		PERMISSION_IS_GRANTED					TRUE
#define		PERMISSION_IS_NOT_GRANTED				FALSE
#define		TIME_IS_CONFERENCE_WIDE					TRUE
#define		TIME_IS_NOT_CONFERENCE_WIDE				FALSE
#define		APPLICATION_IS_ENROLLED_ACTIVELY		TRUE
#define		APPLICATION_IS_NOT_ENROLLED_ACTIVELY	FALSE
#define		APPLICATION_IS_CONDUCTING				TRUE
#define		APPLICATION_IS_NOT_CONDUCTING_CAPABLE	FALSE
#define		APPLICATION_IS_ENROLLED					TRUE
#define		APPLICATION_IS_NOT_ENROLLED				FALSE
#define		DELIVERY_IS_ENABLED						TRUE
#define		DELIVERY_IS_NOT_ENABLED					FALSE

/*
**	Typedef for a GCC octet string.  This typedef is used throughout GCC for
**	storing	variable length single byte character strings with embedded NULLs.
*/
typedef struct
{
	unsigned short			octet_string_length;
	unsigned char FAR *		octet_string;
} GCCOctetString;

/*
**	Typedef for a GCC hex string.  This typedef is used throughout GCC for
**	storing	variable length wide character strings with embedded NULLs.
*/
typedef struct
{
	unsigned short			hex_string_length;
	unsigned short FAR *	hex_string;
} GCCHexString;

/*
**	Typedef for a GCC long string.  This typedef is used in GCC for
**	storing	variable length strings of longs with embedded NULLs.
*/
typedef struct
{
	unsigned short			long_string_length;
	unsigned long FAR *		long_string;
} GCCLongString;

/*
**	Typedef for a GCC Unicode string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, wide character strings.
*/
typedef	unsigned short						GCCUnicodeCharacter;
typedef	GCCUnicodeCharacter		FAR *		GCCUnicodeString;

/*
**	Typedef for a GCC Character string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
*/
typedef	unsigned char						GCCCharacter;
typedef	GCCCharacter			FAR *		GCCCharacterString;

/*
**	Typedef for a GCC Numeric string.  This typedef is used throughout GCC for
**	storing	variable length, NULL terminated, single byte character strings.
**	A single character in this string is constrained to numeric values 
**	ranging from "0" to "9".
*/
typedef	unsigned char						GCCNumericCharacter;
typedef	GCCNumericCharacter		FAR *		GCCNumericString;

/*
**	Typdef for GCC version which is used when registering the node controller
**	or an application.
*/
typedef	struct
{
	unsigned short	major_version;
	unsigned short	minor_version;
} GCCVersion;


/*
**	The following enum structure typedefs are used to define the GCC Object Key.
**	The GCC Object Key is used throughout GCC for things like the Application
**	keys and Capability IDs.
*/
typedef enum
{
	GCC_OBJECT_KEY					= 1,
	GCC_H221_NONSTANDARD_KEY		= 2
} GCCObjectKeyType; 

typedef struct 
{
    GCCObjectKeyType		key_type;
    union 
    {
        GCCLongString		object_id;
        GCCOctetString		h221_non_standard_id;
    } u;
} GCCObjectKey;

/*
**	GCCNonStandardParameter
**		This structure is used within the NetworkAddress typedef and
**		the NetworkService typedef defined below.
*/
typedef struct 
{
	GCCObjectKey		object_key;
	GCCOctetString		parameter_data;
} GCCNonStandardParameter;


/*
**	GCCConferenceName
**		This structure defines the conference name.  In a create request, the
**		conference name can include an optional unicode string but it must 
**		always include the simple numeric string.  In a join request, either
**		one can be specified.
*/
typedef struct
{
	GCCNumericString		numeric_string;
	GCCUnicodeString		text_string;			/* optional */
} GCCConferenceName;

/*
**	GCCConferenceID
**		Locally allocated identifier of a created conference.  All subsequent 
**		references to the conference are made using the ConferenceID as a unique 
**		identifier. The ConferenceID shall be identical to the MCS domain 
**		selector used locally to identify the MCS domain associated with the 
**		conference. 
*/
typedef	unsigned long						GCCConferenceID;

/*
**	GCCResponseTag
**		Generally used by GCC to match up certain responses to certain 
**		indications.
*/
typedef	unsigned long						GCCResponseTag;						


/*
**	MCSChannelType
**		Should this be defined in MCATMCS?  It is used in a couple of places
**		below and is explicitly defined in the T.124 specification.
*/
typedef enum
{
	MCS_STATIC_CHANNEL					= 0,
	MCS_DYNAMIC_MULTICAST_CHANNEL		= 1,
	MCS_DYNAMIC_PRIVATE_CHANNEL			= 2,
	MCS_DYNAMIC_USER_ID_CHANNEL			= 3,
	MCS_NO_CHANNEL_TYPE_SPECIFIED		= 4
} MCSChannelType;

/*
**	GCCUserData
**		This structure defines a user data element which is used throughout GCC.
*/
typedef struct
{
	GCCObjectKey			key;
	GCCOctetString FAR *	octet_string;	/* optional */
} GCCUserData;	


/************************************************************************
*																		*
*					Node Controller Related Typedefs					*
*																		*
*************************************************************************/

/*
**	GCCTerminationMethod
**		The termination method is used by GCC to determine
**		what action to take when all participants of a conference have
**		disconnected.  The conference can either be manually terminated
**		by the node controller or it can terminate itself automatically when 
**		all the participants have left the conference.
*/
typedef enum
{
	GCC_AUTOMATIC_TERMINATION_METHOD 		= 0, 
	GCC_MANUAL_TERMINATION_METHOD 	 		= 1
} GCCTerminationMethod;

/*
**	GCCNodeType
**		GCC specified node types.  These node types dictate node controller	  
**		behavior under certain conditions.  See T.124 specification for
**		proper assignment based on the needs of the Node Controller.
*/
typedef enum
{
	GCC_TERMINAL							= 0,
	GCC_MULTIPORT_TERMINAL					= 1,
	GCC_MCU									= 2
} GCCNodeType;

/*
**	GCCNodeProperties
**		GCC specified node properties.  See T.124 specification for proper
**		assignment by the Node Controller.
*/
typedef enum
{
	GCC_PERIPHERAL_DEVICE					= 0,
	GCC_MANAGEMENT_DEVICE					= 1,
	GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE	= 2,
	GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT	= 3
} GCCNodeProperties;

/*
**	GCCPassword
**		This is the unique password specified by the convenor of the
**		conference that is used by the node controller to insure conference
**		security. This is also a unicode string.
*/
typedef	struct
{
	GCCNumericString	numeric_string;
	GCCUnicodeString	text_string;	/* optional */
} GCCPassword;

/*
**	GCCChallengeResponseItem
**		This structure defines what a challenge response should look like.
**		Note that either a password string or response data should be passed
**		but not both.
*/
typedef struct
{
    GCCPassword		FAR *				password_string;
	unsigned short				   		number_of_response_data_members;
	GCCUserData		FAR *	FAR *		response_data_list;
} GCCChallengeResponseItem;

typedef	enum
{
	GCC_IN_THE_CLEAR_ALGORITHM	= 0,
	GCC_NON_STANDARD_ALGORITHM	= 1
} GCCPasswordAlgorithmType;

typedef struct 
{
    GCCPasswordAlgorithmType			password_algorithm_type;
	GCCNonStandardParameter	FAR *		non_standard_algorithm;	/* optional */
} GCCChallengeResponseAlgorithm;

typedef struct 
{
    GCCChallengeResponseAlgorithm		response_algorithm;
	unsigned short				   		number_of_challenge_data_members;
	GCCUserData		FAR *	FAR *		challenge_data_list;
} GCCChallengeItem;

typedef struct 
{
    GCCResponseTag						challenge_tag;
	unsigned short						number_of_challenge_items;
	GCCChallengeItem	FAR *	FAR *	challenge_item_list;
} GCCChallengeRequest;

typedef struct 
{
    GCCResponseTag						challenge_tag;
    GCCChallengeResponseAlgorithm		response_algorithm;
    GCCChallengeResponseItem			response_item;
} GCCChallengeResponse;


typedef	enum
{
	GCC_PASSWORD_IN_THE_CLEAR	= 0,
	GCC_PASSWORD_CHALLENGE 		= 1
} GCCPasswordChallengeType;

typedef struct 
{
	GCCPasswordChallengeType	password_challenge_type;
	
	union 
    {
        GCCPassword			password_in_the_clear;
        
        struct 
        {
            GCCChallengeRequest		FAR *	challenge_request;	/* optional */
            GCCChallengeResponse	FAR *	challenge_response;	/* optional */
        } challenge_request_response;
    } u;
} GCCChallengeRequestResponse;

/*
**	GCCAsymmetryType
**		Used in queries to determine if the calling and called node are known
**		by both Node Controllers involved with the connection.
*/
typedef enum
{
	GCC_ASYMMETRY_CALLER				= 1,
	GCC_ASYMMETRY_CALLED				= 2,
	GCC_ASYMMETRY_UNKNOWN				= 3
} GCCAsymmetryType;

/*
**	GCCAsymmetryIndicator
**		Defines how the Node Controller sees itself when making a Query
**		request or response.  The random number portion of this structure is
**		only used if the asymmetry_type is specified to be 
**		GCC_ASYMMETRY_UNKNOWN.
*/
typedef struct
{
	GCCAsymmetryType	asymmetry_type;
	unsigned long		random_number;		/* optional */
} GCCAsymmetryIndicator;

/*
**	GCCNetworkAddress
**		The following block of structures defines the Network Address as defined 
**		by T.124.  Most of these structures were taken almost verbatim from the
**		ASN.1 interface file.  Since I'm not really sure what most of this stuff
**		is for I really didn't know how to simplify it.
*/
typedef	struct 
{
    T120Boolean         speech;
    T120Boolean         voice_band;
    T120Boolean         digital_56k;
    T120Boolean         digital_64k;
    T120Boolean         digital_128k;
    T120Boolean         digital_192k;
    T120Boolean         digital_256k;
    T120Boolean         digital_320k;
    T120Boolean         digital_384k;
    T120Boolean         digital_512k;
    T120Boolean         digital_768k;
    T120Boolean         digital_1152k;
    T120Boolean         digital_1472k;
    T120Boolean         digital_1536k;
    T120Boolean         digital_1920k;
    T120Boolean         packet_mode;
    T120Boolean         frame_mode;
    T120Boolean         atm;
} GCCTransferModes;

#define		MAXIMUM_DIAL_STRING_LENGTH		17
typedef char	GCCDialingString[MAXIMUM_DIAL_STRING_LENGTH];

typedef struct 
{
    unsigned short  		length;
    unsigned short  FAR	*	value;
} GCCExtraDialingString;

typedef	struct 
{
    T120Boolean         telephony3kHz;
    T120Boolean         telephony7kHz;
    T120Boolean         videotelephony;
    T120Boolean         videoconference;
    T120Boolean         audiographic;
    T120Boolean         audiovisual;
    T120Boolean         multimedia;
} GCCHighLayerCompatibility; 

typedef	struct 
{
    GCCTransferModes				transfer_modes;
    GCCDialingString   				international_number;
    GCCCharacterString				sub_address_string;  		/* optional */
    GCCExtraDialingString	FAR	*	extra_dialing_string;  		/* optional */
  	GCCHighLayerCompatibility FAR *	high_layer_compatibility;	/* optional */
} GCCAggregatedChannelAddress;

#define		MAXIMUM_NSAP_ADDRESS_SIZE		20
typedef struct 
{
    struct 
    {
        unsigned short  length;
        unsigned char   value[MAXIMUM_NSAP_ADDRESS_SIZE];
    } nsap_address;
   
   	GCCOctetString		FAR	*	transport_selector;				/* optional */
} GCCTransportConnectionAddress;

typedef enum
{
	GCC_AGGREGATED_CHANNEL_ADDRESS		= 1,
	GCC_TRANSPORT_CONNECTION_ADDRESS	= 2,
	GCC_NONSTANDARD_NETWORK_ADDRESS		= 3
} GCCNetworkAddressType;

typedef struct
{
    GCCNetworkAddressType  network_address_type;
    
    union 
    {
		GCCAggregatedChannelAddress		aggregated_channel_address;
		GCCTransportConnectionAddress	transport_connection_address;
        GCCNonStandardParameter			non_standard_network_address;
    } u;
} GCCNetworkAddress;

/*
**	GCCNodeRecord
**		This structure defines a single conference roster record.  See the
**		T.124 specification for parameter definitions.
*/
typedef struct
{
	UserID							node_id;
	UserID							superior_node_id;
	GCCNodeType						node_type;
	GCCNodeProperties				node_properties;
	GCCUnicodeString				node_name; 					/* optional */
	unsigned short					number_of_participants;
	GCCUnicodeString 		FAR *	participant_name_list; 		/* optional */	
	GCCUnicodeString				site_information; 			/* optional */
	unsigned short					number_of_network_addresses;
	GCCNetworkAddress FAR * FAR *	network_address_list;		/* optional */
	GCCOctetString			FAR *	alternative_node_id;		/* optional */
	unsigned short					number_of_user_data_members;
	GCCUserData		FAR *	FAR *	user_data_list;				/* optional */
} GCCNodeRecord;

/*
**	GCCConferenceRoster
**		This structure hold a complete conference roster.  See the
**		T.124 specification for parameter definitions.
*/

typedef struct
{  
	unsigned short						instance_number;
	T120Boolean 						nodes_were_added;
	T120Boolean 						nodes_were_removed;
	unsigned short						number_of_records;
	GCCNodeRecord		 FAR *	FAR *	node_record_list;
} GCCConferenceRoster;

/*
**	GCCConferenceDescriptor
**		Definition for the conference descriptor returned in a 
**		conference query confirm.  This holds information about the
**		conferences that exists at the queried node.
*/
typedef struct
{
	GCCConferenceName				conference_name;
	GCCNumericString				conference_name_modifier;	/* optional */
	GCCUnicodeString				conference_descriptor;		/* optional */
	T120Boolean						conference_is_locked;
	T120Boolean						password_in_the_clear_required;
	unsigned short					number_of_network_addresses;
	GCCNetworkAddress FAR * FAR *	network_address_list;		/* optional */
} GCCConferenceDescriptor;

/*
**	ConferencePrivileges
**		This structure defines the list of privileges that can be assigned to
**		a particular conference. 
*/
typedef struct
{
	T120Boolean		terminate_is_allowed;
	T120Boolean		eject_user_is_allowed;
	T120Boolean		add_is_allowed;
	T120Boolean		lock_unlock_is_allowed;
	T120Boolean		transfer_is_allowed;
} GCCConferencePrivileges;


/************************************************************************
*																		*
*					User Application Related Typedefs					*
*																		*
*************************************************************************/

/*
**	SapHandle 
**		When the node controller or a user application registers it's service 
**		access point with GCC, it is assigned a SapHandle that can be used to 
**		perform GCC services. GCC uses the SapHandles to keep track of 
**		applications enrolled with the conference and also uses these to keep 
**		track of the callbacks it makes to route the indications and confirms 
**		to the appropriate application or node controller.
*/
typedef	unsigned short					GCCSapHandle;

/*
**	GCCSessionKey
**		This is a unique identifier for an application that is
**		using GCC.  See the T.124 for the specifics on what an application
**		key should look like.  A sess