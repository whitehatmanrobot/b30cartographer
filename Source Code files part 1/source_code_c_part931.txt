 Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:24:47

 ---------------------------------------------------------------------------
*/



// ===========================================================================
/*    Function    :  GetPrivilege
   Description    :  This function enables the requested privilege on the requested
                     computer.
*/
// ===========================================================================
BOOL                                       // ret-TRUE if successful.
   GetPrivilege(
      WCHAR          const * sMachineW,    // in -NULL or machine name
      LPCWSTR                pPrivilege    // in -privilege name such as SE_SHUTDOWN_NAME
   );

// ===========================================================================
/*    Function    :  ComputerShutDown
   Description    :  This function shutsdown/restarts the given computer.

*/
// ===========================================================================

DWORD 
   ComputerShutDown(
      WCHAR          const * pComputerName,  // in - computer name to shut down
      WCHAR          const * pMessage,       // in - message to display in NT shutdown dialog
      DWORD                  delay,          // in - delay, in seconds
      DWORD                  bRestart,       // in - flag, whether to reboot
      BOOL                   bNoChange       // in - flag, whether to really do it
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rename.cpp ===
/*---------------------------------------------------------------------------
  File: RenameComputer.cpp

  Comments: Implementation of COM object to change the name of a computer.
  This must be run locally on the computer to be renamed.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:22:41

 ---------------------------------------------------------------------------
*/

// RenameComputer.cpp : Implementation of CRenameComputer
#include "stdafx.h"
#include "WorkObj.h"
#include "Rename.h"
#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include <lm.h>
#include "TReg.hpp"

/////////////////////////////////////////////////////////////////////////////
// CRenameComputer

STDMETHODIMP CRenameComputer::RenameLocalComputer(BSTR NewName)
{
	HRESULT                   hr = S_OK;
   WCHAR                   * newNameW = (WCHAR*)NewName;
   WCHAR                     nameW[LEN_Computer];
   DWORD                     rc = 0;

   if ( newNameW[0] == L'\\' )
   {
      safecopy(nameW,newNameW+2);
   }
   else
   {
      safecopy(nameW,newNameW);
   }
   // convert the name to uppercase
   for ( int i = 0 ; nameW[i] ; i++ )
   {
      nameW[i] = towupper(nameW[i]);
   }

   if ( ! m_bNoChange )
   {
      if ( ! SetComputerName(nameW) )
      {
         DWORD rc = GetLastError();
         hr = HRESULT_FROM_WIN32(rc);
      }
      else
      {
         // Set the host name or the NVHostname value as required
         LPWKSTA_INFO_100  pBuf = NULL;
         rc = NetWkstaGetInfo(NULL, 100, (LPBYTE*)&pBuf);
         if( !rc ) 
         {
            TRegKey                   network(L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters");

            if ( pBuf->wki100_ver_major < 5 )
               rc = network.ValueSetStr(L"Hostname", nameW);
            else
               rc = network.ValueSetStr(L"NVHostname", nameW);

            if ( rc ) 
               hr = HRESULT_FROM_WIN32(GetLastError());
            NetApiBufferFree(pBuf);
         }
         else
            hr = HRESULT_FROM_WIN32(GetLastError());
      }
   }
	return hr;
}

STDMETHODIMP CRenameComputer::get_NoChange(BOOL *pVal)
{
   (*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP CRenameComputer::put_NoChange(BOOL newVal)
{
	m_bNoChange = newVal;
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\recnode.hpp ===
/*---------------------------------------------------------------------------
  File: RecNode.hpp

  Comments: Definition of Membership node object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 02/15/99 11:18:21

 ---------------------------------------------------------------------------
*/

	
// AcctRepl.h : Declaration of the CAcctRepl

#ifndef __RECNODE_HPP_
#define __RECNODE_HPP_

#include "WorkObj.h"
#include "TARNode.hpp"

class TRecordNode:public TNode
{
   _bstr_t             sMember;
   _bstr_t             sMemberSam;
   _bstr_t             sDN;
   TAcctReplNode     * pNode;
   BOOL                bMemberMoved;

public:
   TRecordNode() { pNode = NULL; bMemberMoved = FALSE; }
   const WCHAR * GetMember() const { return (WCHAR const *)sMember; }
   const WCHAR * GetMemberSam() const { return (WCHAR const *)sMemberSam; }
   const WCHAR * GetDN() const { return (WCHAR const *)sDN; }
   TAcctReplNode * GetARNode() const { return pNode; }
   BOOL          IsMemberMoved() { return bMemberMoved; }

   void SetMember(const WCHAR * pMember) { sMember = pMember; }
   void SetMemberSam(const WCHAR * pMemberSam) { sMemberSam = pMemberSam; }
   void SetDN(const WCHAR * pDN) { sDN = pDN; }
   void SetARNode(TAcctReplNode * p) { pNode = p; }
   void SetMemberMoved(BOOL bVal = TRUE) { bMemberMoved = bVal; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\regtrans.cpp ===
/*---------------------------------------------------------------------------
  File: RegTranslator.cpp

  Comments: Routines for translating security on the registry keys and files 
  that form a user profile.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/12/99 11:11:46

 ---------------------------------------------------------------------------
*/


#include "stdafx.h"

#include "stargs.hpp"
#include "sd.hpp"
#include "SecObj.hpp"   
#include "sidcache.hpp"
#include "sdstat.hpp"
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"   
#include "TReg.hpp"
#include "TxtSid.h"
#include "RegTrans.h"
#include <WinBase.h>
//#import "\bin\McsDctWorkerObjects.tlb"
#import "WorkObj.tlb"
#include "CommaLog.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct             err;

#define LEN_SID              200
#define REGKEY_ADD_LIMIT     15



DWORD 
   TranslateRegHive(
      HKEY                     hKeyRoot,            // in - root of registry hive to translate
      const LPWSTR             keyName,             // in - name of registry key
      SecurityTranslatorArgs * stArgs,              // in - translation settings
      TSDRidCache            * cache,               // in - translation table
      TSDResolveStats        * stat,                // in - stats on items modified
      BOOL                     bWin2K               // in - flag, whether the machine is Win2K
   )
{
   DWORD                       rc = 0;

   // Translate the permissions on the root key
   TRegSD                      sd(keyName,hKeyRoot);

   
   if ( sd.HasDacl() )
   {
      TSD * pSD = sd.GetSecurity();

      // if there are more than 15 aces in a registry entry, and we are re-ACLing in Add Mode, 
      // skip the entry.  There seems to be a problem in Windows 2000 RC2 where if there are more than 
      // 30 or so ACEs, some of them never get resolved.  If this happens to the Administrator account,
      // (This may only happen if there are 30 or so ACEs alphabetically ahead of the Administrator account)
      // The Administrator account never gets resolved, and the machine is effectively trashed.
      if ( bWin2K && ( stArgs->TranslationMode() == ADD_SECURITY ) && (pSD->GetNumDaclAces() >= REGKEY_ADD_LIMIT) )
      {
         err.MsgWrite(0,DCT_MSG_SKIPPING_REGKEY_TRANSLATION_SDD,keyName,pSD->GetNumDaclAces(),REGKEY_ADD_LIMIT);
      }
      else
      {
         sd.ResolveSD(stArgs,stat,regkey ,NULL);
      }
   }
   // Recursively process any subkeys
   int                       n = 0;
   FILETIME                  writeTime;
   WCHAR                     name[MAX_PATH];
   DWORD                     lenName = DIM(name);
   WCHAR                     fullName[2000];
   HKEY                      hKey;

   do 
   {
      lenName = DIM(name);
      rc = RegEnumKeyEx(hKeyRoot,n,name,&lenName,NULL,NULL,NULL,&writeTime);
      if ( rc && rc != ERROR_MORE_DATA )
         break;
      
      swprintf(fullName,L"%s\\%s",keyName,name);
      // Open the subkey
      rc = RegCreateKeyEx(hKeyRoot,name,0,L"",REG_OPTION_BACKUP_RESTORE,KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,NULL,&hKey,NULL);
      
      if (! rc )
      {
         // Process the subkey
         TranslateRegHive(hKey,fullName,stArgs,cache,stat,bWin2K);   
         RegCloseKey(hKey);
      }
      else
      {
         if  ( (rc != ERROR_FILE_NOT_FOUND) && (rc != ERROR_INVALID_HANDLE) )
         {
            err.SysMsgWrite(ErrS,rc,DCT_MSG_REG_KEY_OPEN_FAILED_SD,fullName,rc);
         }
      }
      n++;

   } while ( rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA);
   if ( rc != ERROR_NO_MORE_ITEMS && rc != ERROR_FILE_NOT_FOUND && rc != ERROR_INVALID_HANDLE )
   {
      err.SysMsgWrite(ErrS,rc,DCT_MSG_REGKEYENUM_FAILED_D,rc);
   }
   return rc;
}

DWORD 
   TranslateRegistry(
      WCHAR            const * computer,        // in - computername to translate, or NULL
      SecurityTranslatorArgs * stArgs,          // in - translation settings
      TSDRidCache            * cache,           // in - translation account mapping
      TSDResolveStats        * stat             // in - stats for items examined and modified
   )
{
   DWORD                       rc = 0;
   WCHAR                       comp[LEN_Computer];

   if ( ! computer )
   {
      comp[0] = 0;
   }
   else
   {
      safecopy(comp,computer);
   }
   
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   TRegKey                    hKey;
   DWORD                      verMaj,verMin,verSP;
   BOOL                       bWin2K = TRUE;  // assume win2k unless we're sure it's not

   // get the OS version - we need to know the OS version because Win2K can fail when registry keys 
   // have many entries
   HRESULT hr = pAccess->raw_GetOsVersion(SysAllocString(comp),&verMaj,&verMin,&verSP);
   if ( SUCCEEDED(hr) )
   {
      if ( verMaj < 5 )
         bWin2K = FALSE;
   }


   err.MsgWrite(0,DCT_MSG_TRANSLATING_REGISTRY);

   rc = hKey.Connect(HKEY_CLASSES_ROOT,computer);
   if ( ! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_CLASSES_ROOT",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }

   rc = hKey.Connect(HKEY_LOCAL_MACHINE,computer);
   if ( ! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_LOCAL_MACHINE",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }

   rc = hKey.Connect(HKEY_USERS,computer);
   if (! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_USERS",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }

   rc = hKey.Connect(HKEY_PERFORMANCE_DATA,computer);
   if ( ! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_PERFORMANCE_DATA",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }
   
   rc = hKey.Connect(HKEY_CURRENT_CONFIG,computer);
   if ( ! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_CURRENT_CONFIG",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }

   rc = hKey.Connect(HKEY_DYN_DATA,computer);
   if ( ! rc )
   {
      rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_DYN_DATA",stArgs,cache,stat,bWin2K);
      hKey.Close();
   }

   return rc;
}


DWORD  
   TranslateUserProfile(
      WCHAR            const * profileName,       // in - name of file containing user profile
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat,              // in - stats on items modified
      WCHAR                  * sSourceName,       // in - Source account name
      WCHAR                  * sSourceDomainName  // in - Source domain name
   )
{
   DWORD                       rc = 0;
   WCHAR                       oldName[MAX_PATH];
   WCHAR                       newName[MAX_PATH];
   WCHAR                       otherName[MAX_PATH];
   HKEY                        hKey;
   HRESULT                     hr = S_OK;
   BOOL                        bWin2K = TRUE;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
   
   safecopy(oldName,profileName);
   safecopy(newName,profileName);
   UStrCpy(newName+UStrLen(newName),".temp");
   safecopy(otherName,profileName);
   UStrCpy(otherName + UStrLen(otherName),".premigration");
      
   // check the OS version of the computer
   // if UNC name is specified, get the computer name
   if ( profileName[0] == L'\\' && profileName[1] == L'\\' )
   {
      bWin2K = TRUE; // if the profile is specified in UNC format (roaming profile) it can be used
      // from multiple machines.  There is no guarantee that the profile will not be loaded on a win2000 machine
   }
   else
   {
      DWORD                     verMaj;
      DWORD                     verMin;
      DWORD                     verSP;
      HRESULT                   hr = pAccess->raw_GetOsVersion(SysAllocString(L""),&verMaj,&verMin,&verSP);

      if ( SUCCEEDED(hr) )
      {
         if ( verMaj < 5 )
         {
            bWin2K = FALSE;
         }
      }
   }
   // Load the registry hive into the registry
   rc = RegLoadKey(HKEY_USERS,L"OnePointTranslation",profileName);
   if ( ! rc )
   {
      // Open the key
      rc = RegOpenKeyEx(HKEY_USERS,L"OnePointTranslation",0,KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,&hKey);
      if ( ! rc )
      {
         // Process the registry hive 
         rc = TranslateRegHive(hKey,L"",stArgs,cache,stat,bWin2K);
         // Unload the registry hive
         if ( ! stArgs->NoChange() )
         {
            DeleteFile(newName);
            hr = UpdateMappedDrives(sSourceName, sSourceDomainName, L"OnePointTranslation");
            rc = RegSaveKey(hKey,newName,NULL);
         }
         else
         {
            rc = 0;
         }
         if ( rc )
         {
            err.SysMsgWrite(ErrS,rc,DCT_MSG_SAVE_HIVE_FAILED_SD,newName,rc);
         }
         RegCloseKey(hKey);
      }
      rc = RegUnLoadKey(HKEY_USERS,L"OnePointTranslation");
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_KEY_UNLOADKEY_FAILED_SD,profileName,rc);
      }
   }
   else
   {
      err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_LOAD_FAILED_SD,profileName,rc);
   }
   if ( ! rc )
   {
      if (! stArgs->NoChange() )
      {
         // Switch out the filenames
         if ( MoveFileEx(oldName,otherName,MOVEFILE_REPLACE_EXISTING) )
         {
            if ( ! MoveFileEx(newName,oldName,0) )
            {
               rc = GetLastError();
               err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,newName,oldName,rc);
            }
         }
         else
         {
            rc = GetLastError();
            if ( rc == ERROR_ACCESS_DENIED )
            { 
               // we do not have access to the directory
               // temporarily grant ourselves access
               // Set NTFS permissions for the results directory
               WCHAR                     dirName[LEN_Path];
               
               safecopy(dirName,oldName);
               WCHAR * slash = wcsrchr(dirName,L'\\');
               if ( slash )
               {
                  (*slash) = 0;
               }

               TFileSD                fsdDirBefore(dirName);
               TFileSD                fsdDirTemp(dirName);
               TFileSD                fsdDatBefore(oldName);
               TFileSD                fsdDatTemp(oldName);
               TFileSD                fsdNewBefore(newName);
               TFileSD                fsdNewTemp(newName);
               BOOL                   dirChanged = FALSE;
               BOOL                   datChanged = FALSE;
               BOOL                   newChanged = FALSE;

               // Temporarily reset the permissions on the directory and the appropriate files
               if ( fsdDirTemp.GetSecurity() != NULL )
               {
                  TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                                    GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                  PACL             acl = NULL;
      
                  fsdDirTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
				  if (acl)
				  {
                     fsdDirTemp.GetSecurity()->SetDacl(acl,TRUE);
      
                     fsdDirTemp.WriteSD();
                     dirChanged = TRUE;
				  }
               }

               if ( fsdDatTemp.GetSecurity() != NULL )
               {
                  TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                                    GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                  PACL             acl = NULL;
      
                  fsdDatTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
				  if (acl)
				  {
                     fsdDatTemp.GetSecurity()->SetDacl(acl,TRUE);
      
                     fsdDatTemp.WriteSD();
                     datChanged = TRUE;
				  }
               }

               if ( fsdNewTemp.GetSecurity() != NULL )
               {
                  TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                                    GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                  PACL             acl = NULL;
      
                  fsdNewTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
				  if (acl)
				  {
                     fsdNewTemp.GetSecurity()->SetDacl(acl,TRUE);
      
                     fsdNewTemp.WriteSD();
                     newChanged = TRUE;
				  }
               }
               rc = 0;
               // Now retry the operations
               if ( MoveFileEx(oldName,otherName,MOVEFILE_REPLACE_EXISTING) )
               {
                  if ( ! MoveFileEx(newName,oldName,0) )
                  {
                     rc = GetLastError();
                     err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,newName,oldName,rc);
                  }
               }
               else
               {
                  rc = GetLastError();
                  err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,oldName,otherName,rc);
               }
               // now that we're done, set the permissions back to what they were
               if ( dirChanged )
               {
                  fsdDirBefore.Changed(TRUE);
                  fsdDirBefore.WriteSD();
               }   
               if ( datChanged )
               {
                  fsdDatBefore.Changed(TRUE);
                  fsdDatBefore.WriteSD();
               }
               if ( newChanged )
               {
                  fsdNewBefore.Changed(TRUE);
                  fsdNewBefore.WriteSD();
               }
            }
            else
            {
               err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,oldName,otherName,rc);
            }
         }
      }
   }
   return rc;
}

DWORD 
   CopyDirectoryTree(
      WCHAR          const * targetDirectory,     // in - target to copy files/dirs to
      WCHAR          const * sourceDirectory      // in - source directory to copy files/dirs from
   )
{
   DWORD                     rc = 0;
   HANDLE                    hFind;
   WIN32_FIND_DATA           fDat;
   WCHAR                     sourceWC[MAX_PATH];
   WCHAR                     sourceFile[MAX_PATH];
   WCHAR                     targetFile[MAX_PATH];

   safecopy(sourceWC,sourceDirectory);
   UStrCpy(sourceWC + UStrLen(sourceWC),L"\\*.*");

   // Loop through the items in the source directory
   hFind = FindFirstFile(sourceWC,&fDat);
   if ( hFind != INVALID_HANDLE_VALUE )
   {
      do {
         if ( UStrICmp(fDat.cFileName,L".") && UStrICmp(fDat.cFileName,L"..") )
         {
            //build the source and target filenames
            swprintf(sourceFile,L"%s\\%s",sourceDirectory,fDat.cFileName);
            swprintf(targetFile,L"%s\\%s",targetDirectory,fDat.cFileName);
         
            TFileSD                   fileSD(sourceFile);
            
            if ( fDat.dwFileAttributes &  FILE_ATTRIBUTE_DIRECTORY )
            {
               // copy the directory, update its SD
               SECURITY_ATTRIBUTES       sAttr;
            
               sAttr.nLength = (sizeof sAttr);
               sAttr.bInheritHandle = FALSE;
               sAttr.lpSecurityDescriptor = NULL;

               if ( fileSD.GetSecurity() )
               {
                  sAttr.lpSecurityDescriptor = fileSD.GetSecurity()->MakeRelSD();
               }
               if (! CreateDirectoryEx(sourceFile,targetFile,&sAttr) )
               {
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_COPY_DIR_FAILED_SSD,sourceFile,targetFile,rc);
               }
               else
               {
                  // Recursively process the contents of the directory
                  CopyDirectoryTree(targetFile,sourceFile);
               }
            }
            else
            {
               // Copy the file
               if (! CopyFile(sourceFile,targetFile,TRUE) )
               {
                  rc = GetLastError();
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_COPY_FILE_FAILED_SSD,sourceFile,targetFile,rc);
               }
               else
               {
                  // copy the security descriptor for the file
                  TFileSD       targetSD(targetFile);

                  targetSD.CopyAccessData(&fileSD);

                  targetSD.WriteSD();
               }
            }
         }
         if (! FindNextFile(hFind,&fDat) )
         {
            rc = GetLastError();
         }

      } while ( ! rc );
   
      if ( rc != ERROR_NO_MORE_FILES )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_FILE_ENUM_FAILED_SD,sourceDirectory,rc);
      }
      FindClose(hFind);
   }
   return rc;
}

DWORD
   CreateNewProfileDirectory(
      WCHAR          const * oldDirectoryName,   // in - directory name for old profile path
      WCHAR          const * newAccountName,     // in - target account name for new profile directory
      WCHAR                * profileDirectory    // out- directory name created for new profile directory
   )
{
   DWORD                     rc = 0;
   WCHAR                     targetDir[MAX_PATH];
   WCHAR                     targetDirWithSuffix[MAX_PATH];
   WCHAR                   * slashNdx;
   TFileSD                   fileSD(const_cast<WCHAR*>(oldDirectoryName));
   SECURITY_ATTRIBUTES       sAttr;

   sAttr.nLength = (sizeof sAttr);
   sAttr.bInheritHandle = FALSE;
   sAttr.lpSecurityDescriptor = NULL;

   if ( fileSD.GetSecurity() )
   {
      sAttr.lpSecurityDescriptor = fileSD.GetSecurity()->MakeRelSD();
   }

   safecopy(targetDir,oldDirectoryName);
   
   if ( targetDir[UStrLen(targetDir)-1] == L'\\' )
      targetDir[UStrLen(targetDir)-1] = 0;
   
   slashNdx = wcsrchr(targetDir,L'\\');

   if ( slashNdx )
   {
      UStrCpy(slashNdx+1,newAccountName);
      // try to create the directory
      if ( ! CreateDirectory(targetDir,NULL) )
      {
         rc = GetLastError();
         
         int                 ndx = 0;

         do {
            if ( ndx >= 1000 ) // abort
            {
               rc = ERROR_ALREADY_EXISTS;
               break;
            }
            
            if ( rc != ERROR_ALREADY_EXISTS )
               break;
            
            swprintf(targetDirWithSuffix,L"%s[%03d]",targetDir,ndx);
            
            if ( ! CreateDirectoryEx(oldDirectoryName,targetDirWithSuffix,&sAttr) )
            {
               rc = GetLastError();
            }
            else
            {
               rc = 0;
            }
            ndx++;
         } while ( rc == ERROR_ALREADY_EXISTS );
         if (! rc )
            UStrCpy(profileDirectory,targetDirWithSuffix);
      }
      else
      {
         UStrCpy(profileDirectory,targetDir);
      }
   }
   else
   {
      rc = ERROR_INVALID_NAME;
   }
   return rc;
}

DWORD 
   UpdateProfilePermissions(
      WCHAR          const   * path,              // in - path for directory to update
      SecurityTranslatorArgs * globalArgs,        // in - path for overall job
      TRidNode               * pNode              // in - account to translate
   )
{
   DWORD                       rc = 0;
   SecurityTranslatorArgs      localArgs;
   TSDResolveStats             stat(localArgs.Cache());
   BOOL						   bUseMapFile = globalArgs->UsingMapFile();

   // set-up the parameters for the translation

   localArgs.Cache()->CopyDomainInfo(globalArgs->Cache());
   localArgs.Cache()->ToSorted();
   if (!bUseMapFile)
   {
      localArgs.SetUsingMapFile(FALSE);
      localArgs.Cache()->InsertLast(pNode->GetAcctName(),pNode->SrcRid(),pNode->GetTargetAcctName(),pNode->TgtRid(),pNode->Type());
   }
   else
   {
      localArgs.SetUsingMapFile(TRUE);
      localArgs.Cache()->InsertLastWithSid(pNode->GetAcctName(),pNode->GetSrcDomSid(),pNode->GetSrcDomName(),pNode->SrcRid(),
		                                   pNode->GetTargetAcctName(),pNode->GetTgtDomSid(),pNode->GetTgtDomName(),pNode->TgtRid(),pNode->Type());
   }
   localArgs.TranslateFiles(TRUE);
   localArgs.SetTranslationMode(globalArgs->TranslationMode());
   localArgs.SetWriteChanges(!globalArgs->NoChange());
   localArgs.PathList()->AddPath(const_cast<WCHAR*>(path),0);

   rc = ResolveAll(&localArgs,&stat);

   return rc;
}


// if the specified node is a normal share, this attempts to convert it to a path
// using the administrative shares
void 
   BuildAdminPathForShare(
      WCHAR       const * sharePath,         // in - 
      WCHAR             * adminShare
   )
{
   // if all else fails, return the same name as specified in the node
   UStrCpy(adminShare,sharePath);

   SHARE_INFO_502       * shInfo = NULL;
   DWORD                  rc = 0;
   WCHAR                  shareName[LEN_Path];
   WCHAR                * slash = NULL;
   WCHAR                  server[LEN_Path];

   safecopy(server,sharePath);

   // split out just the server name
   slash = wcschr(server+3,L'\\');
   if ( slash )
   {
      (*slash) = 0;
   }

   // now get just the share name
   UStrCpy(shareName,sharePath + UStrLen(server) +1);
   slash = wcschr(shareName,L'\\');
   if ( slash )
      *slash = 0;


   rc = NetShareGetInfo(server,shareName,502,(LPBYTE*)&shInfo);
   if ( ! rc )
   {
      if ( *shInfo->shi502_path )
      {
         // build the administrative path name for the share
         UStrCpy(adminShare,server);
         UStrCpy(adminShare + UStrLen(adminShare),L"\\");
         UStrCpy(adminShare + UStrLen(adminShare),shInfo->shi502_path);
         WCHAR * colon = wcschr(adminShare,L':');
         if ( colon )
         {
            *colon = L'$';
            UStrCpy(adminShare + UStrLen(adminShare),L"\\");
            UStrCpy(adminShare + UStrLen(adminShare),slash+1);

         }
         else
         {
            // something went wrong -- revert to the given path
            UStrCpy(adminShare,sharePath);
         }

      }
      NetApiBufferFree(shInfo);
   }
}
                  
DWORD
   CopyProfileDirectoryAndTranslate(
      WCHAR          const   * directory,         // in - directory path for profile 
      WCHAR                  * directoryOut,      // out- new Profile Path (including environment variables)
      TRidNode               * pNode,             // in - node for account being translated
      SecurityTranslatorArgs * stArgs,            // in - translation settings 
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   DWORD                       rc = 0;
   WCHAR                       fullPath[MAX_PATH];
   WCHAR                       targetPath[MAX_PATH];
   WCHAR                       profileName[MAX_PATH];
   WCHAR                       targetAcctName[MAX_PATH];
   WCHAR                       sourceDomName[MAX_PATH];
   HANDLE                      hFind;
   WIN32_FIND_DATA             fDat;
   BOOL						   bTranslateDirOnly = FALSE;

   rc = ExpandEnvironmentStrings(directory,fullPath,DIM(fullPath));
   if ( !rc )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_EXPAND_STRINGS_FAILED_SD,directory,rc);
   }
   else
   {
      // Create a new directory for the target profile
       // Get the account name for target user
      wcscpy(targetAcctName, pNode->GetTargetAcctName());
      if ( wcslen(targetAcctName) == 0 )
      {
         // if target user name not specified then use the source name.
         wcscpy(targetAcctName, pNode->GetAcctName());
      }
      
      //stArgs->SetTranslationMode(ADD_SECURITY);

      // We are changing our stratergy. We are not going to copy the profile directories anymore.
      // we will be reACLing the directories and the Registry instead.
      /*
      rc = CreateNewProfileDirectory(fullPath, targetAcctName,targetPath);
      if ( ! rc )
      {
         rc = CopyDirectoryTree(targetPath,fullPath);
      }
      */
      BuildAdminPathForShare(fullPath,targetPath);

	  wcscpy(sourceDomName, const_cast<WCHAR*>(stArgs->Cache()->GetSourceDomainName()));
	     //if we are using a sID mapping file, try to get the src domain name from this node's information
      wcscpy(sourceDomName, pNode->GetSrcDomName());

      // Look for profile files in the target directory
      // look for NTUser.MAN
      swprintf(profileName,L"%s\\NTUser.MAN",targetPath);
      hFind = FindFirstFile(profileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         err.MsgWrite(0,DCT_MSG_TRANSLATING_NTUSER_MAN_S,targetAcctName);
         rc = TranslateUserProfile(profileName,stArgs,stArgs->Cache(),stat, pNode->GetAcctName(), sourceDomName);
         FindClose(hFind);
      }
      else
      {
         // check for NTUser.DAT
         swprintf(profileName,L"%s\\NTUser.DAT",targetPath);
         hFind = FindFirstFile(profileName,&fDat);
         if ( hFind != INVALID_HANDLE_VALUE )
         {
            err.MsgWrite(0,DCT_MSG_TRANSLATING_NTUSER_BAT_S,targetAcctName);
            rc = TranslateUserProfile(profileName,stArgs,stArgs->Cache(),stat,pNode->GetAcctName(), sourceDomName);
            FindClose(hFind);
         }
         else
         {
            err.MsgWrite(ErrS,DCT_MSG_PROFILE_REGHIVE_NOT_FOUND_SS,targetAcctName,targetPath);
			bTranslateDirOnly = TRUE; //set falg to atleast change permissins on the share dir
            rc = 2;  // File not found
         }
      }
      
      if ((!rc) || (bTranslateDirOnly))
         rc = UpdateProfilePermissions(targetPath,stArgs,pNode);

      wcscpy(directoryOut, fullPath);
   }
   return rc;
}

DWORD 
   TranslateLocalProfiles(
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   DWORD                       rc = 0;
   WCHAR                       keyName[MAX_PATH];
   DWORD                       lenKeyName = DIM(keyName);   
   TRegKey                     keyProfiles;
   BOOL						   bUseMapFile = stArgs->UsingMapFile();

   rc = keyProfiles.Open(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",HKEY_LOCAL_MACHINE);
   
   if ( ! rc )
   {
      // get the number of subkeys
      // enumerate the subkeys
      DWORD                    ndx;
      DWORD                    nSubKeys = 0;

      rc = RegQueryInfoKey(keyProfiles.KeyGet(),NULL,0,NULL,&nSubKeys,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
      if ( ! rc )
      {
         // construct a list containing the sub-keys
         PSID                * pSids = new PSID[nSubKeys];

         for ( ndx = nSubKeys - 1 ; (long)ndx >= 0 ; ndx-- ) 
         { 
            rc = keyProfiles.SubKeyEnum(ndx,keyName,lenKeyName);
      
            if ( rc )
               break;
      
            pSids[ndx] = SidFromString(keyName);
            
         }
         if ( ! rc )
         {
            // process each profile
            for ( ndx = 0 ; ndx < nSubKeys ; ndx++ )
            {
               do // once  
               { 
                     if ( ! pSids[ndx] )
                        continue;
                  // see if this user needs to be translated
				  TRidNode  * pNode = NULL;
				  if (!bUseMapFile)
                     pNode = (TRidNode*)cache->Lookup(pSids[ndx]);
				  else
					 pNode = (TRidNode*)cache->LookupWODomain(pSids[ndx]);
            
                  if ( pNode == (TRidNode *)-1 )
                     pNode = NULL;
                  
                  if ( pNode && pNode->IsValidOnTgt() )  // need to translate this one
                  {
                     PSID                 pSidTgt = NULL;
                     WCHAR                strSourceSid[200];
                     WCHAR                strTargetSid[200];
                     DWORD                dimSid = DIM(strSourceSid);
                     TRegKey              srcKey;
                     TRegKey              tgtKey;
                     DWORD                disposition;
                     WCHAR                keyPath[MAX_PATH];
                     WCHAR                targetPath[MAX_PATH];
                     DWORD                lenValue;
                     DWORD                typeValue;

	                 if (!bUseMapFile)
                        pSidTgt = cache->GetTgtSid(pSids[ndx]);
	                 else
                        pSidTgt = cache->GetTgtSidWODomain(pSids[ndx]);
                     GetTextualSid(pSids[ndx],strSourceSid,&dimSid);
                     dimSid = DIM(strTargetSid);
                     GetTextualSid(pSidTgt,strTargetSid,&dimSid);

                     rc = srcKey.Open(strSourceSid,&keyProfiles);
                     if ( rc )
                     {
                        err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_ENTRY_OPEN_FAILED_SD,pNode->GetAcctName(),rc );
                        break;
                     }
                     if ( (stArgs->TranslationMode() == ADD_SECURITY) || (stArgs->TranslationMode() == REPLACE_SECURITY) )
                     {
                        // make a copy of this registry key, so the profile will refer to the new user
                        if ( ! stArgs->NoChange() )
                        {
                           rc = tgtKey.Create(strTargetSid,&keyProfiles,&disposition);
                        }
                        else
                        {
                           // We need to see if the key already exists or not and set the DISPOSITION accordingly.
                           rc = tgtKey.OpenRead(strTargetSid, &keyProfiles);
                           if ( rc ) 
                           {
                              disposition = REG_CREATED_NEW_KEY;
                              rc = 0;
                           }
                           tgtKey.Close();
                        }
                        if ( rc )
                        {
                           err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_CREATE_ENTRY_FAILED_SD,pNode->GetTargetAcctName(),rc);
                           break;
                        }
                        if ( disposition == REG_CREATED_NEW_KEY || (stArgs->TranslationMode() == REPLACE_SECURITY))
                        {
                           // copy the entries from the source key
                           if ( ! stArgs->NoChange() )
                           {
                              rc = tgtKey.HiveCopy(&srcKey);
                           }
                           else 
                           {
                              rc = 0;
                              tgtKey = srcKey;
                           }
                           if ( rc )
                           {
                              err.SysMsgWrite(ErrS,rc,DCT_MSG_COPY_PROFILE_FAILED_SSD,pNode->GetAcctName(),pNode->GetTargetAcctName(),rc);
                              break;
                           }
                           // now get the profile path ...
                           lenValue = (sizeof keyPath);
                           rc = tgtKey.ValueGet(L"ProfileImagePath",(void *)keyPath,&lenValue,&typeValue);
                           if ( rc )
                           {
                              err.SysMsgWrite(ErrS,rc,DCT_MSG_GET_PROFILE_PATH_FAILED_SD,pNode->GetAcctName(),rc);
                              break;
                           }
                           //copy the profile directory and its contents, and translate the profile registry hive itself
                           rc = CopyProfileDirectoryAndTranslate(keyPath,targetPath,pNode,stArgs,stat);
                           if ( rc )
                           {
                              // Since the translation failed and we created the key we should delete it.
                              if ( disposition == REG_CREATED_NEW_KEY )
                              {
                                 if ( ! stArgs->NoChange() )
                                    keyProfiles.SubKeyDel(strTargetSid);
                              }
                              break;
                           }
                           // Update the ProfileImagePath key
                           if ( !stArgs->NoChange() )
                              rc = tgtKey.ValueSet(L"ProfileImagePath",(void*)targetPath,(1+UStrLen(targetPath)) * (sizeof WCHAR),typeValue);
                           else
                              rc = 0;
                           if ( rc )
                           {
                              err.SysMsgWrite(ErrS,rc,DCT_MSG_SET_PROFILE_PATH_FAILED_SD,pNode->GetTargetAcctName(),rc);
                              break;
                           }

                           // update the SID property
                           if ( !stArgs->NoChange() )
                              rc = tgtKey.ValueSet(L"Sid",(void*)pSidTgt,GetLengthSid(pSidTgt),REG_BINARY);
                           else
                              rc = 0;
                           if ( rc )
                           {
                              rc = GetLastError();
                              err.SysMsgWrite(ErrS,rc,DCT_MSG_UPDATE_PROFILE_SID_FAILED_SD,pNode->GetTargetAcctName(),rc);
                              break;
                           }
                        }
                        else
                        {
                           err.MsgWrite(ErrW,DCT_MSG_PROFILE_EXISTS_S,pNode->GetTargetAcctName());
                           break;
                        }
                     }
                     if ( stArgs->TranslationMode() != ADD_SECURITY )
                     {
                        // delete the old registry key
                        if ( ! stArgs->NoChange() )
                           rc = keyProfiles.SubKeyDel(strSourceSid);
                        else
                           rc = 0;
                        if ( rc )
                        {
                           err.SysMsgWrite(ErrS,rc,DCT_MSG_DELETE_PROFILE_FAILED_SD,pNode->GetAcctName(),rc);
                           break;
                        }
                        else
                        {
                           err.MsgWrite(0, DCT_MSG_DELETED_PROFILE_S, pNode->GetAcctName());
                        }
                     }
                  }
               } while ( FALSE ); 
            }

            // clean up the list
            for ( ndx = 0 ; ndx < nSubKeys ; ndx++ )
            {
               if ( pSids[ndx] )
                  FreeSid(pSids[ndx]);
               pSids[ndx] = NULL;
            }
            delete [] pSids;
         }         
      }
      if ( rc && rc != ERROR_NO_MORE_ITEMS )
      {
         err.SysMsgWrite(ErrS,rc,DCT_MSG_ENUM_PROFILES_FAILED_D,rc);
      }
   }
   else
   {
      err.SysMsgWrite(ErrS,rc,DCT_MSG_OPEN_PROFILELIST_FAILED_D,rc);
   }
   return rc;
}

DWORD 
   TranslateRemoteProfile(
      WCHAR          const * sourceProfilePath,   // in - source profile path
      WCHAR                * targetProfilePath,   // out- new profile path for target account
      WCHAR          const * sourceName,          // in - name of source account
      WCHAR          const * targetName,          // in - name of target account
      WCHAR          const * srcDomain,           // in - source domain
      WCHAR          const * tgtDomain,           // in - target domain
      IIManageDB           * pDb,				  // in - pointer to DB object
	  long					 lActionID,           // in - action ID of this migration
	  PSID                   sourceSid,           // in - source sid from MoveObj2K
      BOOL                   bNoWriteChanges      // in - No Change mode.
   )
{
   DWORD                     rc = 0;
   BYTE                      srcSid[LEN_SID];
   PSID                      tgtSid[LEN_SID];
   SecurityTranslatorArgs    stArgs;
   TSDResolveStats           stat(stArgs.Cache());
   TRidNode                * pNode = NULL;
   WCHAR                     domain[LEN_Domain];
   DWORD                     lenDomain = DIM(domain);
   DWORD                     lenSid = DIM(srcSid);
   DWORD                     srcRid=0;
   DWORD                     tgtRid=0;
   SID_NAME_USE              snu;
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk = NULL;
   HRESULT                   hr = S_OK;
   WCHAR                     sActionInfo[MAX_PATH];
   _bstr_t                   sSSam;
   long						 lrid;

   stArgs.Cache()->SetSourceAndTargetDomains(srcDomain,tgtDomain);

   if ( stArgs.Cache()->IsInitialized() )
   {
      // Get the source account's rid
      if (! LookupAccountName(stArgs.Cache()->GetSourceDCName(),sourceName,srcSid,&lenSid,domain,&lenDomain,&snu) )
      {
         rc = GetLastError();
      }
      else
      {
         if ( !UStrICmp(domain,srcDomain) )
         {
            PUCHAR              pCount = GetSidSubAuthorityCount(srcSid);
            if ( pCount )
            {
               DWORD            nSub = (DWORD)(*pCount) - 1;
               DWORD          * pRid = GetSidSubAuthority(srcSid,nSub);

               if ( pRid )
               {
                  srcRid = *pRid;
               }

            }
         }
      }
	     //if we couldn't get the src Rid, we are likely doing an intra-forest migration.
	     //In this case we will lookup the src Rid in the Migrated Objects table
	  if (!srcRid)
	  {
		 CopySid(GetLengthSid(srcSid), srcSid , sourceSid);
		 hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
		 if ( SUCCEEDED(hr) )
			hr = pDb->raw_GetMigratedObjects(lActionID, &pUnk);

		 if ( SUCCEEDED(hr) )
		 {
			long lCnt = pVs->get("MigratedObjects");
			bool bFound = false;
			for ( long l = 0; (l < lCnt) && (!bFound); l++)
			{
				wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceSamName));      
				sSSam = pVs->get(sActionInfo);
				if (_wcsicmp(sourceName, (WCHAR*)sSSam) == 0)
				{
                   wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceRid));      
                   lrid = pVs->get(sActionInfo);
				   srcRid = (DWORD)lrid;
				   bFound = true;
				}
			}
		 }
	  }
      
      lenSid = DIM(tgtSid);
      lenDomain = DIM(domain);
      // Get the target account's rid
      if (! LookupAccountName(stArgs.Cache()->GetTargetDCName(),targetName,tgtSid,&lenSid,domain,&lenDomain,&snu) )
      {
         rc = GetLastError();
      }
      else
      {
         if ( !UStrICmp(domain,tgtDomain) )
         {
            PUCHAR              pCount = GetSidSubAuthorityCount(tgtSid);
            if ( pCount )
            {
               DWORD            nSub = (DWORD)(*pCount) - 1;
               DWORD          * pRid = GetSidSubAuthority(tgtSid,nSub);

               if ( pRid )
               {
                  tgtRid = *pRid;
               }
            }
         }
      }
   }

   if ( ((srcRid && tgtRid) || !stArgs.NoChange()) && (!bNoWriteChanges) )
   {
      stArgs.Cache()->InsertLast(const_cast<WCHAR * const>(sourceName), srcRid, const_cast<WCHAR * const>(targetName), tgtRid);         
	  pNode = (TRidNode*)stArgs.Cache()->Lookup(srcSid);

      if ( pNode )
      {
         // Set up the security translation parameters
         stArgs.SetTranslationMode(ADD_SECURITY);
         stArgs.TranslateFiles(FALSE);
         stArgs.TranslateUserProfiles(TRUE);
         stArgs.SetWriteChanges(!bNoWriteChanges);
         //copy the profile directory and its contents, and translate the profile registry hive itself
         rc = CopyProfileDirectoryAndTranslate(sourceProfilePath,targetProfilePath,pNode,&stArgs,&stat);
      }
   }                        
   return rc;
}

HRESULT UpdateMappedDrives(WCHAR * sSourceSam, WCHAR * sSourceDomain, WCHAR * sRegistryKey)
{
   TRegKey                   reg;
   TRegKey                   regDrive;
   DWORD                     rc = 0;
   WCHAR                     netKey[LEN_Path];
   int                       len = LEN_Path;
   int                       ndx = 0;
   HRESULT                   hr = S_OK;
   WCHAR                     sValue[LEN_Path];
   WCHAR                     sAcct[LEN_Path];
   WCHAR                     keyname[LEN_Path];

   // Build the account name string that we need to check for
   wsprintf(sAcct, L"%s\\%s", (WCHAR*) sSourceDomain, (WCHAR*) sSourceSam);
   // Get the path to the Network subkey for this users profile.
   wsprintf(netKey, L"%s\\%s", (WCHAR*) sRegistryKey, L"Network");
   rc = reg.Open(netKey, HKEY_USERS);
   if ( !rc ) 
   {
      while ( !reg.SubKeyEnum(ndx, keyname, len) )
      {
         rc = regDrive.Open(keyname, reg.KeyGet());
         if ( !rc ) 
         {
            // Get the user name value that we need to check.
            rc = regDrive.ValueGetStr(L"UserName", sValue, LEN_Path);
            if ( !rc )
            {
               if ( !_wcsicmp(sAcct, sValue) )
               {
                  // Found this account name in the mapped drive user name.so we will set the key to ""
                  regDrive.ValueSetStr(L"UserName", L"");
                  err.MsgWrite(0, DCT_MSG_RESET_MAPPED_CREDENTIAL_S, sValue);
               }
            }
            else
               hr = HRESULT_FROM_WIN32(GetLastError());
            regDrive.Close();
         }
         else
            hr = HRESULT_FROM_WIN32(GetLastError());
         ndx++;
      }
      reg.Close();
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WorkObj.rc
//
#define IDS_PROJNAME                    100
#define IDR_ACCTREPL                    101
#define IDR_COMPPWDAGE                  102
#define IDR_CHANGEDOMAIN                103
#define IDR_RENAMECOMPUTER              104
#define IDR_REBOOT                      105
#define IDR_PWDCOPY                     106
#define IDR_USERRIGHTS                  107
#define IDR_STATUSOBJ                   108
#define IDR_SECTRANSLATOR               109
#define IDR_ACCESSCHECKER               110
#define IDR_PLUGININFO                  111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rename.h ===
/*---------------------------------------------------------------------------
  File: RenameComputer.h

  Comments: Implementation class definition for COM object to rename the local computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:25:06

 ---------------------------------------------------------------------------
*/

// RenameComputer.h : Declaration of the CRenameComputer

#ifndef __RENAMECOMPUTER_H_
#define __RENAMECOMPUTER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRenameComputer
class ATL_NO_VTABLE CRenameComputer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRenameComputer, &CLSID_RenameComputer>,
	public IDispatchImpl<IRenameComputer, &IID_IRenameComputer, &LIBID_MCSDCTWORKEROBJECTSLib>
{  
   BOOL                      m_bNoChange;
public:
	CRenameComputer()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_RENAMECOMPUTER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRenameComputer)
	COM_INTERFACE_ENTRY(IRenameComputer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRenameComputer
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(RenameLocalComputer)(BSTR NewName);
};

#endif //__RENAMECOMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rightstr.h ===
#ifndef __RIGHTSTRANSLATOR_H__
#define __RIGHTSTRANSLATOR_H__
/*---------------------------------------------------------------------------
  File: RightsTranslator.h

  Comments: Functions to translate user rights.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/25/99 19:56:44

 ---------------------------------------------------------------------------
*/




DWORD  
   TranslateUserRights(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

#endif //__RIGHTSTRANSLATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\rightstr.cpp ===
/*---------------------------------------------------------------------------
  File: RightsTranslator.cpp

  Comments: Functions to translate user rights

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/25/99 19:57:16

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Mcs.h"
#include "WorkObj.h"
#include "SecTrans.h"
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"
#include "TxtSid.h"
#include "ErrDct.hpp"

//#import "\bin\McsDctWorkerObjects.tlb"
#import "WorkObj.tlb"

extern TErrorDct err;

DWORD  
   TranslateUserRights(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
//   DWORD                       rc = 0;
   HRESULT                     hr;
   SAFEARRAY                 * pRights = NULL;
   SAFEARRAY                 * pUsers = NULL;
   TAcctNode                 * node = NULL;
   _bstr_t                     server = serverName;
   MCSDCTWORKEROBJECTSLib::IUserRightsPtr pLsa(CLSID_UserRights);
   WCHAR                       currPath[500];
   DWORD                       mode = stArgs->TranslationMode();
   BOOL						   bUseMapFile = stArgs->UsingMapFile();

   if ( pLsa == NULL )
   {
      return E_FAIL;
   }
   pLsa->NoChange = stArgs->NoChange();
   
   if ( stArgs->TranslationMode() != ADD_SECURITY )
   {
      err.MsgWrite(0,DCT_MSG_USER_RIGHTS_ONLY_ADDS);
      stArgs->SetTranslationMode(ADD_SECURITY);
   }
   // Get a list of all the rights
   hr = pLsa->raw_GetRights(server,&pRights);
   if ( SUCCEEDED(hr) )
   {
      LONG                   nRights = 0;
      long                   ndx[1];
      hr = SafeArrayGetUBound(pRights,1,&nRights);
      if ( SUCCEEDED(hr) )
      {
         for ( long i = 0 ; i <= nRights ; i++ )
         {
            BSTR             right;
            
            ndx[0] = i;
            hr = SafeArrayGetElement(pRights,ndx,&right);
            if ( SUCCEEDED(hr) )
            {
               swprintf(currPath,L"%s\\%s",serverName,(WCHAR*)right);
               if( stat )
               {
                  stat->DisplayPath(currPath);
               }
               // Get a list of users who have this right
               hr = pLsa->raw_GetUsersWithRight(server,right,&pUsers);
               if ( SUCCEEDED(hr))
               {
                  LONG       nUsers = 0;
                  
                  hr = SafeArrayGetUBound(pUsers,1,&nUsers);
                  if ( SUCCEEDED(hr) )
                  {
                     BSTR    user;
                     PSID    pSid = NULL;
//                     PSID    pTgt = NULL;
                     
                     for ( long j = 0 ; j <= nUsers ; j++ )
                     {
                        ndx[0] = j;
                        hr = SafeArrayGetElement(pUsers,ndx,&user);
                        if ( SUCCEEDED(hr)) 
                        {
                           // Get the user's sid
                           pSid = SidFromString(user);
                           if ( pSid )
                           {
                              stat->IncrementExamined(userright);
                              // Lookup the user in the cache
							  if (!bUseMapFile)
                                 node = cache->Lookup(pSid);
							  else
                                 node = cache->LookupWODomain(pSid);
                              if ( node )
                              {
                                 if ( node == (TAcctNode*)-1 )
                                 {
                                    node = NULL;     
                                 }
                                 if ( node && node->IsValidOnTgt() )
                                 {
                                    // Found the account in the cache
                                    // remove the right from the source user
                                    
                                    if ( (stArgs->TranslationMode() != ADD_SECURITY) )
                                    {
                                       hr = pLsa->raw_RemoveUserRight(server,user,right);
                                       if ( FAILED(hr))
                                       {
                                          err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_RIGHT_FAILED_SSSD,
                                                   (WCHAR*)right,node->GetAcctName(),serverName,hr);
                                          stat->IncrementSkipped(userright);
                                       }
                                       else
                                       {
                                          err.MsgWrite(0,DCT_MSG_REMOVED_RIGHT_SSSS,serverName,right,stArgs->Source(),node->GetAcctName());
                                       }
                                    }
                                    if ( SUCCEEDED(hr) )
                                    {
                                       stat->IncrementChanged(userright);
                                       PSID sid = NULL;
	                                   if (!bUseMapFile)
                                          sid = cache->GetTgtSid(node);
	                                   else
                                          sid = cache->GetTgtSidWODomain(node);
                                       if ( sid )
                                       {
                                          WCHAR          strSid[200];
                                          DWORD          lenStrSid = DIM(strSid);
                                          GetTextualSid(sid,strSid,&lenStrSid);
                                          
                                          if ( (stArgs->TranslationMode() != REMOVE_SECURITY) )
                                          {
                                             hr = pLsa->raw_AddUserRight(server,SysAllocString(strSid),right);
                                             if ( FAILED(hr) )
                                             {
                                                err.SysMsgWrite(ErrE,hr,DCT_MSG_ADD_RIGHT_FAILED_SSSD,
                                                         (WCHAR*)right,node->GetAcctName(),serverName,hr);
                                                
                                             }
                                             else
                                             {
                                                err.MsgWrite(0,DCT_MSG_ADDED_RIGHT_SSSS,serverName,right,stArgs->Target(),node->GetAcctName());
                                             }
                                          }
                                          free(sid);
                                       }
                                    }
                                 }
                              }
                              FreeSid(pSid);
                           }
                           else
                           {
                              err.MsgWrite(ErrW,DCT_MSG_INVALID_SID_STRING_S,user);
                           }
                           SysFreeString(user);
                        }
                     }
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_USERS_WITH_RIGHT_COUNT_FAILED_SSD,(WCHAR*)right,serverName,hr);
                  }
                  SafeArrayDestroy(pUsers);
               }
               else
               {
                  err.MsgWrite(ErrE,DCT_MSG_GET_USERS_WITH_RIGHT_FAILED_SSD,(WCHAR*)right,serverName,hr);
               }
               SysFreeString(right);
            }
            else
            {
               err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,serverName,hr);
               break;
            }
         }
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,serverName,hr);
      }
      SafeArrayDestroy(pRights);   
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,serverName,hr);
   }
   if( stat )
   {
      stat->DisplayPath(L"");
   }

   // set the translation mode back to its original value
   stArgs->SetTranslationMode(mode);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\secobj_stub.cpp ===
/* This is a stub to include common\commonlib\secobj.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "secobj.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sdstat.cpp ===
//#pragma title ("SDStat.hpp -- Statistical information for SDResolve")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdstat.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Statistical information for SDResolve
Updates     -
===============================================================================
*/

#include "stdafx.h"
#include <stdio.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "sidcache.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "enumvols.hpp"
#include "sdstat.hpp"

#include "Mcs.h"


extern TErrorDct        err;

   TSDResolveStats::TSDResolveStats(
      TSDRidCache          * cache,       // in - cache containing mapping of accounts for the translation
      const TPathList      * plist,       // in - list of paths being translated
      IVarSet              * pVarSet      // in - varset to store stats in
   )
{
   memset(&unit,0,sizeof TSDFileActions);
   memset(&part,0,sizeof TSDPartStats);
   pPList = plist;
   len = 0;
   frame_foreground =FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN ;                        
   background = BACKGROUND_BLUE ;
   data_foreground =frame_foreground | FOREGROUND_INTENSITY ;
   message_foreground = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
   pCache = cache;
   m_pVarSet = pVarSet;
   }



   TSDResolveStats::TSDResolveStats(
      TSDRidCache          * cache        // in - cache containing mapping of accounts for translation
   )  
{
   memset(&unit,0,sizeof TSDFileActions);
   memset(&part,0,sizeof TSDPartStats);
   pPList = NULL;
   len = 0;
   frame_foreground =FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN ;                        
   background = BACKGROUND_BLUE ;
   data_foreground =frame_foreground | FOREGROUND_INTENSITY ;
   message_foreground = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
   pCache = cache;
	//Added by Sham : Initialize m_pVarSet
	IVarSetPtr pVarSet(__uuidof(VarSet));
	m_pVarSet = pVarSet;
	// Need to add code to release this interface once we are done. In the destructor maybe
	m_pVarSet->AddRef();
}
void 
   TSDResolveStats::IncrementOwnerChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed 
   ) 
{ 
   acct->AddOwnerChange(type);

   if ( acct->IsValidOnTgt() )
   {
      part.owner.changed++;
    //  DisplayStatItem(OWNER_ROW,CHANGED_COL,part.owner.changed);
   }
   else
   {
      part.owner.notarget++;
    //  DisplayStatItem(OWNER_ROW,SKIPPED_COL,part.owner.skipped);
      // TODO log an error message
   }

   if ( file )
      file->LogOwnerChange(acct);
}

void 
   TSDResolveStats::IncrementGroupChange(
      TAcctNode            * acct,                    // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                     // in -file changed
   ) 
{ 
   acct->AddGroupChange(type); 
   if ( acct->IsValidOnTgt() )
   {
      part.group.changed++;
    //  DisplayStatItem(GROUP_ROW,CHANGED_COL,part.group.changed);
   }
   else
   {
      part.group.notarget++;
     // DisplayStatItem(GROUP_ROW,SKIPPED_COL,part.group.skipped);
   }

   if ( file )
      file->LogGroupChange(acct);
}
   
void 
   TSDResolveStats::IncrementDACEChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed
   )  
{ 
   acct->AddAceChange(type); 
   if ( acct->IsValidOnTgt() )
   {
      part.dace.changed++;
    //  DisplayStatItem(DACE_ROW,CHANGED_COL,part.dace.changed);
   }
   else
   {
      part.dace.notarget++;
  //    DisplayStatItem(DACE_ROW,SKIPPED_COL,part.dace.skipped);
   }
   if ( file )
      file->LogDACEChange(acct); 
}

void 
   TSDResolveStats::IncrementSACEChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed
   )  
{ 
   acct->AddSaceChange(type); 
   if ( acct->IsValidOnTgt() ) 
   {
      part.sace.changed++;
    //  DisplayStatItem(SACE_ROW,CHANGED_COL,part.sace.changed);
   }
   else
   {
      part.sace.notarget++;
     // DisplayStatItem(SACE_ROW,SKIPPED_COL,part.sace.skipped);
   }
   if ( file )
      file->LogSACEChange(acct); 
}

void 
   TSDResolveStats::IncrementDACENotSelected(
      TSecurableObject *file               // in - object to increment stats for
   ) 
{ 
   file->daceNS++;  
   part.dace.notselected++; 
}
void 
   TSDResolveStats::IncrementSACENotSelected(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->saceNS++;  
   part.sace.notselected++; 
}

void 
   TSDResolveStats::IncrementDACEUnknown(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->daceU++;  
   part.dace.unknown++; 
}
void 
   TSDResolveStats::IncrementSACEUnknown(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if  ( file )
      file->saceU++;  
   part.sace.unknown++; 
}

void 
   TSDResolveStats::IncrementDACENoTarget(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->daceNT++;  
   part.dace.notarget++; 
}
void 
   TSDResolveStats::IncrementSACENoTarget(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->saceNT++;  
   part.sace.notarget++; 
}

/***************************************************************************************************/
/* IncrementLastFileChanges: used in conjunction with last-seen heuristic.  When a SD matches the 
                          last-seen SD, this routine repeats all the stat-updates 
                          that were done for the last-seen SD, so that we have accurate stats 
                          (especially ACE changes per account)
/**************************************************************************************************/
void 
   TSDResolveStats::IncrementLastFileChanges(
      const TSecurableObject            * lastfile,                 // in -file to repeat change stats from
      objectType                       objType                   // in -type of object
   )
{
   TNodeListEnum             tenum;
   TStatNode               * snode;
   
   // make modifications except changes
   // owner
   IncrementOwnerExamined();
   IncrementGroupExamined();
   
   if ( lastfile->UnknownOwner() )
      part.owner.unknown++;
  
   // group
   if ( lastfile->UnknownGroup() )
      part.group.unknown++;
   // dacl
   if ( lastfile->HasDacl() )
      IncrementDACLExamined();
   // sacl 
   if ( lastfile->HasSacl() )
      IncrementSACLExamined();
   // aces
   part.dace.notarget+=lastfile->daceNT;
   part.sace.notarget+=lastfile->saceNT;
   part.dace.unknown+=lastfile->daceU;
   part.sace.unknown+=lastfile->saceU;
   part.dace.notselected+=lastfile->daceNS;
   part.sace.notselected+=lastfile->saceNS;
   if ( lastfile->Changed() )
   {
      IncrementChanged(objType);
   }
     
   if ( lastfile->Changed() || (lastfile->GetChangeLog())->Count() )
   {
      if ( lastfile->IsDaclChanged() )
      {
         IncrementDACLChanged();
      }
      if ( lastfile->IsSaclChanged() )
      {
         IncrementSACLChanged();
      }
      for ( snode = (TStatNode *)tenum.OpenFirst(lastfile->GetChangeLog()) ; 
            snode ;
            snode = (TStatNode *)tenum.Next()
          )
      {             
         switch ( snode->changetype )
         {
            case TStatNode::owner: 
               IncrementOwnerChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::group: 
               IncrementGroupChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::dace: 
               IncrementDACEChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::sace: 
               IncrementSACEChange(snode->acctnode,objType,NULL);
               break;
           default: 
               MCSASSERT( false );
         }
      }
      tenum.Close();
   }
}

void 
   TSDResolveStats::ReportToVarSet(
      IVarSet              * pVarSet,     // in -varset to write data to
      DWORD                  verbnum      // in -which info to log
   ) const
{        
   BOOL                      summary = verbnum & SUMMARYSTATS;
   BOOL                      accts   = verbnum & ACCOUNTSTATS;
//   BOOL                      file    = verbnum & FILESTATS;
   BOOL                      paths   = verbnum & PATHSTATS;
     
   if ( summary )
   {
      if ( paths && pPList )
      {
         pVarSet->put(GET_BSTR(DCTVS_Stats_Paths),(LONG)pPList->GetNumPaths() );
      
         pVarSet->put(GET_BSTR(DCTVS_Stats_Servers),(LONG)pPList->GetNumServers() );
      }
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Examined),(LONG)unit.examined.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Examined),(LONG)unit.examined.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Examined),(LONG)unit.examined.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Examined),(LONG)unit.examined.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Examined),(LONG)unit.examined.container);
      
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_CacheHits),(LONG)unit.cachehit.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_CacheHits),(LONG)unit.cachehit.dir);
      
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Skipped),(LONG)unit.skipped.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Skipped),(LONG)unit.skipped.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Skipped),(LONG)unit.skipped.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Skipped),(LONG)unit.skipped.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Skipped),(LONG)unit.skipped.container);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Changed),(LONG)unit.changed.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Changed),(LONG)unit.changed.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Changed),(LONG)unit.changed.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Changed),(LONG)unit.changed.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Changed),(LONG)unit.changed.container);

      

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Examined),(LONG)part.owner.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Examined),(LONG)part.group.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Examined),(LONG)part.dacl.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Examined),(LONG)part.sacl.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Examined),(LONG)part.dace.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Examined),(LONG)part.sace.examined);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Changed),(LONG)part.owner.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Changed),(LONG)part.group.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Changed),(LONG)part.dacl.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Changed),(LONG)part.sacl.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Changed),(LONG)part.dace.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Changed),(LONG)part.sace.changed);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NoTarget),(LONG)part.owner.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NoTarget),(LONG)part.group.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_NoTarget),(LONG)part.dace.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_NoTarget),(LONG)part.sace.notarget);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Unknown),(LONG)part.owner.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Unknown),(LONG)part.group.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Unknown),(LONG)part.dace.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Unknown),(LONG)part.sace.unknown);

   }  
   if ( accts ) 
      pCache->ReportToVarSet(pVarSet,false, true);

}


void 
   TSDResolveStats::Report(
      BOOL                   summary,     // in -flag, whether to report summary information
      BOOL                   accts,       // in -flag, whether to report account detail information
      BOOL                   paths        // in -flag, whether to report path detail information
   ) const
{        
   if ( accts ) 
      pCache->Display(summary!=0, accts!=0);
#ifdef FST
   if ( paths & pPList )
      pPList->Display();
#endif
     if ( summary )
   {
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_HEADER);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_FILES_DDD,unit.examined.file, unit.changed.file, unit.examined.file - unit.changed.file);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_DIRS_DDD,unit.examined.dir, unit.changed.dir, unit.examined.dir - unit.changed.dir);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_SHARES_DDD,unit.examined.share, unit.changed.share, unit.examined.share - unit.changed.share);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_MEMBERS_DDD,unit.examined.member, unit.changed.member, unit.examined.member - unit.changed.member);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_RIGHTS_DDD,unit.examined.userright, unit.changed.userright, unit.examined.userright - unit.changed.userright);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_MAILBOXES_DDD,unit.examined.mailbox, unit.changed.mailbox, unit.examined.mailbox - unit.changed.mailbox);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_CONTAINERS_DDD,unit.examined.container, unit.changed.container, unit.examined.container - unit.changed.container);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_DACLS_DDD,part.dacl.examined, part.dacl.changed, part.dacl.examined - part.dacl.changed);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_SACLS_DDD,part.sacl.examined, part.sacl.changed, part.sacl.examined - part.sacl.changed);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_HEADER);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_OWNERS_DDDDD,part.owner.examined, part.owner.changed, part.owner.notarget, part.owner.examined - part.owner.changed - part.owner.notarget - part.owner.unknown, part.owner.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_GROUPS_DDDDD,part.group.examined, part.group.changed, part.group.notarget, part.group.examined - part.group.changed - part.group.notarget - part.group.unknown ,part.group.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_DACES_DDDDD,part.dace.examined, part.dace.changed, part.dace.notarget,part.dace.notselected,part.dace.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_SACES_DDDDD,part.sace.examined, part.sace.changed, part.sace.notarget,part.sace.notselected,part.sace.unknown);
   }

}
#define HDR1ITEMS  2
#define HDRCOL1    8
#define HDRROW1    4
#define COLWIDTH   12
#define HDRCOL2    ( HDRCOL1 + COLWIDTH )
#define HDRROW2    ( HDRROW1 + ( 2 * HDR1ITEMS + 1) + 1)

void 
   TSDResolveStats::InitDisplay(
      BOOL                   nochange        
   )
{
}

// no longer used
void 
   TSDResolveStats::DisplayStatFrame(
      BOOL                   nochange
)
{
   
}
// no longer used 
void TSDResolveStats::DisplayStatItem(SHORT row, SHORT col, DWORD val, BOOL forceUpdate)
{

}

DWORD             dwLastUpdate = 0;

void 
   TSDResolveStats::DisplayPath(LPWSTR str,BOOL forceUpdate)
{
   DWORD                     now = GetTickCount();

   if ( m_pVarSet )
   {
      m_pVarSet->put(GET_BSTR(DCTVS_CurrentPath),str);
      if ( now - dwLastUpdate > 1000 ) 
      {
         ReportToVarSet(m_pVarSet,SUMMARYSTATS);
         dwLastUpdate = GetTickCount();
      }
   }
}
void 
   TSDResolveStats::DisplayBox(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
{
}
   
void 
TSDResolveStats::SetFrameText(WCHAR * msg)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sdrcmn.cpp ===
//#pragma title( "SDRCommon.cpp - SDResolve:  Common routines for sdresolve" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdrCommon.cpp
System      -  Domain Consolidation Toolkit
Author      -  Christy Boles
Created     -  97/07/11
Description -  Command line parsing, help text, and utilities for EADCFILE and EADCEXCH
Updates     -
===============================================================================
*/

#include "stdafx.h"

#include <stdlib.h>
#include <stdio.h>
#include <iostream.h>
#include <fstream.h>
#include <assert.h>
#include <lm.h>
#include <lmwksta.h>
#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "sidcache.hpp"
#include "enumvols.hpp"
#include "ealen.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct                      err;
bool                                  ignoreall;
extern  bool                          enforce;
bool                                  silent;

extern bool ContainsWildcard(WCHAR const * name);

#define MAX_BUFFER_LENGTH             10000

int ColonIndex(TCHAR * str)
{
   if ( ! str )
      return 0;
   int                     i;

   for (i = 0 ; str[i] && str[i] != ':' ; i++)
   ;
   if ( str[i] != ':' )
      i = 0;
 
   return i;
} 


WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   )
{
   int                       i;
   WCHAR                   * machinename = NULL; 
   if (    pathname
        && pathname[0] == L'\\'
        && pathname[1] == L'\\'
      )
   {
      for ( i = 2 ; pathname[i] && pathname[i] != L'\\' ; i++ ) 
      ;
      machinename = new WCHAR[i+2];
      UStrCpy(machinename,pathname,i+1);
      machinename[i] = 0;
   }
   return machinename;
}

   

int EqualSignIndex(char * str)
{
   if ( ! str )
      return 0;
   int                     i;

   for (i = 0 ; str[i] && str[i] != '=' ; i++)
   ;
   if ( str[i] != '=' )
      i = 0;
 
   return i;
} 

BOOL BuiltinRid(DWORD rid)
{
   // returns TRUE if rid is the rid of a builtin account
   
   BOOL                      result;
   // 500 Administrator
   // 501 Guest
   // 512 Domain Admins
   // 513 Domain Users
   // 514 Domain Guests
   // 544 Administrators
   // 545 Users
   // 546 Guests
   // 547 Power Users
   // 548 Account Operators
   // 549 Server Operators
   // 550 Print Operators
   // 551 Backup Operators
   // 552 Replicator 
   if ( rid < 500 )
      return TRUE;

   switch ( rid )
   {
      case DOMAIN_USER_RID_ADMIN:
      case DOMAIN_USER_RID_GUEST:          
      case DOMAIN_ALIAS_RID_ADMINS:        
      case DOMAIN_ALIAS_RID_USERS:         
      case DOMAIN_ALIAS_RID_GUESTS:        
      case DOMAIN_ALIAS_RID_POWER_USERS:   
      case DOMAIN_ALIAS_RID_ACCOUNT_OPS:   
      case DOMAIN_ALIAS_RID_SYSTEM_OPS:    
      case DOMAIN_ALIAS_RID_PRINT_OPS:     
      case DOMAIN_ALIAS_RID_BACKUP_OPS:    
      case DOMAIN_ALIAS_RID_REPLICATOR:
         result = TRUE;
         break;
      default:
         result = FALSE;
   }
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sdstat.hpp ===
//#pragma title ("SDStat.hpp -- Statistical information for SDResolve")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdstat.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Statistical information for SDResolve
Updates     -
===============================================================================
*/

#ifndef SDSTAT_HEADER 
#define SDSTAT_HEADER

#include "stdafx.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#include "ResStr.h"

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif

class TSidCache;
class TSDRidCache;
class TPathList;
class TSecurableObject;
class TAcctNode;

enum objectType { file = 1,directory,share,mailbox,container,groupmember, userright, regkey, printer };


typedef DWORD StatCell ;
struct TSDFileDirCell
{  
   StatCell                  file;
   StatCell                  dir;
   StatCell                  share;
   StatCell                  mailbox;
   StatCell                  container;
   StatCell                  member;
   StatCell                  userright;
   StatCell                  regkey;
   StatCell                  printer;
};
   
struct TSDFileActions
{
   TSDFileDirCell            examined;
   TSDFileDirCell            changed;
   TSDFileDirCell            skipped;
   TSDFileDirCell            error;
   TSDFileDirCell            cachehit;
};
struct TSDPartActions
{
   StatCell                   examined;
   StatCell                   changed;
   StatCell                   notselected;
   StatCell                   unknown;
   StatCell                   notarget;
 
};
struct TSDPartStats
{
   TSDPartActions            owner;
   TSDPartActions            group;
   TSDPartActions            dacl;
   TSDPartActions            sacl;
   TSDPartActions            dace;
   TSDPartActions            sace;
};

#define FILE_ROW         1
#define DIR_ROW          2
#define DACL_ROW         3
#define SACL_ROW         4
#define OWNER_ROW        6
#define GROUP_ROW        7
#define DACE_ROW         8
#define SACE_ROW         9

#define EXAMINED_COL     1
#define CHANGED_COL      2
#define NOTARGET_COL     3
#define NOTSELECTED_COL  4
#define UNKNOWN_COL      5

class TStatNode:public TNode
{
public:
   TAcctNode                * acctnode;
   BOOL                       changed;
   enum ChangeType { owner , group, dace, sace } changetype;
   
   
   TStatNode(TAcctNode * acct, ChangeType type, BOOL bChanged) { acctnode = acct; changetype = type; changed = bChanged; }
};

class TSDResolveStats 
{
protected:

   TSDPartStats              part;
   TSDFileActions            unit;
 
   WORD                      background;                        
   WORD                      frame_foreground;
   WORD                      data_foreground;
   WORD                      message_foreground ;

   TSDRidCache             * pCache;
   const TPathList         * pPList;
   HANDLE                    csbuffer;
   USHORT                    len;
//   CStatsWnd               * wnd;
   IVarSet                 * m_pVarSet;
   
public:
      TSDResolveStats(TSDRidCache * cache, const TPathList * plist, IVarSet * pVarSet);
      TSDResolveStats(TSDRidCache * cache);
   

//   void SetWindow(CStatsWnd *w ) { wnd = w; }
   void IncrementOwnerChange(TAcctNode * acct, objectType type, TSecurableObject *file); 
   void IncrementGroupChange(TAcctNode * acct, objectType type, TSecurableObject *file);
   void IncrementDACEChange (TAcctNode * acct, objectType type, TSecurableObject *file);  
   void IncrementSACEChange (TAcctNode * acct, objectType type, TSecurableObject *file);  
   void IncrementOwnerExamined () { part.owner.examined++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Examined),(LONG)part.owner.examined);} 
   void IncrementGroupExamined () { part.group.examined++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Examined),(LONG)part.group.examined);}
   void IncrementDACLExamined () { part.dacl.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Examined),(LONG)part.dacl.examined);}
   void IncrementSACLExamined () { part.sacl.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Examined),(LONG)part.sacl.examined);}
   void IncrementDACEExamined () { part.dace.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Examined),(LONG)part.dace.examined);}
   void IncrementSACEExamined () { part.sace.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Examined),(LONG)part.sace.examined);}
   
   void IncrementOwnerNoTarget () { part.owner.notarget++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NoTarget),(LONG)part.owner.notarget);}
   void IncrementGroupNoTarget () { part.group.notarget++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NoTarget),(LONG)part.group.notarget);}
   void IncrementDACENoTarget (TSecurableObject *file);
   void IncrementSACENoTarget (TSecurableObject *file);

   void IncrementOwnerNotSelected () { part.owner.notselected++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NotSelected),(LONG)part.owner.notselected);}
   void IncrementGroupNotSelected () { part.group.notselected++; if ( m_pVarSet )  m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NotSelected),(LONG)part.group.notselected);}
   void IncrementDACENotSelected  (TSecurableObject *file);
   void IncrementSACENotSelected  (TSecurableObject *file);

   void IncrementOwnerUnknown () { part.owner.unknown++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Unknown),(LONG)part.owner.unknown);}
   void IncrementGroupUnknown () { part.group.unknown++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Unknown),(LONG)part.group.unknown);}
   void IncrementDACEUnknown (TSecurableObject *file);
   void IncrementSACEUnknown (TSecurableObject *file);


   void IncrementLastFileChanges(const TSecurableObject *lastfile, objectType container);
   void IncrementCacheHit(objectType type) { 
      switch ( type )
      {
      case file:
         unit.cachehit.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_CacheHits),(LONG)unit.cachehit.file); 
            break;
      case directory:
         unit.cachehit.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_CacheHits),(LONG)unit.cachehit.dir);
            break;
      case share:
         unit.cachehit.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_CacheHits),(LONG)unit.cachehit.share);
            break;
      case mailbox:
         unit.cachehit.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_CacheHits),(LONG)unit.cachehit.mailbox);
            break;
      case container:
         unit.cachehit.container++; 
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_CacheHits),(LONG)unit.cachehit.container);
            break;
      case groupmember:
         unit.cachehit.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_CacheHits),(LONG)unit.cachehit.member);
            break;
      case userright:
         unit.cachehit.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_CacheHits),(LONG)unit.cachehit.userright);
         break;
      case regkey:
         unit.cachehit.regkey++;
         // TODO:  if (m_pVarSet ) ...
         break;
      case printer:
         unit.cachehit.printer++;
         // TODO:  if (m_pVarSet ) ...
         break;         
      default:
         MCSASSERT(FALSE); // invalid type
         if ( m_pVarSet ) 
            break;
      }
   }
   void IncrementChanged(objectType type) { 
      switch ( type)
      {
      case file:
         unit.changed.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Changed),(LONG)unit.changed.file);
         break;
      case directory:
         unit.changed.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Changed),(LONG)unit.changed.dir);
            break;
      case share:
         unit.changed.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Changed),(LONG)unit.changed.share);
            break;
      case mailbox:
         unit.changed.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Changed),(LONG)unit.changed.mailbox);
            break;
      case container:
         unit.changed.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Changed),(LONG)unit.changed.container);
            break;
      case groupmember:
         unit.changed.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Changed),(LONG)unit.changed.member);
            break;
      case userright:
         unit.changed.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Changed),(LONG)unit.changed.userright);
            break;
      case regkey:
         unit.changed.regkey++;
         // TODO: if ( m_pVarSet ) ...
         break;
      case printer:
         unit.changed.printer++;
         // TODO: if ( m_pVarSet ) ...
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementExamined(objectType type) { 
      switch ( type)
      {
      case file:
         unit.examined.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Examined),(LONG)unit.examined.file);
         break;
      case directory:
         unit.examined.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Examined),(LONG)unit.examined.dir); 
         break;
      case share:
         unit.examined.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Examined),(LONG)unit.examined.share);
         break;
      case mailbox:
         unit.examined.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Examined),(LONG)unit.examined.mailbox);
         break;
      case container:
         unit.examined.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Examined),(LONG)unit.examined.container);
         break;
      case groupmember:
         unit.examined.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Examined),(LONG)unit.examined.member);
         break;
      case userright:
         unit.examined.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Examined),(LONG)unit.examined.userright);
         break;
      case regkey:
         unit.examined.regkey++;
         //TODO:  if ( m_pVarSet ) m_pVarSet->put(
         break;
      case printer:
         unit.examined.printer++;
         //TODO:  if ( m_pVarSet ) m_pVarSet->put(
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementSkipped(objectType type) { 
      switch ( type)
      {
      case file:
         unit.skipped.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Skipped),(LONG)unit.skipped.file);
         break;
      case directory:
         unit.skipped.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Skipped),(LONG)unit.skipped.dir);
         break;
      case share:
         unit.skipped.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Skipped),(LONG)unit.skipped.share);
         break;
      case mailbox:
         unit.skipped.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Skipped),(LONG)unit.skipped.mailbox);
         break;
      case container:
         unit.skipped.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Skipped),(LONG)unit.skipped.container);
         break;
      case groupmember:
         unit.skipped.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Skipped),(LONG)unit.skipped.member);
         break;
      case userright:
         unit.skipped.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Skipped),(LONG)unit.skipped.userright);
         break;
      case regkey:
         unit.skipped.regkey++;
         // TODO:  if ( m_pVarSet ) ...
         break;
      case printer:
         unit.skipped.printer++;
         // TODO:  if ( m_pVarSet ) ...
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementDACLChanged()   { part.dacl.changed++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Changed),(LONG)part.dacl.changed);} //DisplayStatItem(DACL_ROW,CHANGED_COL,part.dacl.changed); }
   void IncrementSACLChanged()   { part.sacl.changed++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Changed),(LONG)part.sacl.changed);} //DisplayStatItem(SACL_ROW,CHANGED_COL,part.sacl.changed); }
   void Report(BOOL summary,BOOL acct_detail,BOOL pathdetail) const;  
   void InitDisplay(BOOL nochange);
   void DisplayStatFrame(BOOL nochange);
   void DisplayStatItem(SHORT row, SHORT col, DWORD val, BOOL forceRedraw = FALSE);
   void DisplayBox(SHORT x1, SHORT y1, SHORT x2, SHORT y2); 
   void DisplayPath(LPWSTR str,BOOL forceRedraw = FALSE);
   void SetFrameText(WCHAR * msg);

   void ReportToVarSet(IVarSet * pVarSet,DWORD verbnum) const;
  
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sdresolv.cpp ===
//#pragma title( "SDResolve.cpp - SDResolve:  A Domain Migration Utility" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdresolve.cpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/07/11
Description -  Routines to iterate through files, shares, and printers
               when processing security on a machine.    
Updates     -
===============================================================================
*/

#include "stdafx.h"

#include <stdlib.h>
#include <stdio.h>
#include <iostream.h>
#include <fstream.h>
#include <assert.h>

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "sd.hpp"
          
#include "sidcache.hpp"
#include "enumvols.hpp"
#include "SecObj.hpp"
#include "ealen.hpp"
#include "BkupRstr.hpp"
#include "TxtSid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

bool enforce;
extern TErrorDct err;
extern bool silent;
extern bool IsMachineName(const LPWSTR name);
extern bool IsShareName(const LPWSTR name);
extern bool ContainsWildcard( WCHAR const * name);


#define MAX_BUFFER_LENGTH 10000
#define PRINT_BUFFER_SIZE 2000

//******************************************************************************************************
//         Main routine for SDResolve

// Iterates files and directories to be resolved
void
   IteratePath(
      WCHAR                  * path,          // in -path to start iterating from
      SecurityTranslatorArgs * args,          // in -translation settings
      TSDResolveStats        * stats,         // in -stats (to display pathnames & pass to ResolveSD)
      TSecurableObject       * LC,            // in -last container
      TSecurableObject       * LL,            // in -last file
      bool                     haswc          // in -indicates whether path contains a wc character
   )
{
   HANDLE                    hFind;
   WIN32_FIND_DATA           findEntry;              
   BOOL                      b;
   TFileSD                 * currSD;
   bool                      changeLastCont;
   bool                      changeLastLeaf;
   WCHAR                   * appendPath = NULL;
   WCHAR                     safepath[LEN_Path + 10];
   TFileSD                 * LastContain = (TFileSD*) LC;
   TFileSD                 * LastLeaf = (TFileSD*) LL;
   WCHAR                     localPath[LEN_Path];
      // this is the first (for this) dir
   
   safecopy(safepath,path);
   safecopy(localPath,path);
    
   // Check to see if path is longer than MAX_PATH
   // if so, add \\?\ to the beginning of it to 
   // turn off path parsing
   if ( UStrLen(path) >= MAX_PATH && path[2] != L'?' )
   {
      WCHAR                   temp[LEN_Path];

      if ( (path[0] == L'\\') && (path[1] == L'\\') ) // UNC name
      {
         UStrCpy(temp,L"\\\\?\\UNC\\");
      }
      else
      {
         UStrCpy(temp,L"\\\\?\\");
      }
      UStrCpy(temp + UStrLen(temp),path);
      safecopy(localPath,temp);
   }
   appendPath = localPath + UStrLen(localPath);

   if ( *(appendPath-1) == L'\\' )   // if there's already a backslash on the end of the path, don't add another one
      appendPath--;
   if ( ! haswc )
      UStrCpy(appendPath, "\\*.*");
   if ( args->LogVerbose() )
      err.DbgMsgWrite(0,L"Starting IteratePath: %ls",path);
  
   for ( b = ((hFind = FindFirstFile(localPath, &findEntry)) != INVALID_HANDLE_VALUE)
         ; b ; b = FindNextFile(hFind, &findEntry) )
   {
      if ( ! haswc) 
         appendPath[1] = '\0';      // restore path -- remove \*.* append
      if ( ! UStrCmp((LPWSTR)findEntry.cFileName,L".") || ! UStrCmp((LPWSTR)findEntry.cFileName,L"..") )
         continue;                        // ignore names '.' and '..'
      if ( ! haswc )
         UStrCpy(appendPath+1, findEntry.cFileName);
      else
      {
         for ( WCHAR * ch = appendPath-1; ch >= path && *ch != L'\\' ; ch-- )
         ;
         UStrCpy(ch+1,findEntry.cFileName);
      }
      if ( ((TAccountCache *)args->Cache())->IsCancelled() )
      {
        break;
      } 
      currSD = new TFileSD(localPath);
      stats->DisplayPath(localPath);
      if ( !currSD || !currSD->HasSecurity() )
      {
         //err.MsgWrite(0,"Error:  Couldn't get the SD");
      }
      else
      {
         if ( findEntry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) // if dir
         {
            // resolve this container & iterate next container
            changeLastCont = currSD->ResolveSD(args,stats,directory,LastContain);
            if ( changeLastCont )
            {
               if ( LastContain && LastContain != LC )
               {
                  delete LastContain;
               }
               LastContain = currSD;
            }
            else
            {
               delete currSD;
            }
            IteratePath(localPath,args,stats,LastContain,LastLeaf,false);
         }
         else
         {
                       // iterate this file with last 
            changeLastLeaf = currSD->ResolveSD(args,stats,file,LastLeaf); 
            if ( changeLastLeaf )
            {
               if ( LastLeaf && LastLeaf != LL )
               {
                  delete LastLeaf;
               }
               LastLeaf = currSD;
            }
            else
            {
               delete currSD;
            }
         }
      }
   }
   if ( LastContain && LastContain != LC )
   {
      delete LastContain;
   }
   if ( LastLeaf && LastLeaf != LL )
   {
      delete LastLeaf;
   }
   appendPath[0] = '\0';
   DWORD                     rc = GetLastError();

   if ( args->LogVerbose() )
      err.DbgMsgWrite(0,L"Closing IteratePath %S",safepath);
   FindClose(hFind);
   switch ( rc )
   {
      case ERROR_NO_MORE_FILES:
      case 0:
         break;
      default:
         err.SysMsgWrite(ErrE, rc,  DCT_MSG_FIND_FILE_FAILED_SD, path, rc);
   }
   return;
}       

DWORD 
   ResolvePrinter(
      PRINTER_INFO_4         * pPrinter,     // in - printer information
      SecurityTranslatorArgs * args,      // in - translation settings
      TSDResolveStats        * stats      // in - stats
   )
{
   DWORD                    rc = 0;
//   DWORD                    needed = 0;
   
   TPrintSD            sd(pPrinter->pPrinterName);

   if ( sd.GetSecurity() )
   {
      sd.ResolveSD(args,stats,printer,NULL);
   }

   return rc;
}

int 
   ServerResolvePrinters(
      WCHAR          const * server,      // in -translate the printers on this server
      SecurityTranslatorArgs * args,      // in -translation settings
      TSDResolveStats      * stats        // in -stats 
   )
{
   DWORD                     rc = 0;
   PRINTER_INFO_4          * pInfo = NULL;
   BYTE                    * buffer = new BYTE[PRINT_BUFFER_SIZE];
   DWORD                     cbNeeded = PRINT_BUFFER_SIZE;
   DWORD                     nReturned = 0;

   if (!buffer)
      return ERROR_NOT_ENOUGH_MEMORY;

   if (! EnumPrinters(PRINTER_ENUM_LOCAL,NULL,4,buffer,PRINT_BUFFER_SIZE,&cbNeeded,&nReturned) )
   {
      rc = GetLastError();
      if ( rc == ERROR_INSUFFICIENT_BUFFER )
      {
         // try again with a bigger buffer size
         delete buffer;
         buffer = new BYTE[cbNeeded];
         if (!buffer)
            return ERROR_NOT_ENOUGH_MEMORY;
         if (! EnumPrinters(PRINTER_ENUM_LOCAL,NULL,4,buffer,cbNeeded,&cbNeeded,&nReturned) )
         {
            rc = GetLastError();
         }
      }
   }

   if ( ! rc )
   {
      pInfo = (PRINTER_INFO_4 *)buffer;
      for ( DWORD i = 0 ; i < nReturned ; i++ )
      {
         ResolvePrinter(&(pInfo[i]),args,stats);
      }
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_ENUMERATING_LOCAL_PRINTERS_D,rc);
   }

   delete buffer;

   return rc;
}
int 
   ServerResolveShares(
      WCHAR          const * server,      // in -enumerate and translate the shares on this server
      SecurityTranslatorArgs * args,      // in -translation settings
      TSDResolveStats      * stats        // in -stats (to display pathnames & pass to ResolveSD)
   )
{
   DWORD                     rc           = 0;
   DWORD                     numRead      = 0;
   DWORD                     totalEntries = 0;
   DWORD                     resumeHandle = 0;
   SHARE_INFO_0            * bufPtr       = NULL;
   WCHAR                     serverName[LEN_Computer];
   WCHAR                     fullPath[LEN_Path];
   WCHAR                   * pServerName = serverName;
   DWORD                     ttlRead = 0;

   if ( server )
   {
      safecopy(serverName,server);
   }
   else
   {
      pServerName = NULL;

   }
   
   do 
   {
      rc = NetShareEnum(pServerName,0,(LPBYTE *)&bufPtr,MAX_BUFFER_LENGTH,&numRead,&totalEntries,&resumeHandle);   
      
      if ( ! rc || rc == ERROR_MORE_DATA )
      {
         for ( UINT i = 0 ; i < numRead ; i++ )
         {
            // Process the SD   
            if ( pServerName )
            {
               swprintf(fullPath,L"%s\\%s",pServerName,bufPtr[i].shi0_netname);
            }
            else
            {
               swprintf(fullPath,L"%s",bufPtr[i].shi0_netname);
            }
           

            TShareSD             tSD(fullPath);

            if ( tSD.HasSecurity() )
            {   
               stats->DisplayPath(fullPath,TRUE);          
               tSD.ResolveSD(args,stats,share,NULL);
            }
         }
         ttlRead += numRead;
         resumeHandle = ttlRead;
         NetApiBufferFree(bufPtr);
      }
   } while ( rc == ERROR_MORE_DATA && numRead < totalEntries );
   
   if ( rc && rc != ERROR_MORE_DATA )
      err.SysMsgWrite(ErrE,rc,DCT_MSG_SHARE_ENUM_FAILED_SD,server,rc);

   return rc;
}

void 
   ResolveFilePath(
      SecurityTranslatorArgs * args,          // in - translation options
      TSDResolveStats        * Stats,         // in - class to display stats
      WCHAR                  * path,          // in - path name
      bool                     validAlone,    // in - whether this object exists (false for share names and volume roots)
      bool                     containsWC,    // in - true if path contains wildcard
      bool                     iscontainer    // in - whether the starting path is a container
   )
{
   TFileSD                * pSD;
   
   if ( args->LogVerbose() ) 
      err.MsgWrite(0,DCT_MSG_PROCESSING_S,path);
  
   Stats->DisplayPath(path);
   
   if ( validAlone && ! containsWC )
   {
      pSD = new TFileSD(path);
	  if (!pSD)
	     return;
      if ( pSD->HasSecurity() )
         pSD->ResolveSD(args,
                        Stats,
                        iscontainer?directory:file,
                        NULL);
      delete pSD;
   }
   if  ( iscontainer || containsWC )
   {
      IteratePath(path,
                  args,
                  Stats,
                  NULL,
                  NULL,
                  containsWC);
   }
   if ( args->Cache()->IsCancelled() )
   {
      err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
   }
}

void WriteOptions(SecurityTranslatorArgs * args)
{
//*   WCHAR                     cmd[1000] = L"SecurityTranslation ";;
   WCHAR                     cmd[1000];
   WCHAR                     arg[300];

   
   UStrCpy(cmd, GET_STRING(IDS_STOptions_Start));
   
   if ( args->NoChange() )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"WriteChanges:No ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_WriteChng));
   }   
   if ( args->TranslateFiles() )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"Files:Yes ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_Files));
   }
   if ( args->TranslateShares() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"Shares:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Shares));
   }
   if ( args->TranslateLocalGroups() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"LGroups:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_LocalGroup));
   }
   if ( args->TranslateUserRights() )
   {
//      UStrCpy(cmd + UStrLen(cmd),L"UserRights:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_URights));
   }
   if ( args->TranslatePrinters() )
   {
//      UStrCpy(cmd + UStrLen(cmd),L"UserRights:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Printers));
   }
   if ( args->TranslateUserProfiles() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"Profiles:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Profiles));
   }
   if ( args->TranslateRecycler() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"RecycleBin:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_RBin));
   }
   
   if ( *args->LogFile() )
   {
//*      wsprintf(arg,L"LogFile:%S ",args->LogFile());
      wsprintf(arg,GET_STRING(IDS_STOptions_LogName),args->LogFile());
      UStrCpy(cmd +UStrLen(cmd), arg);
   }
   if ( args->TranslationMode() == ADD_SECURITY )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"TranslationMode:Add ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_AddMode));
   }
   else if ( args->TranslationMode() == REMOVE_SECURITY )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"TranslationMode:Remove ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_RemoveMode));
   }
   else 
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"TranslationMode:Replace ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_ReplaceMode));
   }
   wsprintf(arg,L"%s %s ",args->Source(), args->Target());
   UStrCpy(cmd +UStrLen(cmd), arg);

   err.MsgWrite(0,DCT_MSG_GENERIC_S,&*cmd);
}

void 
   TranslateRecycler(
      SecurityTranslatorArgs * args,          // in - translation options
      TSDResolveStats        * Stats,         // in - class to display stats
      WCHAR                  * path           // in - drive name
   )
{
   err.MsgWrite(0,DCT_MSG_PROCESSING_RECYCLER_S,path);
   WCHAR                        folder[LEN_Path];
   WCHAR                const * recycler = L"RECYCLER";
   WCHAR                        strSid[200];
   WCHAR                        srcPath[LEN_Path];
   WCHAR                        tgtPath[LEN_Path];
   DWORD                        lenStrSid = DIM(strSid);
   _wfinddata_t                 fData;
//   long                         hRecycler;
   LONG_PTR                     hRecycler;
   PSID                         pSidSrc = NULL, pSidTgt = NULL;
   TRidNode                   * pNode;
   DWORD                        rc = 0;

   swprintf(folder,L"%s\\%s\\*",path,recycler);

   long                         mode = args->TranslationMode();

   // Windows 2000 checks the SD for the recycle bin when the recycle bin is opened.  If the SD does not match the 
   // default template (permissions for user, admin, and system), Windows displays a message that the recycle bin is corrupt.
   // This change may also be in NT 4 SP 7.  To avoid causing this corrupt recycle bin message, we will always translate the 
   // recycle bins in replace mode.   We will not change if we are doing a remove.
   if (args->TranslationMode() != REMOVE_SECURITY)
      args->SetTranslationMode(REPLACE_SECURITY);
   
   // use _wfind to look for hidden files in the folder
   for ( hRecycler = _wfindfirst(folder,&fData) ; hRecycler != -1 && ( rc == 0 ); rc = (DWORD)_wfindnext(hRecycler,&fData) )
   {
      pSidSrc = SidFromString(fData.name);
      if ( pSidSrc )
      {
         err.MsgWrite(0,DCT_MSG_PROCESSING_RECYCLE_FOLDER_S,fData.name);
		   pNode = (TRidNode*)args->Cache()->Lookup(pSidSrc);
         if ( pNode && pNode != (TRidNode*)-1 )
         {
            pSidTgt = args->Cache()->GetTgtSid(pNode);
            // get the target directory name
            GetTextualSid(pSidTgt,strSid,&lenStrSid);
            if ( args->LogVerbose() )
               err.DbgMsgWrite(0,L"Target sid is: %ls",strSid);
            if ( ! args->NoChange() && args->TranslationMode() != REMOVE_SECURITY )
            {
               // rename the directory
               swprintf(srcPath,L"%s\\%s\\%s",path,recycler,fData.name);
               swprintf(tgtPath,L"%s\\%s\\%s",path,recycler,strSid);
               if ( ! MoveFile(srcPath,tgtPath) )
               {
                  rc = GetLastError();
                  if ( (rc == ERROR_ALREADY_EXISTS) && (args->TranslationMode() == REPLACE_SECURITY) )
                  {
                     // the target recycle bin already exists 
                     // attempt to rename it with a suffix, so we can rename the new bin to the SID
                     WCHAR         tmpPath[LEN_Path];
                     long          ndx = 0;

                     do 
                     {
                        swprintf(tmpPath,L"%ls%ls%ld",tgtPath,GET_STRING(IDS_RenamedRecyclerSuffix),ndx);   
                        if (! MoveFile(tgtPath,tmpPath) )
                        {
                           rc = GetLastError();
                           ndx++;
                        }
                        else
                        {
                           rc = 0;
                           err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,tgtPath,tmpPath);
                        }
                     } while ( rc == ERROR_ALREADY_EXISTS );
                     if ( ! rc )
                     {
                        // we have moved the pre-existing target recycler out of the way
                        // now retry the rename
                        if (! MoveFile(srcPath,tgtPath) )
                        {
                           err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                        }
                        else
                        {
                           err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,srcPath,tgtPath);
                           // run security translation on the new folder
                           ResolveFilePath(args,Stats,tgtPath,TRUE,FALSE,TRUE);      
                        }
                     }
                     else
                     {
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                     }
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,srcPath,tgtPath);
                  // run security translation on the new folder
                  ResolveFilePath(args,Stats,tgtPath,TRUE,FALSE,TRUE);      
               }

            }
            FreeSid(pSidTgt);
         }
         FreeSid(pSidSrc);
      }   
   }
   // set the translation mode back to its original value
   args->SetTranslationMode(mode);
}

// if the specified node is a normal share, this attempts to convert it to a path
// using the administrative shares
void 
   BuildAdminPathForShare(
      TPathNode         * tnode,
      WCHAR             * adminShare
   )
{
   // if all else fails, return the same name as specified in the node
   UStrCpy(adminShare,tnode->GetPathName());

   SHARE_INFO_502       * shInfo = NULL;
   DWORD                  rc = 0;
   WCHAR                  shareName[LEN_Path];
   WCHAR                * slash = NULL;

   UStrCpy(shareName,tnode->GetPathName() + UStrLen(tnode->GetServerName()) +1);
   slash = wcschr(shareName,L'\\');
   if ( slash )
      *slash = 0;


   rc = NetShareGetInfo(tnode->GetServerName(),shareName,502,(LPBYTE*)&shInfo);
   if ( ! rc )
   {
      if ( *shInfo->shi502_path )
      {
         // build the administrative path name for the share
         UStrCpy(adminShare,tnode->GetServerName());
         UStrCpy(adminShare + UStrLen(adminShare),L"\\");
         UStrCpy(adminShare + UStrLen(adminShare),shInfo->shi502_path);
         WCHAR * colon = wcschr(adminShare,L':');
         if ( colon )
         {
            *colon = L'$';
            UStrCpy(adminShare + UStrLen(adminShare),L"\\");
            UStrCpy(adminShare + UStrLen(adminShare),slash+1);

         }
         else
         {
            // something went wrong -- revert to the given path
            UStrCpy(adminShare,tnode->GetPathName());
         }

      }
      NetApiBufferFree(shInfo);
   }
}
                              

// Main routine for resolving file and directory SD's.
int
   ResolveAll(
      SecurityTranslatorArgs * args,            // in- translation settings
      TSDResolveStats        * Stats            // in- counts of examined, changed objects, etc.
   )
{
   WCHAR                   * warg;
   WCHAR                   * machine;
   UINT                      errmode;                 
   int                       retcode = 0;
   TPathNode               * tnode;
   
   errmode = SetErrorMode(SEM_FAILCRITICALERRORS); 
  
   if ( ! retcode )
   {
      WriteOptions(args);
      Stats->InitDisplay(args->NoChange());

      err.MsgWrite(0,DCT_MSG_FST_STARTING);
      
      // Process Files and Directories
      if (! args->IsLocalSystem() )
      {
         TNodeListEnum        tenum;
         for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)args->PathList()) ; tnode ; tnode = (TPathNode *)tenum.Next() )
         {
            DWORD               rc;
            BOOL                needToGetBR = FALSE;
//            BOOL                abort = FALSE;
//            BOOL                firstTime = TRUE;

            warg = tnode->GetPathName();
            machine = GetMachineName(warg);
         
            needToGetBR = ( args->TranslateFiles() );

            if ( *tnode->GetServerName() && ! args->IsLocalSystem() )
            {
               warg = tnode->GetPathName();
               err.MsgWrite(0,DCT_MSG_PROCESSING_S,warg);
               if ( args->TranslateFiles() )
               {
                  if ( needToGetBR )
                  {
                     GetBkupRstrPriv(tnode->GetServerName());
                  }
                  if ( IsMachineName(warg) )
                  {
                     // need to process each drive on this machine
                     TVolumeEnum          vEnum;
      
                     rc = vEnum.Open(warg,VERIFY_PERSISTENT_ACLS,args->LogVerbose());
                     if ( rc ) 
                     {
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_ACCESSING_DRIVES_SD,warg,rc);
                     }
                     else
                     {
                        while ( warg = vEnum.Next() )
                        {
                           ResolveFilePath(args,
                                           Stats,
                                           warg,
                                           false,     // not valid alone
                                           false,     // no wildcard
                                           true );    // container
                        }
                        warg = machine;
                     }
                     vEnum.Close();
                  }
                  else
                  {
                     WCHAR                   adminShare[LEN_Path];
                     
                     // Verify that the volume is NTFS
                     rc = tnode->VerifyPersistentAcls();
                     switch ( rc )
                     {
                     case ERROR_SUCCESS:   
                        // Process the path
                     
                        // if it's a share name, process the root of the share
                        if( IsShareName(tnode->GetPathName()) ) 
                        {
                           WCHAR       sharePath[LEN_Path];
                        
                           swprintf(sharePath,L"%s\\.",tnode->GetPathName());
                           TFileSD     sd(sharePath);
                           if ( sd.HasSecurity() )
                           {  
                              sd.ResolveSD(args,
                                             Stats,
                                             directory,
                                             NULL);
                           }
                        }
                        // if this is a normal share, convert it to an administrative share 
                        // path, so that we can take advantage of backup/restore privileges
                        BuildAdminPathForShare(tnode,adminShare);
                        ResolveFilePath(args,
                                        Stats,
                                        adminShare,
                                        !IsShareName(tnode->GetPathName()),
                                        ContainsWildcard(tnode->GetPathName()),
                                        tnode->IsContainer() || IsShareName(tnode->GetPathName()));
                        break;
                     case ERROR_NO_SECURITY_ON_OBJECT:
                        err.MsgWrite(ErrW,DCT_MSG_SKIPPING_FAT_VOLUME_S,warg);
                        break;
                     default:
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_SKIPPING_PATH_SD,warg,rc );
                        break;
                     }
                  }         
               }
               // Process the shares for this machine
               if ( args->TranslateShares() )
               {
                  if ( IsMachineName(warg) )
                  {
                     err.MsgWrite(0,DCT_MSG_PROCESSING_SHARES_S,tnode->GetServerName());
                     ServerResolveShares(tnode->GetServerName(),args,Stats);
                  }
                  else if  ( IsShareName(warg) )
                  {
                     TShareSD      sd(warg);
         
                     if ( sd.HasSecurity() )
                     {
                        if ( args->LogVerbose() )
                        {
                           err.MsgWrite(0,DCT_MSG_PROCESSING_SHARE_S,warg);
                        }
                        sd.ResolveSD(args,
                                    Stats,
                                    share,
                                    NULL);
                     }
                  }
               }
            }
            else 
            {
               // this is a local path
               // Verify that the volume is NTFS
               DWORD            rc2;
         
               GetBkupRstrPriv((WCHAR*)NULL);
               
               rc2 = tnode->VerifyPersistentAcls();
               switch ( rc2 )
               {
               case ERROR_SUCCESS:   
                  // Process the path
                  if ( args->TranslateFiles() )
                  {
                     ResolveFilePath(args,
                                  Stats,
                                  tnode->GetPathName(),
                                  true,      // isValidAlone
                                  ContainsWildcard(tnode->GetPathName()),
                                  tnode->IsContainer() );
                  }
                  break;
               case ERROR_NO_SECURITY_ON_OBJECT:
                  err.MsgWrite(ErrW,DCT_MSG_SKIPPING_FAT_VOLUME_S,warg);
                  break;
               default:
                  err.SysMsgWrite(ErrE,rc2,DCT_MSG_SKIPPING_PATH_SD,warg,rc2 );
                  break;
               }
      
            }
            if ( machine ) 
            {
               delete machine;
               machine = NULL;
            }
         }
         tenum.Close();
      }
      else
      {
         // Translate the entire machine
         err.MsgWrite(0,DCT_MSG_LOCAL_TRANSLATION);
         if ( args->TranslateFiles() || args->TranslateRecycler() )
         {
            GetBkupRstrPriv((WCHAR const*)NULL);
            // need to process each drive on this machine
            TVolumeEnum          vEnum;

            vEnum.SetLocalMode(TRUE);

            DWORD rc2 = vEnum.Open(NULL,VERIFY_PERSISTENT_ACLS,args->LogVerbose());
            if ( rc2 ) 
            {
               err.SysMsgWrite(ErrE,rc2,DCT_MSG_ERROR_ACCESSING_LOCAL_DRIVES_D,rc2);
            }
            else
            {
               while ( warg = vEnum.Next() )
               {
                  err.MsgWrite(0,DCT_MSG_PROCESSING_S,warg);
                  
                  if ( args->TranslateFiles() )
                  {
                     ResolveFilePath(args,
                                  Stats,
                                  warg,
                                  false,     // not valid alone
                                  false,     // no wildcard
                                  true );    // container
                  }
                  if ( args->TranslateRecycler() )
                  {
                     TranslateRecycler(args,Stats,warg);
                  }
               }
               warg = NULL;
            }
            vEnum.Close();
         }
         if ( args->TranslateShares() )
         {
            err.MsgWrite(0,DCT_MSG_PROCESSING_LOCAL_SHARES,NULL);
            ServerResolveShares(NULL,args,Stats);
         }
         if ( args->TranslatePrinters() )
         {
            err.MsgWrite(0,DCT_MSG_PROCESSING_LOCAL_PRINTERS,NULL);
            ServerResolvePrinters(NULL,args,Stats);
         }
      }
      Stats->DisplayPath(L"");
   } // end if ( ! retcode)

   SetErrorMode(errmode);
   
   return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sidflags.h ===
/*---------------------------------------------------------------------------
  File: SidFlags.h

  Comments: Flags that are used by access checker to return from the
            CanAddSidHistory function.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Created : 9/24/1999 Sham Chauthani
  ---------------------------------------------------------------------------
*/

#ifndef SIDFLAG_H
#define SIDFLAG_H

#define  F_WORKS                    0x00000000
#define  F_WRONGOS                  0x00000001
#define  F_NO_REG_KEY               0x00000002
#define  F_NO_AUDITING_SOURCE       0x00000004
#define  F_NO_AUDITING_TARGET       0x00000008
#define  F_NO_LOCAL_GROUP           0x00000010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sectrans.cpp ===
/*Copyright (c) 1995-1999, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecTranslator.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  97/06/27
Description -  COM object that controls the security translation process.
               Reads the settings for the translation and performs the necessary
               operations.  

Updates     -
===============================================================================
*/
// SecTranslator.cpp : Implementation of CSecTranslator
#include "stdafx.h"
#include "WorkObj.h"
#include "SecTrans.h"

#include "Mcs.h"     
#include "EaLen.hpp"     
#include "BkupRstr.hpp"
#include "exchange.hpp"            
#include "ErrDct.hpp"

#include "MapiProf.hpp"       

#include "SDStat.hpp" 
#include "sd.hpp"
#include "SecObj.hpp"
#include "LGTrans.h"
#include "RightsTr.h"
#include "RegTrans.h"
#include "RebootU.h"
#include "TReg.hpp"
#include "TxtSid.h"

#include "LSAUtils.h"
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids
#include "varset_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifndef IStatusObjPtr
_COM_SMARTPTR_TYPEDEF(IStatusObj, __uuidof(IStatusObj));
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecTranslator

#define BACKUP_FAILED   5
#define BAD_PATH        6
#define BAD_LOG         2
#define LEN_SID         200

extern TErrorDct   err;

// Defined in EnumVols.cpp
bool                                   // ret -true if name begins with "\\" has at least 3 total chars, and no other '\'
   IsMachineName(
      const LPWSTR           name      // in -possible machine name to check
   );

DWORD                                      // ret- OS return code
   GetProgramFilesDirectory(
      WCHAR                * directory,    // out- location of program files directory
      WCHAR          const * computer      // in - computer to find PF directory on
   )
{
   TRegKey                   hklm;
   TRegKey                   key;
   DWORD                     rc;

   rc = hklm.Connect(HKEY_LOCAL_MACHINE,computer);
   if ( ! rc )
   {
      rc = key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion",&hklm);
   }
   if ( !rc )
   {
      rc = key.ValueGetStr(L"ProgramFilesDir",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}


BOOL 
   IsLocallyInstalled()
{
   BOOL                      bFound;
   TRegKey                   key;
   DWORD                     rc;


   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key));
   if ( ! rc )
   {
      bFound = TRUE;
   }
   else
   {
      bFound = FALSE;
   }
   return bFound;
}


DWORD                                      // ret- OS return code
   GetLocalMachineName(WCHAR * computer)
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * buf = NULL;

   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&buf);
   if ( ! rc )
   {
      UStrCpy(computer,L"\\\\");
      UStrCpy(computer+2,buf->wki100_computername);
      NetApiBufferFree(buf);
   }
   return rc;
}

BOOL 
   IsThisDispatcherMachine(IVarSet * pVarSet)
{
   BOOL                     bIsIt = FALSE;
   _bstr_t                  dispatcher = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Server));
   WCHAR                    localComputer[LEN_Computer] = L"";
   
   GetLocalMachineName(localComputer);

   if ( ! UStrICmp(dispatcher,localComputer) )
   {
      bIsIt = TRUE;
   }
   return bIsIt;
}

class TSession : public TNode
{
   WCHAR                     server[LEN_Computer];
public:
   TSession(WCHAR const * s) { safecopy(server,s); }
   WCHAR             const * ServerName() { return server;} 
};


BOOL 
   CSecTranslator::EstablishASession(
      WCHAR          const * serverName   // in - computer to establish a session to
   )
{
   BOOL                      bSuccess = TRUE;
   TSession                * pSession = new TSession(serverName);

   if ( EstablishSession(serverName,m_domain,m_username,m_password,TRUE) )
   {
      m_ConnectionList.InsertBottom(pSession);
   }
   else
   {
	  delete pSession;
      bSuccess = FALSE;
      err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_NO_SESSION_SD,serverName,GetLastError());
   }
   return bSuccess;
}

void 
   CSecTranslator::CleanupSessions()
{
   TNodeListEnum             e;
   TSession                * s;
   TSession                * snext;

   for ( s = (TSession*)e.OpenFirst(&m_ConnectionList) ; s ; s = snext )
   {
      snext = (TSession*) e.Next();
      m_ConnectionList.Remove(s);
      // close the session
      EstablishSession(s->ServerName(),NULL,NULL,NULL,FALSE);
      delete s;
   }
   e.Close();


}

STDMETHODIMP 
   CSecTranslator::Process(
      IUnknown             * pWorkItem     // in - varset describing translation options
   )
{
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSet = pWorkItem;
   IStatusObjPtr             pStatus = pVarSet->get(GET_BSTR(DCTVS_StatusObject));
   BOOL                      bReallyDoEverything = FALSE; // this (though not implemented yet) can be used
                                                          // to provide a way to override the default behavior 
                                                          // of only processing file, etc. security when running as 
                                                          // local system.  This would allow selective translation of items
                                                          // on the local machine
   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   
   m_Args.LogFile(text);

   
   // Open the log file
   // use append mode since other processes may also be using this file
   if ( ! err.LogOpen(m_Args.LogFile(),1 /*append*/,0) )
   {
      return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
   }

   
   LoadSettingsFromVarSet(pVarSet);

   // Set up the cache
   TSDResolveStats     stat(m_Args.Cache(),m_Args.PathList(),pVarSet);

   if ( pStatus )
   {   
      m_Args.Cache()->SetStatusObject(pStatus);
   }

   if ( m_Args.Cache()->IsTree() )
   {
      m_Args.Cache()->ToSorted();
   }
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&RidComp);
   m_Args.Cache()->Balance();
   m_Args.Cache()->UnCancel();
   
   // Verify that the Cache got the source and target domain information it needs
   if ( ! m_Args.Cache()->IsInitialized() )
   {
      err.MsgWrite(ErrS,DCT_MSG_NO_CACHE_INFO);
   }
   else
//   if (1)
   {
      
      if ( m_Args.IsLocalSystem() || bReallyDoEverything ) 
      {// Do the required translations
         if ( m_Args.TranslateFiles() || m_Args.TranslateShares() || m_Args.TranslatePrinters() || m_Args.TranslateRecycler() )
         {
            // This runs the old FST code
            pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_FST_OPERATION_TEXT));
            DoResolution(&stat);
         }

         if ( m_Args.TranslateLocalGroups() )
         {
            pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_LGST_OPERATION_TEXT));
            DoLocalGroupResolution(&stat);
         }

         if ( m_Args.TranslateUserRights() )
         {
            pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_URST_OPERATION_TEXT));
            DoUserRightsTranslation(&stat);
         }

         if ( m_Args.TranslateRegistry() )
         {
            pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_REGST_OPERATION_TEXT));
            GetBkupRstrPriv((WCHAR*)NULL);
       	   GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
            TranslateRegistry(NULL,&m_Args,m_Args.Cache(),&stat);
         }
         if ( m_Args.TranslateUserProfiles() )
         {
            GetBkupRstrPriv((WCHAR*)NULL);
            GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
            TranslateLocalProfiles(&m_Args,m_Args.Cache(),&stat);
         }
      }
      else
      {
         // do exchange translation

         if ( m_Args.TranslateMailboxes() ||  m_Args.TranslateContainers() )
         {
            // This will run the old EST code
            pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_EST_OPERATION_TEXT));
            DoExchangeResolution(&stat,pVarSet);
         }
      }
   }
   pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),"");
      
   ExportStatsToVarSet(pVarSet,&stat);

   if ( *m_CacheFile )
   {
      BuildCacheFile(m_CacheFile);
   }

   // Record whether errors occurred
   long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
   if ( level < err.GetMaxSeverityLevel() )
   {
      pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
   }
             
   err.LogClose();
   CleanupSessions();
   return hr;
}


void 
   CSecTranslator::LoadSettingsFromVarSet(
      IVarSet              * pVarSet      // in - varset containing settings
   )
{
   MCSASSERT(pVarSet);
   
   _bstr_t                   text;
   _bstr_t                   text2;
   
   DWORD                     val;

   try 
   {
      m_Args.Reset();

      text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         err.MsgWrite(0,DCT_MSG_LOCAL_MODE);
         m_LocalOnly = TRUE;
         m_Args.SetLocalMode(TRUE);
         text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainSid));
         safecopy(m_SourceSid,(WCHAR const *)text);
         text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainSid));
         safecopy(m_TargetSid,(WCHAR const *)text);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
      m_Args.Source(text);

      text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
      m_Args.Target(text);

      val = (LONG)pVarSet->get(GET_BSTR(DCTVS_Options_LogLevel));
      if ( val )
         m_Args.SetLogging(val);
   
      val = (LONG)pVarSet->get(L"Security.DebugLogLevel");
      if ( val )
         m_Args.SetLogging(val);

      text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.SetWriteChanges(FALSE);
      }
      else
      {
         m_Args.SetWriteChanges(TRUE);
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));

      if ( !UStrICmp(text,GET_STRING(IDS_Add)) )
      {
         m_Args.SetTranslationMode(ADD_SECURITY);
      }
      else if (! UStrICmp(text,GET_STRING(IDS_Replace)) )
      {
         m_Args.SetTranslationMode(REPLACE_SECURITY);
      }
      else if ( ! UStrICmp(text,GET_STRING(IDS_Remove)) )
      {
         m_Args.SetTranslationMode(REMOVE_SECURITY);
      }
      else
      {
         // Incorrect value - don't need to log this, just use replace
         // the log will show replace as the translation mode
         // err.MsgWrite(ErrE,DCT_MSG_BAD_TRANSLATION_MODE_S,(WCHAR*)text);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateFiles(TRUE);
      }
      else
      {
         m_Args.TranslateFiles(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateShares(TRUE);
      }
      else
      {
         m_Args.TranslateShares(FALSE);
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslatePrinters(TRUE);
      }
      else
      {
         m_Args.TranslatePrinters(FALSE);  
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateUserProfiles(TRUE);
         m_Args.TranslateRecycler(TRUE);
      }
      else
      {
         m_Args.TranslateUserProfiles(FALSE); 
         m_Args.TranslateRecycler(FALSE);
      }
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateLocalGroups(TRUE);
      }
      else
      {
         m_Args.TranslateLocalGroups(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if (! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateRegistry(TRUE);
      }
      else
      {
         m_Args.TranslateRegistry(FALSE);
      }

      val = (LONG)pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
      for ( int i = 0 ; i < (int)val ; i++ )
      {
         WCHAR                  key[MAX_PATH];
         DWORD                  flags = 0;
         _bstr_t                bStr;

         swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);

         bStr = key;

         text = pVarSet->get(bStr);
         if ( text.length() )
         {
            m_Args.PathList()->AddPath(text,flags);
         }
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_GatherInformation));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.Cache()->AddIfNotFound(TRUE);
         m_Args.SetWriteChanges(FALSE);
         m_Args.SetLogging(m_Args.LogSettings() & ~FILESTATS);
      }
      else
      {
         m_Args.Cache()->AddIfNotFound(FALSE);
      }

      // Exchange Security Translation settings
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateMailboxes));
      if ( text.length() )
      {
         m_Args.TranslateMailboxes(TRUE);
         safecopy(m_Container,(WCHAR*)text);

         text = pVarSet->get(GET_BSTR(DCTVS_Security_MapiProfile));
         safecopy(m_Profile,(WCHAR*)text);

      }
      else
      {
         m_Args.TranslateMailboxes(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));
      if ( text.length() )
      {
         m_Args.TranslateContainers(TRUE);
         if ( ((WCHAR*)text)[0] == L'\\' && ((WCHAR*)text)[1] == L'\\' )
            safecopy(m_exchServer,(WCHAR*)text+2);
         else
            safecopy(m_exchServer,(WCHAR*)text);
      }
      else
      {
         m_Args.TranslateContainers(FALSE);
      }
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateUserRights(TRUE);
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      if ( text.length() )
      {
         safecopy(m_CacheFile,(WCHAR*)text);
      }
      // Check for inconsistent arguments
      
      // Load the cache
      // There are 4 possible ways to populate the cache
      // 1.  Use the list from the migrated objects table in our database
      // 2.  We are given a list of accounts in the VarSet, under "Accounts.".  This allows for renaming, but requires the most space
      // 3.  We are given an input file that was generated by AR, in "Accounts.InputFile".  This also allows for renaming, with less overall memory use.
	  // 4.  We are given a sid mapping, comma-seperated, file with source and target sids.
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      text2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
         //if list is in the migrated objects table
      if ((!m_LocalOnly) && (!UStrICmp(text2,GET_STRING(IDS_YES)))) 
      {
         LoadMigratedObjects(pVarSet);
      }
	     //else if a sid mapping file is being used
      else if ((!m_LocalOnly) && (UStrICmp(text2,GET_STRING(IDS_YES)))) 
      {
         m_Args.SetUsingMapFile(TRUE); //set the arg flag to indicate use of map file
         text2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile));
         LoadCacheFromMapFile(text2, pVarSet);
      }
      //  took out the not because gather information sets this to false.
      //else if ( !m_Args.Cache()->AddIfNotFound() ) // skip loading the cache if we're gathering information
      else if ( m_Args.Cache()->AddIfNotFound() ) // skip loading the cache if we're gathering information
      {
         if ( m_LocalOnly )
         {
            m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
         }
         else
         {
            m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
         }
      }
      else
      {
         text = pVarSet->get(GET_BSTR(DCTVS_Accounts_InputFile));
         if ( text.length() )
         {
            LoadCacheFromFile(text,pVarSet);
         }
         else
         {
            LoadCacheFromVarSet(pVarSet);
         }
      }
   }
   catch ( ... )
   {
      err.MsgWrite(ErrS,DCT_MSG_EXCEPTION_READING_VARSET);
      throw;
   }
}
 
void 
   CSecTranslator::ExportStatsToVarSet(
      IVarSet              * pVarSet,        // in - varset to write stats to
      TSDResolveStats      * stat            // in - object containing stats
   )
{
   _bstr_t                   filename;
   _bstr_t                   domain = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Domain));
   _bstr_t                   username = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_UserName));
   _bstr_t                   password = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Password));
   _bstr_t                   server = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Server));
   _bstr_t                   share = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Share));
   BOOL                      bSessEstablished;

   if ( username.length() && server.length() && share.length() )
   {
      bSessEstablished = EstablishSession(server, domain, username, password, TRUE);
   }
   filename = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));

   stat->Report(m_Args.LogSummary(),m_Args.LogAccountDetails(),m_Args.LogPathDetails());
   
   if ( m_Args.NoChange() )
   {
      err.MsgWrite(0,DCT_MSG_NO_CHANGE_MODE);
   }
   
   stat->ReportToVarSet(pVarSet,m_Args.LogSettings() & SUMMARYSTATS);
   
   if ( filename.length() )
   {
      err.MsgWrite(0,DCT_MSG_EXPORTING_ACCOUNT_REFS_S,(WCHAR*)filename);
      m_Args.Cache()->ReportAccountReferences((WCHAR*)filename);
   }

   // if session was established, unestablish

   if (bSessEstablished)
   {
      EstablishSession(server, domain, username, password, FALSE);
   }

   long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
   if ( level < err.GetMaxSeverityLevel() )
   {
      pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
   }
}

void 
   CSecTranslator::DoResolution(
      TSDResolveStats      * stat         // in - object to write translation stats to
   )
{
   // display confirmation message if writing changes 
   int                       result;
  
   result = ResolveAll(&m_Args,stat);
}

void 
   CSecTranslator::DoLocalGroupResolution(
      TSDResolveStats      * stat         // in - object to write translation stats to
  )
{
   DWORD                     rc;
   TNodeListEnum             tenum;
   TPathNode               * tnode;

   
   if ( m_LocalOnly )
   {
      err.MsgWrite(0,DCT_MSG_TRANSLATING_LOCAL_GROUPS);
      rc = TranslateLocalGroups(NULL,&m_Args,m_Args.Cache(),stat);
   }
   else
   {   // Enumerate the machines in the pathlist
      for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)m_Args.PathList()) 
         ; tnode 
         ; tnode = (TPathNode *)tenum.Next() )
      {
         if ( IsMachineName(tnode->GetPathName()) )
         {
            err.MsgWrite(0,DCT_MSG_TRANSLATING_LOCAL_GROUPS_ON_S,tnode->GetPathName());
            rc = TranslateLocalGroups(tnode->GetPathName(),&m_Args,m_Args.Cache(),stat);
         }
      }
   }
   tenum.Close();
}              

void 
   CSecTranslator::DoUserRightsTranslation(
      TSDResolveStats      * stat         // in - object to write stats to
  )
{
   DWORD                     rc;
   TNodeListEnum             tenum;
   TPathNode               * tnode;

   
   if ( m_LocalOnly )
   {
      err.MsgWrite(0,DCT_MSG_TRANSLATING_USER_RIGHTS);
      rc = TranslateUserRights(NULL,&m_Args,m_Args.Cache(),stat);
   }
   else
   {   // Enumerate the machines in the pathlist
      for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)m_Args.PathList()) 
         ; tnode 
         ; tnode = (TPathNode *)tenum.Next() )
      {
         if ( IsMachineName(tnode->GetPathName()) )
         {
            err.MsgWrite(0,DCT_MSG_TRANSLATING_RIGHTS_ON_S,tnode->GetPathName());
            rc = TranslateUserRights(tnode->GetPathName(),&m_Args,m_Args.Cache(),stat);
         }
      }
   }
   tenum.Close();
}


BOOL 
   CSecTranslator::LoadCacheFromVarSet(
      IVarSet              * pVarSet      // in - varset containing account mapping
   )
{
   BOOL                      bSuccess = TRUE;
   _bstr_t                   text;

   if ( m_LocalOnly )
   {
      m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
   }
   else
   {
      m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
   }
   m_Args.Cache()->ToSorted();
   // no wildcard filter specified.  Use the explicit list of accounts
   long numAccounts = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   for ( int i = 0 ; i < numAccounts ; i++ )
   {
      WCHAR                  key[LEN_Path];
      WCHAR                  name[LEN_Account];
      WCHAR                  targetName[LEN_Account];
      WCHAR                  type[LEN_Path];
      short                  sType;

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
      text = pVarSet->get(key);
      safecopy(name,(WCHAR*)text);

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
      text = pVarSet->get(key);
      safecopy(targetName,(WCHAR*)text);

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_Type_D),i);
      text = pVarSet->get(key);
      safecopy(type,(WCHAR*)text);


      if (! UStrICmp(type,L"user") )
         sType = EA_AccountUser;
      else if (! UStrICmp(type,L"group") )
         sType = EA_AccountGroup;
      else
         sType = 0;
      m_Args.Cache()->InsertLast(name,0,targetName,0,sType);
   }
   
   if ( bSuccess && ! m_LocalOnly )
   {
      bSuccess = GetRIDsFromEA();
   }
   
   return bSuccess;
}



HRESULT CSecTranslator::LoadMigratedObjects(IVarSet * pVarSetIn)
{
   HRESULT                   hr = S_OK;

   // this reads the migrated objects table from the database, and 
   // constructs a mapping file to be used for security translation
   IIManageDBPtr             pDB;
   IUnknown                * pUnk = NULL;
   IVarSetPtr                pVarSet(CLSID_VarSet);
   WCHAR                     strKey[MAX_PATH];
   long                      ndx = 0;
   _bstr_t                   srcSam = L"?";
   _bstr_t                   tgtSam = L"?";
   _bstr_t                   type;
   _bstr_t                   srcDom;
   _bstr_t                   tgtDom;
//   FILE                    * pFile = NULL;

//   BOOL                      bSuccess = TRUE;
   UCHAR                     srcEaServer[LEN_Computer];
   UCHAR                     tgtEaServer[LEN_Computer];
   _bstr_t                   text;

   safecopy(srcEaServer,m_Args.Source());
   safecopy(tgtEaServer,m_Args.Target());

   if ( m_LocalOnly )
   {
      m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
   }
   else
   {
      m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
   }
   m_Args.Cache()->ToSorted();
   
   hr = pDB.CreateInstance(CLSID_IManageDB);

   if  ( SUCCEEDED(hr) )
   {
      hr = pVarSet->QueryInterface(IID_IUnknown,(void**)&pUnk);
      if ( SUCCEEDED(hr) )
      {
         hr = pDB->raw_GetMigratedObjects(-1,&pUnk);
      }
      if ( SUCCEEDED(hr) )
      {
         pVarSet = pUnk;
         pUnk->Release();
         short sType;
         long rid = 0;
         long rid2 = 0;
         // GetMigratedObjects returns the migrated objects in the varset as:
         // MigratedObjects.%ld.*
         for ( ndx = 0 ;srcSam.length() && tgtSam.length() ; ndx++ )
         {
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceDomain));
            srcDom = pVarSet->get(strKey);
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetDomain));
            tgtDom = pVarSet->get(strKey);

            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceSamName));
            srcSam = pVarSet->get(strKey);
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetSamName));
            tgtSam = pVarSet->get(strKey);
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_Type));
            type = pVarSet->get(strKey);
            
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_SourceRid));
            rid = pVarSet->get(strKey);
            
            swprintf(strKey,L"MigratedObjects.%ld.%s",ndx,GET_STRING(DB_TargetRid));
            rid2 = pVarSet->get(strKey);
            
            if ( !UStrICmp(srcDom, m_Args.Source()) && !UStrICmp(tgtDom, m_Args.Target()) )
            {
               if ( !UStrICmp(type,L"user") || !UStrICmp(type,L"group") )
               {
                  if (! UStrICmp(type,L"user") )
                     sType = EA_AccountUser;
                  else if (! UStrICmp(type,L"group") )
                     sType = EA_AccountGroup;
                  else
                     sType = 0;
                  m_Args.Cache()->InsertLast((WCHAR*)srcSam,rid,(WCHAR*)tgtSam,rid2,sType);   
               }
            }
         }
      }
   }
/*   if ( SUCCEEDED(hr) )
   {
      GetRIDsFromEA();
   }
*/   return hr;
}

BOOL 
   CSecTranslator::BuildCacheFile(
      WCHAR          const * filename        // in - file to write account mapping to
   )
{
   BOOL                      bSuccess = TRUE;
   FILE                    * pFile;
   
   m_Args.Cache()->ToSorted();

   TNodeListEnum             e;
   TRidNode                * node;
   WCHAR                     type[LEN_Path];


   pFile = _wfopen(filename,L"wb");
   
   if ( pFile )
   {
      for ( node = (TRidNode*) e.OpenFirst(m_Args.Cache() ); node ; node = (TRidNode*)e.Next() )
      {
      
         switch ( node->Type() )
         {
         case EA_AccountUser:
            safecopy(type,L"user");
            break;
         case EA_AccountGroup:
         case EA_AccountGGroup:
         case EA_AccountLGroup:
            safecopy(type,L"group");
            break;
        default:
            type[0] = 0;
            break;
         }

//         if (!UStrICmp(node->GetAcctName(),node->GetTargetAcctName()))
         if ((UStrICmp(node->GetSrcDomSid(),L"")) && (UStrICmp(node->GetTgtDomSid(),L"")))
         {
		       //account and domain names could be empty when using a sid
		       //mapping file for security translation.  A later scanf by
		       //the agent will fail on a NULL name, so we will store "(UnKnown)"
		       //instead and deal with that on the scanf-side
		    WCHAR ssname[MAX_PATH];
			wcscpy(ssname, node->GetAcctName());
		    if (!wcslen(ssname))
		       wcscpy(ssname, GET_STRING(IDS_UnknownSid));
		    WCHAR stname[MAX_PATH];
			wcscpy(stname, node->GetTargetAcctName());
		    if (!wcslen(stname))
		       wcscpy(stname, GET_STRING(IDS_UnknownSid));
		    WCHAR ssdname[MAX_PATH];
			wcscpy(ssdname, node->GetSrcDomName());
		    if (!wcslen(ssdname))
		       wcscpy(ssdname, GET_STRING(IDS_UnknownSid));
		    WCHAR stdname[MAX_PATH];
			wcscpy(stdname, node->GetTgtDomName());
		    if (!wcslen(stdname))
		       wcscpy(stdname, GET_STRING(IDS_UnknownSid));
         
            fwprintf(pFile,L"%s\t%s\t%s\t%lx\t%lx\t%lx\t%s\t%s\t%s\t%s\r\n",ssname,stname,type,
                                                   0, node->SrcRid(), node->TgtRid(), node->GetSrcDomSid(), node->GetTgtDomSid(), 
												   ssdname, stdname);
         }
         else
         {
            fwprintf(pFile,L"%s\t%s\t%s\t%lx\t%lx\t%lx\r\n",node->GetAcctName(),node->GetTargetAcctName(),type,
                                                   0, node->SrcRid(), node->TgtRid());
         }
      }
      e.Close();
      fclose(pFile);
   }
   else
   {
      bSuccess = FALSE;
//      DWORD rc = GetLastError();
   }
   return bSuccess;
}
BOOL 
   CSecTranslator::LoadCacheFromFile(
      WCHAR          const * filename,       // in - file to read account mapping from
      IVarSet              * pVarSet         // in - pointer to varset
   )
{
   BOOL                      bSuccess = TRUE;
   _bstr_t                   text;
   FILE                    * pFile;
   WCHAR                     sourceName[LEN_Account];
   WCHAR                     targetName[LEN_Account];
   WCHAR                     sourceDomSid[MAX_PATH];
   WCHAR                     targetDomSid[MAX_PATH];
   WCHAR                     sourceDomName[MAX_PATH];
   WCHAR                     targetDomName[MAX_PATH];
   WCHAR                     type[LEN_Account];
   DWORD                     status;
   int                       count = 0;
   BOOL                      bNeedRids = FALSE;
   WCHAR                     path[MAX_PATH];
   WCHAR                     temp[MAX_PATH];
   BOOL						 bUseMapFile = FALSE;
   
   if ( m_LocalOnly )
   {
      m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
      
      // find the module path
      DWORD          rc = GetModuleFileName(NULL,temp,DIM(temp));
      if ( rc )
      {
         // Generally, our DCTCache file will be in the same directory as our EXE.
         // This is true 1) when agent is dispatched to clean machine (all will be in OnePointDomainAgent directory)
         // and also 2) when agent is dispatched to the local ADMT machine (all will be in Program Files\ADMT directory)
         // The exception is when the agent is dispatched to a remote machine where ADMT is also installed.
         WCHAR * slash = wcsrchr(temp,L'\\');
         UStrCpy(slash+1,filename);
         // Check whether ADMT is locally installed here
         if ( IsLocallyInstalled() && !IsThisDispatcherMachine(pVarSet) )
         {
            // ADMT is installed here, so we're running from the binaries
            // in the Program files\ADMT directory
            // However, our cache file should be in %Program Files%\\OnePOintDomainAgent
            GetProgramFilesDirectory(temp,NULL);
            UStrCpy(temp+UStrLen(temp),L"\\OnePointDomainAgent\\");
            UStrCpy(temp+UStrLen(temp),filename);
         }
      }
      else
      {
         rc = GetLastError();
         err.DbgMsgWrite(0,L"Couldn't get the module filename, rc=%ld",rc);
         swprintf(temp,L"..\\OnePointDomainAgent\\%ls",filename);
      }
      _wfullpath(path,temp,MAX_PATH);
   }
   else
   {
      m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
      _wfullpath(path,filename,MAX_PATH);
   }
   m_Args.Cache()->ToSorted();
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
   if (UStrICmp(text,GET_STRING(IDS_YES)))
   {
      m_Args.SetUsingMapFile(TRUE); //set the arg flag to indicate use of map file
      bUseMapFile = TRUE;
   }
   
   // The input file should have the format:
   // SourceName, TargetName, Type, Status [,rid1, rid2]
   
   pFile = _wfopen(path,L"rb");
   if ( pFile )
   {
      int result;
      do 
      {
         DWORD rid1 = 0;
         DWORD rid2 = 0;
         if (!bUseMapFile)
		 {
            result = fwscanf(pFile,L"%[^\t]\t%[^\t]\t%[^\t]\t%lx\t%lx\t%lx\r\n",
			                 sourceName,targetName,type,&status,&rid1,&rid2);

            if ( result < 4 )
               break;
		 }
		 else
		 {
            result = fwscanf(pFile,L"%[^\t]\t%[^\t]\t%[^\t]\t%lx\t%lx\t%lx\t%[^\t]\t%[^\t]\t%[^\t]\t%[^\r]\r\n",
			                 sourceName,targetName,type,&status,&rid1,&rid2,sourceDomSid,targetDomSid,
						     sourceDomName, targetDomName);

            if ( result < 8 )
               break;
		 }

         
         short lType = 0;
         if ( !UStrICmp(type,L"user") )
            lType = EA_AccountUser;
         else if ( ! UStrICmp(type,L"group") )
            lType = EA_AccountGroup;

         if (!bUseMapFile)
			m_Args.Cache()->InsertLast(sourceName,rid1,targetName,rid2,lType);
		 else
            m_Args.Cache()->InsertLastWithSid(sourceName,sourceDomSid,sourceDomName,rid1,
			                                  targetName,targetDomSid,targetDomName,rid2,lType);
         count++;
         if ( ! rid1 | ! rid2 )
         {
            bNeedRids = TRUE;
         }
      } while ( result >= 4 ); // 4 fields read and assigned

      if ( result )
      {
         err.MsgWrite(ErrS,DCT_MSG_ERROR_READING_INPUT_FILE_S,path);
      }
      err.MsgWrite(0,DCT_MSG_ACCOUNTS_READ_FROM_FILE_DS,count,path);
      fclose(pFile);
   }
   else
   {
      err.MsgWrite(ErrS,DCT_MSG_ERROR_OPENING_FILE_S,path);
      bSuccess = FALSE;
   }

   if ( bSuccess && bNeedRids && ! m_LocalOnly)
   {
      bSuccess = GetRIDsFromEA();
   }
  
   return bSuccess;
}

// This doesn't get RIDs from EA any more, since we have removed dependencies on MCS products.
// Instead, we use the Net APIs to get this information
BOOL CSecTranslator::GetRIDsFromEA()
{
   BOOL                      bSuccess = TRUE;

   // set the cache to a tree sorted by name
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompN);

   // do NQDI to get RIDS for accounts
   DWORD                     rc = 0;
   NET_DISPLAY_USER        * pUser = NULL;
   NET_DISPLAY_GROUP       * pGroup = NULL;
   DWORD                     count = 0;
   DWORD                     resume = 0;
   TRidNode                * pNode = NULL;

   // Get source rids for users
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetSourceDCName(),1,resume,5000,100000,&count,(void**)&pUser);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vNameComp,pUser[i].usri1_name);
            if ( pNode )
            {
               pNode->SrcRid(pUser[i].usri1_user_id);   
            }
         }
         if ( count )
         {
            resume = pUser[count-1].usri1_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pUser);
      }
   } while ( rc == ERROR_MORE_DATA );

   count = 0;
   resume = 0;

   // Get source rids for global groups
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetSourceDCName(),3,resume,5000,100000,&count,(void**)&pGroup);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vNameComp,pGroup[i].grpi3_name);
            if ( pNode )
            {
               pNode->SrcRid(pGroup[i].grpi3_group_id);   
            }
         }
         if ( count )
         {
            resume = pGroup[count-1].grpi3_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pGroup);
      }
   } while ( rc == ERROR_MORE_DATA );

   count = 0;
   resume = 0;
   
   // Get target rids for users
   // set the cache to a tree sorted by target name
   m_Args.Cache()->ToSorted();
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompTargetN);

   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetTargetDCName(),1,resume,5000,100000,&count,(void**)&pUser);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vTargetNameComp,pUser[i].usri1_name);
            if ( pNode )
            {
               pNode->TgtRid(pUser[i].usri1_user_id);   
            }
         }
         if ( count )
         {
            resume = pUser[count-1].usri1_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pUser);
      }
   } while ( rc == ERROR_MORE_DATA );


   
   // TODO:  Add error message if rc != 0

   count = 0;
   resume = 0;
   // Get target rids for global groups
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetTargetDCName(),3,resume,5000,100000,&count,(void**)&pGroup);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vTargetNameComp,pGroup[i].grpi3_name);
            if ( pNode )
            {
               pNode->TgtRid(pGroup[i].grpi3_group_id);   
            }
         }
         if ( count )
         {
            resume = pGroup[count-1].grpi3_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pGroup);
      }
   } while ( rc == ERROR_MORE_DATA );


   // sort back to regular source name order
   m_Args.Cache()->ToSorted();
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompN);


   // get source and target rids for local groups
   TNodeTreeEnum             tEnum;
   BYTE                      sid[LEN_SID];
   DWORD                     lenSid;
   WCHAR                     domain[LEN_Domain];
   DWORD                     lenDomain;
   SID_NAME_USE              snu;

   
   for ( pNode = (TRidNode*)tEnum.OpenFirst(m_Args.Cache()) ; pNode ; pNode = (TRidNode*) tEnum.Next() )
   {
      if ( ! pNode->SrcRid() )
      {
         // we don't have a rid for this account, possibly because it is a local group
         lenSid = DIM(sid);
         lenDomain = DIM(domain);
         if ( LookupAccountName(m_Args.Cache()->GetSourceDCName(),pNode->GetAcctName(),sid,&lenSid,domain,&lenDomain,&snu) )
         {
            if (! UStrICmp(m_Args.Source(),domain) )
            {
               // found the source SID
               // get the last sub-id
               PUCHAR        pCount = GetSidSubAuthorityCount(&sid);
               if ( pCount )
               {
                  LPDWORD    pRid = GetSidSubAuthority(&sid,(*pCount) - 1 );
                  if ( pRid )
                  {
                     pNode->SrcRid(*pRid);
                  }
               }
            }
         }
      }

      if ( pNode->SrcRid() && !pNode->TgtRid() )
      {
         // we got the source RID, now try to get the target RID
         lenSid = DIM(sid);
         lenDomain = DIM(domain);
         if ( LookupAccountName(m_Args.Cache()->GetTargetDCName(),pNode->GetTargetAcctName(),sid,&lenSid,domain,&lenDomain,&snu) )
         {
            if (! UStrICmp(m_Args.Target(),domain) )
            {
               // found the source SID
               // get the last sub-id
               PUCHAR        pCount = GetSidSubAuthorityCount(&sid);

               if ( pCount )
               {
                  LPDWORD    pRid = GetSidSubAuthority(&sid,(*pCount) - 1 );

                  if ( pRid )
                  {
                     pNode->TgtRid(*pRid);
                  }
               }
            }
         }
      }
   }
   tEnum.Close();

   return bSuccess;
}

// We remove the Exchange server service accont from the cache before translating, 
// since it is not recommended to change the service account from exchange
// in any event, the service account for exchange cannot be changed simply by granting
// exchange permissions to the new account.  It also requires configuration changes within
// exchange that must be performed manually
BOOL 
   CSecTranslator::RemoveExchangeServiceAccountFromCache()
{
   WCHAR          const    * exServiceName = L"MSExchangeDS";
   SC_HANDLE                 hSCM; 
   DWORD                     rc = 0;           // return code
   BOOL                      result = FALSE;
   BOOL						 bUseMapFile = m_Args.UsingMapFile();

   if ( m_Args.TranslateContainers() )
   {
      // get the service account name for the exchange directory service on exchServer
//      BOOL                      retval=FALSE; // returned value
      SC_HANDLE                 hSvc;         // Service handle
      DWORD                     lenQsc;       // required qsc info len
     
      union
      {
         QUERY_SERVICE_CONFIG   qsc;          // Exchange Directory service information
         BYTE                   padding[1000];
      }                         bufQsc;
      
      hSCM = OpenSCManager( m_exchServer, NULL, GENERIC_READ );
      if ( !hSCM )
      {
         rc = GetLastError();
         err.SysMsgWrite( ErrW, rc,
               DCT_MSG_SCM_OPEN_FAILED_SD, m_exchServer,rc );
         
      }
      else
      {
         hSvc = OpenService( hSCM, exServiceName, SERVICE_QUERY_CONFIG );
         if ( !hSvc )
         {
            rc = GetLastError();
            switch ( rc )
            {
               case ERROR_SERVICE_DOES_NOT_EXIST: // 1060
               default:
                  err.SysMsgWrite( ErrW, rc, DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                       m_exchServer , exServiceName, rc );
                  break;
            }
         }
         else 
         {
            if ( !QueryServiceConfig( hSvc, &bufQsc.qsc, sizeof bufQsc, &lenQsc ) )
            {
               rc = GetLastError();
               err.SysMsgWrite( ErrW, rc, DCT_MSG_QUERY_SERVICE_CONFIG_FAILED_SSD,
                     m_exchServer, exServiceName, rc );
            }
            else
            {
               // We've found the account
               result = TRUE;
               // bufQsc.qsc.lpServiceStartName is DOMAIN\Account or .\Account
               WCHAR       * domAcct = bufQsc.qsc.lpServiceStartName;
               WCHAR       * domName;  // domain-name
               WCHAR       * acctName; // account-name

               for ( domName = domAcct ; *domName && *domName != _T('\\') ; domName++ )
                  ;
               if ( *domName == _T('\\') )
               {
                  *domName = 0;
                  acctName = domName+1;
                  domName = domAcct;
               }
               // Is the account from the source domain?
               WCHAR szSourceDomain[LEN_Domain];
               WCHAR wszAccountName[LEN_Account];
               
               safecopy(wszAccountName,acctName);
               
			      //use the domain name from the cache if we are not using a sID mapping
			      //file
               if (!bUseMapFile)
			   {
                  safecopy(szSourceDomain,m_Args.Cache()->GetSourceDomainName());
                  if ( !UStrICmp(domName,szSourceDomain ) )
				  {
                     // if so, is it in the cache?
                     TAcctNode * tnode;
                     TNodeTreeEnum  tEnum;
                     // the cache is a tree, sorted by RID
                     for ( tnode = (TAcctNode *)tEnum.OpenFirst(m_Args.Cache()) ; tnode ; tnode = (TAcctNode *)tEnum.Next() )
					 {
                        if ( !UStrICmp(tnode->GetAcctName(),wszAccountName) )
						{
                           // remove it from the cache, and notify the user
                           err.MsgWrite(ErrW,DCT_MSG_SKIPPING_EXCHANGE_ACCOUNT_SS,domName,acctName);
                           m_Args.Cache()->Remove(tnode);
						}
					 }
                     tEnum.Close();
				  }
			   }//end if not using mapping file
			   else //else using sID mapping file, get the source domain name from the
			   {    //node itself
                     //is this account in the cache?
                  TAcctNode * tnode;
                  TNodeTreeEnum  tEnum;
                     // the cache is a tree, sorted by RID
                  for ( tnode = (TAcctNode *)tEnum.OpenFirst(m_Args.Cache()) ; tnode ; tnode = (TAcctNode *)tEnum.Next() )
				  {
                     if (( !UStrICmp(tnode->GetAcctName(),wszAccountName) ) &&
						 ( !UStrICmp(((TRidNode*)tnode)->GetSrcDomName(),domName) ))
					 {
                           // remove it from the cache, and notify the user
                        err.MsgWrite(ErrW,DCT_MSG_SKIPPING_EXCHANGE_ACCOUNT_SS,domName,acctName);
                        m_Args.Cache()->Remove(tnode);
					 }
				  }
                  tEnum.Close();
			   }//end if using mapping file
               CloseServiceHandle( hSvc );
            }
         }
         CloseServiceHandle(hSCM);
      }
   }
   if ( !result ) 
   {
      // couldn't get the service account name
      err.SysMsgWrite(ErrW,rc,DCT_MSG_CANT_FIND_EXCHANGE_ACCOUNT_SD,
         m_exchServer,rc);
   }
   return result;
}

void 
   CSecTranslator::DoExchangeResolution(
      TSDResolveStats      * stat,          // in - stats object to record stats
      IVarSet              * pVarSet
   )
{

   {
      TGlobalDirectory          m_exDir;
      _bstr_t                   domain = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Domain));
      _bstr_t                   username = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_UserName));
      _bstr_t                   password = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
      _bstr_t                   mode = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
      _bstr_t                   mbquery = pVarSet->get(L"ExchangeMigration.LdapQuery");
      WCHAR                     creds[LEN_Account + LEN_Domain + 6];
      WCHAR                     query[LEN_Path] = L"(objectClass=*)";
      if ( m_exchServer[0] )
      {
         if (! RemoveExchangeServiceAccountFromCache() )
            goto end;
      }
   
      if ( mbquery.length() )
      {
         UStrCpy(query,(WCHAR*)mbquery);
      }
      if ( m_Args.TranslateMailboxes() || m_Args.TranslateContainers() )
      {
          // make sure we have some accts in the cache
         m_exDir.SetStats(stat);
         m_Args.Cache()->UnCancel();      
         swprintf(creds,L"cn=%ls,cn=%ls",(WCHAR*)username,(WCHAR*)domain);
         err.MsgWrite(0,DCT_MSG_EXCHANGE_TRANSLATION_MODE_S,(WCHAR*)mode);
         m_exDir.DoLdapTranslation(m_exchServer,creds,password,&m_Args,NULL,query);
         stat->DisplayPath(L"");
         
      } 
   }
end:
   // destructor for m_exDir must be called before we release the MAPI library!
   ReleaseMAPI();
   ReleaseDAPI();
   return;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for retrieving account sIDs from *
 * the given sID mapping file and adding these sids to the cache.    *
 *                                                                   *
 *********************************************************************/

//BEGIN LoadCacheFromMapFile
BOOL 
   CSecTranslator::LoadCacheFromMapFile(
      WCHAR          const * filename,       // in - file to read sid mapping from
      IVarSet              * pVarSet         // in - pointer to varset
   )
{
   FILE                    * pFile = NULL;
   WCHAR                     path[MAX_PATH];
   WCHAR                     sourceSid[MAX_PATH];
   WCHAR                     targetSid[MAX_PATH];
   int                       count = 0;
   BOOL                      bSuccess = TRUE;
   
//      m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
   _wfullpath(path,filename,MAX_PATH);

   m_Args.Cache()->ToSorted();
   
   // The input file should have the format:
   // srcSid,tgtSid
   pFile = OpenMappingFile(path);   
//   pFile = _wfopen(path,L"rb");
   if ( pFile )
   {
      int result;
			   
	     //move past the UNICODE Byte Order Mark
//      fgetwc(pFile);

      do 
      {
         result = fwscanf(pFile,L"%[^,], %[^\r\n]\n",sourceSid,targetSid);

         if ( result < 2 )
            break;
         
         short lType = EA_AccountUser;

		   //divide the sids into domain sids and rids
		 WCHAR    srcDomainSid[MAX_PATH] = L"";
		 WCHAR    tgtDomainSid[MAX_PATH] = L"";
		 WCHAR    srcDomainName[MAX_PATH] = L"";
		 WCHAR    tgtDomainName[MAX_PATH] = L"";
		 DWORD    srcRid = 0;
		 DWORD    tgtRid = 0;
		 WCHAR	  srcName[MAX_PATH] = L"";
		 WCHAR	  tgtName[MAX_PATH] = L"";
		 WCHAR	  domainName[MAX_PATH] = L"";
	     DWORD	  cb = MAX_PATH;
	     DWORD    cbDomain = MAX_PATH;
         SID_NAME_USE	sid_Use;
		 PSID     srcSid = NULL;
		 PSID	  tgtSid = NULL;
         WCHAR  * slash;
	     LPWSTR   pdomc;	
		 WCHAR	  DCName[MAX_PATH];
         BYTE     ssid[200];
         BYTE     tsid[200];
         DWORD    lenSid = DIM(ssid);
		 BOOL	  bNeedToFreeSrc = FALSE;
		 BOOL	  bNeedToFreeTgt = FALSE;

            //see if the source is given by domain\account format or 
		    //decimal-style sid format
		 if (wcschr(sourceSid,L'\\'))
		 {
			   //seperate domain and account names
            wcscpy(srcDomainName,sourceSid);
            slash = wcschr(srcDomainName,L'\\');
            if ( slash )
            {
               *slash = 0;
               wcscpy(srcName,slash+1);
            }
			  //get a DC for the given domain
	        HRESULT res = NetGetDCName(NULL,srcDomainName,(LPBYTE *)&pdomc); 
	        if (res!=NERR_Success)
			{
               err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
			   continue;
			}

		    wcscpy(DCName, pdomc);
		    NetApiBufferFree(pdomc);

			  //get the sid for this account
			if(!LookupAccountName(DCName,srcName,(PSID)ssid,&lenSid,srcDomainName,&cbDomain,&sid_Use))
			{
               err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
			   continue;
			}

			srcSid = (PSID)ssid;

			if (sid_Use == SidTypeGroup)
			   lType = EA_AccountGroup;
			else
			   lType = EA_AccountUser;
		 }//end if domain\account format
		 else
		 {
            srcSid = SidFromString(sourceSid);
			if (!srcSid)
			{
               err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
			   continue;
			}

			bNeedToFreeSrc = TRUE;

            if (LookupAccountSid(NULL, srcSid, srcName, &cb, srcDomainName, &cbDomain, &sid_Use))
			{
			   if (sid_Use == SidTypeGroup)
			      lType = EA_AccountGroup;
			   else
			      lType = EA_AccountUser;
			}
		 }//end else sid format

            //see if the target is given by domain\account format or 
		    //decimal-style sid format
         lenSid = DIM(tsid);
	     cb = cbDomain = MAX_PATH;
		 if (wcschr(targetSid,L'\\'))
		 {
			   //seperate domain and account names
            wcscpy(tgtDomainName,targetSid);
            slash = wcschr(tgtDomainName,L'\\');
            if ( slash )
            {
               *slash = 0;
               wcscpy(tgtName,slash+1);
            }
			  //get a DC for the given domain
	        HRESULT res = NetGetDCName(NULL,tgtDomainName,(LPBYTE *)&pdomc); 
	        if (res!=NERR_Success)
			{
			   if (bNeedToFreeSrc)
		          FreeSid(srcSid);
               err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
			   continue;
			}

		    wcscpy(DCName, pdomc);
		    NetApiBufferFree(pdomc);

			  //get the sid for this account
			if(!LookupAccountName(DCName,tgtName,(PSID)tsid,&lenSid,tgtDomainName,&cbDomain,&sid_Use))
			{
			   if (bNeedToFreeSrc)
		          FreeSid(srcSid);
               err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
			   continue;
			}

			tgtSid = (PSID)tsid;

			if (sid_Use == SidTypeGroup)
			   lType = EA_AccountGroup;
			else
			   lType = EA_AccountUser;
		 }//end if domain\account format
		 else
		 {
            tgtSid = SidFromString(targetSid);
			if (!tgtSid)
			{
			   if (bNeedToFreeSrc)
		          FreeSid(srcSid);
               err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
			   continue;
			}

			bNeedToFreeTgt = TRUE;

            if (LookupAccountSid(NULL, tgtSid, tgtName, &cb, tgtDomainName, &cbDomain, &sid_Use))
			{
			   if (sid_Use == SidTypeGroup)
			      lType = EA_AccountGroup;
			   else
			      lType = EA_AccountUser;
			}
		 }//end else sid format

		    //if the source account is not already in the cache, then add it
		 if ((m_Args.Cache()->GetNumAccts() == 0) || (m_Args.Cache()->LookupWODomain(srcSid) == NULL))
		 {
		       //get the domain sids and account rids from the account sids
		    SplitAccountSids(srcSid, srcDomainSid, &srcRid, tgtSid, tgtDomainSid, &tgtRid);

 		       //insert this node into the cache
            m_Args.Cache()->InsertLastWithSid(srcName,srcDomainSid,srcDomainName,srcRid,tgtName,
			                                  tgtDomainSid,tgtDomainName,tgtRid,lType);
            count++;
		 }
		 else
            err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_DUPLICATE_IN_FILE_DS, sourceSid, targetSid, path, sourceSid);

		 if (bNeedToFreeSrc)
		    FreeSid(srcSid);
		 if (bNeedToFreeTgt)
		    FreeSid(tgtSid);
      } while ( result >= 2 ); // 2 fields read and assigned

      err.MsgWrite(0,DCT_MSG_ACCOUNTS_READ_FROM_FILE_DS,count,path);
      fclose(pFile);
   }
   else
   {
      err.MsgWrite(ErrS,DCT_MSG_ERROR_OPENING_FILE_S,path);
      bSuccess = FALSE;
   }

   return bSuccess;
}
//END LoadCacheFromMapFile 


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for opening the sid mapping file *
 * whether it is anm ANSI or UNICODE file and return the file        *
 * pointer.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN OpenMappingFile
FILE* CSecTranslator::OpenMappingFile(LPCTSTR pszFileName)
{
	// open in binary mode first in order to check for UNICODE byte order
	// mark if the file is UNICODE then it must be read in binary mode
	// with the stream i/o functions

	FILE* fp = _tfopen(pszFileName, _T("rb"));

	if (fp == NULL)
	{
		return NULL;
//		_com_issue_error(E_INVALIDARG);
	}

	// check if file is ANSI or UNICODE or UTF-8

	BYTE byteSignature[3];

	if (fread(byteSignature, sizeof(BYTE), 3, fp) == 3)
	{
		static BYTE byteUtf8[] = { 0xEF, 0xBB, 0xBF };
		static BYTE byteUnicodeLE[] = { 0xFF, 0xFE };
		static BYTE byteUnicodeBE[] = { 0xFE, 0xFF };

		// check for signature or byte order mark

		if (memcmp(byteSignature, byteUtf8, sizeof(byteUtf8)) == 0)
		{
			// UTF-8 signature
			// TODO: not currently supported
		    return NULL;
//			_com_issue_error(E_INVALIDARG);
		}
		else if (memcmp(byteSignature, byteUnicodeLE, sizeof(byteUnicodeLE)) == 0)
		{
			// UNICODE Little Endian Byte Order Mark
			// supported
			// must read in binary mode
			// move file pointer back one byte because we read 3 bytes
			fseek(fp, -1, SEEK_CUR);
		}
		else if (memcmp(byteSignature, byteUnicodeBE, sizeof(byteUnicodeBE)) == 0)
		{
			// UNICODE Big Endian Byte Order Mark
			// TODO: not currently supported
		    return NULL;
//			_com_issue_error(E_INVALIDARG);
		}
		else
		{
			// assume ANSI
			// re-open file in text mode as the stream i/o functions will
			// treat the file as multi-byte characters and will convert them
			// to UNICODE

			fclose(fp);

			fp = _tfopen(pszFileName, _T("rt"));
		}
	}
	else
	{
		return NULL;
//		_com_issue_error(E_INVALIDARG);
	}

	return fp;
}
//END OpenMappingFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sectrans.h ===
// SecTranslator.h : Declaration of the CSecTranslator

#ifndef __SECTRANSLATOR_H_
#define __SECTRANSLATOR_H_

#include "resource.h"       // main symbols

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty") //#imported via sdstat.hpp below
#include "STArgs.hpp"
#include "SDStat.hpp"
#include "EaLen.hpp"
#include "TNode.hpp"

/////////////////////////////////////////////////////////////////////////////
// CSecTranslator
class ATL_NO_VTABLE CSecTranslator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSecTranslator, &CLSID_SecTranslator>,
	public ISecTranslator
{
public:
	CSecTranslator()
	{
		m_pUnkMarshaler = NULL;
      m_exchServer[0] = 0;
      m_Profile[0] = 0;
      m_Container[0] = 0;
      m_CacheFile[0] = 0;
      m_domain[0] = 0;
      m_username[0] = 0;
      m_password[0] = 0;
      m_LocalOnly = FALSE;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SECTRANSLATOR)
DECLARE_NOT_AGGREGATABLE(CSecTranslator)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSecTranslator)
	COM_INTERFACE_ENTRY(ISecTranslator)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISecTranslator
public:
	STDMETHOD(Process)(IUnknown * pWorkItemIn);

protected:
   SecurityTranslatorArgs    m_Args;
   WCHAR                     m_exchServer[LEN_Computer];
   WCHAR                     m_Profile[LEN_DistName];
   WCHAR                     m_Container[LEN_DistName];
   WCHAR                     m_CacheFile[MAX_PATH];
   WCHAR                     m_domain[LEN_Domain];
   WCHAR                     m_username[LEN_Account];
   WCHAR                     m_password[LEN_Password];
   WCHAR                     m_SourceSid[LEN_Account];
   WCHAR                     m_TargetSid[LEN_Account];
   BOOL                      m_LocalOnly;
   TNodeList                 m_ConnectionList;

   void LoadSettingsFromVarSet(IVarSet * pVarSet);
   void ExportStatsToVarSet(IVarSet * pVarSet, TSDResolveStats * stat);
   void DoResolution(TSDResolveStats * stat);
   void DoLocalGroupResolution(TSDResolveStats * stat);
   void DoExchangeResolution(TSDResolveStats * stat, IVarSet * pVarSet);
   void DoUserRightsTranslation(TSDResolveStats * stat);
   void CleanupSessions();
   BOOL LoadCacheFromVarSet(IVarSet * pVarSet);
   BOOL LoadCacheFromFile(WCHAR const * filename, IVarSet * pVarSet);
   BOOL GetRIDsFromEA();
   BOOL BuildCacheFile(WCHAR const * filename);
   BOOL RemoveExchangeServiceAccountFromCache();
   BOOL EstablishASession(WCHAR const * serverName);
   HRESULT LoadMigratedObjects(IVarSet * pVarSetIn);
   BOOL LoadCacheFromMapFile(WCHAR const * filename, IVarSet * pVarSet);
   FILE* OpenMappingFile(LPCTSTR pszFileName);
};

#endif //__SECTRANSLATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sidcache.cpp ===
//#pragma title ("SidCache.hpp -- Cache, Tree of SIDs")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sidcache.cpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Cache of SIDs.  Implemented using TNode derived classes, Cache is 
               organized as a tree, sorted by Domain B RID.  Each node contains 
               Domain A RID, Domain B RID, Account Name, and counters for stats.  
Updates     -
===============================================================================
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "stdafx.h"

#include <malloc.h>
#include <winbase.h>
#include <lm.h>
#include <lmaccess.h>
#include <assert.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "Ustring.hpp"
#include "sidcache.hpp"

#include "CommaLog.hpp"
#include "TxtSid.h"
#include "ResStr.h"
#include "EaLen.hpp"
#include "LSAUtils.h" // For GetDomainDCName

// from sdresolve.hpp
extern BOOL BuiltinRid(DWORD rid);
extern DWORD OpenDomain(WCHAR const * domain);

extern TErrorDct err;
extern bool silent;

/***************************************************************************************************/
/* vRidComp is used as a compare function for TSidNode Trees
// It searches for v1 in the ridA field.  The Tree must be sorted with RidComp before using this 
// search fn.
// Return values:  0   tn->ridA == v1
//                 1   tn->ridA < v1   
//                -1   tn->ridA > v1  
// 
/**************************************************************************************************/
int
   vRidComp(
      const TNode           * tn,           // in -TSidNode 
      const void            * v1            // in -DWORD ridA value to look for
   )
{
   DWORD                     rid1;
   DWORD                     rid2;
   TRidNode                * n2;
   int                       retval;
   assert( tn );                    // we should always be given valid inputs
   assert( v1 );
   
   n2 = (TRidNode *)tn;
   rid1 = n2->SrcRid();
   rid2 = *(DWORD *)v1;
   if ( rid1 < rid2 )
   {
      retval = -1;
   }
   if (rid1 > rid2)
   {
      retval = 1;
   }
   if ( rid1 == rid2)  // ( rid1 == rid2 )
   {
      retval = 0;
   }
   return retval;
}
/***************************************************************************************************/
/* RidComp:  used as a compare function for TSidNode Trees
     
   It compares the ridA fields of SIDTNodes
   
   Return Values:
                  0     t1->ridA == t2->ridA
                  1     t1->ridA >  t2->ridA
                 -1     t1->ridA <  t2->ridA

/***************************************************************************************************/

int RidComp(
   const TNode             * t1,     //in -first node to compare
   const TNode             * t2      //in -second node to compare
   )
{
   assert( t1 );
   assert( t2 );

   TRidNode                * st1 = (TRidNode *) t1;
   TRidNode                * st2 = (TRidNode *) t2;
   DWORD                     rid1 = st1->SrcRid();
   DWORD                     rid2 = st2->SrcRid();
   int                       retval;

   if ( rid1 < rid2 )
   {
      retval = -1;
   }
   if (rid1 > rid2)
   {
      retval = 1;
   }
   if ( rid1 == rid2 ) // (rid1 == rid2)
   {
      retval = 0;
   }
   return retval;
}
/***************************************************************************************************
 vNameComp: used as a compare function for TSidNode trees

   It compares a UNICODE string, with the acct_name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/

int 
   vNameComp(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )

{
   assert( tn );
   assert( actname );

   LPWSTR                    str1 = ((TRidNode *)tn)->GetAcctName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
/***************************************************************************************************/
/* CompN:  used as a compare function for TSidNode Trees
     
   It compares the acct_name fields of SIDTNodes
   
   Return Values:
                  0     t1->acct_name == t2->acct_name
                  1     t1->acct_name >  t2->acct_name
                 -1     t1->acct_name <  t2->acct_name

   Error Handling:
      if given bad inputs, CompN displays an error message and returns 0
/***************************************************************************************************/

int 
   CompN(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  
   assert( v1 );
   assert( v2 );

   TRidNode                * t1 = (TRidNode *)v1;
   TRidNode                * t2 = (TRidNode *)v2;
  
   return UStrICmp(t1->GetAcctName(),t2->GetAcctName());
} 

int 
   vTargetNameComp(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )

{
   assert( tn );
   assert( actname );

   LPWSTR                    str1 = ((TRidNode *)tn)->GetTargetAcctName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
int 
   CompTargetN(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  
   assert( v1 );
   assert( v2 );

   TRidNode                * t1 = (TRidNode *)v1;
   TRidNode                * t2 = (TRidNode *)v2;
  
   return UStrICmp(t1->GetTargetAcctName(),t2->GetTargetAcctName());
} 

int 
   TSidCompare(
      PSID const             sid1,     // in - first sid to compare
      PSID const             sid2      // in - second sid to compare
   )
{
   DWORD                     len1,
                             len2;
   int                       retval = 0;

   len1 = GetLengthSid(sid1);
   len2 = GetLengthSid(sid2);

   if ( len1 < len2 )
   {
      retval = -1;
   }
   if ( len1 > len2 )
   {
      retval = 1;
   }
   if ( len1 == len2 )
   {
      retval = memcmp(sid1,sid2,len1);
   }

   return retval;
}
/**************************************************************************************************
 vSidComp: used as a compare function for TSidNode trees

   It compares a UNICODE string, with the acct_name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/
int 
   vSidComp(
      const TNode          * tn,          //in -tree node  
      const void           * val         //in -sid to look for  
   )
{
   PSID                     sid1 = ((TGeneralSidNode *)tn)->SrcSid();
   PSID                     sid2 = (PSID)val;

   return TSidCompare(sid1,sid2);
}


int 
   nSidComp(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{
   TGeneralSidNode                * t1 = (TGeneralSidNode *)v1;
   TGeneralSidNode                * t2 = (TGeneralSidNode *)v2;
  
   return TSidCompare(t1->SrcSid(), t2->SrcSid());
}
   

/*******************************************************************************************************/
//                                 TSidNode Implementation
/*******************************************************************************************************/

TGeneralCache::TGeneralCache()
{
   CompareSet(&nSidComp);
   TypeSetTree();
}

TGeneralCache::~TGeneralCache()
{
   DeleteAllListItems(TGeneralSidNode);
}

void * TRidNode::operator new(size_t sz, const LPWSTR oldname, const LPWSTR newname)
{
   int                       nlen = UStrLen(newname) + UStrLen(oldname) + 1;
   void                    * node = malloc(sz + nlen * (sizeof WCHAR) );

   return node;
}

   TAcctNode::TAcctNode()
{
   owner_changes = 0;
   group_changes = 0; 
   ace_changes   = 0;
   sace_changes  = 0; 
}

WCHAR *                                   // ret- domain part of name 
   GetDomainName(
   WCHAR *                   name         // in - domain\\account name
   )
{
   assert (name);

   int                       i;
   int                       len = UStrLen(name);
   WCHAR                   * domain;
   
   for (i = 2 ; name[i] != '\\' && i < len ; i++ )
   ;
   if ( i < len )
   {
      domain = new WCHAR[i+1];
	  if (!domain)
	     return NULL;
      UStrCpy(domain,name,i);
   }
   else
   {
      domain = NULL;
   }
   return domain;
}

   TGeneralSidNode::TGeneralSidNode(
      const LPWSTR           name1,        // in - account name on source domain
      const LPWSTR           name2         // in - account name on target domain
  )
{
   assert (name1 && name2);
   assert (*name1 && *name2);
   
   WCHAR                   * domname;

   memset(&ownerStats,0,(sizeof ownerStats));
   memset(&groupStats,0,(sizeof ownerStats));
   memset(&daclStats,0,(sizeof ownerStats));
   memset(&saclStats,0,(sizeof ownerStats));

   src_acct_name = new WCHAR[UStrLen(name1)+1];
   if (!src_acct_name)
      return;
   safecopy(src_acct_name,name1);
   tgt_acct_name = new WCHAR[UStrLen(name2) + 1];
   if (!tgt_acct_name)
      return;
   safecopy(tgt_acct_name,name2);
   SDRDomainInfo             info;
   domname = GetDomainName(name1);
   if (!domname)
      return;
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )
   {
      src_domain = new WCHAR[UStrLen(info.domain_name)];
      if (!src_domain)
         return;
      safecopy(src_domain, info.domain_name);
      // src_dc = info.dc_name;
      src_nsubs = info.nsubs;
      src_sid = info.domain_sid;
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_DOMAIN_NOT_FOUND_S,domname);
      src_domain = NULL;
      //   src_dc = NULL;
      src_nsubs = 0;
      src_sid = NULL;
   }
   delete domname;
   domname = GetDomainName(name2);
   if (!domname)
      return;
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )
   {
      tgt_domain = new WCHAR[UStrLen(info.domain_name)];
      if (!tgt_domain)
         return;
      safecopy(tgt_domain, info.domain_name);
      tgt_nsubs = info.nsubs;
      tgt_sid = info.domain_sid;
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_DOMAIN_NOT_FOUND_S,domname);
      tgt_domain = NULL;
      tgt_nsubs = 0;
      tgt_sid = NULL;
   }
   sizediff = GetSidLengthRequired(tgt_nsubs) - GetSidLengthRequired(src_nsubs);

}


WCHAR *                                      // ret- textual representation of sid
   BuildSidString(
      PSID                   pSid            // in - sid
   )
{
   WCHAR                   * buf;
   DWORD                     bufLen = 0;

   GetTextualSid(pSid,NULL,&bufLen);

   buf = new WCHAR[bufLen+1];
   if (!buf)
      return NULL;

   if ( ! GetTextualSid(pSid,buf,&bufLen) )
   {
      wcscpy(buf,L"<Unknown>");
   }
   return buf;
}
   
TGeneralSidNode::TGeneralSidNode(
   const PSID                pSid1,          // in - source domain sid
   const PSID                pSid2           // in - target domain sid
   )
{
   WCHAR                     domain[LEN_Domain];
   WCHAR                     account[LEN_Account];
   DWORD                     lenDomain = DIM(domain);
   DWORD                     lenAccount = DIM(account);
   SID_NAME_USE              snu;
   DWORD                     nBytes;
   
   memset(&ownerStats,0,(sizeof ownerStats));
   memset(&groupStats,0,(sizeof ownerStats));
   memset(&daclStats,0,(sizeof ownerStats));
   memset(&saclStats,0,(sizeof ownerStats));

   
   // Source domain
   if ( pSid1 )
   {
      // Make a copy of the SID 
      src_nsubs = *GetSidSubAuthorityCount(pSid1);
      nBytes = GetSidLengthRequired(src_nsubs);
      src_sid = new BYTE[nBytes];
	  if (!src_sid)
	     return;
      CopySid(nBytes,src_sid,pSid1);
      // Look up name for source SID
      if ( LookupAccountSid(NULL,pSid1,account,&lenAccount,domain,&lenDomain,&snu) )
      {
         if ( lenAccount == 0 && snu == SidTypeDeletedAccount )
         {
            WCHAR * buf = BuildSidString(pSid1);
			if (!buf)
		       return;
            swprintf(account,L"<Deleted Account (%s)>",buf);
            delete buf;
         }
         src_acct_name = new WCHAR[UStrLen(domain) + 1 + UStrLen(account)+1];
	     if (!src_acct_name)
	        return;
         swprintf(src_acct_name,L"%s\\%s",domain,account);
         src_domain = NULL;
      }
      else
      {
         src_acct_name = BuildSidString(pSid1);
		 if (!src_acct_name)
		    return;
         src_domain = NULL;
      }
   }
   else
   {
      src_nsubs = 0;
      src_sid = NULL;
      src_acct_name = NULL;
      src_domain = NULL;
   }

   // Target domain
   if ( pSid2 )
   {
      tgt_nsubs = *GetSidSubAuthorityCount(pSid2);
      nBytes = GetSidLengthRequired(tgt_nsubs);
      tgt_sid = new BYTE[nBytes];
	  if (!tgt_sid)
	     return;
      CopySid(nBytes,tgt_sid,pSid2);
      if ( LookupAccountSid(NULL,pSid2,account,&lenAccount,domain,&lenDomain,&snu) )
      {
         tgt_acct_name = new WCHAR[UStrLen(domain) + 1 + UStrLen(account)+1];
	     if (!tgt_acct_name)
	        return;
         swprintf(tgt_acct_name,L"%s\\%s",domain,account);
         tgt_domain = NULL;
      }
      else
      {
         tgt_acct_name = NULL;
         tgt_domain = NULL;
      }
   }
   else
   {
      tgt_nsubs = 0;
      tgt_sid = NULL;
      tgt_acct_name = NULL;
      tgt_domain = NULL;
   }
   sizediff = GetSidLengthRequired(src_nsubs) - GetSidLengthRequired(tgt_nsubs);
}
   
   TGeneralSidNode::~TGeneralSidNode()
{
   if ( src_acct_name )
      delete src_acct_name;
   if ( tgt_acct_name )
      delete tgt_acct_name;
   if ( src_sid )
      delete src_sid;
   if ( tgt_sid )
      delete tgt_sid;
   if ( src_domain )
      delete src_domain;
   if ( tgt_domain )
      delete tgt_domain;
}    

   TRidNode::TRidNode(
      const LPWSTR           oldacctname,       // in -source account name
      const LPWSTR           newacctname        // in -target account name
   )
{
   
   srcRid = 0;
   tgtRid = 0; 
   tgtRidIsValid = false;
   
   if ( ! newacctname )
   {
      acct_len = -1;
      swprintf(acct_name,L"%s",oldacctname);
      acct_name[UStrLen(acct_name)+1] = 0;
   }
   else
   {
      acct_len = UStrLen(oldacctname);
      swprintf(acct_name,L"%s:%s",oldacctname,newacctname);
      acct_name[acct_len] = 0; 
   }
  
   wcscpy(srcDomSid,L"");
   wcscpy(tgtDomSid,L"");
   wcscpy(srcDomName,L"");
   wcscpy(tgtDomName,L"");

}
   TRidNode::~TRidNode()
{
   
}

/*******************************************************************************************************/
//                                 TSidCache Implementation
/*******************************************************************************************************/

void 
   TSDRidCache::ReportAccountReferences(
      WCHAR          const * filename              // in - filename to record account references
   )
{
   if ( m_otherAccounts )
   {
      CommaDelimitedLog      resultLog;

      if ( resultLog.LogOpen(filename,FALSE) )
      {

         TGeneralSidNode   * gnode;
         TNodeTreeEnum       tEnum;

         for ( gnode = (TGeneralSidNode *)tEnum.OpenFirst(m_otherAccounts) ; gnode ; gnode = (TGeneralSidNode*)tEnum.Next() )
         {
            TSDFileDirCell       * pOwner = gnode->GetOwnerStats();
            TSDFileDirCell       * pGroup = gnode->GetGroupStats();
            TSDFileDirCell       * pDacl = gnode->GetDaclStats();
            TSDFileDirCell       * pSacl = gnode->GetSaclStats();
            WCHAR * sAccountSid = BuildSidString(gnode->SrcSid());
			if (!sAccountSid)
		       return;

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_File),
                                                          pOwner->file,
                                                          pGroup->file,
                                                          pDacl->file,
                                                          pSacl->file );
            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Dir),
                                                          pOwner->dir,
                                                          pGroup->dir,
                                                          pDacl->dir,
                                                          pSacl->dir );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Share),
                                                          pOwner->share,
                                                          pGroup->share,
                                                          pDacl->share,
                                                          pSacl->share );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Mailbox),
                                                          pOwner->mailbox,
                                                          pGroup->mailbox,
                                                          pDacl->mailbox,
                                                          pSacl->mailbox );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Container),
                                                          pOwner->container,
                                                          pGroup->container,
                                                          pDacl->container,
                                                          pSacl->container );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Member),
                                                          pOwner->member,
                                                          pGroup->member,
                                                          pDacl->member,
                                                          pSacl->member );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_UserRight),
                                                          pOwner->userright,
                                                          pGroup->userright,
                                                          pDacl->userright,
                                                          pSacl->userright );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_RegKey),
                                                          pOwner->regkey,
                                                          pGroup->regkey,
                                                          pDacl->regkey,
                                                          pSacl->regkey );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Printer),
                                                          pOwner->printer,
                                                          pGroup->printer,
                                                          pDacl->printer,
                                                          pSacl->printer );

			if (sAccountSid)
               delete sAccountSid;
         }
         tEnum.Close();
         resultLog.LogClose();
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_COULD_NOT_OPEN_RESULT_FILE_S,filename);
      }
   }
}
      

void 
   TSDRidCache::ReportToVarSet(
      IVarSet              * pVarSet,           // in -varset to write information to
      bool                   summary,           // in -flag: whether to print summary information 
      bool                   detail             // in -flag: whether to print detailed stats
   ) 
{
   TNodeTreeEnum             tEnum;
   TRidNode                * tnode;
   long                      users=0;
   long                      lgroups=0;
   long                      ggroups=0;
   long                      other=0;
   long                      unres_users=0;
   long                      unres_lg=0;
   long                      unres_gg=0;
   long                      unres_other=0;
   long                      total=0;
   long                      n = 0;    
  // sort the cache by names before printing the report
   Sort(&CompN);
   Balance();
   if ( detail )
   {
      for ( tnode = (TRidNode *)tEnum.OpenFirst(this) ; tnode ; tnode = (TRidNode *)tEnum.Next() )
      {
         if( tnode->ReportToVarSet(pVarSet,n) )
         {
            n++;
         }
         switch ( tnode->Type() )
         {
            case EA_AccountGroup: ggroups++; break;
            case EA_AccountGGroup: ggroups++; break;
            case EA_AccountLGroup: lgroups++; break;
            case EA_AccountUser: users++; break;
            default:
               other++;
               err.MsgWrite(0,DCT_MSG_BAD_ACCOUNT_TYPE_SD,tnode->GetAcctName(),tnode->Type() );
         }
   
      }

      tEnum.Close();

      if ( m_otherAccounts )
      {
         TGeneralSidNode   * gnode;

         for ( gnode = (TGeneralSidNode *)tEnum.OpenFirst(m_otherAccounts) ; gnode ; gnode = (TGeneralSidNode*)tEnum.Next() )
         {
            if( gnode->ReportToVarSet(pVarSet,n) )
            {
               n++;
            }
            other++;
         }
      }
      total = users+lgroups+ggroups+other + unres_gg + unres_lg + unres_users + unres_other;

      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumUsers),users);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumGlobalGroups),ggroups);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumLocalGroups),lgroups);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumOther),other);

   }
   // re-sort by rid after printing the report
   Sort(&RidComp);
   Balance();
}

/***************************************************************************************************/
/* TSidCache::Display: Displays the summary information, and/or contents of the TSidCache tree

  
/***************************************************************************************************/
void 
   TSDRidCache::Display(
      bool                   summary,           // in -flag: whether to print summary information 
      bool                   detail             // in -flag: whether to print detailed stats
   ) 
{
   TNodeTreeEnum             tEnum;
   TRidNode                * tnode;
   long                      users=0;
   long                      lgroups=0;
   long                      ggroups=0;
   long                      other=0;
   long                      unres_users=0;
   long                      unres_lg=0;
   long                      unres_gg=0;
   long                      unres_other=0;
   long                      total=0;
      
  // sort the cache by names before printing the report
   Sort(&CompN);
   Balance();
   if ( detail )
   {
      err.MsgWrite(0,DCT_MSG_ACCOUNT_DETAIL_HEADER);
      for ( tnode = (TRidNode *)tEnum.OpenFirst(this) ; tnode ; tnode = (TRidNode *)tEnum.Next() )
      {
         tnode->DisplayStats();
         switch ( tnode->Type() )
         {
            case EA_AccountGroup: ggroups++; break;
            case EA_AccountGGroup: ggroups++; break;
            case EA_AccountLGroup: lgroups++; break;
            case EA_AccountUser: users++; break;
            default:
               other++;
               err.MsgWrite(0,DCT_MSG_BAD_ACCOUNT_TYPE_SD,tnode->GetAcctName(),tnode->Type() );
         }
   
      }
      total = users+lgroups+ggroups+other + unres_gg + unres_lg + unres_users + unres_other;

      err.MsgWrite(0,DCT_MSG_ACCOUNT_DETAIL_FOOTER);
   }
   if ( summary )
   {
      err.MsgWrite(0,DCT_MSG_ACCOUNT_USER_GROUP_COUNT_DD,users+unres_users,ggroups+unres_gg+lgroups+unres_lg);
      err.MsgWrite(0,DCT_MSG_ACCOUNT_STATUS_COUNT_DDD,accts,accts_resolved,accts - accts_resolved);
   }
   // re-sort by rid after printing the report
   Sort(&RidComp);
   Balance();
}
/***************************************************************************************************/
/* GetSidB: 

         Builds a sid containing the Identifier Authority from the target-domain SID, along with the 
         RID from the ridB field of the supplied node.   

/***************************************************************************************************/

PSID                                // ret -the domain B sid for the account referenced in tnode
   TSDRidCache::GetTgtSid(
      const TAcctNode       * anode // in -node to copy RID from
   ) 
{
   
   TRidNode                * tnode = (TRidNode *)anode; 
   
   assert( tnode );                         
   assert( tnode->IsValidOnTgt() );     
   assert( to_sid );                // we can't resolve if we don't have domain B sid
   
   PDWORD                    rid;
   DWORD                     sidsize = GetSidLengthRequired(to_nsubs);
   PSID                      newsid  = malloc(sidsize);
   
   if (newsid)
   {
      CopySid(sidsize,newsid,to_sid);                          // copy the domain B sid
      rid = GetSidSubAuthority(newsid,to_nsubs -1);
      
      assert( (*rid) == -1 );                                  // FillCache makes sure to_sid always ends with -1(f...f)
                                                             
      (*rid)=tnode->TgtRid();                                 // replace last sub with this node's RID
   }

   return newsid;
}

// GetTgtSidWODomain:
//    Returns the target sid for this node without having the target domain information
// filled in (like when we reACl using a sID mapping file).
PSID                                // ret -the domain B sid for the account referenced in tnode
   TSDRidCache::GetTgtSidWODomain(
      const TAcctNode       * anode // in -node to copy RID from
   ) 
{
   
   TRidNode                * tnode = (TRidNode *)anode;
   
   assert( tnode );                         
   assert( tnode->IsValidOnTgt() );     
   
   PDWORD                    rid;

      //get and convert the target domain sid stored in the node to a PSID
   PSID pTgtSid = SidFromString(tnode->GetTgtDomSid());
   PUCHAR pCount = GetSidSubAuthorityCount(pTgtSid);
   DWORD nSub = (DWORD)(*pCount) - 1;
   
   rid = GetSidSubAuthority(pTgtSid,nSub);
   
   assert( (*rid) == -1 );                                  // FillCache makes sure to_sid always ends with -1(f...f)
                                                          
   (*rid)=tnode->TgtRid();                                 // replace last sub with this node's RID

   return pTgtSid;
}

/***************************************************************************************************/
/*  Display sid - Displays the contents of a SID.
    The sid given is assumed to be a valid SID
/***************************************************************************************************/
void 
   DisplaySid(
      const PSID             ps                 // in -pointer to the sid to display
   ) 
{
   assert( ps );

   PUCHAR                    ch = GetSidSubAuthorityCount(ps);
   DWORD                     nsubs = *ch;
   DWORD                     i;
   PSID_IDENTIFIER_AUTHORITY ida = GetSidIdentifierAuthority(ps);
   
   for ( i = 0 ; i < 6 ; i++ )                               // 6 value fields in IA
   {
      printf("%ld, ",ida->Value[i]);
   }
   printf("\n%ld Subs: ",nsubs);
   for ( i = 0 ; i < nsubs ; i++ )                           // print subauthority values
   {
      printf("\nS[%d]= %ld  ",i,*GetSidSubAuthority(ps,i));
   }
   printf("\n");
}
/***************************************************************************************************/
/* DisplaySid:  If the sid is found in the cache, display the associated name, otherwise display 
                the sid contents.
   ps and C are assumed to be valid.
/***************************************************************************************************/
void 
   DisplaySid(
      const PSID             ps,                // in- sid to display
      TAccountCache        * C                  // in- TSidCache to look for sid in
   )
{
   assert ( ps );

   if ( !C )  
   {
      DisplaySid(ps);
   }
   else 
   {
      WCHAR                * name = C->GetName(ps);
      if ( name )
      {
         err.MsgWrite(0,DCT_MSG_GENERIC_S,name);
      }
      else 
      {
         DisplaySid(ps);
      }
   }
}
/***************************************************************************************************/
//DispSidInfo:  Displays contents of the TSidNode

/***************************************************************************************************/
void 
   TRidNode::DisplaySidInfo() const
{
   err.DbgMsgWrite(0,L"\nRid A= %ld \nName= %S \nRid B= %ld\n",srcRid,acct_name,tgtRid);
   err.DbgMsgWrite(0,L"Owner changes:  %ld\n",owner_changes);
   err.DbgMsgWrite(0,L"Group changes:  %ld\n",group_changes);
   err.DbgMsgWrite(0,L"ACE changes:    %ld\n",ace_changes);
   err.DbgMsgWrite(0,L"SACE changes:   %ld\n",sace_changes);
   if ( !tgtRidIsValid ) 
      err.DbgMsgWrite(0,L"Target RID is not valid\n"); 
}
void 
   TAcctNode::DisplayStats() const
{
   LPWSTR res;
   if ( IsValidOnTgt() )
      res = L"";
   else
      res = (WCHAR*)GET_BSTR(IDS_UNRESOLVED);
   if (owner_changes || group_changes || ace_changes || sace_changes)
      err.MsgWrite(0,DCT_MSG_ACCOUNT_REFS_DATA_SDDDDS,owner_changes,group_changes,ace_changes,sace_changes,res);
}
void 
   TRidNode::DisplayStats() const
{
   LPWSTR res;
   if ( IsValidOnTgt() )
      res = L"";
   else
      res = (WCHAR*)GET_BSTR(IDS_UNRESOLVED);
#ifndef _DEBUG
   if (owner_changes || group_changes || ace_changes || sace_changes )
      err.MsgWrite(0,DCT_MSG_ACCOUNT_REFS_DATA_SDDDDS,acct_name,owner_changes,group_changes,ace_changes,sace_changes,res);
#else
   if (owner_changes || group_changes || ace_changes || sace_changes || true)
      err.DbgMsgWrite(0,L"%-35ls (%ld, %ld, %ld, %ld) %ls [%ld,%ld]",acct_name,owner_changes,group_changes,ace_changes,sace_changes,res,srcRid,tgtRid);
#endif
}


BOOL                                        // ret- TRUE if details reported, FALSE if skipped blank record 
   TAcctNode::ReportToVarSet(
      IVarSet              * pVarSet       ,// in - VarSet to write data to
      DWORD                  n              // in - index of account in varset
   ) 
{
   BOOL                      bRecorded = FALSE;

   if ( owner_changes || group_changes || ace_changes || sace_changes )
   {
      WCHAR                  key[200];

      swprintf(key,L"Stats.Accounts.%ld.Name",n);
      pVarSet->put(key,GetAcctName());

      swprintf(key,L"Stats.Accounts.%ld.Owners",n);
      pVarSet->put(key,(LONG)owner_changes);
            
      swprintf(key,L"Stats.Accounts.%ld.Groups",n);
      pVarSet->put(key,(LONG)group_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.ACEs",n);
      pVarSet->put(key,(LONG)ace_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.SACEs",n);
      pVarSet->put(key,(LONG)sace_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.Resolved",n);
      if ( IsValidOnTgt() )
      {
         pVarSet->put(key,L"Yes");
      }
      else
      {
         pVarSet->put(key,L"No");
      }

      bRecorded = TRUE;
   }
   return bRecorded;
}

/****************************************************************************************************/
/*                SIDTCache Implementation */
/***************************************************************************************************/
   TSDRidCache::TSDRidCache()
{
   from_sid       = NULL;
   to_sid         = NULL;
   from_domain[0] = 0;
   to_domain[0]   = 0;
   from_dc[0]     = 0;
   to_dc[0]       = 0;
   from_nsubs     = 0;
   to_nsubs       = 0;
   accts          = 0;
   accts_resolved = 0;
   m_otherAccounts = NULL;
   CompareSet(&CompN);       //start with an empty tree, to be sorted by acct_name
   TypeSetTree();
}

void 
   TSDRidCache::CopyDomainInfo( 
      TSDRidCache const    * other
   )
{
   from_nsubs = other->from_nsubs;
   to_nsubs = other->to_nsubs;
   from_sid = NULL;
   to_sid = NULL;

   if ( other->from_sid )
      from_sid = malloc(GetSidLengthRequired(from_nsubs));
   if ( other->to_sid )
      to_sid = malloc(GetSidLengthRequired(to_nsubs));

   if ( from_sid )
      CopySid(GetSidLengthRequired(from_nsubs),from_sid,other->from_sid);
   if ( to_sid )
      CopySid(GetSidLengthRequired(to_nsubs),to_sid,other->to_sid);
   
   safecopy(from_domain,other->from_domain);
   safecopy(to_domain,other->to_domain);
   safecopy(from_dc,other->from_dc);
   safecopy(to_dc,other->to_dc);
}

void 
   TSDRidCache::Clear()
{
   TRidNode               * node;
   
   for ( node = (TRidNode *)Head() ;  node ; Remove(node) , free(node), node = (TRidNode *)Head() )
   ;

   accts = 0;
   accts_resolved = 0;
}
   
   TSDRidCache::~TSDRidCache()
{
   if ( from_sid ) 
   {
      free(from_sid);
      from_sid = NULL;
   }
   if ( to_sid )
   {
      free(to_sid);
      to_sid = NULL;
   }
   // empty the list, and free each node
   TRidNode               * node;
   for ( node = (TRidNode *)Head() ;  node ; Remove(node) , free(node), node = (TRidNode *)Head() )
   ;
   if ( m_otherAccounts )
      delete m_otherAccounts;
   }
/***************************************************************************************************/
/* SizeDiff: 
            Returns (Length of Domain B SID) - (Length of Domain A SID)
                     if Domain B sids are longer, otherwise returns 0
         This is used to figure out how much space to allocate for new SIDs in the ACEs
         This function assumes that from_sid and to_sid (from_nsubs and to_nsubs) are valid
/***************************************************************************************************/ 
DWORD 
   TSDRidCache::SizeDiff(
      const TAcctNode *  tnode      // in -this parameter is not used for TSDRidCache
   ) const 
{
   assert( from_sid );        // not having from_sid or to_sid should abort the program
   assert( to_sid );

   DWORD                     fromsize = GetSidLengthRequired(from_nsubs);
   DWORD                     tosize   = GetSidLengthRequired(to_nsubs);
   DWORD                     retval;
   if ( fromsize >= tosize )
   {
      retval = 0;
   }
   else 
   {
      retval = tosize - fromsize;
   }
   return retval;
}

/*****************************************************************************************************/
/*   DomainizeSidFst: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSidFst(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   ) 
{
   assert (psid);

   UCHAR                     len = (* GetSidSubAuthorityCount(psid));
   PDWORD                    sub = GetSidSubAuthority(psid,len-1);
   
   if ( *sub != -1 )
   {
      DWORD                  sdsize = GetSidLengthRequired(len+1);  // sid doesn't already have -1 as rid
      PSID                   newsid = (SID *)malloc(sdsize); // copy the sid, and add -1 to the end
	  if (!newsid)
	  {
         assert(false);
	     return psid;
	  }
   
      if ( ! InitializeSid(newsid,GetSidIdentifierAuthority(psid),len+1) )  // make a bigger sid w/same IA
      {
         err.SysMsgWrite(ErrU,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         assert (false);
      }
      for ( DWORD i = 0 ; i < len ; i++ )
      {
         sub = GetSidSubAuthority(newsid,i);                        // copy subauthorities
         (*sub) = (*GetSidSubAuthority(psid,i));
      }
      sub = GetSidSubAuthority(newsid,len);
      *sub = -1;                                                  // set rid =-1
      if ( freeOldSid )
      {
         free(psid);
      }
      psid = newsid;
      len++;
   }
  return psid;   
}            

void 
   SetDomainInfoStructFromSid(
      PSID                  pSid,          // in -sid for domain
      SDRDomainInfo       * info           // out-struct containing information
   )
{
//   if ( (pSid) )
   if ( IsValidSid(pSid) )
   {
      info->domain_name[0] = 0;
      info->dc_name[0] = 0;
      info->domain_sid = DomainizeSidFst(pSid,FALSE/*don't free old sid*/);
      info->nsubs = *GetSidSubAuthorityCount(info->domain_sid);
      info->valid = TRUE;
   }
   else
   {
//      info->domain_name[0] = 0;
//      info->dc_name[0] = 0;
//      info->valid = TRUE;
      err.MsgWrite(ErrE,DCT_MSG_INVALID_DOMAIN_SID);
      info->valid = FALSE;
   }

}
void                                         
   SetDomainInfoStruct(
      WCHAR const *         domname,        // in -name of domain
      SDRDomainInfo       * info            // in -struct to put info into
   )
{
   DWORD                    rc = 0;
   WCHAR                    domain[LEN_Computer];
   BOOL                     found = FALSE;
   WCHAR                  * computer = NULL;


   safecopy(domain,domname);
   
   info->valid = FALSE;
   safecopy(info->domain_name, domname);
   // get the domain controller name
   if ( GetDomainDCName(domain,&computer) )
   {
      safecopy(info->dc_name,computer);
      NetApiBufferFree(computer);
   }
   else
   {
      rc = GetLastError();
   }

   if ( ! rc )
   {
      // Get the SID for the domain
      WCHAR                  strDomain[LEN_Domain];
      DWORD                  lenStrDomain = DIM(strDomain);
      SID_NAME_USE           snu;
      BYTE                   sid[200];
      DWORD                  lenSid = DIM(sid);

      if ( LookupAccountName(info->dc_name,info->domain_name,sid,&lenSid,strDomain,&lenStrDomain,&snu) )
      {
         info->domain_sid = DomainizeSidFst(sid, FALSE /*don't free sid*/);
         info->nsubs = *GetSidSubAuthorityCount(info->domain_sid);
         info->valid = TRUE;
         found = TRUE;
      }
      else 
      {
         rc = GetLastError();
      }
   }
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_DOMAIN_GET_INFO_FAILED_S,domain);
   }
} 

int 
   TSDRidCache::SetDomainInfoWithSid(
      WCHAR          const * strDomain,    // in -domain name
      WCHAR          const * strSid,       // in -textual representation of sid
      bool                   firstdom      // in -flag:  (true => source domain),  (false => target domain)
   )
{
   SDRDomainInfo             info;
   PSID                      pSid = SidFromString(strSid);

   SetDomainInfoStructFromSid(pSid,&info);
   if ( info.valid )
   {
      if ( firstdom )
      {
         safecopy(from_domain,strDomain);
         from_sid = info.domain_sid;
         from_dc[0] = 0;
         from_nsubs = info.nsubs;
      
      }
      else
      {
         safecopy(to_domain,strDomain);
         to_sid = info.domain_sid;
         to_dc[0] =0;
         to_nsubs = info.nsubs;
      }


   }
   FreeSid(pSid);
   return info.valid;
}
/*****************************************************************************************************/
/* SetDomainInfo: 
         sets either ( from_domain, from_sid, from_dc, from_nsubs) if ( firstdom )
              or     ( to_domain, to_sid, to_dc, to_nsubs)         if ( ! firstdom)
/*****************************************************************************************************/
int                                         // ret -true if members were set, false otherwise 
   TSDRidCache::SetDomainInfo(
      WCHAR const *          domname,       // in -name of domain
      bool                   firstdom       // in -flag:  (true => source domain),  (false => target domain)
   )
{
   
   SDRDomainInfo           info;
   
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )                                  // we have good information to store
   {
      if ( firstdom )
      {
         safecopy(from_domain,info.domain_name);
         from_sid = info.domain_sid;
         safecopy(from_dc,info.dc_name);
         from_nsubs = info.nsubs;
      }
      else
      {
         safecopy(to_domain,info.domain_name);
         to_sid = info.domain_sid;
         safecopy(to_dc,info.dc_name);
         to_nsubs = info.nsubs;
      }
   }
   return info.valid;                           
}

LPWSTR
   TGeneralCache::GetName(
      const PSID             psid      // in - SID to lookup account name for
   ) 
{     
   TGeneralSidNode         * tn = (TGeneralSidNode*)Lookup(psid);

   if ( tn ) 
      return tn->GetAcctName();
   else 
      return NULL;
}

TAcctNode * 
   TGeneralCache::Lookup( 
      const PSID             psid      // in - SID to lookup account name for
   )
{
   TGeneralSidNode         * tn = (TGeneralSidNode*)Find(&vSidComp,psid);

   return (TAcctNode *)tn;   
}
/***************************************************************************************************/
/* Lookup: takes a sid, checks whether it came from domain A.  If so, it finds the corresponding entry
           in the cache, and returns that node.
   
   Returns:  Pointer to TSidNode whose domain A rid matches asid's rid,
             or NULL if not a domain A sid, or not found in the cache
/***************************************************************************************************/ 
TAcctNode *
   TSDRidCache::Lookup(
      const PSID             psid // in -sid to search for 
   )  
                                                   
{
   TRidNode                * tn = NULL;
   DWORD                     rid = 0;
   BOOL                      bFromSourceDomain;
   UCHAR                   * pNsubs;
   DWORD                     nsubs;
   TAcctNode               * anode = NULL;
   assert( IsValidSid(psid) );
   assert ( IsValidSid(from_sid) );
   
   pNsubs = GetSidSubAuthorityCount(psid);
   if ( pNsubs )
   {
      nsubs = (*pNsubs);
   }
   else
   {
      assert(false);
      return NULL;
   }

   rid = (* GetSidSubAuthority(psid,nsubs - 1) );
      
//   if ((!from_sid) || (EqualPrefixSid(psid,from_sid)))   // first check whether asid matches the from-domain
   if ( EqualPrefixSid(psid,from_sid) )   // first check whether asid matches the from-domain
   {
      bFromSourceDomain = TRUE;
      tn = (TRidNode *)Find(&vRidComp,&rid);
      anode = tn;
   }
   else
   {
      bFromSourceDomain = FALSE;
   }
   if (! tn )
   {
      tn = (TRidNode *)-1;
      if ( AddIfNotFound() && ! BuiltinRid(rid) )  // Don't lookup builtin accounts
      {
         if ( ! m_otherAccounts )
         {
            m_otherAccounts = new TGeneralCache();
			if (!m_otherAccounts)
			{
               assert(false);
               return NULL;
			}
         }
         TGeneralSidNode * sn = (TGeneralSidNode *)m_otherAccounts->Lookup(psid);
         if ( ! sn )
         {
            sn = new TGeneralSidNode(psid,NULL);
			if (!sn)
			{
               assert(false);
               return NULL;
			}
            m_otherAccounts->TreeInsert(sn);
         }
         anode = (TAcctNode*)sn;
      }
   }
   
   return anode;
}
/***************************************************************************************************/
/* GetName:  Calls SidCache::Lookup, and returns the acct name from the resulting node
/***************************************************************************************************/
LPWSTR                        // ret -acct_name, or NULL if not found
   TSDRidCache::GetName(
      const PSID             psid               // in -sid to look for
   ) 
{
   TAcctNode               * tn = Lookup(psid);
   LPWSTR                    retval;

   if ( tn )
      retval = tn->GetAcctName();
   else 
      retval = NULL;
   return retval;
}

/***************************************************************************************************/
/* LookupWODomain: takes a sid, checks whether it came from domain A.  If so, it finds the corresponding entry
           in the cache, and returns that node.  This lookup function is used if the
		   src domain sid has not been recorded (like in the case of using a sID mapping file).
   
   Returns:  Pointer to TSidNode whose domain A rid matches asid's rid,
             or NULL if not a domain A sid, or not found in the cache
/***************************************************************************************************/ 
TAcctNode *
   TSDRidCache::LookupWODomain(
      const PSID             psid // in -sid to search for 
   )  
                                                   
{
   TRidNode                * tn = NULL;
   DWORD                     rid = 0;
   BOOL                      bFound = FALSE;
   UCHAR                   * pNsubs;
   DWORD                     nsubs;
   TAcctNode               * anode = NULL;
   assert( IsValidSid(psid) );
   
   pNsubs = GetSidSubAuthorityCount(psid);
   if ( pNsubs )
   {
      nsubs = (*pNsubs);
   }
   else
   {
      assert(false);
      return NULL;
   }

   rid = (* GetSidSubAuthority(psid,nsubs - 1) );
   
      //while not found and more that match the rid, find the next
//   do
//   {
	     //look for a matching Rid
      tn = (TRidNode *)Find(&vRidComp,&rid);
	     //if we found a matching Rid, compare the domain part of the sid for a real match
	  if (tn)
	  {
		    //get the source domain sid of the matching Rid node
		 PSID src_sid = SidFromString(tn->GetSrcDomSid());
         if ((src_sid) && (EqualPrefixSid(psid,src_sid)))   // check whether asid matches the source domain
		 {
            bFound = TRUE;
            anode = tn;
		 }
		 if (src_sid)
		    FreeSid(src_sid);
	  }//end if Rid match
//   } while ((!bFound) && (tn));  //end while no match
   
   return anode;
}
//END LookupWODomain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\stargs.hpp ===
/*---------------------------------------------------------------------------
  File: STArgs.hpp

  Comments: Arguments that define the settings for FST or EST translation.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 10/14/98 15:35:59

 ---------------------------------------------------------------------------
*/

#ifndef __STARGS_HPP__
#define __STARGS_HPP__

#define REPLACE_SECURITY         (1)
#define ADD_SECURITY             (2)
#define REMOVE_SECURITY          (3)


#define SUMMARYSTATS             (0x00000001)
#define ACCOUNTSTATS             (0x00000002)
#define FILESTATS                (0x00000004)
#define PATHSTATS                (0x00000008)
#define MORESTATS                (0x00000010)
#define MASSIVEINFO              (0x00000020)

#define TRANSLATE_FILES          (0x00000001)
#define TRANSLATE_SHARES         (0x00000002)
#define TRANSLATE_MAILBOXES      (0x00000004)
#define TRANSLATE_CONTAINERS     (0x00000008)  
#define TRANSLATE_LGROUPS        (0x00000010) 
#define TRANSLATE_USERRIGHTS     (0x00000020)
#define TRANSLATE_USERPROFILES   (0x00000040)
#define TRANSLATE_PRINTERS       (0x00000080)
#define TRANSLATE_RECYCLER       (0x00000100)
#define TRANSLATE_REGISTRY       (0x00000200)

#include "sidcache.hpp"
#include "EnumVols.hpp"
#include "Common.hpp"
#include "UString.hpp"

class SecurityTranslatorArgs
{
   WCHAR                     m_source[LEN_Computer];
   WCHAR                     m_target[LEN_Computer];
   WCHAR                     m_logfile[LEN_Path];
   DWORD                     m_verbnum;

   BOOL                      m_nochange;
   DWORD                     m_translationMode;
   DWORD                     m_whichObjects;

   TPathList                 m_pathlist;
   
   TSDRidCache               m_cache;
   
   bool                      m_needtoverify;
   bool                      m_invalid;
   bool                      m_IsLocalSystem;
   bool                      m_bUseMapFile;

public:
   bool                      m_bUndo;

   SecurityTranslatorArgs() { Reset(); }

   WCHAR const *  Source() const { return m_source; }
   WCHAR const *  Target() const { return m_target; }
   WCHAR const *  LogFile() const { return m_logfile; }
   TSDRidCache *  Cache() { return &m_cache; }
   TPathList   *  PathList() { return &m_pathlist; }
   BOOL           NoChange() const { return m_nochange;}
   BOOL           Verified() const { return !m_needtoverify; }
   BOOL           IsLocalSystem() const { return m_IsLocalSystem; }
   BOOL           LogFileDetails() { return m_verbnum & FILESTATS; }
   BOOL           LogVerbose() { return m_verbnum & MORESTATS; }
   BOOL           LogMassive() { return m_verbnum & MASSIVEINFO; }
   BOOL           LogSummary() { return m_verbnum & SUMMARYSTATS; }
   BOOL           LogAccountDetails() { return m_verbnum & ACCOUNTSTATS; }
   BOOL           LogPathDetails() { return m_verbnum & PATHSTATS; }
   DWORD          LogSettings() { return m_verbnum; }
   
   DWORD          TranslationMode() { return m_translationMode; }

   BOOL           TranslateFiles() { return m_whichObjects & TRANSLATE_FILES; }
   BOOL           TranslateShares() { return m_whichObjects & TRANSLATE_SHARES; }
   BOOL           TranslateMailboxes() { return m_whichObjects & TRANSLATE_MAILBOXES; }
   BOOL           TranslateContainers() { return m_whichObjects & TRANSLATE_CONTAINERS; }
   BOOL           TranslateLocalGroups() { return m_whichObjects & TRANSLATE_LGROUPS; }
   BOOL           TranslateUserRights() { return m_whichObjects & TRANSLATE_USERRIGHTS; }
   BOOL           TranslateUserProfiles() { return m_whichObjects & TRANSLATE_USERPROFILES; }
   BOOL           TranslatePrinters() { return m_whichObjects & TRANSLATE_PRINTERS; }
   BOOL           TranslateRecycler() { return m_whichObjects & TRANSLATE_RECYCLER; }
   BOOL           TranslateRegistry() { return m_whichObjects & TRANSLATE_REGISTRY; }
   BOOL           UsingMapFile() const { return m_bUseMapFile; }

   void Source(WCHAR const * source) { safecopy(m_source,source); }
   void Target(WCHAR const * target) { safecopy(m_target,target); }
   void LogFile(WCHAR const * logfile) { safecopy(m_logfile,logfile); }
   void Verified(BOOL done) { m_needtoverify = !done; }
   void SetLogging(DWORD vn) { m_verbnum = vn; }
   void SetTranslationMode(DWORD mode) { m_translationMode = mode; }
   void SetWriteChanges(BOOL write) { m_nochange = !write; }
   void SetInvalid() { m_invalid = true; }
   void TranslateFiles(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_FILES : m_whichObjects &= ~TRANSLATE_FILES; }
   void TranslateShares(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_SHARES : m_whichObjects &= ~TRANSLATE_SHARES; }
   void TranslateMailboxes(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_MAILBOXES : m_whichObjects &= ~TRANSLATE_MAILBOXES; }
   void TranslateContainers(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_CONTAINERS : m_whichObjects &= ~TRANSLATE_CONTAINERS; }
   void TranslateLocalGroups(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_LGROUPS : m_whichObjects &= ~TRANSLATE_LGROUPS; }
   void TranslateUserRights(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_USERRIGHTS : m_whichObjects &= ~TRANSLATE_USERRIGHTS; }
   void TranslateUserProfiles(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_USERPROFILES : m_whichObjects &= ~TRANSLATE_USERPROFILES; }
   void TranslatePrinters(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_PRINTERS : m_whichObjects &= ~TRANSLATE_PRINTERS; }
   void TranslateRecycler(BOOL bTranslate)  { bTranslate ? m_whichObjects |= TRANSLATE_RECYCLER : m_whichObjects &= ~TRANSLATE_RECYCLER; }
   void TranslateRegistry(BOOL bTranslate)  { bTranslate ? m_whichObjects |= TRANSLATE_REGISTRY : m_whichObjects &= ~TRANSLATE_REGISTRY; }
   void SetLocalMode(BOOL bLocal) { m_IsLocalSystem = ( bLocal == TRUE); }

   void Reset() { m_invalid = FALSE; m_needtoverify = TRUE; m_source[0]=0; m_target[0]=0;
                  m_IsLocalSystem = FALSE; m_logfile[0]=0; m_verbnum = SUMMARYSTATS | ACCOUNTSTATS | FILESTATS; 
                  m_nochange = FALSE; m_translationMode = REPLACE_SECURITY; 
                  m_whichObjects = TRANSLATE_FILES; m_pathlist.Clear(); m_cache.Clear();
                  m_cache.TypeSetTree(); m_bUndo = false; m_bUseMapFile = false;
   }

   BOOL        IsValid() { return (*m_source && *m_target && m_pathlist.Count() && !m_invalid) ; }
   void SetUsingMapFile(BOOL bUsing) { m_bUseMapFile = ( bUsing == TRUE); }
};


#endif //__STARGS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\statobj.cpp ===
/*---------------------------------------------------------------------------
  File: StatusObj.h

  Comments: COM object used internally by the engine to track whether a job
  is running, or finished, and to provide a mechanism for aborting a job.

  This COM object simply has a single property which reflects the state of a
  migration job (Not started, Running, Aborted, Finished, etc.)

  The agent will set the status to running, or finished, as appropriate.
  If the client cancels the job, the engine's CancelJob function will change the 
  status to 'Aborting'. 

  Each helper object that performs a lengthy operation, such as account replication, or 
  security translation is responsible for periodically checking the status object to see
  if it needs to abort the task in progress.  The engine itself will check between migration
  tasks to see if the job has been aborted.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/18/99 

 ---------------------------------------------------------------------------
*/  
// StatusObj.cpp : Implementation of CStatusObj
#include "stdafx.h"
#include "WorkObj.h"
#include "StatObj.h"

/////////////////////////////////////////////////////////////////////////////
// CStatusObj


STDMETHODIMP CStatusObj::get_Status(LONG *pVal)
{
	m_cs.Lock();
   (*pVal) = m_Status;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CStatusObj::put_Status(LONG newVal)
{
	m_cs.Lock();
   m_Status = newVal;
   m_cs.Unlock();
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\statobj.h ===
/*---------------------------------------------------------------------------
  File: StatusObj.h

  Comments: COM object used internally by the engine to track whether a job
  is running, or finished, and to provide a mechanism for aborting a job.

  The agent will set the status to running, or finished, as appropriate.
  If the client cancels the job, the engine's CancelJob function will change the 
  status to 'Aborting'. 

  Each helper object that performs a lengthy operation, such as account replication, or 
  security translation is responsible for periodically checking the status object to see
  if it needs to abort the task in progress.  The engine itself will check between migration
  tasks to see if the job has been aborted.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/18/99 

 ---------------------------------------------------------------------------
*/ 
	
// StatusObj.h : Declaration of the CStatusObj

#ifndef __STATUSOBJ_H_
#define __STATUSOBJ_H_

#include "resource.h"       // main symbols
#include "DCTStat.h"
/////////////////////////////////////////////////////////////////////////////
// CStatusObj
class ATL_NO_VTABLE CStatusObj : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStatusObj, &CLSID_StatusObj>,
	public IDispatchImpl<IStatusObj, &IID_IStatusObj, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CStatusObj()
	{
		m_pUnkMarshaler = NULL;
      m_Status = 0;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STATUSOBJ)
DECLARE_NOT_AGGREGATABLE(CStatusObj)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStatusObj)
	COM_INTERFACE_ENTRY(IStatusObj)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IStatusObj
public:
	STDMETHOD(get_Status)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_Status)(/*[in]*/ LONG newVal);

protected:
   LONG                      m_Status;
   CComAutoCriticalSection   m_cs;
   
};

#endif //__STATUSOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\sidcache.hpp ===
//#pragma title ("SidCache.hpp -- Cache, Tree of SIDs")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sidcache.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Cache of SIDs.  Implemented using TNode derived classes, Cache is 
               organized as a tree, sorted by Domain B RID.  Each node contains 
               Domain A RID, Domain B RID, Account Name, and counters for stats.  
Updates     -
===============================================================================
*/
#ifndef TSIDCACHE_HEADER 
#define TSIDCACHE_HEADER

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif

//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")//#imported below via sdstat.hpp

#include "DCTStat.h"
#include "WorkObj.h"
#include "sdstat.hpp"

#ifndef IStatusObjPtr
_COM_SMARTPTR_TYPEDEF(IStatusObj, __uuidof(IStatusObj));
#endif

//#define ACCOUNT_NAME_LENGTH 256
#define NUM_IN_BUF 5000  /* the number of accounts to get at one time NetQueryDisplayInfo()*/
#define BUFSIZE  100000  /* preferred max size of buffer for receiving accounts NetQueryDisplayInfo()*/ 
#define DEFAULT_SID_SIZE 500


#define EALB_OCX_LOCAL_USER      13
#define EALB_OCX_GLOBAL_USER     14
#define EALB_OCX_LOCAL_GROUP     16
#define EALB_OCX_GLOBAL_GROUP    17
 


#define FST_CACHE_SOME_SOURCE 1
#define FST_CACHE_NO_TARGET   2
#define FST_CACHE_SOME_TARGET 4
#define FST_CACHE_NO_DOMAIN   8
   
class TAcctNode:public TNode
{

protected:
   DWORD                     owner_changes;	    // Stats for each node
   DWORD                     group_changes;       
   DWORD                     ace_changes;
   DWORD                     sace_changes;                     
 
public:
                     TAcctNode();
   virtual WCHAR *   GetAcctName()  = 0;
   virtual  bool     IsValidOnTgt() const = 0;
   
   virtual void      AddOwnerChange(objectType type) { owner_changes++; }             // Stats functions 
   virtual void      AddGroupChange(objectType type) { group_changes++; }
   virtual void      AddAceChange(objectType type)   { ace_changes++;   }
   virtual void      AddSaceChange(objectType type)  { sace_changes++;  }
   virtual void      DisplayStats() const;    
   DWORD             OwnerChanges() { return owner_changes; }
   DWORD             GroupChanges() { return group_changes; }
   DWORD             DACEChanges() { return ace_changes; }
   DWORD             SACEChanges() { return sace_changes; }
   BOOL              ReportToVarSet(IVarSet * pVarSet, DWORD n);
};                              
class TRidNode:public TAcctNode
{
protected:
   DWORD                     srcRid;               // RID for domain A
   DWORD                     tgtRid;               // RID for domain B
   bool                      tgtRidIsValid;				
   short                     acct_type;
   int                       acct_len;              // length of account name
   WCHAR                     srcDomSid[MAX_PATH];   // source domain sid
   WCHAR                     tgtDomSid[MAX_PATH];   // target domain sid
   WCHAR                     srcDomName[MAX_PATH];  // source domain name
   WCHAR                     tgtDomName[MAX_PATH];  // target domain name
   WCHAR                     acct_name[1];          // source account name \0 target account name
  
public:
   void *                operator new(size_t sz,const LPWSTR name1,const LPWSTR name2);
                     TRidNode(const LPWSTR oldacctname, const LPWSTR newacctname);     
                     ~TRidNode();                                               
   WCHAR *           GetAcctName() { return acct_name; }   // member "Get" functions
   WCHAR *           GetTargetAcctName() { return acct_name + acct_len + 1; }
   DWORD             SrcRid() const { return srcRid; }
   DWORD             TgtRid() const { return tgtRid; }
   bool              IsValidOnTgt() const { return tgtRidIsValid; }
   short             Type() { return acct_type; }
   void              Type(short newtype) { acct_type = newtype; }
   void              MarkInvalidOnTgt() { tgtRidIsValid = false; }
   void              SrcRid(DWORD const val) { srcRid=val; }             // member "Set" functions
   void              TgtRid(DWORD const val) { tgtRid=val; tgtRidIsValid=true;} 
   void              DisplayStats() const;    
   void              DisplaySidInfo() const;
   WCHAR *           GetSrcDomSid() { return srcDomSid; }   // member "Get" function
   WCHAR *           GetTgtDomSid() { return tgtDomSid; }   // member "Get" function
   void              SrcDomSid(const LPWSTR sSid) { wcscpy(srcDomSid,sSid); }       // member "Set" function
   void              TgtDomSid(const LPWSTR sSid) { wcscpy(tgtDomSid,sSid); }       // member "Set" function
   WCHAR *           GetSrcDomName() { return srcDomName; }   // member "Get" function
   WCHAR *           GetTgtDomName() { return tgtDomName; }   // member "Get" function
   void              SrcDomName(const LPWSTR sName) { wcscpy(srcDomName,sName); }       // member "Set" function
   void              TgtDomName(const LPWSTR sName) { wcscpy(tgtDomName,sName); }       // member "Set" function
   
protected:
   
};

class TGeneralSidNode:public TAcctNode
{
protected:
   LPWSTR                  src_acct_name;
   LPWSTR                  tgt_acct_name;
   PSID                    src_sid;
   PSID                    tgt_sid;
   UCHAR                   src_nsubs;
   UCHAR                   tgt_nsubs;
   WCHAR                 * src_domain;
   WCHAR                 * tgt_domain;
   DWORD                   sizediff;
   TSDFileDirCell          ownerStats;
   TSDFileDirCell          groupStats;
   TSDFileDirCell          daclStats;
   TSDFileDirCell          saclStats;

public:   
                     TGeneralSidNode(const LPWSTR name1, const LPWSTR name2);
                     TGeneralSidNode(const PSID pSid1, const PSID pSid2);
                     ~TGeneralSidNode();
   LPWSTR            GetAcctName() { return src_acct_name; }
   PSID              SrcSid() { return src_sid; }
   PSID              TgtSid() { return src_sid; /* this is a hack to allow for counting all references to accounts */ }
                                                   
   bool              IsValidOnTgt() const { return TRUE;/*tgt_sid != NULL;*/ }
   void              DisplaySidInfo() const;    
   DWORD             SizeDiff() const { return 0; } 
   TSDFileDirCell  * GetOwnerStats() { return &ownerStats; }
   TSDFileDirCell  * GetGroupStats() { return &groupStats; }
   TSDFileDirCell  * GetDaclStats() { return &daclStats; }
   TSDFileDirCell  * GetSaclStats() { return &saclStats; }
   virtual void      AddOwnerChange(objectType type) 
   { 
      switch (type) 
      {
         case file:        ownerStats.file++;      break;
         case directory:   ownerStats.dir++;       break;
         case mailbox:     ownerStats.mailbox++;   break;
         case container:   ownerStats.container++; break;
         case share:       ownerStats.share++;     break;
         case groupmember: ownerStats.member++;    break;
         case userright:   ownerStats.userright++; break;
         case regkey:      ownerStats.regkey++;    break;
         case printer:     ownerStats.printer++;   break;
          default:
            break;
      };
   }
   
   virtual void      AddGroupChange(objectType type)
   {
      switch (type) 
      {
         case file:        groupStats.file++;      break;
         case directory:   groupStats.dir++;       break;
         case mailbox:     groupStats.mailbox++;   break;
         case container:   groupStats.container++; break;
         case share:       groupStats.share++;     break;
         case groupmember: groupStats.member++;    break;
         case userright:   groupStats.userright++; break;
         case regkey:      groupStats.regkey++;    break;
         case printer:     groupStats.printer++;   break;
          default:
            break;
      };
   }

   virtual void      AddAceChange(objectType type)  
   {
      switch (type) 
      {
         case file:        daclStats.file++;      break;
         case directory:   daclStats.dir++;       break;
         case mailbox:     daclStats.mailbox++;   break;
         case container:   daclStats.container++; break;
         case share:       daclStats.share++;     break;
         case groupmember: daclStats.member++;    break;
         case userright:   daclStats.userright++; break;
         case regkey:      daclStats.regkey++;    break;
         case printer:     daclStats.printer++;   break;
          default:
            break;
      };
   }
   virtual void      AddSaceChange(objectType type) 
   {
      switch (type) 
      {
         case file:        saclStats.file++;      break;
         case directory:   saclStats.dir++;       break;
         case mailbox:     saclStats.mailbox++;   break;
         case container:   saclStats.container++; break;
         case share:       saclStats.share++;     break;
         case groupmember: saclStats.member++;    break;
         case userright:   saclStats.userright++; break;
         case regkey:      saclStats.regkey++;    break;
         case printer:     saclStats.printer++;   break;
          default:
            break;
      };
   }
   
};

   
/**************************************************************************************************/
/*       TSidCache:  Cache for SIDs.  
         
         The cache is filled by calling FillCache(name_of_domain_A, name_of_domain_B)
         
         Lookup, and GetName search the tree for a domain B SID value.  
         Lookup returns a pointer to the node, while GetName returns the account
                name for the node.
         
         GetSidB( tsidnode *) builds and returns the domain B SID for the node (the node contains only the RID)

         SizeDiff() returns the answer to "How much bigger are domain B sids than domain A sids?"
                    this information is needed when allocating space for ACES.
                    
/**************************************************************************************************/

class TAccountCache: public TNodeListSortable
{
   IStatusObjPtr            m_pStatus;
public:
 
   TAccountCache() { m_cancelled = false; m_bAddIfNotFound = FALSE; }
   ~TAccountCache() {}
virtual TAcctNode       * Lookup(const PSID psid) = 0;                        // sid lookup functions
virtual LPWSTR            GetName(const PSID psid) = 0;
//virtual BOOL              Insert(const LPWSTR acctname,DWORD srcSid, DWORD tgtSid) = 0;
virtual PSID              GetTgtSid(const TAcctNode* tnode) = 0;
virtual DWORD             SizeDiff(const TAcctNode *tnode) const = 0;            // returns max( 0 , (length(to_sid) - length(from_sid)) )     
   bool                   IsCancelled() 
   { 
      if ( m_pStatus ) 
      {
         LONG    status = 0;
//         HRESULT hr = m_pStatus->get_Status(&status);
         m_pStatus->get_Status(&status);

         return (status == DCT_STATUS_ABORTING);
      }
      else 
      {
         return m_cancelled; 
      }
   }
   void                   Cancel() { m_cancelled = true; if ( m_pStatus ) m_pStatus->put_Status(DCT_STATUS_ABORTING); }
   void                   UnCancel() { m_cancelled = false; }
   void                   AddIfNotFound(BOOL val) { m_bAddIfNotFound = val; }
   BOOL                   AddIfNotFound() { return m_bAddIfNotFound; }
   void                   SetStatusObject(IStatusObj * pS) { m_pStatus = pS; }
protected:
   bool                   m_cancelled;
   BOOL                   m_bAddIfNotFound;   
};

class TGeneralCache;

class TSDRidCache: public TAccountCache
{
protected:
   WCHAR                     from_domain[MAX_PATH + 1];             // domain names
   WCHAR                     to_domain[MAX_PATH + 1];
   WCHAR                     from_dc[MAX_PATH + 1];                 // domain controller (machine) names
   WCHAR                     to_dc[MAX_PATH + 1];
   PSID                      from_sid;                                 // domain sids (dynamically allocated)
   PSID                      to_sid;                        
   UCHAR                     from_nsubs;                               // # subauthorities in domain sids
   UCHAR                     to_nsubs;
   DWORD                     accts;                                    // statistical stuff
   DWORD                     accts_resolved;
   TGeneralCache           * m_otherAccounts;
   
public: 
                     TSDRidCache();
                     ~TSDRidCache();
                        // filling methods
   WCHAR     const * GetSourceDomainName() { return from_domain; }
   WCHAR     const * GetTargetDomainName() { return to_domain; }
   WCHAR     const * GetSourceDCName() { return from_dc; }
   WCHAR     const * GetTargetDCName() { return to_dc; }
   void              InsertLast(const LPWSTR acctname,DWORD rida, const LPWSTR newname, DWORD ridb, short type = 0)
						{ TRidNode * tn = new (acctname,newname) TRidNode(acctname,newname); if (tn){tn->SrcRid(rida); tn->TgtRid(ridb);
						tn->Type(type); if ( ridb == 0 ) tn->MarkInvalidOnTgt(); else accts_resolved++; accts++; TNodeListSortable::InsertBottom((TNode *)tn); }}
   void              InsertLastWithSid(const LPWSTR acctname, const LPWSTR srcdomainsid, const LPWSTR srcdomainname, DWORD rida, const LPWSTR newname, 
	                                   const LPWSTR tgtdomainsid, const LPWSTR tgtdomainname, DWORD ridb, short type = 0)
						{ TRidNode * tn = new (acctname,newname) TRidNode(acctname,newname); if (tn){tn->SrcRid(rida); tn->TgtRid(ridb);
					   tn->SrcDomSid(srcdomainsid); tn->TgtDomSid(tgtdomainsid); tn->SrcDomName(srcdomainname); tn->TgtDomName(tgtdomainname);
                       tn->Type(type); if ( ridb == 0 ) tn->MarkInvalidOnTgt(); else accts_resolved++; accts++; TNodeListSortable::InsertBottom((TNode *)tn); }}
                     
   TAcctNode       * Lookup(const PSID psid);                           // sid lookup functions
   TAcctNode       * LookupWODomain(const PSID psid);                           // sid lookup functions
   LPWSTR            GetName(const PSID psid);
   
   // helper methods
   PSID              GetTgtSid(TAcctNode const * tnode) ;                   // "Get" functions
   DWORD             SizeDiff(const TAcctNode *tnode) const ;                        // returns max( 0 , (length(to_sid) - length(from_sid)) )     
   void              Display(bool summary, bool detail);
   void              ReportToVarSet(IVarSet * pVarSet,bool summary, bool detail);
   PSID              GetTgtSid(const PSID psid) { return GetTgtSid(Lookup(psid)); }
   void              CopyDomainInfo( TSDRidCache const * other);
   PSID              GetTgtSidWODomain(TAcctNode const * tnode);                   // "Get" functions
   PSID              GetTgtSidWODomain(const PSID psid) { return GetTgtSid(LookupWODomain(psid)); }   // "Get" functions
  
   DWORD             GetNumAccts() const {return accts; }
   DWORD             GetNumResolvedAccts() const { return accts_resolved; } 
   void              Clear();
   void              SetSourceAndTargetDomains(WCHAR const * src, WCHAR const * tgt) { SetDomainInfo(src,true); SetDomainInfo(tgt,false); }
   void              SetSourceAndTargetDomainsWithSids(WCHAR const * src, WCHAR const * srcSid, WCHAR const * tgt,WCHAR const * tgtSid)
                     { SetDomainInfoWithSid(src,srcSid,true); SetDomainInfoWithSid(tgt,tgtSid,false); }
   void              ReportAccountReferences(WCHAR const * filename);
   BOOL              IsInitialized() { return from_sid!=NULL && to_sid!=NULL; }
   
protected: 
   int               SetDomainInfo(WCHAR const * domname, bool firstdom);   
   int               SetDomainInfoWithSid(WCHAR const * domainName, WCHAR const * domainSid, bool firstdom);
   
};

class TGeneralCache : public TAccountCache
{
protected:
   DWORD                     accts;                                    // statistical stuff
   DWORD                     accts_resolved;
public:
   TGeneralCache();
   ~TGeneralCache();
   TAcctNode       * Lookup(const PSID psid) ;                        // sid lookup functions
   LPWSTR            GetName(const PSID psid) ;
   BOOL              Insert(const LPWSTR acctname1,const LPWSTR acctname2,PSID sid1, PSID sid2);
   PSID              GetTgtSid(const TAcctNode* tnode)  { return ((TGeneralSidNode *)tnode)->TgtSid(); }
   DWORD             SizeDiff(const TAcctNode *tnode) const { return ((TGeneralSidNode *)tnode)->SizeDiff(); }            // returns max( 0 , (length(to_sid) - length(from_sid)) )     

};

// Global Functions
struct SDRDomainInfo
{
   bool                      valid;
   PSID                      domain_sid;
   WCHAR                     domain_name[80];
   WCHAR                     dc_name[80];
   UCHAR                     nsubs;
};
int vRidComp(const TNode * tn, const void * v1);
int vNameComp(const TNode * tn, const void * v1);
int vTargetNameComp(const TNode * tn, const void * v1);
int RidComp(const TNode * n1, const TNode * n2);
int CompN(const TNode * n1, const TNode * n2);
int CompTargetN(const TNode * n1, const TNode * n2);

void DisplaySid(const PSID);                        // displays the contents of a SID 
void DisplaySid(const PSID,TAccountCache *);  // displays the acct name if in cache, or 
void                                         
   SetDomainInfoStruct(
      WCHAR const         * domname,        // in -name of domain
      SDRDomainInfo       * info            // in -struct to put info into
   );

void                                         
   SetDomainInfoStructFromSid(
      PSID                  pSid,           // in -sid for domain
      SDRDomainInfo       * info            // in -struct to put info into
   );

PSID              DomainizeSid(PSID psid,BOOL freeOldSid);                                                   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\tarnode.hpp ===
/*---------------------------------------------------------------------------
  File: TAcctReplNode.hpp

  Comments: implementation/Definition of the TAcctReplNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#ifndef __TACCTREPLNODE_HPP__
#define __TACCTREPLNODE_HPP__
//#pragma title("TAcctReplNode.hpp- class definitions for Account replication code")

#include <lmcons.h>
#include "Common.hpp"
#include "EaLen.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "CommaLog.hpp"
#include "WorkObj.h"
#include <COMDEF.h>

#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Special           (0x00000040)
#define AR_Status_Critical          (0x00000080)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)

// Opertation flags to be performed on the Account
#define OPS_Create_Account          (0x00000001)
#define OPS_Copy_Properties         (0x00000002)
#define OPS_Process_Members         (0x00000004)
#define OPS_Process_MemberOf        (0x00000008)
#define OPS_Call_Extensions         (0x00000010)
#define OPS_Move_Object             (0x00000020)

#define OPS_All                     OPS_Create_Account | OPS_Copy_Properties | OPS_Process_Members | OPS_Process_MemberOf | OPS_Call_Extensions
#define OPS_Copy                    OPS_Create_Account | OPS_Copy_Properties

class TAcctReplNode:public TNode
{
   _bstr_t                   name;
   _bstr_t                   newName;
   _bstr_t                   sourcePath;
   _bstr_t                   targetPath;
   _bstr_t                   type;  // Account Type
   DWORD                     status;
   DWORD                     ridSrc;
   DWORD                     ridTgt;
   _bstr_t                   sSourceSamName;
   _bstr_t                   sTargetSamName;
   _bstr_t                   sSrcProfilePath;
   _bstr_t                   sTgtProfilePath;
   _bstr_t                   sTargetGUID;
   _bstr_t                   sSourceUPN;
   PSID                      srcSid;
   HRESULT                   hr;
   long                      lGroupType;
public:
   DWORD                     operations;     // BitMask Specifies what operations to perform on a pirticular account
   bool                      IsFilled;       // Tells us if we need to process this account node any further to fill in required info
   bool                      IsProfPathFilled;
   bool                      bExpanded;
   bool                      bChangedType;
   // following two properties are added to support UpdateMemberToGroups function to just be able to add
   // migrated objects to the groups that they belong to.
   _bstr_t                   sMemberName;    // This contains the sam name to the member of this group object
   _bstr_t                   sMemberType;    // This contains the type of the member.
   long                      lFlags;
   long                      lExpDate;
   BOOL                      bUPNConflicted;

public:
   TAcctReplNode() :
      status(0),
      ridSrc(0),
      ridTgt(0),
      srcSid(NULL),
      hr(-1),
      lGroupType(0),
      operations(OPS_All),
      IsFilled(false),
      IsProfPathFilled(false),
      bExpanded(false),
      bChangedType(false),
      sMemberName(L""),
      sMemberType(L""),
      lFlags(0),
      lExpDate(0),
      bUPNConflicted(FALSE)
   {
   }

   WCHAR const *        GetName() const { return !name ? L"" : name; }
   WCHAR const *        GetTargetName() const { return !newName ? !name ? L"" : name : newName; }
   WCHAR const *        GetTargetPath() const { return !targetPath ? L"" : targetPath; }
   WCHAR const *        GetSourcePath() const { return !sourcePath ? L"" : sourcePath; }
   WCHAR const *        GetType() const { return !type ? L"" : type; }
   WCHAR const *        GetSourceSam() const { return !sSourceSamName ? L"" : sSourceSamName; }
   WCHAR const *        GetTargetSam() const { return !sTargetSamName ? L"" : sTargetSamName; }
   WCHAR const *        GetTargetProfile() const { return !sTgtProfilePath ? L"" : sTgtProfilePath; }
   WCHAR const *        GetSourceProfile() const { return !sSrcProfilePath ? L"" : sSrcProfilePath; }
   WCHAR const *        GetTargetGUID() const { return !sTargetGUID ? L"" : sTargetGUID; }
   WCHAR const *        GetSourceUPN() const { return !sSourceUPN ? L"" : sSourceUPN; }
   PSID                 GetSourceSid() { return srcSid; }
   
   DWORD                GetStatus() const { return status; }
   DWORD                GetSourceRid() const { return ridSrc; }
   DWORD                GetTargetRid() const { return ridTgt; }
   long                 GetGroupType() { return lGroupType; }
   HRESULT              GetHr() const { return hr; }
   
   void                 SetName(const TCHAR * newname) { name = newname; }
   void                 SetTargetName(const WCHAR * name) { newName = name; }
   void                 SetTargetPath(const WCHAR * sPath) { targetPath = sPath; } 
   void                 SetSourcePath(const WCHAR * sPath) { sourcePath = sPath; }
   void                 SetSourceSam(const WCHAR * sName) { sSourceSamName = sName; }
   void                 SetTargetSam(const WCHAR * sName) { sTargetSamName = sName; }
   void                 SetSourceProfile(const WCHAR * sPath) { sSrcProfilePath = sPath; IsProfPathFilled = true; }
   void                 SetTargetProfile(const WCHAR * sPath) { sTgtProfilePath = sPath; }
   void                 SetTargetGUID(const WCHAR * sGUID) { sTargetGUID = sGUID; }
   void                 SetType(const WCHAR * newtype) { type = newtype; }
   void                 SetSourceUPN(const WCHAR * sName) { sSourceUPN = sName; }
   void                 SetSourceSid(PSID sSid) { srcSid = sSid; }
   
   void                 SetStatus(DWORD val) { status = val; }
   void                 SetGroupType(long type) { lGroupType = type; }
   void                 SetSourceRid(DWORD val) { ridSrc = val; }
   void                 SetTargetRid(DWORD val) { ridTgt = val; }
   void                 SetHr(const HRESULT hrRes) { hr = hrRes; }
   
   void                 MarkCreated() { status |= AR_Status_Created; }
   void                 MarkReplaced() { status |= AR_Status_Replaced; }
   void                 MarkAlreadyThere() { status |= AR_Status_AlreadyExisted; }
   void                 MarkError() { status |= AR_Status_Error; }
   void                 MarkWarning() { status |= AR_Status_Warning; }
   void                 MarkRightsUpdated() { status |= AR_Status_RightsUpdated; }
   void                 MarkDomainChanged() { status |= AR_Status_DomainChanged; }
   void                 MarkRebooted() { status |= AR_Status_Rebooted; }
   void                 MarkCritical() { status = AR_Status_Critical; }
 
   BOOL                 WasCreated() { return status & AR_Status_Created; }
   BOOL                 WasReplaced() { return status & AR_Status_Replaced; }
   BOOL                 IsCritical() { return status & AR_Status_Critical; }
   BOOL                 CreateAccount() { return operations & OPS_Create_Account; }
   BOOL                 CopyProps() { return operations & OPS_Copy_Properties; }
   BOOL                 ProcessMem() { return operations & OPS_Process_Members; }
   BOOL                 ProcessMemOf() { return operations & OPS_Process_MemberOf; }
   BOOL                 CallExt() { return operations & OPS_Call_Extensions; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0351
#endif
#define _ATL_FREE_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\userrts.cpp ===
/*---------------------------------------------------------------------------
  File: UserRights.cpp

  Comments: COM object to update user rights.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:34:35

 ---------------------------------------------------------------------------
*/

// UserRights.cpp : Implementation of CUserRights
#include "stdafx.h"
#include "WorkObj.h"
#include "UserRts.h"
#include "Common.hpp"
#include "TNode.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "EaLen.hpp"
#include "ntsecapi.h"

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct err;
#define LEN_SID      200


#ifndef SE_DENY_INTERACTIVE_LOGON_NAME 
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#endif
#ifndef SE_DENY_NETWORK_LOGON_NAME
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#endif
#ifndef SE_DENY_BATCH_LOGON_NAME
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#endif
#ifndef SE_DENY_SERVICE_LOGON_NAME
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#endif

//

// this function wasn't defined in the header file.
extern "C" {
NTSTATUS
   NTAPI
   LsaEnumeratePrivileges(
    LSA_HANDLE PolicyHandle,
    LSA_ENUMERATION_HANDLE * eHandle,
    LPVOID * enumBuffer,
    ULONG prefMaxLen,
    ULONG * countReturned
   );
   
};
//The following definition was in ntsecapi.h but was mistakenly taken out
//in the W2K build version.
//
// The following data type is used to return information about privileges
// defined on a system.
//

typedef struct _POLICY_PRIVILEGE_DEFINITION {

    LSA_UNICODE_STRING Name;
    LUID LocalValue;

} POLICY_PRIVILEGE_DEFINITION, *PPOLICY_PRIVILEGE_DEFINITION;


class PrivNode : public TNode
{
   WCHAR                     name[200];

public:
   PrivNode(WCHAR * str, USHORT length ) { UStrCpy(name,str,length+1); name[length] = 0; }

   WCHAR * Name() { return name; }
};

class PrivList : public TNodeListSortable
{
protected:
   static TNodeCompare(CompareName) 
   { 
      PrivNode             * p1 = (PrivNode *)v1;
      PrivNode             * p2 = (PrivNode *)v2;

      return UStrICmp(p1->Name(),p2->Name());
   }
   static TNodeCompareValue(CompareValue)
   {
      PrivNode             * p   = (PrivNode *)tnode;
      WCHAR                * str = (WCHAR *)value;

      return UStrICmp(p->Name(),str);
   }
public:
   PrivList() { TypeSetSorted(); CompareSet(&CompareName); }
   ~PrivList() { DeleteAllListItems(PrivNode); }
   void InsertPrivilege(PrivNode * p) { SortedInsertIfNew((TNode *)p); }
   BOOL Contains(WCHAR * priv) { return ( NULL != Find(&CompareValue,(void*)priv) ); }

};

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,   // in - handle to LSA
      WCHAR                * account,  // in - account to list privileges for
      WCHAR                * strSid,   // in - textual form of account's sid, if known
      WCHAR                * computer, // in - computer name
      PrivList             * privList, // i/o- list of privileges
      PSID                 * ppSid     // out- SID for the account
   );

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,   // in - handle to LSA
      PSID                   pSid,     // in - sid of account to list privileges for
      PrivList             * privList  // i/o- list of privileges
   );

NTSTATUS
   OpenPolicy(
      LPWSTR ServerName,          // machine to open policy on (Unicode)
      DWORD DesiredAccess,        // desired access to policy
      PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
   GetAccountSid(
      LPTSTR SystemName,          // where to lookup account
      LPTSTR AccountName,         // account of interest
      PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
   SetPrivilegeOnAccount(
      LSA_HANDLE PolicyHandle,    // open policy handle
      PSID AccountSid,            // SID to grant privilege to
      LPWSTR PrivilegeName,       // privilege to grant (Unicode)
      BOOL bEnable                // enable or disable
    );


/////////////////////////////////////////////////////////////////////////////
// CUserRights

CUserRights::~CUserRights()
{
   if ( m_SrcPolicy )
   {
      LsaClose(m_SrcPolicy);
   }
   if ( m_TgtPolicy )
   {
      LsaClose(m_TgtPolicy);
   }
}

STDMETHODIMP 
   CUserRights::OpenSourceServer(
      BSTR                   serverName      // in - computer name (DC) for source domain
  )
{
	DWORD                     rc;
   
   if ( m_SrcPolicy )
   {
      LsaClose(m_SrcPolicy);
      m_SrcPolicy = NULL;
   }
   rc = OpenPolicy( serverName, POLICY_LOOKUP_NAMES, &m_SrcPolicy );
   m_SourceComputer = serverName;

  return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::OpenTargetServer(
      BSTR                   computerName    // in - computer name (DC) for target domain
   )
{  
   DWORD                     rc;

   if ( m_TgtPolicy )
   {
      LsaClose(m_TgtPolicy);
      m_TgtPolicy = NULL;
   }
   rc = OpenPolicy( computerName,POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES ,&m_TgtPolicy);
   m_TargetComputer = computerName;

	return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::CopyUserRights(
      BSTR                   sourceUserName,       // in - source domain account to copy rights from
      BSTR                   targetUserName        // in - target domain account to copy rights to
   )
{
   HRESULT                   hr = S_OK;
   DWORD                     rc;

   // Make sure source and target are open
   if ( m_SrcPolicy && m_TgtPolicy )
   {
      rc = CopyUserRightsInternal(sourceUserName,targetUserName,L"",L"",m_bNoChange,m_bRemove);
      hr = HRESULT_FROM_WIN32(rc);
   }
   else 
   {
      hr = E_FAIL;
   }
	return S_OK;
}


STDMETHODIMP 
   CUserRights::CopyUserRightsWithSids(
      BSTR                   sourceUserName,       // in - source domain account to copy rights from
      BSTR                   sourceSID,            // in - source account SID (in string format)
      BSTR                   targetUserName,       // in - target domain account to copy rights to
      BSTR                   targetSID             // in - target account SID (in string format)
   )
{
   HRESULT                   hr = S_OK;
   DWORD                     rc;

   // Make sure source and target are open
   if ( m_SrcPolicy && m_TgtPolicy )
   {
      rc = CopyUserRightsInternal(sourceUserName,targetUserName,sourceSID,targetSID,m_bNoChange,m_bRemove);
      hr = HRESULT_FROM_WIN32(rc);
   }
   else 
   {
      hr = E_FAIL;
   }
	return S_OK;
}
STDMETHODIMP CUserRights::get_NoChange(BOOL *pVal) // out- value
{
	(*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP CUserRights::put_NoChange(BOOL newVal)   // in - new value
{
	m_bNoChange = newVal;
   return S_OK;
}

STDMETHODIMP CUserRights::get_RemoveOldRightsFromTargetAccounts(BOOL *pVal)   // out- value
{
   (*pVal) = m_bRemove;
   return S_OK;
}

STDMETHODIMP CUserRights::put_RemoveOldRightsFromTargetAccounts(BOOL newVal)  // in - new value
{
	m_bRemove = newVal;
   return S_OK;
}
                                   


STDMETHODIMP 
   CUserRights::ExportUserRights(
      BSTR                   server,            // in - computer to read rights from
      BSTR                   filename,          // in - filename to export list of rights to
      BOOL                   bAppendToFile      // in - flag, append or overwrite file if it exists
   )
{
   LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   if ( ! rc )
   {
      CommaDelimitedLog      log;

      if ( log.LogOpen(filename,FALSE,bAppendToFile) )
      {
         // Enumerate the privileges on this machine
         
         // arguments for LsaEnumeratePrivileges
         ULONG                         countOfRights;
         DWORD                         prefMax = 0xffffffff;
         LSA_ENUMERATION_HANDLE        handle = 0;
         POLICY_PRIVILEGE_DEFINITION * pRights = NULL;
         
         do 
         {
            rc = LsaEnumeratePrivileges(policy,&handle,(LPVOID*)&pRights,prefMax,&countOfRights);
            if ( rc ) 
            {
               rc = LsaNtStatusToWinError(rc);
               if ( rc == ERROR_NO_MORE_ITEMS )
                  rc = 0;
               break;
            }
               // For each right, enumerate the accounts that have that right
            if ( ! rc )
            {
               
               for ( UINT right = 0 ;right < countOfRights ; right++ )
               {
                  rc = EnumerateAccountsWithRight(policy,server,&pRights[right].Name,&log);
               }
               LsaFreeMemory(pRights);

               LSA_UNICODE_STRING      lsaRight;
               // For some reason, LsaEnumeratePrivileges doesn't return these rights
               // They are defined in "ntsecapi.h", and not with the rest of the privileges in "winnt.h"
               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_INTERACTIVE_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_NETWORK_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_BATCH_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_SERVICE_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }
            }
            else
            {
               rc = LsaNtStatusToWinError(rc);
            }
         }
         while ( ! rc );
         log.LogClose();
      }
      else
      {
         rc = GetLastError();
      }
      LsaClose(policy);
   }
	
   hr = HRESULT_FROM_WIN32(rc);
   return hr;
}


DWORD 
   CUserRights::EnumerateAccountsWithRight(
      LSA_HANDLE             policy,               // in - handle to LSA
      WCHAR                * server,               // in - computer name
      LSA_UNICODE_STRING   * pRight,               // in - user right
      CommaDelimitedLog    * pLog                  // in - pointer to log object to log information to
   )
{
   DWORD                         rc = 0;
   WCHAR                         account[LEN_Account];
   WCHAR                         domain[LEN_Domain];
   WCHAR                         domacct[LEN_Domain + LEN_Account];
   WCHAR                         szRight[LEN_Account];
   WCHAR                         szDisplayName[LEN_DisplayName];
   DWORD                         lenAccount = DIM(account);
   DWORD                         lenDomain = DIM(domain);
   DWORD                         lenDisplayName = DIM(szDisplayName);
   SID_NAME_USE                  snu;
   DWORD                         lid;            
   BOOL                          bUseDisplayName;

   // arguments for LsaEnumerateAccountsWithUserRight
   ULONG                         countOfUsers;
   LSA_ENUMERATION_INFORMATION * pInfo = NULL;
           
   UStrCpy(szRight,pRight->Buffer,pRight->Length/(sizeof WCHAR) + 1);
   bUseDisplayName = m_bUseDisplayName && LookupPrivilegeDisplayName(server,szRight,szDisplayName,&lenDisplayName,&lid);
               
                  
   rc = LsaEnumerateAccountsWithUserRight(policy,pRight,(PVOID*)&pInfo,&countOfUsers);

   if ( ! rc )
   {
      for ( UINT user = 0 ; user < countOfUsers ; user++ )
      {
         if ( ! pInfo[user].Sid )
         {
            break; // something is wrong
         }
         domain[0] = 0;
         account[0] = 0;
         lenDomain = DIM(domain);
         lenAccount = DIM(account);
         if ( LookupAccountSid(server,pInfo[user].Sid,account,&lenAccount,domain,&lenDomain,&snu) )
         {
            if ( *account )
            {
               swprintf(domacct,L"%s\\%s",domain,account);
            }
            else
            {
               lenAccount = DIM(account);
               GetTextualSid(pInfo[user].Sid,account,&lenAccount);
               if ( snu == SidTypeDeletedAccount )
               {
                  swprintf(domacct,L"%s\\<Deleted Account: %s>",domain,account);
               }
               else
               {
                  swprintf(domacct,L"%s\\<%s>",domain,account);
               }
            }
         }
         else
         {
            lenAccount = DIM(account);
            GetTextualSid(pInfo[user].Sid,domacct,&lenAccount);
         }
         if ( bUseDisplayName )
         {
            pLog->MsgWrite(L"%s, %s, %s",server,domacct,szDisplayName);   
         }
         else
         {
            pLog->MsgWrite(L"%s, %s, %s",server,domacct,szRight);
         }
      }
      LsaFreeMemory(pInfo);
   }
   else
   {
      rc = LsaNtStatusToWinError(rc);
      if ( rc == ERROR_NO_MORE_ITEMS )
         rc = 0;
   }
   return rc;
}

DWORD 
   CUserRights::CopyUserRightsInternal(
      WCHAR                * srcAccount,        // in - source account to copy rights from
      WCHAR                * tgtAccount,        // in - account to copy rights to
      WCHAR                * srcSidStr,         // in - sid for source account, in string format
      WCHAR                * tgtSidStr,         // in - sid for target account, in string format
      BOOL                   bNoChange,         // in - flag, whether to write changes
      BOOL                   bRemove            // in - flag, whether to revoke rights from target if not held by source
   )
{
   DWORD                     rc = 0;
   PrivList                  srcList;
   PrivList                  tgtList;
   PSID                      pSidSrc = NULL;
   PSID                      pSidTgt = NULL;
   
   // Get a list of the privileges held by srcAccount
   rc = BuildPrivilegeList(m_SrcPolicy,srcAccount,srcSidStr,m_SourceComputer,&srcList,&pSidSrc);
   if ( ! rc )
   {
      rc = BuildPrivilegeList(m_TgtPolicy,tgtAccount,tgtSidStr,m_TargetComputer,&tgtList,&pSidTgt);
      if ( ! rc )
      {
         if ( bRemove )
         {
            // Get a list of privileges held by tgtAccount
            // Remove old privileges
            TNodeListEnum    tEnum;
            PrivNode       * p;
         
            for ( p = (PrivNode *)tEnum.OpenFirst(&tgtList) ; p ; p = (PrivNode*)tEnum.Next() )
            {
               if ( ! srcList.Contains(p->Name()) )
               {
                  // The source account doesn't have this privilege - remove it
                  if (! bNoChange )
                  {
                     rc = SetPrivilegeOnAccount(m_TgtPolicy,pSidTgt,p->Name(),FALSE);
                  }
                  if ( rc )
                  {
                     rc = LsaNtStatusToWinError(rc);
                     err.MsgWrite(ErrE,DCT_MSG_REMOVE_RIGHT_FAILED_SSD,p->Name(),tgtAccount,rc);
                     break;
                  }
                  else
                  {
                     err.MsgWrite(0,DCT_MSG_REMOVED_RIGHT_SS,p->Name(), tgtAccount);
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_USER_HAS_RIGHT_SS,tgtAccount,p->Name());
               }
            }
         }
         // Grant privileges to new account
         TNodeListEnum       tEnum;
         PrivNode          * p;

         for ( p = (PrivNode *)tEnum.OpenFirst(&srcList) ; p ; p = (PrivNode*)tEnum.Next() )
         {
            if ( ! tgtList.Contains(p->Name()) )
            {
               if ( ! bNoChange )
               {
                  rc = SetPrivilegeOnAccount(m_TgtPolicy,pSidTgt,p->Name(),TRUE);
                  if ( rc )
                  {
                     rc = LsaNtStatusToWinError(rc);
                     err.MsgWrite(ErrE,DCT_MSG_ADD_RIGHT_FAILED_SSD,p->Name(),tgtAccount,rc);
                     break;
                  }
                  else
                  {
                     err.MsgWrite(0,DCT_MSG_RIGHT_GRANTED_SS,p->Name(),tgtAccount);
                  }
               }
            }
           
         }
      }
   }
   
   // Clean up SIDs
   if(pSidSrc != NULL) 
   {
      HeapFree(GetProcessHeap(), 0, pSidSrc);
   }

   if(pSidTgt != NULL) 
   {
      HeapFree(GetProcessHeap(), 0, pSidTgt);
   }
   return rc;
}





/*++

Managing user privileges can be achieved programmatically using the
following steps:

1. Open the policy on the target machine with LsaOpenPolicy(). To grant
   privileges, open the policy with POLICY_CREATE_ACCOUNT and
   POLICY_LOOKUP_NAMES access. To revoke privileges, open the policy with
   POLICY_LOOKUP_NAMES access.

2. Obtain a SID (security identifier) representing the user/group of
   interest. The LookupAccountName() and LsaLookupNames() APIs can obtain a
   SID from an account name.

3. Call LsaAddAccountRights() to grant privileges to the user(s)
   represented by the supplied SID.

4. Call LsaRemoveAccountRights() to revoke privileges from the user(s)
   represented by the supplied SID.

5. Close the policy with LsaClose().

To successfully grant and revoke privileges, the caller needs to be an
administrator on the target system.

The LSA API LsaEnumerateAccountRights() can be used to determine which
privileges have been granted to an account.

The LSA API LsaEnumerateAccountsWithUserRight() can be used to determine
which accounts have been granted a specified privilege.

Documentation and header files for these LSA APIs is provided in the
Windows 32 SDK in the MSTOOLS\SECURITY directory.


--*/




#define RTN_OK 0
#define RTN_USAGE 1            
#define RTN_ERROR 13

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,         // in - handle to LSA
      PSID                   pSid,           // in - SID for account
      PrivList             * privList        // i/o- list of rights held by the account
   )      
{
   DWORD                     rc = 0;
   ULONG                     countOfRights = 0;
   PLSA_UNICODE_STRING       pUserRights = NULL;

   rc = LsaEnumerateAccountRights(policy,pSid,&pUserRights,&countOfRights);
   rc = LsaNtStatusToWinError(rc);
   if ( rc == ERROR_FILE_NOT_FOUND )
   {
      // This account has no privileges
      rc = 0;
      countOfRights = 0;
   }
   if ( ! rc )
   {
      for ( UINT i = 0 ; i < countOfRights ; i++ )
      {
         PrivNode * p = new PrivNode(pUserRights[i].Buffer,pUserRights[i].Length/2);
         privList->InsertPrivilege(p);
      }
      LsaFreeMemory(pUserRights);
   }
   return rc; 
}

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,      // in - handle to LSA
      WCHAR                * account,     // in - account name to list rights for
      WCHAR                * strSid,      // in - text format of the accounts SID, if known
      WCHAR                * computer,    // in - computer to list rights on
      PrivList             * privList,    // i/o- list of rights held by account
      PSID                 * ppSid        // out- SID for account
   )
{
   DWORD                     rc = 0;
   PSID                      pSid = NULL;
   
   if ( strSid && (*strSid) )
   {
      // use the provided SID
      pSid = SidFromString(strSid);
      if ( ! pSid )
      {
         rc = GetLastError();
      }
   }
   else
   {
      // no SID provided, so look it up on the domain
      if ( !GetAccountSid(computer,account,&pSid) )
      {
         rc = GetLastError();
      }
   }

   if ( rc )
   {
      (*ppSid) = NULL;
      if(pSid != NULL) 
      {
         HeapFree(GetProcessHeap(), 0, pSid);
      }
   }
   else
   {
      (*ppSid) = pSid;
   }
   
   if ( pSid )
   {
      rc = BuildPrivilegeList(policy,pSid,privList);
   }
   return rc;
}


BOOL
GetAccountSid(
    LPTSTR SystemName,           // in - computer name to lookup sid on
    LPTSTR AccountName,          // in - account name
    PSID *Sid                    // out- SID for account
    )
{
    WCHAR  ReferencedDomain[LEN_Domain];
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=DIM(ReferencedDomain); // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail

    __try {

    //
    // initial memory allocations
    //
    if((*Sid=HeapAlloc(
                    GetProcessHeap(),
                    0,
                    cbSid
                    )) == NULL) __leave;

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    *Sid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //
            if((*Sid=HeapReAlloc(
                        GetProcessHeap(),
                        0,
                        *Sid,
                        cbSid
                        )) == NULL) __leave;

        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    if(!bSuccess) {
        if(*Sid != NULL) {
            HeapFree(GetProcessHeap(), 0, *Sid);
            *Sid = NULL;
        }
    }

    } // finally

    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}



STDMETHODIMP 
   CUserRights::AddUserRight(
      BSTR                   server,         // in - computer to grant right on
      BSTR                   strSid,         // in - textual form of sid for account to grant right to
      BSTR                   right           // in - right to grant to account
   )
{
	LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   PSID                      pSid = SidFromString(strSid);

   rc = OpenPolicy(server,POLICY_ALL_ACCESS /*POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION*/,&policy);
   if ( ! rc )
   {
      if ( ! m_bNoChange )
      {
         rc = SetPrivilegeOnAccount(policy,pSid,right,TRUE);
      }
      if ( rc )
      {
         rc = LsaNtStatusToWinError(rc);
         hr = HRESULT_FROM_WIN32(rc);
      }
      LsaClose(policy);   
   }
   FreeSid(pSid);
   return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::RemoveUserRight(
      BSTR                   server,         // in - computer to revoke right on
      BSTR                   strSid,         // in - textual sid of account to revoke right for
      BSTR                   right           // in - right to revoke
  )
{
	LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   PSID                      pSid = SidFromString(strSid);
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   if ( ! rc )
   {
      if ( ! m_bNoChange )
      {
         rc = SetPrivilegeOnAccount(policy,pSid,right,FALSE);
      }
      if ( rc )
      {
         rc = LsaNtStatusToWinError(rc);
         hr = HRESULT_FROM_WIN32(rc);
      }
      LsaClose(policy);   
   }
   FreeSid(pSid);
   return HRESULT_FROM_WIN32(rc);
}

DWORD 
   CUserRights::SafeArrayFromPrivList(
      PrivList             * privList,       // in - list of user rights
      SAFEARRAY           ** pArray          // out- safearray containing list contents
   )
{
   DWORD                     rc = 0;
   HRESULT                   hr;
   TNodeListEnum             e;
   SAFEARRAYBOUND            bound;
   LONG                      ndx[1];

   bound.lLbound = 0;
   bound.cElements = privList->Count();
   
   (*pArray) = SafeArrayCreate(VT_BSTR,1,&bound);
   
   if ( (*pArray) )
   {
      PrivNode             * p;
      UINT                   i;

      for ( p=(PrivNode*)e.OpenFirst(privList) , i = 0 ; 
            p ; 
            p = (PrivNode*)e.Next() , i++ )
      {
         ndx[0] = i;
         
         hr = SafeArrayPutElement((*pArray),ndx,SysAllocString(p->Name()));
         if ( FAILED(hr) )
         {
            rc = hr;
            break;
         }
      }
      e.Close();
   }
   else
   {
      rc = GetLastError();
   }
   return rc;
}

STDMETHODIMP 
   CUserRights::GetRights(
      BSTR                   server,         // in - computer
      SAFEARRAY           ** pRightsArray    // out- list of rights on computer
   )
{
   HRESULT                   hr = S_OK;
   PrivList                  priv;
   DWORD                     rc = 0;
    
	LSA_HANDLE                policy = NULL;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
     // Enumerate the privileges on this machine
         
   // arguments for LsaEnumeratePrivileges
   ULONG                         countOfRights;
   DWORD                         prefMax = 0xffffffff;
   LSA_ENUMERATION_HANDLE        handle = 0;
   POLICY_PRIVILEGE_DEFINITION * pRights = NULL;
   
   do 
   {
      if ( rc ) 
         break;
      rc = LsaEnumeratePrivileges(policy,&handle,(LPVOID*)&pRights,prefMax,&countOfRights);
      if ( rc ) 
      {
         rc = LsaNtStatusToWinError(rc);
         if ( rc == ERROR_NO_MORE_ITEMS )
            rc = 0;
         break;
      }
      if ( ! rc )
      {
         
         PrivNode          * p = NULL;

         for ( UINT right = 0 ;right < countOfRights ; right++ )
         {
            // Length is in bytes
            p = new PrivNode(pRights[right].Name.Buffer,pRights[right].Name.Length/2);
            
            priv.InsertPrivilege(p);
         }
         LsaFreeMemory(pRights);

         LSA_UNICODE_STRING      lsaRight;
         // For some reason, LsaEnumeratePrivileges doesn't return these rights
         // They are defined in "ntsecapi.h", and not with the rest of the privileges in "winnt.h"
         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_INTERACTIVE_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_NETWORK_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);

         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_BATCH_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_SERVICE_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }
       
         // Check the OS version on the server
         WKSTA_INFO_100       * pInfo;
         BOOL                   bIsWin2K = TRUE;
         DWORD                  rcInfo = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);

	      if ( ! rcInfo )
	      {
            if ( pInfo->wki100_ver_major < 5 )
            {
               bIsWin2K = FALSE;
            }
            NetApiBufferFree(pInfo);
	      }
         
         // The 4 "deny" rights are only defined on Windows 2000.
         if ( bIsWin2K )
         {
            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_INTERACTIVE_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_NETWORK_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);

            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_BATCH_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_SERVICE_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }
         }
      }
      else
      {
         rc = LsaNtStatusToWinError(rc);
      }
   } while ( false);

   if ( policy )
   {
      LsaClose(policy);
   }
   // Build a safearray of BSTRs from the priv-list
   rc = SafeArrayFromPrivList(&priv,pRightsArray);
  
   hr = HRESULT_FROM_WIN32(rc);
   
   return hr;
}

STDMETHODIMP 
   CUserRights::GetUsersWithRight(
      BSTR                   server,      // in - computer name
      BSTR                   right,       // in - right to lookup
      SAFEARRAY           ** users        // out- list of accounts that hold right
  )
{
   DWORD                     rc = 0;
   LSA_UNICODE_STRING        Right;
   WCHAR                     strSid[LEN_SID];
   DWORD                     lenStrSid = DIM(strSid);
   PrivList                  plist;
   LSA_HANDLE                policy = NULL;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   
   // arguments for LsaEnumerateAccountsWithUserRight
   ULONG                         countOfUsers;
   LSA_ENUMERATION_INFORMATION * pInfo = NULL;
   
   InitLsaString(&Right,right);        
   
   rc = LsaEnumerateAccountsWithUserRight(policy,&Right,(PVOID*)&pInfo,&countOfUsers);

   if ( ! rc )
   {
      for ( UINT user = 0 ; user < countOfUsers ; user++ )
      {
         if ( ! pInfo[user].Sid )
         {
            continue; // something is wrong
         }
         
         GetTextualSid(pInfo[user].Sid,strSid,&lenStrSid);
         PrivNode             * p = new PrivNode(strSid,(USHORT) UStrLen(strSid));
         
         plist.InsertPrivilege(p);
      }
      LsaFreeMemory(pInfo);
   }
   else
   {
      rc = LsaNtStatusToWinError(rc);
      if ( rc == ERROR_NO_MORE_ITEMS )
         rc = 0;
   }
   if ( ! rc )
   {
      rc = SafeArrayFromPrivList(&plist,users);
   }
   if ( policy )
      LsaClose(policy);
   return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::GetRightsOfUser(
      BSTR                   server,      // in - computer name
      BSTR                   strSid,      // in - textual sid for account
      SAFEARRAY           ** rights       // out- list of rights held by account on server
  )
{
	DWORD                     rc = 0;
   PSID                      pSid = SidFromString(strSid);
   LSA_HANDLE                policy = NULL;
   PrivList                  plist;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   if ( ! rc )
   {
      rc = BuildPrivilegeList(policy,pSid,&plist);
      if ( ! rc )
      {
         rc = SafeArrayFromPrivList(&plist,rights);
      }
      LsaClose(policy);
   }
	return HRESULT_FROM_WIN32(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\win2kerr.h ===
/********************
  WinError2000.h
  This file is used to define the Error codes that are not part of NT4 WinError.h
  Please remove this file when we start building with Win2000 SDK.
*/

//
// MessageId: ERROR_DS_UNWILLING_TO_PERFORM
//
// MessageText:
//
//  The server is unwilling to process the request.
//
#define ERROR_DS_UNWILLING_TO_PERFORM    8245L



//
// MessageId: ERROR_DS_SERVER_DOWN
//
// MessageText:
//
//  The server is not operational.
//
#define ERROR_DS_SERVER_DOWN             8250L

//
// MessageId: ERROR_DS_MASTERDSA_REQUIRED
//
// MessageText:
//
//  The operation must be performed at a master DSA.
//
#define ERROR_DS_MASTERDSA_REQUIRED      8314L

//
// MessageId: ERROR_DS_INSUFF_ACCESS_RIGHTS
//
// MessageText:
//
//  Insufficient access rights to perform the operation.
//
#define ERROR_DS_INSUFF_ACCESS_RIGHTS    8344L

//
// MessageId: ERROR_DS_DST_DOMAIN_NOT_NATIVE
//
// MessageText:
//
//  Destination domain must be in native mode.
//
#define ERROR_DS_DST_DOMAIN_NOT_NATIVE   8496L


//
// MessageId: ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
//
// MessageText:
//
//  The connection between client and server requires packet privacy or better.
//
#define ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION 8533L


// MessageId: ERROR_DS_SOURCE_DOMAIN_IN_FOREST
//
// MessageText:
//
//  The source domain may not be in the same forest as destination.
//
#define ERROR_DS_SOURCE_DOMAIN_IN_FOREST 8534L

//
// MessageId: ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
//
// MessageText:
//
//  The destination domain must be in the forest.
//
#define ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST 8535L

//
// MessageId: ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
//
// MessageText:
//
//  The operation requires that destination domain auditing be enabled.
//
#define ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED 8536L

//
// MessageId: ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
//
// MessageText:
//
//  The operation couldn't locate a DC for the source domain.
//
#define ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN 8537L

//
// MessageId: ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
//
// MessageText:
//
//  The source object must be a group or user.
//
#define ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER 8538L

//
// MessageId: ERROR_DS_SRC_SID_EXISTS_IN_FOREST
//
// MessageText:
//
//  The source object's SID already exists in destination forest.
//
#define ERROR_DS_SRC_SID_EXISTS_IN_FOREST 8539L

//
// MessageId: ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
//
// MessageText:
//
//  The source and destination object must be of the same type.
//
#define ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH 8540L


#define ERROR_DS_SOURCE_AUDITING_NOT_ENABLED 8552L

#define ERROR_DS_MUST_BE_RUN_ON_DST_DC 8558L

#define ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER 8559L

//
// MessageId: ERROR_DS_CANT_MOVE_ACCOUNT_GROUP
//
// MessageText:
//
//  Cross-domain move of account groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_ACCOUNT_GROUP 8498L

//
// MessageId: ERROR_DS_CANT_MOVE_RESOURCE_GROUP
//
// MessageText:
//
//  Cross-domain move of resource groups is not allowed.
//
#define ERROR_DS_CANT_MOVE_RESOURCE_GROUP 8499L

// MessageId: ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS
//
// MessageText:
//
//  Can't move objects with memberships across domain boundaries as once moved, this would violate the membership conditions of the account group.  Remove the object from any account group memberships and retry.
//
#define ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS 8493L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\workobj.cpp ===
/*---------------------------------------------------------------------------
  File: WorkerObjects.cpp

  Comments: Library of COM objects to perform DCT tasks
  This file was mostly generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/// WorkerObjects.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for WorkerObjects.idl by adding the following 
//      files to the Outputs.
//          WorkerObjects_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f WorkerObjectsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WorkObj.h"
#include "dlldatax.h"

#include "WorkObj_i.c"

#include "AcctRepl.h"
#include "PwdAge.h"
#include "Reboot.h"
#include "ChDom.h"
#include "Rename.h"
#include "StatObj.h"
#include "UserRts.h"
#include "SecTrans.h"
#include "Checker.h"
#include "PlugInfo.h"
#include "ResStr.h"

StringLoader gString;

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AcctRepl, CAcctRepl)
OBJECT_ENTRY(CLSID_ComputerPwdAge, CComputerPwdAge)
OBJECT_ENTRY(CLSID_RebootComputer, CRebootComputer)
OBJECT_ENTRY(CLSID_ChangeDomain, CChangeDomain)
OBJECT_ENTRY(CLSID_RenameComputer, CRenameComputer)
OBJECT_ENTRY(CLSID_StatusObj, CStatusObj)
OBJECT_ENTRY(CLSID_UserRights, CUserRights)
OBJECT_ENTRY(CLSID_SecTranslator, CSecTranslator)
OBJECT_ENTRY(CLSID_AccessChecker, CAccessChecker)
OBJECT_ENTRY(CLSID_PlugInInfo, CPlugInInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsDctWorkerObjects.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSDCTWORKEROBJECTSLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsDctWorkerObjects.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
		_Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\usercopy.hpp ===
#ifndef __USERCOPY_HPP__
#define __USERCOPY_HPP__
//#pragma title("usercopy.hpp- class definitions for usercopy")
/*
================================================================================

   (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

 Program    - usercopy
 Class      - LAN Manager Utilities
 Author     - Christy Boles
 Created    - 09/04/97
 Description- class definitions to allow usercopy to process subsets of accounts.
              The list of accounts will be generated by the GUI, and will consist 
              of a TNodeList of TAcctNodes.  Users will be added from the front of 
              the list, and groups will be added at the end.


 Updates    - 01/30/98 CAB Added strong password generation


================================================================================
*/

#include <lmcons.h>

#include "TNode.hpp"
#include <share.h>              // for _SH_DENYNO
#include "EaLen.hpp"
#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "CommaLog.hpp"
#include "TARNode.hpp"
#include "WorkObj.h"
#include "ProcExts.h"
//#import  "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb"
#import  "DBMgr.tlb" no_namespace, named_guids
#import  "WorkObj.tlb"

#define AR_BUFSIZE        ((size_t)16000)
#define AR_NUM_IN_BUF 5000  

#define F_REPLACE             0x00000001  // replace account info
#define F_GROUP               0x00000002  // copy global groups
#define F_LGROUP              0x00000004  // copy local groups
#define F_USERS               0x00000008  // copy users
#define F_DISABLE_ALL         0x00000010  // disable all accounts
#define F_DISABLE_SPECIAL     0x00000020  // disable Account Ops, Backup Ops, Administrators, Domain Admins
#define F_STRONGPW_ALL        0x00000040  // generate strong passwords for all accounts
#define F_STRONGPW_SPECIAL    0x00000080  // generate strong passwords for Account Ops, Backup Ops, Admins, and Domain Admins
#define F_MACHINE             0x00000100  // copy computer accounts
#define F_REMOVE_OLD_MEMBERS  0x00000200  // remove old members from replaced groups
#define F_DISABLESOURCE       0x00000400  // disable copied user accounts on source domain
#define F_AddToSrcGroupLocal  0x00000800  // indicates that the add-to group is on the target domain
#define F_AddToGroupLocal     0x00001000  // add to group is a local group
#define F_INTERACT            0x00002000  // use command-line parms to initiate interactive gui session
#define F_WARN_FULLNAME       0x00004000  // warn before replacing accounts w/different fullname 
#define F_WARN_COMMENT        0x00008000  // warn before replacing accounts w/different comment
#define F_CopyPasswords       0x00010000  // copy passwords
#define F_RevokeOldRights     0x00020000  // removes old user rights from copied accounts
#define F_AddSidHistory       0x00040000  // Add SID of source account to the SID history of the target account.
#define F_TranslateProfiles   0x00080000  // Translate roaming profiles
#define F_OUS                 0x00100000  // Process the organizational units.
#define F_COMPUTERS           0x00200000  // Process the computer accounts in Acct replication
#define F_COPY_CONT_CONTENT   0x00400000  // Copy the container contents along with the container when copying accounts.
#define F_COPY_MIGRATED_ACCT  0x00800000  // When expanding containers/membership include accounts that have already been migrated.
#define F_MOVE_REPLACED_ACCT  0x01000000  // move a replaces account to the user-specified OU.
    
#define AR_AccountComputer    (0x80000000)
#define AR_AccountComputerPdc (0x40000000)


#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define DOMAIN_USERS       6
#define DOMAIN_CONTROLLERS 7
#define DOMAIN_COMPUTERS   8

struct AccountStats
{
   long                      users;
   long                      globals;
   long                      locals;
   long                      computers;
   long                      generic;
};

class TANode:public TNode
{
   BOOL           bMarked;
   PSID           pSid;
   WCHAR          name[LEN_Account];
   
public:
   TANode() { name[0] = 0; bMarked = FALSE; pSid = NULL;}
   TANode(WCHAR const * n)
   {
      safecopy(name,n);
      bMarked = FALSE;
      pSid = NULL;
   }
   ~TANode() 
   {
      if ( pSid )
         delete pSid;
   }
   BOOL     Marked() { return bMarked; }
   void     Mark() { bMarked = TRUE; }
   void     SetSid(PSID p) { pSid = p; }
   void     SetName(WCHAR const * n){ safecopy(name,n); }
   WCHAR  * GetName() { return name; }
   PSID     GetSid() { return pSid;}
};

// Password generation service
#define PWGEN_MIN_LENGTH    8    // enforced minimum password length
#define PWGEN_MAX_LENGTH   14    // enforced maximum password length

struct EaPwdFilterInfo
{
   DWORD                     bEnforce;
   DWORD                     bAllowName;
   DWORD                     minLower;
   DWORD                     minUpper;
   DWORD                     minDigits;
   DWORD                     minSpecial;
   DWORD                     maxConsecutiveAlpha;
};



struct Options
{
   WCHAR                     srcComp[LEN_Account];  // source computername
   WCHAR                     srcDomain[LEN_Domain+1];
   WCHAR                     tgtDomain[LEN_Domain+1];
   WCHAR                     srcDomainDns[LEN_Path];
   WCHAR                     tgtDomainDns[LEN_Path];
   WCHAR                     tgtComp[LEN_Account];  // target computername
   PSID                      srcSid;
   PSID                      tgtSid;
   DWORD                     srcDomainVer;
   DWORD                     tgtDomainVer;
   WCHAR                     prefix[UNLEN];     // prefix for added users
   WCHAR                     suffix[UNLEN];     // suffix for added users
   WCHAR                     globalPrefix[UNLEN];
   WCHAR                     globalSuffix[UNLEN];
   WCHAR                     addToGroup[GNLEN+1]; // optional group name to add new users to
   WCHAR                     addToGroupSource[GNLEN+1]; // optional group name to add source users to
   WCHAR                     logFile[MAX_PATH+1];
   EaPwdFilterInfo           policyInfo;
   DWORD                     minPwdLength;
   CommaDelimitedLog         passwordLog;
   DWORD                     flags;             // operation flags
   BOOL                      nochange;
   WCHAR					 authUser[UNLEN+1];	//User name for source authentication
   WCHAR					 authPassword[UNLEN+1];	//Password for Authentication.
   WCHAR					 authDomain[LEN_Domain+1];	// Domain for the user passed for authentication
   HANDLE					 dsBindHandle;	// Handle to the directory service. Should be init by DsBind.
   WCHAR                     srcNamingContext[LEN_Path]; // Naming context for the Adsi path
   WCHAR                     tgtNamingContext[LEN_Path]; // Naming context for the Target domain
   WCHAR                     tgtOUPath[LEN_Path];       // path for the OU container that is to be used to create objects in
   BOOL                      expandContainers;          // Whether or not we want to expand the containers.
   BOOL                      expandMemberOf;
   BOOL                      fixMembership;
   IIManageDB              * pDb;
   BOOL                      bUndo;
   BOOL                      bSameForest;
   long                      lActionID;
   long                      lUndoActionID;
   MCSDCTWORKEROBJECTSLib::IStatusObjPtr             pStatus;
   WCHAR                     sDomUsers[UNLEN+1];               // Name of the domain users group in the source domain
   _bstr_t					 sExcUserProps;                    // user properties to exclude from migration
   _bstr_t					 sExcGroupProps;                   // group properties to exclude from migration
   _bstr_t					 sExcCmpProps;                     // computer properties to exclude from migration
   BOOL						 bExcludeProps;
   _bstr_t					 sWizard;
   

   Options() {
      srcComp[0] = 0;
      srcDomain[0] = 0;
      tgtDomain[0] = 0;
      srcDomainDns[0] = 0;
      tgtDomainDns[0] = 0;
      tgtComp[0] = 0;
      prefix[0] = 0;
      suffix[0] = 0;
      globalPrefix[0] = 0;
      globalSuffix[0] = 0;
      addToGroup[0] = 0;
      addToGroupSource[0] = 0;
      logFile[0] = 0;
      minPwdLength = 0;
      flags = 0;
      nochange = TRUE;
      authUser[0] = 0;
      authPassword[0] = 0;
      authDomain[0] = 0;
      srcNamingContext[0] = 0;
      tgtNamingContext[0] = 0;
      tgtOUPath[0] = 0;
      expandContainers = FALSE;
      fixMembership = TRUE;
      pDb = NULL;
      CoCreateInstance(CLSID_IManageDB,NULL,CLSCTX_ALL,IID_IIManageDB,(void**)&pDb);
      bUndo = FALSE;
      srcDomainVer = -1;
      tgtDomainVer = -1;
      srcSid = NULL;
      tgtSid = NULL;
      lUndoActionID = 0;
      pStatus = NULL;
      bSameForest = FALSE;
      sDomUsers[0] = 0;
	  bExcludeProps = FALSE;
   }
   ~Options()
   {
      if( pDb )
      {
         pDb->Release();
      }
      if ( srcSid )
         FreeSid(srcSid);
      if ( tgtSid )
         FreeSid(tgtSid);
   }
};


typedef void ProgressFn(WCHAR const * mesg);



int 
   UserCopy(
      Options              * options,       // in - options
      TNodeListSortable    * acctlist,      // in - list of accounts to process
      ProgressFn           * progress,      // in - function called to log current progress
      TError               & error,         // in - TError to write messages to      
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   fn (void ),    // in - window update function
      CProcessExtensions   * pExts          // in - pointer to extensions
  );


int 
   UserRename(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
  );

DWORD
   CopyServerName(
      WCHAR                 * uncServ     ,// out-UNC server name
      TCHAR const           * server       // in -\\server or domain name
   );


bool AddSidHistory( 
		  const Options * pOptions,
		  const WCHAR   * strSrcPrincipal,
		  const WCHAR   * strDestPrincipal,
        IStatusObj       * pStatus = NULL,
        BOOL            isFatal = TRUE
		);

bool BindToDS( 
			WCHAR * strDestDC, 
			Options * pOpt
		 );

bool AddToOU (
				  Options              * options,      // in -options
				  TNodeListSortable    * acctlist     // in -list of accounts to process
			 );

void MakeFullyQualifiedAdsPath(
                                             WCHAR * sPath,          //out- Fully qulified LDAP path to the object
											 DWORD	 nPathLen,		 //in - MAX size, in characters, of the sPath buffer
                                             WCHAR * sSubPath,       //in- LDAP subpath of the object
                                             WCHAR * tgtDomain,      //in- Domain name where object exists.
                                             WCHAR * sDN             //in- Deafault naming context for the Domain 
                                          );

BOOL GetDnsAndNetbiosFromName(WCHAR * name,WCHAR * netBios, WCHAR * dns);

void FillupNamingContext(Options * options);

bool IsAccountMigrated( 
                        TAcctReplNode * pNode,     //in -Account node that contains the Account info
                        Options       * pOptions,  //in -Options as specified by the user.
                        IIManageDBPtr   pDb,       //in -Pointer to DB manager. We dont want to create this object for every account we process
                        WCHAR         * sTgtSam    //in,out - Name of the target object that was copied if any.
                     );

bool CheckifAccountExists(
                        Options const* options,    //in-Options as set by the user
                        WCHAR * acctName           //in-Name of the account to look for
                     );

bool CallExtensions(
                     CProcessExtensions   * pExt,         // in - Extension handler.
                     Options              * options,      // in -options
                     TNodeListSortable    * acctlist,     //in -Accounts to be copied.
                     IStatusObj           * pStatus,      // in -status object to support cancellation
                     ProgressFn           * progress      //in- Progress function.
                   );

void
   CopyGlobalGroupMembers(
      Options const        * options      ,// in -options
      TAcctReplNode        * acct         ,// in -account to copy
      TNodeListSortable    * acctlist     ,// in -list of accounts being copied
      void                   WindowUpdate (void )    // in - window update function
   );

void
   CopyLocalGroupMembers(
      Options const        * options      ,// in -options
      TAcctReplNode        * acct         ,// in -account to copy
      TNodeListSortable    * acctlist     ,// in -list of accounts being copied
      void                   WindowUpdate (void )    // in - window update function
   );

HRESULT 
   CopySidHistoryProperty(
      Options              * pOptions,
      TAcctReplNode        * pNode,
      IStatusObj              * pStatus
   );

HRESULT
   GetRidPoolAllocator(
      Options              * pOptions
   );

void Mark( _bstr_t sMark,   _bstr_t sObj);
DWORD GetName(PSID pObjectSID, WCHAR * sNameAccount, WCHAR * sDomain);

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif //__USERCOPY_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\usercopy.cpp ===
//#pragma title("usercopy- copies user accounts")
/*
================================================================================

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

 Program    - usercopy
 Class      - LAN Manager Utilities
 Author     - Tom Bernhardt
 Created    - 05/08/91
 Description- Merges the NetUser information from the specified source
              server with the target system (or the current system if no
              target is specified).  Group information is also merged if
              the /g option is given.   Existing entries on the target system
              are not overwritten unless the /r option is used.

 Syntax     - USERCOPY source [target] [/u] [/l] [/g] [/r]
        where:
           source   source server
           target   destination server
           /g       copies global group information
           /l       copies local group information

           /u       copies user information
           /r       replaces existing target entries with source entries
           /AddTo:x Adds all newly created users (/u) to group "x"

 Updates    - 
 91/06/17 TPB General code cleanup and change so that all stdout i/o lines up 
              nicely on-screen for reporting.
 93/06/12 TPB Port to Win32
 96/06/21 TPB Support for local groups
 97/09/20 CAB Added subset of accounts option for GUI
 98/06    TPB/CAB Support for computer accounts
 99/01    COM-ization of DCT.
================================================================================
*/
#include "StdAfx.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <ntdsapi.h>
#include <lm.h>
#include <iads.h>
#include "TxtSid.h"

#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETERRORS
#include <lm.h>

#include "Common.hpp"                    
#include "UString.hpp"                   

#include "WorkObj.h"

//#include "Usercopy.hpp" //#included by ARUtil.hpp below

#include "ARUtil.hpp"
#include "BkupRstr.hpp"
#include "RebootU.h"

#include "DCTStat.h"
#include "ErrDct.hpp"
#include "Win2KErr.h"
#include "RegTrans.h"
#include "TEvent.hpp"
#include <dsgetdc.h>
#include <sddl.h>


//#import "\bin\NetEnum.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "NetEnum.tlb" no_namespace
//#import "DBMgr.tlb" no_namespace, named_guids //already #imported via ARUtil.hpp

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct             err;
extern TErrorDct           & errC;


bool                         abortall;
extern bool						  g_bAddSidWorks = false;

// global counts of accounts processed
AccountStats                 warnings =  { 0,0,0,0 };
AccountStats                 errors =    { 0,0,0,0 };
AccountStats                 created =   { 0,0,0,0 };
AccountStats                 replaced =  { 0,0,0,0 };
AccountStats                 processed = { 0,0,0,0 };

BOOL                         machineAcctsCreated = FALSE;
BOOL                         otherAcctsCreated = FALSE;
PSID                         srcSid = NULL;      // SID for source domain


typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);
typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSADDSIDHISTORY)(HANDLE, DWORD, LPCTSTR, LPCTSTR, LPCTSTR, RPC_AUTH_IDENTITY_HANDLE,LPCTSTR,LPCTSTR);
    

int TNodeCompareSourceName(TNode const * t1,TNode const * t2)
{
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   return UStrICmp(n1->GetName(),n2->GetName());
}

int TNodeCompareSourceNameValue(TNode const * t1, void const * v)
{
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   WCHAR             const * name = (WCHAR const *)v;

   return UStrICmp(n1->GetName(),name);
}


bool BindToDS( WCHAR * strDestDC, Options * pOpt)
{
	// Get the handle to the Directory service.
	DSBINDFUNC DsBind;
   	HINSTANCE hInst = LoadLibrary(L"NTDSAPI.DLL");
	if ( hInst )
	{
		DsBind = (DSBINDFUNC) GetProcAddress(hInst, "DsBindW");
		if (DsBind)
		{
			DWORD rc = DsBind(strDestDC, NULL, &pOpt->dsBindHandle);
			if ( rc != 0 ) 
			{
				err.SysMsgWrite( ErrE, rc, DCT_MSG_DSBIND_FAILED_S, strDestDC);
            Mark(L"errors", L"generic");
				FreeLibrary(hInst);
				return false;
			}
		}
		else
		{
			err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_GET_PROC_ADDRESS_FAILED_SSD,L"NTDSAPI.DLL",L"DsBindW",GetLastError());
         Mark(L"errors", L"generic");
			FreeLibrary(hInst);
			return false;
		}
	}
	else
	{
		err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_LOAD_LIBRARY_FAILED_SD,L"NTDSAPI.DLL",GetLastError());
      Mark(L"warnings", L"generic");
		return false;
	}
	FreeLibrary(hInst);
	return true;
}

// The following function is used to get the actual account name from the source domain
// instead of account that contains the SID in its SID history.
DWORD GetName(PSID pObjectSID, WCHAR * sNameAccount, WCHAR * sDomain)
{
	DWORD		cb = 255;
	DWORD    cbDomain = 255;
   DWORD    tempVal;
   PDWORD   psubAuth;
   PUCHAR   pVal;
   SID_NAME_USE	sid_Use;
   WCHAR    sDC[255];
   DWORD    rc = 0;

   if ((pObjectSID == NULL) || !IsValidSid(pObjectSID))
   {
      return ERROR_INVALID_PARAMETER;
   }
   // Copy the Sid to a temp SID
   DWORD    sidLen = GetLengthSid(pObjectSID);
   PSID     pObjectSID1 = new BYTE[sidLen];
   if (!pObjectSID1)
      return ERROR_NOT_ENOUGH_MEMORY;

   if (!CopySid(sidLen, pObjectSID1, pObjectSID))
   {
      return GetLastError();
   }
   if (!IsValidSid(pObjectSID1))
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE, rc,DCT_MSG_DOMAIN_LOOKUP_FAILED_D,rc);
      Mark(L"errors", L"generic");
	  delete pObjectSID1;
      return rc;
   }

   // Get the RID out of the SID and get the domain SID
   pVal = GetSidSubAuthorityCount(pObjectSID1);
   (*pVal)--;
   psubAuth = GetSidSubAuthority(pObjectSID1, *pVal);
   tempVal = *psubAuth;
   *psubAuth = -1;

   //Lookup the domain from the SID 
   if (!LookupAccountSid(NULL, pObjectSID1, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use))
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE, rc,DCT_MSG_DOMAIN_LOOKUP_FAILED_D,rc);
      Mark(L"errors", L"generic");
	  delete pObjectSID1;
      return rc;
   }
   
   // Get a DC for the domain
   DSGETDCNAME DsGetDcName = NULL;
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   
   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   if ( hPro )
      DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
   else
   {
      long rc = GetLastError();
      err.SysMsgWrite(ErrE, rc, DCT_MSG_LOAD_LIBRARY_FAILED_SD, L"NetApi32.dll");
      Mark(L"errors", L"generic");
   }

   if (DsGetDcName)   
   {
      if ( DsGetDcName(
                        NULL                                  ,// LPCTSTR ComputerName ?
                        sDomain                               ,// LPCTSTR DomainName
                        NULL                                  ,// GUID *DomainGuid ?
                        NULL                                  ,// LPCTSTR SiteName ?
                        0                                     ,// ULONG Flags ?
                        &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
                     ))
      {
         err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_GET_DCNAME_FAILED_SD,sDomain,GetLastError());
         Mark(L"errors", L"generic");
	     delete pObjectSID1;
         return GetLastError();
      }
      else
      {
         wcscpy(sDC, pSrcDomCtrlInfo->DomainControllerName);
         NetApiBufferFree(pSrcDomCtrlInfo);
      }

      // Reset the sizes
      cb = 255;
      cbDomain = 255;

      // Lookup the account on the PDC that we found above.
      if ( LookupAccountSid(sDC, pObjectSID, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use) == 0)
      {
	     delete pObjectSID1;
         return GetLastError();
      }
   }
   delete pObjectSID1;
   FreeLibrary(hPro);
   return 0;
}

/* This is a list of specific error codes that can be returned by DsAddSidHistory.
This was obtained from Microsoft via email

  > ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
>     The operation requires that destination domain auditing be enabled for
>     Success and Failure auditing of account management operations.
> 
> ERROR_DS_UNWILLING_TO_PERFORM
>     It may be that the user account is not one of UF_NORMAL_ACCOUNT,
>     UF_WORKSTATION_TRUST_ACCOUNT, or UF_SERVER_TRUST_ACCOUNT.
> 
>     It may be that the source principal is a built in account.
> 
>     It may be that the source principal is a well known RID being added
>     to a destination principal that is a different RID. In other words,
>     Administrators of the source domain can only be assigned to
>     Administrators of the destination domain.
> 
> ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
>     The source object must be a group or user.
> 
> ERROR_DS_SRC_SID_EXISTS_IN_FOREST
>     The source object's SID already exists in destination forest.
> 
> ERROR_DS_INTERNAL_FAILURE;
>     The directory service encountered an internal failure. Shouldn't
> happen.
> 
> ERROR_DS_MUST_BE_RUN_ON_DST_DC
>     For security reasons, the operation must be run on the destination DC.
>     Specifically, the connection between the client and server
> (destination
>     DC) requires 128-bit encryption when credentials for the source domain
>     are supplied.
> 
> ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
>     The connection between client and server requires packet privacy or
> better.
> 
> ERROR_DS_SOURCE_DOMAIN_IN_FOREST
>     The source domain may not be in the same forest as destination.
> 
> ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
>     The destination domain must be in the forest.
> 
> ERROR_DS_MASTERDSA_REQUIRED
>     The operation must be performed at a master DSA (writable DC).
> 
> ERROR_DS_INSUFF_ACCESS_RIGHTS
>     Insufficient access rights to perform the operation. Most likely
>     the caller is not a member of domain admins for the dst domain.
> 
> ERROR_DS_DST_DOMAIN_NOT_NATIVE
>     Destination domain must be in native mode.
> 
> ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
>     The operation couldn't locate a DC for the source domain.
> 
> ERROR_DS_OBJ_NOT_FOUND
>     Directory object not found. Most likely the FQDN of the 
>     destination principal could not be found in the destination
>     domain.
> 
> ERROR_DS_NAME_ERROR_NOT_UNIQUE
>     Name translation: Input name mapped to more than one
>     output name. Most likely the destination principal mapped
>     to more than one FQDN in the destination domain.
> 
> ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
>     The source and destination object must be of the same type.
> 
> ERROR_DS_OBJ_CLASS_VIOLATION
>     The requested operation did not satisfy one or more constraints
>     associated with the class of the object. Most likely because the
>     destination principal is not a user or group.
> 
> ERROR_DS_UNAVAILABLE
>     The directory service is unavailable. Most likely the
>     ldap_initW() to the NT5 src DC failed.
> 
> ERROR_DS_INAPPROPRIATE_AUTH
>     Inappropriate authentication. Most likely the ldap_bind_sW() to
>     the NT5 src dc failed.
> 
> ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
>     The operation requires that source domain auditing be enabled for
>     Success and Failure auditing of account management operations.
> 
> ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
>     For security reasons, the source DC must be Service Pack 4 or greater.
> 
*/
BOOL GetDnsAndNetbiosFromName(WCHAR * name,WCHAR * netBios, WCHAR * dns)
{
   IADs      * pDomain = NULL;
   WCHAR       strText[1000];

   // try to connect to the AD, using the specified name
   swprintf(strText,L"LDAP://%ls",name);

   HRESULT hr = ADsGetObject(strText,IID_IADs,(void**)&pDomain);
   if ( SUCCEEDED(hr) )
   {
      _variant_t        var;

      // get the NETBIOS name from the LDAP provider
      hr = pDomain->Get(L"nETBIOSName",&var);
      if ( SUCCEEDED(hr) )
      {
         UStrCpy(netBios,(WCHAR*)var.bstrVal);
      }
      else
      {
         hr = pDomain->Get(L"name",&var);
         if ( SUCCEEDED(hr) )
         {
            UStrCpy(netBios,(WCHAR*)var.bstrVal);
         }
      }

      // get the DNS name from the LDAP provider
      hr = pDomain->Get(L"distinguishedName",&var);
      if ( SUCCEEDED(hr) )
      {
         WCHAR * dn = (WCHAR*)var.bstrVal;
         WCHAR * curr = dns;

         if ( !UStrICmp(dn,L"DC=",3) )
         {
            
            // for each ",DC=" in the name, replace it with a .
            for ( curr = dns, dn = dn+3 ;    // skip the leading "DC="
                  *dn       ;    // until the end of the string is reached
                  curr++         // 
                )
            {
               if ( (L',' == *dn)  && (L'D' == *(dn+1)) && (L'C' == *(dn+2)) && (L'=' == *(dn+3)) )
               {
                  (*curr) = L'.';
                  dn+=4;
               }
               else
               {
                  // just copy the character
                  (*curr) = (*dn);
                  dn++;
               }
            }
            *(curr) = 0;
         }
      }
      pDomain->Release();
   }
   else
   {
      // default to using the specified name as both DNS and NETBIOS
      // this will work for NT 4 domains
      UStrCpy(netBios,name);
      UStrCpy(dns,name);
   }
   return TRUE;
}

HRESULT 
   CopySidHistoryProperty(
      Options              * pOptions,
      TAcctReplNode        * pNode,
      IStatusObj              * pStatus
   )
{
   HRESULT                   hr = S_OK;
   IADs                    * pAds = NULL;
   _variant_t                var;
//   long                      ub = 0, lb = 0;

   // fetch the SIDHistory property for the source account
   // for each entry in the source's SIDHistory, call DsAddSidHistory

   // Get the IADs pointer to the object and get the SIDHistory attribute.
   hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetSourcePath()), IID_IADs, (void**)&pAds);
   if ( SUCCEEDED(hr) )
   {
      hr = pAds->Get(L"sIDHistory", &var);
   }

   if ( SUCCEEDED(hr) )
   {
      // This is a multivalued property so we need to get all the values
      // for each one get the name and the domain of the object and then call the 
      // add sid history function to add the SID to the target objects SIDHistory.
		_variant_t		        var;
		DWORD rc = pAds->GetEx(L"sIDHistory", &var);
		if ( !rc )
		{
			if ( V_VT(&var) == (VT_ARRAY | VT_VARIANT) )
         {
            // This is the array type that we were looking for.
            void HUGEP *pArray;
			   VARIANT var2;
			   ULONG dwSLBound = -1; 
			   ULONG dwSUBound = -1;
			   
			   hr = SafeArrayGetLBound( V_ARRAY(&var),
                                     1,
                                     (long FAR  *) &dwSLBound );
            hr = SafeArrayGetUBound( V_ARRAY(&var),
                                      1,
                                      (long FAR  *) &dwSUBound );
            if (SUCCEEDED(hr))
            {
               // Each element in this array is a SID in form of a VARIANT
               hr = SafeArrayAccessData( V_ARRAY(&var), &pArray );
				   for ( long x = (long)dwSLBound; x <= (long)dwSUBound; x++)
				   {
					   hr = SafeArrayGetElement(V_ARRAY(&var), &x, &var2);
                  // Get the SID from the Variant in a ARRAY form
					   hr = SafeArrayAccessData( V_ARRAY(&var2), &pArray );
					   PSID pObjectSID = (PSID)pArray;
					   //Convert SID to string.
					   if (pObjectSID) 
					   {
						   WCHAR		sNameAccount[255];
						   WCHAR		sDomain[255];
                     WCHAR    sNetBIOS[255];
                     DWORD    rc = 0;

                     rc = GetName(pObjectSID, sNameAccount, sDomain);
                     if (!rc)
                     {
                        WCHAR               sTemp[LEN_Path];
                        WCHAR               sSourceDNS[LEN_Path];
                        // We are going to temporarily change the Domain DNS to the domain of the SID we are adding
                        wcscpy(sTemp, pOptions->srcDomainDns);
                        if ( GetDnsAndNetbiosFromName(sDomain, sNetBIOS, sSourceDNS) )
                        {
                           wcscpy(pOptions->srcDomainDns, sSourceDNS);
                           AddSidHistory(pOptions, sNameAccount, pNode->GetTargetSam(), NULL, FALSE);
                           // Replace the original domain dns.
                           wcscpy(pOptions->srcDomainDns, sTemp);
                        }
                        else
                        {
                           err.SysMsgWrite(ErrE, GetLastError(),DCT_MSG_DOMAIN_DNS_LOOKUP_FAILED_SD, sDomain,GetLastError());
                           Mark(L"errors", pNode->GetType());
                        }
                     }
						   else
                     {
						      // Get name failed we need to log a message.
                        WCHAR                       sSid[LEN_Path];
                        DWORD                       len = LEN_Path;
                        GetTextualSid(pObjectSID, sSid, &len);
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_CONVERTING_SID_SSD,
                                        pNode->GetTargetName(), sSid, rc);
                        Mark(L"errors", pNode->GetType());
                     }
					   }
                  SafeArrayUnaccessData(V_ARRAY(&var2));
				   }
               SafeArrayUnaccessData(V_ARRAY(&var));
            }           
         }              
		}
		else
		{
         // No SID History to copy.
		}
   }
   return hr;
}


bool AddSidHistory( const Options * pOptions,
						  const WCHAR   * strSrcPrincipal,
						  const WCHAR   * strDestPrincipal,
                    IStatusObj    * pStatus,
                    BOOL            isFatal)
{
	//Add the sid to the history
	// Authentication Structure 
	SEC_WINNT_AUTH_IDENTITY		auth;
   DWORD                      rc = 0;
	//memset(&auth, 0, sizeof(SEC_WINNT_AUTH_IDENTITY));

	auth.User = const_cast<WCHAR*>(pOptions->authUser);
	auth.UserLength = wcslen(pOptions->authUser);
	auth.Password = const_cast<WCHAR*>(pOptions->authPassword);
	auth.PasswordLength = wcslen(pOptions->authPassword);
	auth.Domain = const_cast<WCHAR*>(pOptions->authDomain);
	auth.DomainLength = wcslen(pOptions->authDomain);
	auth.Flags  = SEC_WINNT_AUTH_IDENTITY_UNICODE;

	// Auth Identity handle
	// if source domain credentials supplied use them
	// otherwise credentials of caller will be used
	RPC_AUTH_IDENTITY_HANDLE pHandle = ((auth.DomainLength > 0) && (auth.UserLength > 0)) ? &auth : NULL;

	DSADDSIDHISTORY	DsAddSidHistory;
	HINSTANCE hInst = LoadLibrary(L"NTDSAPI.DLL");
   

	if ( hInst )
	{
		DsAddSidHistory = (DSADDSIDHISTORY) GetProcAddress(hInst, "DsAddSidHistoryW");
		if (DsAddSidHistory)
		{
         if ( !pOptions->nochange )
         {
            int loopCount = 0;
            rc = RPC_S_SERVER_UNAVAILABLE;
            // If we get the RPC server errors we need to retry 5 times.
			   while ( (((rc == RPC_S_SERVER_UNAVAILABLE) || (rc == RPC_S_CALL_FAILED) || (rc == RPC_S_CALL_FAILED_DNE)) && loopCount < 5)
                     || ( (rc == ERROR_INVALID_HANDLE) && loopCount < 3 ) )      // In case of invalid handle we try it 3 times now.
            {
               // Make the API call to add Sid to the history
			      rc = DsAddSidHistory( 
                                pOptions->dsBindHandle,		//DS Handle
								        NULL,							// flags
								        pOptions->srcDomainDns,			// Source domain
								        strSrcPrincipal,				// Source Account name
								        NULL,			// Source Domain Controller
								        pHandle,						// RPC_AUTH_IDENTITY_HANDLE
								        pOptions->tgtDomainDns,			   // Target domain
								        strDestPrincipal);			// Target Account name
               if ( loopCount > 0 ) Sleep(500);
               loopCount++;
            }
         }

			if ( rc != 0 )
			{
            switch ( rc )
            {
               // these are the error codes caused by permissions or configuration problems
               case ERROR_NONE_MAPPED:
                  err.MsgWrite(ErrE, DCT_MSG_ADDSIDHISTORY_FAIL_BUILTIN_SSD,strSrcPrincipal, strDestPrincipal, rc); 
                  break;
               case ERROR_DS_UNWILLING_TO_PERFORM:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DS_UNWILLING_TO_PERFORM_SSSSD,strDestPrincipal,pOptions->srcDomain, strSrcPrincipal, pOptions->tgtDomain,rc);
                  break;
               case ERROR_DS_INSUFF_ACCESS_RIGHTS:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INSUFF_ACCESS_SD,strDestPrincipal,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_INVALID_HANDLE:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INVALID_HANDLE_SSD,pOptions->srcDomainDns,strDestPrincipal,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOAUDIT_SSD,strDestPrincipal,pOptions->tgtDomainDns,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_MUST_BE_RUN_ON_DST_DC:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DST_DC_SD,strDestPrincipal,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_PKT_PRIVACY_SD,strDestPrincipal,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_SOURCE_DOMAIN_IN_FOREST:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_SOURCE_IN_FOREST_S,strDestPrincipal);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DEST_WRONG_FOREST_S,strDestPrincipal);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_MASTERDSA_REQUIRED:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NO_MASTERDSA_S,strDestPrincipal);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_ACCESS_DENIED:
                  g_bAddSidWorks = FALSE;
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INSUFF2_SSS,strDestPrincipal,pOptions->authDomain,pOptions->authUser);
                  break;
               case ERROR_DS_DST_DOMAIN_NOT_NATIVE:
                  g_bAddSidWorks = FALSE;
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOT_NATIVE_S,strDestPrincipal);
                  break;
               case ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN:
                  g_bAddSidWorks = FALSE;
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NO_SOURCE_DC_S,strDestPrincipal);
                  break;
   //            case ERROR_DS_INAPPROPRIATE_AUTH:
               case ERROR_DS_UNAVAILABLE:
                  g_bAddSidWorks = FALSE;
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DS_UNAVAILABLE_S,strDestPrincipal);
                  break;
               case ERROR_DS_SOURCE_AUDITING_NOT_ENABLED:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOAUDIT_SSD,strDestPrincipal,pOptions->srcDomain,rc);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_SOURCE_NOT_SP4_S,strDestPrincipal);
                  g_bAddSidWorks = FALSE;
                  break;
               case ERROR_SESSION_CREDENTIAL_CONFLICT:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_CREDENTIALS_CONFLICT_SSSS,strDestPrincipal,pOptions->srcDomain,pOptions->authDomain,pOptions->authUser);
                  g_bAddSidWorks = FALSE;
                  break;
               // these are error codes that only affect this particular account
               case ERROR_SUCCESS:
                  g_bAddSidWorks = TRUE;
                  // no error message needed for success case!
                  break;

               case ERROR_DS_SRC_SID_EXISTS_IN_FOREST:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_IN_FOREST_SD,strDestPrincipal,rc);
                  g_bAddSidWorks = TRUE;
                  break;

               case ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER:
                  err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_WRONGTYPE_SD,strDestPrincipal,rc);
                  g_bAddSidWorks = TRUE;
                   break;
               default:
                 err.MsgWrite(ErrE,DCT_MSG_ADDSID_FAILED_SSD,strSrcPrincipal, strDestPrincipal,rc);
                 g_bAddSidWorks = TRUE;
                   break;
               }
      
            Mark(L"errors", L"generic");

            // This may or may not be a fatal error depending on weather we are Adding
            // sid history or copying sid history
            g_bAddSidWorks |= !(isFatal);

            if (! g_bAddSidWorks )
            {
               // log a message indicating that SIDHistory will not be tried for the rest of the accounts
               err.MsgWrite(ErrW,DCT_MSG_SIDHISTORY_FATAL_ERROR);
               Mark(L"warnings", L"generic");
               // we are going to set the status to abort so that we don't try to migrate anymore.
               if ( pStatus )
               {
                  pStatus->put_Status(DCT_STATUS_ABORTING);
               }
               
            }
				FreeLibrary(hInst);
				return false;
			}
			else
			{
				err.MsgWrite(0, DCT_MSG_ADD_SID_SUCCESS_SSSS, pOptions->srcDomainDns, strSrcPrincipal, pOptions->tgtDomainDns, strDestPrincipal);
				FreeLibrary(hInst);
				return true;
			}
		}
		else
		{
			err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_NO_ADDSIDHISTORY_FUNCTION);
         Mark(L"errors", L"generic");
			FreeLibrary(hInst);
			return false;
		}
	}
	else
	{
		err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_NO_NTDSAPI_DLL);
      Mark(L"errors", L"generic");
		return false;
	}
}

//--------------------------------------------------------------------------
// FillupNamingContext : This function fills in the target Naming context
//                       for NT5 domain.
//--------------------------------------------------------------------------
void FillupNamingContext(
                     Options * options  //in,out- Options to fill up
                   )
{
   WCHAR                     sPath[LEN_Path];
   IADs                    * pAds;
   _variant_t                var;
   HRESULT                   hr;

   wsprintf(sPath, L"LDAP://%s/rootDSE", options->tgtDomain);
   hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr) )
   {
      wcscpy(options->tgtNamingContext, L"");
      return;
   }

   hr = pAds->Get(L"defaultNamingContext", &var);
   if ( FAILED(hr) )
   {
      wcscpy(options->tgtNamingContext, L"");
      return;
   }
   pAds->Release();
   wcscpy(options->tgtNamingContext, (WCHAR*) V_BSTR(&var));
}

//--------------------------------------------------------------------------
// MakeFullyQualifiedAdsPath : Makes a LDAP sub path into a fully qualified 
//                             LDAP path name.
//--------------------------------------------------------------------------
void MakeFullyQualifiedAdsPath(
                                 WCHAR * sPath,          //out- Fully qulified LDAP path to the object
								 DWORD	 nPathLen,		 //in - MAX size, in characters, of the sPath buffer
                                 WCHAR * sSubPath,       //in- LDAP subpath of the object
                                 WCHAR * tgtDomain,      //in- Domain name where object exists.
                                 WCHAR * sDN             //in- Default naming context for the Domain 
                              )
{
   if ((!sPath) || (!sSubPath) || (!tgtDomain) || (!sDN))
      return;

   _bstr_t sTempPath;
   if (wcsncmp(sSubPath, L"LDAP://", 7) == 0)
   {
      //it is already a fully qualified LDAP path so lets copy it and return it
      wcsncpy(sPath, sSubPath, nPathLen-1);
      return;
   }

   //We need to build this path so lets get to work
   if ( wcslen(sDN) )
   {
	  sTempPath = L"LDAP://";
	  sTempPath += tgtDomain;
	  sTempPath += L"/";
	  sTempPath += sSubPath;
	  sTempPath += L",";
	  sTempPath += sDN;
	  wcsncpy(sPath, sTempPath, nPathLen-1);
//      wsprintf(sPath, L"LDAP://%s/%s,%s", tgtDomain, sSubPath, sDN);
   }
   else
   {
	  sTempPath = L"LDAP://";
	  sTempPath += tgtDomain;
	  sTempPath += L"/";
	  sTempPath += sSubPath;
	  wcsncpy(sPath, sTempPath, nPathLen-1);
//      wsprintf(sPath, L"LDAP://%s/%s", tgtDomain, sSubPath);
   }
}


//--------------------------------------------------------------------------
// IsAccountMigrated : Function checks if the account has been migrated in
//                     the past. If it has it returns true filling in the
//                     name of the target object in case it was renamed.
//                     Otherwise it returns FALSE and Empty string for the 
//                     target name.
//--------------------------------------------------------------------------
bool IsAccountMigrated( 
                        TAcctReplNode * pNode,     //in -Account node that contains the Account info
                        Options       * pOptions,  //in -Options as specified by the user.
                        IIManageDBPtr   pDb,       //in -Pointer to DB manager. We dont want to create this object for every account we process
                        WCHAR         * sTgtSam    //in,out - Name of the target object that was copied if any.
                     )
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;

   pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);

   HRESULT hrFind = pDb->raw_GetAMigratedObject(const_cast<WCHAR*>(pNode->GetName()), pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
   pUnk->Release();
   if ( hrFind != S_OK )
   {
      wcscpy(sTgtSam,L"");
      return false;
   }
   else
   {
      _bstr_t     sText;
      sText = pVs->get(L"MigratedObjects.TargetSamName");
	  if (!(WCHAR*)sText)
	  {
         wcscpy(sTgtSam,L"");
	     return false;
	  }
      wcscpy(sTgtSam, (WCHAR*) sText);
      return true;
   }
}

bool CheckifAccountExists(
                        Options const * options,   //in-Options as set by the user
                        WCHAR * acctName     //in-Name of the account to look for
                     )
{
   USER_INFO_0             * buf;
   long                      rc = 0;
   if ( (rc = NetUserGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }
   
   if ( (rc = NetGroupGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }

   if ( (rc = NetLocalGroupGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }

   return false;
}

//--------------------------------------------------------------------------
// Mark : Increments appropriate counters depending on the arguments.
//--------------------------------------------------------------------------
void Mark( 
                        _bstr_t sMark,    //in- Represents the type of marking { processed, errors, replaced, created }
                        _bstr_t sObj      //in- Type of object being marked { user, group, computer }
                     )
{
   if (!UStrICmp(sMark,L"processed"))
   {
      if ( !UStrICmp(sObj,L"user")) processed.users++;
      else if ( !UStrICmp(sObj,L"group")) processed.globals++;
      else if ( !UStrICmp(sObj,L"computer")) processed.computers++;
      else if ( !UStrICmp(sObj,L"generic")) processed.generic++;
   }
   else if (!UStrICmp(sMark,L"errors"))
   {
      if ( !UStrICmp(sObj,L"user")) errors.users++;
      else if ( !UStrICmp(sObj,L"group")) errors.globals++;
      else if ( !UStrICmp(sObj,L"computer")) errors.computers++;
      else if ( !UStrICmp(sObj,L"generic")) errors.generic++;
   }
   else if (!UStrICmp(sMark,L"warnings"))
   {
      if ( !UStrICmp(sObj,L"user")) warnings.users++;
      else if ( !UStrICmp(sObj,L"group")) warnings.globals++;
      else if ( !UStrICmp(sObj,L"computer")) warnings.computers++;
      else if ( !UStrICmp(sObj,L"generic")) warnings.generic++;
   }
   else if (!UStrICmp(sMark,L"replaced"))
   {
      if ( !UStrICmp(sObj,L"user")) replaced.users++;
      else if ( !UStrICmp(sObj,L"group")) replaced.globals++;
      else if ( !UStrICmp(sObj,L"computer")) replaced.computers++;
      else if ( !UStrICmp(sObj,L"generic")) replaced.generic++;
   }
   else if (!UStrICmp(sMark,L"created"))
   {
      if ( !UStrICmp(sObj,L"user")) created.users++;
      else if ( !UStrICmp(sObj,L"group")) created.globals++;
      else if ( !UStrICmp(sObj,L"computer")) created.computers++;
      else if ( !UStrICmp(sObj,L"generic")) created.generic++;
   }
}

HRESULT
   GetRidPoolAllocator(
      Options              * pOptions
   )
{
   _bstr_t                   sRidMaster = L"";
   BSTR                      sParent = L"";
   _bstr_t                   sRidAllocator = pOptions->srcComp;
   _variant_t                varProp;
   IADs                    * pAds = NULL;

   WCHAR                     sPath[LEN_Path];
   HRESULT                   hr = S_OK;

   wsprintf(sPath, L"LDAP://%s/CN=RID Manager$,CN=System,%s", pOptions->srcComp + 2, pOptions->srcNamingContext);
   hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);

   if ( SUCCEEDED(hr) )
   {
      hr = pAds->Get(L"fSMORoleOwner", &varProp);
      pAds->Release();
   }
   
   if ( SUCCEEDED(hr) )
   {
      sRidMaster = varProp.bstrVal;
      wsprintf(sPath, L"LDAP://%s/%s", pOptions->srcDomain, (WCHAR*) sRidMaster);
      hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);
   }

   if ( SUCCEEDED(hr) )
   {
      hr = pAds->get_Parent(&sParent);
      pAds->Release();
   }

   if ( SUCCEEDED(hr) )
   {
      hr = ADsGetObject((WCHAR*)sParent, IID_IADs, (void**)&pAds);
   }

   if ( SUCCEEDED(hr) )
   {
      hr = pAds->Get(L"name", &varProp);
      pAds->Release();
   }

   if ( SUCCEEDED(hr) )
      sRidAllocator = varProp.bstrVal;

   if ( ((WCHAR*) sRidAllocator)[0] == L'\\' )
      wcscpy(pOptions->srcComp, (WCHAR*) sRidAllocator);
   else
      wsprintf(pOptions->srcComp, L"\\\\%s", (WCHAR*) sRidAllocator);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\userrts.h ===
// UserRights.h : Declaration of the CUserRights

#ifndef __USERRIGHTS_H_
#define __USERRIGHTS_H_

#include "resource.h"       // main symbols
#include <comdef.h>

#include "ntsecapi.h"

#include "CommaLog.hpp"

class PrivNode;
class PrivList;

/////////////////////////////////////////////////////////////////////////////
// CUserRights
class ATL_NO_VTABLE CUserRights : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUserRights, &CLSID_UserRights>,
	public IDispatchImpl<IUserRights, &IID_IUserRights, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   BOOL                      m_bNoChange;
   BOOL                      m_bUseDisplayName;
   BOOL                      m_bRemove;
   _bstr_t                   m_SourceComputer;
   _bstr_t                   m_TargetComputer;
   LSA_HANDLE                m_SrcPolicy;
   LSA_HANDLE                m_TgtPolicy;
public:
	CUserRights()
	{
	   m_bNoChange = FALSE;
      m_bUseDisplayName = FALSE;
      m_bRemove = FALSE;
      m_SrcPolicy = 0;
      m_TgtPolicy = 0;
   }
   ~CUserRights();
   
DECLARE_REGISTRY_RESOURCEID(IDR_USERRIGHTS)
DECLARE_NOT_AGGREGATABLE(CUserRights)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUserRights)
	COM_INTERFACE_ENTRY(IUserRights)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IUserRights
public:
	STDMETHOD(GetRightsOfUser)(BSTR server, BSTR user, SAFEARRAY ** rights);
	STDMETHOD(GetUsersWithRight)(BSTR server, BSTR right, /*[out]*/ SAFEARRAY ** users);
	STDMETHOD(GetRights)(BSTR server, /*[out]*/ SAFEARRAY ** rights);
	STDMETHOD(RemoveUserRight)(BSTR server, BSTR username, BSTR right);
	STDMETHOD(AddUserRight)(BSTR server, BSTR username, BSTR right);
	STDMETHOD(ExportUserRights)(BSTR server, BSTR filename, BOOL bAppendToFile);
	STDMETHOD(get_RemoveOldRightsFromTargetAccounts)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_RemoveOldRightsFromTargetAccounts)(/*[in]*/ BOOL newVal);
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(CopyUserRights)(BSTR sourceUserName, BSTR targetUserName);
	STDMETHOD(OpenTargetServer)(BSTR computerName);
	STDMETHOD(OpenSourceServer)(BSTR serverName);
   STDMETHOD(CopyUserRightsWithSids)(BSTR sourceUserName, BSTR sourceSID,BSTR targetUserName,BSTR targetSID);
	
protected:
   DWORD CopyUserRightsInternal(WCHAR * sourceUserName,WCHAR * tgtUserName, WCHAR * sourceSid, WCHAR * targetSid,BOOL noChange, BOOL remove);
   DWORD EnumerateAccountsWithRight(LSA_HANDLE policy, WCHAR * server,LSA_UNICODE_STRING * pRight, CommaDelimitedLog * pLog);
   DWORD SafeArrayFromPrivList(PrivList * privList, SAFEARRAY ** pArray);
   
};

#endif //__USERRIGHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\wtsinfo.h ===
#ifndef WTSINFO_H
#define WTSINFO_H

// Windows Terminal Server Information
typedef struct EaWtsUserInfo
{
   DWORD                     inheritInitialProgram; 
   DWORD                     allowLogonTerminalServer;
   DWORD                     timeoutSettingsConnections; // in ms
   DWORD                     timeoutSettingsDisconnections;  // in ms
   DWORD                     timeoutSettingsIdle;
   DWORD                     deviceClientDrives; // Citrix ICA clients only
   DWORD                     deviceClientPrinters; // RDP 5.0 clients & Citrix ICA Clients
   DWORD                     deviceClientDefaultPrinter; // RDP 5.0 clients & Citrix ICA clients
   DWORD                     brokenTimeoutSettings;
   DWORD                     reconnectSettings;
   DWORD                     modemCallbackSettings; // Citrix ICA clients only
   DWORD                     shadowingSettings;  // RDP 5.0 & Citrix clients
   DWORD                     terminalServerRemoteHomeDir;
   UCHAR                     initialProgram[LEN_Path];
   UCHAR                     workingDirectory[LEN_Path];
   UCHAR                     modemCallbackPhoneNumber[LEN_WTSPhoneNumber];  // Citrix ICA clients only
   UCHAR                     terminalServerProfilePath[LEN_Path];
   UCHAR                     terminalServerHomeDir[LEN_Path];
   UCHAR                     terminalServerHomeDirDrive[LEN_HomeDir];   
} EaWtsUserInfo;

// Flags for WTS Info.
#define  FM_WtsUser_inheritInitialProgram          (0x00000001)
#define  FM_WtsUser_allowLogonTerminalServer       (0x00000002)
#define  FM_WtsUser_timeoutSettingsConnections     (0x00000004)
#define  FM_WtsUser_timeoutSettingsDisconnections  (0x00000008)
#define  FM_WtsUser_timeoutSettingsIdle            (0x00000010)
#define  FM_WtsUser_deviceClientDrives             (0x00000020)
#define  FM_WtsUser_deviceClientPrinters           (0x00000040)
#define  FM_WtsUser_deviceClientDefaultPrinter     (0x00000080)
#define  FM_WtsUser_brokenTimeoutSettings          (0x00000100)
#define  FM_WtsUser_reconnectSettings              (0x00000200)
#define  FM_WtsUser_modemCallbackSettings          (0x00000400)
#define  FM_WtsUser_shadowingSettings              (0x00000800)
#define  FM_WtsUser_terminalServerRemoteHomeDir    (0x00001000)
#define  FM_WtsUser_initialProgram                 (0x00002000)
#define  FM_WtsUser_workingDirectory               (0x00004000)
#define  FM_WtsUser_modemCallbackPhoneNumber       (0x00008000)
#define  FM_WtsUser_terminalServerProfilePath      (0x00010000)
#define  FM_WtsUser_terminalServerHomeDir          (0x00020000)
#define  FM_WtsUser_terminalServerHomeDirDrive     (0x00040000)

#define  FM_WtsUserAll (WtsInheritInitialProgram        | \
                        WtsAllowLogonTerminalServer     | \
                        WtsTimeoutSettingsConnections   | \
                        WtsTimeoutSettingsIdle          | \
                        WtsDeviceClientDrives           | \
                        WtsDeviceClientPrinters         | \
                        WtsDeviceClientDefaultPrinter   | \
                        WtsBrokenTimeoutSettings        | \
                        WtsReconnectSettings            | \
                        WtsModemCallbackSettings        | \
                        WtsShadowingSettings            | \
                        WtsTerminalServerRemoteHomeDir  | \
                        WtsInitialProgram               | \
                        WtsWorkingDirectory             | \
                        WtsModemCallbackPhoneNumber     | \
                        WtsTerminalServerProfilePath    | \
                        WtsTerminalServerHomeDir        | \
                        WtsTerminalServerHomeDirDrive   )

#define  FM_WtsUserCitrixOnly ( WtsDeviceClientDrives          | \
                                WtsModemCallbackSettings       | \
                                WtsModemCallbackPhoneNumber )

#define  FM_WtsUserRDP5AndCitrix ( WtsDeviceClientPrinters        | \
                                   WtsDeviceClientDefaultPrinter  | \
                                   WtsShadowingSettings           )

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\wtsdyna.h ===
#ifndef __WTSDYNA_H__
#define __WTSDYNA_H__
/*---------------------------------------------------------------------------
  File: WtsUtil.h

  Comments: Functions to use the new WTSAPI functions exposed in 
  Terminal Server, SP4, to read and write the user configuration properties.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/08/99 13:22:49

 ---------------------------------------------------------------------------
*/

#include "dll.hpp"

DWORD 
   LoadWtsDLL(BOOL bSilent = TRUE);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\wtsutil.h ===
#ifndef __WTSUTIL_H__
#define __WTSUTIL_H__
/*---------------------------------------------------------------------------
  File: WtsUtil.h

  Comments: Functions to use the new WTSAPI functions exposed in 
  Terminal Server, SP4, to read and write the user configuration properties.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/08/99 13:22:49

 ---------------------------------------------------------------------------
*/


#include "EaLen.hpp"
#include <wtsapi32.h>

#define     WTS_DLL_NAME                     (L"WTSAPI32.DLL")

#define     WTS_QUERY_FUNCTION_NAME          ("WTSQueryUserConfigW")
#define     WTS_SET_FUNCTION_NAME            ("WTSSetUserConfigW")   
#define     WTS_FREE_FUNCTION_NAME           ("WTSFreeMemory")
#define     WTS_OPEN_SERVER_FUNCTION_NAME    ("WTSOpenServerW")
#define     WTS_CLOSE_SERVER_FUNCTION_NAME   ("WTSCloseServer")
#define     WTS_ENUM_SESSIONS_FUNCTION_NAME  ("WTSEnumerateSessionsW")


DWORD                                        // ret-0 or OS return code
   WtsUserGetInfo(                           
      WCHAR          const * pDomCtrlName,   // in -name of domain controller to read from 
      WCHAR          const * pUserName,      // in -username of account to read properties for
      DWORD                  fieldmask,      // in -which fields to read
      EaWtsUserInfo        * pInfo           // out-structure containing requested property values
   );


DWORD                                        // ret-0 or OS return code
   WtsUserSetInfo(
      WCHAR          const * pDomCtrlName,   // in -name of domain controller to read from 
      WCHAR          const * pUserName,      // in -username of account to read properties for
      DWORD                  fieldmask,      // in -which fields to read
      EaWtsUserInfo        * pInfo           // in -structure containing properties to update
   );


// Tries to determine if a server is running WTS
BOOL                                         // ret-TRUE-server is online and running WTS
   WtsTryServer(
      WCHAR                * serverName      // in -name of server
   );

// typedefs for the WTSAPI32 functions we will use

typedef BOOL
WINAPI
   WTSQUERYUSERCONFIGW(
    IN LPWSTR pServerName,
    IN LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );



typedef BOOL
WINAPI
   WTSSETUSERCONFIGW(
    IN LPWSTR pServerName,
    IN LPWSTR pUserName,
    IN WTS_CONFIG_CLASS WTSConfigClass,
    IN LPWSTR pBuffer,
    IN DWORD DataLength
    );

typedef VOID
WINAPI
   WTSFREEMEMORY(
    IN PVOID pMemory
    );


typedef HANDLE
WINAPI
   WTSOPENSERVERW(
    IN LPWSTR pServerName
    );

typedef VOID
WINAPI
WTSCLOSESERVER(
    IN HANDLE hServer
    );


extern DllAccess            gWtsDll;


extern WTSQUERYUSERCONFIGW        * gpWtsQueryUserConfig;
extern WTSSETUSERCONFIGW          * gpWtsSetUserConfig;
extern WTSFREEMEMORY              * gpWtsFreeMemory;
extern WTSOPENSERVERW             * gpWtsOpenServer;
extern WTSCLOSESERVER             * gpWtsCloseServer;


#endif //__WTSUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\wtsutil.cpp ===
/*---------------------------------------------------------------------------
  File: WtsUser.cpp

  Comments: Windows Terminal Server support

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/08/99 13:22:54

 ---------------------------------------------------------------------------
*/

#include <windows.h>

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "EaLen.hpp"
#include "Dll.hpp"
#include "WTSINFO.h"

#include <WtsApi32.h>

#include "wtsdyna.h"
#include "WtsUtil.h"

DllAccess            gWtsDll;
extern TError               err;
long                 gflDebug = 1;
const long EaxDebugFl_Wts = 0;

WTSQUERYUSERCONFIGW        * gpWtsQueryUserConfig = NULL;
WTSSETUSERCONFIGW          * gpWtsSetUserConfig = NULL;
WTSFREEMEMORY              * gpWtsFreeMemory = NULL;
WTSOPENSERVERW             * gpWtsOpenServer = NULL;
WTSCLOSESERVER             * gpWtsCloseServer = NULL;



DWORD 
   WtsUserQueryProperty(
      WCHAR                * pDomCtrl,     // in -name of domain controller to read info from
      WCHAR                * pUserName,    // in -username of account to read
      WTS_CONFIG_CLASS       infotype,     // in -type of information to retrieve
      LPWSTR               * pBuffer,      // out-buffer containing information
      DWORD                * lenBuffer     // out-length of information returned
   )
{
   DWORD                     rc = 0;

   MCSASSERT(pBuffer);
   MCSASSERT(lenBuffer);
   MCSASSERT(pDomCtrl);
   MCSASSERT(pUserName);
   MCSASSERT(gWtsDll.IsLoaded());
   MCSASSERT(gpWtsQueryUserConfig);

   (*pBuffer) = NULL;
   (*lenBuffer) = 0;

   if ( ! (*gpWtsQueryUserConfig)(pDomCtrl,pUserName, infotype, pBuffer, lenBuffer) )
   {
      rc = GetLastError();
      (*lenBuffer) = 0;
      (*pBuffer) = NULL;
   }
   return rc;
}

DWORD 
   WtsUserSetProperty(
      WCHAR                * pDomCtrl,     // in -name of PDC to write info to
      WCHAR                * pUserName,    // in -username of account to modify
      WTS_CONFIG_CLASS       infotype,     // in -type of information to modify
      LPTSTR                 buffer,       // in -buffer containing information to write
      DWORD                  lenBuffer     // in -length of information to write
   )
{
   DWORD                     rc = 0;
   
   MCSASSERT(buffer);
   MCSASSERT(lenBuffer);
   MCSASSERT(pDomCtrl);
   MCSASSERT(pUserName);
   MCSASSERT(gpWtsSetUserConfig);
   MCSASSERT(gWtsDll.IsLoaded());
   
   if ( ! (*gpWtsSetUserConfig)(pDomCtrl,pUserName, infotype, buffer,lenBuffer) )
   {
      rc = GetLastError();
   }
   return rc;
}

// Tries to determine if a server is running WTS
BOOL                                         // ret-TRUE-server is online and running WTS
   WtsTryServer(
      WCHAR                * serverName      // in -name of server
   )
{
   HANDLE                    hServer;
   BOOL                      bOK = FALSE;
   DWORD                     count = 0;

   MCSASSERT(gpWtsOpenServer);
   MCSASSERT(gpWtsCloseServer);
  
   hServer = (*gpWtsOpenServer)(serverName);

   if ( hServer && hServer != INVALID_HANDLE_VALUE )
   {
      if ( gflDebug & EaxDebugFl_Wts )
      {
//         err.MsgWrite(ErrI,L"WTSOpenServer(%ls) succeeded.",serverName);
      }
      bOK = TRUE;
      (*gpWtsCloseServer)(hServer);
   }
   else
   {
      DWORD                  rc = GetLastError();
  
      if ( gflDebug & EaxDebugFl_Wts )
      {
//         err.SysMsgWrite(ErrW, rc, L"WTSOpenServer(%ls) failed, rc=%ld ",serverName,rc);
      }
   }
   return bOK;
}

DWORD 
   WtsUserGetInfo(                           // ret-0 or OS return code
      WCHAR          const * pDomCtrlName,   // in -name of domain controller to read from 
      WCHAR          const * pUserName,      // in -username of account to read properties for
      DWORD                  fieldmask,      // in -which fields to read
      EaWtsUserInfo        * pInfo           // out-structure containing requested property values
   )
{
   DWORD                     rc = 0;
   LPWSTR                    pProperty = NULL;
   DWORD                     lenProperty;
   WCHAR                     domctrl[LEN_Computer];
   WCHAR                     username[LEN_Account];


   MCSASSERT(pInfo);
   MCSASSERT(pUserName);
   MCSASSERT(pDomCtrlName);
   MCSASSERT(gpWtsFreeMemory);
   MCSASSERT(gWtsDll.IsLoaded());
   
   // Initialize output parameter 
   memset(pInfo,0,(sizeof *pInfo));

   safecopy(domctrl,pDomCtrlName);
   safecopy(username,pUserName);

   do {  // once 

      if ( fieldmask & FM_WtsUser_inheritInitialProgram )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfInheritInitialProgram,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->inheritInitialProgram ) )
            {
               memcpy(&pInfo->inheritInitialProgram,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"InheritInitialProgram",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","InheritInitialProgram",username,rc);
            break;
         }
      }

      if ( fieldmask & FM_WtsUser_allowLogonTerminalServer )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfAllowLogonTerminalServer,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->allowLogonTerminalServer ) )
            {
               memcpy(&pInfo->allowLogonTerminalServer,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"AllowLogonTerminalServer",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","AllowLogonTerminalServer",username,rc);
            break;
         }
      }
      
      if ( fieldmask & FM_WtsUser_timeoutSettingsConnections )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTimeoutSettingsConnections,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->timeoutSettingsConnections ) )
            {
               memcpy(&pInfo->timeoutSettingsConnections,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"TimeoutSettingsConnections",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TimeoutSettingsConnections",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_timeoutSettingsDisconnections )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTimeoutSettingsDisconnections,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->timeoutSettingsDisconnections ) )
            {
               memcpy(&pInfo->timeoutSettingsDisconnections,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"TimeoutSettingsDisconnections",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TimeoutSettingsDisconnections",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_timeoutSettingsIdle )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTimeoutSettingsIdle,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->timeoutSettingsIdle ) )
            {
               memcpy(&pInfo->timeoutSettingsIdle,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"TimeoutSettingsIdle",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TimeoutSettingsIdle",username,rc);
            break;
         }
      }
      
      if ( fieldmask & FM_WtsUser_deviceClientDrives )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfDeviceClientDrives,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->deviceClientDrives ) )
            {
               memcpy(&pInfo->deviceClientDrives,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"DeviceClientDrives",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","DeviceClientDrives",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_deviceClientPrinters )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfDeviceClientPrinters,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->deviceClientPrinters ) )
            {
               memcpy(&pInfo->deviceClientPrinters,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"DeviceClientPrinters",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","DeviceClientPrinters",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_deviceClientDefaultPrinter )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfDeviceClientDefaultPrinter,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->deviceClientDefaultPrinter ) )
            {
               memcpy(&pInfo->deviceClientDefaultPrinter,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"DeviceClientDefaultPrinter",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","DeviceClientDefaultPrinter",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_brokenTimeoutSettings )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigBrokenTimeoutSettings,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->brokenTimeoutSettings ) )
            {
               memcpy(&pInfo->brokenTimeoutSettings,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"BrokenTimeoutSettings",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","BrokenTimeoutSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_reconnectSettings )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigReconnectSettings,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->reconnectSettings ) )
            {
               memcpy(&pInfo->reconnectSettings,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"ReconnectSettings",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","ReconnectSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_modemCallbackSettings )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigModemCallbackSettings,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->modemCallbackSettings ) )
            {
               memcpy(&pInfo->modemCallbackSettings,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"ModemCallbackSettings",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","ModemCallbackSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_shadowingSettings )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigShadowingSettings,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->shadowingSettings ) )
            {
               memcpy(&pInfo->shadowingSettings,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"ShadowingSettings",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","ShadowingSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerRemoteHomeDir )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigfTerminalServerRemoteHomeDir,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            if ( lenProperty == (sizeof pInfo->terminalServerRemoteHomeDir ) )
            {
               memcpy(&pInfo->terminalServerRemoteHomeDir,pProperty,lenProperty);
            }
            else
            {
//               err.MsgWrite(ErrW,L"Retrieved unexpected value for %ls %s, length=%ld",username,"TerminalServerRemoteHomeDir",lenProperty);
            }
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TerminalServerRemoteHomeDir",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_initialProgram )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigInitialProgram,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->initialProgram,pProperty);

            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","InitialProgram",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_workingDirectory )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigWorkingDirectory,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->workingDirectory,pProperty);
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","WorkingDirectory",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_modemCallbackPhoneNumber )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigModemCallbackPhoneNumber,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->modemCallbackPhoneNumber,pProperty);
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","ModemCallbackPhoneNumber",username,rc);
            break;
         }
      }
         
      if ( fieldmask & FM_WtsUser_terminalServerProfilePath )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTerminalServerProfilePath,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->terminalServerProfilePath,pProperty);
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TerminalServerProfilePath",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerHomeDir )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTerminalServerHomeDir,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->terminalServerHomeDir,pProperty);
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TerminalServerHomeDir",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerHomeDirDrive )
      {
         rc = WtsUserQueryProperty(domctrl,username,WTSUserConfigTerminalServerHomeDirDrive,&pProperty,&lenProperty);
         if ( ! rc )
         {
            // Copy the property to the structure
            safecopy(pInfo->terminalServerHomeDirDrive,pProperty);
            (*gpWtsFreeMemory)(pProperty);
         }
         else
         {
//            err.SysMsgWrite(ErrE,rc,L"Failed to retrieve %s property for %ls, rc=%ld ","TerminalServerHomeDirDrive",username,rc);
            break;
         }
      }

   } while (FALSE);

   return rc;
}

DWORD 
   WtsUserSetInfo(
      WCHAR          const * pDomCtrlName,   // in -name of domain controller to read from 
      WCHAR          const * pUserName,      // in -username of account to read properties for
      DWORD                  fieldmask,      // in -which fields to read
      EaWtsUserInfo        * pInfo           // in -structure containing properties to update
   )
{
   DWORD                     rc = 0;
   DWORD                     lenProperty;
   WCHAR                     domctrl[LEN_Computer];
   WCHAR                     username[LEN_Account];
   WCHAR                     property[1000];

   MCSASSERT(pInfo);
   MCSASSERT(pUserName);
   MCSASSERT(pDomCtrlName);
   MCSASSERT(gWtsDll.IsLoaded());
   
   safecopy(domctrl,pDomCtrlName);
   safecopy(username,pUserName);

   do {  // once 

      if ( fieldmask & FM_WtsUser_inheritInitialProgram )
      {
         lenProperty = sizeof(pInfo->inheritInitialProgram);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfInheritInitialProgram,(LPWSTR)&pInfo->inheritInitialProgram,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","InheritInitialProgram",username,rc);
            break;
         }
      }

      if ( fieldmask & FM_WtsUser_allowLogonTerminalServer )
      {
         lenProperty = sizeof pInfo->allowLogonTerminalServer;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfAllowLogonTerminalServer,(LPWSTR)&pInfo->allowLogonTerminalServer,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","AllowLogonTerminalServer",username,rc);
            break;
         }
      }
      
      if ( fieldmask & FM_WtsUser_timeoutSettingsConnections )
      {
         lenProperty = sizeof pInfo->timeoutSettingsConnections;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTimeoutSettingsConnections,(LPWSTR)&pInfo->timeoutSettingsConnections,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TimeoutSettingsConnections",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_timeoutSettingsDisconnections )
      {
         lenProperty = sizeof pInfo->timeoutSettingsDisconnections;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTimeoutSettingsDisconnections,(LPWSTR)&pInfo->timeoutSettingsDisconnections,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TimeoutSettingsDisconnections",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_timeoutSettingsIdle )
      {
         lenProperty = sizeof pInfo->timeoutSettingsIdle;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTimeoutSettingsIdle,(LPWSTR)&pInfo->timeoutSettingsIdle,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TimeoutSettingsIdle",username,rc);
            break;
         }
      }
      
      if ( fieldmask & FM_WtsUser_deviceClientDrives )
      {
         lenProperty = sizeof pInfo->deviceClientDrives;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfDeviceClientDrives,(LPWSTR)&pInfo->deviceClientDrives,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","DeviceClientDrives",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_deviceClientPrinters )
      {
         lenProperty = sizeof pInfo->deviceClientPrinters;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfDeviceClientPrinters,(LPWSTR)&pInfo->deviceClientPrinters,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","DeviceClientPrinters",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_deviceClientDefaultPrinter )
      {
         lenProperty = sizeof pInfo->deviceClientDefaultPrinter;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfDeviceClientDefaultPrinter,(LPWSTR)&pInfo->deviceClientDefaultPrinter,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","DeviceClientDefaultPrinter",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_brokenTimeoutSettings )
      {
         lenProperty = sizeof pInfo->brokenTimeoutSettings;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigBrokenTimeoutSettings,(LPWSTR)&pInfo->brokenTimeoutSettings,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","BrokenTimeoutSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_reconnectSettings )
      {
         lenProperty = sizeof pInfo->reconnectSettings;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigReconnectSettings,(LPWSTR)&pInfo->reconnectSettings,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","ReconnectSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_modemCallbackSettings )
      {
         lenProperty = sizeof pInfo->modemCallbackSettings;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigModemCallbackSettings,(LPWSTR)&pInfo->modemCallbackSettings,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","ModemCallbackSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_shadowingSettings )
      {
         lenProperty = sizeof pInfo->shadowingSettings;
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigShadowingSettings,(LPWSTR)&pInfo->shadowingSettings,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","ShadowingSettings",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerRemoteHomeDir )
      {
         // This property is updated automatically when the HomeDirDrive is set
         //lenProperty = sizeof pInfo->terminalServerRemoteHomeDir;
         //rc = WtsUserSetProperty(domctrl,username,WTSUserConfigfTerminalServerRemoteHomeDir,(LPWSTR)&pInfo->terminalServerRemoteHomeDir,lenProperty);
         //if ( rc )
         //{
         //   err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TerminalServerRemoteHomeDir",username,rc );
         //   break;
         //}
      }
      if ( fieldmask & FM_WtsUser_initialProgram )
      {
         
         MCSASSERT(DIM(pInfo->initialProgram) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->initialProgram) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->initialProgram);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigInitialProgram,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","InitialProgram",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_workingDirectory )
      {
         MCSASSERT(DIM(pInfo->workingDirectory) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->workingDirectory) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->workingDirectory);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigWorkingDirectory,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","WorkingDirectory",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_modemCallbackPhoneNumber )
      {
         MCSASSERT(DIM(pInfo->modemCallbackPhoneNumber) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->modemCallbackPhoneNumber) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->modemCallbackPhoneNumber);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigModemCallbackPhoneNumber,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","ModemCallbackPhoneNumber",username,rc);
            break;
         }
      }
         
      if ( fieldmask & FM_WtsUser_terminalServerProfilePath )
      {
         MCSASSERT(DIM(pInfo->terminalServerProfilePath) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->terminalServerProfilePath) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->terminalServerProfilePath);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTerminalServerProfilePath,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TerminalServerProfilePath",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerHomeDir )
      {
         MCSASSERT(DIM(pInfo->terminalServerHomeDir) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->terminalServerHomeDir) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->terminalServerHomeDir);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTerminalServerHomeDir,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TerminalServerHomeDir",username,rc);
            break;
         }
      }
      if ( fieldmask & FM_WtsUser_terminalServerHomeDirDrive )
      {
         MCSASSERT(DIM(pInfo->terminalServerHomeDirDrive) <= DIM(property));
         lenProperty = ( UStrLen(pInfo->terminalServerHomeDirDrive) + 1) * sizeof WCHAR;
         safecopy(property,pInfo->terminalServerHomeDirDrive);
         rc = WtsUserSetProperty(domctrl,username,WTSUserConfigTerminalServerHomeDirDrive,property,lenProperty);
         if ( rc )
         {
//            err.SysMsgWrite(ErrE,rc,"Failed to update %s property for %ls, rc=%ld ","TerminalServerHomeDirDrive",username,rc);
            break;
         }
      }

   } while (FALSE);

  
   return rc;
}

DWORD                                      // ret- 0 or OS return code
   LoadWtsDLL(
      BOOL                   bSilent       // in - FALSE logs error messages, TRUE does not (default=TRUE)
   )
{
   DWORD                     rc = 0;
   
   bSilent = ( ( gflDebug & EaxDebugFl_Wts) == 0);

   if ( ! gWtsDll.IsLoaded() )
   {
      rc = gWtsDll.Open(WTS_DLL_NAME);

      if ( rc )
      {
//         if ( ! bSilent )
//            err.SysMsgWrite(ErrE,rc,"The EA Server could not load %ls.  This DLL is needed for Windows Terminal Server suppport. ",WTS_DLL_NAME);
      }
      else
      {
         // Get the entry points we need
         do { // once
            
            rc = gWtsDll.Access(WTS_QUERY_FUNCTION_NAME,(FARPROC *)&gpWtsQueryUserConfig);
            if ( rc )
            {
//               if ( ! bSilent) 
//                  err.SysMsgWrite(ErrE,rc,"%ls does not contain the entry point %s, rc=%ld ",WTS_DLL_NAME,WTS_QUERY_FUNCTION_NAME);
               break;
            }
            rc = gWtsDll.Access(WTS_SET_FUNCTION_NAME,(FARPROC *)&gpWtsSetUserConfig);
            if ( rc )
            {
//               if  (! bSilent) 
//                  err.SysMsgWrite(ErrE,rc,"%ls does not contain the entry point %s, rc=%ld ",WTS_DLL_NAME,WTS_SET_FUNCTION_NAME);
               break;
            }
            rc = gWtsDll.Access(WTS_FREE_FUNCTION_NAME,(FARPROC *)&gpWtsFreeMemory);
            if ( rc )
            {
//               if ( ! bSilent) 
//                  err.SysMsgWrite(ErrE,rc,"%ls does not contain the entry point %s, rc=%ld ",WTS_DLL_NAME,WTS_FREE_FUNCTION_NAME);
               break;
            }
            rc = gWtsDll.Access(WTS_OPEN_SERVER_FUNCTION_NAME, (FARPROC *)&gpWtsOpenServer);
            if ( rc )
            {
//               if ( ! bSilent) 
//                  err.SysMsgWrite(ErrE,rc,"%ls does not contain the entry point %s, rc=%ld ",WTS_DLL_NAME,WTS_OPEN_SERVER_FUNCTION_NAME);
               break;
            }
            rc = gWtsDll.Access(WTS_CLOSE_SERVER_FUNCTION_NAME, (FARPROC *)&gpWtsCloseServer);
            if ( rc )
            {
//               if ( ! bSilent) 
//                  err.SysMsgWrite(ErrE,rc,"%ls does not contain the entry point %s, rc=%ld ",WTS_DLL_NAME,WTS_CLOSE_SERVER_FUNCTION_NAME);
               break;
            }
            
         } while ( false ); // end - do once
         
         if ( rc )
         {
            gWtsDll.Close();
            // Set all the function pointers to 0.
            gpWtsQueryUserConfig = NULL;
            gpWtsSetUserConfig = NULL;
            gpWtsFreeMemory = NULL;
            gpWtsOpenServer = NULL;
            gpWtsCloseServer = NULL;
         }
      }
      if ( rc )
      {
         if ( gflDebug & EaxDebugFl_Wts )
         {
//            err.SysMsgWrite( ErrW, rc, "WTSAPI32.DLL not loaded, rc=%ld, WTS support is disabled. ",rc);
         }
      }
   }
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\workobj\_entryid.h ===
/*
** --_entryid.h----------------------------------------------------------------
**
**  Header file describing internal structure of EntryIDs returned
**  by Exchange Address Book provider.
**
**
**  Copyright (c) Microsoft Corp. 1986-1996.  All Rights Reserved.
**
** ----------------------------------------------------------------------------
*/

#ifndef _ENTRYID_
#define _ENTRYID_

/*
 *  The version of this ABPs entryids
 */
#define EMS_VERSION         0x000000001

/*
 * The version of the entryids supported by the CreateEntry method in this 
 * ABP.
 */
#define NEW_OBJ_EID_VERSION 0x00000002

/*
 *  Valid values for the entry id's Type field are Mapi Display Types, plus:
 */
#define AB_DT_CONTAINER     0x000000100
#define AB_DT_TEMPLATE      0x000000101
#define AB_DT_OOUSER        0x000000102
#define AB_DT_SEARCH        0x000000200

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}

/*
 *  Directory entry id structure
 *
 *  This entryid is permanent.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _dir_entryid
#else
typedef struct _dir_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
} DIR_ENTRYID, FAR * LPDIR_ENTRYID;

#define CBDIR_ENTRYID sizeof(DIR_ENTRYID)

/*
 *  Mail user entry id structure
 *
 *  This entryid is ephemeral.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_entryid
#else
typedef struct _usr_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    DWORD dwEph;
} USR_ENTRYID, FAR * LPUSR_ENTRYID;

/*
 *  This entryid is permanent.
 */
/* turn off the warning for the unsized array */
#pragma warning (disable:4200)
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_permid
#else
typedef struct _usr_permid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    char  szAddr[];
} USR_PERMID, FAR * LPUSR_PERMID;
#pragma warning (default:4200)

#define CBUSR_ENTRYID sizeof(USR_ENTRYID)
#define CBUSR_PERMID sizeof(USR_PERMID)

#define EPHEMERAL   (UCHAR)(~(  MAPI_NOTRECIP      \
                              | MAPI_THISSESSION   \
                              | MAPI_NOW           \
                              | MAPI_NOTRESERVED))


#endif  /* _ENTRYID_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\coreutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// core utility functions
//
// 30 Nov 1999 sburns



#include "headers.hxx"



HINSTANCE
Burnslib::GetResourceModuleHandle()
{
   ASSERT(hResourceModuleHandle);

   return hResourceModuleHandle;
}



// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for.  This could be an HRESULT, or a win32
// error code.

String
GetMessageHelper(DWORD flags, HMODULE module, DWORD code)
{
   ASSERT(flags & FORMAT_MESSAGE_ALLOCATE_BUFFER);

   String message;

   TCHAR* sysMessage = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         code,
         0,
         reinterpret_cast<PTSTR>(&sysMessage),
         0,
         0);
   if (result)
   {
      ASSERT(sysMessage);
      if (sysMessage)
      {
         message = sysMessage;

         ASSERT(result == message.length());

         ::LocalFree(sysMessage);

         message.replace(L"\r\n", L" ");
      }
   }

   return message;
}



// Attempts to locate message strings for various facility codes in the
// HRESULT

String
Burnslib::GetErrorMessage(HRESULT hr)
{
   LOG_FUNCTION2(GetErrorMessage, String::format(L"%1!08X!", hr));

   if (!FAILED(hr) && hr != S_OK)
   {
      // no messages for success codes other than S_OK

      ASSERT(false);

      return String();
   }

   String message;

   // default is the system error message table

   HMODULE module = 0;

   do
   {
      WORD code = static_cast<WORD>(HRESULT_CODE(hr));
      if (code == -1)
      {
         // return "unknown" message

         break;
      }

      DWORD flags =
            FORMAT_MESSAGE_ALLOCATE_BUFFER
         |  FORMAT_MESSAGE_IGNORE_INSERTS
         |  FORMAT_MESSAGE_FROM_SYSTEM;


      if (!HRESULT_FACILITY(hr) && (code >= 0x5000 && code <= 0x50FF))
      {
         // It's an ADSI error

         flags |= FORMAT_MESSAGE_FROM_HMODULE;

         module =
            ::LoadLibraryEx(
               L"activeds.dll",
               0,
               LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES);
         if (!module)
         {
            // return "unknown" message

            LOG_HRESULT(Win32ToHresult(::GetLastError()));

            break;
         }
      }

      // try FormatMessage with the full HRESULT first

      message = GetMessageHelper(flags, module, hr);

      if (message.empty())
      {
         // try again with just the error code

         message = GetMessageHelper(flags, module, code);
      }
   }
   while (0);

   if (message.empty())
   {
      message = String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   if (module)
   {
      BOOL unused = ::FreeLibrary(module);

      ASSERT(unused);
   }

   return message.strip(String::BOTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\heap.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)



#include "headers.hxx"


//
// Debug and Retail build
//



static const int RES_STRING_SIZE = 512;
static TCHAR LOW_MEMORY_MESSAGE[RES_STRING_SIZE];
static TCHAR LOW_MEMORY_TITLE[RES_STRING_SIZE];

// we declare a static instance of bad_alloc so that the loader allocates
// space for it.  Otherwise, we'd have to allocate an instance during failure
// of operator new, which we obviously can't do, since we're out-of-memory at
// that point.

static const std::bad_alloc nomem;



// Called when OperatorNew cannot satisfy an allocation request.
//
// Brings up a dialog to inform the user to free up some memory then retry the
// allocation, or cancel.  The dialog can appear in low-memory conditions.
//
// Returns IDRETRY if the allocation should be re-attempted, IDCANCEL
// otherwise.  Returns IDCANCEL if the module resource handle has not been
// set (see burnslib.hpp).

int
DoLowMemoryDialog()
{
   static bool initialized = false;

   if (!initialized)
   {
      HINSTANCE hinstance = GetResourceModuleHandle();
      if (!hinstance)
      {
         // DLL/WinMain has not set the handle.  So just throw.

         return IDCANCEL;
      }

      // This will work, even in low memory, as it just returns a pointer
      // to the string in the exe image.

      int result1 =
         ::LoadString(
            hinstance,
            IDS_LOW_MEMORY_MESSAGE,
            LOW_MEMORY_MESSAGE,
            RES_STRING_SIZE);

      int result2 =
         ::LoadString(
            hinstance,
            IDS_LOW_MEMORY_TITLE,
            LOW_MEMORY_TITLE,
            RES_STRING_SIZE);
      if (result1 && result2)
      {
         initialized = true;
      }
   }

   return
      ::MessageBox(
         ::GetDesktopWindow(),
         LOW_MEMORY_MESSAGE,
         LOW_MEMORY_TITLE,

         // ICONHAND + SYSTEMMODAL gets us the special low-memory
         // message box.

         MB_RETRYCANCEL | MB_ICONHAND | MB_SYSTEMMODAL);
}



// Include the code for the debug or retail variations of the replacement
// operator new and delete

#ifdef DBG

   // debug code

   #include "heapdbg.cpp"

#else

   // retail code

   #include "heapretl.cpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\assert.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// ASSERT macro
//
// 3 Mar 2000 sburns



#include "headers.hxx"



int
AddStackTraceLine(
   DWORD64 traceAddress,
   char*   buffer,
   size_t  bufferMax)
{
   if (!buffer || ! traceAddress || !bufferMax)
   {
      return 0;
   }

   char      ansiSymbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
   char      ansiModule[Burnslib::StackTrace::MODULE_NAME_MAX];
   char      ansiSource[MAX_PATH];                           
   DWORD64   displacement = 0;
   DWORD     line         = 0;

   memset(ansiSymbol, 0, Burnslib::StackTrace::SYMBOL_NAME_MAX);
   memset(ansiModule, 0, Burnslib::StackTrace::MODULE_NAME_MAX);
   memset(ansiSource, 0, MAX_PATH);                             

   Burnslib::StackTrace::LookupAddress(
      traceAddress,
      ansiModule,
      0,
      ansiSymbol,
      &displacement,
      &line,
      ansiSource);

   return 
      _snprintf(
         buffer,
         bufferMax,
         " %016I64X %s%!%s+0x%I64X %s (%d)\n",
         traceAddress,
         ansiModule,
         ansiSymbol,
         displacement,
         ansiSource,
         line);
}



bool
Burnslib::FireAssertionFailure(const char* file, int line, const char* expr)
{
   //
   // DON'T CALL ASSERT() IN THIS FUNCTION! 
   //
   // also don't call new, or any other code that could call ASSERT.

   bool result = false;

   char processName[128];
   char* pProcessName = processName;

   if (!::GetModuleFileNameA(0, processName, 128))
   {
      pProcessName = "Unknown";
   }

   static const int MAX_MSG = 2048;

   char details[MAX_MSG];
   DWORD tid = ::GetCurrentThreadId();
   DWORD pid = ::GetCurrentProcessId();

   int used = 
      _snprintf(
         details,
         MAX_MSG,
         " Expression: %s \n"
         "\n"
         " File   \t : %s \n"
         " Line   \t : %d \n"
//         " Module \t : %s \n"
         " Process\t : 0x%X (%d) %s\n"
         " Thread \t : 0x%X (%d)\n"
         "\n"
         " Click Retry to debug.\n"
         "\n",
         expr,
         file,
         line,
//          pModuleName,
         pid,
         pid,
         pProcessName,
         tid,
         tid);
   if (used < 0)
   {
      strcpy(details, "details too detailed.\n");
   }
   else
   {
      // grab a stack trace

      static const size_t TRACE_MAX = 10;
      DWORD64 stackTrace[TRACE_MAX];

      Burnslib::StackTrace::Trace(stackTrace, TRACE_MAX);

      // build a stack trace dump

      // skip the first entry, which corresponds to this function, so that
      // the dump reflects the call stack at the point of assertion failure.
      // so there will be at most TRACE_MAX - 1 lines output.

      for (int i = 1; stackTrace[i] && i < TRACE_MAX; ++i)
      {
         int used2 =
            AddStackTraceLine(
               stackTrace[i],
               details + used,
               MAX_MSG - used);

         if (used2 < 0)
         {
            break;
         }

         used += used2;
      }
   }

   static const char* TITLE = "Assertion Failed!";
   ::OutputDebugStringA(TITLE);
   ::OutputDebugStringA("\n");
   ::OutputDebugStringA(details);

   switch (
      ::MessageBoxA(
         0,
         details,
         TITLE,
            MB_SETFOREGROUND                       
         |  MB_TASKMODAL
         |  MB_ICONERROR
         |  MB_ABORTRETRYIGNORE))
   {
      case IDABORT:
      {
         _exit(3);
      }
      case IDRETRY:
      {
         // user wants to drop into the debugger.
         
         result = true;
         break;
      }
      case IDIGNORE:
      case IDCANCEL:
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\sources.inc ===
# BURNSLIB CORE library
#
# Copyright (c) 1997-2000 Microsoft Corporation
#
# 06 Jan 2000 sburns

# common definitions to be included in the sources file(s) of subfolders


MAJORCOMP=admin
MINORCOMP=blcore

TARGETPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETLIBPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

UMTYPE=windows
C_DEFINES = -DUNICODE -D_UNICODE
USE_MSVCRT=1
USE_NATIVE_EH=1
USE_RTTI=1
USE_STD=1
USE_STL=1

PRECOMPILED_INCLUDE=..\headers.hxx
PRECOMPILED_CXX=1

MSC_WARNING_LEVEL=/W4

INCLUDES=..\;$(PROJECT_ROOT)\burnslib\inc;$(NET_INC_PATH)

UMLIBS= \
 	$(SDK_LIB_PATH)\kernel32.lib \
 	$(SDK_LIB_PATH)\user32.lib   \
 	$(SDK_LIB_PATH)\comctl32.lib \


SOURCES= \
	..\Assert.cpp	\
	..\coreutil.cpp \
	..\init.cpp     \
	..\log.cpp      \
	..\heap.cpp     \
	..\stacktr.cpp  \
	..\string.cpp   \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\init.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Initialization stuff
// 
// 9-25-97 sburns



#include "headers.hxx"



unsigned Burnslib::InitializationGuard::counter = 0;
const wchar_t* REG_ADMIN_RUNTIME_OPTIONS = 0;


Burnslib::InitializationGuard::InitializationGuard()
{
   if (!counter)
   {
      REG_ADMIN_RUNTIME_OPTIONS =
         L"Software\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\";

      // cause assertion failures to appear in the debugger and the UI

      _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_WNDW | _CRTDBG_MODE_DEBUG);

      Heap::Initialize();
   }

   counter++;
}



Burnslib::InitializationGuard::~InitializationGuard()
{
   if (--counter == 0)
   {

#ifdef LOGGING_BUILD
      Log::Cleanup();
#endif

      // we have to dump leaks ourselves, as the CRT explicitly disables the
      // client dump function before it dumps leaks (if you set the
      // _CRTDBG_LEAK_CHECK_DF flag).  The downside is that we will also see
      // normal blocks that were allocated during static initialization.

      // You should pass -D_DEBUG to the compiler to get this extra heap
      // checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
      // in your build environment)

      Heap::DumpMemoryLeaks();

      // this must come after the leak dump, as the leak dump resolves symbols

      StackTrace::Cleanup();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\heapdbg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)
//
// This file is #include'd from mem.cpp
// DO NOT include in the sources file list
//
// this is the checked (debug) version:



#ifndef DBG
   #error This file must be compiled with the DBG symbol defined
#endif



static const int   TRACE_MAX              = 10;        
static const DWORD SAFETY_FILL            = 0xDEADDEAD;
static const DWORD DEFAULT_HEAP_FLAGS     = 0;         
static const DWORD HEAP_TRACE_ALLOCATIONS = (1 << 0);
static       DWORD heapFlags              = 0;



struct AllocationPrefix
{
   LONG    serialNumber;
   DWORD   status;
   DWORD64 stackTrace[TRACE_MAX];
   DWORD   safetyFill;

   // status bitmasks

   static const DWORD STATUS_REPORTED_LEAKED = 0x00000001;
};



inline
void
SafeStrncat(char* dest, const char* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      strncat(dest, src, bufmax - strlen(dest) - 1);
   }
}



inline
void
SafeStrncat(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      wcsncat(dest, src, bufmax - wcslen(dest) - 1);
   }
}



// strncpy that will not overflow the buffer.

inline
void
SafeStrncpy(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   memset(dest, 0, bufmax);
   wcsncpy(dest, src, bufmax - 1);
}




void
ReadHeapFlags()
{
   // don't call new in this routine, it may be called as a result of doing
   // a stack trace as part of OperatorNew

   do
   {
      wchar_t keyname[MAX_PATH];
      memset(keyname, 0, MAX_PATH * sizeof(wchar_t));

      SafeStrncpy(keyname, REG_ADMIN_RUNTIME_OPTIONS, MAX_PATH);
      SafeStrncat(keyname, RUNTIME_NAME, MAX_PATH);
         
      HKEY hKey = 0;
      LONG result =
         ::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            keyname,
            0,
            0,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            0,
            &hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      static const wchar_t* HEAP_FLAG_VALUE_NAME = L"HeapFlags";

      DWORD dataSize = sizeof(heapFlags);
      result =
         ::RegQueryValueEx(
            hKey,
            HEAP_FLAG_VALUE_NAME,
            0,
            0,
            reinterpret_cast<BYTE*>(&heapFlags),
            &dataSize);
      if (result != ERROR_SUCCESS)
      {
         heapFlags = DEFAULT_HEAP_FLAGS;

         // create the value for convenience

         result =
            ::RegSetValueEx(
               hKey,
               HEAP_FLAG_VALUE_NAME,
               0,
               REG_DWORD,
               reinterpret_cast<BYTE*>(&heapFlags),
               dataSize);
         ASSERT(result == ERROR_SUCCESS);
      }

      ::RegCloseKey(hKey);
   }
   while (0);
}



void
Burnslib::Heap::Initialize()
{
   ReadHeapFlags();

   // You should pass -D_DEBUG to the compiler to get this extra heap
   // checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
   // in your build environment)

   _CrtSetDbgFlag(
      0
//      |  _CRTDBG_CHECK_ALWAYS_DF       // check heap every allocation
      |  _CRTDBG_ALLOC_MEM_DF          // use debug heap allocator
      |  _CRTDBG_DELAY_FREE_MEM_DF);   // delay free: helps find overwrites
}



bool
ShouldTraceAllocations()
{
   return (heapFlags & HEAP_TRACE_ALLOCATIONS) ? true : false;
}



// The debug version of myOperatorNew/Delete prepends the allocation with an
// array to hold the stack backtrace at the point this function is called.  If
// the stack trace debugging option is active, then this stack trace array is
// filled in.  Then, upon termination, that array is used to dump the stack
// trace of any allocation that has not been freed.

void*
Burnslib::Heap::OperatorNew(
   size_t      size,

#ifdef _DEBUG

   // these are only used when DEBUG_CRTS=1

   const char* file,
   int         line
#else
   const char* /* file */ ,
   int         /* line */ 
#endif

)
throw (std::bad_alloc)
{
   static LONG allocationNumber = 0;

   AllocationPrefix* ptr = 0;

   for (;;)
   {
      // NOTE: if some other user of the CRT has used _set_new_mode or
      // _CrtSetAllocHook, then they may circumvent our careful arrangement
      // and hose us.  The really sad part is that the only way to prevent
      // that problem is for us to not use any CRT heap functions.

      size_t mallocSize = sizeof(AllocationPrefix) + size;

      ptr =

#ifdef _DEBUG            

         reinterpret_cast<AllocationPrefix*>(
            _malloc_dbg(
               mallocSize,
               _CLIENT_BLOCK,
               file,
               line));
#else
         reinterpret_cast<AllocationPrefix*>(malloc(mallocSize));
#endif

      if (ptr)
      {
         break;
      }

      // the allocation failed.  Give the user the opportunity to try to
      // free some, or throw an exception.
      if (DoLowMemoryDialog() == IDRETRY)
      {
         continue;
      }

      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"  myOperatorNew: user opted to throw bad_alloc\n");

      throw nomem;
   }

   ptr->serialNumber = allocationNumber;
   ::InterlockedIncrement(&allocationNumber);

   ptr->status = 0;

   memset(ptr->stackTrace, 0, sizeof(DWORD64) * TRACE_MAX);
   if (ShouldTraceAllocations())
   {
      Burnslib::StackTrace::Trace(ptr->stackTrace, TRACE_MAX);
   }

   ptr->safetyFill = SAFETY_FILL;

   memset(ptr + 1, 0xFF, size);

   // return the address of the byte just beyond the prefix
   return reinterpret_cast<void*>(ptr + 1);
}



void
Burnslib::Heap::OperatorDelete(void* ptr)
throw ()
{
   if (ptr)
   {
      // note that ptr will be the address of the byte just after the prefix,
      // so we need to back up to include the prefix.

      AllocationPrefix* realptr = reinterpret_cast<AllocationPrefix*>(ptr) - 1;
      ASSERT(realptr->safetyFill == SAFETY_FILL);

      _free_dbg(realptr, _CLIENT_BLOCK);
   }
}



// This bit is cleared on allocation, and set on leak report.  This is to
// handle the case that more than 1 module (say an exe and a dll) link with
// blcore.
// 
// In that situation, each module's allocations are made from a
// common crt heap, but there are two static copies of the Burnslib::Heap code
// -- one per module.   This means the leak dumper will run twice over the
// same heap.
// 
// If the leak is in a dll, then dumped, then the dll is unloaded, when the
// same leak is dumped by the exe, the dll static data which includes the
// filename of the code that leaked will no longer be available, and the dump
// code will throw an exception.  Then, the crt will catch the exception, and
// call the leak dumper routine.  The routine checks the "already reported"
// bit and emits a message to ignore the second report.
// 
// We could eliminate the second report entirely if _CrtDoForAllClientObjects
// weren't broken.

void
leakDumper(void* ptr, void*)
{
   AllocationPrefix* prefix     = reinterpret_cast<AllocationPrefix*>(ptr);
   DWORD64*          stackTrace = prefix->stackTrace;                      
   LONG              serial     = prefix->serialNumber;
   DWORD&            status     = prefix->status;

   static const int BUF_MAX = MAX_PATH * 2;
   char output[BUF_MAX];
   char buf[BUF_MAX];

   memset(output, 0, BUF_MAX);
   SafeStrncat(output, "allocation ", BUF_MAX);

   memset(buf, 0, BUF_MAX);
   _ltoa(serial, buf, 10);
   SafeStrncat(output, buf, BUF_MAX);

   SafeStrncat(output, "\r\n", BUF_MAX);
   ::OutputDebugStringA(output);

   if (status & AllocationPrefix::STATUS_REPORTED_LEAKED)
   {
      ::OutputDebugString(
         L"NOTE: this allocation has already been reported as a leak.");
   }

   for (int i = 0; i < TRACE_MAX; i++)
   {
      if (!stackTrace[i])
      {
         break;
      }

      char      symbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
      char      image[MAX_PATH];                              
      char      module[Burnslib::StackTrace::MODULE_NAME_MAX];
      char      fullpath[MAX_PATH];                           
      DWORD64   displacement = 0;
      DWORD     line         = 0;

      memset(symbol,   0, Burnslib::StackTrace::SYMBOL_NAME_MAX);
      memset(image,    0, MAX_PATH);                             
      memset(module,   0, Burnslib::StackTrace::MODULE_NAME_MAX);
      memset(fullpath, 0, MAX_PATH);                             

      Burnslib::StackTrace::LookupAddress(
         stackTrace[i],
         module,
         image,
         symbol,
         &displacement,
         &line,
         fullpath);

      memset(output, 0, BUF_MAX);
      SafeStrncat(output, "   ", BUF_MAX);
      SafeStrncat(output, module, BUF_MAX);
      SafeStrncat(output, "!", BUF_MAX);
      SafeStrncat(output, symbol, BUF_MAX);
      SafeStrncat(output, "+0x", BUF_MAX);

      memset(buf, 0, BUF_MAX);
      sprintf(buf, "%I64X", displacement);
      SafeStrncat(output, buf, BUF_MAX);

      if (line)
      {
         SafeStrncat(output, " line ", BUF_MAX);
         memset(buf, 0, BUF_MAX);
         _ultoa(line, buf, 10);
         SafeStrncat(output, buf, BUF_MAX);
      }

      SafeStrncat(output, "   ", BUF_MAX);
      ::OutputDebugStringA(output);

      memset(output, 0, BUF_MAX);

      if (strlen(fullpath))
      {
         SafeStrncat(output, fullpath, BUF_MAX);
      }

      SafeStrncat(output, "\r\n", BUF_MAX);
      ::OutputDebugStringA(output);
   }

   status = status | AllocationPrefix::STATUS_REPORTED_LEAKED;
}



void __cdecl
leakDumper2(void* ptr, size_t)
{
   leakDumper(ptr, 0);
}



void
Burnslib::Heap::DumpMemoryLeaks()
{

#ifdef _DEBUG
   
   _CrtMemState heapState;

   _CrtMemCheckpoint(&heapState);

   if (heapState.lCounts[_CLIENT_BLOCK] != 0)
   {
      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"   dumping leaked CLIENT blocks -- "
         L"Only blocks with type CLIENT are actual leaks\r\n");
      _CrtSetDumpClient(leakDumper2);

   //   _CrtDoForAllClientObjects(leakDumper, 0);  // ideal, but broken

      _CrtMemDumpAllObjectsSince(0);
   }

#endif   // _DEBUG

}



#ifdef _DEBUG

Burnslib::Heap::Frame::Frame(const wchar_t* file_, unsigned line_)
   :
   file(file_),
   line(line_)
{
   LOG(
      String::format(
         L"Heap frame opened at %1, line %2!d!",
         file,
         line));

   _CrtMemCheckpoint(&checkpoint);
}



Burnslib::Heap::Frame::~Frame()
{
   LOG(
      String::format(
         L"Dumping alloations for HeapFrame opened at %1, line %2!d!",
         file,
         line));

   _CrtMemDumpAllObjectsSince(&checkpoint);

   file = 0;

   LOG(L"Heap frame closed");
}

#endif   // _DEBUG






// // log this allocation to disk, along with a stack trace.  We write directly
// // to a separate log file instead of using LOG() because LOG() makes
// // (many) heap allocations, which would result in an infinite loop.
// //
// // CODEWORK: unfortunately, one effect of this is that LOG() adds white
// // noise to the allocation log.
// //
//
// void
// logAllocation(long requestNumber, size_t dataSize, const char* file, int line)
// {
//    static HANDLE logfile = 0;
//
//    if (!logfile)
//    {
//       do
//       {
//          TCHAR buf[MAX_PATH + 1];
//          memset(buf, 0, sizeof(TCHAR) * (MAX_PATH + 1));
//
//          UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
//          if (result == 0 || result > MAX_PATH)
//          {
//             break;
//          }
//
//          _tcsncat(buf, L"\\debug\\alloc.log", MAX_PATH - result);
//
//          DWORD attrs = ::GetFileAttributes(buf);
//          if (attrs != -1)
//          {
//             // file already exists.  Delete it.
//             if (!::DeleteFile(buf))
//             {
//                break;
//             }
//          }
//
//          logfile =
//             ::CreateFile(
//                buf,
//                GENERIC_READ | GENERIC_WRITE,
//                FILE_SHARE_READ | FILE_SHARE_WRITE,
//                0,
//                OPEN_ALWAYS,
//                FILE_ATTRIBUTE_NORMAL,
//                0);
//       }
//       while (0);
//    }
//
//    if (logfile && logfile != INVALID_HANDLE_VALUE)
//    {
//       // we write the log in ascii
//       static const int BUF_MAX = MAX_PATH * 2;
//       char output[BUF_MAX];
//       char buf[BUF_MAX];
//       memset(output, 0, BUF_MAX);
//       memset(buf, 0, BUF_MAX);
//
//       _ltoa(requestNumber, output, 10);
//       SafeStrncat(output, "\r\n   ", BUF_MAX);
//
//       SafeStrncat(output, file ? file : "<no file>", BUF_MAX);
//
//       if (line)
//       {
//          _ltoa(line, buf, 10);
//          SafeStrncat(output, " line ", BUF_MAX);
//          SafeStrncat(output, buf, BUF_MAX);
//       }
//       else
//       {
//          SafeStrncat(output, " <no line>", BUF_MAX);
//       }
//
//       SafeStrncat(output, "\r\n", BUF_MAX);
//
//       DWORD bytesWritten = 0;
//       ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//
//       static const int TRACE_MAX = 20;
//       DWORD stackTrace[TRACE_MAX];
//       GetStackTrace(stackTrace, TRACE_MAX);
//
//       for (int i = 0; i < TRACE_MAX; i++)
//       {
//          if (stackTrace[i])
//          {
//             char  symbol[SYMBOL_NAME_MAX];
//             char  image[MAX_PATH];
//             char  module[MODULE_NAME_MAX];
//             char  fullpath[MAX_PATH];
//             DWORD displacement = 0;
//             DWORD line = 0;
//
//             memset(symbol, 0, SYMBOL_NAME_MAX);
//             memset(image, 0, MAX_PATH);
//             memset(module, 0, MODULE_NAME_MAX);
//             memset(fullpath, 0, MAX_PATH);
//
//             LookupStackTraceSymbol(
//                stackTrace[i],
//                module,
//                image,
//                symbol,
//                &displacement,
//                &line,
//                fullpath);
//
//             memset(output, 0, BUF_MAX);
//             SafeStrncat(output, "   ", BUF_MAX);
//             SafeStrncat(output, module, BUF_MAX);
//             SafeStrncat(output, "!", BUF_MAX);
//             SafeStrncat(output, symbol, BUF_MAX);
//             SafeStrncat(output, "+0x", BUF_MAX);
//
//             memset(buf, 0, BUF_MAX);
//             _ltoa(displacement, buf, 16);
//             SafeStrncat(output, buf, BUF_MAX);
//
//             if (line)
//             {
//                SafeStrncat(output, " line ", BUF_MAX);
//                memset(buf, 0, BUF_MAX);
//                _ltoa(line, buf, 10);
//                SafeStrncat(output, buf, BUF_MAX);
//             }
//
//             SafeStrncat(output, "   ", BUF_MAX);
//             ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//
//             memset(output, 0, BUF_MAX);
//
//             if (strlen(fullpath))
//             {
//                SafeStrncat(output, fullpath, BUF_MAX);
//             }
//
//             SafeStrncat(output, "\r\n", BUF_MAX);
//             ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//          }
//       }
//    }
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\log.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Debugging tools
//
// 8-13-97 sburns




#include "headers.hxx"



#ifdef LOGGING_BUILD



//
// Debug build only
//



static Burnslib::Log* logInstance = 0;

// # of spaces per indentation level

static const int TAB = 2;



Burnslib::Log*
Burnslib::Log::GetInstance()
{
   do
   {
      if (!logInstance)
      {
         static bool initialized = false;

         if (initialized)
         {
            ASSERT(false);
            break;
         }

         // this might fail with a thrown exception if Log::Log can't
         // init it's critical section.  In that case, we can't allocate
         // an instance.  We don't handle that exception, but let it
         // propagate to the caller
      
         logInstance = new Burnslib::Log(RUNTIME_NAME);
         initialized = true;
      }
   }
   while (0);

   return logInstance;
}



// read the debugging options from the registry

void
Burnslib::Log::ReadLogFlags()
{
   do
   {
      static String keyname =
         String(REG_ADMIN_RUNTIME_OPTIONS) + RUNTIME_NAME;
         
      HKEY hKey = 0;
      LONG result =
         ::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            keyname.c_str(),
            0,
            0,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            0,
            &hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      static const wchar_t* FLAG_VALUE_NAME = L"LogFlags";

      DWORD dataSize = sizeof(flags);
      result =
         ::RegQueryValueEx(
            hKey,
            FLAG_VALUE_NAME,
            0,
            0,
            reinterpret_cast<BYTE*>(&flags),
            &dataSize);
      if (result != ERROR_SUCCESS)
      {
         flags = DEFAULT_LOGGING_OPTIONS;

         // create the value for convenience

         result =
            ::RegSetValueEx(
               hKey,
               FLAG_VALUE_NAME,
               0,
               REG_DWORD,
               reinterpret_cast<BYTE*>(&flags),
               dataSize);
         ASSERT(result == ERROR_SUCCESS);
      }

      ::RegCloseKey(hKey);
   }
   while (0);
}



Burnslib::Log::~Log()
{
   WriteLn(Burnslib::Log::OUTPUT_LOGS, L"closing log");

   ::DeleteCriticalSection(&critsec);

   BOOL success = ::TlsFree(logfileMarginTlsIndex);
   ASSERT(success);

   if (IsOpen())
   {
      ::CloseHandle(fileHandle);
      fileHandle = INVALID_HANDLE_VALUE;

      ::CloseHandle(spewviewHandle);
      spewviewHandle = INVALID_HANDLE_VALUE;
   }
}



void
Burnslib::Log::Cleanup()
{
   delete logInstance;
   logInstance = 0;
}



// Returns the string name of the platform

String
OsName(OSVERSIONINFO& info)
{
   switch (info.dwPlatformId)
   {
      case VER_PLATFORM_WIN32s:
      {
         return L"Win32s on Windows 3.1";
      }
      case VER_PLATFORM_WIN32_WINDOWS:
      {
         switch (info.dwMinorVersion)
         {
            case 0:
            {
               return L"Windows 95";
            }
            case 1:
            {
               return L"Windows 98";
            }
            default:
            {
               return L"Windows 9X";
            }
         }
      }
      case VER_PLATFORM_WIN32_NT:
      {
         return L"Windows NT";
      }
      // case VER_PLATFORM_WIN32_CE:
      // {
      //    return L"Windows CE";
      // }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return L"Some Unknown Windows Version";
}



// locate the log file with the highest-numbered extension, then add 1 and
// return the result.

int
DetermineNextLogNumber(const String& logDir, const String& logBaseName)
{
   ASSERT(!logDir.empty());
   ASSERT(!logBaseName.empty());

   int largest = 0;

   String filespec = logDir + L"\\" + logBaseName + L".*.log";

   WIN32_FIND_DATA findData;
   HANDLE ff = ::FindFirstFile(filespec.c_str(), &findData);

   if (ff != INVALID_HANDLE_VALUE)
   {
      for (;;)
      {
         String current = findData.cFileName;

         // grab the text between the dots: "nnn" in foo.nnn.ext

         // first dot

         size_t pos = current.find(L".");
         if (pos == String::npos)
         {
            continue;
         }

         String extension = current.substr(pos + 1);

         // second dot

         pos = extension.find(L".");
         if (pos == String::npos)
         {
            continue;
         }
   
         extension = extension.substr(0, pos);

         int i = 0;
         extension.convert(i);
         largest = max(i, largest);

         if (!::FindNextFile(ff, &findData))
         {
            BOOL success = ::FindClose(ff);
            ASSERT(success);

            break;
         }
      }
   }

   // roll over after 255
   
   return (++largest & 0xFF);
}



// Determine the name of the log file.  If a log file of that name already
// exists, rename the existing file to a numbered backup.  Create the new
// log file, return a handle to it.
// 
// May propagate exceptions from the FS namespace.

HANDLE
OpenNewLogFile(const String& logBaseName, String& logName)
{
   wchar_t buf[MAX_PATH + 1];

   UINT err = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(err != 0 && err <= MAX_PATH);

   String logDir = String(buf) + L"\\debug";
   logName = logDir + L"\\" + logBaseName + L".log";

   if (::GetFileAttributes(logName.c_str()) != 0xFFFFFFFF)
   {
      // file already exists.  rename the existing file

      int logNumber = DetermineNextLogNumber(logDir, logBaseName);
      String newName =
            logDir
         +  L"\\"
         +  logBaseName
         +  String::format(L".%1!03d!.log", logNumber);

      if (::GetFileAttributes(newName.c_str()) != 0xFFFFFFFF)
      {
         // could exist, as the log numbers roll over

         BOOL success = ::DeleteFile(newName.c_str());
         ASSERT(success);
      }

      // Don't assert that the move is successful.  The user may not have
      // rights to rename the file.  If this is the case, then we will attempt
      // to re-open the old log file and append to it.

      ::MoveFile(logName.c_str(), newName.c_str());
   }

   HANDLE result =
      ::CreateFile(
         logName.c_str(),
         GENERIC_READ | GENERIC_WRITE,
         FILE_SHARE_READ | FILE_SHARE_WRITE,
         0,
         OPEN_ALWAYS,
         FILE_ATTRIBUTE_NORMAL,
         0);

   // don't assert that the create worked: the current user may not have
   // rights to open the log file.

   if (result != INVALID_HANDLE_VALUE)
   {
      LARGE_INTEGER li;
      LARGE_INTEGER newpos;

      memset(&li,     0, sizeof(li));    
      memset(&newpos, 0, sizeof(newpos));

      BOOL success = ::SetFilePointerEx(result, li, &newpos, FILE_END);
      ASSERT(success);
   }

   return result;
}

// Opens the specified log file or creates one if it doesn't
// already exist.
// 
// May propagate exceptions from the FS namespace.

HANDLE
AppendLogFile(const String& logBaseName, String& logName)
{
   wchar_t buf[MAX_PATH + 1];

   UINT err = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(err != 0 && err <= MAX_PATH);

   String logDir = String(buf) + L"\\debug";
   logName = logDir + L"\\" + logBaseName + L".log";

   HANDLE result =
      ::CreateFile(
         logName.c_str(),
         GENERIC_READ | GENERIC_WRITE,
         FILE_SHARE_READ | FILE_SHARE_WRITE,
         0,
         OPEN_ALWAYS,
         FILE_ATTRIBUTE_NORMAL,
         0);

   // don't assert that the create worked: the current user may not have
   // rights to open the log file.

   if (result != INVALID_HANDLE_VALUE)
   {
      LARGE_INTEGER li;
      LARGE_INTEGER newpos;

      memset(&li,     0, sizeof(li));    
      memset(&newpos, 0, sizeof(newpos));

      BOOL success = ::SetFilePointerEx(result, li, &newpos, FILE_END);
      ASSERT(success);
   }

   return result;
}



// This wrapper function required to make prefast shut up.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      ::InitializeCriticalSection(critsec);
   }

   // propagate the exception to our caller.  This will cause Log::Log
   // to abort prematurely, which will jump to the the handler in
   // Log::GetInstance
   
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
   
   

// Create a new log.
//
// logBaseName - base name of the log.  If logging-to-file is active, then a
// file in the %windir%\debug folder will be created/used.  The name of the
// file is of the form %windir%\debug\logBaseName.log.  If a file by that name
// already exists, then the existing file will be renamed
// %windir%\debug\logBaseName.xxx.log, where xxx is an integer 1 greater than
// the last so-numbered file in that directory.

Burnslib::Log::Log(const String& logBaseName)
   :
   baseName(logBaseName),
   fileHandle(INVALID_HANDLE_VALUE),
   flags(0),
   spewviewHandle(INVALID_HANDLE_VALUE),
   spewviewPipeName(),
   traceLineNumber(0),
   logfileMarginTlsIndex(0)
{
   ASSERT(!logBaseName.empty());

   ReadLogFlags();

   ExceptionPropagatingInitializeCriticalSection(&critsec);

   // create thread-local storage for per-thread debugging state.  We keep
   // the output margin in the slot.

   logfileMarginTlsIndex = ::TlsAlloc();
   ASSERT(logfileMarginTlsIndex != 0xFFFFFFFF);

   // spewview setup is done on-demand in WriteLn, so that spewview will
   // be used as soon as the server sets up the connection.

   if (ShouldLogToFile())
   {
      String logName;
      fileHandle = OpenNewLogFile(logBaseName, logName);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(L"opening log file %1", logName.c_str()));
   }
   else if (ShouldAppendLogToFile())
   {
      String logName;
      fileHandle = AppendLogFile(logBaseName, logName);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(L"appending to log file %1", logName.c_str()));
   }

   WriteHeader();
}



void
Burnslib::Log::WriteHeaderModule(HMODULE moduleHandle)
{
   do
   {
      wchar_t filename[MAX_PATH + 1];
      ::ZeroMemory(filename, sizeof(filename));

      if (::GetModuleFileNameW(moduleHandle, filename, MAX_PATH) == 0)
      {
         break;
      }

      WriteLn(Burnslib::Log::OUTPUT_HEADER, filename);

      // add the timestamp of the file

      WIN32_FILE_ATTRIBUTE_DATA attr;
      ::ZeroMemory(&attr, sizeof(attr));
      if (
         ::GetFileAttributesEx(
            filename,
            GetFileExInfoStandard,
            &attr) == 0)
      {
         break;
      }

      FILETIME localtime;
      ::FileTimeToLocalFileTime(&attr.ftLastWriteTime, &localtime);
      SYSTEMTIME systime;
      ::FileTimeToSystemTime(&localtime, &systime);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(
            L"file timestamp %1!02u!/%2!02u!/%3!04u! "
            L"%4!02u!:%5!02u!:%6!02u!.%7!04u!",
            systime.wMonth,
            systime.wDay,
            systime.wYear,
            systime.wHour,
            systime.wMinute,
            systime.wSecond,
            systime.wMilliseconds));
   }
   while (0);
}



void
Burnslib::Log::WriteHeader()
{
   // Log the name and timestamp of the file that created the process.

   WriteHeaderModule(0);

   // Log the name and timestamp of the file that corresponds to the
   // resource module handle, if there is one.

   if (hResourceModuleHandle)
   {
      WriteHeaderModule(hResourceModuleHandle);
   }

   SYSTEMTIME localtime;
   ::GetLocalTime(&localtime);
   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"local time %1!02u!/%2!02u!/%3!04u! "
         L"%4!02u!:%5!02u!:%6!02u!.%7!04u!",
         localtime.wMonth,
         localtime.wDay,
         localtime.wYear,
         localtime.wHour,
         localtime.wMinute,
         localtime.wSecond,
         localtime.wMilliseconds));

   OSVERSIONINFO info;
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

   BOOL success = ::GetVersionEx(&info);
   ASSERT(success);

   // Get the whistler build lab version

   String labInfo;
   do
   {
      HKEY key = 0;
      LONG err =
         ::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &key);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      wchar_t buf[MAX_PATH + 1];
      DWORD type = 0;
      DWORD bufSize = MAX_PATH + 1;

      err =
         ::RegQueryValueEx(
            key,
            L"BuildLab",
            0,
            &type,
            reinterpret_cast<BYTE*>(buf),
            &bufSize);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      labInfo = buf;
   }
   while (0);

   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"running %1 %2!d!.%3!d! build %4!d! %5 (BuildLab:%6)",
         OsName(info).c_str(),
         info.dwMajorVersion,
         info.dwMinorVersion,
         info.dwBuildNumber,
         info.szCSDVersion,
         labInfo.c_str()));

   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"logging flags %1!08X!",
         flags));
}



HRESULT
Log::AdjustLogMargin(int delta)
{
   // extract the current value in this thread's slot

   HRESULT hr = S_OK;   
   do
   {
      PVOID margin = ::TlsGetValue(logfileMarginTlsIndex);
      if (!margin)
      {
         DWORD err = ::GetLastError();
         if (err != NO_ERROR)
         {
            hr = HRESULT_FROM_WIN32(err);
            break;
         }
      }

      // indent by adding to the margin

      ULONG_PTR marginTemp = reinterpret_cast<ULONG_PTR>(margin);

      // marginTemp will always be > 0, as it is unsigned.

      marginTemp += delta;

      margin = reinterpret_cast<PVOID>(marginTemp);

      // save the new margin in this thread's slot

      BOOL succeeded = ::TlsSetValue(logfileMarginTlsIndex, margin);
      if (!succeeded)
      {
         DWORD lastErr = ::GetLastError();
         hr = HRESULT_FROM_WIN32(lastErr);
         break;
      }
   }
   while (0);

   return hr;
}



// guarded by caller

void
Burnslib::Log::Indent()
{
   HRESULT hr = AdjustLogMargin(TAB);
   ASSERT(SUCCEEDED(hr));
}



// guarded by caller

void
Burnslib::Log::Outdent()
{
   HRESULT hr = AdjustLogMargin(-TAB);
   ASSERT(SUCCEEDED(hr));
}



size_t
Burnslib::Log::GetLogMargin()
{
   PVOID margin = ::TlsGetValue(logfileMarginTlsIndex);
   if (!margin)
   {
      DWORD err = ::GetLastError();
      if (err != NO_ERROR)
      {
         ASSERT(false);
         return 0;
      }
   }

   return   
      static_cast<size_t>(
         reinterpret_cast<ULONG_PTR>(margin));
}



// Examine the registry key for the name of the pipe, append our debugging
// baseName to make it specific to this binary, and return the result.  Return
// an empty string on error (most likely casuse: the registry keys are not yet
// present)
// 
// baseName - the logfile base name used to identify this binary.

String
DetermineSpewviewPipeName(const String& baseName)
{
   String result;

   do
   {
      HKEY key = 0;
      LONG err =
         ::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            (String(REG_ADMIN_RUNTIME_OPTIONS) + L"Spewview\\" + baseName).c_str(),
            0,
            KEY_READ,
            &key);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      wchar_t buf[MAX_PATH + 1];
      DWORD type = 0;
      DWORD bufSize = MAX_PATH + 1;

      err =
         ::RegQueryValueEx(
            key,
            L"Server",
            0,
            &type,
            reinterpret_cast<BYTE*>(buf),
            &bufSize);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      result = 
            L"\\\\"
         +  String(buf)
         +  L"\\pipe\\spewview\\"
         +  baseName;
   }
   while (0);

   return result;
}



// Attempts to connect to the spewview application that is running elsewhere.
// Sets the spewviewHandle parameter to a valid handle on success, or
// INVALID_HANDLE_VALUE on error.
//
// baseName - the logfile base name used to identify this binary.
//
// spewviewPipeName - if empty, set to the name of the pipe.  If not empty,
// used as the name of the pipe that the handle will be opened on.
//
// spewviewHandle - handle to the named pipe that spewage will be written to.
// On success, this is set to a valid handle.  On failure, this is set to
// INVALID_HANDLE_VALUE.

void
AttemptConnectToSpewPipe(
   const String&  baseName,
   String&        spewviewPipeName,
   HANDLE&        spewviewHandle)
{
   ASSERT(!baseName.empty());
   ASSERT(spewviewHandle == INVALID_HANDLE_VALUE);

   spewviewHandle = INVALID_HANDLE_VALUE;

   // only attempt to determine the pipe name as long as we haven't been
   // successful determining it so far.

   if (spewviewPipeName.empty())
   {
      spewviewPipeName = DetermineSpewviewPipeName(baseName);
   }

   do
   {
      // wait a very short time for the pipe to become available

      BOOL err = ::WaitNamedPipe(spewviewPipeName.c_str(), 500);
      if (!err)
      {
         // pipe not available

         // DWORD lastErr = ::GetLastError();

         break;
      }

      spewviewHandle =
         ::CreateFile(
            spewviewPipeName.c_str(),
            GENERIC_WRITE,
            0,
            0,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            0);

      if (spewviewHandle == INVALID_HANDLE_VALUE)
      {
         // DWORD lastErr = ::GetLastError();

         break;
      }
   }
   while (0);

   return;
}



String
Burnslib::Log::ComposeSpewLine(const String& text)
{
   // This needs to be a wchar_t*, not a String, as this function will be
   // called by Log::~Log, which is called when the process is being cleaned
   // up.  Part of the cleanup is to delete all static objects created since
   // the program started, in reverse order of construction.  This includes
   // the InitializationGuard instances.
   //
   // The final invocation of the Initialization dtor will cause the single
   // Log instance to be deleted, which will log a message, which will call
   // this routine, so SPEW_FMT better still exist. If SPEW_FMT were an
   // object, it would be instanciated after the InitializationGuard objects,
   // and destroyed before them, and so would not exist at that point.
   //
   // (you may rightly suspect that I discovered this after I had declared
   // SPEW_FMT a String instance.)

   static const wchar_t* SPEW_FMT = 
      L"%1 "         // base name
      L"%2!03X!."    // process id
      L"%3!03X! "    // thread id
      L"%4!04X! "    // spew line number
      L"%5"          // time of day
      L"%6"          // run time (time since process start)
      L"%7"          // margin whitespace
      L"%8"          // text
      L"\r\n";

   size_t margin = GetLogMargin();
   String white(margin, L' ');

   String tod;
   if (ShouldLogTimeOfDay())
   {
      SYSTEMTIME localtime;
      ::GetLocalTime(&localtime);

      tod = 
         String::format(
            L"%1!02u!:%2!02u!:%3!02u!.%4!04u! ",
            localtime.wHour,
            localtime.wMinute,
            localtime.wSecond,
            localtime.wMilliseconds);
   }

   String rt;
   if (ShouldLogRunTime())
   {
      static DWORD MILLIS_PER_SECOND = 1000;
      static DWORD MILLIS_PER_MINUTE = 60000;
      static DWORD MILLIS_PER_HOUR   = 3600000;
      static DWORD MILLIS_PER_DAY    = 86400000;

      DWORD tics = ::GetTickCount();

      unsigned days = tics / MILLIS_PER_DAY;
      tics -= days * MILLIS_PER_DAY;

      unsigned hours = tics / MILLIS_PER_HOUR;
      tics -= hours * MILLIS_PER_HOUR;

      unsigned minutes = tics / MILLIS_PER_MINUTE;
      tics -= minutes * MILLIS_PER_MINUTE;

      unsigned seconds = tics / MILLIS_PER_SECOND;
      tics -= seconds * MILLIS_PER_SECOND;

      rt =
         String::format(
            L"%1!02u!:%2!02u!:%3!02u!:%4!02u!.%5!04u! ",
            days,
            hours,
            minutes,
            seconds,
            tics);
   }

   String t =
      String::format(
         SPEW_FMT,
         RUNTIME_NAME,
         ::GetCurrentProcessId(),
         ::GetCurrentThreadId(),
         traceLineNumber,
         tod.c_str(),
         rt.c_str(),
         white.c_str(),
         text.c_str() );

   return t;
}



// Spews output to the log according to the current logging type and
// output options in effect.
//
// type - log output type of this output spewage.
//
// text - the spewage.  This is prefaced with the log name, thread id, spewage
// line number, and current indentation.

void
Burnslib::Log::UnguardedWriteLn(DWORD type, const String& text)
{
   // guarded by caller

   // CODEWORK: could circumvent this with a registry change notification
   // (re-read only if changed)

   // ReadLogFlags();

   if (
            !ShouldLogToFile()
      and   !ShouldLogToDebugger()
      and   !ShouldLogToSpewView() )
   {
      // nothing to do

      return;
   }

   if (type & DebugType())
   {
      String t = ComposeSpewLine(text);

      if (ShouldLogToDebugger())
      {
         ::OutputDebugString(t.c_str());
      }

      if (ShouldLogToFile())
      {
         if (IsOpen())
         {
            // write disk output as unicode text.

            DWORD bytesToWrite =
               static_cast<DWORD>(t.length() * sizeof(wchar_t));
            DWORD bytesWritten = 0;
            BOOL success =
               ::WriteFile(
                  fileHandle,
                  reinterpret_cast<void*>(const_cast<wchar_t*>(t.data())),
                  bytesToWrite,
                  &bytesWritten,
                  0);

            ASSERT(success);
         }
      }

      if (ShouldLogToSpewView())
      {
         if (spewviewHandle == INVALID_HANDLE_VALUE)
         {
            AttemptConnectToSpewPipe(
               baseName,
               spewviewPipeName,
               spewviewHandle);
         }

         if (spewviewHandle != INVALID_HANDLE_VALUE)
         {
            // the connect attempt worked, and we have a valid handle.
               
            DWORD bytesToWrite =
               static_cast<DWORD>(t.length() * sizeof(wchar_t));
            DWORD bytesWritten = 0;

            BOOL result =
               ::WriteFile(
                  spewviewHandle,
                  t.c_str(),
                  bytesToWrite,
                  &bytesWritten,
                  0);
            if (!result)
            {
               // write failed, so disconnect.  On the next call to this
               // function, we will attempt to reconnect.

               ::CloseHandle(spewviewHandle);
               spewviewHandle = INVALID_HANDLE_VALUE;
            }
         }
      }

      ++traceLineNumber;
   }
}



void
Burnslib::Log::WriteLn(
   WORD           type,
   const String&  text)
{
   ::EnterCriticalSection(&critsec);
   UnguardedWriteLn(type, text);
   ::LeaveCriticalSection(&critsec);
}



Burnslib::Log::ScopeTracer::ScopeTracer(
   DWORD          type_,
   const String&  message_)
   :
   message(message_),
   type(type_)
{
   // build this string once, instead of using the string literal in the
   // below expression (which would implicitly build the string on each
   // evaluation of that expression) as a slight performance gain.

   static const String ENTER(L"Enter ");

   Burnslib::Log* li = Burnslib::Log::GetInstance();

   ASSERT(li);

   if (!li)
   {
      return;
   }

   if (type & li->DebugType())
   {
      ::EnterCriticalSection(&li->critsec);

      li->UnguardedWriteLn(type, ENTER + message);
      li->Indent();

      ::LeaveCriticalSection(&li->critsec);
   }
}



Burnslib::Log::ScopeTracer::~ScopeTracer()
{
   // build this string once, instead of using the string literal in the
   // below expression (which would implicitly build the string on each
   // evaluation of that expression) as a slight performance gain.

   static const String EXIT(L"Exit  ");

   Burnslib::Log* li = Burnslib::Log::GetInstance();

   ASSERT(li);

   if (!li)
   {
      return;
   }

   DWORD dt = li->DebugType();
   if ((type & dt))
   {
      ::EnterCriticalSection(&li->critsec);

      li->Outdent();

      if (OUTPUT_SCOPE_EXIT & dt)
      {
         li->UnguardedWriteLn(type, EXIT + message);
      }

      ::LeaveCriticalSection(&li->critsec);
   }
}



#endif   // LOGGING_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\stacktr.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// stack backtracing stuff
//
// 22-Nov-1999 sburns (refactored)



#include "headers.hxx"



// Since we call some of this code from Burnslib::FireAssertionFailure,
// we use our own even more private ASSERT

#if DBG

#define RTLASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else
#define RTLASSERT( exp )
#endif // DBG



static HMODULE  imageHelpDll = 0;              



// function pointers to be dynamically resolved by the Initialize function.

typedef DWORD (*SymSetOptionsFunc)(DWORD);
static SymSetOptionsFunc MySymSetOptions = 0;

typedef BOOL (*SymInitializeFunc)(HANDLE, PSTR, BOOL);
static SymInitializeFunc MySymInitialize = 0;

typedef BOOL (*SymCleanupFunc)(HANDLE);
static SymCleanupFunc MySymCleanup = 0;

typedef BOOL (*SymGetModuleInfoFunc)(HANDLE, DWORD64, PIMAGEHLP_MODULE64);
static SymGetModuleInfoFunc MySymGetModuleInfo = 0;

typedef BOOL (*SymGetLineFromAddrFunc)(HANDLE, DWORD64, PDWORD, PIMAGEHLP_LINE64);
static SymGetLineFromAddrFunc MySymGetLineFromAddr = 0;

typedef BOOL (*StackWalkFunc)(
   DWORD, HANDLE, HANDLE, LPSTACKFRAME64, PVOID,
   PREAD_PROCESS_MEMORY_ROUTINE64, PFUNCTION_TABLE_ACCESS_ROUTINE64,
   PGET_MODULE_BASE_ROUTINE64, PTRANSLATE_ADDRESS_ROUTINE64);
static StackWalkFunc MyStackWalk = 0;

typedef BOOL (*SymGetSymFromAddrFunc)(
   HANDLE, DWORD64, PDWORD64, PIMAGEHLP_SYMBOL64);
static SymGetSymFromAddrFunc MySymGetSymFromAddr = 0;



namespace Burnslib
{

namespace StackTrace
{
   // This must be called before any of the other functions in this
   // namespace

   void
   Initialize();

   bool
   IsInitialized()
   {
      return imageHelpDll != 0;
   }
}

}  // namespace Burnslib



void
Burnslib::StackTrace::Initialize()
{
   RTLASSERT(!IsInitialized());

   // load the imagehlp dll

   imageHelpDll = static_cast<HMODULE>(::LoadLibrary(L"imagehlp.dll"));

   RTLASSERT(imageHelpDll);

   if (!imageHelpDll)
   {
      return;
   }

   // resolve the function pointers

   MySymSetOptions =
      reinterpret_cast<SymSetOptionsFunc>(
         ::GetProcAddress(imageHelpDll, "SymSetOptions"));

   MySymInitialize =
      reinterpret_cast<SymInitializeFunc>(
         ::GetProcAddress(imageHelpDll, "SymInitialize"));

   MySymCleanup =
      reinterpret_cast<SymCleanupFunc>(
         ::GetProcAddress(imageHelpDll, "SymCleanup"));

   MySymGetModuleInfo =
      reinterpret_cast<SymGetModuleInfoFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetModuleInfo64"));

   MySymGetLineFromAddr =
      reinterpret_cast<SymGetLineFromAddrFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetLineFromAddr64"));

   MyStackWalk =
      reinterpret_cast<StackWalkFunc>(
         ::GetProcAddress(imageHelpDll, "StackWalk64"));

   MySymGetSymFromAddr =
      reinterpret_cast<SymGetSymFromAddrFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetSymFromAddr64"));
      
   if (
         !MySymSetOptions
      or !MySymInitialize
      or !MySymCleanup
      or !MySymGetModuleInfo
      or !MySymGetLineFromAddr
      or !MyStackWalk
      or !MySymGetSymFromAddr)
   {
      return;
   }

   // Init the stack trace facilities

   //lint -e(534) we're not interested in the return value.

   MySymSetOptions(
         SYMOPT_DEFERRED_LOADS
      |  SYMOPT_UNDNAME
      |  SYMOPT_LOAD_LINES);

   // the (default) symbol path is:
   // current directory;%_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%;
   // %SYSTEMROOT%

   BOOL succeeded = MySymInitialize(::GetCurrentProcess(), 0, TRUE);

   RTLASSERT(succeeded);
}



void
Burnslib::StackTrace::Cleanup()
{
   if (IsInitialized())
   {
      BOOL succeeded = MySymCleanup(::GetCurrentProcess());

      RTLASSERT(succeeded);

      ::FreeLibrary(imageHelpDll);
      imageHelpDll = 0;
   }
}



// a SEH filter function that walks the stack, and stuffs the offset pointers
// into the provided array.

DWORD
GetStackTraceFilter(
   DWORD64 stackTrace[],
   size_t    traceMax,    
   CONTEXT*  context,
   size_t    levelsToSkip)     
{
   RTLASSERT(Burnslib::StackTrace::IsInitialized());
   RTLASSERT(MyStackWalk);

   memset(stackTrace, 0, traceMax * sizeof(DWORD64));

   if (!MyStackWalk)
   {
      // initialization failed in some way, so do nothing.

      return EXCEPTION_EXECUTE_HANDLER;
   }

   STACKFRAME64 frame;
   memset(&frame, 0, sizeof(frame));

#if defined(_M_IX86)
   #define MACHINE_TYPE  IMAGE_FILE_MACHINE_I386
   frame.AddrPC.Offset       = context->Eip;
   frame.AddrPC.Mode         = AddrModeFlat;
   frame.AddrFrame.Offset    = context->Ebp;
   frame.AddrFrame.Mode      = AddrModeFlat;
   frame.AddrStack.Offset    = context->Esp;
   frame.AddrStack.Mode      = AddrModeFlat;

#elif defined(_M_AMD64)
   #define MACHINE_TYPE  IMAGE_FILE_MACHINE_AMD64
   frame.AddrPC.Offset       = context->Rip;

#elif defined(_M_IA64)
   #define MACHINE_TYPE  IMAGE_FILE_MACHINE_IA64

#else
   #error( "unknown target machine" );
#endif

   HANDLE process = ::GetCurrentProcess();
   HANDLE thread = ::GetCurrentThread();

   for (size_t i = 0, top = 0; top < traceMax; ++i)
   {
      BOOL result =
         MyStackWalk(
            MACHINE_TYPE,
            process,
            thread,
            &frame,
            context,
            0,
            SymFunctionTableAccess64,
            SymGetModuleBase64,
            0);
      if (!result)
      {
         break;
      }

      // skip the n most recent frames

      if (i >= levelsToSkip)
      {
         stackTrace[top++] = frame.AddrPC.Offset;
      }
   }

   return EXCEPTION_EXECUTE_HANDLER;
}



DWORD
Burnslib::StackTrace::TraceFilter(
   DWORD64  stackTrace[],
   size_t   traceMax,    
   CONTEXT* context)     
{
   RTLASSERT(stackTrace);
   RTLASSERT(traceMax);
   RTLASSERT(context);

   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   return 
      GetStackTraceFilter(stackTrace, traceMax, context, 0);
}
   


void
Burnslib::StackTrace::Trace(DWORD64 stackTrace[], size_t traceMax)
{
   RTLASSERT(stackTrace);
   RTLASSERT(traceMax);

   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   // the only way to get the context of a running thread is to raise an
   // exception....

   __try
   {
      RaiseException(0, 0, 0, 0);
   }
   __except (
      GetStackTraceFilter(
         stackTrace,
         traceMax,

         //lint --e(*) GetExceptionInformation is like a compiler intrinsic

         (GetExceptionInformation())->ContextRecord,

         // skip the 2 most recent function calls, as those correspond to
         // this function itself.

         2))
   {
      // do nothing in the handler
   }
}



// strncpy that will not overflow the buffer.

inline
void
SafeStrncpy(char* dest, const char* src, size_t bufmax)
{
   memset(dest, 0, bufmax);
   strncpy(dest, src, bufmax - 1);
}



void
Burnslib::StackTrace::LookupAddress(
   DWORD64  traceAddress,   
   char     moduleName[],   
   char     fullImageName[],
   char     symbolName[],    // must be SYMBOL_NAME_MAX bytes
   DWORD64* displacement,   
   DWORD*   line,           
   char     fullpath[])      // must be MAX_PATH bytes
{
   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   RTLASSERT(traceAddress);

   HANDLE process = ::GetCurrentProcess();

   if (moduleName || fullImageName)
   {
      IMAGEHLP_MODULE64 module;
      memset(&module, 0, sizeof(module));
      module.SizeOfStruct = sizeof(module);
      if (MySymGetModuleInfo(process, traceAddress, &module))
      {
         if (moduleName)
         {
            SafeStrncpy(moduleName, module.ModuleName, MODULE_NAME_MAX);
         }
         if (fullImageName)
         {
            SafeStrncpy(
               fullImageName,
               module.LoadedImageName,
               MAX_PATH);
         }
      }
   }

   if (symbolName || displacement)
   {
      BYTE buf[sizeof(IMAGEHLP_SYMBOL) + SYMBOL_NAME_MAX];
      memset(buf, 0, sizeof(IMAGEHLP_SYMBOL) + SYMBOL_NAME_MAX);

      IMAGEHLP_SYMBOL64* symbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>(buf);
      symbol->SizeOfStruct = sizeof(buf);
      symbol->MaxNameLength = SYMBOL_NAME_MAX;

      if (MySymGetSymFromAddr(process, traceAddress, displacement, symbol))
      {
         if (symbolName)
         {
            SafeStrncpy(symbolName, symbol->Name, SYMBOL_NAME_MAX);
         }
      }
   }

   if (line || fullpath)
   {
      DWORD disp2 = 0;
      IMAGEHLP_LINE64 lineinfo;
      memset(&lineinfo, 0, sizeof(lineinfo));
      lineinfo.SizeOfStruct = sizeof(lineinfo);

      if (MySymGetLineFromAddr(process, traceAddress, &disp2, &lineinfo))
      {
         // disp2 ?= displacement

         if (line)
         {
            *line = lineinfo.LineNumber;
         }
         if (fullpath)
         {
            SafeStrncpy(fullpath, lineinfo.FileName, MAX_PATH);
         }
      }
   }
}



String
Burnslib::StackTrace::LookupAddress(
   DWORD64 traceAddress,
   const wchar_t* format)
{
   RTLASSERT(traceAddress);
   RTLASSERT(format);

   String result;

   if (!format or !traceAddress)
   {
      return result;
   }

   char      ansiSymbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
   char      ansiModule[Burnslib::StackTrace::MODULE_NAME_MAX];
   char      ansiSource[MAX_PATH];                           
   DWORD64   displacement = 0;
   DWORD     line         = 0;

   memset(ansiSymbol, 0, Burnslib::StackTrace::SYMBOL_NAME_MAX);
   memset(ansiModule, 0, Burnslib::StackTrace::MODULE_NAME_MAX);
   memset(ansiSource, 0, MAX_PATH);                             

   Burnslib::StackTrace::LookupAddress(
      traceAddress,
      ansiModule,
      0,
      ansiSymbol,
      &displacement,
      &line,
      ansiSource);

   String module(ansiModule);
   String symbol(ansiSymbol);
   String source(ansiSource);

   result =
      String::format(
         format,
         module.c_str(),
         symbol.c_str(),
         source.c_str(),
         line);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\string.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// string class
//
// 8-14-97 sburns
 
  

#include "headers.hxx"



String::String(PCSTR lpsz)
   :
   base()
{
   size_t len = lpsz ? static_cast<size_t>(lstrlenA(lpsz)) : 0;

   if (len)
   {
      assignFromAnsi(lpsz, len);
   }
}



String::String(const AnsiString& s)
   :
   base()
{
   size_t len = s.length();

   if (len)
   {
      assignFromAnsi(s.data(), len);
   }
}



void
String::assignFromAnsi(PCSTR lpsz, size_t len)
{
   ASSERT(lpsz);
   ASSERT(len);

   // add 1 to allow for trailing null

   wchar_t* buf = new wchar_t[len + 1];
   memset(buf, 0, (len + 1) * sizeof(wchar_t));

   size_t result =
      static_cast<size_t>(
         ::MultiByteToWideChar(
            CP_ACP,
            0,
            lpsz,

            // len bytes in the source ansi string (not incl trailing null)

            static_cast<int>(len),
            buf,

            // len characters in the result wide string (not incl trailing
            // null)

            static_cast<int>(len)));

   if (result)
   {
      ASSERT(result <= len);
      assign(buf);
   }

   delete[] buf;
}
      


HRESULT
String::as_OLESTR(LPOLESTR& oleString) const
{
   size_t len = length();

   oleString =
      reinterpret_cast<LPOLESTR>(
         ::CoTaskMemAlloc((len + 1) * sizeof(wchar_t)));
   if (oleString)
   {
      copy(oleString, len);
      oleString[len] = 0;
      return S_OK;
   }

   return E_OUTOFMEMORY;
}



String
String::load(unsigned resID, HINSTANCE hInstance)
{
   if (!hInstance)
   {
      hInstance = GetResourceModuleHandle();
   }

   static const int TEMP_LEN = 512;
   wchar_t temp[TEMP_LEN];
   int tempLen = TEMP_LEN;

   int len = ::LoadString(hInstance, resID, temp, tempLen);
   ASSERT(len);

   if (len == 0)
   {
      return String();
   }

   if (tempLen - len > 1)
   {
      // the string fit into the temp buffer with at least 1 character to
      // spare.  If the load failed, len == 0, and we return the empty
      // string.

      return String(temp);
   }

   // the string did not fit.  Try larger buffer sizes until the string does
   // fit with at least 1 character to spare

   int newLen = tempLen;
   wchar_t* newTemp = 0;
   do
   {
      delete[] newTemp;
      newLen += TEMP_LEN;
      newTemp = new wchar_t[static_cast<size_t>(newLen)];
      len = ::LoadString(hInstance, resID, newTemp, newLen);
   }
   while (newLen - len <= 1);   // repeat until at least 1 char to spare

   String r(newTemp);
   delete[] newTemp;
   return r;
}



String&
String::replace(const String& from, const String& to)
{
   if (from.empty())
   {
      return *this;
   }

   _copy();
   String::size_type i = 0;
   String::size_type fl = from.length();
   String::size_type tl = to.length();
   String::size_type len = length();
   const wchar_t* td = to.data();

   do
   {
      i = find(from, i);
      if (i == String::npos)
      {
         return *this;
      }
      base::replace(i, fl, td, tl);
      i += tl;
   }
   while (i <= len);

   return *this;
}



String&
String::strip(StripType type, wchar_t charToStrip)
{
   String::size_type start = 0;
   String::size_type stop = length();
   const wchar_t* p = data();

   if (type & LEADING)
   {
      while (start < stop && p[start] == charToStrip)
      {
         ++start;
      }
   }

   if (type & TRAILING)
   {
      while (start < stop && p[stop - 1] == charToStrip)
      {
         --stop;
      }
   }

   if (stop == start)
   {
      assign(String());
   }
   else
   {
      // this goofiness due to a bug in basic_string where you can't assign
      // a piece of yourself, because you delete yourself before you copy!
      // assign(p + start, stop - start);

      String s(p + start, stop - start);
      assign(s);
   }

   return *this;
}



String&
String::to_lower()
{
   if (length())
   {
      _copy();
      _wcslwr(const_cast<wchar_t*>(c_str()));
   }
   return *this;
}



String&
String::to_upper()
{
   if (length())
   {
      _copy();
      _wcsupr(const_cast<wchar_t*>(c_str()));
   }
   return *this;
}



void
String::_copy() 
{
   size_type len = length();
   if (len)
   {
      value_type* buf = new value_type[len + 1];
      copy(buf, len);
      buf[len] = 0;
      assign(buf);
      delete[] buf;
   }
}



//
// static functions
//



#if defined(ALPHA) || defined(IA64)
   String __cdecl
   String::format(
      const String& qqfmt,
      ...)
#else

   // the x86 compiler won't allow the first parameter to be a reference
   // type.  This is a compiler bug.

   String __cdecl
   String::format(
      const String qqfmt,
      ...)
#endif

{
   String result;

   va_list argList;
   va_start(argList, qqfmt);

   PTSTR temp = 0;
   PCTSTR f = qqfmt.c_str();

   if (
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         f,
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(
   const wchar_t* qqfmt,
   ...)
{
   String result;

   va_list argList;
   va_start(argList, qqfmt);

   PTSTR temp = 0;

   if (
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         qqfmt,
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(unsigned formatResID, ...)
{
   String fmt = String::load(formatResID);
   String result;

   va_list argList;
   va_start(argList, formatResID);
   PTSTR temp = 0;
   if (
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         fmt.c_str(),
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(int formatResID, ...)
{
   String fmt = String::load(formatResID);

   va_list argList;
   va_start(argList, formatResID);
   PTSTR temp = 0;
   if (
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         fmt.c_str(),
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      String retval(temp);
      ::LocalFree(temp);
      va_end(argList);
      return retval;
   }

   va_end(argList);
   return String();
}



int
String::icompare(const String& str) const
{
   int i =
      ::CompareString(
         LOCALE_USER_DEFAULT,
            NORM_IGNORECASE

            // these flags necessary for Japanese strings

         |  NORM_IGNOREKANATYPE  
         |  NORM_IGNOREWIDTH,
         c_str(),
         static_cast<int>(length()),
         str.c_str(),
         static_cast<int>(str.length()));
   if (i)
   {
      // convert to < 0, == 0, > 0 C runtime convention

      return i - 2;
   }

   // this will be wrong, but what option do we have?

   return i; 
}
   


HRESULT
WideCharToMultiByteHelper(
   DWORD          flags,
   const String&  str,
   char*          buffer,
   size_t         bufferSize,
   size_t&        result)
{
   ASSERT(!str.empty());

   result = 0;

   HRESULT hr = S_OK;

   int r =
      ::WideCharToMultiByte(
         CP_ACP,
         flags,
         str.c_str(),
         static_cast<int>(str.length()),
         buffer,
         static_cast<int>(bufferSize),
         0,
         0);
   if (!r)
   {
      hr = Win32ToHresult(::GetLastError());
   }

   ASSERT(SUCCEEDED(hr));

   result = static_cast<size_t>(r);

   return hr;
}



String::ConvertResult
String::convert(AnsiString& ansi) const
{
   ansi.erase();

   ConvertResult result = CONVERT_FAILED;

   do
   {
      if (empty())
      {
         // nothing else to do.

         result = CONVERT_SUCCESSFUL;
         break;
      }

      // determine the size of the buffer required to hold the ANSI string

      const wchar_t* wide = c_str();

      size_t bufsize = 0;
      HRESULT hr = ::WideCharToMultiByteHelper(0, wide, 0, 0, bufsize);
      BREAK_ON_FAILED_HRESULT(hr);
   
      if (bufsize > 0)
      {
         AnsiString a(bufsize, 0);
         char* p = const_cast<char*>(a.c_str());

         size_t r = 0;
         hr = ::WideCharToMultiByteHelper(0, wide, p, bufsize, r);
         BREAK_ON_FAILED_HRESULT(hr);

         ansi = a;
         result = CONVERT_SUCCESSFUL;
      }
   }
   while (0);

   return result;
}



template<class UnsignedType>
class UnsignedConvertHelper
{
   public:

   // at first glance, one might think that this is a job for a template
   // member function.  That's what I thought.  Unfortunately, the combination
   // of freely convertible integer types and the binding rules for resolving
   // function templates results in ambiguity.  Using a static class method,
   // though, allows the caller to specify the template parameter types, and
   // avoid the abiguity.
   
   static
   String::ConvertResult
   doit(const String& s, UnsignedType& u, int radix, UnsignedType maxval)
   {
      // call the long version, then truncate as appropriate
   
      unsigned long ul = 0;
      u = 0;
      String::ConvertResult result = s.convert(ul, radix);

      if (result == String::CONVERT_SUCCESSFUL)
      {
         if (ul <= maxval)
         {
            // ul will fit into an unsigned int.
            u = static_cast<UnsignedType>(ul);
         }
         else
         {
            result = String::CONVERT_OVERFLOW;
         }
      }

      return result;
   }
};



template<class IntType>
class IntegerConvertHelper
{
   public:

   static
   String::ConvertResult
   doit(const String& s, IntType& u, int radix, IntType minval, IntType maxval)
   {
      long l = 0;
      u = 0;
      String::ConvertResult result = s.convert(l, radix);

      if (result == String::CONVERT_SUCCESSFUL)
      {
         if (l <= maxval)
         {
            if (l >= minval)
            {
               // l will fit into an IntType.
               u = static_cast<IntType>(l);
            }
            else
            {
               result = String::CONVERT_UNDERFLOW;
            }
         }
         else
         {
            result = String::CONVERT_OVERFLOW;
         }
      }

      return result;
   }
};




String::ConvertResult
String::convert(short& s, int radix) const
{
   return
      IntegerConvertHelper<short>::doit(*this, s, radix, SHRT_MIN, SHRT_MAX);
}



String::ConvertResult
String::convert(int& i, int radix) const
{
   return
      IntegerConvertHelper<int>::doit(*this, i, radix, INT_MIN, INT_MAX);
}



String::ConvertResult
String::convert(unsigned short& us, int radix) const
{
   return
      UnsignedConvertHelper<unsigned short>::doit(
         *this,
         us,
         radix,
         USHRT_MAX);
}



String::ConvertResult
String::convert(unsigned& ui, int radix) const
{
   return
      UnsignedConvertHelper<unsigned int>::doit(
         *this,
         ui,
         radix,
         UINT_MAX);
}



String::ConvertResult
String::convert(long& l, int radix) const
{
   l = 0;
   if (radix != 0 && (radix < 2 || radix > 36))
   {
      ASSERT(false);
      return CONVERT_BAD_RADIX;
   }

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   long result = wcstol(begptr, &endptr, radix);
   if (errno == ERANGE)
   {
      return result == LONG_MAX ? CONVERT_OVERFLOW : CONVERT_UNDERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   l = result;
   return CONVERT_SUCCESSFUL;
}



String::ConvertResult
String::convert(unsigned long& ul, int radix) const
{
   ul = 0;
   if (radix != 0 && (radix < 2 || radix > 36))
   {
      ASSERT(false);
      return CONVERT_BAD_RADIX;
   }

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   unsigned long result = wcstoul(begptr, &endptr, radix);
   if (errno == ERANGE)
   {
      // overflow is the only possible range error for an unsigned type.
      return CONVERT_OVERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   ul = result;
   return CONVERT_SUCCESSFUL;
}



String::ConvertResult
String::convert(double& d) const
{
   d = 0.0;

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   double result = wcstod(begptr, &endptr);
   if (errno == ERANGE)
   {
      // result is +/-HUGE_VAL on overflow, 0 on underflow.

      return result ? CONVERT_OVERFLOW : CONVERT_UNDERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   d = result;
   return CONVERT_SUCCESSFUL;
}

#define MAX_DECIMAL_STRING_LENGTH_FOR_LARGE_INTEGER 20

String::ConvertResult
String::convert(LARGE_INTEGER& li) const
{
   li.QuadPart = 0;

   if (size() > MAX_DECIMAL_STRING_LENGTH_FOR_LARGE_INTEGER)
   {
      // string is too long
      return CONVERT_OVERFLOW;
   }

   String::const_pointer begptr = c_str();
   String::const_pointer endptr = begptr;
   errno = 0;

	BOOL bNeg = FALSE;
	if (*endptr == L'-')
	{
		bNeg = TRUE;
		endptr++;
	}
	while (*endptr != L'\0')
	{
		li.QuadPart = 10 * li.QuadPart + (*endptr-L'0');
		endptr++;
	}
	if (bNeg)
	{
		li.QuadPart *= -1;
	}

   if (begptr == endptr)
   {
      // no valid characters found
      li.QuadPart = 0;
      return CONVERT_BAD_INPUT;
   }

   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         li.QuadPart = 0;
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      li.QuadPart = 0;
      return CONVERT_FAILED;
   }
   
   return CONVERT_SUCCESSFUL;
}

bool
String::is_numeric() const
{
   if (empty())
   {
      return false;
   }

   size_t len = length();
   WORD* charTypeInfo = new WORD[len];
   memset(charTypeInfo, 0, sizeof(WORD) * len);

   bool result = false;

   do
   {
      BOOL success =
         ::GetStringTypeEx(
            LOCALE_USER_DEFAULT,
            CT_CTYPE1,
            c_str(),
            static_cast<int>(length()),
            charTypeInfo);

      ASSERT(success);

      if (!success)
      {
         break;
      }

      // look thru the type info array, ensure that all chars are digits.

      bool nonDigitFound = false;
      for (size_t i = 0; i < len; ++i)
      {
         // We only consider decimal digits, not C2_EUROPENUMBER and
         // C2_ARABICNUMBER.  I wonder if that is correct?

         if (!(charTypeInfo[i] & C1_DIGIT))
         {
            nonDigitFound = true;
            break;
         }
      }

      // a string is numeric if no non-digit characters are found.

      result = !nonDigitFound;
   }
   while (0);

   delete[] charTypeInfo;
   charTypeInfo = 0;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\heapretl.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)
//
// This file is #include'd from mem.cpp
// DO NOT include in the sources file list
//
// this is the retail version:



#ifdef DBG
   #error This file must NOT be compiled with the DBG symbol defined
#endif



//
// Retail build only
//



void
Burnslib::Heap::Initialize()
{
   // we do not make available instrumented heap in retail builds, so there
   // is nothing to do here.
}



void*
Burnslib::Heap::OperatorNew(
   size_t      size,
   const char* /* file */ ,
   int         /* line */ )
throw (std::bad_alloc)
{
   void* ptr = 0;

   for (;;)
   {
      // NOTE: if some other user of the CRT has used _set_new_mode or
      // _CrtSetAllocHook, then they may circumvent our careful arrangement
      // and hose us.  The really sad part is that the only way to prevent
      // that problem is for us to not use any CRT heap functions.

      ptr = malloc(size);

      if (ptr)
      {
         break;
      }

      // the allocation failed.  Give the user the opportunity to try to
      // free some, or throw an exception.

      if (DoLowMemoryDialog() == IDRETRY)
      {
         continue;
      }

      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"  Burnslib::Heap::OperatorNew: user opted to throw bad_alloc\n");

      throw nomem;
   }

   return ptr;
}



void
Burnslib::Heap::OperatorDelete(void* ptr)
throw ()
{
   free(ptr);
}



void
Burnslib::Heap::DumpMemoryLeaks()
{
   // does nothing in the retail (free) build.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-assert.cpp ===
// test Burnslib ASSERT macro



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
f3()
{
   LOG_FUNCTION(f3);

   LOG_LAST_WINERROR();

   {
      LOG_SCOPE(L"nested scope");
   }

   class Foo
   {
      public:

      Foo()
      {
         LOG_CTOR(Foo);
      }

      ~Foo()
      {
         LOG_DTOR(Foo);
      }

      void
      Method()
      {
         LOG_FUNCTION(Foo::Method);

         ASSERT(false);
      }
   };

   Foo afoo;
   afoo.Method();
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the games begin");

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-heap.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



// set the HeapFlags to trace allocations to see the leak detection

void
f3()
{
   LOG_FUNCTION(f3);

   int* leak4 = new int[2];
   leak4[0] = 1;
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   String* leak3 = new String;
   *leak3 = L"jello";

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   char* leak1 = new char[100];
   leak1[0] = 'S';

   f2();

   char* leak2 = new char[45];
   leak2[0] = 'B';
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the leaks begin");

   f1();

   wchar_t* leak5 = new wchar_t;
   *leak5 = L'X';

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-string.cpp ===
// Test string class

#include "headers.hxx"
#include <containers.hpp>
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   String s(L"a list of tokens all in a row");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens));
   ASSERT(token_count == tokens.size());

   for (
      StringList::iterator i = tokens.begin();
      i != tokens.end();
      ++i)
   {
      AnsiString ansi;
      i->convert(ansi);
      std::cout << ansi << std::endl;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-warning.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_TYPICAL;



void
trigger4244()
{

#ifdef COMPILE_WARNINGS

   // trigger warning 4244 with assignment

   __int64 yyyy = 5678;
   int* leak6 = new int;
   *leak6 = yyyy;

   // and again with initialization

   int xxxx = yyyy;
   xxxx -= 100;

#endif

}




VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   trigger4244();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-tokenize.cpp ===
// Test String class

#include "headers.hxx"
#include <containers.hpp>
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
DumpList(const StringList& tokens)
{   
   for (
      StringList::iterator i = tokens.begin();
      i != tokens.end();
      ++i)
   {
      AnsiString ansi;
      i->convert(ansi);
      std::cout << ansi << std::endl;
   }
}



void
test1()
{
   // use default whitespace delimiter

   String s(L"a list of\ttokens \tall  in  a\t\trow");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens));
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



void
test2()
{
   // use custom delimiters, end with delimiter

   String s(L"mydomain.in-addr.arpa.");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens), L".");
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



void
test3()
{
   // use custom delimiters

   String s(L"mydomain.ipv6.int");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens), L".");
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   test1();
   test2();
   test3();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\args.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// argument parsing
// 
// 3-3-99 sburns

                           

#ifndef ARGS_HPP_INCLUDED
#define ARGS_HPP_INCLUDED



// args of the form "/argname:value" create an entry such that
// (argmap["argname"] == value) is true. '/' or '-' are treated synonymously.
// 
// args of the form "argspec" creates an entry such that
// argmap.find(arg) != argmap.end().
//
// args are case-preserving but not case sensitive, so
// argmap["myarg"], argmap["MYARG"], and argmap["MyArG"] all are equivalent.
// 
// To test for the presence of a arg in a map, use std::map::find().
//

typedef
   std::map<
      String,
      String,
      String::LessIgnoreCase,
      Burnslib::Heap::Allocator<String> >
   ArgMap;



// Populates a map of command line arguments and their values from the
// command line arguements of the currently executing program.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.
//
// The first command-line argument is the command used to start the program.
// This value is mapped to the key "_command"

void
MapCommandLineArgs(ArgMap& argmap);



// Populates a map of arguments and their values from the given
// string.
//
// args - text containing args separated by spaces/tabs.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.

void
MapArgs(const String& args, ArgMap& argmap);



// Populates a map of command line arguments and their values from the list
//
//
// args - list of Strings, where each node is an arg.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.

void
MapArgsHelper(const String& arg, ArgMap& argmap);

template <class InputIterator>
void
MapArgs(InputIterator first, const InputIterator& last, ArgMap& argmap)
{
   for (
      ;
      first != last;
      ++first)
   {
      MapArgsHelper(*first, argmap);
   }
}



#endif   // ARGS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-log.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
f3()
{
   LOG_FUNCTION(f3);

   LOG_LAST_WINERROR();

   {
      LOG_SCOPE(L"nested scope");
   }

   class Foo
   {
      public:

      Foo()
      {
         LOG_CTOR(Foo);
      }

      ~Foo()
      {
         LOG_DTOR(Foo);
      }

      void
      Method()
      {
         LOG_FUNCTION(Foo::Method);

         HRESULT hr = CO_E_RUNAS_LOGON_FAILURE;
         LOG_HRESULT(hr);
      }
   };

   Foo afoo;
   afoo.Method();
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the games begin");

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\core\test\test-stacktrace.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



// set the HeapFlags to trace allocations to see the leak detection



void
raise()
{
   // force an AV

   char* null = 0;
   *null = 'X';
}



void
DumpStack(DWORD64 stackTrace[], size_t traceMax)
{

   for (int i = 0; stackTrace[i] and (i <= traceMax); ++i)
   {
      ::OutputDebugString(
         StackTrace::LookupAddress(stackTrace[i]).c_str());
      ::OutputDebugString(L"\r\n");
   }
}



void
f3()
{
   const size_t TRACE_MAX = 10;
   DWORD64 stackTrace[TRACE_MAX];
   size_t traceMax = TRACE_MAX;

   wchar_t* leak = new wchar_t;
   *leak = L'X';

   __try
   {
      raise();
   }
   __except(
      StackTrace::TraceFilter(
         stackTrace,
         traceMax,
         (GetExceptionInformation())->ContextRecord))
   {
      DumpStack(stackTrace, traceMax);
   }
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\assert.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// ASSERT macro
//
// 3 Mar 2000 sburns


// to be #included from blcore.hpp


// Using the CRT assert or _ASSERTE turned into a hassle, as the CRT has
// it's own notions of debug building.

#undef ASSERT

#ifdef DBG

   #define ASSERT(expr)                                                   \
      { /* open scope */                                                  \
         if (!(expr))                                                     \
         {                                                                \
            if (Burnslib::FireAssertionFailure(__FILE__, __LINE__, #expr)) \
            {                                                             \
               DebugBreak();                                              \
            }                                                             \
         }                                                                \
      }  /* close scope */                                                \


#else

   #define ASSERT(expr) ((void)0)

#endif

namespace Burnslib
{

// Returns true to indicate that the user has requested to drop into
// the debugger, false to ignore the assertion failure
//
// If the user chooses to abort the app, this function will call exit(3)
// and not return.

bool
FireAssertionFailure(const char* file, int line, const char* expr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\burnslib.h ===
// Copyright (c) 1997-1999 Microsoft Corporation



#define IDC_STATIC_HELPLESS             13 
#define IDC_STATIC_HELPLESS2            14 
#define IDC_STATIC_HELPLESS3            15 
#define IDC_STATIC_HELPLESS4            16 
#define IDC_STATIC_HELPLESS5            17 
#define IDC_STATIC_HELPLESS6            18 
#define IDC_STATIC_HELPLESS7            19 
#define IDC_STATIC_HELPLESS8            20 
#define IDC_STATIC_HELPLESS9            21 
#define IDS_SYSTEM32                    202
#define IDS_HRESULT_SANS_MESSAGE        227
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\callback.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Generic callback mechanism
//
// 8-14-97 sburns



#ifndef CALLBACK_HXX_INCLUDED
#define CALLBACK_HXX_INCLUDED



// abstract base class representing a callback function.  To create
// your own callback, subclass this class.

class Callback
{
   public:

   // returns a status code that may have meaning to the invoker.
   //
   // param - a user-defined value.

   virtual
   int
   Execute(void* param) = 0;
};



#endif   // CALLBACK_HXX_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\burnslib.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// all library header files
//
// 12-12-97 sburns



#ifndef BURNSLIB_HPP_INCLUDED
#define BURNSLIB_HPP_INCLUDED


#if !defined(__cplusplus)
   #error This module must be compiled as C++
#endif
#if !defined(UNICODE)
   #error This module must be compiled UNICODE. (add -DUNICODE to C_DEFINES in sources file)
#endif



#include "blcore.hpp"

#include "EncodedString.hpp"
#include "containers.hpp"
#include "error.hpp"
#include "win.hpp"
#include "callback.hpp"
#include "filesys.hpp"
#include "extract.hpp"
#include "computer.hpp"
#include "dialog.hpp"
#include "proppage.hpp"
#include "wizpage.hpp"
#include "wizard.hpp"
#include "dns.hpp"
#include "registry.hpp"
#include "bits.hpp"
#include "popup.hpp"
#include "safedll.hpp"
#include "service.hpp"
#include "args.hpp"
#include "dsutil.hpp"
#include "netutil.hpp"
#include "dllref.hpp"
#include "tempfact.hpp"
#include "utility.hpp"
#include "burnslib.h"



// Your DllMain or WinMain must initialize this data to the name of the
// helpfile containing context help (help the popup up in response to right
// clicking a control, or pressing F1) for classes derived from Dialog.
// 
// The path is relative to the System Windows Directory, so you will
// typically need to include the help subdirectory.
// 
// e.g. HELPFILE_NAME = L"\\help\\myhelp.hlp";

extern const wchar_t* HELPFILE_NAME;



#endif   // BURNSLIB_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\blcore.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// core library header files
//
// 30 Nov 1999 sburns



#ifndef BLCORE_HPP_INCLUDED
#define BLCORE_HPP_INCLUDED



#if !defined(__cplusplus)
   #error This module must be compiled as C++
#endif
#if !defined(UNICODE)
   #error This module must be compiled UNICODE. (add -DUNICODE to C_DEFINES in sources file)
#endif



// Include system headers before the burnslib headers.  This is necessary
// because the burnslib headers redefine things like operator new, which may
// appear in system headers.  We don't want to change the behavior of code
// outside this library (and users of this library).

#ifdef BURNSLIB_HPP_INCLUDED

   // This file is being included as part of burnslib.hpp, so include the
   // full set of system headers

   #include "sysfull.hpp"
#else 

   #include "syscore.hpp"
#endif



#include "PragmaWarning.hpp"



// include Assert.hpp after syscore.hpp, as it redefines ASSERT()

#include "Assert.hpp"



namespace Burnslib
{
   // For an explanation of the initialization guard thing, see Meyers,
   // Scott. "Effective C++ pp. 178-182  Addison-Wesley 1992.  Basically, it
   // guarantees that this library is properly initialized before any code
   // that uses it is called.

   class InitializationGuard
   {
      public:

      InitializationGuard();
      ~InitializationGuard();

      private:

      static unsigned counter;

      // not defined

      InitializationGuard(const InitializationGuard&);
      const InitializationGuard& operator=(const InitializationGuard&);
   };
}



//lint -e(1502) ok that InitializationGuard has no members: we use it for
// the side effects of static initialization calling the ctor

static Burnslib::InitializationGuard guard;



// we put mem.hpp at the top of our header list, as it redefines new.  If
// any project header includes code that calls new, that code will see the
// redefinition.  For the same reason, we #include mem.hpp after all the
// system headers, as we are uninterested in calls to new that they might
// make.

#include "mem.hpp"
#include "string.hpp"
#include "stacktr.hpp"
#include "log.hpp"
#include "smartptr.hpp"
#include "comstuff.hpp"
#include "coreutil.hpp"
#include "coreres.h"



using namespace Burnslib;



// this is defined in init.cpp

extern const wchar_t* REG_ADMIN_RUNTIME_OPTIONS;



//
// Things you must define in your code:
//



// CODEWORK Putting these externs in a namespace seems to confuse the
// linker.

// namespace Burnslib
// {


// your DllMain or WinMain must set this to the HINSTANCE of the module
// containing all string and other resources.  Without this, no function that
// loads a resource will operate correctly.

extern HINSTANCE hResourceModuleHandle;

// The name of the log file where LOG output is sent.  This file is
// placed in the %systemroot%\debug directory.  The extension will be ".log"

extern const wchar_t* RUNTIME_NAME;

// The default debugging control options to be used, unless overriden in the
// registry DWORD value LogFlags under the key
// HKLM\Software\Microsoft\Windows\CurrentVersion\AdminDebug\\ + RUNTIME_NAME.
// The LOWORD is a set of flag specifing output destinations, the HIWORD is
// the debugging output options in effect.

extern DWORD DEFAULT_LOGGING_OPTIONS;


// }; // namespace Burnslib



#endif   // BLCORE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\bits.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// bit twiddling stuff
// 
// 8-5-98 sburns



// One would think that after n decades of C, these would be builtin
// keywords...



// Returns state of bit n: true if it is set, false if not
//
// bits - set of bits
//
// n - bit to test

inline
bool
getbit(ULONG bits, unsigned int n)
{
   if (bits & (1 << n))
   {
      return true;
   }

   return false;
}


// flips bit n (sets it to the opposite state), returns new state of bit n
//
// bits - set of bits.
//
// n - bit to flip

inline
bool
flipbit(ULONG& bits, unsigned int n)
{
   return getbit((bits ^= (1 << n)), n);
}


// sets bit n to 1
//
// bits - set of bits
//
// n - bit to set

inline
void
setbit(ULONG& bits, unsigned int n)
{
   bits |= (1 << n);
}



// sets bit n to 0
//
// bits - set of bits
//
// n - bit to clear

inline
void
clearbit(ULONG& bits, unsigned int n)
{
   ULONG mask = (1 << n);
   bits &= ~mask;
}



// Sets all bits in mask.  Returns result
//
// bits - holds bits to be set
// 
// mask - mask of bits to set

inline
DWORD 
setbits(ULONG& bits, ULONG mask)
{
   ASSERT(mask);

   bits |= mask;
   return bits;
}



// Clears all bits in mask.  Returns result.
//
// bits - holds bits to be cleared
// 
// mask - mask of bits to clear

inline
DWORD
clearbits(ULONG& bits, ULONG mask)
{
   ASSERT(mask);

   bits &= ~mask;
   return bits;
}



// Toggles all bits in mask.  bits that were set are cleared, and vice-
// versa.  Returns result.
//
// bits - holds bits to be toggled
// 
// mask - mask of bits to toggled

inline
DWORD
flipbits(ULONG& bits, ULONG mask)
{
   bits ^= mask;
   return bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\containers.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// common container classes
//
// 13 Jan 2000 sburns



#ifndef CONTAINERS_HPP_INCLUDED
#define CONTAINERS_HPP_INCLUDED



namespace Burnslib
{

typedef
   std::list<String, Burnslib::Heap::Allocator<String> >
   StringList;

typedef
   std::vector<String, Burnslib::Heap::Allocator<String> >
   StringVector;

}  // namespace Burnslib


#endif   // CONTAINERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\coreres.h ===
// Copyright (c) 1997-1999 Microsoft Corporation

#define IDS_UNKNOWN_ERROR_CODE          224
#define IDS_LOW_MEMORY_MESSAGE          225
#define IDS_LOW_MEMORY_TITLE            226
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\controlsubclasser.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// windows control subclassing wrapper
//
// 22 Nov 2000 sburns



#ifndef CONTROLSUBCLASSER_HPP_INCLUDED
#define CONTROLSUBCLASSER_HPP_INCLUDED



// Class for hooking the window proc of a control.

class ControlSubclasser
{
   protected:

   ControlSubclasser();

   // reverses the subclassing by calling UnhookWindowProc.
   
   virtual   
   ~ControlSubclasser();



   // Hooks the window proc of the supplied window so that all future messages
   // are routed to the OnMessage method.  The OnInit of the parent dialog
   // where the control resides is a good place to call this method.
   //
   // The hook requires that that the GWLP_USERDATA portion of the window
   // be overwritten with the this pointer to this instance.  If you need
   // that data, then you could derive a class from this one, and add
   // members for your extra data.
   //
   // Your overrided Init method must call this base method.
   // 
   // control - in, handle to the control to be hooked.
   
   virtual
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.  The default implementation
   // calls the control's original window procedure.  When you derive a new
   // class from this one, be sure to call this base class method from your
   // derived method for any messages your derived method doesn't handle.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.

   virtual   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

      

   // the handle to the subclassed control.  Only valid after Init has
   // been called.
   
   HWND hwnd;              



   private:

   // restore the original window proc to the window

   void
   UnhookWindowProc();


   
   // a static Windows Proc that acts as a dispatcher to the non-static
   // OnMessage method.
   
   static
   LRESULT CALLBACK
   WindowProc(
      HWND   window,
      UINT   message,       
      WPARAM wParam,        
      LPARAM lParam);



   // not implemented: no copying allowed

   ControlSubclasser(const ControlSubclasser&);
   const ControlSubclasser& operator=(const ControlSubclasser&);

   WNDPROC originalWindowProc;
};



#endif   // CONTROLSUBCLASSER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\comstuff.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// COM utility code
//
// 2-3-99 sburns



#ifndef COMSTUFF_HPP_INCLUDED
#define COMSTUFF_HPP_INCLUDED



// Ensures that the type of the pointer to receive the interface pointer
// matches the IID of the interface.  If it doesn't, the static_cast will
// cause a compiler error.
// 
// Example:
// IFoo* fooptr = 0;
// HRESULT hr = punk->QueryInterface(QI_PARAMS(IFoo, &fooptr));
// 
// From Box, D. Essential COM.  pp 60-61.  Addison-Wesley. ISBN 0-201-63446-5

#define QI_PARAMS(Interface, ppvExpression)  \
   IID_##Interface, reinterpret_cast<void**>(static_cast<Interface**>(ppvExpression))




namespace Burnslib
{



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit
   AutoBstr(const String& s)
      :
      bstr(::SysAllocString(const_cast<wchar_t*>(s.c_str())))
   {
   }
         
   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
      ASSERT(s);
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};



}  // namespace Burnslib



#endif   // COMSTUFF_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\computer.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Computer naming tool
//
// 12-1-97 sburns



#ifndef COMPUTER_HPP_INCLUDED
#define COMPUTER_HPP_INCLUDED



// An object representing the name, domain membership state, and other
// interesting properties of a machine.

class Computer
{
   public:



   // Constructs a new instance.  The new instance is not usable until the
   // Refresh method is called.
   // 
   // name - name of the computer.  May have leading backslashes.  May be
   // an IP address, DNS, or NetBIOS computer name.  empty means the local
   // computer.

   explicit
   Computer(const String& name = String());

   ~Computer();



   // Returns the NetBIOS name of the computer.

   String
   GetNetbiosName() const;



   // Returns the Fully-Qualified DNS name of the computer, taking into
   // account the policy-imposed DNS suffix (if any).  Returns the empty
   // string if the computer does not have a DNS name (most likely because
   // TCP/IP is not installed or properly configured on the machine).

   String
   GetFullDnsName() const;



   // Returns the DNS name of the domain the computer is joined to, or the
   // empty string if the computer is not joined to a DS domain.

   String
   GetDomainDnsName() const;



   // Returns the NetBIOS name of the domain the computer is joined to, if
   // the computer is joined to a domain, or the NetBIOS name of the
   // workgroup the computer is joined to, if the computer is joined to a
   // workgroup.  See IsJoinedToDomain(), IsJoinedToWorkgroup().

   String
   GetDomainNetbiosName() const;



   // Returns the name of the forest the machine is joined to, or the empty
   // string if the machine is not joined to a DS domain.
   // 
   // (The forest name is the dns domain name of the first domain in the
   // forest.)

   String
   GetForestDnsName() const;



   // Returns the major version number of the operating system the machine is
   // running.  For Windows NT 4, this is 4.  For Windows 2000, this is 5.

   DWORD
   GetOsMajorVersion() const;



   // Returns the minor version number of the operating system the machine is
   // running.

   DWORD
   GetOsMinorVersion() const;



   enum Role
   {
      STANDALONE_WORKSTATION = DsRole_RoleStandaloneWorkstation,  
      MEMBER_WORKSTATION     = DsRole_RoleMemberWorkstation,      
      STANDALONE_SERVER      = DsRole_RoleStandaloneServer,       
      MEMBER_SERVER          = DsRole_RoleMemberServer,           
      PRIMARY_CONTROLLER     = DsRole_RolePrimaryDomainController,
      BACKUP_CONTROLLER      = DsRole_RoleBackupDomainController  
   };

   // Returns a value indicating the role of the computer.  This value is
   // always the "true" role of the computer, regardless of the safe boot
   // mode of the computer.

   Role
   GetRole() const;



   // Returns true if the machine is a domain controller, false if not.

   bool
   IsDomainController() const;



   // Returns true if the instance refers to the local computer, false if
   // it refers to another computer on the network.  "Local Computer" means
   // the computer on which this process is running.

   bool
   IsLocal() const;



   // Returns true if the machine is joined to any domain, false if not.
   // (Note that IsJoinedToWorgroup == !IsJoinedToDomain, and vice-versa).

   bool
   IsJoinedToDomain() const;



   // Returns true if the machine is joined to the given DS domain, false if
   // not -- the machine is joined to a non-DS domain, not joined to a domain,
   // or joined to a DS domain of another name.
   //
   // domainDnsName - DNS name of the domain to test membership against.

   bool
   IsJoinedToDomain(const String& domainDnsName) const;



   // Returns true if the machine is joined to any workgroup, false if not.
   // (Note that IsJoinedToWorgroup == !IsJoinedToDomain, and vice-versa).
   //
   // If this function returns true, then the name returned by
   // GetDomainNetbiosName is actually the name of the workgroup.

   bool
   IsJoinedToWorkgroup() const;



   // Re-evaluates all computer info.  Returns S_OK if all info was refreshed,
   // or a standard error code if not.  Typical errors include access denied
   // and network path not found.

   HRESULT
   Refresh();



   //
   // static functions
   //



   // Combines the hostname and suffix to form a fully-qualified DNS computer
   // name, and returns that result.  E.g. hostname.dns.domain.suffix.com
   //    
   // hostname - the hostname component of the name.  This string should not
   // be empty.
   //    
   // domainSuffix - the DNS domain suffix portion of the name.  This portion
   // may be empty, in which case the hostname is considered to be in the root
   // domain ".".  Or the suffix may be a single "." to indicate the root
   // domain.  Or the suffix may be a more typical sequence of labels
   // separated by "."

   static
   String
   ComposeFullDnsComputerName(
      const String& hostname,
      const String& domainSuffix);



   // Retreives the netbios computer name that is currently in effect.
   
   static
   String
   GetActivePhysicalNetbiosName();


   
   // Retreives the fully-qualified DNS computer name that is currently in
   // effect.  May return the empty string if no DNS name exists (e.g. tcp/ip
   // is not installed).

   static
   String
   GetActivePhysicalFullDnsName();



   // Retreives the netbios computer name that will take effect upon next
   // reboot, or the current active name if no name change is pending.

   static 
   String
   GetFuturePhysicalNetbiosName();

   
   // Retreives the fully-qualified DNS computer name that will be in effect
   // when the computer is rebooted.  If a future name is not set, then the
   // result is the current active name (as that will still be the name in the
   // future).  Can return the empty string if the active name is not set
   // either (e.g. tcp/ip is not installed)
   
   static 
   String
   GetFuturePhysicalFullDnsName();


   // Determine the safeboot option that the machine is currently running
   // under, or return 0 if the machine is running in normal boot mode.
   // Returns S_OK on success, or an error code on failure.
   // 
   // regHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of a
   // remote computer, or the special HKEY value of HKEY_LOCAL_MACHINE to
   // evaluate the result for the local computer.
   // 
   // result - the safeboot option.  See sdk\inc\safeboot.h for the possible
   // values.

   static
   HRESULT
   GetSafebootOption(HKEY regHKLM, DWORD& result);



   // Returns the product type like RtlGetNtProductType, except that the value
   // is read directly from the registry.  This is preferred to
   // RtlGetNtProductType, because when booted in safe mode,
   // RtlGetNtProductType is caused to lie such that a DC returns a result as
   // though it were a normal server.   Returns S_OK on success, or an error
   // code on failure.
   //
   // regHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of a
   // remote computer, or the special HKEY value of HKEY_LOCAL_MACHINE to
   // evaluate the result for the local computer.
   //
   // result - the product type code.

   static
   HRESULT
   GetProductTypeFromRegistry(HKEY regHLKM, NT_PRODUCT_TYPE& result);



   // Determine if the Dns suffix portion of the local computer name is forced
   // to be a certain value by policy.  If so, return true.  If the
   // determination cannot be made, or if the policy is not in effect, return
   // false.
   // 
   // policyDnsSuffix - out, if there is a policy in effect, this parameter
   // will receive the suffix (which may be the empty string).

   static
   bool
   IsDnsSuffixPolicyInEffect(String& policyDnsSuffix);


   
   // Removes the leading backslashes from a UNC-style computer name, if
   // present, and returns the result.  For example, a name "\\mycomputer"
   // would be returned as "mycomputer".
   // 
   // computerName - the name from which leading backslashes are to be
   // removed. If this name does not have leading backslashes, then this name
   // is returned.

   static 
   String
   RemoveLeadingBackslashes(const String& computerName);



   private:



   // not implemented

   Computer(const Computer& c);
   const Computer& operator=(const Computer& c);

   friend struct ComputerState;

   String         ctorName;   
   bool           isRefreshed;
   ComputerState* state;      
};













#endif   // COMPUTER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\coreutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// core utility functions
//
// 30 Nov 1999 sburns

                           

#ifndef COREUTIL_HPP_INCLUDED
#define COREUTIL_HPP_INCLUDED



#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



#define BREAK_ON_FAILED_HRESULT2(hr,msg)                          \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG(msg)                                                    \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



namespace Burnslib
{



// Loads various message dlls in an an attempt to resolve the HRESULT into
// an error message.  Returns a "unknown error" string on failure.

String
GetErrorMessage(HRESULT hr);



// Returns the HINSTANCE of the DLL designated to contain all resources. 
//
// This function requires that the first module loaded (whether it be a DLL or
// EXE) set the global variable hResourceModuleHandle to the HINSTANCE of the
// module (DLL or EXE) that contains all of the program's binary resources.
// This should be done as early as possible in the module's startup code.

HINSTANCE
GetResourceModuleHandle();



// a safe version of HRESULT_FROM_WIN32 that doesn't repeatedly evaluate
// it's arguement.  The problem with using the macro directly is that the
// argument -- the win32 error to convert -- will be evaluated more than
// once.  So, if you use an expression as the argument, at best you get
// an inefficiency, at worst you get unexpected side effects.

inline 
HRESULT
Win32ToHresult(DWORD win32Error)
{
   ASSERT(win32Error < 0xFFFF);

   return HRESULT_FROM_WIN32(win32Error);
}



// unsigned version

inline 
HRESULT
Win32ToHresult(LONG win32Error)
{
   ASSERT(win32Error < 0xFFFF);
      
   return HRESULT_FROM_WIN32(win32Error);
}



inline
HRESULT
NtStatusToHRESULT(NTSTATUS status)
{
   return Win32ToHresult(::RtlNtStatusToDosError(status));
}



}  // namespace Burnslib



#endif   // COREUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\diagnosedcnotfound.h ===
// Copyright (C) 2000 Microsoft Corporation
//
// resources to be included in programs that use ShowDcNotFoundErrorDialog
//
// 9 October 2000 sburns


#define IDS_NO_ADDRESSES                     3201
#define IDS_ROOT_ZONE                        3202
#define IDS_DC_NOT_FOUND_DIAG_ERROR_CODE     3203
#define IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE 3204
#define IDI_BIGX                             3205
#define IDS_DC_NOT_FOUND_TIMEOUT             3206
#define IDC_DETAILS_BUTTON                   3207
#define IDC_DETAILS_TEXT                     3208
#define IDD_DC_NOT_FOUND                     3209
#define IDS_SHOW_DETAILS_LABEL               3210
#define IDS_GENERIC_DC_NOT_FOUND_PARAM       3211
#define IDC_ERROR_MESSAGE                    3212
#define IDS_DC_NOT_FOUND_DIAG_NO_RESULTS     3213
#define IDS_DC_NOT_FOUND_NETBIOS_PREFACE     3214
#define IDS_DC_NOT_FOUND_NAME_ERROR          3215
#define IDS_DC_NOT_FOUND_NO_RESULTS          3216   
#define IDS_DC_NOT_FOUND_NO_ERROR_1          3217
#define IDS_DC_NOT_FOUND_NO_ERROR_2          3218
#define IDS_DC_NOT_FOUND_DEFAULT             3219
#define IDS_HIDE_DETAILS_LABEL               3220
#define IDC_HORIZONTAL_LINE                  3221
#define IDS_DC_NOT_FOUND_TITLE               3222
#define IDS_DC_NOT_FOUND_SOOTHING_PREFACE_PARAM 3223
#define IDS_DC_NOT_FOUND_SOOTHING_PREFACE 3224
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\diagnosedcnotfound.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// diagnose domain controller not found problems, offer a popup dialog to
// assail the user with the results.
//
// 9 October 2000 sburns



#ifndef DIAGNOSEDCNOTFOUND_HPP_INCLUDED
#define DIAGNOSEDCNOTFOUND_HPP_INCLUDED




// Bring up a modal error message dialog that shows the user an error message
// and offers to run some diagostic tests and point the user at some help to
// try to resolve the problem.
// 
// parent - in, the handle to the parent of this dialog.
// 
// editResId - in, the resource id of the edit box that contains the domain
// name.  If -1 is passed, then this parameter is ignored.  Otherwise, when
// the dialog is closed, window messages will be sent to the control such that
// the contents will be selected.  It is assumed the control is a child of the
// window identified by the parent parameter.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  This name may be a DNS or netbios domain name.
// 
// dialogTitle - in, the title of the error dialog.
// 
// errorMessage - in, the error message to be displayed in the dialog
// 
// domainNameIsNotNetbios - in, if the caller knows that the domain named in
// the domainName parameter can't possibly be a netbios domain name, then this
// value should be true.  If the caller is not sure, then false should be
// passed.
//
// userIsDomainSavvy - in, true if the end user is expected to be an
// administrator or somesuch that might have an inkling what DNS is and how to
// configure it.  If false, then the function will preface the diagnostic text
// with calming words that hopefully prevent the non-administrator from
// weeping.

void
ShowDcNotFoundErrorDialog(
   HWND          parent,
   int           editResId,
   const String& domainName,
   const String& dialogTitle,
   const String& errorMessage,
   bool          domainNameIsNotNetbios,
   bool          userIsDomainSavvy = true);

  

#endif   // DIAGNOSEDCNOTFOUND_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\dialog.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Dialog class
// 
// 10-15-97 sburns



#ifndef DIALOG_HPP_INCLUDED
#define DIALOG_HPP_INCLUDED



// Wraps a Windows dialog box, cracks and demuxes the dialog messages, and
// provides a mechanism for tracking the control IDs that have been touched
// over a given period.  Also provides what-is help.
//
// May only be used as a base class.

class Dialog
{
   public:

   // can't use an enum 'cause the type needs to be DWORD
   #define NO_HELP (static_cast<DWORD>(-1))
      
   // Executes the dialog modally via the Win DialogBox API.  Blocks until the
   // Win EndDialog API is called; returns the value passed to EndDialog.
   // Derived classes must call EndDialog in their message processing to
   // terminate the execution of the dialog.
   //
   // parent - handle to the parent window, which will be disabled during
   // the execution of the dialog.

   INT_PTR
   ModalExecute(HWND parent);

   INT_PTR
   ModalExecute(const Dialog& parent);

   // Executes the dialog box modelessly, returning immediately.  Derived
   // classes should call EndModelessExecution to close a Dialog executing
   // modelessly, or, destroy the Dialog instance.
   // 
   // Example:
   // 
   // MyFooDialog* dlg = new MyFooDialog(....);
   // dlg->ModlessExecute();
   // 
   // // ... later
   // 
   // dlg->EndModelessExecution();
   // 
   // // or just:
   // 
   // delete dlg;
   // 
   // parent - handle to the parent window of this dialog, for establishing
   // z-order.

   void
   ModelessExecute(HWND parent);

   void
   ModelessExecute(const Dialog& parent);

   // Terminates the modeless execution of a dialog that has been started
   // with ModalExecute.  It is illegal to call this method before calling
   // ModalExecute.

   void
   EndModelessExecution();

   // Returns the window handle of the dialog.  This method is only valid
   // after the window has been created and initialized by receiving
   // WM_INITDIALOG (which will be the case before any virtual message
   // handling functions are invoked).

   HWND
   GetHWND() const;

   // Returns the resource ID with which this instance was created.

   unsigned
   GetResID() const;

   // Returns a pointer to the Dialog instance that has been previously
   // stashed in the DWL_USER portion of the window structure.  This method is
   // only valid after the window has been created and initialized by
   // receiving WM_INITDIALOG (which will be the case before any virtual
   // message handling functions are invoked).
   // 
   // dialog - handle to initialized dialog window.

   static
   Dialog*
   GetInstance(HWND dialog);

   protected:

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // resID - resource identifier of the dialog template resource.
   // 
   // helpMap - array mapping dialog control IDs to context help IDs.  The
   // array must be in the following form:
   // {
   //    controlID1, helpID1,
   //    controlID2, helpID2,
   //    controlIDn, helpIDn,
   //    0, 0
   // }
   // 
   // To indicate that a control does not have help, the value of its
   // corresponding help ID should be NO_HELP.  This array is copied
   // by the constructor.

   Dialog(
      unsigned    resID,
      const DWORD helpMap[]);

   // Destroys an instance.  If the ModelessExecute method has been called,
   // and the EndModlessExecution method has not yet been called,
   // EndModelessExecution is called.

   virtual ~Dialog();

   // Resets the control ID change map.

   void
   ClearChanges();

   // Marks a control ID as changed.  Derived classes should call this from
   // their processing of OnCommand or OnNotify as appropriate to indicate
   // that a control has changed state.  This is useful for keeping track of
   // the fields in a database that need to be changed, etc.
   //
   // controlResID - the resource ID of the control that changed.

   void
   SetChanged(UINT_PTR controlResID);

   // Queries the control ID change map, returning true if the specified
   // control ID was previously marked as changed (with SetChanged), false
   // if not.
   //
   // controlResID - the resource ID of the control that changed.

   bool
   WasChanged(UINT_PTR controlResID) const;

   // Returns true if SetChanged was called for any control on the dialog,
   // false if not.

   bool
   WasChanged() const;

   // (For debugging) dumps the state of the control ID change map using
   // OutputDebugString.  For non-debug builds, a no-op.

   void
   DumpChangeMap() const;

   // Invoked upon receipt of WM_DESTROY.  The default implementation does
   // nothing.

   virtual
   void
   OnDestroy();

   // Invoked upon receipt of WM_COMMAND.  Derived class' implementation
   // should return true they handle the message, false if not.  The default
   // implementation returns false.
   //
   // windowFrom - the HWND of the child window (control) that originated the
   // message.
   // 
   // controlIDFrom - The resource ID of the child window corresponding to the
   // window indicated in the windowFrom parameter.   
   // 
   // code - the notification code.

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   // Invoked upon receipt of WM_INITDIALOG, after having set things up such
   // that GetHWND and GetInstance will work correctly.  The default
   // implementation does nothing.

   virtual
   void
   OnInit();

   // Invoked upon receipt of any window message that is not dispatched to
   // other member functions of this class, including user-defined messages.
   // Derived class' implementation should return true they handle the
   // message, false if not.  The default implementation returns false.
   // 
   // message - the message code passed to the dialog window.
   // 
   // wparam - the WPARAM parameter accompanying the message.
   // 
   // lparam - the LPARAM parameter accompanying the message.
   
   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // Invoked upon receipt of WM_NOTIFY.  Derived class' implementation should
   // return true they handle the message, false if not.  The default
   // implementation returns false.
   //
   // windowFrom - the HWND of the child window (control) that originated the
   // message.
   // 
   // controlIDFrom - The resource ID of the child window corresponding to the
   // window indicated in the windowFrom parameter.   
   // 
   // code - the notification code.
   //
   // lparam - the LPARAM parameter of the WM_NOTIFY message, which may,
   // depending on the window that originated the message, be a pointer to a
   // structure indicating other parameters to the notification.

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   // Stores the window handle of the dialog in this instance, so that it can
   // be later retrieved by GetHWND.  This is typically called by derived
   // classes that are doing their own processing of WM_INITDIALOG.  This
   // function may be legally called only once in the lifetime of any Dialog
   // instance.
   // 
   // window - handle to the dialog window.

   void
   SetHWND(HWND window);

   // The window handle of corresponding to this instance.  Only valid after
   // WM_INITDIALOG has been received.

   HWND hwnd;

   // accessible to PropertyPage, etc.

   static
   INT_PTR CALLBACK
   dialogProc(HWND dialog, UINT message, WPARAM wparam, LPARAM lparam);

   private:

   // not implemented: no copying allowed
   Dialog(const Dialog&);
   const Dialog& operator=(const Dialog&);

   typedef
      std::map<
         UINT_PTR,
         bool,
         std::less<UINT_PTR>,
         Burnslib::Heap::Allocator<bool> >
      ChangeMap;

   // 'mutable' required for non-const map<>::operator[].  
   mutable ChangeMap changemap;
   DWORD*            helpMap;
   bool              isEnded;
   bool              isModeless;
   unsigned          resID;
};



#endif   // DIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\dns.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DNS API wrappers
//
// 12-16-97 sburns



#ifndef DNS_HPP_INCLUDED
#define DNS_HPP_INCLUDED



// A collection of DNS related names.

namespace Dns
{
   // the number of bytes in a full DNS name to reserve for stuff
   // netlogon pre-/appends to DNS names when registering them

   const size_t SRV_RECORD_RESERVE = 100;



   // the max lengths, in bytes, of strings when represented in the UTF-8
   // character set.  These are the limits we expose to the user

   const size_t MAX_NAME_LENGTH = DNS_MAX_NAME_LENGTH - SRV_RECORD_RESERVE;
   const size_t MAX_LABEL_LENGTH = DNS_MAX_LABEL_LENGTH;



   // Compares DNS names with DnsNameCompareEx (see private\inc\dnsapi.h),
   // returning the result.

   DNS_NAME_COMPARE_STATUS
   CompareNames(const String& dnsNameLeft, const String& dnsNameRight);



   // Returns the name of the parent DNS domain.  E.g. if "foo.bar.com" is
   // passed, then "bar.com" is the result.  If "com" is passed, then "."
   // (the root zone) is the result.
   //
   // domainName - the name of the domain
   
   String
   GetParentDomainName(const String& domainName);

   

   // Returns corresponding NetBIOS name, or empty string if mapping failed.
   // Not for domain names -- just computer names!
   // 
   // hostname - the name to be mapped to a NetBIOS name.  This name must be a
   // valid DNS name.
   //
   // err - ptr to a variable that will accept the win error code returned if
   // the conversion fails.  If the conversion fails, the return value is
   // the empty string.

   String
   HostnameToNetbiosName(const String& hostname, HRESULT* err=0);



   // returns true if the DNS client is configured, false if not.

   bool
   IsClientConfigured();



   // returns true if the Microsoft DNS server is installed on this computer,
   // false if not.

   bool
   IsServiceInstalled();



   // returns true if the Microsoft DNS server is currently running on this
   // computer, false if not.

   bool
   IsServiceRunning();



   enum ValidateResult
   {
      VALID,
      INVALID,
      NON_RFC,
      TOO_LONG,
      NUMERIC,
      BAD_CHARS
   };

   // Validates a single DNS label for proper length (in the UTF-8
   // character set) and syntax.
   //
   // candidateDNSLabel - the label to be validated

   ValidateResult
   ValidateDnsLabelSyntax(const String& candidateDNSLabel);



   // Validates the format, not the existence, of a DNS name.  Checks for
   // proper length in the UTF-8 character set, and proper syntax.
   //
   // candidateDNSName - in, the DNS name to verify.
   //
   // maxUnicodeCharacters - in, maximum number of uncode characters to
   // allow in the name.  If the name contains more characters than this,
   // TOO_LONG is returned.
   //
   // maxUTF8Bytes - in, maximum number of bytes allowed to represent the name
   // in the UTF-8 character set.  Since a unicode character requires at
   // least one byte in UTF-8, this value must be >= maxUnicodeCharacters.

   ValidateResult
   ValidateDnsNameSyntax(
      const String&  candidateDNSName,
      size_t         maxUnicodeCharacters = Dns::MAX_NAME_LENGTH,
      size_t         maxUTF8Bytes = Dns::MAX_NAME_LENGTH);
}



DNS_STATUS
MyDnsValidateName(const String& name, DNS_NAME_FORMAT format);



String
MyDnsStatusString(DNS_STATUS status);



// caller must free the result with MyDnsRecordListFree

DNS_STATUS
MyDnsQuery(
   const String& name,
   WORD          type,
   DWORD         options,
   DNS_RECORD*&  result);



void
MyDnsRecordListFree(DNS_RECORD* rl);


#endif   // DNS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\dsutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS utility functions
//
// 3-11-99 sburns



#ifndef DSUTIL_HPP_INCLUDED
#define DSUTIL_HPP_INCLUDED



// Returns true if the dcpromo wizard UI is running on the local machine,
// false if not.

bool
IsDcpromoRunning();



// Returns true if a domain controller for the domain can be contacted, false
// if not.

bool
IsDomainReachable(const String& domainName);



// Returns true if the directory service is running on this computer, false
// if not.

bool
IsDSRunning();



// Caller must unbind the handle with DsUnbind

HRESULT
MyDsBind(const String& dcName, const String& dnsDomain, HANDLE& hds);



// username may be empty, which means use null, default credentials

HRESULT
MyDsBindWithCred(
   const String&  dcName,
   const String&  dnsDomain,
   const String&  username,
   const String&  userDomain,
   const String&  password,
   HANDLE&        hds);



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcName(
   const TCHAR*               machine,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info);



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcNameWithAccount(
   const TCHAR*               machine,
   const String&              accountName,
   ULONG                      allowedAccountFlags,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info);



// Caller needs to delete info with (My)DsFreeDomainControllerInfo

HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W*&   info);



// Caller needs to delete info with (My)DsFreeDomainControllerInfo

HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W*&   info);



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W* info);



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W* info);


// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info);



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_OPERATION_STATE_INFO*& info);



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_UPGRADE_STATUS_INFO*&  info);



#endif   // DSUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\dllref.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// DLL object instance and server lock utility class
// 
// 8-19-97 sburns
// concept stolen from DavidMun, who stole it from RaviR, who ...



#ifndef __DLLREF_HPP_INCLUDED
#define __DLLREF_HPP_INCLUDED



// Maintains a instance counter and lock counter, with methods to manipulate
// both in a thread-safe fashion.   This is useful in implementing
// DllCanUnloadNow.
// 
// Each class that is instanciated and passed outside of the control of the
// DLL should contain an instance of ComServerReference.  This will automatically
// increment and decrement the ComServerLockState instance counter in step with the
// instance's lifetime.  Typically, this includes all class factory instances,
// and instances of classes that are created by those class factories.
// 
// Calls to a class factory's LockServer method should be deferred to
// this class.
// 
// Calls to DllCanUnloadNow should defer to this class' CanUnloadNow method.

class ComServerLockState
{
   public:

   static
   void
   IncrementInstanceCounter()
   {
      ::InterlockedIncrement(&instanceCount);
   }

   static
   void
   DecrementInstanceCounter()
   {
      ::InterlockedDecrement(&instanceCount);
   }

   static
   void
   LockServer(bool lock)
   {
      lock
      ? ::InterlockedIncrement(&lockCount)
      : ::InterlockedDecrement(&lockCount);
   }

   static
   bool
   CanUnloadNow()
   {
      return (instanceCount == 0 && lockCount == 0) ? true : false;
   }

   private:

   static long instanceCount;
   static long lockCount;

   // not implemented
   ComServerLockState();
   ComServerLockState(const ComServerLockState&);
   const ComServerLockState& operator=(const ComServerLockState&);
};  



class ComServerReference
{
   public:

   ComServerReference()
   {
      ComServerLockState::IncrementInstanceCounter();
   }

   ~ComServerReference()
   {
      ComServerLockState::DecrementInstanceCounter();
   }

   private:

   // not implemented; no instance copying allowed.
   ComServerReference(const ComServerReference&);
   const ComServerReference& operator=(const ComServerReference&);
}; 



#endif   // __DLLREF_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\error.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// abstract pure virtual base class for all Error objects,
// defining the services all Error objects must supply.
// 
// 8-14-97 sburns



#ifndef ERROR_HPP_INCLUDED
#define ERROR_HPP_INCLUDED



// this really could be anything.  Someday I might actually use this
// HelpContext stuff.

typedef LONG_PTR HelpContext;



// class Error is a pure virtual base class used to encapsulate error
// information in to a single unit which may participate in exception
// handling or be passed between functions in lieu of a simple error
// code. 
// 
// It is the base class of a taxonomy of Error classes.  Rather than
// attempt to reuse an existing type, a new component should consider
// defining a new type suitable for the semantics of that component's
// function.  (implementation, of course, can be re-used). Introducing
// types in this fashion facilitates selection of error handlers in a
// try..catch blocks, beyond the OO-wholesomeness of the practice.
// 
// Another characteristic of this abstraction is the ability to
// support cross-locale exception propagation.  This is the problem
// where an exception is thrown in a system which is in a different
// locale than the system catching the exception.  A remoteable
// implementation of this class could account for crossing locales (by
// utilizing locale-independent representations of the error, and
// providing translation capabilities for each supported locale, for
// instance).
// 
// At some point in the future, this class could subclass
// std::exception in some useful way, when the semantics of the C++
// exception hierarchy finally stabilize in practice.

class Error
{
   public:

//    // Error::Details expresses the truly gritty bits of an occurrence
//    // of an error, which user interfaces may or may not wish to expose
//    // to the end user.
// 
//    class Details
//    {
//       public:
// 
//       // Constructs an instance.
//       // 
//       // body - The gritty details text.
//       // 
//       // fileName - The source file of the code that produced the
//       // error
//       // 
//       // lineNumber - The location within the source file of the code
//       // that produced the error.
// 
//       Details(
//          const String&  body,
//          const String&  fileName,
//          unsigned       lineNumber);
// 
//       // default dtor, copy ctor, op= used.  This class is cheap to
//       // copy
// 
//       // Returns the body text with which the instance was created.
// 
//       String
//       GetBody() const;
// 
//       // Returns the file name with which the instance was created.
// 
//       String
//       GetFileName() const;
// 
//       // Returns the line number with which the instance was created.
// 
//       unsigned
//       GetLineNumber() const;
// 
//       private:
//      
//       String  body_;
//       String  file;
//       int     line;
//    };

   // a pure virtual dtor ensures abstractness
   virtual ~Error() = 0;

//    // return a Details object containing additional trivia, such as
//    // context information.
// 
//    virtual 
//    Details
//    GetDetails() const = 0;

   // return the HelpContext that will point the user to assistance
   // in deciphering the error message and details.

   virtual 
   HelpContext
   GetHelpContext() const = 0;

   // return the human readable error message.

   virtual 
   String
   GetMessage() const = 0;

   // return a 1-line summary: The essence of the error, suitable for
   // use as the title of a reporting dialog, for instance.

   virtual 
   String
   GetSummary() const = 0;
};



#endif   // ERROR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\filesys.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// File System services.
//
// 8-14-97 (sburns)
      


#ifndef FILESYS_HPP_INCLUDED
#define FILESYS_HPP_INCLUDED



// CODEWORK: remove exceptions in favor of an HRESULT orientation.


namespace Burnslib
{
   
namespace FS
{
   // Facilitates walking a directory tree.

   // CODEWORK: add methods to extract current file data beyond just the
   // name.

   class Iterator
   {
      public:

      enum 
      {
         INCLUDE_FILES     = 0x0001,
         INCLUDE_FOLDERS   = 0x0002,
         INCLUDE_DOT_PATHS = 0x0004,

// CODEWORK:
//         EXPAND_SUBDIRS      = 0x0008,

         RETURN_FULL_PATHS = 0x0010
      };

      // Constructs a new instance of an Iterator.
      // 
      // startingPathSpec - fully-qualified path specification of the
      // files/directories to be iterated upon.  A wildcard
      // specification is allowed at the end of the path.  E.g.
      // "C:\dir\*.txt"
      // 
      // (Without a wildcard expression of some kind, the iteration set will
      // be the single file or folder that matches startingPathSpec.  This set
      // may be further reduced to the empty set if the optionMask eliminates
      // the single match.)
      // 
      // optionMask - Options, OR'ed together.

      explicit
      Iterator(
         const String&  startingPathSpec,
         unsigned       optionMask =
               INCLUDE_FILES
            |  INCLUDE_FOLDERS
            |  INCLUDE_DOT_PATHS
            /* | EXPAND_SUBDIRS */
            |  RETURN_FULL_PATHS);

      ~Iterator();

      // Restores the iterator to the state that it had upon
      // construction. 

      void
      Reset();

      // Retrieve the name of the file at the current iterator position.  If
      // the iterator was constructed with the RETURN_FULL_PATHS Option, then
      // the returned string is a fully-qualified path, instead of a path
      // relative to the starting path the Iterator was constructed with.
      // Returns S_OK on success, S_FALSE if the iteration is empty (there are
      // no files), or an error code.
      // 
      // If AtEnd() is true, then the empty string is returned.
      //
      // result - receives the file path at the current position of the
      // iterator, or the empty string if the iteration set is empty, or
      // an error occurred.

      HRESULT
      GetCurrent(String& result);

      // Move the current position to the next file, according to the
      // iterator filtering options.  May cause the iterator to become
      // invalid, which can be tested with AtEnd().  Returns S_OK on success
      // S_FALSE when the iteration is complete, or an error code.

      HRESULT
      Increment();

      private:

      WIN32_FIND_DATA*  findData;
      HANDLE            findHandle;
      bool              finished;
      unsigned          options;
      String            parentFolder;
      String            startSearchSpec;

      void
      Finish();

      bool
      IsNotStarted();

      String
      ReturnPath();

      bool
      ShouldSkipCurrent();

      HRESULT
      Start();

      HRESULT
      SkipFilteredPaths();

      // copying not implemented in the interest of simplicity (could be done
      // in theory)

      Iterator(const Iterator&);
      const Iterator& operator=(const Iterator&);
   };



   // Simple file-to-file copy.
   //   
   // sourceFile - Fully-qalified path of the file to be copied.  This
   // path must reference an existing file.
   // 
   // destinationFile - Fully-qualified path of the file to be
   // created.  This file is always overwritten, if it exists.  All
   // intermediate subdirectories required are created.
   // 
   // progressCallback - Callback object to receive progress
   // notifications.  The param argument to the callback's Execute
   // method will be an instance of CopyCallbackParam.  The method
   // should return !0 to abort the copy.

   struct CopyCallbackParam
   {
      String         sourceFile;
      String         destinationFile;
      int            percentCopied;
   };

   HRESULT
   CopyFile(
      const String&  sourceFile,
      const String&  destinationFile,
      Callback*      progressCallback);



   // Creates a directory, including all intermediate subdirectories,
   // as necessary.  Returns S_FALSE if the path already exists.
   //
   // path - Fully-qualified path to be created.  It must not
   // already exist.

   HRESULT
   CreateFolder(const String& path);



   // Opens a file for shared read/write access with normal attributes,
   // creating it if it does not already exist.
   // 
   // path - Fully-qualified path of file to open.  If path doesn't
   // exist, it is created, including intermediate subdirectories.
   //
   // result - receives the resulting file handle, on success.  On falure,
   // this is set to INVALID_HANDLE_VALUE

   HRESULT
   CreateFile(
      const String&  path,
      HANDLE&        result,
      DWORD          desiredAccess       = GENERIC_READ | GENERIC_WRITE,
      DWORD          shareMode           = FILE_SHARE_READ | FILE_SHARE_WRITE,
      DWORD          creationDisposition = OPEN_ALWAYS,
      DWORD          flagsAndAttributes  = FILE_ATTRIBUTE_NORMAL);



   // Splits a fully-qualified path into its constituent parts.
   //          
   // drive - receives the volume portion (in the form "X:")
   //       
   // parentFolderPath - receives the path of the folder containing the leaf
   // file or folder.
   //      
   // leafName - receives the base name of the last file or folder on the
   // path.
   //
   // extension - receives the extension, of the last file or folder on the
   // path, including the dot (".ext")

   void
   SplitPath(
      const String&  fullpath,
      String&        drive,
      String&        parentFolderPath,
      String&        leafName,
      String&        extension);


   // Appends an unqualified relative path (i.e.  system32\cys.exe) to the
   // the base path supplied and returns the full path.  A '\' will be added
   // between the parts if needed.  If the base path is not normalized the
   // result will not be normalized either.
   //
   // base - fully-qualified path which will be appended to
   //
   // additional - unqualified relative path which will be appended
   
   String
   AppendPath(
      const String& base, 
      const String& additional);

   // Returns the leaf portion of a fully-qualified path, including the
   // extension.  The path may refer to either a file or a folder.  For
   // example, "x:\foo\bar.ext" returns "bar.ext"
   //   
   // fullpath - fully-qualified filename.

   String
   GetPathLeafElement(const String& fullpath);



   // Removes the last component of a fully-qualified file name or folder
   // name. Includes trailing path separator only if the parent folder is the
   // root folder on a volume.
   //
   // e.g. "x:\foo" returns "x:\", but "x:\foo\bar" returns "x:\foo" (not
   // "x:\foo\")
   //
   // fullpath - fully-qualified filename.

   String
   GetParentFolder(const String& fullpath);



   // Returns the available space, in bytes, to the current user of the
   // calling thread (i.e. takes into account user quotas)
   // 
   // path - Fully-qualified path of file/directory for which attributes will
   // be retrieved.  This need not be the root directory of the volume in
   // question.
   //
   // result - receives the result, the available space in bytes.  Set to
   // 0 on error.
   
   HRESULT
   GetAvailableSpace(const String& path, ULONGLONG& result);



   // Returns the root folder path of the given full path, e.g. for
   // "C:\foo\bar" returns "C:\"
   //
   // fullpath - Fully-qualified path of file/directory

   String
   GetRootFolder(const String& fullpath);



   // Reports the current position of the file read/write pointer.  Returns
   // S_OK on success, or an error code on failure.
   //
   // handle - valid handle to an opened file
   //
   // result - receives the file position, set to 0 on error

   HRESULT
   GetFilePosition(HANDLE handle, LONGLONG& result);



   // Returns the total size, in bytes, of the file opened on the provided
   // handle.
   //
   // handle - valid handle to an opened file
   //
   // result - receives the file size, or 0 on error.

   HRESULT
   GetFileSize(HANDLE handle, LONGLONG& result);



   // Returns the type of the file system of the volume on which the path
   // refers.  Non-existant paths are considered to have the FAT file system.
   //
   // path - fully-qualified path, which contains the drive letter of the
   // volume

   // CODEWORK: how does this behave in the presence of mount points?  For
   // example, what if a FAT volume is mounted as a subdirectory of an
   // NTFS volume?

   enum FSType
   {
      FAT,
      CDFS,
      NTFS4,
      NTFS5
   };

   FSType
   GetFileSystemType(const String& path);



   enum PathSyntax
   {
      SYNTAX_ABSOLUTE_DRIVE,              // d:\foo\bar 
      SYNTAX_ABSOLUTE_DRIVE_WILDCARD,     // d:\foo\*.*
      SYNTAX_ABSOLUTE_NO_DRIVE,           // \foo\bar
      SYNTAX_ABSOLUTE_NO_DRIVE_WILDCARD,  // \foo\*.*
      SYNTAX_RELATIVE_DRIVE,              // d:foo\bar
      SYNTAX_RELATIVE_DRIVE_WILDCARD,     // d:foo\*.*
      SYNTAX_RELATIVE_NO_DRIVE,           // foo\bar
      SYNTAX_RELATIVE_NO_DRIVE_WILDCARD,  // foo\*.*
      SYNTAX_UNC,                         // \\machine\share
      SYNTAX_UNC_WILDCARD,                // \\machine\share\*.*
      SYNTAX_UNRECOGNIZED
   };

   // Parses the supplied string an attempts to validate its syntax.  The
   // string need not refer to an existing file or directory.
   // 
   // str - the string to be analysed.

   PathSyntax
   GetPathSyntax(const String& str);



   // Populates the given DriveList with elements representing the valid
   // drive letters on the local machine.  Each element is a string of the
   // form "X:" where X is a drive letter.
   //
   // BackInsertableContainer - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // bii - a reference to a back_insert_iterator of the
   // BackInsertableContainer template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // hr = FS::GetValidDrives(back_inserter<container>);
   //
   // StringVector container2;
   // hr = FS::GetValidDrives(back_inserter<container2>);

   template <class BackInsertableContainer>
   HRESULT
   GetValidDrives(std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      HRESULT hr = S_OK;
      TCHAR* buf = 0;
      do
      {
         // first call determines the size of the buffer we need.

         DWORD bufchars = 0;
         hr = Win::GetLogicalDriveStrings(0, 0, bufchars);
         BREAK_ON_FAILED_HRESULT(hr);

         // add 1 for extra-safe null terminator
         size_t bufbytes = (bufchars + 1) * sizeof(TCHAR);
         buf = new TCHAR[bufbytes];
         memset(buf, 0, bufbytes);

         // second call actually retrieves the strings

         DWORD unused = 0;
         hr = Win::GetLogicalDriveStrings(bufchars, buf, unused);
         BREAK_ON_FAILED_HRESULT(hr);

         // walk thru buf and chop it into substrings.
         for (
            TCHAR* sub = _tcschr(buf, 0), *buf2 = buf;
            sub && buf2 && buf2[0];
            buf2 = sub + 1, sub = _tcschr(buf2, 0))
         {
             *bii++ = buf2;
         }
      }
      while (0);

      delete[] buf;

      return hr;
   }



   // Wrapper of the Win32 API of the same name
   //
   // path - Fully-qualified path.  This path need not exist.

   HRESULT
   GetVolumePathName(const String& path, String&);



   // Returns true if the path refers to an empty or non-existent directory.
   //
   // path - Fully-qualified path 

   bool
   IsFolderEmpty(const String& path);



   // Returns true if parent is the name of a parent directory of the given
   // child directory, false if not.  A parent directory is defined as one
   // that appears closer to the root than a child on the same branch.  A
   // parent may be any superior directory (e.g. grandparent,
   // great-grandparent), not just the immediate superior.
   // 
   // parent - valid, fully-qualified path of supposed parent directory.  Need
   // not exist.
   // 
   // child - valid, fully-qualified path of child directory.  Need not exist.

   bool
   IsParentFolder(const String& parent, const String& child);



   // Checks the validity, but not the existence of, the specified
   // file or directory.  the path must be absolute and include the
   // drive specifier.
   //
   // path - Fully-qualified path.

   bool
   IsValidPath(const String& path);



   // Moves or renames an existing file or directory.
   //
   // sourcePath - Fully-qualified path of the file/directory to be
   // moved/renamed. This file or directory must exist.  If the path refers to
   // a directory, the directory and all of its children are moved.
   //
   // destinationPath - Fully-qualified path of the destination
   // file/directory.  This path need not be on the same volume as the
   // sourcePath, but if it is not, the move will result in a recursive copy
   // of the sourcePath.
   //
   // replaceExisting - If the destinationPath refers to an existing
   // file/directory, and this parameter is true, the destinationPath is
   // overwritten.  Otherwise, if the destinationPath exists, an error is
   // returned.

   HRESULT
   MoveFile(
      const String&  sourcePath,
      const String&  destinationPath);

// CODEWORK:
//      bool           replaceExisting = false);



   // "Normalize" a path by parsing any relative path components (like . and
   // ..), and return the resulting path.  If there are no relative
   // components, or if an error occurred, return the same string as the
   // input.
   // 
   // Example:
   // L"c:\\.\\.\\..\\.\\temp\\.\\foo\\bar\\..\\baz" results in
   // L"c:\\temp\\foo\\baz"
   //    
   // abnormalPath - path to parse.

   String
   NormalizePath(const String& abnormalPath);



   // Returns true if the specified file or directory exists.
   //
   // path - Fully-qualified path.

   bool
   PathExists(const String& path);



   // Returns true if the specified file exists, i.e. the path exists and
   // it refers to a file (as opposed to a folder)

   bool
   FileExists(const String& filePath);
   


   // Reads bytes from the current file pointer of the handle as Unicode
   // text (2 bytes/character).
   //    
   // handle - valid, open file handle, with read/write pointer positioned
   // to the first byte of the first character to be read.
   //    
   // charactersToRead - number of characters to read.  -1 to read all
   // characters up to the end of the file or the first null character
   // encountered.  If this number would cause a read past the end of the
   // file, or past a null character, the read will stop at the end of the
   // file or null character.  In the case of a null character, the file
   // read/write pointer will be positioned at the byte following the null
   // character.
   // 
   // text - the characters read.  A truncated read operation can be detected
   // by comparing the length of this string to the charactersToRead
   // parameter.

   HRESULT
   Read(HANDLE handle, int charactersToRead, String& text);



   // Reads bytes from the current file pointer of the handle as ANSI
   // text.
   //
   // handle - valid, open file handle, with read/write pointer positioned
   // to the first byte of the first character to be read.
   //
   // bytesToRead - count of the number of bytes (*NOT* characters) to read
   //
   // text - the bytes read.

   HRESULT
   Read(HANDLE handle, int bytesToRead, AnsiString& text);



   // Positions the file read/write pointer.
   //
   // handle - Valid, open file handle.
   //
   // position - new position of the pointer, from the beginning of the
   // file.

   HRESULT
   Seek(HANDLE handle, LONGLONG position);



   // Moves the file read/write pointer to the end of the file.
   // 
   // handle - Valid, open file handle.

   HRESULT
   SeekToEnd(HANDLE handle);



   // Writes the supplied string as Unicode text to the file.
   // 
   // handle - Valid, open file handle.
   //
   // text - the text to be written

   HRESULT
   Write(HANDLE handle, const String& text);



   // appends a crlf

   HRESULT
   WriteLine(HANDLE handle, const String& text);




   // Writes the supplied buffer to the file.
   //
   // handle - Valid, open file handle.
   //
   // buf - buffer to write.  This is an instance of basic_string<char>

   HRESULT
   Write(HANDLE handle, const AnsiString& buf);



   // appends a crlf

   HRESULT
   WriteLine(HANDLE handle, const AnsiString& text);
}

}





#endif   // FILESYS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\encodedstring.hpp ===
// Copyright (c) 2001 Microsoft Corporation
// 
// run-encoded string class
// 
// 2001-02-08 sburns



#ifndef ENCODEDSTRING_HPP_INCLUDED
#define ENCODEDSTRING_HPP_INCLUDED



// A class that has a similar public interface as class Burnslib::String, but
// is represented as a run-encoded unicode string, using the Rtl functions.
// This class is used to represent password strings in-memory, instead of
// holding them as cleartext, which is a security hole if the memory pages
// are swapped to disk.

class EncodedString
{
   typedef String::size_type size_type;
   
   public:


   
   // constucts an empty string.

   explicit
   EncodedString();


   
   // constructs a copy of an existing, already encoded string

   EncodedString(const EncodedString& rhs);



   // scribbles out the text, and deletes it.
   
   ~EncodedString()
   {
      Reset();
   }



   // Extracts the decoded cleartext representation of the text, including
   // null terminator.  The caller must free the result with delete[], and
   // should scribble it out, too.
   //
   // Example:
   // WCHAR* cleartext = encoded.GetDecodedCopy();
   // // use the cleartext
   // ::ZeroMemory(cleartext, encoded.GetLength() * sizeof(WCHAR));
   // delete[] cleartext;
   
   WCHAR* 
   EncodedString::GetDecodedCopy() const;


   
   // Returns true if the string is zero-length, false if not.
   
   bool
   IsEmpty() const
   {
      return (GetLength() == 0);
   }



   // Sets the contents of self to the encoded representation of the
   // cleartext, replacing the previous value of self.  The encoded
   // representation will be the same length, in characters, as the
   // cleartext.
   //
   // clearText - in, un-encoded text to be encoded.  May be empty string, but
   // not a null pointer.
   
   void
   Encode(const WCHAR* cleartext);
      

   
   // Returns the length, in unicode characters, of the text.

   size_type
   GetLength() const
   {
      return cypherText.Length;
   }


   
   // Replaces the contents of self with a copy of the contents of rhs.
   // Returns *this.
   
   const EncodedString&
   operator= (const EncodedString& rhs);



   // Compares the cleartext representations of self and rhs, and returns
   // true if they are lexicographically the same: the lengths are the same
   // and all the characters are the same.
      
   bool
   operator== (const EncodedString& rhs) const;



   bool
   operator!= (const EncodedString& rhs) const
   {
      return !(operator==(rhs));
   }
   

   
   private:



   // scribbles out and frees the internal string.
   
   void
   Reset();



   // builds the internal encoded representation from the cleartext.
   //
   // clearText - in, un-encoded text to be encoded.  May be empty string, but
   // not a null pointer.
      
   void
   Init(const WCHAR* clearText);


   
   // We deliberately do not implement conversion to or from wchar_t* or
   // String.  This is to force the user of the class to be very deliberate
   // about decoding the string.  class String is a copy-on-write shared
   // reference implementation, and we don't want to make it easy to create
   // "hidden" copies of cleartext, or move from one representation to
   // another, or accidentally get a String filled with encoded text.

   // deliberately commented out
   // explicit
   // EncodedString(const String& cleartext);
  
   operator WCHAR* ();
   operator String ();



   // In the course of encoding, decoding, and assigning to the instance,
   // we may create and destroy these, but logically the string is "const"   
   
   mutable UCHAR            seed;
   mutable UNICODE_STRING   cypherText;
};



#endif   // ENCODEDSTRING_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\extract.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// class Extractor
// 
// 11-12-97 sburns



#ifndef EXTRACT_HPP_INCLUDED
#define EXTRACT_HPP_INCLUDED



// Extractor encapsulates clipboard extraction buffers, allocating and
// initializing them upon construction, deallocating them upon deletion. By
// keeping a single (static) instance of an Extractor around, one can avoid
// allocation/deallocation for each extraction operation, and be assured that
// cleanup occurs properly.

class Extractor
{
   protected:

   // Creates a new instance.  Declared protected so as to function only 
   // as a base class.
   //
   // clipFormatID - clipboard format ID returned from Win
   // RegisterClipboardFormat.
   // 
   // bufSize - the buffer size, in bytes, required to extract the data in the
   // clipboard format expressed by the clipFormatID parameter.

   Extractor(CLIPFORMAT clipFormatID, size_t bufSize);

   virtual ~Extractor();

   // Calls GetDataHere on the data object, returning a pointer to the buffer
   // if the call was successful, or 0 if the call failed.  The invoker should
   // NOT free the returned HGLOBAL, as this is managed by the object.
   // 
   // dataObject - the data object from which the clipboard data should be
   // extracted.

   HGLOBAL
   GetData(IDataObject& dataObject);

   private:

   // not implemented: no copying allowed
   Extractor(const Extractor&);
   const Extractor& operator=(const Extractor&);

   FORMATETC formatetc;
   STGMEDIUM stgmedium;
   size_t    bufSize;
};



#endif   // EXTRACT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\log.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// debug logging tools
//
// 8-13-97 sburns



#ifndef LOG_HPP_INCLUDED
#define LOG_HPP_INCLUDED



// Log provides an interface to a singleton application logging facility.

namespace Burnslib
{

class Log
{
   public:
   
   // use these to set DEFAULT_LOGGING_OPTIONS
   //
   // During CRT startup of our module (i.e. before main, WinMain, or
   // DllMain), the debug code examines the DWORD LogFlags value under the
   // registry key named by REG_ADMIN_RUNTIME_OPTIONS\LOGFILE_NAME.  If the
   // value is not present, it is created and DEFAULT_LOGGING_OPTIONS is
   // written there. If the value is present, it is read.
   //
   // The HIWORD is a bit mask specifying the destination of the logging
   // output.
   //
   // The LOWORD of that value contains a bitmask of the various debug
   // message types to be output:


   // cause LOG output to go to a log file named RUNTIME_NAME.log

   static const DWORD OUTPUT_TO_FILE = (1 << 16);

   // cause LOG output to go to OutputDebugString

   static const DWORD OUTPUT_TO_DEBUGGER = (1 << 17);

   // cause LOG output to go to SpewView application

   static const DWORD OUTPUT_TO_SPEWVIEW = (1 << 18);

   // cause LOG output to be appended to a log file named RUNTIME_NAME.log

   static const DWORD OUTPUT_APPEND_TO_FILE = (1 << 19);


   // output object construction/destruction

   static const DWORD OUTPUT_CTORS = (1 << 0);

   // output calls to AddRef/Release   

   static const DWORD OUTPUT_ADDREFS = (1 << 1);

   // output function call entry

   static const DWORD OUTPUT_FUNCCALLS = (1 << 2);

   // output trace messages

   static const DWORD OUTPUT_LOGS = (1 << 3);

   // output log header

   static const DWORD OUTPUT_HEADER = (1 << 4);

   // output error messages

   static const DWORD OUTPUT_ERRORS = (1 << 5);

   // output time-of-day on each log line

   static const DWORD OUTPUT_TIME_OF_DAY = (1 << 6);

   // output time-since-start on each log line

   static const DWORD OUTPUT_RUN_TIME = (1 << 7);

   // output function/scope exits 

   static const DWORD OUTPUT_SCOPE_EXIT = (1 << 8);



   static const DWORD OUTPUT_MUTE = 0;

   static const DWORD OUTPUT_FULL_VOLUME =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_TO_DEBUGGER
      |  Log::OUTPUT_TO_SPEWVIEW
      |  Log::OUTPUT_CTORS
      |  Log::OUTPUT_ADDREFS
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_TIME_OF_DAY
      |  Log::OUTPUT_RUN_TIME
      |  Log::OUTPUT_SCOPE_EXIT;

   static const DWORD OUTPUT_TYPICAL =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_TO_DEBUGGER
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_ERRORS;


   // Returns a pointer to the single Burnslib::Log instance.

   static
   Log*
   GetInstance();



   // Called by the initialization machinery to tear down the debugging setup.
   // This takes place during static de-initialization, after
   // main/WinMain/DllMain(DLL_PROCESS_DETACH) has returned.

   static
   void
   Cleanup();



   // Dumps text to the log for the given logging type.
   //
   // type - log type of text.
   // 
   // text - text to dump.
   // 
   // file - filename of source file producing text.
   // 
   // line - line number in source file producing text.

   void
   WriteLn(
      WORD           type,
      const String&  text);
      // const String&  file,
      // unsigned       line);



   // A ScopeTracer object emits text to the log upon construction and
   // destruction.  Place one at the beggining of a lexical scope, and it
   // will log when the scope is entered and exited.
   
   // See LOG_SCOPE, LOG_CTOR, LOG_DTOR, LOG_FUNCTION,
   // LOG_FUNCTION2

   class ScopeTracer
   {
      public:

      // Constructs a new instance, and logs it's creation.
      // 
      // type - the logging type for the log output
      // 
      // message - the text to be emited on construction and destruction

      ScopeTracer(
         DWORD          type,
         const String&  message);

      ~ScopeTracer();

      private:

      String message;
      DWORD   type;
   };


   friend class ScopeTracer;



   private:



   explicit Log(const String& logBaseName);
   ~Log();



   HRESULT
   AdjustLogMargin(int delta);



   String
   ComposeSpewLine(const String& text);



   // Closes and deletes the single Burnslib::Log instance.  If GetInstance
   // is called after this point, then a new instance will be created.

   static
   void
   KillInstance();



   size_t
   GetLogMargin();



   void
   Indent();



   // Returns true if the log file is open, false if not.

   bool
   IsOpen() const
   {
      return fileHandle != INVALID_HANDLE_VALUE;
   }



   void
   Outdent();



   void
   ReadLogFlags();



   // This does all the work, really.

   void
   UnguardedWriteLn(DWORD type, const String& text);



   DWORD
   DebugType()
   {
      // mask off the HIWORD for now.

      return LOWORD(flags);
   }



   bool
   ShouldLogToFile()
   {
      return (flags & OUTPUT_TO_FILE) ? true : false;
   }


   bool
   ShouldAppendLogToFile()
   {
      return (flags & OUTPUT_APPEND_TO_FILE) ? true : false;
   }

   bool
   ShouldLogToDebugger()
   {
      return (flags & OUTPUT_TO_DEBUGGER) ? true : false;
   }



   bool
   ShouldLogToSpewView()
   {
      return (flags & OUTPUT_TO_SPEWVIEW) ? true : false;
   }



   bool
   ShouldLogTimeOfDay()
   {
      return (flags & OUTPUT_TIME_OF_DAY) ? true : false;
   }



   bool
   ShouldLogRunTime()
   {
      return (flags & OUTPUT_RUN_TIME) ? true : false;
   }



   void
   WriteHeader();


   void
   WriteHeaderModule(HMODULE moduleHandle);



   String           baseName;             
   HANDLE           fileHandle;           
   DWORD            flags;                
   HANDLE           spewviewHandle;
   String           spewviewPipeName;
   unsigned         traceLineNumber;      
   CRITICAL_SECTION critsec;              
   DWORD            logfileMarginTlsIndex;

   // not implemented; no instance copying allowed.
   Log(const Log&);
   const Log& operator=(const Log&);
};



// CODEWORK: purge these aliases

const DWORD OUTPUT_MUTE = Log::OUTPUT_MUTE;

const DWORD OUTPUT_FULL_VOLUME = Log::OUTPUT_FULL_VOLUME;

const DWORD OUTPUT_TYPICAL = Log::OUTPUT_TYPICAL;



} // namespace Burnslib
   


#ifdef LOGGING_BUILD


// The logging feature offers the ability to cause output spew at the opening
// and closing of a lexical scope.  This can be done at arbitrary scope with
// the LOG_SCOPE macro, or (more commonly) at function scope with the
// LOG_FUNCTION/2 macros.  Specializations of LOG_FUNCTION include LOG_CTOR/2,
// LOG_DTOR/2, LOG_ADDREF, and LOG_RELEASE.  Refer to the following table:
//    
// Spew macro				      Output spewed (spewn?) when this flag is set
//
// LOG_SCOPE				      OUTPUT_LOGS
// LOG_FUNCTION 			      OUTPUT_FUNCCALLS
// LOG_FUNCTION2			      OUTPUT_FUNCCALLS
// LOG_CTOR				         OUTPUT_CTORS	
// LOG_CTOR2				      OUTPUT_CTORS
// LOG_DTOR				         OUTPUT_CTORS
// LOG_DTOR2				      OUTPUT_CTORS
// LOG_ADDREF				      OUTPUT_ADDREFS
// LOG_RELEASE				      OUTPUT_ADDREFS
// LOG_LOG_EGGS_AND_SPAM_LOG	To be implemented
//       
// At the point where the LOG macro is executed, if the corresponding flag
// is set, a line starting with "Enter " is output.  Subsequent output is then
// indented.  At the point where the lexical scope enclosing the macro ends,
// if the OUTPUT_SCOPE_EXIT flag is set, a line starting with "Exit" is
// output.  Subsequent output is aligned with the next most recent Enter, i.e.
// outdented.
//          
// If the flag corresponding to a LOG macro is not set, then no "Enter" or
// "Exit" lines are output.


   #define LOGT(type, msg)                                                \
   {  /* open scope */                                                    \
      Burnslib::Log* _dlog = Burnslib::Log::GetInstance();                \
      if (_dlog)                                                          \
      {                                                                   \
         _dlog->WriteLn(type, msg);                                       \
      }                                                                   \
   }  /* close scope */                                                   \



   #define LOG(msg) LOGT(Burnslib::Log::OUTPUT_LOGS, msg)



   #define LOG_LAST_WINERROR()                                            \
      LOGT(                                                               \
         Burnslib::Log::OUTPUT_ERRORS,                                    \
         String::format(                                                  \
            L"GetLastError = 0x%1!08X!",                                  \
            ::GetLastError()))                                            \
                                                                          \


   #define LOG_SCOPET(type, msg)                                          \
   Burnslib::Log::ScopeTracer __tracer(type, msg)                  



   #define LOG_SCOPE(msg)                                                 \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_LOGS,                                         \
      msg)



   #define LOG_CTOR(classname)                                            \
   LOG_SCOPET(Burnslib::Log::OUTPUT_CTORS, L"ctor: " TEXT(#classname))



   #define LOG_CTOR2(classname, msg)                                      \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_CTORS,                                        \
         String(L"ctor: " TEXT(#classname) L" ")                          \
      +  String(msg))



   #define LOG_DTOR(classname)                                            \
   LOG_SCOPET(Burnslib::Log::OUTPUT_CTORS, L"dtor: " TEXT(#classname))



   #define LOG_DTOR2(classname, msg)                                      \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_CTORS,                                        \
         String(L"dtor: " TEXT(#classname) L" ")                          \
      +  String(msg))



   #define LOG_ADDREF(classname)                                          \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ADDREFS,                                      \
      L"AddRef: " TEXT(#classname))



   #define LOG_RELEASE(classname)                                         \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ADDREFS,                                      \
      L"Release: " TEXT(#classname))



   #define LOG_FUNCTION(func)                                             \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_FUNCCALLS,                                    \
      TEXT(#func))                                                        



   #define LOG_FUNCTION2(func, s)                                         \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_FUNCCALLS,                                    \
      String(TEXT(#func) L" ").append(s))                                 



   #define LOG_HRESULT(hr)                                                \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ERRORS,                                       \
      String::format(L"HRESULT = 0x%1!08X!", hr))



   #define LOG_BOOL(boolexpr)                                             \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_LOGS,                                         \
      String::format(                                                     \
         L"%1 = %2",                                                      \
         TEXT(#boolexpr),                                                 \
         (boolexpr) ? L"true" : L"false"))                                
      


#else    // LOGGING_BUILD

   #define LOGL(type, msg)
   #define LOG(msg)
   #define LOG_LAST_WINERROR()

   #define LOG_SCOPEL(type, msg)
   #define LOG_SCOPE(msg)

   #define LOG_CTOR(classname)
   #define LOG_CTOR2(classname, msg)
   #define LOG_DTOR(classname)
   #define LOG_DTOR2(classname, msg)

   #define LOG_ADDREF(classname)
   #define LOG_RELEASE(classname)

   #define LOG_FUNCTION(func)

   #define LOG_FUNCTION2(func, s)

   #define LOG_HRESULT(hr)
   #define LOG_BOOL(boolexpr)

#endif   // LOGGING_BUILD



#endif   // LOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\pragmawarning.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// Use of pointer types with STL container classes generates this beauty,
// which is a warning because if the situation it warns agains is
// ever encountered, that code will fail to compile.
// 
// The problem is that iterator classes define operator-> to return a pointer
// to the element type T of the container.  When that element is itself a
// pointer, then the return type of is a pointer to pointer, which has no
// members or methods to invoke.  So code like
// 
// list<Foo*> l;
// list<Foo*>::iterator i = l.begin();
// i->f();
// 
// will not compile, as the type Foo* does not have a method f().  So if the
// code will not compile, why warn about the potential for such code to exist?

#pragma warning (disable: 4284)


// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\popup.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Popup message box class
// 
// 8-31-98 sburns



#ifndef POPUP_HPP_INCLUDED
#define POPUP_HPP_INCLUDED


// Augments MessageBox with useful behavior

class Popup
{
   public:

   // Constuct an instance.
   //
   // titleStringResID - resource ID of the string to be used as the title
   // for all message dialogs raised by invoking methods of the instance.
   //
   // systemModal - true to indicate that message dialogs should have
   // system modal behavior

   explicit
   Popup(UINT titleStringResID, bool systemModal = false);

   // Constuct an instance.
   //
   // title - the string to be used as the title for all message dialogs
   // raised by invoking methods of the instance.
   //
   // systemModal - true to indicate that message dialogs should have
   // system modal behavior

   explicit
   Popup(const String& title, bool systemModal = false);

   // default dtor used.

   // Present a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.
   // 
   // parentDialog - the parent window containing the control to receive focus.
   //
   // editResID - Resource ID of the edit box to which focus will be set.
   // 
   // messageStringResID - Resource ID of the message text to be shown in the
   // dialog.  The title of the dialog is "Error".

   void
   Gripe(
      HWND  parentDialog,
      int   editResID,
      UINT  messageStringResID);

   // Presents a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.
   // 
   // parentDialog - the parent window containing the control to receive focus.

   // editResID - Resource ID of the edit box to which focus will be set.
   //
   // message - Text to appear in the dialog.  

   void
   Gripe(
      HWND           parentDialog,
      int            editResID,
      const String&  message);

   // Presents a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.  The message is followed with the
   // description of the provided HRESULT.
   // 
   // parentDialog - the parent window containing the control to receive focus.

   // editResID - Resource ID of the edit box to which focus will be set.
   //
   // hr - HRESULT indicating the error description text to appear after the
   // message text.
   //
   // message - Text to appear in the dialog.  The title is "Error".

   void
   Gripe(
      HWND           parentDialog,
      int            editResID,
      HRESULT        hr,
      const String&  message);

   void
   Gripe(
      HWND    parentDialog,       
      int     editResID,          
      HRESULT hr,                 
      UINT    messageStringResID);

   // variation on the theme that does not have an associated edit box.

   void
   Gripe(
      HWND           parentDialog,
      const String&  message);

   // Presents a message box

   void
   Error(
      HWND           parentDialog,
      HRESULT        hr,
      const String&  message);

   void
   Error(
      HWND    parentDialog,       
      HRESULT hr,                 
      UINT    messageStringResID);

   void
   Error(
      HWND parentDialog,       
      UINT messageStringResID);

   void
   Error(
      HWND           parentDialog,
      const String&  message);

   void
   Info(
      HWND parentDialog,       
      UINT messageStringResID);
   
   void
   Info(
      HWND           parentDialog,
      const String&  message);

   int
   MessageBox(
      HWND           parentDialog,
      const String&  message,
      UINT           flags);

   int
   MessageBox(
      HWND parentDialog,      
      UINT messageStringResID,
      UINT flags);            

   private:

   void
   checkInit();

   UINT
   getStyleMask();

   bool     initialized;
   bool     systemModal;
   String   title;
   UINT     titleResId;
};



#endif   // POPUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\netutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Net utility functions
//
// 11-4-1999 sburns



#ifndef NETUTIL_HPP_INCLUDED
#define NETUTIL_HPP_INCLUDED



// Returns true if some form of networking support is installed on the
// machine, false if not.

bool
IsNetworkingInstalled();



// Returns true if tcp/ip protocol is installed and bound to at least 1
// adapter.

bool
IsTcpIpInstalled();



HRESULT
MyNetJoinDomain(
   const String&  domain,
   const String&  username,
   const String&  password,
   ULONG          flags);



HRESULT
MyNetRenameMachineInDomain(
   const String& newNetbiosName,
   const String& username,
   const String& password,
   DWORD         flags);



HRESULT
MyNetUnjoinDomain(
   const String&  username,
   const String&  password,
   DWORD          flags);



HRESULT
MyNetValidateName(
   const String&        name,
   NETSETUP_NAME_TYPE   nameType);



// Caller must delete info with NetApiBufferFree.

HRESULT
MyNetWkstaGetInfo(const String& serverName, WKSTA_INFO_100*& info);




#endif   // NETUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\runtime.hpp ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\registry.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// System Registry Class
//
// 7-9-98 sburns



#ifndef REGISTRY_HPP_INCLUDED
#define REGISTRY_HPP_INCLUDED



class RegistryKey
{
   public:

   RegistryKey();
   ~RegistryKey();

   HRESULT
   Close();

   HRESULT
   Create(
      HKEY                 parentKey,
      const String&        subkeyName,
      DWORD                options = REG_OPTION_NON_VOLATILE,
      REGSAM               desiredAccess = KEY_WRITE,
      SECURITY_ATTRIBUTES* securityAttrs = 0,
      DWORD*               disposition = 0);

   HRESULT
   Open(
      HKEY           parentKey,
      const String&  subkeyName,
      REGSAM         desiredAccess = KEY_READ);

   // Returns Win32ToHresult(ERROR_INVALID_FUNCTION) if the type of the value
   // is not REG_DWORD, REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN.

   HRESULT
   GetValue(
      const String&  valueName,
      DWORD&         value);

   // Retrieves the contents of the named value, and whether the type of the
   // key is REG_SZ or REG_EXPAND_SZ.  Returns
   // Win32ToHresult(ERROR_INVALID_FUNCTION) if the type of the value is not
   // REG_SZ or REG_EXPAND_SZ
   //
   // valueName - name of the value.
   //
   // value - receives the contents of the value, if the read was successful.
   // cleared on failure.
   //
   // isExpandSz - set to true if the value is of type REG_EXPAND_SZ, false
   // if the type is REG_SZ (or an error ocurred).

   HRESULT
   GetValue(
      const String&  valueName,
      String&        value,
      bool&          isExpandSz);

   // Calls GetValue(), and throws away the isExpandSz result.

   HRESULT
   GetValue(
      const String&  valueName,
      String&        value);

   // Inserts strings from a REG_MULTI_SZ value into any container from
   // which a std::BackInsertionSequence can be constructed, the elements
   // of which must be constructable from an PWSTR.
   //
   // BackInsertionSequence - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // valueName - name of REG_MULTI_SZ value to retrieve.
   // 
   // bii - a reference to a back_insert_iterator of the
   // BackInsertionSequence template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // hr = key.GetValue(L"myValue", back_inserter(container));
   //
   // StringVector container;
   // hr = key.GetValue(L"myValue", back_inserter(container));

   template <class BackInsertableContainer>
   HRESULT
   GetValue(
      const String& valueName,
      std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      LOG_FUNCTION2(RegistryKey::GetValue-MultiString, valueName);
      ASSERT(!valueName.empty());
      ASSERT(key);

      DWORD type = 0;
      DWORD size = 0;
      HRESULT hr = Win::RegQueryValueEx(key, valueName, &type, 0, &size);
      if (SUCCEEDED(hr))
      {
         if (type == REG_MULTI_SZ)
         {
            // now that we know the size, read the contents
            BYTE* buf = new BYTE[size];   // a bitesized buffer!  Ha Ha!
            memset(buf, 0, size);

            type = 0;
            hr = Win::RegQueryValueEx(key, valueName, &type, buf, &size);
            if (SUCCEEDED(hr))
            {
               // pull off each of the null-terminated strings

               // the container values can be any type that can be constructed
               // from PWSTR...

               wchar_t* newbuf = reinterpret_cast<PWSTR>(buf);
               while (*newbuf)
               {
                  size_t len = wcslen(newbuf);

                  //lint --e(*)  lint does not grok back_insert_iterator
                  *bii++ = String(newbuf, len);

                  // move to the next string, + 1 to skip the terminating null
                  newbuf += len + 1;
               };

               delete[] buf;
            }
         }
         else
         {
            // caller requested a string from a non-multi-string key
            hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
         }
      }

      return hr;
   }

   // Calls GetValue and returns the result, or an empty string on failure.

   String
   GetString(const String& valueName);

   // Creates and/or sets a value under the currently open key.  Returns
   // S_OK on success.
   // 
   // valueName - name of the value.  If the value is not already present, it
   // is created with a REG_DWORD type.
   // 
   // value - the value to br written.

   HRESULT
   SetValue(
      const String&  valueName,
      DWORD          value);

   // Creates and/or sets a value under the currently open key.  Returns
   // S_OK on success.
   // 
   // valueName - name of the value.  If the value is not already present, it
   // is created.
   // 
   // value - the value to br written.
   //
   // expand - if true, the value type is REG_EXPAND_SZ, if false, the value
   // type is REG_SZ.

   HRESULT
   SetValue(
      const String&  valueName,
      const String&  value,
      bool           expand = false);

   template<class ForwardIterator>
   HRESULT
   SetValue(
      const String& valueName,
      ForwardIterator first,
      ForwardIterator last)
   {
      LOG_FUNCTION2(RegistryKey::SetValue--MultiString, valueName);
      ASSERT(!valueName.empty());

      // determine the size of the buffer to write
      size_t bufsize = 0;
      for (
         ForwardIterator f = first, l = last;
         f != l;
         ++f)
      {
         // + 1 for null terminator
         bufsize += (f->length() + 1) * sizeof(wchar_t);
      }

      // + 2 bytes for double-null terminator at very end
      bufsize += 2;

      BYTE* buf = new BYTE[bufsize];   
      memset(buf, 0, bufsize);

      // copy the elements of the container into the buffer
      wchar_t* newbuf  = reinterpret_cast<wchar_t*>(buf);
      wchar_t* copyPos = newbuf;                        
      for (
         f = first, l = last;
         f != l;
         ++f)
      {
         copyPos = std::copy(f->begin(), f->end(), copyPos);

         // skip a character for terminating null   
         copyPos++;
      }

      // write the buffer to the registry
      HRESULT hr = 
         Win::RegSetValueEx(
            key,
            valueName,
            REG_MULTI_SZ,
            buf,
            bufsize);

      delete[] buf;

      return hr;
   }

   private:

   HKEY     key;
};



#endif   // REGISTRY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\mem.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 7-30-98 sburns



namespace Burnslib
{

namespace Heap
{
   // cause calls to new to capture the call stack at the point of
   // allocation.

   const WORD TRACE_ALLOCATIONS = (1 << 6);


   void
   DumpMemoryLeaks();



   // called by the InitializationGuard.  Read flags from registry,
   // sets heap options.

   void
   Initialize();



   // our replacement operator new implementation

   void*
   OperatorNew(size_t size, const char* file, int line)
   throw (std::bad_alloc);



   // ... and the corresponding replacement operator delete
   // implementation

   void
   OperatorDelete(void* ptr)
   throw ();

}  // namespace Heap

}  // namespace Burnslib



// Replace the global new and delete operators.
//
// If the allocation fails, the user is given a system modal retry/cancel
// window.  If the user opts for retry, re-attempt the allocation.  Otherwise
// throw bad_alloc.
//
// Note that the CRT heap APIs are used, and that the debug heap APIs are
// also available.  This implies that other modules linking to the same CRT
// dll can install hooks that may break our implementation!


//lint -e(1727) ok that our re-definition is inline

inline
void* __cdecl
operator new(size_t size)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, 0, 0);
}



//lint -e(1548) ok that our redefinition throw spec doesn't match the CRT

inline
void* __cdecl
operator new[](size_t size)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, 0, 0);
}



// placement versions of operator new.  Although we use the placement syntax,
// we use the additional parameters to record debug information about the
// allocation, rather than indicating a location to allocate memory.

inline
void* __cdecl
operator new(size_t size, const char* file, int line)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, file, line);
}



inline
void* __cdecl
operator new[](size_t size, const char* file, int line)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, file, line);
}



inline
void __cdecl
operator delete(void* ptr)
throw ()
{
   // check for 0, since deleting the null pointer is legal.

   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



inline
void __cdecl
operator delete[](void* ptr)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



// placement versions of operator delete.  We must provide placement versions
// of operator delete with corresponding signatures to the placement versions
// of operator new that we have declared, even though we don't use those
// parameters.

inline
void __cdecl
operator delete(void* ptr, const char*, int)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



inline
void __cdecl
operator delete[](void* ptr, const char*, int)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



namespace Burnslib
{

namespace Heap
{
   // An STL-compatible allocator class that uses our replacement new
   // and delete operators.  We define this class after redefining our
   // operator new and delete, above, so that it uses our redefinition.
   // @@ (is that necessary, as construct uses placement new?)

   template <class T>
   class Allocator
   {
      public:

      typedef size_t    size_type;
      typedef ptrdiff_t difference_type;
      typedef T*        pointer;
      typedef const T*  const_pointer;
      typedef T&        reference;
      typedef const T&  const_reference;
      typedef T         value_type;

      pointer
      address(reference x) const
      {
         return &x;
      }

      const_pointer
      address(const_reference x) const
      {
         return &x;
      }

      // allocate enough storage for n elements of type T

      pointer
      allocate(size_type n, const void * /* hint */ )
      {
         size_t size = n * sizeof(T);
         return
            reinterpret_cast<pointer>(
               Burnslib::Heap::OperatorNew(size, 0, 0));
      }

      void
      deallocate(void* p, size_type /* n */ )
      {
         if (p)
         {
            Burnslib::Heap::OperatorDelete(p);
         }
      }

      void
      construct(pointer p, const T& val)
      {
         // this calls placement new, which just insures that T's copy ctor
         // is executed on memory at address p (so that the p becomes the
         // this pointer of the new instance.

         //lint -e534 -e522 ignore the return value, which is just p.

         new (reinterpret_cast<void*>(p)) T(val);
      }

      void
      destroy(pointer p)
      {
         ASSERT(p);

         (p)->~T();
      }

      size_type
      max_size() const
      {
         return size_t (-1) / sizeof (T);
      }

      char*
      _Charalloc(size_type n)
      {
         size_t size = n * sizeof(char*);
            
         return reinterpret_cast<char*>(
            Burnslib::Heap::OperatorNew(size, 0, 0));
      }

      // use default ctor, op=, copy ctor, which do nothing, as this class
      // has no members.

   };

   template<class T, class U>
   inline
   bool
   operator==(
      const Burnslib::Heap::Allocator<T>&,
      const Burnslib::Heap::Allocator<U>&)
   {
      return (true);
   }

   template<class T, class U>
   inline
   bool
   operator!=(
      const Burnslib::Heap::Allocator<T>&,
      const Burnslib::Heap::Allocator<U>&)
   {
      return (false);
   }

}  // namespace Heap

}  // namespace Burnslib



#ifdef DBG

   // redefine new to call our version that offers file and line number
   // tracking.  This causes calls to new of the form:
   // X* px = new X;
   // to expand to:
   // X* px = new (__FILE__, __LINE__) X;
   // which calls operator new(size_t, const char*, int)

   #define new new(__FILE__, __LINE__)

#endif



// You should pass -D_DEBUG to the compiler to get this extra heap
// checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
// in your build environment)

#ifdef _DEBUG

   // A HeapFrame is an object that, upon destruction, dumps to the debugger a
   // snapshot of the heap allocations that were made since its construction.
   // This only works on chk builds.  HeapFrame instances may overlap.  Place
   // one at the beginning of a lexical scope, and you will get a dump of all
   // the allocations made in that scope.
   // 
   // See HEAP_FRAME.

   namespace Burnslib
   {
      namespace Heap
      {
         class Frame
         {
            public:

            // Constructs a new instance.  The object will track all allocations
            // made after this ctor executes.
            //
            // file - name of the source file to be dumped with the allocation
            // report.  ** This pointer is aliased, so it should point to a
            // static address. **
            //
            // line - line number in the above source file to be dumped with the
            // allocation report.

            Frame(const wchar_t* file, unsigned line);

            // Dumps the allocations made since construction.

            ~Frame();

            private:

            const wchar_t* file;
            unsigned       line;

            _CrtMemState   checkpoint;
         };
      }
   }

   #define HEAP_FRAME() Burnslib::Heap::Frame __frame(__FILE__, __LINE__)

#else

   #define HEAP_FRAME()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\proppage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Property Page base class
// 
// 9-9-97 sburns



#ifndef PROPPAGE_HPP_INCLUDED
#define PROPPAGE_HPP_INCLUDED



// PropertyPage extends the Dialog class to provide message cracking for
// property page notifications.

class PropertyPage : public Dialog
{
   public:

   // Calls CreatePropertySheetPage and returns the resulting HPROPSHEETPAGE.
   // Normally, the HPROPSHEETPAGE is deleted by a later call to the Win32
   // API ::PropertySheet.  If the HPROPSHEETPAGE is not passed to
   // PropertySheet, or PropertySheet fails, it should be deleted with
   // ::DestroyPropertySheetPage.

   virtual 
   HPROPSHEETPAGE
   Create();

   protected:

   // Invoked upon receipt of the PSN_APPLY notification message.  Return true
   // if you handle the messages, false if you do not.  The default
   // implementation returns false.
   //
   // isClosing - true if the sheet is closing (OK was pressed), false if
   // not (Apply was pressed).

   virtual
   bool
   OnApply(bool isClosing);

   // Invoked upon receipt of the PSN_HELP notification message.  Return true
   // if you handle the message, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnHelp();

   // Invoked upon receipt of the PSN_KILLACTIVE notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.
   
   virtual
   bool
   OnKillActive();

   // Invoked upon receipt of the PSN_SETACTIVE notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnSetActive();

   // Invoked upon receipt of the PSN_QUERYCANCEL notification message.
   // Return true if you handle the messages, false if you do not.  The
   // default implementation returns false.

   virtual
   bool
   OnQueryCancel();

   // Invoked upon receipt of the PSN_RESET notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnReset();

   // Invoked upon receipt of the PSN_WIZBACK notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnWizBack();

   // Invoked upon receipt of the PSN_WIZNEXT notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnWizNext();

   // Invoked upon receipt of the PSN_WIZFINISH notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.
   // The handler must set the DWLP_MSGRESULT by calling Win::SetWindowLongPtr
   // to tell the sheet whether or not to shutdown the wizard.  

   virtual
   bool
   OnWizFinish();

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // dialogResID - resource identifier of the dialog template resource.
   // 
   // helpMap - array mapping dialog control IDs to context help IDs.  The
   // array must be in the following form:
   // {
   //    controlID1, helpID1,
   //    controlID2, helpID2,
   //    controlIDn, helpIDn,
   //    0, 0
   // }
   // 
   // To indicate that a control does not have help, the value of its
   // corresponding help ID should be -1.  This array is copied by the
   // constuctor.
   //
   // deleteOnRelease - true to delete the instance when the Win32
   // ::PropertySheet function is about to destroy the sheet, and sends the
   // PSPCB_RELEASE message to each page's callback.  false if the page
   // instance will be deleted at a later point.

   PropertyPage(
      unsigned    dialogResID,
      const DWORD helpMap[],
      bool        deleteOnRelease = true);

   // protected dtor so that the dtors of derived classes can call this,
   // the base class' dtor, and to suggest that prop pages are self-deleting.

   virtual ~PropertyPage();

   static
   INT_PTR APIENTRY
   propPageDialogProc(
      HWND   dialog, 
      UINT   message,
      WPARAM wparam, 
      LPARAM lparam);

   static
   UINT CALLBACK 
   PropSheetPageCallback(HWND hwnd,	UINT uMsg, PROPSHEETPAGE* page);

   private:

   static
   PropertyPage*
   getPage(HWND pageDialog);

   // not implemented: no copying allowed
   PropertyPage(const PropertyPage&);
   const PropertyPage& operator=(const PropertyPage&);

   bool deleteOnRelease;
};




#endif   // PROPPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\safedll.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Self-freeing DLL class
// 
// 10-9-98 sburns



#ifndef SAFEDLL_HPP_INCLUDED
#define SAFEDLL_HPP_INCLUDED



class SafeDLL
{
   public:

   // Constructs an instance that will on-demand load the named dll.
   //
   // dllName - name of the dll to be loaded.

   explicit
   SafeDLL(const String& dllName);

   // calls FreeLibrary on the DLL

   ~SafeDLL();

   HRESULT
   GetProcAddress(const String& functionName, FARPROC& result) const;
   
   private:

   mutable HMODULE   module;
   String            name;
};



#endif   // SAFEDLL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\service.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Service Control Manager wrapper class
// 
// 10-6-98 sburns



#ifndef SERVICE_HPP_INCLUDED
#define SERVICE_HPP_INCLUDED



// Simple NTService Control Manager wrapper

class NTService
{
   public:

   // Constructs a new instance that corresponds to the given service name on
   // the given computer.
   // 
   // machine - name of the computer.  Empty string corresponds to the local
   // computer.
   // 
   // serviveName - name of the service.

   NTService(const String& machine, const String& serviceName);

   // Constructs a new instance that corresponds to the given service name on
   // the local computer (the machine on which this call is invoked).
   // 
   // serviveName - name of the service.

   explicit
   NTService(const String& serviceName);

   ~NTService();

   bool
   IsInstalled();

   // Queries the SCM for the last reported state of the service.

   HRESULT
   GetCurrentState(DWORD& state);

   private:

   // not implemented: no copying allowed
   NTService(const NTService&);
   const NTService& operator=(const NTService&);

   String machine;
   String name;
};



#endif   // SERVICE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// 9-25-97 sburns



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



namespace Burnslib
{
   
// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface()
      :

#ifdef DBG      
      ptrGuard(0xDDDDDDDD),
#endif
      
      ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)

#ifdef DBG      
      :
      ptrGuard(0xDDDDDDDD)
#endif 
      
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)

#ifdef DBG      
      :
      ptrGuard(0xDDDDDDDD)
#endif 

   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      ASSERT(SUCCEEDED(hr));

      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.
   //
   // (does not return a const IUnknown&, as COM interfaces are not const
   // aware.)

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



   private:

   
#ifdef DBG

//    Some code that takes the address of an instance of this class is working
//    by happy coincidence: that taking the address of an instance yields the
//    same address as the ptr member.  For chk builds, I am deliberately
//    breaking that code by inserting a dummy guard value, so that &i != i.ptr
// 
//    You should not try to take the address of a SmartInterface in order to
//    access the internal pointer.  You should instead use one of the Acquire
//    methods, or use a dumb pointer and then acquire it. Under no
//    circumstances will we allow access to our internal state!
   
   int ptrGuard;
#endif
         
   T* ptr;
};


}  // namespace Burnslib



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\tempfact.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Class Factory template
// 
// 8-20-97 sburns



#ifndef TEMPFACT_HPP_INCLUDED
#define TEMPFACT_HPP_INCLUDED



// COM class factory implementation

template <class C>
class ClassFactory : public IClassFactory
{
   public:

   ClassFactory()
      :
      refcount(1)    // implicit AddRef
   {
      LOG_CTOR(ClassFactory);
   }

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef()
   {
      LOG_ADDREF(ClassFactory::AddRef);   
      return Win::InterlockedIncrement(refcount);
   }

   virtual
   ULONG __stdcall
   Release()
   {
      LOG_RELEASE(ClassFactory);   
      if (Win::InterlockedDecrement(refcount) == 0)
      {
         delete this;
         return 0;
      }

      return refcount;
   }

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired)
   {
      LOG_FUNCTION(ClassFactory::QueryInterface);
      ASSERT(interfaceDesired);

      HRESULT hr = 0;

      if (!interfaceDesired)
      {
         hr = E_INVALIDARG;
         LOG_HRESULT(hr);
         return hr;
      }

      if (interfaceID == IID_IUnknown)
      {
//         LOG(L"Supplying IUnknown interface");         
         *interfaceDesired =
            static_cast<IUnknown*>(static_cast<IClassFactory*>(this));
      }
      else if (interfaceID == IID_IClassFactory)
      {
//         LOG(L"Supplying IClassFactory interface");
         *interfaceDesired = static_cast<IClassFactory*>(this);
      }
      else
      {
         *interfaceDesired = 0;
         hr = E_NOINTERFACE;
         LOG(
               L"interface not supported: "
            +  Win::StringFromGUID2(interfaceID));
         LOG_HRESULT(hr);
         return hr;
      }

      AddRef();
      return S_OK;
   }

   // IClassFactory overrides
  
   virtual
   HRESULT __stdcall
   CreateInstance(
      IUnknown*   outerUnknown,
      const IID&  interfaceID,
      void**      interfaceDesired)
   {
      LOG_FUNCTION(ClassFactory::CreateInstance);  

      HRESULT hr = 0;

      if (outerUnknown)
      {
         hr = CLASS_E_NOAGGREGATION;
         LOG_HRESULT(hr);
         return hr;
      }

      // the instance starts with a ref count of 1.  If the QI fails, then it
      // will self-destruct upon release.
      C* c = new C;
      hr = c->QueryInterface(interfaceID, interfaceDesired);
      c->Release();

      return hr;
   }

   virtual
   HRESULT __stdcall
   LockServer(BOOL lock)
   {
      LOG_FUNCTION(ClassFactory::LockServer);   
      ComServerLockState::LockServer(lock ? true : false);
      return S_OK;
   }
 
   private:


   
   // only Release can cause us to be deleted

   virtual
   ~ClassFactory()
   {
      LOG_DTOR(ClassFactory);   
      ASSERT(refcount == 0);
   }

   // not implemented; no instance copying allowed.
   ClassFactory(const ClassFactory&);
   const ClassFactory& operator=(const ClassFactory&);

   ComServerReference   dllref;
   long                 refcount;
};
   


#endif   // TEMPFACT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\syscore.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// includes sdk and other headers external to this project necessary to
// build the burnslib core library
//
// 30 Nov 1999 sburns



#ifndef SYSCORE_HPP_INCLUDED
#define SYSCORE_HPP_INCLUDED


// the sources file should specify warning level 4.  But with warning level
// 4, most of the SDK and CRT headers fail to compile (isn't that nice?).
// So, here we set the warning level to 3 while we compile the headers

#pragma warning(push, 3)

   #include <nt.h>
   #include <ntrtl.h>
   #include <nturtl.h>
   #include <windows.h>
   #include <ole2.h>

   // Standard C++ headers, including STL

   // These warnings are emitted when compiling win64 with /W4, but we
   // disable them because they occur in code we are not responsible for.
   // (The #pragma warning (pop) at the end here will re-enable these
   // warnings)

   #pragma warning (disable: 4244)

   #include <string>
   #include <functional>
   #include <iterator>
   #include <crtdbg.h>
   #include <iso646.h>

#pragma warning (pop)



#endif   // SYSCORE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\sysfull.hpp ===
#ifndef SYSHDRS_HPP_INCLUDED
#define SYSHDRS_HPP_INCLUDED



// the sources file should specify warning level 4.  But with warning level
// 4, most of the SDK and CRT headers fail to compile (isn't that nice?).
// So, here we set the warning level to 3 while we compile the headers

#pragma warning(push,3)

   #include "syscore.hpp"

   #include <list>
   #include <vector>
   #include <map>
   #include <algorithm>
   #include <stack>

   #include <comutil.h>
   #include <commctrl.h>
   #include <shlobj.h>
   #include <shellapi.h>
   #include <htmlhelp.h>
   #include <tchar.h>

   #include <lmerr.h>
   #include <lmcons.h>
   #include <lmjoin.h>
   #include <lmapibuf.h>
   #include <lmserver.h>
   #include <lmwksta.h>
   #include <icanon.h>
   #include <dsrole.h>
   #include <dnsapi.h>
   #include <dsgetdc.h>
   #include <safeboot.h>
   #include <regstr.h>

   extern "C"
   {
      #include <dsgetdcp.h>
   }

   #include <ntdsapi.h>
   #include <sddl.h>

#pragma warning(pop)



#endif   // SYSHDRS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\utility.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns

                           

#ifndef UTILITY_HPP_INCLUDED
#define UTILITY_HPP_INCLUDED



// Returns true if current process token contains administrators membership.

bool
IsCurrentUserAdministrator();



// Reboots the machine.  Returns S_OK on success.

HRESULT
Reboot();



enum NetbiosValidationResult
{
   VALID_NAME,
   INVALID_NAME,  // contains illegal characters
   NAME_TOO_LONG
};

NetbiosValidationResult
ValidateNetbiosComputerName(const String& s);



NetbiosValidationResult
ValidateNetbiosDomainName(const String& s);



// Inserts a value into the end of the container (by calling push_back on the
// container) iff the value is not already present in the container.  Returns
// true if the value was inserted, or false if it was not.
// 
// Container - class that supports methods begin() and end(), which return
// forward iterators positioned in the usual STL fashion, and push_back.  Also
// must support a nested typedef named value_type indicating the type of
// values that the container contains.
// 
// c - the container
// 
// value - the value to conditionally insert

template <class Container>
bool
push_back_unique(Container& c, const Container::value_type& value)
{
   bool result = false;
   if (std::find(c.begin(), c.end(), value) == c.end())
   {
      // value is not already present, so push it onto the end

      c.push_back(value);
      result = true;
   }

   return result;
}



#endif   // UTILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\stacktr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// stack backtracing stuff
//
// 22-Nov-1999 sburns (refactored)



namespace Burnslib
{
   
namespace StackTrace
{
   const size_t MODULE_NAME_MAX = 32;
   const size_t SYMBOL_NAME_MAX = 256;



   // This should be called when stack tracing facilities are no longer
   // needed.

   void
   Cleanup();



   // Fill the provided array with a stack backtrace, starting with the
   // code address indicated by the context structure supplied.
   // 
   // This version is suited for use in an SEH exception handler to determine
   // the call stack at the point at which an exception was raised.
   //
   // Example:
   //
   // DWORD64 stackTrace[TRACE_MAX];
   // size_t traceMax = TRACE_MAX;
   // 
   // __try
   // {
   //    // call some code that might raise an SEH exception
   // }
   // __except(
   //    Burnslib::StackTrace::TraceFilter(
   //       stackTrace,
   //       traceMax,
   //       (GetExceptionInformation())->ContextRecord))
   // {
   //    // for each element in stackTrace, call
   //    // Burnslib::StackTrace::LookupAddress
   // }      
   //
   // Each element is an address that can be used to obtain a corresponding
   // module, function name, line number and source file name (or a subset of
   // that information, depending on the debugging symbol information
   // available), from the LookupAddress function.
   // Returns EXCEPTION_EXECUTE_HANDLER
   //
   // stackTrace - the array to receive the addresses.
   // 
   // traceMax - the maximum number of stack frames to traverse.  The
   // stackTrace array must be able to hold at least this many elements.
   // If the depth of the call stack is less than traceMax, then the
   // remaining elements are 0.

   DWORD
   TraceFilter(
      DWORD64  stackTrace[],
      size_t   traceMax,    
      CONTEXT* context);    



   // Fill the provided array with a stack backtrace, starting with the
   // invoker of this function.
   //
   // Each element is an address that can be used to obtain a corresponding
   // module, function name, line number and source file name (or a subset of
   // that information, depending on the debugging symbol information
   // available), from the LookupAddress function.
   // 
   // stackTrace - the array to receive the addresses.
   // 
   // traceMax - the maximum number of stack frames to traverse.  The
   // stackTrace array must be able to hold at least this many elements.
   // If the depth of the call stack is less than traceMax, then the
   // remaining elements are 0.

   void
   Trace(DWORD64 stackTrace[], size_t traceMax);



   // Resolves an address obtained by Trace.  ::SymSetOptions and
   // ::SymInitialize must have been called at some point before this
   // function is called.
   // 
   // traceAddress - the address to resolve.
   // 
   // moduleName - address of an array of char to receieve the name of the
   // module to which the address originates, or 0.  The array must be able
   // to hold MODULE_NAME_MAX bytes.
   // 
   // fullImageName - address of an array of char to receive the full path
   // name of the binary file from which the module was loaded, or 0.  The
   // array must be able to hold MAX_PATH bytes.
   // 
   // symbolName - address of an array of char to receive the undecorated
   // name of the function corresponding to the address, or 0.  The array
   // must be able to hold SYMBOL_NAME_MAX bytes.
   // 
   // displacement - address of a DWORD to receive the byte offset from the
   // beginning of the function that corresponds to the address, or 0.
   // 
   // line - address of a DWORD to receive the line number in the source of
   // the code that corresponds to the instruction at the displacement
   // offset of the function, or 0.
   // 
   // fullpath - address of an array of char to receive the full name of
   // the source code file that defines the function corresponding to the
   // address, or 0.  The array must be able to hold MAX_PATH bytes.

   void
   LookupAddress(
      DWORD64  traceAddress,   
      char     moduleName[],   
      char     fullImageName[],
      char     symbolName[],    // must be SYMBOL_NAME_MAX bytes
      DWORD64* displacement,   
      DWORD*   line,           
      char     fullpath[]);     // must be MAX_PATH bytes



   // Calls LookupAddress and fills in the blanks
   //
   // %1 - module name
   // %2 - symbol name
   // %3 - source full path
   // %4 - line number

   String
   LookupAddress(
      DWORD64 traceAddress,
      const wchar_t* format = L"%1%!%2 %3(%4!d!)");

}  // namespace StackTrace



}  // namespace Burnslib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\string.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Enhancement of std::basic_string; Windows-aware version
// 
// 8-14-97 sburns



// Users of this class should assume that none of the member functions here
// are threadsafe: that is, that concurrent calls to member functions on the
// same instance are not guaranteed to produce correct results.  The static
// class functions are, however, threadsafe.



typedef
   std::basic_string<
      char,
      std::char_traits<char>,
      Burnslib::Heap::Allocator<char> >
   AnsiString;



typedef
   std::basic_string<
      wchar_t,
      std::char_traits<wchar_t>,
      Burnslib::Heap::Allocator<wchar_t> >
   StringBase;



class String : public StringBase
{
   public:

   typedef StringBase base;

   // contructor pass-thrus: we support all of the constructors of the
   // base class.

   explicit String()
      :
      base()
   {
   }

   //lint -e(1931) allow implicit type conversion with this ctor

   String(const base& x)
      :
      base(x)
   {
   }

   String(const String& x, base::size_type p, base::size_type m)
      :
      base(x, p, m)
   {
   }

   String(base::const_pointer s, base::size_type n)
      :
      base(s, n)
   {
   }

   //lint -e(1931) allow implicit type conversion with this ctor

   String(base::const_pointer s)
      :
      base(s)
   {
   }

   String(base::size_type n, base::value_type c)
      :
      base(n, c)
   {
   }

   String(base::const_iterator f, base::const_iterator l)
      :
      base(f, l)
   {
   }


   //
   // Enhancements to the base class std::base
   //



   // conversion from ANSI to Unicode

   String(PCSTR lpsz);
   String(const AnsiString& s);



   // Same as compare, except case is ignored.

   int
   icompare(const String& str) const;



   // returns true if the string consists entirely of digits, false
   // otherwise.

   bool
   is_numeric() const;
      


   // Overload of the replace() family of methods.  Replaces all occurrances
   // of the substring 'from' with the string 'to'.  Returns *this.  All
   // characters of the string are examined exactly once.  If the replacement
   // results in the creation of new occurrances of the 'from' substring,
   // these are not reconsidered.
   //   
   // from - The substring to be replaced.  If 'from' is the empty string,
   // then no change is made.
   //   
   // to - The string to replace 'from'.  If 'to' is the empty string, then
   // all occurrances of 'from' are removed from the string.

   //lint -e(1511) we are properly overloading base::replace

   String&
   replace(const String& from, const String& to);



   enum StripType
   {
      LEADING = 0x01,
      TRAILING = 0x02,
      BOTH = LEADING | TRAILING
   };

   // Removes all consecutive occurrances of a given character from one or
   // more ends of the string.  Returns *this.

   String&
   strip(
      StripType type = TRAILING,
      wchar_t charToStrip = L' ');



   // Converts all lower case characters of the string to upper case.  Returns
   // *this.

   String&
   to_upper();



   // Converts all upper case characters of the string to lower case.  Returns
   // *this.

   String&
   to_lower();



   // Copy the string into an OLESTR that has been allocated with
   // CoTaskMemAlloc, which the caller is responsible for deleting with
   // CoTaskMemFree.  Returns S_OK on success, E_OUTOFMEMORY if CoTaskMemAlloc
   // fails.
   //       
   // oleString - where to place the allocated copy.

   HRESULT
   as_OLESTR(LPOLESTR& oleString) const;



   enum ConvertResult
   {
      CONVERT_SUCCESSFUL,
      CONVERT_FAILED,
      CONVERT_OVERFLOW,
      CONVERT_UNDERFLOW,
      CONVERT_OUT_OF_MEMORY,
      CONVERT_BAD_INPUT,
      CONVERT_BAD_RADIX
   };

   // Converts the string from Unicode to the ANSI character set, for as many
   // characters as this can be done.  See the restrictions for
   // WideCharToMultiByte.
   //   
   // ansi - the string (i.e. basic_string<char>) in which the result is
   // placed.  If the conversion fails, this is set to the empty string.

   ConvertResult
   convert(AnsiString& ansi) const;



   // For all numeric converions, the string is expected in the following
   // form:
   // 
   // [whitespace] [{+ | }] [0 [{ x | X }]] [digits]
   // 
   // whitespace may consist of space and tab characters, which are ignored;
   // 
   // digits are one or more decimal digits. The first character that does not
   // fit this form stops the scan.
   // 
   // The default radix for the conversion is 10 (decimal).  If radix is 0,
   // then the the initial characters of the string are used to determine the
   // radix for which the digits are to be interpreted. If the first character
   // is 0 and the second character is not 'x' or 'X', the string is
   // interpreted as an octal integer; otherwise, it is interpreted as a
   // decimal number. If the first character is '0' and the second character
   // is 'x' or 'X', the string is interpreted as a hexadecimal integer. If
   // the first character is '1' through '9', the string is interpreted as a
   // decimal integer. The letters 'a' through 'z' (or 'A' through 'Z') are
   // assigned the values 10 through 35; only letters whose assigned values
   // are less than the radix are permitted.  The radix must be within the
   // range from 2 to 36, or the conversion will fail with an error
   // CONVERT_BAD_RADIX, and the result parameter is set to 0.
   //
   // If any additional, unrecognized characters appear in the string, the
   // conversion will fail with an error CONVERT_BAD_INPUT, and the result
   // parameter is set to 0.
   // 
   // If the conversion would produce a result too large or too small for the
   // target type, then the conversion fails with error CONVERT_OVERFLOW or
   // CONVERT_UNDERFLOW, and the result parameter is set to 0.
   // 
   // Conversions for unsigned types allow a plus (+) or minus (-) sign
   // prefix; a leading minus sign indicates that the result value is to be
   // negated.

   ConvertResult
   convert(short& s, int radix = 10) const;

   ConvertResult
   convert(unsigned short& us, int radix = 10) const;

   ConvertResult
   convert(int& i, int radix = 10) const;

   ConvertResult
   convert(long& l, int radix = 10) const;

   ConvertResult
   convert(unsigned& ui, int radix = 10) const;

   ConvertResult
   convert(unsigned long& ul, int radix = 10) const;

   ConvertResult
   convert(double& d) const;

   ConvertResult
   convert(LARGE_INTEGER& li) const;


   // Separates the tokens in the string and pushes them in left-to-right
   // order into the supplied container as a individual String instances. A
   // token is a sequence of characters separated by one or characters in the
   // set of delimiters.  Similar to the strtok function.  Returns the
   // number of tokens placed in the container.
   //
   // usage:
   // String s(L"a list of tokens");
   // StringList tokens;
   // size_t token_count = s.tokenize(back_inserter(tokens));
   // ASSERT(token_count == tokens.size())

   template <class BackInsertableContainer>
   size_t
   tokenize(
      std::back_insert_iterator<BackInsertableContainer>& bii,
      const String& delimiters = String(L" \t") ) const
   {
      size_t tokenCount = 0;
      size_type p1 = 0;

      while (1)
      {
         p1 = find_first_not_of(delimiters, p1);
         if (p1 == npos)
         {
            // no more tokens

            break;
         }
         size_type p2 = find_first_of(delimiters, p1 + 1);
         if (p2 == npos)
         {
            // this is the last token

            *bii++ = substr(p1);
            ++tokenCount;
            break;
         }

         // the region [p1..(p2 - 1)] is a token

         *bii++ = substr(p1, p2 - p1);
         ++tokenCount;
         p1 = p2 + 1;
      }

      return tokenCount;
   }



   //
   // static functions 
   //



   // Returns the string resource as a new instance.
   // 
   // resID - resource ID of the string resource to load.

   static
   String
   load(unsigned resId, HINSTANCE hInstance = 0);

   inline 
   static
   String
   load(int resId, HINSTANCE hInstance = 0)
   {
      return String::load(static_cast<unsigned>(resId), hInstance);
   }



   // FormatMessage-style formatted output.

#if defined(ALPHA) || defined(IA64)
//lint -e(1916)   it's ok to use elipsis here
   static
   String __cdecl
   String::format(
      const String& fmt,
      ...);
#else

   // the x86 compiler won't allow the first parameter to be a reference
   // type.  This is a compiler bug.

//lint -e(1916)   it's ok to use elipsis here

   static
   String __cdecl
   String::format(
      const String fmt,
      ...);
#endif

   static
   String __cdecl
   format(const wchar_t* qqfmt, ...);

//lint -e(1916)   it's ok to use elipsis here
   static 
   String __cdecl
   format(unsigned formatResID, ...);

   static 
   String __cdecl
   format(int formatResID, ...);


   //
   // STL support 
   //



   // Function object class for performing case-insensive comparisons of
   // Strings.  Can be used with any STL template involving binary_function.

   class EqualIgnoreCase
      :
      public std::binary_function<String, String, bool>
   {
      public:

      // Returns true if f and s are equal, ignoring case in the comparison

      inline
      bool
      operator()(
         const first_argument_type&  f,
         const second_argument_type& s) const
      {
         return (f.icompare(s) == 0);
      }
   };

   class LessIgnoreCase
      :
      public std::binary_function<String, String, bool>
   {
      public:

      // Returns true if f is less than s, ignoring case in the comparison

      inline
      bool
      operator()(
         const first_argument_type&  f,
         const second_argument_type& s) const
      {
         return (f.icompare(s) < 0);
      }
   };



   private:

   // Causes this to control a distinct copy of the string, without any shared
   // references.

   void
   _copy();

   void
   assignFromAnsi(PCSTR lpsz, size_t len);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\win.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Wrappers of Win APIs
// 
// 8-14-97 sburns



#ifndef WIN_HPP_INCLUDED
#define WIN_HPP_INCLUDED



// Wrappers of Win32 APIs, doing such nice things as taking Strings
// as parameters, asserting parameters and return values, assuming
// certain parameters such as resource instance handles, and other
// stuff.
// 
// Each function name is identical to the API function it wraps.

namespace Burnslib
{
   
namespace Win
{
   // Win::Error is a subclass of ::Error that automatically maps
   // error codes to message strings, pulling the strings string from
   // various windows system resources.

   class Error : public ::Error
   {
      public:

      // Constructs a new instance.
      // 
      // hr - The HRESULT to keep track of.
      // 
      // summaryResID - ID of the string resource that corresponds to
      // the summary text to be returned by GetSummary().

      Error(HRESULT hr, int summaryResID);



      virtual
      ~Error()
      {
      }


      
      // Overrides the default windows message text.
      //
      // hr - The HRESULT to keep track of.
      //
      // message - The error message that will be returned by calls to
      // GetMessage.
      //
      // summary - the string that will be returned by calls to GetSummary

      Error(HRESULT hr, const String& message, const String& summary);

      HRESULT
      GetHresult() const;

      // Returns the HelpContext that will point the user to
      // assistance in deciphering the error message and details.  For
      // this implementation, this is just the HRESULT parameter
      // passed to the ctor.

      virtual 
      HelpContext
      GetHelpContext() const;

      // Returns the human readable error message from the system
      // error message string table(s).

      virtual 
      String
      GetMessage() const;

      // returns a 1-line summary: The essence of the error, suitable
      // for use as the title of a reporting dialog, for instance.

      virtual 
      String
      GetSummary() const;

      const Error& operator=(const Error& rhs);

      private:

      HRESULT        hr;            
      mutable String message;
      mutable String summary;
      int            summaryResId;
   };



   // A CursorSetting is a convenient trick to change the cursor only
   // for the lifetime of a single code block.  When an instance is
   // constructed, the cursor is changed.  When it is destroyed, the
   // old cursor is restored.
   //
   // Example:
   //
   // {  // open block scope
   //   Win::CursorSetting scope(IDC_WAIT);
   //   // the cursor is now IDC_WAIT
   //
   //   // do something time consuming
   // }  // close block scope
   // // scope destroyed; the cursor is restored to what it was before

   // NOTE: not threadsafe: do not use the same CursorSetting object from
   // multiple threads.
      
   class CursorSetting
   {
      public:

      // Construct a new instance with the named cursor resource.

      explicit
      CursorSetting(const String& newCursorName);

      // MAKEINTRESOURCE version

      explicit
      CursorSetting(
         const TCHAR* newCursorName,
         bool         isSystemCursor = true);

      // Construct a new instance from a valid HCURSOR.
      explicit
      CursorSetting(HCURSOR newCursor);

      ~CursorSetting();

      private:

      HCURSOR oldCursor;

      void init(
         const TCHAR* cursorName,
         bool         isSystemCursor = true);

      // these are not defined

      CursorSetting(const CursorSetting&);
      const CursorSetting& operator=(const CursorSetting&);
   };



   class WaitCursor : public CursorSetting
   {
      public:

      WaitCursor()
         :
         CursorSetting(IDC_WAIT)
      {
      }

      private:

      // these are not defined

      WaitCursor(const WaitCursor&);
      const WaitCursor& operator=(const WaitCursor&);
   };



   HRESULT
   AdjustTokenPrivileges(
      HANDLE             tokenHandle,
      bool               disableAllPrivileges,
      TOKEN_PRIVILEGES   newState[],
      DWORD              bufferLength,
      TOKEN_PRIVILEGES*  previousState,
      DWORD*             returnLength);

   HRESULT
   AllocateAndInitializeSid(
      SID_IDENTIFIER_AUTHORITY&  authority,
      BYTE                       subAuthorityCount,
      DWORD                      subAuthority0,
      DWORD                      subAuthority1,
      DWORD                      subAuthority2,
      DWORD                      subAuthority3,
      DWORD                      subAuthority4,
      DWORD                      subAuthority5,
      DWORD                      subAuthority6,
      DWORD                      subAuthority7,
      PSID&                      sid);

#undef Animate_Open

   void
   Animate_Open(HWND animation, const TCHAR* animationNameOrRes);

#undef Animate_Stop

   void
   Animate_Stop(HWND animation);

   HRESULT
   AppendMenu(
      HMENU    menu,     
      UINT     flags,    
      UINT_PTR idNewItem,
      PCTSTR   newItem);

#undef Button_SetCheck

   void
   Button_SetCheck(HWND button, int checkState);

#undef Button_GetCheck

   bool
   Button_GetCheck(HWND button);

#undef Button_SetStyle

   void
   Button_SetStyle(HWND button, int style, bool redraw);

   void
   CheckDlgButton(HWND parentDialog, int buttonID, UINT buttonState);

   void
   CheckRadioButton(
      HWND  parentDialog,
      int   firstButtonInGroupID,
      int   lastButtonInGroupID,
      int   buttonInGroupToCheckID);



   // sets the handle to INVALID_HANDLE_VALUE

   void
   CloseHandle(HANDLE& handle);



   void
   CloseServiceHandle(SC_HANDLE handle);

#undef ComboBox_AddString

   int
   ComboBox_AddString(HWND combo, const String& s);



   // Adds all of the strings in the range defined by the provided iterators
   // to the combo box control, and returns the 0-based index of the last
   // string added.  Returns CB_ERR if an error occurred, or CB_ERRSPACE if
   // insufficient space is available to add the string.
   // 
   // Each element is added in the sequence provided by the iterators.  If an
   // error is encountered, the iteration stops, and the error value is
   // returned.  In other words, remaining elements in the iteration are
   // skipped.
   // 
   // Each element must be a String, or a type convertible to String (PWSTR,
   // etc.)
   // 
   // combo - a HWND for a combo box.
   //    
   // first - a forward iterator set to the first element in the sequence to
   // be added to the combo box.
   // 
   // last - a forward iterator set to just beyond the last element of the
   // sequence.
   // 
   // Example:
   // 
   // StringList fooStrings;
   // fooStrings.push_back(L"hello");
   // fooStrings.push_back(L"world");
   // 
   // int err =
   //    Win::ComboBox_AddStrings(
   //       combo,
   //       fooStrings.begin(),
   //       fooStrings.end());

   template<class ForwardIterator>
   int
   ComboBox_AddStrings(
      HWND              combo,
      ForwardIterator   first,
      ForwardIterator   last)
   {
      ASSERT(Win::IsWindow(combo));

      int err = CB_ERR;
      for (

         // copy the iterators so as not to modify the actual parameters

         ForwardIterator f = first, l = last;
         f != l;
         ++f)
      {
         err = Win::ComboBox_AddString(combo, *f);
         if (err == CB_ERR || err == CB_ERRSPACE)
         {
            break;
         }
      }

      return err;
   }



#undef ComboBox_GetCurSel

   int
   ComboBox_GetCurSel(HWND combo);

   // Retrieves the text of the selected item in the list box of the combo
   // or empty if no item is selected.

   String
   ComboBox_GetCurText(HWND combo);

#undef ComboBox_GetLBText

   String
   ComboBox_GetLBText(HWND combo, int index);

#undef ComboBox_GetLBTextLen

   int
   ComboBox_GetLBTextLen(HWND combo, int index);

#undef ComboBox_SelectString

   int
   ComboBox_SelectString(HWND combo, const String& str);

#undef ComboBox_SetCurSel

   void
   ComboBox_SetCurSel(HWND combo, int index);

   int
   CompareString(
      LCID  locale,
      DWORD flags,
      const String& string1,
      const String& string2);

   HRESULT
   ConnectNamedPipe(
      HANDLE      pipe,
      OVERLAPPED* overlapped);

   HRESULT
   ConvertSidToStringSid(PSID sid, String& result);

   HRESULT
   CopyFileEx(
      const String&        existingFileName,
      const String&        newFileName,
      LPPROGRESS_ROUTINE   progressRoutine,
      void*                progressParam,
      BOOL*                cancelFlag,
      DWORD                flags);

   HRESULT
   CopySid(DWORD destLength, PSID dest, PSID source);
      
   HRESULT
   CreateDialogParam(
      HINSTANCE      hInstance,	
      const TCHAR*   templateName,
      HWND           owner,
      DLGPROC        dialogProc,
      LPARAM         param,
      HWND&          result);

   HRESULT
   CreateDirectory(const String& path);

   HRESULT
   CreateEvent(
      SECURITY_ATTRIBUTES* securityAttributes,
      bool                 manualReset,
      bool                 initiallySignaled,
      HANDLE&              result);

   HRESULT
   CreateEvent(
      SECURITY_ATTRIBUTES* securityAttributes,
      bool                 manualReset,
      bool                 initiallySignaled,
      const String&        name,
      HANDLE&              result);

   HRESULT
   CreateFile(
      const String&        fileName,
      DWORD                desiredAccess,	
      DWORD                shareMode, 
      SECURITY_ATTRIBUTES* securityAttributes,	
      DWORD                creationDistribution,
      DWORD                flagsAndAttributes,
      HANDLE               hTemplateFile,
      HANDLE&              result);

   HRESULT
   CreateFontIndirect(
      const LOGFONT& logFont,
      HFONT&         result);

   HRESULT
   CreateMailslot(
      const String&        name,
      DWORD                maxMessageSize,
      DWORD                readTimeout,
      SECURITY_ATTRIBUTES* attributes,
      HANDLE&              result);

   HRESULT
   CreateMutex(
      SECURITY_ATTRIBUTES* attributes,
      bool                 isInitialOwner,
      const String&        name,
      HANDLE&              result);

   HRESULT
   CreateNamedPipe(
      const String&        name,
      DWORD                openMode,
      DWORD                pipeMode,
      DWORD                maxInstances,
      DWORD                outBufferSizeInBytes,
      DWORD                inBufferSizeInBytes,
      DWORD                defaultTimeout,
      SECURITY_ATTRIBUTES* sa,
      HANDLE&              result);

   HRESULT
   CreatePopupMenu(HMENU& result);

#undef CreateProcess
      
   HRESULT
   CreateProcess(
      String&              commandLine,
      SECURITY_ATTRIBUTES* processAttributes,
      SECURITY_ATTRIBUTES* threadAttributes,
      bool                 inheritHandles,
      DWORD                creationFlags,
      void*                environment,
      const String&        currentDirectory,
      STARTUPINFO&         startupInformation,
      PROCESS_INFORMATION& processInformation);

   HRESULT
   CreatePropertySheetPage(
      const PROPSHEETPAGE& pageInfo,
      HPROPSHEETPAGE&      result);

   HRESULT
   CreateSolidBrush(
      COLORREF color,
      HBRUSH&  result);
      
   HRESULT
   CreateStreamOnHGlobal(
      HGLOBAL     hglobal,
      bool        deleteOnRelease,
      IStream*&   result);
      
   HRESULT
   CreateWindowEx(
      DWORD          exStyle,      
      const String&  className,
      const String&  windowName,
      DWORD          style,
      int            x,
      int            y,
      int            width,
      int            height,
      HWND           parent,
      HMENU          menuOrChildID,
      void*          param,
      HWND&          result);

   HRESULT
   DeleteFile(const String& path);

   // object is set to 0

   HRESULT
   DeleteObject(HGDIOBJ& object);

   HRESULT
   DeleteObject(HFONT& object);

   HRESULT
   DeleteObject(HBITMAP& object);
   
   // icon is set to 0

   HRESULT
   DestroyIcon(HICON& icon);

   // menu is set to 0

   HRESULT
   DestroyMenu(HMENU& menu);
      
   // page is set to 0

   HRESULT
   DestroyPropertySheetPage(HPROPSHEETPAGE& page);
      
   // window is set to 0

   HRESULT
   DestroyWindow(HWND& window);
         
   INT_PTR
   DialogBoxParam(
      HINSTANCE      hInstance,	
      const TCHAR*   templateName,
      HWND           owner,
      DLGPROC        dialogProc,
      LPARAM         param);



   HRESULT
   DisconnectNamedPipe(HANDLE pipe);

   HRESULT
   DrawFocusRect(HDC dc, const RECT& rect);

   // appends text to the contents of an edit control.
   //
   // editbox - HWND of the edit control
   //
   // text - text to append.  Must not be empty.
   //
   // preserveSelection - true to keep any active selection, false to move
   // the care to the end of the appended text.
   //
   // canUndo - true to allow undo of the append, false if not.

   void
   Edit_AppendText(
      HWND           editbox,
      const String&  text,
      bool           preserveSelection = true,
      bool           canUndo = true);

#undef Edit_GetSel

   void
   Edit_GetSel(HWND editbox, int& start, int& end);
         
#undef Edit_LimitText

   void
   Edit_LimitText(HWND editbox, int limit);

#undef Edit_ReplaceSel

   void
   Edit_ReplaceSel(HWND editbox, const String& newText, bool canUndo);
      
#undef Edit_SetSel

   void
   Edit_SetSel(HWND editbox, int start, int end);

   bool
   EqualSid(PSID sid1, PSID sid2);
         
   void
   EnableWindow(HWND window, bool state);

   HRESULT
   EndDialog(HWND dialog, int result);

#undef EnumUILanguages

   HRESULT
   EnumUILanguages(
      UILANGUAGE_ENUMPROCW proc,
      DWORD                flags,
      LONG_PTR             lParam);

   HRESULT
   ExitWindowsEx(UINT options);

   // expands strings in s, returns s on failure, expanded version on
   // success.

   String
   ExpandEnvironmentStrings(const String& s);
      
   HRESULT
   FindFirstFile(
      const String&     fileName,
      WIN32_FIND_DATA&  data,
      HANDLE&           result);
      
   HRESULT
   FindClose(HANDLE& findHandle);

   HRESULT
   FindNextFile(HANDLE& findHandle, WIN32_FIND_DATA& data);

   HRESULT
   FlushFileBuffers(HANDLE handle);

   HRESULT
   FrameRect(HDC dc, const RECT& rect, HBRUSH brush);

   HRESULT
   FreeLibrary(HMODULE& module);

   void
   FreeSid(PSID sid);

   // used to free the result returned by Win::GetTokenInformation
                  
   void
   FreeTokenInformation(TOKEN_USER* userInfo);
   
   HWND
   GetActiveWindow();

   // for Windows pre-defined classes.
         
   HRESULT
   GetClassInfoEx(const String& className, WNDCLASSEX& info);

   HRESULT
   GetClassInfoEx(
      HINSTANCE      hInstance,
      const String&  className,
      WNDCLASSEX&    info);

   String
   GetClassName(HWND window);

   String
   GetClipboardFormatName(UINT format);

   HRESULT
   GetClientRect(HWND window, RECT& rect);

   HRESULT
   GetColorDepth(int& result);

   String
   GetCommandLine();

   // Inserts the command line arguments of the current process into the
   // provided list.  The list is not cleared beforehand.  The list is similar
   // to the traditional argv array.  Returns the number of args inserted.
   //
   // Use instead of ::GetCommandLine, ::ComandLineToArgVW.
   //
   // BackInsertionSequence - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // bii - a reference to a back_insert_iterator of the
   // BackInsertionSequence template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // int argCount = Win::GetCommandLineArgs(std::back_inserter(container));
   //
   // StringVector container;
   // int argCount = Win::GetCommandLineArgs(std::back_inserter(container));

   template <class BackInsertableContainer>
   int
   GetCommandLineArgs(
      std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      PWSTR* clArgs   = 0;
      int    argCount = 0;
      int    retval   = 0;

      clArgs =
         ::CommandLineToArgvW(Win::GetCommandLine().c_str(), &argCount);
      ASSERT(clArgs);
      if (clArgs)
      {
         for (retval = 0; retval < argCount; retval++)
         {
            // the container values can be any type that can be constructed
            // from PWSTR...

            //lint --e(*)  lint does not grok back_insert_iterator
            *bii++ = clArgs[retval];
         }

         Win::LocalFree(clArgs);
      }

      ASSERT(argCount == retval);

      return retval;
   }

   // HRESULT
   // GetComputerNameEx(COMPUTER_NAME_FORMAT format, String& result);

   String
   GetComputerNameEx(COMPUTER_NAME_FORMAT format);

   HRESULT
   GetCurrentDirectory(String& result);

   HANDLE
   GetCurrentProcess();
   
   HRESULT
   GetCursorPos(POINT& result);

   HRESULT
   GetDC(HWND window, HDC& result);

   int
   GetDeviceCaps(HDC hdc, int index);

   HWND
   GetDesktopWindow();

   HRESULT
   GetDiskFreeSpaceEx(
      const String&     path,
      ULARGE_INTEGER&   available,
      ULARGE_INTEGER&   total,
      ULARGE_INTEGER*   free);
      
   HWND
   GetDlgItem(HWND parentDialog, int itemResID);

   String
   GetDlgItemText(HWND parentDialog, int itemResID);

   int
   GetDlgItemInt(HWND parentDialog, int itemResID, bool isSigned = false);

   UINT
   GetDriveType(const String& path);

   EncodedString
   GetEncodedDlgItemText(HWND parentDialog, int itemResID);

   String
   GetEnvironmentVariable(const String& name);

   HRESULT
   GetExitCodeProcess(HANDLE hProcess, DWORD& exitCode);

   HRESULT
   GetFileAttributes(const String& path, DWORD& result);

   HRESULT
   GetFileSizeEx(HANDLE handle, LARGE_INTEGER& result);

   DWORD
   GetFileType(HANDLE handle);
            
   // DWORD
   // GetLastError();

   HRESULT
   GetFullPathName(const String& path, String& result);

   HRESULT
   GetLastErrorAsHresult();

   void
   GetLocalTime(SYSTEMTIME& time);

   HRESULT
   GetLogicalDriveStrings(size_t bufChars, TCHAR* buf, DWORD& result);

   HRESULT
   GetMailslotInfo(
      HANDLE   mailslot,
      DWORD*   maxMessageSize,
      DWORD*   nextMessageSize,
      DWORD*   messageCount,
      DWORD*   readTimeout);

   String
   GetModuleFileName(HMODULE hModule);

   // of this process exe

   HINSTANCE
   GetModuleHandle();

   HWND
   GetParent(HWND child);

   String
   GetPrivateProfileString(
      const String& section,
      const String& key,
      const String& defaultValue,
      const String& filename);

   HRESULT
   GetProcAddress(HMODULE module, const String& procName, FARPROC& result);

   HRESULT
   GetStringTypeEx(
      LCID           localeId,
      DWORD          infoTypeOptions,
      const String&  sourceString,
      WORD*          charTypeInfo);

   HRESULT
   GetSysColor(int element, DWORD& result);

   // returns %systemroot%\system32

   String
   GetSystemDirectory();

   void
   GetSystemInfo(SYSTEM_INFO& info);

   // returns %systemroot%, always (even under terminal server).

   String
   GetSystemWindowsDirectory();

//    // returns %systemroot%, always
// 
//    String
//    GetSystemRootDirectory();

   int
   GetSystemMetrics(int index);

#undef GetTempPath
   
   HRESULT
   GetTempPath(String& result);
         
   HRESULT
   GetTextExtentPoint32(HDC hdc, const String& string, SIZE& size);

   HRESULT
   GetTextMetrics(HDC hdc, TEXTMETRIC& tm);

   // free the result with Win::FreeTokenInformation.
   //
   // allocates the result and returns it thru userInfo.
      
   HRESULT
   GetTokenInformation(HANDLE hToken, TOKEN_USER*& userInfo);

   // ... other varations of GetTokenInformation could be defined for
   // other infomation classes...
   
   // trims off leading and trailing whitespace

   String
   GetTrimmedDlgItemText(HWND parentDialog, int itemResID);

   // trims off leading and trailing whitespace

   String
   GetTrimmedWindowText(HWND window);

   HRESULT
   GetVersionEx(OSVERSIONINFO& info);

   HRESULT
   GetVersionEx(OSVERSIONINFOEX& info);

   HRESULT
   GetVolumeInformation(
      const String&  volume,
      String*        name,
      DWORD*         serialNumber,
      DWORD*         maxFilenameLength,
      DWORD*         flags,
      String*        fileSystemName);

   HRESULT
   GetWindowDC(HWND window, HDC& result);

#undef GetWindowFont

   HFONT
   GetWindowFont(HWND window);

   HRESULT
   GetWindowPlacement(HWND window, WINDOWPLACEMENT& placement);

   HRESULT
   GetWindowRect(HWND window, RECT& rect);

   // returns %windir%, which may vary for terminal server users.

   String
   GetWindowsDirectory();

#undef GetWindowLong

   HRESULT
   GetWindowLong(HWND window, int index, LONG& result);

#undef GetWindowLongPtr

   HRESULT
   GetWindowLongPtr(HWND window, int index, LONG_PTR& result);

   String
   GetWindowText(HWND window);

   HRESULT
   GlobalAlloc(UINT flags, size_t bytes, HGLOBAL& result);

   HRESULT
   GlobalFree(HGLOBAL mem);

   HRESULT
   GlobalLock(HGLOBAL mem, PVOID& result);

   HRESULT
   GlobalUnlock(HGLOBAL mem);

   void
   HtmlHelp(
      HWND           caller,
      const String&  file,
      UINT           command,
      DWORD_PTR      data);

#undef ImageList_Add

   int
   ImageList_Add(HIMAGELIST list, HBITMAP image, HBITMAP mask);

#undef ImageList_AddIcon

   int
   ImageList_AddIcon(HIMAGELIST list, HICON icon);

#undef ImageList_AddMasked

   int
   ImageList_AddMasked(HIMAGELIST list, HBITMAP bitmap, COLORREF mask);

   HIMAGELIST
   ImageList_Create(
      int      pixelsx, 	
      int      pixelsy, 	
      UINT     flags, 	
      int      initialSize, 	
      int      reserve);

   HRESULT
   InitializeSecurityDescriptor(SECURITY_DESCRIPTOR& sd);

   LONG
   InterlockedDecrement(LONG& addend);

   LONG
   InterlockedIncrement(LONG& addend);

   bool
   IsDlgButtonChecked(HWND parentDialog, int buttonResID);

   // returns true if the name matches one of the local computer's names
   // (case insensitive)

   bool
   IsLocalComputer(const String& computerName);    

   bool
   IsWindow(HWND candidate);

   bool
   IsWindowEnabled(HWND window);
   
#undef ListBox_AddString

   int
   ListBox_AddString(HWND box, const String& s);

#undef ListBox_SetItemData

   int
   ListBox_SetItemData(HWND box, int index, LPARAM value);

#undef ListBox_GetItemData

   LPARAM
   ListBox_GetItemData(HWND box, int index);

#undef ListBox_SetCurSel

   int
   ListBox_SetCurSel(HWND box, int index);

#undef ListBox_GetCurSel

   int
   ListBox_GetCurSel(HWND box);

#undef ListView_DeleteItem

   bool
   ListView_DeleteItem(HWND listview, int item);

#undef ListView_GetItem

   bool
   ListView_GetItem(HWND listview, LVITEM& item);

#undef ListView_GetItemCount

   int
   ListView_GetItemCount(HWND listview);

#undef ListView_GetItemState

   UINT
   ListView_GetItemState(HWND listview, int index, UINT mask);

#undef ListView_GetSelectedCount

   int
   ListView_GetSelectedCount(HWND listview);

#undef ListView_GetSelectionMark

   int
   ListView_GetSelectionMark(HWND listview);

#undef ListView_InsertColumn

   int
   ListView_InsertColumn(HWND listview, int index, const LVCOLUMN& column);

#undef ListView_InsertItem

   int
   ListView_InsertItem(HWND listview, const LVITEM& item);
      
#undef ListView_SetImageList

   HIMAGELIST
   ListView_SetImageList(HWND listview, HIMAGELIST images, int type);

#undef ListView_SetItem

   void
   ListView_SetItem(HWND listview, const LVITEM& item);
      
#undef ListView_SetItemText

   void
   ListView_SetItemText(
      HWND listview, 
      int item, 
      int subItem, 
      const String& text);

   HRESULT
   LoadBitmap(unsigned resId, HBITMAP& result);
      
   HRESULT   
   LoadCursor(const String& cursorName, HCURSOR& result);

   // provided for MAKEINTRESOURCE versions of cursorName

   HRESULT
   LoadCursor(
      const TCHAR* cursorName,
      HCURSOR&     result,
      bool         isSystemCursor = true);

   HRESULT
   LoadIcon(int resID, HICON& result);

   HRESULT
   LoadImage(unsigned resID, unsigned type, HANDLE& result);

   HRESULT
   LoadImage(unsigned resID, HICON& result);

   HRESULT
   LoadImage(unsigned resID, HBITMAP& result);

   HRESULT
   LoadLibrary(const String& libFileName, HINSTANCE& result);
         
   HRESULT
   LoadLibraryEx(const String& libFileName, DWORD flags, HINSTANCE& result);

   HRESULT
   LoadMenu(unsigned resID, HMENU& result);

   // Loads from the module indicated by GetResourceModuleHandle()

   String
   LoadString(unsigned resID);

   String
   LoadString(unsigned resID, HINSTANCE hInstance);

   HRESULT
   LocalFree(HLOCAL mem);

   HRESULT
   LookupAccountSid(
      const String&  machineName,
      PSID           sid,
      String&        accountName,
      String&        domainName);

#undef LookupPrivilegeValue

   HRESULT
   LookupPrivilegeValue(
      const TCHAR* systemName,
      const TCHAR* privName,
      LUID& luid);

   HRESULT
   MapWindowPoints(
      HWND  from,
      HWND  to,
      RECT& rect,
      int*  dh = 0,      // number of pixels added to horizontal coord
      int*  dv = 0);     // number of pixels added to vertical coord

   int
   MessageBox(
      HWND           owner,
      const String&  text,
      const String&  title,
      UINT           flags);

   HRESULT
   MoveFileEx(
      const String& srcPath,
      const String& dstPath,
      DWORD         flags);

   HRESULT
   MoveWindow(
      HWND  window,
      int   x,
      int   y,
      int   width,
      int   height,
      bool  shouldRepaint);

   HRESULT
   OpenProcessToken(
      HANDLE   processHandle,
      DWORD    desiredAccess,
      HANDLE&  tokenHandle);

   HRESULT
   OpenSCManager(
      const String&  machine,
      DWORD          desiredAccess,
      SC_HANDLE&     result);

   HRESULT
   OpenService(
      SC_HANDLE      managerHandle,
      const String&  serviceName,
      DWORD          desiredAccess,
      SC_HANDLE&     result);

   void
   OutputDebugString(const String& string);

   HRESULT
   PeekNamedPipe(
      HANDLE pipe,                     
      void*  buffer,                   
      DWORD  bufferSize,               
      DWORD* bytesRead,                
      DWORD* bytesAvailable,           
      DWORD* bytesRemainingThisMessage);

   HRESULT
   PostMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam);

   HRESULT
   PropertySheet(PROPSHEETHEADER* header, INT_PTR& result);

#undef PropSheet_Changed

   void
   PropSheet_Changed(HWND propSheet, HWND page);

#undef PropSheet_Unchanged

   void
   PropSheet_Unchanged(HWND propSheet, HWND page);

#undef PropSheet_RebootSystem

   void
   PropSheet_RebootSystem(HWND propSheet);

#undef PropSheet_SetTitle

   void
   PropSheet_SetTitle(
      HWND propSheet,
      DWORD style,
      const String& title);
      
#undef PropSheet_SetWizButtons

   void
   PropSheet_SetWizButtons(HWND propSheet, DWORD buttonFlags);

   HRESULT
   QueryServiceStatus(
      SC_HANDLE       handle,
      SERVICE_STATUS& status);

   HRESULT
   ReadFile(
      HANDLE      file,
      void*       buffer,
      DWORD       bytesToRead,
      DWORD&      bytesRead,
      OVERLAPPED* overlapped);

   void
   ReleaseStgMedium(STGMEDIUM& medium);

   HRESULT
   RegCloseKey(HKEY hKey);

   HRESULT
   RegConnectRegistry(
      const String&  machine,
      HKEY           hKey,
      HKEY&          result);

   HRESULT
   RegCreateKeyEx(
      HKEY                 hKey,
      const String&        subkeyName,
      DWORD                options,
      REGSAM               access,
      SECURITY_ATTRIBUTES* securityAttrs,
      HKEY&                result,
      DWORD*               disposition);

   HRESULT
   RegDeleteValue(
      HKEY           hKey,
      const String&  valueName);

   HRESULT
   RegOpenKeyEx(
      HKEY           hKey,
      const String&  subKey,
      REGSAM         accessDesired,
      HKEY&          result);
      
   HRESULT
   RegQueryValueEx(
      HKEY           hKey,
      const String&  valueName,
      DWORD*         type,
      BYTE*          data,
      DWORD*         dataSize);

   HRESULT
   RegSetValueEx(
      HKEY           hKey,
      const String&  valueName,
      DWORD          type,
      const BYTE*    data,
      size_t         dataSize);

   HRESULT 
   RegisterClassEx(const WNDCLASSEX& wndclass, ATOM& result);

   CLIPFORMAT
   RegisterClipboardFormat(const String& name);

   void
   ReleaseDC(HWND window, HDC dc);

   HRESULT
   ReleaseMutex(HANDLE mutex);

   HRESULT
   RemoveDirectory(const String& path);

   inline
   HRESULT
   RemoveFolder(const String& path)
   {
      return Win::RemoveDirectory(path);
   }

   HRESULT
   ResetEvent(HANDLE event);

   HRESULT
   ScreenToClient(HWND window, POINT& point);

   HRESULT
   ScreenToClient(HWND window, RECT& rect);

   HGDIOBJ
   SelectObject(HDC hdc, HGDIOBJ hobject);
      
   LRESULT
   SendMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam);
  
   HRESULT
   SetComputerNameEx(COMPUTER_NAME_FORMAT format, const String& newName);

   HCURSOR
   SetCursor(HCURSOR newCursor);

   HRESULT   
   SetDlgItemText(
      HWND           parentDialog,
      int            itemResID,
      const String&  text);

   inline
   HRESULT   
   SetDlgItemText(
      HWND parentDialog,
      int  itemResID,   
      int  textResID)   
   {
      return
         Win::SetDlgItemText(
            parentDialog,
            itemResID,
            String::load(textResID));
   }

   HRESULT   
   SetDlgItemText(
      HWND                 parentDialog, 
      int                  itemResID,    
      const EncodedString& cypherText);
      
   HRESULT
   SetEvent(HANDLE event);

   HRESULT
   SetFilePointerEx(
      HANDLE               handle,
      const LARGE_INTEGER& distanceToMove,
      LARGE_INTEGER*       newPosition,
      DWORD                moveMethod);

   HWND
   SetFocus(HWND window);

   bool
   SetForegroundWindow(HWND window);

   HRESULT
   SetSecurityDescriptorDacl(
      SECURITY_DESCRIPTOR& sd,
      bool                 daclPresent,
      ACL*                 dacl,             // ptr not ref to allow null dacl
      bool                 daclDefaulted);

#undef SetWindowFont

   void
   SetWindowFont(HWND window, HFONT font, bool redraw);
      
#undef SetWindowLong

   HRESULT
   SetWindowLong(
      HWND  window,  
      int   index,   
      LONG  value,   
      LONG* oldValue = 0);

#undef SetWindowLongPtr

   HRESULT
   SetWindowLongPtr(
      HWND      window,   
      int       index,    
      LONG_PTR  value,    
      LONG_PTR* oldValue = 0);

   HRESULT
   SetWindowPos(
      HWND  window,
      HWND  insertAfter,
      int   x,
      int   y,
      int   width,
      int   height,
      UINT  flags);

   HRESULT
   SetWindowText(HWND window, const String& text);

   LPITEMIDLIST
   SHBrowseForFolder(BROWSEINFO& bi);

   HRESULT
   SHGetMalloc(LPMALLOC& pMalloc);

   String
   SHGetPathFromIDList(LPCITEMIDLIST pidl);
      
   HRESULT
   SHGetSpecialFolderLocation(
      HWND          hwndOwner, 	
      int           nFolder, 	
      LPITEMIDLIST& pidl);

   void
   ShowWindow(HWND window, int swOption);

   // 'Spin' is a synonym for 'Up-Down' control

   void
   Spin_GetRange(HWND spinControl, int* low, int* high);

   void
   Spin_SetRange(HWND spinControl, int low, int high);

   int
   Spin_GetPosition(HWND spinControl);

   void
   Spin_SetPosition(HWND spinControl, int position);


#undef Static_SetIcon

   void
   Static_SetIcon(HWND staticText, HICON icon);
  
   String
   StringFromCLSID(const CLSID& clsID);

   // inline synonym

   inline
   String
   CLSIDToString(const CLSID& clsID)
   {
      return StringFromCLSID(clsID);
   }

   String
   StringFromGUID2(const GUID& guid);

   // inline synonym

   inline
   String
   GUIDToString(const GUID& guid)
   {
      return StringFromGUID2(guid);
   }
      
   HRESULT
   SystemParametersInfo(
      UINT  action,
      UINT  param,
      void* vParam,
      UINT  WinIni);

   HRESULT 
   TlsAlloc(DWORD& result);

   HRESULT
   TlsFree(DWORD index);

   HRESULT
   TlsSetValue(DWORD index, PVOID value);

   HRESULT
   TlsGetValue(DWORD index, PVOID& result);

   HRESULT
   UpdateWindow(HWND winder);

   bool
   ToolTip_AddTool(HWND toolTip, TOOLINFO& info);

   bool
   ToolTip_GetToolInfo(HWND toolTip, TOOLINFO& info);

   bool
   ToolTip_SetTitle(HWND toolTip, int icon, const String& title);

   void
   ToolTip_TrackActivate(HWND toolTip, bool activate, TOOLINFO& info);
   
   void
   ToolTip_TrackPosition(HWND toolTip, int xPos, int yPos);
   
   HRESULT
   UnregisterClass(const String& classname, HINSTANCE module);

   HRESULT
   WaitForSingleObject(
      HANDLE   object,       
      unsigned timeoutMillis,
      DWORD&   result);

   HRESULT
   WideCharToMultiByte(
      DWORD          flags,
      const String&  string,
      char*          buffer,
      size_t         bufferSize,
      size_t&        result);

   HRESULT
   WinHelp(
      HWND           window,
      const String&  helpFileName,
      UINT           command,
      ULONG_PTR      data);
      
   HRESULT
   WriteFile(
      HANDLE      handle, 
      const void* buffer,
      DWORD       numberOfBytesToWrite,
      DWORD*      numberOfBytesWritten);

   HRESULT
   WritePrivateProfileString(
      const String& section,
      const String& key,
      const String& value,
      const String& filename);
}

}  // namespace Burnslib



#endif   // WIN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\wizard.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#ifndef WIZARD_HPP_INCLUDED
#define WIZARD_HPP_INCLUDED



// A Wizard manages the traversal of 1+ WizardPage instances.

class Wizard
{
   public:

   Wizard(
      unsigned titleStringResID,
      unsigned banner16BitmapResID,
      unsigned banner256BitmapResID,
      unsigned watermark16BitmapResID,
      unsigned watermark1256BitmapResID);
   ~Wizard();



   // Adds the page to the wizard.  Takes ownership of the instance, and
   // will delete it when the Wizard is deleted.

   void
   AddPage(WizardPage* page);



   // Invokes Create on all of the pages that have been added.
   // Calls Win32 ::PropertySheet to display and (modally) execute the
   // wizard.  Returns same values as ::PropertySheet.
   //
   // parentWindow - in, optional, handle to parent window. Default is 0,
   // for which the current desktop window will be used.

   INT_PTR
   ModalExecute(HWND parentWindow = 0);

   void
   SetNextPageID(HWND wizardPage, int pageResID);

   void
   Backtrack(HWND wizardPage);

   bool
   IsBacktracking();

   private:

   // not implemented: copy not allowed
   
   Wizard(const Wizard&);
   const Wizard& operator=(const Wizard&);

   typedef
      std::list<WizardPage*, Burnslib::Heap::Allocator<WizardPage*> >
      PageList;

   typedef
      std::vector<unsigned, Burnslib::Heap::Allocator<unsigned> >
      UIntVector;

   typedef
      std::stack<unsigned, UIntVector>
      PageIdStack;

   unsigned    banner16ResId;    
   unsigned    banner256ResId;   
   bool        isBacktracking;   
   PageIdStack pageIdHistory;    
   PageList    pages;            
   unsigned    titleResId;       
   unsigned    watermark16ResId; 
   unsigned    watermark256ResId;
};



#endif   // WIZARD_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\maindialog.cpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Main dialog window
//
// 16 Mar 2000 sburns



#include "headers.hxx"
#include "MainDialog.hpp"
#include "SpewDialog.hpp"
#include "resource.h"



static const DWORD _help_map[] =
{
   IDC_CLIENT_NAME,        NO_HELP,                          
   IDC_APP_NAME,           NO_HELP,                          
   IDC_GET_FLAGS,          NO_HELP,                          
   IDC_SET_FLAGS,          NO_HELP,                          
   IDC_VIEW_SPEW,          NO_HELP,
   IDC_FLAGS_GROUP,        NO_HELP,
   IDC_OUTPUT_TO_FILE,     NO_HELP,
   IDC_OUTPUT_TO_DEBUGGER, NO_HELP,
   IDC_OUTPUT_TO_SPEWVIEW, NO_HELP,
   IDC_OUTPUT_LOGS,        NO_HELP,
   IDC_OUTPUT_HEADER,      NO_HELP,
   IDC_OUTPUT_ERRORS,      NO_HELP,
   IDC_OUTPUT_CTORS,       NO_HELP,
   IDC_OUTPUT_ADDREFS,     NO_HELP,
   IDC_OUTPUT_FUNCCALLS,   NO_HELP,
   IDC_OUTPUT_TIME_OF_DAY, NO_HELP,
   IDC_OUTPUT_RUN_TIME,    NO_HELP,
   IDC_OUTPUT_SCOPE_EXIT,  NO_HELP,
   IDC_FLAGS,              NO_HELP,
   IDC_STATUS,             NO_HELP,
   0, 0
};



static const DWORD ID_TO_FLAGMAP[] =
{
   IDC_OUTPUT_TO_FILE,     Burnslib::Log::OUTPUT_TO_FILE,    
   IDC_OUTPUT_TO_DEBUGGER, Burnslib::Log::OUTPUT_TO_DEBUGGER,
   IDC_OUTPUT_TO_SPEWVIEW, Burnslib::Log::OUTPUT_TO_SPEWVIEW,
   IDC_OUTPUT_LOGS,        Burnslib::Log::OUTPUT_LOGS,       
   IDC_OUTPUT_HEADER,      Burnslib::Log::OUTPUT_HEADER,     
   IDC_OUTPUT_ERRORS,      Burnslib::Log::OUTPUT_ERRORS,     
   IDC_OUTPUT_CTORS,       Burnslib::Log::OUTPUT_CTORS,      
   IDC_OUTPUT_ADDREFS,     Burnslib::Log::OUTPUT_ADDREFS,    
   IDC_OUTPUT_FUNCCALLS,   Burnslib::Log::OUTPUT_FUNCCALLS,   
   IDC_OUTPUT_TIME_OF_DAY, Burnslib::Log::OUTPUT_TIME_OF_DAY, 
   IDC_OUTPUT_RUN_TIME,    Burnslib::Log::OUTPUT_RUN_TIME,
   IDC_OUTPUT_SCOPE_EXIT,  Burnslib::Log::OUTPUT_SCOPE_EXIT,
   0, 0
};



MainDialog::MainDialog()
   :
   Dialog(IDD_MAIN, _help_map),
   spewviewer(0),
   setFlagsOnStart(false)
{
   LOG_CTOR(MainDialog);
}
   


MainDialog::~MainDialog()
{
   LOG_DTOR(MainDialog);

   SaveUiHistory();

   delete spewviewer;
   spewviewer = 0;
}



void
MainDialog::SetStatusText(const String& text)
{
   LOG_FUNCTION2(MainDialog::SetStatusText, text);

   Win::SetDlgItemText(hwnd, IDC_STATUS, text);
}



void
MainDialog::EnableControls()
{
   LOG_FUNCTION(MainDialog::EnableControls);

   String c = Win::GetTrimmedDlgItemText(hwnd, IDC_CLIENT_NAME);
   String a = Win::GetTrimmedDlgItemText(hwnd, IDC_APP_NAME);

   bool enableButtons =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_CLIENT_NAME).empty()
      && !Win::GetTrimmedDlgItemText(hwnd, IDC_APP_NAME).empty();

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_GET_FLAGS),   enableButtons);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SET_FLAGS),   enableButtons);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_VIEW_SPEW),   enableButtons);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_FLAGS_GROUP), enableButtons);


   for (int i = 0; ID_TO_FLAGMAP[i]; i += 2)
   {
      Win::EnableWindow(
         Win::GetDlgItem(hwnd, ID_TO_FLAGMAP[i]),
         enableButtons);
   }
}



void
MainDialog::AddToUiHistory(const String& clientName, const String& appName)
{
   LOG_FUNCTION(MainDialog::AddToUiHistory);
   ASSERT(!clientName.empty());
   ASSERT(!appName.empty());

   push_back_unique(clientNameHistory, clientName);
   push_back_unique(appNameHistory,    appName);

   lastClientNameUsed = clientName;
   lastAppNameUsed    = appName;   
}



// Caller must call Win::RegCloseKey(remoteHKLM) 

HRESULT
MainDialog::ConnectToClientRegistry(
   HKEY&   remoteHKLM,
   String& clientName,
   String& appName)   
{
   LOG_FUNCTION(MainDialog::ConnectToClientRegistry);
   ASSERT(!remoteHKLM);

   remoteHKLM = 0;
   clientName = Win::GetTrimmedDlgItemText(hwnd, IDC_CLIENT_NAME);
   appName    = Win::GetTrimmedDlgItemText(hwnd, IDC_APP_NAME);   

   if (clientName.empty() or appName.empty())
   {
      popup.Error(
         hwnd,
         L"You need to specify a client machine and application");
      return E_INVALIDARG;
   }

   HRESULT hr = S_OK;
   do
   {
      SetStatusText(
         String::format(
            L"Attempting to attach to machine %1",
            clientName.c_str()));

      Computer comp(clientName);

      hr = comp.Refresh();
      if (FAILED(hr))
      {
         String msg =
            String::format(
               L"Can't attach to client machine %1",
               clientName.c_str());
 
         SetStatusText(msg);

         popup.Error(hwnd, hr, msg);
         break;
      }

      // connect to the client machine's registry

      hr =
         Win::RegConnectRegistry(
            comp.IsLocal() ? String() : L"\\\\" + comp.GetNetbiosName(),
            HKEY_LOCAL_MACHINE,
            remoteHKLM);
      if (FAILED(hr))
      {
         String msg =
            String::format(
               L"Can't connect to registry of client machine %1",
               clientName.c_str());

         SetStatusText(msg);

         popup.Error(hwnd, hr, msg);            
         break;
      }
   }
   while (0);

#ifdef DBG
   if (SUCCEEDED(hr))
   {
      ASSERT(remoteHKLM);
   }
#endif

   return hr;
}



DWORD
CollectFlags(HWND dialogParent)
{
   LOG_FUNCTION(CollectFlags);
   ASSERT(Win::IsWindow(dialogParent));

   DWORD outputFlags = 0;

   for (int i = 0; ID_TO_FLAGMAP[i]; i += 2)
   {
      if (Win::IsDlgButtonChecked(dialogParent, ID_TO_FLAGMAP[i]))
      {
         outputFlags |= ID_TO_FLAGMAP[i + 1];
      }
   }

   return outputFlags;
}



void
UpdateFlagsEdit(HWND dialogParent)
{
   LOG_FUNCTION(UpdateFlagsEdit);
   ASSERT(Win::IsWindow(dialogParent));

   DWORD flags = CollectFlags(dialogParent);

   Win::SetDlgItemText(
      dialogParent,
      IDC_FLAGS,
      String::format(L"%1!08X!", flags));
}
   


// Set the logging options
//
// remoteHKLM - already opened registry handle.  Not closed by this
// function.

HRESULT
SetLoggingOptions(
   HWND           dialogParent,
   HKEY           remoteHKLM,
   const String&  clientName,
   const String&  appName)   
{
   LOG_FUNCTION(SetLoggingOptions);
   ASSERT(Win::IsWindow(dialogParent));
   ASSERT(remoteHKLM);
   ASSERT(!clientName.empty());
   ASSERT(!appName.empty());

   HRESULT hr = S_OK;

   do
   {
      String logKey = String(REG_ADMIN_RUNTIME_OPTIONS) + appName;
      RegistryKey key;
               
      hr = key.Create(remoteHKLM, logKey);
      if (FAILED(hr))
      {
         popup.Error(
            dialogParent,
            hr,
            String::format(
               L"Can't create logging registry key %1 on client machine %2",
               logKey.c_str(),
               clientName.c_str()));
         break;
      }

      DWORD outputFlags = CollectFlags(dialogParent);

      hr = key.SetValue(L"LogFlags", outputFlags);
      if (FAILED(hr))
      {
         popup.Error(
            dialogParent,
            hr,
            String::format(
               L"Can't set logging registry value on client machine %1",
               clientName.c_str()));
         break;
      }
   }
   while (0);

   return hr;
}



HRESULT
MainDialog::SetFlags()
{
   LOG_FUNCTION(MainDialog::SetFlags);

   HRESULT hr = S_OK;
   HKEY    remoteHKLM = 0;   
   String  clientName;
   String  appName;

   do
   {
      hr = ConnectToClientRegistry(remoteHKLM, clientName, appName);

      // if that failed, the connect function will have griped to the user
      // already, so just bail out here

      BREAK_ON_FAILED_HRESULT(hr);

      hr = SetLoggingOptions(hwnd, remoteHKLM, clientName, appName);

      // ditto about griping here

      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
   Win::RegCloseKey(remoteHKLM);

   if (SUCCEEDED(hr))
   {
      // Since we could successfully perform the operation, save the
      // client name and app name in the ui history

      AddToUiHistory(clientName, appName);
   }

   return hr;
}



void
MainDialog::OnSetFlagsButton()
{
   LOG_FUNCTION(MainDialog::OnSetFlagsButton);

   if (SUCCEEDED(SetFlags()))
   {
      // refresh the flags

      HRESULT hr = GetFlags();
      ASSERT(SUCCEEDED(hr));

      SetStatusText(L"Flags set successfully.");
   }
}



void
MainDialog::OnGetFlagsButton()
{
   LOG_FUNCTION(MainDialog::OnGetFlagsButton);

   if (SUCCEEDED(GetFlags()))
   {
      SetStatusText(L"Flags read successfully.");
   }
}



void
MainDialog::UpdateCheckboxen(DWORD flags)
{
   LOG_FUNCTION(MainDialog::UpdateCheckboxen);
   
   for (int i = 0; ID_TO_FLAGMAP[i]; i += 2)
   {
      Win::CheckDlgButton(
         hwnd,
         ID_TO_FLAGMAP[i],
            (flags & ID_TO_FLAGMAP[i + 1])
         ?  BST_CHECKED
         :  BST_UNCHECKED);
   }
}



void
MainDialog::ResetFlagsDisplay()
{
   LOG_FUNCTION(MainDialog::ResetFlagsDisplay);

   Win::SetDlgItemText(hwnd, IDC_FLAGS, L"");
   Win::UpdateWindow(Win::GetDlgItem(hwnd, IDC_FLAGS));

   // clear all the checkboxes

   UpdateCheckboxen(0);
}



HRESULT
MainDialog::GetFlags()
{
   LOG_FUNCTION(MainDialog::GetFlags);

   HRESULT hr = S_OK;
   HKEY    remoteHKLM = 0;   
   String  clientName;
   String  appName;

   Win::WaitCursor wait;

   do
   {
      ResetFlagsDisplay();

      hr = ConnectToClientRegistry(remoteHKLM, clientName, appName);

      // if that failed, the connect function will have griped to the user
      // already, so just bail out here

      BREAK_ON_FAILED_HRESULT(hr);   

      // Set the logging options

      String logKey = String(REG_ADMIN_RUNTIME_OPTIONS) + appName;
      RegistryKey key;
               
      hr = key.Open(remoteHKLM, logKey);
      if (FAILED(hr))
      {
         String msg =
            String::format(
               L"Can't open logging registry key %1 on client machine %2",
               logKey.c_str(),
               clientName.c_str());
            
         SetStatusText(msg);
               
         popup.Error(hwnd, hr, msg);
         break;
      }

      DWORD outputFlags = 0;
      hr = key.GetValue(L"LogFlags", outputFlags);
      if (FAILED(hr))
      {
         String msg =
            String::format(
               L"Can't get logging registry value on client machine %1",
               clientName.c_str());
            
         SetStatusText(msg);
               
         popup.Error(hwnd, hr, msg);
         break;
      }

      // here, we've got the flags, so update the checkboxen

      UpdateCheckboxen(outputFlags);
      UpdateFlagsEdit(hwnd);
   }
   while (0);

   Win::RegCloseKey(remoteHKLM);

   if (SUCCEEDED(hr))
   {
      // Since we could successfully perform the operation, save the
      // client name and app name in the ui history

      AddToUiHistory(clientName, appName);
   }

   return hr;
}



HRESULT
MainDialog::SetClientConfiguration()
{
   LOG_FUNCTION(MainDialog::SetClientConfiguration);

   HRESULT hr = S_OK;
   HKEY    remoteHKLM = 0;   
   String  clientName;
   String  appName;

   Win::WaitCursor wait;

   do
   {
      hr = ConnectToClientRegistry(remoteHKLM, clientName, appName);

      // if that failed, the connect function will have griped to the user
      // already, so just bail out here

      BREAK_ON_FAILED_HRESULT(hr);   

      // create the spewview key with the name of the server (this machine)

      RegistryKey key;

      hr =
         key.Create(
            remoteHKLM,
            SPEWVIEW_KEY_NAME + appName,
            REG_OPTION_VOLATILE);
      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               L"Can't create spewview registry key on client machine %1",
               clientName.c_str()));
         break;
      }

      hr =
         key.SetValue(
            L"Server",
            Win::GetComputerNameEx(ComputerNameNetBIOS));
      if (FAILED(hr))
      {
         popup.Error(
            hwnd,
            hr,
            String::format(
               L"Can't set spewview server registry value on client machine %1",
               clientName.c_str()));
         break;
      }

      if (setFlagsOnStart)
      {
         hr = SetLoggingOptions(hwnd, remoteHKLM, clientName, appName);

         // if that failed, the function will have griped to the user already,
         // so just bail out here

         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   Win::RegCloseKey(remoteHKLM);

   if (SUCCEEDED(hr))
   {
      // Since we could successfully perform the operation, save the
      // client name and app name in the ui history

      AddToUiHistory(clientName, appName);
   }

   return hr;
}



void
MainDialog::OnStartButton()
{
   LOG_FUNCTION(MainDialog::OnStartButton);

   HRESULT hr = S_OK;
   do
   {
      if (spewviewer)
      {
         popup.Error(
            hwnd,
            L"Spew Viewing has already commenced.");
         break;
      }
         
      String clientName = Win::GetTrimmedDlgItemText(hwnd, IDC_CLIENT_NAME);
      String appName    = Win::GetTrimmedDlgItemText(hwnd, IDC_APP_NAME);   

      if (clientName.empty() or appName.empty())
      {
         popup.Error(
            hwnd,
            L"You need to specify a client machine and application");
         break;
      }

      if (!setFlagsOnStart)
      {
         GetFlags();
      }

      // configure the client

      hr = SetClientConfiguration();

      // if that call failed, it will have griped at the user.

      BREAK_ON_FAILED_HRESULT(hr);

      // deleted either in dtor or in WM_KILL_SPEWVIEWER handler

      spewviewer = new SpewDialog(clientName, appName);
      spewviewer->ModelessExecute(hwnd);
   }
   while (0);
}



bool
MainDialog::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   //   LOG_FUNCTION(MainDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_VIEW_SPEW:
      {
         if (code == BN_CLICKED)
         {
            OnStartButton();
            return true;
         }
         break;
      }
      case IDC_GET_FLAGS:
      {
         if (code == BN_CLICKED)
         {
            OnGetFlagsButton();
            return true;
         }
         break;
      }
      case IDC_SET_FLAGS:
      {
         if (code == BN_CLICKED)
         {
            OnSetFlagsButton();
            return true;
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            // kill the spew window...

            Win::EndDialog(hwnd, 0);
            return true;
         }
         break;
      }
      case IDC_CLIENT_NAME:
      case IDC_APP_NAME:
      {
         if (code == CBN_EDITCHANGE)
         {
            EnableControls();
         }
         if (code == CBN_CLOSEUP)
         {
            // move the list box selection into the combo box edit control

            Win::SetWindowText(
               windowFrom,
               Win::ComboBox_GetCurText(windowFrom));

            EnableControls();
         }
         break;
      }
      case IDC_OUTPUT_TO_FILE:
      case IDC_OUTPUT_TO_DEBUGGER:
      case IDC_OUTPUT_TO_SPEWVIEW:
      case IDC_OUTPUT_LOGS:
      case IDC_OUTPUT_HEADER:
      case IDC_OUTPUT_ERRORS:
      case IDC_OUTPUT_CTORS:
      case IDC_OUTPUT_ADDREFS:
      case IDC_OUTPUT_FUNCCALLS:
      case IDC_OUTPUT_TIME_OF_DAY:
      case IDC_OUTPUT_RUN_TIME:
      case IDC_OUTPUT_SCOPE_EXIT:
      {
         if (code == BN_CLICKED)
         {
            UpdateFlagsEdit(hwnd);
            setFlagsOnStart = true;
         }
         break;
      }
      case IDC_FLAGS:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               setFlagsOnStart = true;

               // update the display

               String text = Win::GetWindowText(windowFrom);
               DWORD flags = 0;
               text.convert(flags, 16);

               UpdateCheckboxen(flags);
               break;
            }
            case EN_UPDATE:
            {
               
               
            }
            default:
            {
               // do nothing

               break;
            }
         break;
         }
      }
      default:
      {
         // do nothing
      }
   }

   return false;
}



void
AddLastUsedNameToCombo(
   HWND              combo,
   const StringList& historyList,
   const String&     lastNameUsed)
{
   typedef std::binder1st<String::EqualIgnoreCase> FindIfPredicate;

   if (!lastNameUsed.empty())
   {
      if (
         std::find_if(
            historyList.begin(),
            historyList.end(),
            FindIfPredicate(String::EqualIgnoreCase(), lastNameUsed))
         == historyList.end() )
      {
         // last name used not present in history list, so add it

         Win::ComboBox_AddString(combo, lastNameUsed);
      }

      Win::ComboBox_SelectString(combo, lastNameUsed);
   }
}



void
MainDialog::OnInit()
{
   LOG_FUNCTION(MainDialog::OnInit);

   LoadUiHistory();

   // Load the client and app name combo boxes with the historical values

   HWND clientCombo = Win::GetDlgItem(hwnd, IDC_CLIENT_NAME);

   Win::ComboBox_AddStrings(
      clientCombo,
      clientNameHistory.begin(),
      clientNameHistory.end());

   HWND appCombo = Win::GetDlgItem(hwnd, IDC_APP_NAME);

   Win::ComboBox_AddStrings(
      appCombo,
      appNameHistory.begin(),
      appNameHistory.end());

   AddLastUsedNameToCombo(clientCombo, clientNameHistory, lastClientNameUsed);
   AddLastUsedNameToCombo(appCombo,    appNameHistory,    lastAppNameUsed);   

   // Limit to number of hex digits in a DWORD

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_FLAGS), 8);

   SetStatusText(L"");
   ResetFlagsDisplay();
   EnableControls();
}



void
MainDialog::LoadUiHistory()
{
   LOG_FUNCTION(MainDialog::LoadUiHistory);

   HRESULT hr = S_OK;

   do
   {
      RegistryKey key;

      hr = key.Open(HKEY_LOCAL_MACHINE, SPEWVIEW_KEY_NAME);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         key.GetValue(
            L"ClientNameHistory",
            std::back_inserter(clientNameHistory));
      LOG_HRESULT(hr);

      // don't break on failure, try to read the app name history too.

      hr =
         key.GetValue(
            L"AppNameHistory",
            std::back_inserter(appNameHistory));
      LOG_HRESULT(hr);

      // don't break on failure, try to read the last names used, too.

      hr = key.GetValue(L"LastClientNameUsed", lastClientNameUsed);
      LOG_HRESULT(hr);

      hr = key.GetValue(L"LastAppNameUsed", lastAppNameUsed);
      LOG_HRESULT(hr);
   }
   while (0);
}



void
MainDialog::SaveUiHistory()
{
   LOG_FUNCTION(MainDialog::SaveUiHistory);

   HRESULT hr = S_OK;

   do
   {
      RegistryKey key;

      hr = key.Create(HKEY_LOCAL_MACHINE, SPEWVIEW_KEY_NAME);
      BREAK_ON_FAILED_HRESULT(hr);

      hr =
         key.SetValue(
            L"ClientNameHistory",
            clientNameHistory.begin(),
            clientNameHistory.end());
      LOG_HRESULT(hr);

      // don't break on failure, try to write the app name history too.

      hr =
         key.SetValue(
            L"AppNameHistory",
            appNameHistory.begin(),
            appNameHistory.end());
      LOG_HRESULT(hr);

      // don't break on failure, try to write the last names used, too.

      hr = key.SetValue(L"LastClientNameUsed", lastClientNameUsed);
      LOG_HRESULT(hr);

      hr = key.SetValue(L"LastAppNameUsed", lastAppNameUsed);
      LOG_HRESULT(hr);
   }
   while (0);
}



bool
MainDialog::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
   switch (message)
   {
      case WM_KILL_SPEWVIEWER:
      {
         delete spewviewer;
         spewviewer = 0;

         return true;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\readerthread.hpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Thread to read remote debug spew
//
// 20 Mar 2000 sburns



#ifndef READERTHREAD_HPP_INCLUDED
#define READERTHREAD_HPP_INCLUDED



struct ReaderThreadParams
{
   HWND   hwnd;   
   int*   endFlag;
   String appName;
};



void _cdecl
ReaderThreadProc(void* p);



#endif   // READERTHREAD_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\inc\wizpage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard page base class
//
// 12-15-97 sburns



#ifndef WIZPAGE_HPP_INCLUDED
#define WIZPAGE_HPP_INCLUDED



class WizardPage : public PropertyPage
{
   friend class Wizard;

   public:

   protected:

   WizardPage(
      unsigned dialogResID,
      unsigned titleResID,
      unsigned subtitleResID,   
      bool     isInteriorPage = true,
      bool     enableHelp = false);

   virtual ~WizardPage();

   // calls Backtrack();

   virtual
   bool
   OnWizBack();

   Wizard&
   GetWizard() const;

   private:

   // Create the page with wizard style flags, title & subtitle, etc.
   // Overridden from PropertyPage base class, and access adjusted to
   // private so that just the Wizard class can call it.

   virtual 
   HPROPSHEETPAGE
   Create();

   // not defined: no copying allowed
   WizardPage(const WizardPage&);
   const WizardPage& operator=(const WizardPage&);

   bool     hasHelp;
   bool     isInterior;
   unsigned titleResId;
   unsigned subtitleResId;
   Wizard*  wizard;
};



#endif   // WIZPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDD_DUMPER                      227
#define IDD_MAIN                        227
#define IDD_SPEWAGE                     228
#define IDC_SPEWAGE                     1161
#define IDC_START                       1163
#define IDC_APP_NAME                    1165
#define IDC_STOP                        1166
#define IDC_SELECT_ALL                  1167
#define IDC_CLIENT_NAME                 1168
#define IDC_LINE_COUNTER                1169
#define IDC_OUTPUT_TO_FILE              1175
#define IDC_OUTPUT_TO_DEBUGGER          1176
#define IDC_OUTPUT_TO_SPEWVIEW          1177
#define IDC_CLEAR                       1178
#define IDC_OUTPUT_CTORS                1179
#define IDC_OUTPUT_ADDREFS              1180
#define IDC_OUTPUT_FUNCCALLS            1181
#define IDC_OUTPUT_LOGS                 1182
#define IDC_OUTPUT_HEADER               1183
#define IDC_OUTPUT_ERRORS               1184
#define IDC_OUTPUT_TIME_OF_DAY          1185
#define IDC_OUTPUT_RUN_TIME             1186
#define IDC_GET_FLAGS                   1187
#define IDC_SET_FLAGS                   1188
#define IDC_VIEW_SPEW                   1190
#define IDC_FLAGS_GROUP                 1191
#define IDC_FLAGS                       1192
#define IDC_OUTPUT_SCOPE_EXIT           1193
#define IDC_STATUS                      1194
#define IDS_APP_TITLE                   2000
#define IDS_ERROR_CONNECTING            2001
#define IDS_ERROR_READING               2003
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1195
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\maindialog.hpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Main dialog window
//
// 16 Mar 2000 sburns



#ifndef MAINDIALOG_HPP_INCLUDED
#define MAINDIALOG_HPP_INCLUDED



class SpewDialog;



class MainDialog : public Dialog
{
   public:

   MainDialog();
   
   virtual ~MainDialog();

   static const int WM_KILL_SPEWVIEWER = WM_USER + 201;
      
   private:

   void
   AddToUiHistory(const String& clientName, const String& appName);

   HRESULT
   ConnectToClientRegistry(
      HKEY&   remoteHKLM,
      String& clientName,
      String& appName);

   void
   EnableControls();

   HRESULT
   GetFlags();

   void
   OnGetFlagsButton();

   void
   OnSetFlagsButton();
   
   void
   OnStartButton();

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   virtual
   void
   OnInit();

   void
   LoadUiHistory();

   void
   ResetFlagsDisplay();

   void
   SaveUiHistory();

   HRESULT
   SetClientConfiguration();

   HRESULT
   SetFlags();

   void
   SetStatusText(const String& text);

   void
   UpdateCheckboxen(DWORD flags);

   // not implemented: no copying allowed

   MainDialog(const MainDialog&);
   const MainDialog& operator=(const MainDialog&);

   StringList  clientNameHistory;
   StringList  appNameHistory;
   String      lastClientNameUsed;
   String      lastAppNameUsed;
   SpewDialog* spewviewer;
   bool        setFlagsOnStart;
};



#endif   // MAINDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\readerthread.cpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Thread to read remote debug spew
//
// 20 Mar 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "ReaderThread.hpp"
#include "SpewDialog.hpp"



int readMessageCount = 0;



HRESULT
CreateAndConnectSpewPipe(
   const String&  appName,
   HANDLE&        result)
{
   LOG_FUNCTION(CreateAndConnectSpewPipe);
   ASSERT(!appName.empty());

   result = INVALID_HANDLE_VALUE;

   HRESULT hr = S_OK;

   do
   {
      // build a null dacl for the pipe to allow everyone access

      SECURITY_ATTRIBUTES sa;
      memset(&sa, 0, sizeof(sa));

      SECURITY_DESCRIPTOR sd;
      hr = Win::InitializeSecurityDescriptor(sd);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::SetSecurityDescriptorDacl(sd, true, 0, false);
      BREAK_ON_FAILED_HRESULT(hr);

      sa.nLength              = sizeof(SECURITY_ATTRIBUTES);
      sa.lpSecurityDescriptor = &sd;                        
      sa.bInheritHandle       = TRUE;                       
   
      String pipename = L"\\\\.\\pipe\\spewview\\" + appName;
      hr =
         Win::CreateNamedPipe(
            pipename,
            PIPE_ACCESS_INBOUND | WRITE_DAC,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE /* | PIPE_NOWAIT */ ,
            1,
            MAX_PATH,
            MAX_PATH,
            500,
            &sa,
            result);
      BREAK_ON_FAILED_HRESULT(hr);

      // block until the spewing app connects to us.

      hr = Win::ConnectNamedPipe(result, 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



void
AddSpewMessage(
   HWND           spewWindow,
   const String&  message,
   DWORD          readMessageCount = -1)
{
   ASSERT(!message.empty());

   // post the received text to the message window.

   // deleted in the UI thread when the WM_UPDATE_SPEWAGE message
   // is receieved.

   String* spew = new String(message);

   Win::PostMessage(
      spewWindow,
      SpewDialog::WM_UPDATE_SPEWAGE,
      readMessageCount,
      reinterpret_cast<LPARAM>(spew));
}



HRESULT
ReadSpew(HANDLE pipe, HWND spewWindow)
{
   LOG_FUNCTION(ReadSpew);
   ASSERT(pipe != INVALID_HANDLE_VALUE);
   ASSERT(Win::IsWindow(spewWindow));

   HRESULT hr = S_OK;

   String messageBuffer;
   messageBuffer.reserve(2048);

   static const size_t SPEW_BUF_MAX_CHARACTERS = 1023;
   static const size_t SPEW_BUF_MAX_BYTES =
      SPEW_BUF_MAX_CHARACTERS * sizeof(wchar_t);

   wchar_t buf[SPEW_BUF_MAX_CHARACTERS + 1];
   BYTE*   byteBuf = reinterpret_cast<BYTE*>(buf);

   for (;;)
   {
      DWORD bytesRead = 0;
      hr = 
         Win::ReadFile(
            pipe,
            byteBuf,
            SPEW_BUF_MAX_BYTES,
            bytesRead,
            0);
      if (hr == Win32ToHresult(ERROR_MORE_DATA))
      {
         // don't break: we will pick up the rest of the message in the
         // next pass
      }
      else
      {
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (!bytesRead)
      {
         // it's possbile that the client wrote zero bytes.

         continue;
      }

      // force null termination

      byteBuf[bytesRead]      = 0;
      byteBuf[bytesRead + 1]  = 0;
            
      ++readMessageCount;

      String message(buf);
      if (messageBuffer.length() + message.length() >= 2048)
      {
         // flush the buffer

         AddSpewMessage(
            spewWindow,
            messageBuffer,
            readMessageCount);
         messageBuffer.erase();
         messageBuffer.reserve(2048);
      }

      messageBuffer.append(message);
   }

   // flush the buffer

   AddSpewMessage(
      spewWindow,
      messageBuffer,
      readMessageCount);

   return hr;
}



void _cdecl
ReaderThreadProc(void* p)
{
   LOG_FUNCTION(ReaderThreadProc);
   ASSERT(p);

   if (!p)
   {
      return;
   }
            
   // copy what we need from p, then delete it.

   ReaderThreadParams* params = reinterpret_cast<ReaderThreadParams*>(p);

   HWND   spewWindow      = params->hwnd;   
   int*   endReaderThread = params->endFlag;
   String appName         = params->appName;

   delete params;
   params = 0;
   p = 0;

   HRESULT hr = S_OK;

   do
   {
      // create and connect to the pipe

      HANDLE pipe = INVALID_HANDLE_VALUE;
      hr = CreateAndConnectSpewPipe(appName, pipe);
      if (FAILED(hr))
      {
         AddSpewMessage(
            spewWindow,
            String::format(L"Connect failed: %1!08X!", hr));
         popup.Error(
            spewWindow,
            hr,
            IDS_ERROR_CONNECTING);
         break;
      }

      // read the contents of the slot until the thread is flagged to die,
      // or a failure occurs.

      while (!*endReaderThread)
      {
         hr = ReadSpew(pipe, spewWindow);

         if (FAILED(hr))
         {
            LOG_HRESULT(hr);

            *endReaderThread = 1;

            popup.Error(
               spewWindow,
               hr,
               IDS_ERROR_READING);
         }
      }

      // we're supposed to stop.

      // this will terminate the client's connection too.

      hr = Win::DisconnectNamedPipe(pipe);
      BREAK_ON_FAILED_HRESULT(hr);

      // this will delete the pipe instance

      Win::CloseHandle(pipe);

      // Tell the viewer to enable the start button

      Win::PostMessage(spewWindow, SpewDialog::WM_ENABLE_START, 0, 0);
   }
   while (0);
}



// CODEWORK:
// stop button does not work, as ReadFile is blocking, and reader thread
// never gets around to evaluating end flag.
// therefore, restart and cancel buttons do not work either

// to allow non-blocking reads of the pipe, need to use async read so
// reader thread is not blocked waiting for client write

// replace end flag with event triggered when cancel or stop pressed.

// static alloc overlapped struct
// put ptr to spew window in overlapped hEvent member
// call ReadFileEx
// 
// while WaitForMultpleObjects(cancel event, read, timeout)
//    if timeout
//       flush read buffer
//    if io complete, do nothing
//    if cancel signalled,
//       flush read buffer,
//       cancel io
//       exit loop
//    if other error
//       flush read buffer,
//       cancel io
//       exit loop
// 
// completion callback
//    if error != ERROR_OPERATION_ABORTED
//       append to read buffer
//       if buffer full, flush to spew window
//    call ReadFileEx
//       will this eat stack forever?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\spewdialog.cpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Spew monitoring window: modeless dialog to capture spewage
//
// 16 Mar 2000 sburns



#include "headers.hxx"
#include "SpewDialog.hpp"
#include "MainDialog.hpp"
#include "ReaderThread.hpp"
#include "resource.h"



const int WM_UPDATE_SPEWAGE = WM_USER + 200;



static const DWORD _help_map[] =
{
   IDC_START,           NO_HELP,
   IDC_STOP,            NO_HELP,
   IDC_SPEWAGE,         NO_HELP,
   IDC_LINE_COUNTER,    NO_HELP,
   IDC_SELECT_ALL,      NO_HELP,
   0, 0
};



SpewDialog::SpewDialog(const String& clientName_, const String& appName_)
   :
   Dialog(IDD_SPEWAGE, _help_map),
   spewLineCount(0),
   textBoxLineCount(0),
   clientName(clientName_),
   appName(appName_),
   readerThreadCreated(false),
   endReaderThread(0)
{
   LOG_CTOR(SpewDialog);
}



SpewDialog::~SpewDialog()
{
   LOG_DTOR(SpewDialog);

   StopReadingSpewage();
}



void
SpewDialog::OnStartButton()
{
   LOG_FUNCTION(SpewDialog::OnStartButton);

   if (!readerThreadCreated)
   {
      Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_START), false);      
      StartReadingSpewage();
   }
}



void
SpewDialog::OnStopButton()
{
   LOG_FUNCTION(SpewDialog::OnStopButton);

   StopReadingSpewage();
}



bool
SpewDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
   switch (controlIDFrom)
   {
      case IDC_START:
      {
         if (code == BN_CLICKED)
         {
            OnStartButton();
            return true;
         }
         break;
      }
      case IDC_STOP:
      {
         if (code == BN_CLICKED)
         {
            OnStopButton();
            return true;
         }
         break;
      }
      case IDC_SELECT_ALL:
      {
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            // signal the reader thread to die.

            StopReadingSpewage();

            // signal the main dialog to kill us

            Win::PostMessage(
               Win::GetParent(hwnd),
               MainDialog::WM_KILL_SPEWVIEWER,
               0,
               0);

            return true;
         }
         break;
      }
      default:
      {
         // do nothing
      }
   }

   return false;
}



void
SpewDialog::ResizeSpewWindow(int newParentWidth, int newParentHeight)
{
   HRESULT hr = S_OK;
   HWND spewWindow   = Win::GetDlgItem(hwnd, IDC_SPEWAGE);

   do
   {
      hr =
         Win::SetWindowPos(
            spewWindow,
            0,
            0,
            0,
            newParentWidth - margins.left - margins.right,
            newParentHeight - margins.top - margins.bottom,
            SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
}



bool
SpewDialog::OnMessage(
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
   switch (message)
   {
      case WM_UPDATE_SPEWAGE:
      {
         // lparam is pointer to spewage buffer to dump into the edit
         // box.

         ASSERT(lparam);

         if (lparam)
         {
            String* spew = reinterpret_cast<String*>(lparam);
            ASSERT(!spew->empty());

            AppendMessage(wparam, *spew);

            delete spew;
         }
         return true;
      }
      case WM_ENABLE_START:
      {
         // The reader thread has disconnected and closed the pipe, and is
         // (nearly) dead, so it's ok to allow another reader thread to be
         // started.

         Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_START), true);

         return true;
      }
      case WM_SIZE:
      {
         int newDlgWidth  = LOWORD(lparam);
         int newDlgHeight = HIWORD(lparam);

         ResizeSpewWindow(newDlgWidth, newDlgHeight);

         return false;
      }
      default:
      {
         // do nothing;
         break;
      }
   }

   return false;
}



void
SpewDialog::AppendMessage(WPARAM wparam, const String& message)
{
   bool isSpew = (wparam != -1);

   if (isSpew)
   {
      ++spewLineCount;
      Win::SetDlgItemText(
         hwnd,
         IDC_LINE_COUNTER,
         String::format(L"%1!010d!", spewLineCount));
   }

   Win::Edit_AppendText(
      Win::GetDlgItem(hwnd, IDC_SPEWAGE),
      isSpew ? message : L">>>> " + message);

   ++textBoxLineCount;
}



void
SpewDialog::OnInit()
{
   LOG_FUNCTION(SpewDialog::OnInit);

   Win::SetWindowText(
      hwnd, 
      String::format(
         L"Spewage from %1 on machine %2",
         appName.c_str(),
         clientName.c_str()));

   spewLineCount = 0;
   Win::SetDlgItemText(
      hwnd,
      IDC_LINE_COUNTER,
      String::format(L"%1!010d!", spewLineCount));

   // extend the amount of text that can be inserted into the spew
   // rich edit control

   HWND spewWindow = Win::GetDlgItem(hwnd, IDC_SPEWAGE);

   Win::SendMessage(
      spewWindow,
      EM_EXLIMITTEXT,
      0,

      // 256K characters.

      (1 << 18));

   // Change the font in the spew window to fixed-width

   do
   {
      static String SPEW_FONT_NAME = L"Lucida Console";

      LOGFONT logFont;
      memset(&logFont, 0, sizeof(LOGFONT));

      SPEW_FONT_NAME.copy(
         logFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, SPEW_FONT_NAME.length()));

      HDC hdc = 0;
      HRESULT hr = Win::GetDC(hwnd, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      logFont.lfHeight =
         - ::MulDiv(8, Win::GetDeviceCaps(hdc, LOGPIXELSY), 72);

      Win::ReleaseDC(hwnd, hdc);

      HFONT font = 0;
      hr = Win::CreateFontIndirect(logFont, font);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::SetWindowFont(spewWindow, font, false);
   }
   while (0);

   ComputeMargins();

   // Disable the start button, as we start upon initialization

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_START), false);

   // Start the reader thread.  This will create and connect to the spew
   // pipe, and start reading messages from it.

   StartReadingSpewage();
}



void
SpewDialog::ComputeMargins()
{
   LOG_FUNCTION(SpewDialog::ComputeMargins);

   memset(&margins, 0, sizeof(margins));

   HRESULT hr = S_OK;
   do
   {
      HWND spewWindow = Win::GetDlgItem(hwnd, IDC_SPEWAGE);

      // get the current dimmensions of the dialog

      // use the client rect to remove non-client area from consideration

      RECT parentRect;
      hr = Win::GetClientRect(hwnd, parentRect);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::MapWindowPoints(hwnd, 0, parentRect);
      BREAK_ON_FAILED_HRESULT(hr);

      // get the dimmensions of the spew window, relative to the
      // parent dialog

      RECT spewRect;
      hr = Win::GetWindowRect(spewWindow, spewRect);
      BREAK_ON_FAILED_HRESULT(hr);

      // compute the margins between the spew window and the parent dialog

      margins.bottom = parentRect.bottom - spewRect.bottom;
      margins.right  = parentRect.right  - spewRect.right; 
      margins.left   = spewRect.left     - parentRect.left;
      margins.top    = spewRect.top      - parentRect.top; 
   }
   while (0);
}



void
SpewDialog::StartReadingSpewage()
{
   LOG_FUNCTION(SpewDialog::StartReadingSpewage);

   if (!readerThreadCreated)
   {
      // deleted in readerThreadProc

      ReaderThreadParams* params = new ReaderThreadParams; 
      params->hwnd    = hwnd;            
      params->endFlag = &endReaderThread;
      params->appName = appName;

      // endReaderThread is shared among this thread and the thread we are
      // about to spawn. It does not need guarding, because it is an atomic
      // data type (int), and because we do not care about the order in which
      // the threads read/write to it.  Further, this thread only writes to
      // the value, and the reader thread only reads it.

      endReaderThread = 0;

      // start the reader thread a-runnin'

      _beginthread(ReaderThreadProc, 0, params);

      readerThreadCreated = true;
   }
}



void
SpewDialog::StopReadingSpewage()
{
   LOG_FUNCTION(SpewDialog::StopReadingSpewage);

   if (readerThreadCreated)
   {
      // Tell the reader thread to die.  This will cause the pipe to be
      // disconnected and closed, and a message sent (to this window)
      // that the start button can be enabled again.

      endReaderThread = 1;

      // We check for this in the start procedure.  Since the start button
      // can't be enabled until the thread is about to die, we are safe
      // from a race condition where the user starts two reader threads.

      readerThreadCreated = false;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\args.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// argument parsing
// 
// 3-3-99 sburns



#include "headers.hxx"



void
MapCommandLineArgs(ArgMap& argmap)
{
   Burnslib::StringList args;

   //lint -e(1058)   lint does not grok back_inserter

   int argCount = Win::GetCommandLineArgs(std::back_inserter(args));

   // should have at least one argument

   ASSERT(argCount);

   // give special treatment to the first arg: the name of the program

   String arg = args.front();
   args.pop_front();
   argmap[L"_command"] = arg;

   MapArgs(args.begin(), args.end(), argmap);
}



void
MapArgsHelper(const String& arg, ArgMap& argmap)
{
   String key;
   String value;
      
   if (arg[0] == L'/' || arg[0] == L'-')
   {
      // possibly of the form "/argname:value"
      // look for ':' to make sure

      size_t x = arg.find(L":");
      if (x != String::npos)
      {
         // found an arg of the form "/argname:value"

         key = arg.substr(1, x - 1);

         // check for the case "/:value"

         if (key.length())
         {
            value = arg.substr(x + 1);
         }
      }
      else
      {
         // form is "/argname" or "-argname", so remove the leading
         // character.

         key = arg.substr(1);
      }
   }

   // arg is of the form "argspec" (i.e. *not* of the form
   // "/argname:value")

   argmap[key] = value;
}



void
MapArgs(const String& args, ArgMap& argmap)
{
   PWSTR*     clArgs   = 0;
   int        argCount = 0;
   StringList tokens; 

   clArgs = ::CommandLineToArgvW(args.c_str(), &argCount);
   ASSERT(clArgs);
   if (clArgs)
   {
      while (argCount)
      {
         tokens.push_back(clArgs[argCount - 1]);
         --argCount;
      }

      Win::GlobalFree(clArgs);
   }

   MapArgs(tokens.begin(), tokens.end(), argmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\spewview.cpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 1999 Microsoft Corp.
//
// 9 November 1999 sburns



#include "headers.hxx"
#include "resource.h"
#include "MainDialog.hpp"



// The general idea is this: The machine running spewview.exe is the observer
// of a spewing application running remotely.  This machine is the server.
// The machine running the application that is spewing is the client.
// 
// The server should start spewview before the client starts the spewing app.
// 
// The server does the following:
//    -  creates a local pipe object
// 
//    -  sets the ACL on the pipe object to allow everyone write access
// 
//    -  connects to the client machine's registry, creates a volatile reg key
//       that contains the name of the server machine, and the name of the
//       pipe object.
//
//    -  spawns a separate thread to read the pipe and forward messages
//       to the edit control
// 
// The client does the following:
//    -  reads the registry for the reg values created by the server
// 
//    -  calls CreateFile on \\<server>\pipe\<pipe name> to get a
//       handle to the pipe
// 
//    -  spews to the pipe handle
//
// The client is implemented in burnslib\src\log.cpp



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"spewview";
const wchar_t* HELPFILE_NAME = 0;

DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_TYPICAL;

Popup popup(IDS_APP_TITLE);



int WINAPI
WinMain(
   HINSTANCE   hInstance, 
   HINSTANCE   /* hPrevInstance */ ,
   LPSTR       /* lpszCmdLine */ ,
   int         /* nCmdShow */ )
{
   hResourceModuleHandle = hInstance;

   ::CoInitialize(0);

   try
   {
      HMODULE m = 0;
      HRESULT hr = Win::LoadLibrary(L"riched32.dll", m);
      ASSERT(SUCCEEDED(hr));

      ::InitCommonControls();
      MainDialog().ModalExecute(Win::GetDesktopWindow());
   }
   catch (std::bad_alloc&)
   {
      popup.Error(
         Win::GetDesktopWindow(),
         L"Memory Allocation failure caught");
   }
   catch (...)
   {
      popup.Error(
         Win::GetDesktopWindow(),
         L"Unhandled Exception.");
   }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\computer.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Computer naming tool
//
// 12-1-97 sburns
// 10-26-1999 sburns (redone)



#include "headers.hxx"



static const wchar_t* TCPIP_PARAMS_KEY = 
   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

static const wchar_t* TCPIP_POLICY_KEY =
   L"Software\\Policies\\Microsoft\\System\\DNSclient";

static const wchar_t* NEW_HOSTNAME_VALUE = L"NV Hostname";
static const wchar_t* NEW_SUFFIX_VALUE   = L"NV Domain";
   
   

// rather than make this a nested type inside the Computer class, I chose
// to hide it completely as a private struct in the implementation file.

struct ComputerState
{
   bool            isLocal;            
   bool            isDomainJoined;
   bool            searchedForDnsDomainNames;
   String          netbiosComputerName;
   String          dnsComputerName;    
   String          netbiosDomainName;  
   String          dnsDomainName;      
   String          dnsForestName;      
   NT_PRODUCT_TYPE realProductType;
   Computer::Role  role;
   DWORD           verMajor;           
   DWORD           verMinor;           
   DWORD           safebootOption;

   ComputerState()
      :
      isLocal(false),
      isDomainJoined(false),
      searchedForDnsDomainNames(false),
      netbiosComputerName(),
      dnsComputerName(),
      netbiosDomainName(),  
      dnsDomainName(),      
      dnsForestName(),      
      realProductType(NtProductWinNt),
      role(Computer::STANDALONE_WORKSTATION),
      verMajor(0),
      verMinor(0),           
      safebootOption(0)
   {
   }

   // implicit dtor used
};



String
Computer::RemoveLeadingBackslashes(const String& computerName)
{
   LOG_FUNCTION2(Computer::RemoveLeadingBackslashes, computerName);

   static const String BACKSLASH(L"\\");

   String s = computerName;
   if (s.length() >= 2)
   {
      if ((s[0] == BACKSLASH[0]) and (s[1] == BACKSLASH[0]))
      {
         // remove the backslashes
         s.erase(0, 2);
      }
   }

   return s;
}



// Removes leading backslashes and trailing whitespace, if present, and
// returns the result.
// 
// name - string from which leading backslashes and trailing whitespace is to
// be stripped.

static
String
MassageName(const String& name)
{
   String result = Computer::RemoveLeadingBackslashes(name);
   result = result.strip(String::TRAILING, 0);

   return result;
}



Computer::Computer(const String& name)
   :
   ctorName(MassageName(name)),
   isRefreshed(false),
   state(0)
{
   LOG_CTOR(Computer);
}



Computer::~Computer()
{
   LOG_DTOR(Computer);

   delete state;
   state = 0;
}



Computer::Role
Computer::GetRole() const
{
   LOG_FUNCTION2(Computer::GetRole, GetNetbiosName());
   ASSERT(isRefreshed);

   Role result = STANDALONE_WORKSTATION;

   if (state)
   {
      result = state->role;
   }

   LOG(String::format(L"role: %1!X!", result));

   return result;
}



bool
Computer::IsDomainController() const
{
   LOG_FUNCTION2(Computer::IsDomainController, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   switch (GetRole())
   {
      case PRIMARY_CONTROLLER:
      case BACKUP_CONTROLLER:
      {
         result = true;
         break;
      }
      case STANDALONE_WORKSTATION:
      case MEMBER_WORKSTATION:
      case STANDALONE_SERVER:
      case MEMBER_SERVER:
      default:
      {
         // do nothing

         break;
      }
   }
   
   LOG(
      String::format(
         L"%1 a domain controller",
         result ? L"is" : L"is not"));
         
   return result;
}



String
Computer::GetNetbiosName() const
{
   LOG_FUNCTION(Computer::GetNetbiosName);
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->netbiosComputerName;
   }

   LOG(result);

   return result;
}



String
Computer::GetFullDnsName() const
{
   LOG_FUNCTION2(Computer::GetFullDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->dnsComputerName;
   }

   LOG(result);

   return result;
}



// Updates the dnsDomainName and dnsForestName members of the supplied
// ComputerState instance, if either of members are empty, and we have reason
// to believe that it's appropriate to attempt to do so.
// 
// Called by methods that are looking for the dnsDomainName and / or
// dnsForestName to ensure that those values are present.  They might not be
// read when the Computer instance is refreshed (which is normally the case),
// because the domain may have been upgraded since the time that the machine
// was joined to that domain.
// 
// state - ComputerState instance to update.

void
GetDnsDomainNamesIfNeeded(ComputerState& state)
{
   LOG_FUNCTION(GetDnsDomainNamesIfNeeded);

   if (
            // only applies if joined to a domain

            state.isDomainJoined

            // either name might be missing.

      and   (state.dnsDomainName.empty() or state.dnsForestName.empty())

            // should always be true, but just in case,

      and   !state.netbiosDomainName.empty()

            // don't search again -- it's too expensive

      and   !state.searchedForDnsDomainNames)
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      HRESULT hr =
         MyDsGetDcName(
            state.isLocal ? 0 : state.netbiosComputerName.c_str(),
            state.netbiosDomainName,
            DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
            info);
      if (SUCCEEDED(hr) && info)
      {
         if ((info->Flags & DS_DNS_DOMAIN_FLAG) and info->DomainName)
         {
            // we found a DS domain

            state.dnsDomainName = info->DomainName;

            ASSERT(info->DnsForestName);
            ASSERT(info->Flags & DS_DNS_FOREST_FLAG);

            if (info->DnsForestName)
            {
               state.dnsForestName = info->DnsForestName;
            }
         }
         ::NetApiBufferFree(info);
      }

      // flag the fact that we've looked, so we don't look again, as the
      // search is expensive.

      state.searchedForDnsDomainNames = true;
   }
}



String
Computer::GetDomainDnsName() const
{
   LOG_FUNCTION2(Computer::GetDomainDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      GetDnsDomainNamesIfNeeded(*state);
      result = state->dnsDomainName;
   }

   LOG(result);

   return result;
}



String
Computer::GetForestDnsName() const
{
   LOG_FUNCTION2(Computer::GetForestDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      GetDnsDomainNamesIfNeeded(*state);
      result = state->dnsForestName;
   }

   LOG(result);

   return result;
}



String
Computer::GetDomainNetbiosName() const
{
   LOG_FUNCTION2(Computer::GetDomainDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->netbiosDomainName;
   }

   LOG(result);

   return result;
}



// I can't think why I would need to do this, so I'm not.
// 
// static
// String
// canonicalizeComputerName(const String& computerName)
// {
//    LOG_FUNCTION2(canonicalizeComputerName, computerName);
// 
//    if (ValidateNetbiosComputerName(computerName) == VALID_NAME)
//    {
//       String s(MAX_COMPUTERNAME_LENGTH, 0);
// 
//       NET_API_STATUS err =
//          I_NetNameCanonicalize(
//             0,
//             const_cast<wchar_t*>(computerName.c_str()),
//             const_cast<wchar_t*>(s.c_str()),
//             s.length() * sizeof(wchar_t),
//             NAMETYPE_COMPUTER,
//             0);
//       if (err == NERR_Success)
//       {
//          // build a new string without trailing null characters.
//          return String(s.c_str());
//       }
//    }
// 
//    return String();
// }



bool
Computer::IsJoinedToDomain() const
{
   LOG_FUNCTION2(Computer::IsJoinedToDomain, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   if (state)
   {
      result = state->isDomainJoined;
   }

   LOG(
      String::format(
         L"%1 domain joined",
         result ? L"is" : L"is not"));
         
   return result;
}



bool
Computer::IsJoinedToWorkgroup() const
{
   LOG_FUNCTION2(Computer::IsJoinedToWorkgroup, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = !IsJoinedToDomain();

   LOG(
      String::format(
         L"%1 domain joined",
         result ? L"is" : L"is not"));
         
   return result;
}



bool
Computer::IsJoinedToDomain(const String& domainDnsName) const
{
   LOG_FUNCTION2(Computer::IsJoinedToDomain, domainDnsName);
   ASSERT(!domainDnsName.empty());
   ASSERT(isRefreshed);

   bool result = false;

   if (!domainDnsName.empty())
   {
      if (state and IsJoinedToDomain())
      {
         String d1 =
            GetDomainDnsName().strip(String::TRAILING, L'.');
         String d2 =
            String(domainDnsName).strip(String::TRAILING, L'.');
         result = (d1.icompare(d2) == 0);
      }
   }

   LOG(
      String::format(
         L"%1 joined to %2",
         result ? L"is" : L"is NOT",
         domainDnsName.c_str()));

   return result;
}



bool
Computer::IsLocal() const
{
   LOG_FUNCTION2(Computer::IsLocal, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   if (state)
   {
      result = state->isLocal;
   }

   LOG(
      String::format(
         L"%1 local machine",
         result ? L"is" : L"is not"));

   return result;
}



// Updates the following members of the ComputerState parameter with values
// from the local machine:
// 
// netbiosComputerName
// dnsComputerName
// verMajor
// verMinor
// 
// Note that the dnsComputerName may not have a value if tcp/ip is not
// installed and properly configured.  This is not considered an error
// condition.
// 
// Returns S_OK on success, or a failure code otherwise.
// 
// state - the ComputerState instance to be updated.

HRESULT
RefreshLocalInformation(ComputerState& state)
{
   LOG_FUNCTION(RefreshLocalInformation);

   state.netbiosComputerName =
      Win::GetComputerNameEx(ComputerNameNetBIOS);

   state.dnsComputerName =
      Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

   HRESULT hr = S_OK;

   do
   {
      OSVERSIONINFO verInfo;
      hr = Win::GetVersionEx(verInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      state.verMajor = verInfo.dwMajorVersion;
      state.verMinor = verInfo.dwMinorVersion;
   }
   while (0);

   return hr;
}



// Read the registry of a remote machine to determine the fully-qualified
// DNS computer name of that machine, taking into account any policy-imposed
// DNS suffix.
// 
// On success, stores the result in the dnsComputerName member of the supplied
// ComputerState instance, and returns S_OK;
// 
// On failure, clears the dnsComputerName member, and returns a failure code.
// Thre failure code (ERROR_FILE_NOT_FOUND) may indicate that the registry
// value(s) are not present, which means that TCP/IP is not installed or is
// not properly configured on the remote machine.
// 
// remoteRegHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of
// the remote computer.
// 
// state - ComputerState instance to be updated with the resulting name.

HRESULT
DetermineRemoteDnsComputerName(
   HKEY           remoteRegHKLM,
   ComputerState& state)        
{
   state.dnsComputerName.erase();

   String hostname;
   String suffix;
   String policySuffix;
   bool   policyInEffect = false;

   HRESULT hr = S_OK;

   do
   {
      RegistryKey key;
      hr = key.Open(remoteRegHKLM, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      // Read these values without checking for failure, as empty string
      // is ok.

      hostname = key.GetString(L"Hostname");
      suffix   = key.GetString(L"Domain");  
      
      // We need to check to see if there is a policy-supplied dns suffix

      if (state.realProductType != NtProductLanManNt)
      {
         hr = key.Open(remoteRegHKLM, TCPIP_POLICY_KEY);
         if (SUCCEEDED(hr))
         {
            hr = key.GetValue(L"PrimaryDnsSuffix", policySuffix);
            if (SUCCEEDED(hr))
            {
               // a policy-supplied computer DNS domain name is in effect.

               policyInEffect = true;
            }
         }
      }
   }
   while (0);

   if (!hostname.empty())
   {
      state.dnsComputerName =
         Computer::ComposeFullDnsComputerName(
            hostname,
            policyInEffect ? policySuffix : suffix);
   }

   return hr;
}



// Returns true if the computer represented by the provided ComputerState is
// a domain controller booted in DS repair mode.  Returns false otherwise.
// 
// state - a "filled-in" ComputerState instance.

bool
IsDcInRepairMode(const ComputerState& state)
{
   LOG_FUNCTION(IsDcInRepairMode);

   if (
          state.safebootOption  == SAFEBOOT_DSREPAIR
      and state.realProductType == NtProductLanManNt)
   {
      return true;
   }

   return false;
}



// Sets the following members of the supplied ComputerState struct, based on
// the current values of the isLocal and netbiosComputerName members of the
// same struct.  Returns S_OK on success, or an error code on failure.
// 
// role
// isDomainJoined
// 
// optionally sets the following, if applicable:
// 
// dnsForestName
// dnsDomainName
// netbiosDomainName
// 
// state - instance with isLocal and netbiosComputerName members previously
// set.  The members mentioned above will be overwritten.

HRESULT
DetermineRoleAndMembership(ComputerState& state)
{
   LOG_FUNCTION(DetermineRoleAndMembership);

   HRESULT hr = S_OK;

   do
   {
      DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
      hr = 
         MyDsRoleGetPrimaryDomainInformation(
            state.isLocal ? 0 : state.netbiosComputerName.c_str(),
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      if (info->DomainNameFlat)
      {
         state.netbiosDomainName = info->DomainNameFlat;
      }
      if (info->DomainNameDns)
      {
         // not always present, even if the domain is NT 5.  See note
         // for GetDnsDomainNamesIfNeeded.

         state.dnsDomainName = info->DomainNameDns;
      }
      if (info->DomainForestName)
      {
         // not always present, even if the domain is NT 5.  See note
         // for GetDnsDomainNamesIfNeeded.

         state.dnsForestName = info->DomainForestName;
      }

      switch (info->MachineRole)
      {
         case DsRole_RoleStandaloneWorkstation:
         {
            state.role = Computer::STANDALONE_WORKSTATION;
            state.isDomainJoined = false;

            break;
         }
         case DsRole_RoleMemberWorkstation:
         {
            state.role = Computer::MEMBER_WORKSTATION;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RoleStandaloneServer:
         {
            state.role = Computer::STANDALONE_SERVER;
            state.isDomainJoined = false;

            // I wonder if we're really a DC booted in ds repair mode?

            if (IsDcInRepairMode(state))
            {
               LOG(L"machine is in ds repair mode");

               state.role = Computer::BACKUP_CONTROLLER;
               state.isDomainJoined = true;

               // the domain name will be reported as "WORKGROUP", which
               // is wrong, but that's the way the ds guys wanted it.
            }

            break;
         }
         case DsRole_RoleMemberServer:
         {
            state.role = Computer::MEMBER_SERVER;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RolePrimaryDomainController:
         {
            state.role = Computer::PRIMARY_CONTROLLER;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RoleBackupDomainController:
         {
            state.role = Computer::BACKUP_CONTROLLER;
            state.isDomainJoined = true;

            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   while (0);

   if (FAILED(hr))
   {
      // infer a best-guess on the role from the product type

      state.isDomainJoined = false;

      switch (state.realProductType)
      {
         case NtProductWinNt:
         {
            state.role = Computer::STANDALONE_WORKSTATION;
            break;
         }
         case NtProductServer:
         {
            state.role = Computer::STANDALONE_SERVER;
            break;
         }
         case NtProductLanManNt:
         {
            state.isDomainJoined = true;
            state.role = Computer::BACKUP_CONTROLLER;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }

   return hr;
}



// Sets the isLocal member of the provided ComputerState instance to true if
// the given name refers to the local computer (the computer on which this
// code is executed).  Sets the isLocal member to false if not, or on error.
// Returns S_OK on success or an error code on failure. May also set the
// following:
// 
// netbiosComputerName
// verMajor
// verMinor
// 
// state - instance of ComputerState to be modified.
// 
// ctorName - the computer name with which an instance of Computer was
// constructed.  This may be any computer name form (netbios, dns, ip
// address).
   
HRESULT
IsLocalComputer(ComputerState& state, const String& ctorName)
{
   LOG_FUNCTION(IsLocalComputer);

   HRESULT hr = S_OK;
   bool result = false;

   do
   {
      if (ctorName.empty())
      {
         // an unnamed computer always represent the local computer.

         result = true;
         break;
      }

      String localNetbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);

      if (ctorName.icompare(localNetbiosName) == 0)
      {
         result = true;
         break;
      }
   
      String localDnsName =
         Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      if (ctorName.icompare(localDnsName) == 0)
      {
         // the given name is the same as the fully-qualified dns name
         
         result = true;
         break;
      }

      // we don't know what kind of name it is.  Ask the workstation service
      // to resolve the name for us, and see if the result refers to the
      // local machine.

      // NetWkstaGetInfo returns the netbios name for a given machine, given
      // a DNS, netbios, or IP address.

      WKSTA_INFO_100* info = 0;
      hr = MyNetWkstaGetInfo(ctorName, info);
      BREAK_ON_FAILED_HRESULT(hr);

      state.netbiosComputerName = info->wki100_computername;
      state.verMajor            = info->wki100_ver_major;   
      state.verMinor            = info->wki100_ver_minor;   

      ::NetApiBufferFree(info);

      if (state.netbiosComputerName.icompare(localNetbiosName) == 0)
      {
         // the given name is the same as the netbios name
         
         result = true;
         break;
      }
   }
   while (0);

   state.isLocal = result;

   return hr;
}



HRESULT
Computer::Refresh()
{
   LOG_FUNCTION(Computer::Refresh);

   // erase all the state that we may have set before

   isRefreshed = false;

   delete state;
   state = new ComputerState;

   HRESULT hr = S_OK;
   HKEY registryHKLM = 0;
   do
   {
      // First, determine if the computer this instance represents is the
      // local computer.

      hr = IsLocalComputer(*state, ctorName);
      BREAK_ON_FAILED_HRESULT(hr);

      // Next, based on whether the machine is local or not, populate the
      // netbios and dns computer names, and version information.

      if (state->isLocal)
      {
         // netbiosComputerName
         // dnsComputerName
         // version

         hr = RefreshLocalInformation(*state);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      else
      {
         // IsLocalComputer has already set:
         // netbiosComputerName
         // version

         ASSERT(!state->netbiosComputerName.empty());
         ASSERT(state->verMajor);
      }

      // We will need to examine the registry to determine the safeboot
      // option and real product type.

      hr =
         Win::RegConnectRegistry(
            state->isLocal ? String() : L"\\\\" + state->netbiosComputerName,
            HKEY_LOCAL_MACHINE,
            registryHKLM);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = GetProductTypeFromRegistry(registryHKLM, state->realProductType);
      BREAK_ON_FAILED_HRESULT(hr);

      if (!state->isLocal)
      {
         // still need to get dnsComputerName, which we can do now that
         // we know the real product type.

         // The DNS Computer name can be determined be reading the remote
         // registry.

         hr = DetermineRemoteDnsComputerName(registryHKLM, *state);
         if (FAILED(hr) and hr != Win32ToHresult(ERROR_FILE_NOT_FOUND))
         {
            // if the DNS registry settings are not present, that's ok.
            // but otherwise:

            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      // We'll need to know the safeboot option to determine the role
      // in the next step.

      hr = GetSafebootOption(registryHKLM, state->safebootOption);
      if (FAILED(hr) and hr != Win32ToHresult(ERROR_FILE_NOT_FOUND))
      {
         // if the safeboot registry settings are not present, that's ok.
         // but otherwise:

         BREAK_ON_FAILED_HRESULT(hr);
      }

      // Next, determine the machine role and domain membership

      hr = DetermineRoleAndMembership(*state);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (registryHKLM)
   {
      Win::RegCloseKey(registryHKLM);
   }

   if (SUCCEEDED(hr))
   {
      isRefreshed = true;
   }

   return hr;
}



String
Computer::ComposeFullDnsComputerName(
   const String& hostname,
   const String& domainSuffix)
{
   LOG_FUNCTION2(
      Computer::ComposeFullDnsComputerName,
      String::format(
         L"hostname: %1 suffix: %2",
         hostname.c_str(),
         domainSuffix.c_str()));
   ASSERT(!hostname.empty());

   // The domain name may be empty if the machine is unjoined...

   if (domainSuffix.empty() or domainSuffix == L".")
   {
      // "computername."

      return hostname + L".";
   }

   // "computername.domain"

   return hostname + L"." + domainSuffix;
}



HRESULT
Computer::GetSafebootOption(HKEY regHKLM, DWORD& result)
{
   LOG_FUNCTION(GetSafebootOption);
   ASSERT(regHKLM);

   result = 0;
   HRESULT hr = S_OK;

   RegistryKey key;

   do
   {
      hr =       
         key.Open(
            regHKLM,
            L"System\\CurrentControlSet\\Control\\SafeBoot\\Option");
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.GetValue(L"OptionValue", result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG(String::format(L"returning : 0x%1!X!", result));

   return hr;
}



HRESULT
Computer::GetProductTypeFromRegistry(HKEY regHKLM, NT_PRODUCT_TYPE& result)
{
   LOG_FUNCTION(GetProductTypeFromRegistry);
   ASSERT(regHKLM);

   result = NtProductWinNt;
   HRESULT hr = S_OK;

   RegistryKey key;

   do
   {
      hr =       
         key.Open(
            regHKLM,
            L"System\\CurrentControlSet\\Control\\ProductOptions");
      BREAK_ON_FAILED_HRESULT(hr);

      String prodType;
      hr = key.GetValue(L"ProductType", prodType);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(prodType);

      // see ntos\rtl\prodtype.c, which uses case-insensitive unicode string
      // compare.

      if (prodType.icompare(L"WinNt") == 0)
      {
         result = NtProductWinNt;
      }
      else if (prodType.icompare(L"LanmanNt") == 0)
      {
         result = NtProductLanManNt;
      }
      else if (prodType.icompare(L"ServerNt") == 0)
      {
         result = NtProductServer;
      }
      else
      {
         LOG(L"unknown product type, assuming workstation");
      }
   }
   while (0);

   LOG(String::format(L"prodtype : 0x%1!X!", result));

   return hr;
}



String
Computer::GetFuturePhysicalNetbiosName()
{
   LOG_FUNCTION(Computer::GetFuturePhysicalNetbiosName);

   // the default future name is the existing name.
      
   String name = Win::GetComputerNameEx(ComputerNamePhysicalNetBIOS);
   RegistryKey key;

   HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, REGSTR_PATH_COMPUTRNAME);

   if (SUCCEEDED(hr))
   {
      hr = key.GetValue(REGSTR_VAL_COMPUTRNAME, name);
   }

   LOG_HRESULT(hr);
   LOG(name);
   
   return name;
}



String
Computer::GetActivePhysicalNetbiosName()
{
   LOG_FUNCTION(Computer::GetActivePhysicalNetbiosName);

   String result = Win::GetComputerNameEx(ComputerNamePhysicalNetBIOS);

   LOG(result);

   return result;   
}



// see base\win32\client\compname.c
      
bool
Computer::IsDnsSuffixPolicyInEffect(String& policyDnsSuffix)
{
   LOG_FUNCTION(Computer::IsDnsSuffixPolicyInEffect);

   bool policyInEffect = false;
   policyDnsSuffix.erase();

   NT_PRODUCT_TYPE productType = NtProductWinNt;
   if (!::RtlGetNtProductType(&productType))
   {
      // on failure, do nothing; assume workstation         

      ASSERT(false);
   }
   
   if (productType != NtProductLanManNt)
   {
      RegistryKey key;
      
      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_POLICY_KEY);
      if (SUCCEEDED(hr))
      {
         hr = key.GetValue(L"PrimaryDnsSuffix", policyDnsSuffix);
         if (SUCCEEDED(hr))
         {
            // a policy-supplied computer DNS domain name is in effect.

            policyInEffect = true;
         }
      }
   }

   LOG(policyInEffect ? L"true" : L"false");
   LOG(policyDnsSuffix);

   return policyInEffect;
}



String
Computer::GetActivePhysicalFullDnsName()
{
   LOG_FUNCTION(Computer::GetActivePhysicalFullDnsName);

   // As a workaround to NTRAID#NTBUG9-216349-2000/11/01-sburns, compose our
   // own full DNS name from the hostname and suffix.

   String hostname = Win::GetComputerNameEx(ComputerNamePhysicalDnsHostname);
   String suffix   = Win::GetComputerNameEx(ComputerNamePhysicalDnsDomain);  
   String result   = Computer::ComposeFullDnsComputerName(hostname, suffix);

   LOG(result);

   return result;
}



String
Computer::GetFuturePhysicalFullDnsName()
{
   LOG_FUNCTION(Computer::GetFuturePhysicalFullDnsName);

   String result = Computer::GetActivePhysicalFullDnsName();
   RegistryKey key;

   HRESULT hr = S_OK;
   
   do
   {
      hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);

      // may be that there are no dns name parameters at all, probably because
      // tcp/ip is not installed.  So the future name == active name
      
      BREAK_ON_FAILED_HRESULT(hr);

      String hostname;
      hr = key.GetValue(NEW_HOSTNAME_VALUE, hostname);

      if (FAILED(hr))
      {
         // no new hostname set (or we can't tell what it is).  So the future
         // hostname is the active hostname.
         
         hostname = Win::GetComputerNameEx(ComputerNamePhysicalDnsHostname);
      }
      
      String suffix;
      hr = key.GetValue(NEW_SUFFIX_VALUE, suffix);
      if (FAILED(hr))
      {
         // no new suffix set (or we can't tell what it is).  So the future
         // suffix is the active suffix.
         
         suffix = Win::GetComputerNameEx(ComputerNamePhysicalDnsDomain);
      }

      // Decide which suffix -- local or policy -- is in effect

      String policyDnsSuffix;
      bool policyInEffect =
         Computer::IsDnsSuffixPolicyInEffect(policyDnsSuffix);

      result =
         Computer::ComposeFullDnsComputerName(
            hostname,
            policyInEffect ? policyDnsSuffix : suffix);
   }
   while (0);
   
   LOG_HRESULT(hr);
   LOG(result);
   
   return result;
}








// Implementation notes: please don't delete:

// Init/Refresh
// 
//    if given name empty,
//       set is local = true
// 
//    if !given name empty,
//       Win::IsLocalComputer(given name), if same set is local = true
// 
//    connect to local/remote registry
// 
//    read safe boot mode
//    read real product type
// 
//    if local 
//       get local dns name (getcomputernameex)
//       get local netbios name (getcomputernameex)
//       get version (getversion)
// 
//    if not local
//       call netwkstagetinfo,
//          get netbios name
//          get version
//       get dns name (account for policy, which requires real prod type)
// 
//    call dsrolegpdi (with netbios name if !local)
//       if succeeded
//          set role
//          set netbios domain name
//          set dns domain name
//          set dns forest name
//          set is joined
// 
//       if failed
//          infer role from real product type
// 
//    set is dc in restore mode
//
//
// true role
//    is dc                                x
//    is dc in restore mode                x
// netbios name                         x
// dns name                             x
//    is local machine                     x
// dns domain name                      x
// netbios domain name                  x
//    is joined to domain X                x
//    is domain joined                     x
//    is workgroup joined                  x
// dns forest name                      x
// version                              x
// is booted safe mode                  x
// 
// 
// netwkstgetinfo(100)
//    version
//    if name is netbios or not
// 
// registry:
//    real product type
//    safe boot mode
//    netbios name
//    dns name (remember to account for policy)
//      
// dsrolegpdi
//    role (wrong if in safeboot)
//    netbios domain name
//    dns domain name
//    dns forest name (also available from dsgetdcname)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\spewview\spewdialog.hpp ===
// Spewview: remote debug spew monitor
//
// Copyright (c) 2000 Microsoft Corp.
//
// Spew monitoring window: modeless dialog to capture spewage
//
// 16 Mar 2000 sburns



#ifndef SPEWWINDOW_HPP_INCLUDED
#define SPEWWINDOW_HPP_INCLUDED



class SpewDialog : public Dialog
{
   public:

   SpewDialog(const String& clientName, const String& appName);

   virtual
   ~SpewDialog();

   static const int WM_ENABLE_START   = WM_USER + 202;
   static const int WM_UPDATE_SPEWAGE = WM_USER + 203;

   private:

   void
   AppendMessage(WPARAM wparam, const String& message);

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   void
   OnStartButton();

   void
   OnStopButton();

   void
   ComputeMargins();

   void
   ResizeSpewWindow(int newParentWidth, int newParentHeight);

   void
   StartReadingSpewage();

   void
   StopReadingSpewage();

   // not defined: no copying allowed

   SpewDialog(const SpewDialog&);
   const SpewDialog& operator=(const SpewDialog&);

   int    spewLineCount;   
   int    textBoxLineCount;
   RECT   margins;         
   String clientName;      
   String appName;
   bool   readerThreadCreated;
   int    endReaderThread;
};



#endif   // SPEWWINDOW_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\controlsubclasser.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// windows control subclassing wrapper
//
// 22 Nov 2000 sburns



#include "headers.hxx"
#include "ControlSubclasser.hpp"



ControlSubclasser::ControlSubclasser()
   :
   hwnd(0),
   originalWindowProc(0)
{
   LOG_CTOR(ControlSubclasser);
}



ControlSubclasser::~ControlSubclasser()
{
   LOG_DTOR(ControlSubclasser);

   UnhookWindowProc();
}



HRESULT
ControlSubclasser::Init(HWND control)
{
   LOG_FUNCTION(ControlSubclasser::Init);
   ASSERT(Win::IsWindow(control));

   // hwnd should not be set, nor originalWindowProc.  If they are, then
   // Init has been called already.
      
   ASSERT(!hwnd);
   ASSERT(!originalWindowProc);

   hwnd = control;

   HRESULT hr = S_OK;

   do
   {
      // save our this pointer so we can find ourselves again when messages
      // are sent to the window.

      hr = Win::SetWindowLongPtr(
         hwnd,
         GWLP_USERDATA,
         reinterpret_cast<LONG_PTR>(this));
      BREAK_ON_FAILED_HRESULT(hr);
            
      // hook the windows procedure.

      LONG_PTR ptr = 0;
      hr = Win::GetWindowLongPtr(hwnd, GWLP_WNDPROC, ptr);
      BREAK_ON_FAILED_HRESULT(hr);

      originalWindowProc = reinterpret_cast<WNDPROC>(ptr);
      
      if (!originalWindowProc)
      {
         LOG(L"unable to hook winproc");
         
         hr = E_FAIL;
         break;
      }

      hr = Win::SetWindowLongPtr(
         hwnd,
         GWLP_WNDPROC,
         reinterpret_cast<LONG_PTR>(ControlSubclasser::WindowProc));
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      // if we failed to save the this pointer, then we will never get
      // called back, as we don't try to hook the window proc.

      // if we fail to hook the window proc, then we will never get called
      // back, and the saved this pointer is irrelevant.
      
      hwnd = 0;
      originalWindowProc = 0;
   }

   return hr;
}



void
ControlSubclasser::UnhookWindowProc()
{
   LOG_FUNCTION(ControlSubclasser::UnhookWindowProc);

   if (Win::IsWindow(hwnd) && originalWindowProc)
   {
      // unhook the window proc

      Win::SetWindowLongPtr(
         hwnd,
         GWLP_WNDPROC,
         reinterpret_cast<LONG_PTR>(originalWindowProc));
   }
}



LRESULT
ControlSubclasser::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(ControlSubclasser::OnMessage);

   switch (message)
   {
      case WM_DESTROY:
      {
         UnhookWindowProc();
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return ::CallWindowProc(originalWindowProc, hwnd, message, wparam, lparam);
}




LRESULT
CALLBACK
ControlSubclasser::WindowProc(
    HWND   window, 
    UINT   message,
    WPARAM wparam, 
    LPARAM lparam)
{
   // LOG_FUNCTION(ControlSubclasser::WindowProc)

   LRESULT result = 0;
      
   LONG_PTR ptr = 0;
   HRESULT hr = Win::GetWindowLongPtr(window, GWLP_USERDATA, ptr);

   if (SUCCEEDED(hr))
   {
      ControlSubclasser* that =
         reinterpret_cast<ControlSubclasser*>(ptr);

      ASSERT(that);

      result = that->OnMessage(message, wparam, lparam);
   }
   else
   {
      ASSERT(false);
   }

   return result;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\diagnosedcnotfound.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// diagnose domain controller not found problems, offer a popup dialog to assail the user
// with the results.
//
// 9 October 2000 sburns



// In order for clients of these functions to get the proper resources, the clients need to include
// burnslib\inc\DiagnoseDcNotFound.rc in their resources.  For an example, see admin\dcpromo\exe\dcpromo.rc



#include "headers.hxx"
#include "DiagnoseDcNotFound.h"
#include "DiagnoseDcNotFound.hpp"



// Return a string of IP addresses, each separated by a CRLF, one address for
// each DNS server specified in this machines TCP/IP protocol configuration.
// On failure, the return value is the empty string.

String
GetListOfClientDnsServerAddresses()
{
   LOG_FUNCTION(GetListOfClientDnsServerAddresses);

   String result = String::load(IDS_NO_ADDRESSES);

   PIP_ARRAY pipArray = 0;
   DWORD bufSize = sizeof(IP_ARRAY);

   do
   {   
      DNS_STATUS status =
         ::DnsQueryConfig(
            DnsConfigDnsServerList,
            DNS_CONFIG_FLAG_ALLOC,
            0,
            0,
            &pipArray,
            &bufSize);
      if (status != ERROR_SUCCESS || !pipArray || !pipArray->AddrArray)
      {
         LOG(String::format(L"DnsQueryConfig failed %1!d!", status));
         break;
      }

      result = L"";
      PIP_ADDRESS pIpAddrs = pipArray->AddrArray;
      while (pipArray->AddrCount--)
      {
         result +=
            String::format(
               L"%1!d!.%2!d!.%3!d!.%4!d!\r\n",
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 0 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 1 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 2 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 3 ) );
      }
   }
   while (0);

   Win::LocalFree(pipArray);
      
   LOG(result);

   return result;
}



// Return a string of DNS zone names derived from the given DNS domain name.
// Each zone is separated by a CRLF.  The last zone is the root zone, even if
// the domain name is the empty string, or a fully-qualified domain name.
// 
// example: if "foo.bar.com" is passed as the domain name, then the result is
// "foo.bar.com
// bar.com
// com
// . (the root zone)"
// 
// domainDnsName - in, the DNS domain name.

String
GetListOfZones(const String domainDnsName)
{
   LOG_FUNCTION2(GetListOfZones, domainDnsName);
   ASSERT(!domainDnsName.empty());

   String result;
   String zone = domainDnsName;

   while (zone != L"." && !zone.empty())
   {
      result += zone + L"\r\n";
      zone = Dns::GetParentDomainName(zone);
   }

   result += String::load(IDS_ROOT_ZONE);

   LOG(result);

   return result;
}



// Return a formatted string describing the given error code, including the
// corresponding error message, the error code in hex, and the symbolic name
// of the error code (e.g. "DNS_RCODE_NAME_ERROR")
// 
// errorCode - in, the DNS error code

String
GetErrorText(DNS_STATUS errorCode)
{
   LOG_FUNCTION(GetErrorText);

   String result = 
      String::format(
         IDS_DC_NOT_FOUND_DIAG_ERROR_CODE,
         GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
         errorCode,
         MyDnsStatusString(errorCode).c_str());

   LOG(result);

   return result;      
}



// For each SRV record in the given linked list of DnsQuery results, extract
// the name of the machine.  Compose a string of all the names, separated by
// CRLFs.  If no SRV records are found, then return a string saying (to the
// effect) "none found"
// 
// queryResults - in, the linked list of DNS_RECORDs -- the result of calling
// DnsQuery.  Should not be null.

String
GetListOfDomainControllers(DNS_RECORD* queryResults)
{
   LOG_FUNCTION(GetListOfDomainControllers);
   ASSERT(queryResults);

   String result;
   
   if (queryResults)
   {
      DNS_RECORD* record = queryResults;
      while (record)
      {
         if (record->wType == DNS_TYPE_SRV)
         {
            // Extract the domain controller name from the RDATA

            result += String(record->Data.SRV.pNameTarget) + L"\r\n";
         }

         record = record->pNext;
      }
   }

   if (result.empty())
   {
      result = String::load(IDS_DC_NOT_FOUND_NO_RESULTS);
   }
   
   LOG(result);

   return result;
}

   

// Returns a text string describing the likely causes of DsGetDcName failing.
// Performs DnsQuery(ies) and exmaines the results.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  This name may be a netbios or DNS name, but the DNS
// diagnostics portion of the result text will not be useful if the name is a
// netbios name.
// 
// nameIsNotNetbios - in, if the caller knows that the domain named in
// the domainName parameter can't possibly be a netbios domain name, then this
// value should be true.  If the caller is not sure, then false should be
// passed.
// 
// helpTopic - out, the help topic link corresponding to the diagnostic result
// (HtmlHelp is used to display the link)

String
DiagnoseDcNotFound(
   const String&  domainName,
   bool           nameIsNotNetbios,
   String&        helpTopic)
{
   LOG_FUNCTION2(DiagnoseDcNotFound, domainName);
   ASSERT(!domainName.empty());

   String result = String::load(IDS_DC_NOT_FOUND_DIAG_NO_RESULTS);
   String message; 
   helpTopic.erase();
      
   // first possibility is that the name is a netbios name.  Let's check.

   if (
         domainName.length() > DNLEN
      || domainName.find_first_of(L".") != String::npos)
   {
      // Name is too long to be netbios, or contains dots.
      // 
      // While it is technically possible for a netbios domain name to contain
      // dots, we've been prohibiting it since win2k, and an administrator
      // from before that would have to have been spectacularly unwise to have
      // chosen such a name.
      // 
      // If I don't check for dots here, then as sure as it rains in Redmond,
      // someone will complain that a name with dots in it sure doesn't look
      // like a netbios name, so this code had better not imply that it is.

      nameIsNotNetbios = true;
   }

   if (!nameIsNotNetbios)
   {
      // i.e. name might be a netbios name

      message += 
         String::format(
            IDS_DC_NOT_FOUND_NETBIOS_PREFACE,
            domainName.c_str());
   }

   // attempt to find domain controllers for the domain with DNS

   String serverName = L"_ldap._tcp.dc._msdcs." + domainName;
         
   DNS_RECORD* queryResults = 0;
   DNS_STATUS status =
      MyDnsQuery(
         serverName,
         DNS_TYPE_SRV,
         DNS_QUERY_BYPASS_CACHE,
         queryResults);
   switch (status)
   {
      case DNS_ERROR_RCODE_SERVER_FAILURE:
      {
         // message F (message letters correspond to those in the spec)

         String zones = GetListOfZones(domainName);
         String addresses = GetListOfClientDnsServerAddresses();

         message +=
            String::format(
               IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),
               addresses.c_str(),
               zones.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageF.htm";
         
         break;
      }
      case DNS_ERROR_RCODE_NAME_ERROR:
      {
         // message E

         String zones = GetListOfZones(domainName);
         
         message +=
            String::format(
               IDS_DC_NOT_FOUND_NAME_ERROR,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),               
               zones.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageE.htm";
         
         break;
      }
      case ERROR_TIMEOUT:
      {
         // message B

         String addresses = GetListOfClientDnsServerAddresses();

         message +=
            String::format(
               IDS_DC_NOT_FOUND_TIMEOUT,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),               
               addresses.c_str());
         
         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageB.htm";
         
         break;
      }
      case NO_ERROR:
      {
         if (queryResults)
         {
            // non-empty query results -- message Hb

            String dcs = GetListOfDomainControllers(queryResults);

            message +=
               String::format(
                  IDS_DC_NOT_FOUND_NO_ERROR_1,
                  domainName.c_str(),
                  serverName.c_str(),
                  dcs.c_str());
                              
            helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageHa.htm";
            break;
         }

         // empty query results -- message A
         // fall thru to default case
      }
      default:
      {
         // message A

         message +=
            String::format(
               IDS_DC_NOT_FOUND_DEFAULT,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageA.htm";
         
         break;
      }
   }

   MyDnsRecordListFree(queryResults);

   if (!message.empty())
   {
      result = message;
   }
   
   LOG(result);

   return result;   
}



// Class for displaying the a "dc not found" error and offering to run a
// diagnostic test to determine why the dc was not found.

class DcNotFoundErrorDialog : public Dialog
{
   public:

   // domainName - in, the name of the domain for which a domain controller
   // can't be located.  This name may be a netbios or DNS name, but the DNS
   // diagnostics portion of the result text will not be useful if the name is
   // a netbios name.
   //          
   // dialogTitle - in, the title of the error dialog.
   //       
   // errorMessage - in, the error message to be displayed in the dialog
   //    
   // domainNameIsNotNetbios - in, if the caller knows that the domain named
   // in the domainName parameter can't possibly be a netbios domain name,
   // then this value should be true.  If the caller is not sure, then false
   // should be passed.
   // 
   // userIsDomainSavvy - in, true if the end user is expected to be an
   // administrator or somesuch that might have an inkling what DNS is and how
   // to configure it.  If false, then the function will preface the
   // diagnostic text with calming words that hopefully prevent the
   // non-administrator from weeping.
   
   DcNotFoundErrorDialog(
      const String&  domainName,
      const String&  dialogTitle,
      const String&  errorMessage,
      bool           domainNameIsNotNetbios,
      bool           userIsDomainSavvy);

   virtual ~DcNotFoundErrorDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   void
   HideDetails();

   void
   ShowDetails();
   
   void
   DiagnoseAndSetDetailsText();
   
   String dialogTitle;
   bool   diagnosticWasRun;
   String domainName;            
   String errorMessage;          
   bool   domainNameIsNotNetbios;
   String helpTopicLink;         
   bool   detailsShowing;
   bool   userIsDomainSavvy;
   LONG   originalHeight;        

   // not defined: no copying allowed

   DcNotFoundErrorDialog(const DcNotFoundErrorDialog&);
   const DcNotFoundErrorDialog& operator=(const DcNotFoundErrorDialog&);
};



static const DWORD HELP_MAP[] =
{
   0, 0
};



DcNotFoundErrorDialog::DcNotFoundErrorDialog(
   const String&  domainName_,
   const String&  dialogTitle_,
   const String&  errorMessage_,
   bool           domainNameIsNotNetbios_,
   bool           userIsDomainSavvy_)
   :
   Dialog(IDD_DC_NOT_FOUND, HELP_MAP),
   dialogTitle(dialogTitle_),
   diagnosticWasRun(false),
   domainName(domainName_),
   errorMessage(errorMessage_),
   userIsDomainSavvy(userIsDomainSavvy_),
   domainNameIsNotNetbios(domainNameIsNotNetbios_),
   detailsShowing(false)
{
   LOG_CTOR(DcNotFoundErrorDialog);
   ASSERT(!domainName.empty());
   ASSERT(!errorMessage.empty());
   ASSERT(!dialogTitle.empty());

   // fall back to a default title
      
   if (dialogTitle.empty())
   {
      dialogTitle = String::load(IDS_DC_NOT_FOUND_TITLE);
   }
}



DcNotFoundErrorDialog::~DcNotFoundErrorDialog()
{
   LOG_DTOR(DcNotFoundErrorDialog);
}



void
DcNotFoundErrorDialog::OnInit()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::OnInit);

   Win::SetWindowText(hwnd, dialogTitle);   
   Win::SetDlgItemText(hwnd, IDC_ERROR_MESSAGE, errorMessage);

   // save the full size of the dialog so we can restore it later.
   
   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);

   originalHeight = fullRect.bottom - fullRect.top;

   HideDetails();
}



// resize the window to hide the details portion

void
DcNotFoundErrorDialog::HideDetails()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::HideDetails);

   // find the location of the horizontal line

   HWND line = Win::GetDlgItem(hwnd, IDC_HORIZONTAL_LINE);
   RECT lineRect;
   Win::GetWindowRect(line, lineRect);

   // find the dimensions of the dialog

   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);
   
   LONG shortHeight = lineRect.bottom - fullRect.top;

   MoveWindow(
      hwnd,
      fullRect.left,
      fullRect.top,
      fullRect.right - fullRect.left,
      shortHeight,
      true);
}



// resize the window to show the diagnostic results

void
DcNotFoundErrorDialog::ShowDetails()
{
   LOG_FUNCTION(DcNoFoundErrorDialog::ShowDetails);

   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);
   
   MoveWindow(
      hwnd,
      fullRect.left,
      fullRect.top,
      fullRect.right - fullRect.left,
      originalHeight,
      true);
}



// Write the diagnostic text to a well-known file
// (%systemroot%\debug\dcdiag.txt), and return the name of the file.  Replaces
// the file if it exists already.  Return S_OK on success, or an error code on
// failure.  (On failure, the existence and contents of the file are not
// guaranteed).  The file is written in Unicode, as it may contain Unicode
// text (like non-rfc domain names).
// 
// contents - in, the text to be written.  Should not be the empty string.
// 
// filename - out, the name of the file that was written (on success), or
// would have been written (on failure).

HRESULT
WriteLogFile(const String& contents, String& filename)
{
   LOG_FUNCTION(WriteLogFile);
   ASSERT(!contents.empty());

   filename.erase();
   HRESULT hr = S_OK;
   HANDLE handle = INVALID_HANDLE_VALUE;
   
   do
   {
      String path = Win::GetSystemWindowsDirectory();

      filename = path + L"\\debug\\dcdiag.txt";

      hr =
         FS::CreateFile(
            filename,
            handle,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            CREATE_ALWAYS);
      BREAK_ON_FAILED_HRESULT(hr);            

      hr = FS::Write(handle, contents);
      BREAK_ON_FAILED_HRESULT(hr);            
   }
   while (0);

   Win::CloseHandle(handle);
   
   LOG_HRESULT(hr);

   return hr;
}



// Run the diagnostic, and populate the UI with the results.  Also writes
// the results to a file if the user is deemed easily spooked.

void
DcNotFoundErrorDialog::DiagnoseAndSetDetailsText()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::DiagnoseAndSetDetailsText);

   if (!diagnosticWasRun)
   {
      String details =
         DiagnoseDcNotFound(
            domainName,
            domainNameIsNotNetbios,
            helpTopicLink);

      if (!userIsDomainSavvy)
      {
         // The diagnosis will probably just frighten the poor user.  So write
         // the diagnostic info to a file, and preface all the icky computer
         // lingo with a soothing message about just delivering the file to an
         // administrator.

         String logFilename;
         HRESULT hr = WriteLogFile(details, logFilename);

         if (SUCCEEDED(hr))
         {
            details =
                  String::format(
                     IDS_DC_NOT_FOUND_SOOTHING_PREFACE_PARAM,
                     logFilename.c_str())
               +  details;
         }
         else
         {
            details = String::load(IDS_DC_NOT_FOUND_SOOTHING_PREFACE) + details;
         }
      }
   
      Win::SetDlgItemText(hwnd, IDC_DETAILS_TEXT, details);

      diagnosticWasRun = true;
   }
}

   

bool
DcNotFoundErrorDialog::OnCommand(
   HWND     /* windowFrom */ ,   
   unsigned controlIDFrom,
   unsigned code)         
{
//   LOG_FUNCTION(DcNotFoundErrorDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDHELP:
      {
         if (code == BN_CLICKED)
         {
            DiagnoseAndSetDetailsText();

            if (!helpTopicLink.empty())
            {
               Win::HtmlHelp(hwnd, helpTopicLink, HH_DISPLAY_TOPIC, 0);
            }

            return true;
         }

         break;
      }
      case IDC_DETAILS_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            int buttonLabelResId = IDS_SHOW_DETAILS_LABEL;
            
            if (detailsShowing)
            {
               HideDetails();
               detailsShowing = false;
            }
            else
            {
               buttonLabelResId = IDS_HIDE_DETAILS_LABEL;
               
               DiagnoseAndSetDetailsText();
               ShowDetails();
               detailsShowing = true;
            }

            Win::SetDlgItemText(
               hwnd,
               IDC_DETAILS_BUTTON,
               String::load(buttonLabelResId));
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return false;
}
   


void
ShowDcNotFoundErrorDialog(
   HWND          parent,
   int           editResId,
   const String& domainName,
   const String& dialogTitle,
   const String& errorMessage,
   bool          domainNameIsNotNetbios,
   bool          userIsDomainSavvy)
{
   LOG_FUNCTION(ShowDcNotFoundErrorDialog);
   ASSERT(Win::IsWindow(parent));
   
   // show the error dialog with the given error message.

   DcNotFoundErrorDialog(
      domainName,
      dialogTitle,
      errorMessage,
      domainNameIsNotNetbios,
      userIsDomainSavvy).ModalExecute(parent);   

   if (editResId != -1)
   {      
      HWND edit = Win::GetDlgItem(parent, editResId);
      Win::SendMessage(edit, EM_SETSEL, 0, -1);
      Win::SetFocus(edit);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\dllref.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// DLL object instance and server lock utility class
// 
// 8-19-97 sburns



#include "headers.hxx"



long ComServerLockState::instanceCount = 0;
long ComServerLockState::lockCount = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\error.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// abstract base class to encapsulate error information
//
// 8-14-97 sburns



#include "headers.hxx"



// Error::Details::Details(
//    const String&  body,
//    const String&  fileName,
//    unsigned       lineNumber)
//    :
//    body_(body),
//    file(fileName),
//    line(lineNumber)
// {
// }
// 


// due to an oddity of C++, this must be defined although it is
// pure virtual.  What a langauge!

Error::~Error()
{
}



// String
// Error::Details::GetBody() const
// {
//    return body_;
// }
// 
// 
// 
// String
// Error::Details::GetFileName() const
// {
//    return file;
// }
// 
// 
// 
// unsigned
// Error::Details::GetLineNumber() const
// {
//    return line;
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\dns.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DNS API wrappers
//
// 12-16-97 sburns



#include "headers.hxx"



// not a String instance to avoid order of static initialization problems

static const wchar_t* DNS_SERVICE_NAME = L"dns";



bool
Dns::IsClientConfigured()
{
   LOG_FUNCTION(Dns::IsClientConfigured);

   bool result = true;

   PDNS_RECORD unused = 0;
   LOG(L"Calling DnsQuery");
   LOG(               L"lpstrName         : \"\" (empty)");
   LOG(               L"wType             : DNS_TYPE_A");
   LOG(               L"fOPtions          : DNS_QUERY_BYPASS_CACHE");
   LOG(               L"aipServers        : 0");
   LOG(String::format(L"ppQueryResultsSet : 0x%1!X!", &unused));
   LOG(               L"pReserved         : 0");

   DNS_STATUS testresult =
      ::DnsQuery(
         L"",
         DNS_TYPE_A,
         DNS_QUERY_BYPASS_CACHE,    
         0,   // use the default server list
         &unused,   
         0);  // as above

   LOG(String::format(L"Result 0x%1!X!", testresult));
   LOG(MyDnsStatusString(testresult));

   if (testresult == DNS_ERROR_NO_DNS_SERVERS)
   {
      result = false;
   }

   LOG(
      String::format(
         L"DNS client %1 configured",
         result ? L"is" : L"is NOT"));

   return result;
}



String
MyDnsStatusString(DNS_STATUS status)
{
   // this converts the ansi result to unicode with a String ctor, and strips whitespace

   return String(::DnsStatusString(status)).strip(String::BOTH);
}



DNS_STATUS
MyDnsValidateName(const String& name, DNS_NAME_FORMAT format)
{
   LOG_FUNCTION2(MyDnsValidateName, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsValidateName");
   LOG(String::format(L"pszName : %1", name.c_str()));
   LOG(String::format(L"Format  : %1!d!", format));

   DNS_STATUS status = ::DnsValidateName(name.c_str(), format);

   LOG(String::format(L"status 0x%1!X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}
   


// maxUnicodeCharacters - in, max number of unicode characters allowed in
// the name.
   
// maxUTF8Bytes - in, maximum number of bytes allowed to represent s in the
// UTF-8 character set.

Dns::ValidateResult
DoDnsValidation(
   const String&     s,
   size_t            maxUnicodeCharacters,
   size_t            maxUTF8Bytes,
   DNS_NAME_FORMAT   format)
{
   LOG_FUNCTION2(
      DoDnsValidation,
      String::format(
         L"s: %1, max len unicode: %2!d!, max len utf8: %3!d!",
         s.c_str(),
         maxUnicodeCharacters,
         maxUTF8Bytes));
   ASSERT(!s.empty());
   ASSERT(maxUnicodeCharacters);
   ASSERT(maxUTF8Bytes);

   // a unicode character requires at least 1 byte in utf8, so sanity check
   // the limits.
   
   ASSERT(maxUTF8Bytes >= maxUnicodeCharacters);

   Dns::ValidateResult result = Dns::INVALID;
   do
   {
      if (s.empty())
      {
         // obviously bad

         break;
      }

      //
      // we do our own length checking, as the DnsValidateName API does not
      // return a distinct error code for length problems.
      //

      // first- cheap length test.  Since a character will never be smaller
      // than 1 byte, if the number of characters exceeds the number of
      // bytes, we know it will never fit.

      if (s.length() > maxUTF8Bytes || s.length() > maxUnicodeCharacters)
      {
         result = Dns::TOO_LONG;
         break;
      }

      // second- check length of against corresponding UTF8 string
      // utf8bytes is the number of bytes (not characters) required to hold
      // the string in the UTF-8 character set.

      size_t utf8bytes = 
         static_cast<size_t>(
            // @@ why isn't this wrapped with a Win function?
            ::WideCharToMultiByte(
               CP_UTF8,
               0,
               s.c_str(),
               static_cast<int>(s.length()),
               0,
               0,
               0,
               0));

      LOG(String::format(L"name is %1!d! utf-8 bytes", utf8bytes));

      if (utf8bytes > maxUTF8Bytes)
      {
         LOG(L"UTF-8 length too long");
         result = Dns::TOO_LONG;
         break;
      }

      // last- check the name for valid characters

      DNS_STATUS status = MyDnsValidateName(s, format);
      switch (status)
      {
         case ERROR_SUCCESS:
         {
            result = Dns::VALID;
            break;
         }
         case DNS_ERROR_NON_RFC_NAME:
         {
            result = Dns::NON_RFC;
            break;
         }
         case DNS_ERROR_NUMERIC_NAME:
         {
            result = Dns::NUMERIC;
            break;
         }
         case DNS_ERROR_INVALID_NAME_CHAR:
         {
            result = Dns::BAD_CHARS;
            break;
         }
         case ERROR_INVALID_NAME:
         default:
         {
            // do nothing

            break;
         }
      }
   }
   while (0);

   return result;
}



Dns::ValidateResult
Dns::ValidateDnsLabelSyntax(const String& candidateDNSLabel)
{
   LOG_FUNCTION2(Dns::ValidateDnsLabelSyntax, candidateDNSLabel);
   ASSERT(!candidateDNSLabel.empty());

   return 
      DoDnsValidation(
         candidateDNSLabel,
         Dns::MAX_LABEL_LENGTH,
         Dns::MAX_LABEL_LENGTH,

         // always use the Hostname formats, as they check for all-numeric
         // labels.

         DnsNameHostnameLabel);
}

  

Dns::ValidateResult
Dns::ValidateDnsNameSyntax(
   const String&  candidateDNSName,
   size_t         maxLenUnicodeCharacters,
   size_t         maxLenUTF8Bytes)
{
   LOG_FUNCTION2(Dns::ValidateDnsNameSyntax, candidateDNSName);
   ASSERT(!candidateDNSName.empty());

   return
      DoDnsValidation(
         candidateDNSName,
         maxLenUnicodeCharacters,
         maxLenUTF8Bytes,     // for policy bug workaround
         DnsNameDomain);      // allow numeric first labels
}



bool
Dns::IsServiceInstalled()
{
   LOG_FUNCTION(Dns::IsServiceInstalled);
  
   NTService s(DNS_SERVICE_NAME);

   bool result = s.IsInstalled();

   LOG(
      String::format(
         L"service %1 installed.",
         result ? L"is" : L"is not"));

   return result;
}



bool
Dns::IsServiceRunning()
{
   LOG_FUNCTION(Dns::IsServiceRunning);

   bool result = false;
   NTService s(DNS_SERVICE_NAME);
   DWORD state = 0;
   if (SUCCEEDED(s.GetCurrentState(state)))
   {
      result = (state == SERVICE_RUNNING);
   }

   LOG(
      String::format(
         L"service %1 running.",
         result ? L"is" : L"is not"));

   return result;
}



String
Dns::HostnameToNetbiosName(const String& hostname, HRESULT* err)
{
   LOG_FUNCTION2(Dns::HostnameToNetbiosName, hostname);

   ASSERT(!hostname.empty());

   if (err)
   {
      *err = S_OK;
   }

   static const int NAME_SIZE = MAX_COMPUTERNAME_LENGTH + 1;
   DWORD size = NAME_SIZE;
   TCHAR buf[NAME_SIZE];
   memset(buf, 0, sizeof(buf));

   BOOL result =
      ::DnsHostnameToComputerName(
         const_cast<wchar_t*>(hostname.c_str()),
         buf,
         &size);
   ASSERT(result);

   if (result)
   {
      LOG(buf);
      return buf;
   }

   HRESULT hr = Win::GetLastErrorAsHresult();
   LOG_HRESULT(hr);

   if (err)
   {
      *err = hr;
   }

   return String();
}



DNS_NAME_COMPARE_STATUS
Dns::CompareNames(const String& dnsNameA, const String& dnsNameB)
{
   LOG_FUNCTION2(
      Dns::CompareNames,
      dnsNameA + L" vs " + dnsNameB);
   ASSERT(!dnsNameA.empty());
   ASSERT(!dnsNameB.empty());

   PCWSTR a = dnsNameA.c_str();
   PCWSTR b = dnsNameB.c_str();
    
   LOG(L"Calling DnsNameCompareEx_W");
   LOG(String::format(L"pszLeftName  : %1", a));
   LOG(String::format(L"pszRightName : %1", b));
   LOG(               L"dwReserved   : 0");

   DNS_NAME_COMPARE_STATUS status = ::DnsNameCompareEx_W(a, b, 0);

#ifdef LOGGING_BUILD
   LOG(String::format(L"Result 0x%1!X!", status));

   String rel;
   switch (status)
   {
      case DnsNameCompareNotEqual:
      {
         rel = L"DnsNameCompareNotEqual";
         break;
      }
      case DnsNameCompareEqual:
      {
         rel = L"DnsNameCompareEqual";
         break;
      }
      case DnsNameCompareLeftParent:
      {
         rel = L"DnsNameCompareLeftParent";
         break;
      }
      case DnsNameCompareRightParent:
      {
         rel = L"DnsNameCompareRightParent";
         break;
      }
      case DnsNameCompareInvalid:
      {
         rel = L"DnsNameCompareInvalid";
         break;
      }
      default:
      {
         ASSERT(false);
         rel = L"error";
         break;
      }
   }

   LOG(String::format(L"relation: %1", rel.c_str()));
#endif

   return status;
}



void
MyDnsRecordListFree(DNS_RECORD* rl)
{
   if (rl)
   {
      ::DnsRecordListFree(rl, DnsFreeRecordListDeep);
   }
}



// caller must free the result with MyDnsRecordListFree

DNS_STATUS
MyDnsQuery(
   const String& name,
   WORD          type,
   DWORD         options,
   DNS_RECORD*&  result)
{
   LOG_FUNCTION2(MyDnsQuery, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsQuery_W");
   LOG(String::format(L"lpstrName : %1", name.c_str()));
   LOG(String::format(L"wType     : %1!X!", type));
   LOG(String::format(L"fOptions  : %1!X!", options));

   DNS_STATUS status =
      ::DnsQuery_W(
         const_cast<PWSTR>(name.c_str()),
         type,
         options,
         0,
         &result,
         0);

   LOG(String::format(L"status = %1!08X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}



String
Dns::GetParentDomainName(const String& domainName)
{
   LOG_FUNCTION2(Dns::GetParentDomainName, domainName);
   ASSERT(!domainName.empty());

   String result(domainName);

   do
   {
      if (domainName.empty())
      {
         break;
      }

      size_t pos = domainName.find_first_of(L".");

      if (pos == String::npos)
      {
         // no dot found, so we've found the last label of a name that is
         // not fully qualified. So the parent zone is the root zone.

         result = L".";
         break;
      }

      if (pos == domainName.length() - 1)
      {
         // we found the last dot.  Don't back up any further -- we define
         // the parent zone of the root zone to be the root zone itself.

         result = domainName.substr(pos);
         break;
      }

      result = domainName.substr(pos + 1);
   }
   while (0);

   LOG(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\dsutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS utility functions
//
// 3-11-99 sburns



#include "headers.hxx"



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcName(
   const TCHAR*               machine,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info)
{
   LOG_FUNCTION(MyDsGetDcName);

   info = 0;

   LOG(L"Calling DsGetDcName");
   LOG(String::format(L"ComputerName : %1", machine ? machine : L"(null)"));
   LOG(String::format(L"DomainName   : %1", domainName.c_str()));
   LOG(               L"DomainGuid   : (null)");
   LOG(               L"SiteGuid     : (null)");
   LOG(String::format(L"Flags        : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDcName(
            machine,
            domainName.c_str(),
            0,
            0,
            flags,
            &info));

   LOG_HRESULT(hr);

   // do second attempt masking in DS_FORCE_REDISCOVERY, if not already
   // specified.

   if (FAILED(hr) && !(flags & DS_FORCE_REDISCOVERY))
   {
      // try again w/ rediscovery on

      LOG(L"Trying again w/ rediscovery");

      flags |= DS_FORCE_REDISCOVERY;
      hr =
         Win32ToHresult(
            ::DsGetDcName(
               machine,
               domainName.c_str(),
               0,
               0,
               flags,
               &info));

      LOG_HRESULT(hr);
   }


#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"DomainControllerName    : %1",       info->DomainControllerName));
      LOG(String::format(L"DomainControllerAddress : %1",       info->DomainControllerAddress));
      LOG(String::format(L"DomainGuid              : %1",       Win::StringFromGUID2(info->DomainGuid).c_str()));
      LOG(String::format(L"DomainName              : %1",       info->DomainName));
      LOG(String::format(L"DnsForestName           : %1",       info->DnsForestName));
      LOG(String::format(L"Flags                   : 0x%1!X!:", info->Flags));
      LOG(String::format(L"DcSiteName              : %1",       info->DcSiteName));
      LOG(String::format(L"ClientSiteName          : %1",       info->ClientSiteName));
   }
#endif

   return hr;
}



bool
IsDomainReachable(const String& domainName)
{
   LOG_FUNCTION(IsDomainReachable);
   ASSERT(!domainName.empty());

   bool result = false;
   if (!domainName.empty())
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      HRESULT hr =
         MyDsGetDcName(
            0, // this server
            domainName,

            // force discovery to ensure that we don't pick up a cached
            // entry for a domain that may no longer exist

            DS_FORCE_REDISCOVERY,
            info);
      if (SUCCEEDED(hr))
      {
         ::NetApiBufferFree(info);
         result = true;
      }
   }

   LOG(
      String::format(
         L"The domain %1 %2 be reached.",
         domainName.c_str(),
         result ? L"can" : L"can NOT"));

   return result;
}



bool
IsDSRunning()
{
   LOG_FUNCTION(IsDSRunning);

   bool result = false;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      result = info->Flags & DSROLE_PRIMARY_DS_RUNNING ? true : false;
      ::DsRoleFreeMemory(info);
   }

   LOG(
      String::format(
         L"DS %1 running",
         result ? L"is" : L"is NOT"));

   return result;
}



HRESULT
MyDsBind(const String& dcName, const String& dnsDomain, HANDLE& hds)
{
   LOG_FUNCTION(MyDsBind);

   // either parameter may be empty
      
   LOG(L"Calling DsBind");
   LOG(String::format(L"DomainControllerName : %1",
      dcName.empty() ? L"(null)" : dcName.c_str()));
   LOG(String::format(L"DnsDomainName        : %1",
      dnsDomain.empty() ? L"(null)" : dnsDomain.c_str()));

   hds = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsBind(
            dcName.empty() ? 0 : dcName.c_str(),
            dnsDomain.empty() ? 0 : dnsDomain.c_str(),
            &hds));

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
MyDsBindWithCred(
   const String&  dcName,
   const String&  dnsDomain,
   const String&  username,
   const String&  userDomain,
   const String&  password,
   HANDLE&        hds)
{
   LOG_FUNCTION(MyDsBindWithCred);

#ifdef DBG   
   if (username.empty())
   {
      ASSERT(userDomain.empty());
      ASSERT(password.empty());
   }
#endif

   hds = 0;
   HRESULT hr = S_OK;
   do
   {
      // create an identity handle
      HANDLE authIdentity = INVALID_HANDLE_VALUE;
      PWSTR u =
         username.empty() ? 0 : const_cast<wchar_t*>(username.c_str());
      PWSTR p = const_cast<wchar_t*>(password.c_str());
      PWSTR d = const_cast<wchar_t*>(userDomain.c_str());

      LOG(L"Calling DsMakePasswordCredentials");
      LOG(String::format(L"User   : %1", u ? u : L"(null)"));
      LOG(String::format(L"Domain : %1", d ? d : L"(null)"));

      hr = Win32ToHresult(::DsMakePasswordCredentials(u, d, p, &authIdentity));
      BREAK_ON_FAILED_HRESULT(hr);

      LOG_HRESULT(hr);

      PCWSTR dc = dcName.empty() ? 0 : dcName.c_str();
      PCWSTR dom = dnsDomain.empty() ? 0 : dnsDomain.c_str();

      LOG(L"Calling DsBindWithCred");
      LOG(String::format(L"DomainControllerName : %1", dc ? dc : L"(null)"));
      LOG(String::format(L"DnsDomainName        : %1", dom ? dom : L"(null)"));

      hr = Win32ToHresult(::DsBindWithCred(dc, dom, authIdentity, &hds));
      // don't break here, continue on to free the identity handle

      LOG_HRESULT(hr);

      ::DsFreePasswordCredentials(authIdentity);
   }
   while (0);

   return hr;
}



HRESULT
MyDsGetDomainControllerInfoHelper(
   HANDLE         hDs,
   const String&  domainName,
   DWORD          infoLevel,
   DWORD&         cOut,
   void**         info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfoHelper);
   ASSERT(hDs);
   ASSERT(!domainName.empty());
   ASSERT(infoLevel);
   ASSERT(info);

   cOut = 0;

   LOG(L"Calling DsGetDomainControllerInfo");
   LOG(String::format(L"DomainName : %1", domainName.c_str()));
   LOG(String::format(L"InfoLevel  : %1!d!", infoLevel));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDomainControllerInfo(
            hDs,
            domainName.c_str(),
            infoLevel,
            &cOut,
            info));

   LOG_HRESULT(hr);

#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"*pcOut : %1!d!", cOut));
   }
#endif

   return hr;
}



HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W*&   info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfo);

   return
      MyDsGetDomainControllerInfoHelper(
         hDs,
         domainName,
         1,
         cOut,
         reinterpret_cast<void**>(&info));
}



HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W*&   info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfo);

   return
      MyDsGetDomainControllerInfoHelper(
         hDs,
         domainName,
         2,
         cOut,
         reinterpret_cast<void**>(&info));
}



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W* info)
{
   LOG_FUNCTION(MyDsFreeDomainControllerInfo);
   ASSERT(info);

   ::DsFreeDomainControllerInfo(1, cOut, info);
}



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W* info)
{
   LOG_FUNCTION(MyDsFreeDomainControllerInfo);
   ASSERT(info);

   ::DsFreeDomainControllerInfo(2, cOut, info);
}

                                 

#ifdef LOGGING_BUILD

String
LevelName(DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level)
{
   switch (level)
   {
      case ::DsRoleOperationState:
      {
         return L"DsRoleOperationState";
      }
      case ::DsRolePrimaryDomainInfoBasic:
      {
         return L"DsRolePrimaryDomainInfoBasic";
      }
      case ::DsRoleUpgradeStatus:
      {
         return L"DsRoleUpgradeStatus";
      }
      default:
      {
         ASSERT(false);

         // fall thru;
      }
   }

   return L"** unknown **";
}

#endif



// Caller needs to buffer info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformationHelper(
   const TCHAR*                     machine,
   DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
   BYTE*&                           buffer)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformationHelper);

   buffer = 0;

   LOG(L"Calling DsRoleGetPrimaryDomainInformation");
   LOG(
      String::format(
         L"lpServer  : %1",
         machine ? machine : L"(null)" ));
   LOG(
      String::format(
         L"InfoLevel : 0x%1!X! (%2)",
         level,
         LevelName(level).c_str()));

   HRESULT hr =
      Win32ToHresult(
         ::DsRoleGetPrimaryDomainInformation(machine, level, &buffer));

   LOG_HRESULT(hr);

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_OPERATION_STATE_INFO*&       info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRoleOperationState,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_OPERATION_STATE_INFO*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(
            String::format(
               L"OperationState : 0x%1!X!",
               info->OperationState));
      }
#endif

   }

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRolePrimaryDomainInfoBasic,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_PRIMARY_DOMAIN_INFO_BASIC*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(String::format(L"MachineRole   : 0x%1!X!", info->MachineRole));
         LOG(String::format(L"Flags         : 0x%1!X!", info->Flags));
         LOG(String::format(L"DomainNameFlat: %1",      info->DomainNameFlat));
         LOG(String::format(L"DomainNameDns : %1",      info->DomainNameDns));
         LOG(String::format(L"DomainForestName: %1",    info->DomainForestName));
      }
#endif

   }

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_UPGRADE_STATUS_INFO*&  info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRoleUpgradeStatus,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_UPGRADE_STATUS_INFO*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(String::format(L"OperationState      : %1!d!", info->OperationState));
         LOG(String::format(L"PreviousServerState : %1!d!", info->PreviousServerState));
      }
#endif

   }

   return hr;
}



HRESULT
MyDsGetDcNameWithAccount(
   const TCHAR*               machine,
   const String&              accountName,
   ULONG                      allowedAccountFlags,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info)
{
   LOG_FUNCTION(MyDsGetDcNameWithAccount);
   ASSERT(!domainName.empty());
   ASSERT(!accountName.empty());

   info = 0;

   LOG(L"Calling DsGetDcNameWithAccount");
   LOG(String::format(L"ComputerName          : %1",      machine ? machine : L"(null)"));
   LOG(String::format(L"AccountName           : %1",      accountName.c_str()));
   LOG(String::format(L"AllowableAccountFlags : 0x%1!X!", allowedAccountFlags));
   LOG(String::format(L"DomainName            : %1",      domainName.c_str()));
   LOG(               L"DomainGuid            : (null)");
   LOG(               L"SiteGuid              : (null)");
   LOG(String::format(L"Flags                 : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDcNameWithAccountW(
            machine,
            accountName.c_str(),
            allowedAccountFlags,
            domainName.c_str(),
            0,
            0,
            flags,
            &info));

   LOG_HRESULT(hr);

   // on error, do second attempt masking in DS_FORCE_REDISCOVERY, if not
   // already specified.

   if (FAILED(hr) && !(flags & DS_FORCE_REDISCOVERY))
   {
      LOG(L"Trying again w/ rediscovery");

      flags |= DS_FORCE_REDISCOVERY;
      hr =
         Win32ToHresult(
            ::DsGetDcNameWithAccountW(
               machine,
               accountName.c_str(),
               allowedAccountFlags,
               domainName.c_str(),
               0,
               0,
               flags,
               &info));

      LOG_HRESULT(hr);
   }

#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"DomainControllerName    : %1", info->DomainControllerName));
      LOG(String::format(L"DomainControllerAddress : %1", info->DomainControllerAddress));
      LOG(String::format(L"DomainGuid              : %1", Win::StringFromGUID2(info->DomainGuid).c_str()));
      LOG(String::format(L"DomainName              : %1", info->DomainName));
      LOG(String::format(L"DnsForestName           : %1", info->DnsForestName));
      LOG(String::format(L"Flags                   : 0x%1!X!:", info->Flags));
      LOG(String::format(L"DcSiteName              : %1", info->DcSiteName));
      LOG(String::format(L"ClientSiteName          : %1", info->ClientSiteName));
   }
#endif

   return hr;
}



bool
IsDcpromoRunning()
{
   LOG_FUNCTION(IsDcpromoRunning);

   bool result = false;

   // If we can open the mutex created by dcpromo, then dcpromo is running,
   // as it created that mutex.

   HANDLE mutex = ::OpenMutex(SYNCHRONIZE, FALSE, L"dcpromoui");
   if (mutex)
   {
      result = true;
      Win::CloseHandle(mutex);
   }

   LOG(String::format(L"Dcpromo %1 running", result ? L"is" : L"is not"));

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\encodedstring.cpp ===
// Copyright (c) 2001 Microsoft Corporation
// 
// run-encoded string class
// 
// 2001-02-08 sburns



#include <headers.hxx>



EncodedString::EncodedString()
   :
   seed(0)   
{
   ::ZeroMemory(&cypherText, sizeof(cypherText));
   
   Init(L"");
}
   
   

EncodedString::EncodedString(const EncodedString& rhs)
   :
   seed(rhs.seed)
{
   // Since the seed values are the same, we can just copy the string
   // (instead of decoding the source and re-encoding it).

   ::RtlCreateUnicodeString(&cypherText, rhs.cypherText.Buffer);
}


   
const EncodedString&
EncodedString::operator= (const EncodedString& rhs)
{
   // handle the a = a case.
   
   if (this == &rhs)
   {
      return *this;
   }

   // dump our old contents
   
   Reset();

   seed = rhs.seed;
   
   // Since the seed values are the same, we can just copy the string
   // (instead of decoding the source and re-encoding it).
   
   ::RtlCreateUnicodeString(&cypherText, rhs.cypherText.Buffer);

   return *this;
}



void
EncodedString::Reset()
{
   if (cypherText.Buffer)
   {
      ::RtlEraseUnicodeString(&cypherText);
      ::RtlFreeUnicodeString(&cypherText);
   }
   seed = 0;
}



void
EncodedString::Init(const wchar_t* clearText)
{
   ASSERT(clearText);

   Reset();
   
   if (clearText)
   {
      BOOL succeeded = ::RtlCreateUnicodeString(&cypherText, clearText);
      ASSERT(succeeded);

      // if we didn't succeed, then we're out of memory, and the string
      // will have the same value as the empty string.

      ::RtlRunEncodeUnicodeString(&seed, &cypherText);
   }
}
   


wchar_t* 
EncodedString::GetDecodedCopy() const
{
   size_t length = cypherText.Length + 1;
   WCHAR* cleartext = new WCHAR[length];
   ::ZeroMemory(cleartext, sizeof(WCHAR) * length);

   ::RtlRunDecodeUnicodeString(seed, &cypherText);
   wcsncpy(cleartext, cypherText.Buffer, length - 1);
   ::RtlRunEncodeUnicodeString(&seed, &cypherText);

   return cleartext;
}



void
EncodedString::Encode(const wchar_t* clearText)
{
   Init(clearText);
}



bool
EncodedString::operator==(const EncodedString& rhs) const
{
   // handle the a == a case
   
   if (this == &rhs)
   {
      return true;
   }

   if (GetLength() != rhs.GetLength())
   {
      // can't be the same if lengths differ...
      
      return false;
   }
   
   // Two strings are the same if their decoded contents are the same.  We
   // don't consider the seed value and compare the encoded strings, as two
   // equivalent strings may be encoded separetly and have different seeds and
   // encoded data.

   WCHAR* decodedThis = GetDecodedCopy();
   WCHAR* decodedThat = rhs.GetDecodedCopy();

   bool result = (wcscmp(decodedThis, decodedThat) == 0);

   ::ZeroMemory(decodedThis, sizeof(WCHAR) * GetLength());
   delete[] decodedThis;
   
   ::ZeroMemory(decodedThat, sizeof(WCHAR) * rhs.GetLength());
   delete[] decodedThat;
   
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\extract.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// class Extractor
// 
// 11-12-97 sburns



#include "headers.hxx"



Extractor::Extractor(CLIPFORMAT clipFormatID, size_t bufSize_)
   :
   formatetc(),
   stgmedium(),
   bufSize(bufSize_)
{
   ASSERT(clipFormatID);
   ASSERT(bufSize);

   formatetc.cfFormat = clipFormatID;
   formatetc.ptd = 0;
   formatetc.dwAspect = DVASPECT_CONTENT;
   formatetc.lindex = -1;
   formatetc.tymed = TYMED_HGLOBAL;

   stgmedium.tymed = TYMED_HGLOBAL;
   HRESULT hr = Win::GlobalAlloc(GPTR, bufSize, stgmedium.hGlobal);

   ASSERT(SUCCEEDED(hr));
}



Extractor::~Extractor()
{
   if (stgmedium.hGlobal)
   {
      Win::GlobalFree(stgmedium.hGlobal);
   }
}



HGLOBAL
Extractor::GetData(IDataObject& dataObject)
{
   HGLOBAL result = 0;
   do
   {
      if (!stgmedium.hGlobal)
      {
         break;
      }

      // clear out any prior contents of the memory.  We don't need to call
      // GlobalLock because the memory was allocated as fixed.
      
      ::ZeroMemory(reinterpret_cast<void*>(stgmedium.hGlobal), bufSize);
      
      HRESULT hr = dataObject.GetDataHere(&formatetc, &stgmedium);
      BREAK_ON_FAILED_HRESULT(hr);
      result = stgmedium.hGlobal;
   }
   while (0);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\dialog.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Dialog class
// 
// 10-15-97 sburns



#include "headers.hxx"



// The base map is copied into the map supplied to the ctor.  It includes
// elements to disable context help for a range of control IDs.

static const DWORD BASE_HELP_MAP[] =
{
   // The STATIC_HELPLESS family is used to identify static controls for which
   // the Windows context help algorithm for ID == -1 is inappropriate.  That
   // algorithm is: if the control ID is -1, look for the next control in the
   // dialog, and present the help for it.  For group boxes and static text
   // following a control, this produces confusing results.  Unfortunately, -1
   // is the only ID exempt from resource compiler checking of unique control
   // IDs, so we need a bunch of "reserved" IDs.  Each control for which we
   // wish to disable context help is assigned an ID from the resvered pool.

   IDC_STATIC_HELPLESS,    NO_HELP,   
   IDC_STATIC_HELPLESS2,   NO_HELP,
   IDC_STATIC_HELPLESS3,   NO_HELP,
   IDC_STATIC_HELPLESS4,   NO_HELP,
   IDC_STATIC_HELPLESS5,   NO_HELP,
   IDC_STATIC_HELPLESS6,   NO_HELP,
   IDC_STATIC_HELPLESS7,   NO_HELP,
   IDC_STATIC_HELPLESS8,   NO_HELP,
   IDC_STATIC_HELPLESS9,   NO_HELP,
};

static const size_t baseMapSize = sizeof(BASE_HELP_MAP) / sizeof(DWORD);



Dialog::Dialog(
   unsigned    resID_,
   const DWORD helpMap_[])
   :
   hwnd(0),
   changemap(),
   helpMap(0),
   isEnded(false),
   isModeless(false),
   resID(resID_)
{
// Don't emit ctor trace, as this class is always a base class, and the
// derived class should emit the trace.

//   LOG_CTOR(Dialog);
   ASSERT(resID > 0);
   ASSERT(helpMap_);
   
   if (helpMap_)
   {
      size_t ctorMapsize = 0;
      while (helpMap_[++ctorMapsize])
      {
      }

      // make an even size, and add space for IDC_STATIC_HELPLESSn IDs

      size_t mapsize = ctorMapsize + (ctorMapsize % 2) + baseMapSize;
      helpMap = new DWORD[mapsize];
      memset(helpMap, 0, mapsize * sizeof(DWORD));

      // copy the base map

      std::copy(BASE_HELP_MAP, BASE_HELP_MAP + baseMapSize, helpMap);

      // then append the ctor map

      std::copy(helpMap_, helpMap_ + ctorMapsize, helpMap + baseMapSize);
   }

   ClearChanges();
}



Dialog::~Dialog()
{
   
// Don't emit dtor trace, as this class is always a base class, and the
// derived class should emit the trace.
//   LOG_DTOR(Dialog);

   if (isModeless && !isEnded)
   {
      // this will destroy the window

      EndModelessExecution();
   }

   delete[] helpMap;
   hwnd = 0;
}
   


Dialog*
Dialog::GetInstance(HWND pageDialog)
{
   LONG_PTR ptr = 0;
   HRESULT hr = Win::GetWindowLongPtr(pageDialog, DWLP_USER, ptr);

   ASSERT(SUCCEEDED(hr));

   // don't assert ptr, it may not have been set.  Some messages are
   // sent before WM_INITDIALOG, which is the earliest we can set the
   // pointer.

   return reinterpret_cast<Dialog*>(ptr);
}



INT_PTR
Dialog::ModalExecute(HWND parent)
{
   LOG_FUNCTION(Dialog::ModalExecute);
   ASSERT(parent == 0 || Win::IsWindow(parent));

   return
      Win::DialogBoxParam(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         parent,
         Dialog::dialogProc,
         reinterpret_cast<LPARAM>(this));
}



INT_PTR
Dialog::ModalExecute(const Dialog& parent)
{
   return ModalExecute(parent.GetHWND());
}



HWND
Dialog::GetHWND() const
{
//   LOG_FUNCTION(Dialog::GetHWND);
   ASSERT(hwnd);

   return hwnd;
}   



void
Dialog::OnInit()
{
//   LOG_FUNCTION(Dialog::OnInit);
}



void
Dialog::OnDestroy()
{
//   LOG_FUNCTION(Dialog::OnDestroy);
}



bool
Dialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    /* controlIDFrom */ ,
   unsigned    /* code */ )
{
//   LOG_FUNCTION(Dialog::OnCommand);

   return false;
}



bool
Dialog::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR /* controlIDFrom */ ,
   UINT     /* code */ ,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(Dialog::OnNotify);

   return false;
}



unsigned
Dialog::GetResID() const
{
   return resID;
}



void
Dialog::SetHWND(HWND window)
{
   if (hwnd == window)
   {
      // this should not be already set unless it's a modeless dialog
      ASSERT(isModeless);
   }
   else
   {
      ASSERT(!hwnd);
   }

   hwnd = window;
}



// CODEWORK: I assert that in all cases, the lifetime of the Dialog instance
// encompasses the lifetime of the Window handle.  Therefore, it is not
// possible to have a message sent to a window that will be dispatched to a
// Dialog instance that no longer exists.
// 
// However, the code could be made to verify this assertion by:
// 
// - allocating user space in the window for a flag (this means subclassing
// and adding bytes to the window with the cbWndExtra member of the WNDCLASSEX
// structure)
// 
// - setting that flag in the user area of the hwnd when the WM_INITDIALOG
// message sets the DWLP_USER to point to the Dialog instance.
// 
// - clearing the DWLP_USER value in the dtor
// 
// - in dialogProc, asserting that if the flag is set, the DWLP_USER value is
// set too.

INT_PTR CALLBACK
Dialog::dialogProc(
   HWND     dialog,
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
   switch (message)
   {
      case WM_INITDIALOG:
      {
         // a pointer to the Dialog is in lparam.  Save this in the window
         // structure so that it can later be retrieved by GetInstance.

         ASSERT(lparam);
         Win::SetWindowLongPtr(dialog, DWLP_USER, lparam);

         Dialog* dlg = GetInstance(dialog);
         if (dlg)
         {
            dlg->SetHWND(dialog);
            dlg->OnInit();
         }
   
         return TRUE;
      }
      case WM_COMMAND:
      {
         Dialog* dlg = GetInstance(dialog);

         // Amazingly, buddy spin controls send EN_UPDATE and EN_CHANGE
         // before WM_INITDIALOG is called!
         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               dlg->OnCommand(
                  reinterpret_cast<HWND>(lparam),
                  LOWORD(wparam),
                  HIWORD(wparam));
         }
         break;   
      }
      case WM_NOTIFY:
      {
         NMHDR* nmhdr = reinterpret_cast<NMHDR*>(lparam);
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            return
               dlg->OnNotify(
                  nmhdr->hwndFrom,
                  nmhdr->idFrom,
                  nmhdr->code,
                  lparam);
         }
         break;
      }
      case WM_DESTROY:
      {
         // It's possible to get a WM_DESTROY message without having gotten
         // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
         // comctl32.dll) fails, so guard against this case.

         Dialog* dlg = GetInstance(dialog);
         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            dlg->OnDestroy();
         }

         return FALSE;
      }
      case WM_HELP:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            if (dlg->helpMap && HELPFILE_NAME && HELPFILE_NAME[0])
            {
               HELPINFO* helpinfo = reinterpret_cast<HELPINFO*>(lparam);
               ASSERT(helpinfo);

               if (helpinfo)
               {
                  if (helpinfo->iContextType == HELPINFO_WINDOW)
                  {
                     Win::WinHelp(
                        reinterpret_cast<HWND>(helpinfo->hItemHandle),
                        Win::GetSystemWindowsDirectory().append(HELPFILE_NAME),
                        HELP_WM_HELP,
                        reinterpret_cast<ULONG_PTR>(dlg->helpMap));
                  }
               }
            }
         }
         return TRUE;
      }
      case WM_CONTEXTMENU:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            if (dlg->helpMap && HELPFILE_NAME && HELPFILE_NAME[0])
            {
               Win::WinHelp(
                  reinterpret_cast<HWND>(wparam),
                  Win::GetSystemWindowsDirectory().append(HELPFILE_NAME),
                  HELP_CONTEXTMENU,
                  reinterpret_cast<ULONG_PTR>(dlg->helpMap));
            }
         }
         return TRUE;
      }
      default:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return dlg->OnMessage(message, wparam, lparam);
         }
         break;
      }
   }

   return FALSE;
}



void
Dialog::ClearChanges()
{
//   LOG_FUNCTION(Dialog::ClearChanges);

   changemap.clear();
}



void
Dialog::SetChanged(UINT_PTR controlResID)
{
//   LOG_FUNCTION(Dialog::SetChanged);

   if (Win::GetDlgItem(hwnd, static_cast<int>(controlResID)))
   {
      changemap[controlResID] = true;
   }
}



bool
Dialog::WasChanged(UINT_PTR controlResId) const
{
//   LOG_FUNCTION(Dialog::WasChanged);

   bool result = false;
   do
   {
      ChangeMap::iterator iter = changemap.find(controlResId);
      if (iter != changemap.end())
      {
         // the res id was in the map, so check the mapped value.

         result = iter->second;
         break;
      }

      // the res id was not in the map, so it can't have been changed.

      ASSERT(result == false);
   }
   while (0);

   return result;
}



bool
Dialog::WasChanged() const
{
//   LOG_FUNCTION(Dialog::WasChanged);

   bool result = false;

   do
   {   
      if (changemap.size() == 0)
      {
         // no entries in the map == no changes.

         break;
      }

      for (
         Dialog::ChangeMap::iterator i = changemap.begin();
         i != changemap.end();
         ++i)
      {
         if (i->second)
         {
            // found an entry marked "changed"

            result = true;
            break;
         }
      }
   }
   while (0);

   return result;
}

   

void
Dialog::DumpChangeMap() const
{

#ifdef DBG
   Win::OutputDebugString(L"start\n");
   for (
      Dialog::ChangeMap::iterator i = changemap.begin();
      i != changemap.end();
      ++i)
   {
      Win::OutputDebugString(
         String::format(
            L"%1!d! %2 \n",
            (*i).first,
            (*i).second ? L"true" : L"false"));
   }
   Win::OutputDebugString(L"end\n");
#endif

}



bool
Dialog::OnMessage(
   UINT     /* message */,
   WPARAM   /* wparam */,
   LPARAM   /* lparam */)
{
//   LOG_FUNCTION(Dialog::OnMessage);

   return false;
}



void
Dialog::ModelessExecute(HWND parent)
{
   LOG_FUNCTION(Dialog::ModelessExecute);
   ASSERT(parent == 0 || Win::IsWindow(parent));

   isModeless = true;

   HRESULT hr = 
      Win::CreateDialogParam(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         parent,
         Dialog::dialogProc,
         reinterpret_cast<LPARAM>(this),
         hwnd);

   ASSERT(SUCCEEDED(hr));
}



void
Dialog::ModelessExecute(const Dialog& parent)
{
   ModelessExecute(parent.GetHWND());
}



void
Dialog::EndModelessExecution()
{
   LOG_FUNCTION(Dialog::EndModelessExecution);
   ASSERT(isModeless);
   ASSERT(Win::IsWindow(hwnd));

   if (isModeless)
   {
      Win::DestroyWindow(hwnd);
      isEnded = true;
      hwnd = 0;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\netutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Net utility functions
//
// 11-4-1999 sburns



#include "headers.hxx"



HRESULT
MyNetWkstaGetInfo(const String& serverName, WKSTA_INFO_100*& info)
{
   LOG_FUNCTION2(MyNetWkstaGetInfo, serverName);

   info = 0;   

   LOG(L"Calling NetWkstaGetInfo");

   PWSTR server =
         serverName.empty()
      ?  0
      :  const_cast<PWSTR>(serverName.c_str());

   BYTE* buf = 0;
   HRESULT hr =
      Win32ToHresult(       
         ::NetWkstaGetInfo(
            server,
            100,
            &buf));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<WKSTA_INFO_100*>(buf);
   }

   return hr;
}



HRESULT
MyNetValidateName(
   const String&        name,
   NETSETUP_NAME_TYPE   nameType)
{
   LOG_FUNCTION(MyNetValidateName);
   ASSERT(!name.empty());

   if (!name.empty())
   {

#ifdef LOGGING_BUILD

      String typedesc;
      switch (nameType)
      {
         case NetSetupDomain:
         {
            typedesc = L"NetSetupDomain";
            break;
         }
         case NetSetupWorkgroup:
         {
            typedesc = L"NetSetupWorkgroup";
            break;
         }
         case NetSetupMachine:
         {
            typedesc = L"NetSetupMachine";
            break;
         }
         case NetSetupNonExistentDomain:
         {
            typedesc = L"NetSetupNonExistentDomain";
            break;
         }
         case NetSetupDnsMachine:
         {
            typedesc = L"NetSetupDnsMachine";
            break;
         }
         case NetSetupUnknown:
         {
            typedesc = L"NetSetupUnknown";
            break;
         }
         default:
         {
            typedesc = L"** unknown **";
            break;
         }
      }

      LOG(L"Calling NetValidateName");
      LOG(               L"lpServer   : (null)");
      LOG(String::format(L"lpName     : %1", name.c_str()));
      LOG(               L"lpAccount  : (null)");
      LOG(               L"lpPassword : (null)");
      LOG(String::format(L"NameType   : %1", typedesc.c_str()));
#endif

      HRESULT hr =
         Win32ToHresult(
            ::NetValidateName(
               0,
               name.c_str(),
               0,
               0,
               nameType));

      LOG_HRESULT(hr);

      // remap the error code to more meaningful ones depending on the
      // context in which the call was made

      if (FAILED(hr))
      {
         // 382695

         if (
                nameType == NetSetupDomain
            and hr == Win32ToHresult(ERROR_INVALID_NAME) )
         {
            LOG(L"mapping ERROR_INVALID_NAME to ERROR_INVALID_DOMAINNAME");

            hr = Win32ToHresult(ERROR_INVALID_DOMAINNAME);
         }
      }
         
      return hr;
   }

   return Win32ToHresult(ERROR_INVALID_PARAMETER);
}



HRESULT
MyNetJoinDomain(
   const String&  domain,
   const String&  username,
   const String&  password,
   ULONG          flags)
{
   LOG_FUNCTION2(myNetJoinDomain, domain);
   ASSERT(!domain.empty());

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0 : server.c_str();  
   PCWSTR u = username.empty() ? 0 : username.c_str();
   PCWSTR p = u ? password.c_str() : 0;

   LOG(L"Calling NetJoinDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpDomain         : %1", domain.c_str()));
   LOG(               L"lpAccountOU      : (null)");
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fJoinOptions : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::NetJoinDomain(
            s,
            domain.c_str(),
            0, // default OU
            u,
            p,
            flags));

   LOG_HRESULT(hr);

   return hr;
}



bool
IsNetworkingInstalled()
{
   LOG_FUNCTION(IsNetworkingInstalled);

   // We test to see if the workstation service is running.  An alternative is
   // to check
   // HLKM\System\CurrentControlSet\Control\NetworkProvider\Order\ProviderOrder
   // registry value to see that it is not empty.
   // see net\config\common\ncbase\ncmisc.cpp

   NTService wks(L"LanmanWorkstation");
   DWORD state = 0;
   HRESULT hr = wks.GetCurrentState(state);

   bool result = false;
   if (SUCCEEDED(hr))
   {
      result = (state == SERVICE_RUNNING);
   }

   LOG(
      String::format(
         L"workstation service %1 running",
         result ? L"is" : L"is NOT"));

   return result;
}



bool
IsTcpIpInstalled()
{
   LOG_FUNCTION(IsTcpIpInstalled);

   HKEY key = 0;
   HRESULT hr = S_OK;
   bool result = false;

   do
   {
      hr = 
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Tcpip\\Linkage",
            KEY_QUERY_VALUE,
            key);
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD dataSize = 0;
      hr =
         Win::RegQueryValueEx(
            key,
            L"Export",
            0,
            0,
            &dataSize);
      BREAK_ON_FAILED_HRESULT(hr);

      if (dataSize > 2)
      {
         // the value is non-null

         result = true;
      }
   }
   while (0);

   if (key)
   {
      hr = Win::RegCloseKey(key);
   }

   LOG(String::format(L"TCP/IP %1 detected", result ? L"is" : L"is not"));

   return result;
}



HRESULT
MyNetRenameMachineInDomain(
   const String& newNetbiosName,
   const String& username,
   const String& password,
   DWORD         flags)
{
   LOG_FUNCTION(MyNetRenameMachineInDomain);
   ASSERT(!newNetbiosName.empty());

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0 : server.c_str();  
   PCWSTR u = username.empty() ? 0 : username.c_str();
   PCWSTR p = u ? password.c_str() : 0;

   LOG(L"Calling NetRenameMachineInDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpNewMachineName : %1", newNetbiosName.c_str()));
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fRenameOptions   : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::NetRenameMachineInDomain(
            s,
            newNetbiosName.c_str(),
            u,
            p,
            flags));

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
MyNetUnjoinDomain(
   const String&  username,
   const String&  password,
   DWORD          flags)
{
   LOG_FUNCTION(MyNetUnjoinDomain);

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0 : server.c_str();  
   PCWSTR u = username.empty() ? 0 : username.c_str();
   PCWSTR p = u ? password.c_str() : 0;

   LOG(L"Calling NetUnjoinDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fUnjoinOptions   : 0x%1!X!", flags));

   HRESULT hr = Win32ToHresult(::NetUnjoinDomain(s, u, p, flags));

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\popup.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Popup message box class
// 
// 8-31-98 sburns



#include "headers.hxx"



Popup::Popup(UINT titleStringResID, bool systemModal_)
   :
   initialized(false),
   systemModal(systemModal_),
   title(),
   titleResId(titleStringResID)
{
   LOG_CTOR(Popup);

   ASSERT(titleResId);
}



Popup::Popup(const String& title_, bool systemModal_)
   :
   initialized(true),
   systemModal(systemModal_),
   title(title_),
   titleResId(0)
{
   LOG_CTOR(Popup);   
}



void
Popup::Gripe(HWND parentDialog, int editResID, UINT errStringResID)
{
   Gripe(parentDialog, editResID, String::load(errStringResID));
}



void
Popup::checkInit()
{
   if (!initialized)
   {
      ASSERT(titleResId);

      title = Win::LoadString(titleResId);
      if (!title.empty())
      {
         initialized = true;
      }
   }
}



void
Popup::Info(
   HWND parentDialog,      
   UINT messageStringResID)
{
   ASSERT(messageStringResID);

   Info(parentDialog, String::load(messageStringResID));
}


   
void
Popup::Info(
   HWND           parentDialog,
   const String&  message)
{
   LOG_FUNCTION(Popup::Info);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
         MB_OK
      |  MB_ICONINFORMATION
      |  getStyleMask());
}



void
Popup::Gripe(
   HWND           parentDialog,
   int            editResID,
   const String&  message)
{
   LOG_FUNCTION(Popup::Gripe);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());
   ASSERT(editResID);

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
      MB_OK | MB_ICONERROR | getStyleMask());

   HWND edit = Win::GetDlgItem(parentDialog, editResID);
   Win::SendMessage(edit, EM_SETSEL, 0, -1);
   Win::SetFocus(edit);
}



void
Popup::Gripe(
   HWND           parentDialog,
   const String&  message)
{
   LOG_FUNCTION(Popup::Gripe);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
      MB_OK | MB_ICONERROR | getStyleMask());
}



void
Popup::Gripe(
   HWND           parentDialog,
   int            editResID,
   HRESULT        hr,
   const String&  message)
{
   Error(parentDialog, hr, message);

   HWND edit = Win::GetDlgItem(parentDialog, editResID);
   Win::SendMessage(edit, EM_SETSEL, 0, -1);
   Win::SetFocus(edit);
}



void
Popup::Error(
   HWND           parent,
   HRESULT        hr,
   const String&  message)
{
   LOG_FUNCTION(Popup::Error);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!message.empty());

   checkInit();

   String newMessage = message + L"\n\n";
   if (FAILED(hr))
   {
      String errorMessage = GetErrorMessage(hr);
      if (errorMessage.empty())
      {
         // these are error codes for which there are no descriptions

         newMessage += String::format(IDS_HRESULT_SANS_MESSAGE, hr);
      }
      else
      {
         newMessage += errorMessage;
      }
   }

   Win::MessageBox(
      parent,
      newMessage,
      title,
      MB_ICONERROR | MB_OK | getStyleMask());
}



void
Popup::Error(
   HWND    parent,      
   HRESULT hr,          
   UINT    messageResID)
{
   Error(parent, hr, String::load(messageResID));
}



void
Popup::Error(
   HWND parentDialog,      
   UINT messageStringResID)
{
   Error(parentDialog, String::load(messageStringResID));
}



void
Popup::Error(
   HWND           parentDialog,
   const String&  message)
{
   LOG_FUNCTION(Popup::Error);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
         MB_OK
      |  MB_ICONERROR
      |  getStyleMask());
}



int
Popup::MessageBox(
   HWND           parentDialog,
   const String&  message,
   UINT           flags)
{
   LOG_FUNCTION(Popup::MessageBox);
   ASSERT(!message.empty());

   // can't assert flags 'cause MB_OK is 0

   checkInit();

   return
      Win::MessageBox(
         parentDialog,
         message,
         title,
         flags | getStyleMask());
}



int
Popup::MessageBox(
   HWND parentDialog,      
   UINT messageStringResID,
   UINT flags)             
{
   return MessageBox(parentDialog, String::load(messageStringResID), flags);
}
   


UINT
Popup::getStyleMask()
{
   UINT mask = 0;
   if (systemModal)
   {
      mask |= MB_SETFOREGROUND | MB_SYSTEMMODAL;
   }
   else
   {
      mask |= MB_APPLMODAL;
   }

   return mask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\filesys.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// file system services
//
// 8-14-97 sburns



// CODEWORK: fix this: debug should be independent of this class.
// This class is used by the Debug::Log facility, so don't call into the
// Debug::Log or you'll cause an infinite recursion.
//


#include "headers.hxx"



static const int ROOTDIR_SIZE = 3;



// Returns true if the find handle is valid, false if not.

bool
IsValidHandle(HANDLE findHandle)
{
   if (findHandle != 0 && findHandle != INVALID_HANDLE_VALUE)
   {
      return true;
   }

   return false;
}



FS::Iterator::Iterator(
   const String&  startingPathSpec,
   unsigned       optionMask)
   :
   findData(0),
   findHandle(INVALID_HANDLE_VALUE),
   finished(false),
   options(optionMask),
   parentFolder(),
   startSearchSpec(startingPathSpec)
{
   LOG_CTOR(FS::Iterator);

   parentFolder = GetParentFolder(startSearchSpec);

   if (parentFolder.length() > ROOTDIR_SIZE)
   {
      // the parent folder is not a root folder, and so will not have
      // a trailing whack

      parentFolder += L"\\";
   }
}



FS::Iterator::~Iterator()
{
   LOG_DTOR(FS::Iterator);

   if (!finished)
   {
      Finish();
   }

   delete findData;
   findData = 0;
}



// Forces the iterator to the finished state.

void
FS::Iterator::Finish()
{
   LOG_FUNCTION(FS::Iterator::Finish);

   if (IsValidHandle(findHandle))
   {
      HRESULT unused = Win::FindClose(findHandle);

      ASSERT(SUCCEEDED(unused));   
      ASSERT(findData);

      findHandle = INVALID_HANDLE_VALUE;
   }

   delete findData;
   findData = 0;

   finished = true;
}



// Forces the iterator to the not started state.

void
FS::Iterator::Reset()
{
   LOG_FUNCTION(FS::Iterator::Reset);

   Finish();

   finished = false;
}



HRESULT
FS::Iterator::Start()
{
   LOG_FUNCTION(FS::Iterator::Start);

   // we should be in the "not started" state

   ASSERT(IsNotStarted());

   HRESULT hr = S_OK;

   do
   {
      // findData is deleted by Iterator::Finish

      findData = new WIN32_FIND_DATA;

      hr = Win::FindFirstFile(startSearchSpec, *findData, findHandle);
      if (FAILED(hr))
      {
         Finish();

         if (
               hr == Win32ToHresult(ERROR_NO_MORE_FILES)
            or hr == Win32ToHresult(ERROR_FILE_NOT_FOUND) )
         {
            // the iteration set is empty

            hr = S_FALSE;
         }

         break;   
      }

      // Here, we're positioned at the first match, which may not meet
      // our filter criteria.  Skip those matches that don't.

      hr = SkipFilteredPaths();
      BREAK_ON_FAILED_HRESULT(hr);
      if (hr == S_FALSE)
      {
         break;
      }
   }
   while (0);

   return hr;
}



bool
FS::Iterator::IsNotStarted()
{
   return !finished and !findData and (findHandle == INVALID_HANDLE_VALUE);
}



HRESULT
FS::Iterator::GetCurrent(String& result)
{
//   LOG_FUNCTION(FS::Iterator::GetCurrent);

   HRESULT hr = S_OK;
   result.erase();

   do
   {
      if (finished)
      {
         hr = S_FALSE;
         break;
      }

      if (IsNotStarted())
      {
         hr = Start();
         BREAK_ON_FAILED_HRESULT(hr);
         if (hr == S_FALSE)
         {
            break;
         }
      }

      // At this point, we're positioned at the first match that meets
      // our filter.

      result = ReturnPath();
   }
   while (0);

   return hr;
}



HRESULT
FS::Iterator::Increment()
{
//   LOG_FUNCTION(FS::Iterator::Increment);

   HRESULT hr = S_OK;
   
   do
   {
      // Start the iterator if it is not started already.

      String unused;
      hr = GetCurrent(unused);
      BREAK_ON_FAILED_HRESULT(hr);
      if (hr == S_FALSE)
      {
         break;
      }

      // now step to the next match.

      do
      {
         ASSERT(findData);

         if (findData)
         {
            hr = Win::FindNextFile(findHandle, *findData);
         }
         else
         {
            hr = E_POINTER;
         }
         if (FAILED(hr))
         {
            Finish();

            if (hr == Win32ToHresult(ERROR_NO_MORE_FILES))
            {
               // this is a "good" error.  It means we are done.

               hr = S_FALSE;
            }

            break;
         }

         ASSERT(IsValidHandle(findHandle));
      }
      while (ShouldSkipCurrent());
   }
   while (0);

   return hr;
}



String
FS::Iterator::ReturnPath()
{
//   LOG_FUNCTION(FS::Iterator::ReturnPath);
   ASSERT(findData);
   ASSERT(IsValidHandle(findHandle));

   if ((options bitand RETURN_FULL_PATHS) and findData)
   {
      return parentFolder + findData->cFileName;
   }

   if (findData)
   {
      return findData->cFileName;
   }

   return String();
}



// Determines if the Current path should be skipped according to the
// filtering options set upon contruction of the iterator.

bool
FS::Iterator::ShouldSkipCurrent()
{
//   LOG_FUNCTION(FS::Iterator::ShouldSkipCurrent);
   ASSERT(findData);

   bool result = false;

   do
   {
      if (!findData)
      {
         LOG(L"findData is null");
         break;
      }

      String file = findData->cFileName;

      if (!(options & INCLUDE_DOT_PATHS))
      {
         if (file == L"." || file == L"..")
         {
            LOG(L"skipping dot path " + file);
            result = true;
            break;
         }
      }

      bool isFolder =
            findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
         ?  true
         :  false;

      if (!(options & INCLUDE_FOLDERS))
      {
         if (isFolder)
         {
            LOG(L"skipping folder " + file);
            result = true;
            break;
         }
      }

      if (!(options & INCLUDE_FILES))
      {
         if (!isFolder)
         {
            LOG(L"skipping file " + file);
            result = true;
            break;
         }
      }
   }
   while (0);

   return result;
}



HRESULT
FS::Iterator::SkipFilteredPaths()
{
//   LOG_FUNCTION(FS::Iterator::SkipFilteredPaths);

   ASSERT(IsValidHandle(findHandle));

   HRESULT hr = S_OK;
   while (
         hr != S_FALSE
      && IsValidHandle(findHandle)
      && ShouldSkipCurrent())
   {
      hr = Increment();
      BREAK_ON_FAILED_HRESULT(hr);
   }

   return hr;
}



struct CopyFileExProgressData
{
   FS::CopyCallbackParam*  param;
   BOOL                    cancelFlag;
   Callback*               callback;
};



// Return the next highest whole number greater than n if the
// fractional portion of n >= 0.5, otherwise return n.

int
Round(double n)
{
   // truncate n to the integer portion
   //lint -e(922)  
   int n1 = static_cast<int>(n);
   if (n - n1 >= 0.5)
   {
      return n1 + 1;
   }

   return n1;
}



DWORD
WINAPI
copyFileProgress(

   //lint -e1746 These parameters can't be made const refs

   LARGE_INTEGER  TotalFileSize,
   LARGE_INTEGER  TotalBytesTransferred,
   LARGE_INTEGER  /* StreamSize */ ,
   LARGE_INTEGER  /* StreamBytesTransferred */ ,	
   DWORD          /* dwStreamNumber */ ,	
   DWORD          /* dwCallbackReason */ ,	
   HANDLE         /* hSourceFile */ ,	
   HANDLE         /* hDestinationFile */ ,
   void*          dp)
{
   ASSERT(dp);

   CopyFileExProgressData* data =
      reinterpret_cast<CopyFileExProgressData*>(dp);

   if (data)
   {
      LONGLONG totalCopied = TotalBytesTransferred.QuadPart;
      LONGLONG totalSize = TotalFileSize.QuadPart;

      if (totalSize != 0)
      {
         data->param->percentCopied =
            Round(totalCopied / totalSize * 100.0);
      }
      else
      {
         data->param->percentCopied = 100;
      }

      // invoke the callback
      if (data->callback)
      {
         data->cancelFlag = !data->callback->Execute(data->param);
      }

      if (!data->cancelFlag)
      {
         return PROGRESS_CONTINUE;
      }
   }

   return PROGRESS_CANCEL;
}



HRESULT
FS::CopyFile(
   const String& sourceFile,
   const String& destinationFile,
   Callback*     progressCallback)
{
   LOG_FUNCTION(FS::CopyFile);
   ASSERT(!sourceFile.empty());
   ASSERT(!destinationFile.empty());
   ASSERT(PathExists(sourceFile));

   HRESULT hr = S_OK;

   do
   {
      if (!PathExists(sourceFile))
      {
         hr = Win32ToHresult(ERROR_FILE_NOT_FOUND);
         break;
      }

      if (PathExists(destinationFile))
      {
         hr = Win32ToHresult(ERROR_ALREADY_EXISTS);
         break;
      }

      // do the copy

      // pull off the destination path

      String destPath = GetParentFolder(destinationFile);
      if (!PathExists(destPath))
      {
         hr = CreateFolder(destPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      CopyCallbackParam param;
      memset(&param, 0, sizeof(param));
      param.sourceFile      = sourceFile;     
      param.destinationFile = destinationFile;
      param.percentCopied   = 0;              

      CopyFileExProgressData data;
      memset(&data, 0, sizeof(data));
      data.param      = &param;          
      data.cancelFlag = FALSE;           
      data.callback   = progressCallback;

      hr =
         Win::CopyFileEx(
            sourceFile,
            destinationFile,
            copyFileProgress,
            &data,
            &data.cancelFlag,
            0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
FS::CreateFolder(const String& path)
{
   LOG_FUNCTION(FS::CreateFolder);
   ASSERT(IsValidPath(path));

   HRESULT hr = S_OK;

   do
   {
      if (PathExists(path))
      {
         // already exists is considered a successful create.

         hr = S_FALSE;
         break;
      }

      // Create all the folders required, up to and including the leaf folder.
      // The SDK api MakeSureDirectoryPathExists from dbghelp.lib also does
      // this, but the documented failure semantics are a bit vague, and it
      // doesn't seem necessary to require another link lib for this
      // operation.
      
      // copy the path into an array that we can mark up as we walk thru the
      // nested subdirectories.

      size_t len = path.length() + 1;
      wchar_t* c = new wchar_t[len];
      memset(c, 0, sizeof(wchar_t) * len);

      path.copy(c, len - 1);

      // Search for the first backslash after the first folder name.  Skip the
      // volume designation, and one character more, as we know that a folder
      // name must consist of at least one character that is not '\'
                                                                 
      wchar_t* current = wcschr(c + GetRootFolder(path).length() + 1, L'\\');

      while (SUCCEEDED(hr))
      {
         if (current)
         {
            // mark the trailing backslash as the end of the string.  This
            // makes c point to a truncated path (containing only the folder
            // names we have walk thru so far).

            *current = 0;
         }

         hr = Win::CreateDirectory(c);
         if (FAILED(hr))
         {
            if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
            {
               // folder already exists, so treat that as a successful
               // create.  We don't set hr = S_FALSE, because the existing
               // folder is an intermediate folder, not the one indicated
               // by the path parameter (that case is handled above).

               hr = S_OK;
            }
            else
            {
               break;
            }
         }

         if (current)
         {
            // replace the original trailing backslash, and move on to the
            // next backslash after that.

            *current = L'\\';
            current = wcschr(current + 1, L'\\');
         }
         else
         {
            // no more folders are on the path.  We're done.

            break;
         }
      }

      delete[] c;
   }
   while (0);

   return hr;
}



HRESULT
FS::GetAvailableSpace(const String& path, ULONGLONG& result)
{
   LOG_FUNCTION2(FS::GetAvailableSpace, path);
   ASSERT(FS::PathExists(path));

   memset(&result, 0, sizeof(result));

   ULARGE_INTEGER available;
   memset(&available, 0, sizeof(available));

   ULARGE_INTEGER total;
   memset(&total, 0, sizeof(total));

   HRESULT hr = Win::GetDiskFreeSpaceEx(path, available, total, 0);

   if (SUCCEEDED(hr))
   {
      result = available.QuadPart;
   }

   return hr;   
}



String
FS::GetRootFolder(const String& fullpath)
{
   LOG_FUNCTION2(FS::GetRootFolder, fullpath);
   ASSERT(FS::IsValidPath(fullpath));

   String result;

   do
   {
      FS::PathSyntax syn = FS::GetPathSyntax(fullpath);
      if (syn == SYNTAX_UNC_WILDCARD or syn == SYNTAX_UNC)
      {
         // we define the root folder of a UNC path to be the
         // share name with trailing backslash: \\server\share\

         // start looking for backslashes after the first two characters.

         size_t pos = fullpath.find(L"\\", 2);

         // this assertion had better hold if it's a valid unc path

         ASSERT(pos != String::npos);
         if (pos == String::npos)
         {
            break;
         }

         // look for the next backslash after that

         pos = fullpath.find(L"\\", pos + 1);

         if (pos != String::npos)
         {
            // include the trailing \

            result = fullpath.substr(0, pos + 1);
         }
         else
         {
            // it's just a share name, \\foo\bar, add trailing \

            result = fullpath + L"\\";
         }
      }
   }
   while (0);

   if (result.empty())
   {
      result = fullpath.substr(0, ROOTDIR_SIZE);
   }

   return result;
}



bool
FS::IsFolderEmpty(const String& path)
{
   LOG_FUNCTION(FS::IsFolderEmpty);
   ASSERT(IsValidPath(path));

   bool result = true;

   do
   {
      if (!PathExists(path))
      {
         // non-existent folders are empty by definition

         break;
      }

      String wild = path;

      if (wild[wild.length() - 1] != L'\\')
      {
         wild += L"\\";
      }

      wild += L"*.*";

      FS::Iterator iter(wild, FS::Iterator::INCLUDE_FILES);

// when recursive iteration is done, this can be added back in.
//          |  FS::Iterator::INCLUDE_FOLDERS);

      String unused;
      if (iter.GetCurrent(unused) != S_FALSE)
      {
         // there is at least one file/folder in the iteration set

         result = false;
      }
   }
   while (0);

   return result;
}



FS::PathSyntax
FS::GetPathSyntax(const String& str)
{
   LOG_FUNCTION(FS::GetPathSyntax);
   ASSERT(!str.empty());

   if (!str.empty())
   {
      wchar_t* p = const_cast<wchar_t*>(str.c_str());
      DWORD pathType = 0;

      NET_API_STATUS err = I_NetPathType(0, p, &pathType, 0);
      if (err == NERR_Success)
      {
         switch (pathType)
         {
            case ITYPE_PATH_ABSND:
            {
               return SYNTAX_ABSOLUTE_NO_DRIVE;
            }
            case ITYPE_PATH_ABSD:
            {
               return SYNTAX_ABSOLUTE_DRIVE;
            }
            case ITYPE_PATH_RELND:
            {
               return SYNTAX_RELATIVE_NO_DRIVE;
            }
            case ITYPE_PATH_RELD:
            {
               return SYNTAX_RELATIVE_DRIVE;
            }
            case ITYPE_PATH_ABSND_WC:
            {
               return SYNTAX_ABSOLUTE_NO_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_ABSD_WC:
            {
               return SYNTAX_ABSOLUTE_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_RELND_WC:
            {
               return SYNTAX_RELATIVE_NO_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_RELD_WC:
            {
               return SYNTAX_RELATIVE_DRIVE_WILDCARD;
            }
            case ITYPE_UNC:
            {
               return SYNTAX_UNC;
            }
            case ITYPE_UNC_WC:
            {
               return SYNTAX_UNC_WILDCARD;
            }
            default:
            {
               // fall thru
            }
         }
      }
   }

   return SYNTAX_UNRECOGNIZED;
}



bool
FS::IsValidPath(const String& path)
{
   ASSERT(!path.empty());

   if (!path.empty())
   {
      FS::PathSyntax syn = GetPathSyntax(path);
      if (syn == SYNTAX_ABSOLUTE_DRIVE or syn == SYNTAX_UNC)
      {
         return true;
      }
   }

   return false;
}



HRESULT
FS::CreateFile(
   const String&  path,
   HANDLE&        handle,
   DWORD          desiredAccess,
   DWORD          shareMode,
   DWORD          creationDisposition,
   DWORD          flagsAndAttributes)
{
   LOG_FUNCTION(FS::CreateFile);
   ASSERT(IsValidPath(path));

   HRESULT hr = S_OK;
   handle = INVALID_HANDLE_VALUE;

   do
   {
      // remove the last element of the path to form the parent directory

      String parentFolder = GetParentFolder(path);
      if (!PathExists(parentFolder))
      {
         hr = FS::CreateFolder(parentFolder);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = 
         Win::CreateFile(
            path,
            desiredAccess,
            shareMode,
            0,
            creationDisposition,
            flagsAndAttributes,
            0,
            handle);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
FS::PathExists(const String& path)
{
   ASSERT(IsValidPath(path));

   bool result = false;

   if (IsValidPath(path))
   {
      DWORD attrs = 0;
      HRESULT hr = Win::GetFileAttributes(path, attrs);
      if (SUCCEEDED(hr))
      {
         result = true;
      }
   }

   LOG(result ? L"true" : L"false");

   return result;
}



bool
FS::FileExists(const String& filepath)
{
   ASSERT(IsValidPath(filepath));

   bool result = false;

   if (IsValidPath(filepath))
   {
      DWORD attrs = 0;
      HRESULT hr = Win::GetFileAttributes(filepath, attrs);
      if (SUCCEEDED(hr))
      {
         result = !(attrs & FILE_ATTRIBUTE_DIRECTORY);
      }
   }

   LOG_BOOL(result);

   return result;
}



HRESULT
mySeek(
   HANDLE    handle,     
   LONGLONG  position,   
   DWORD     whence,     
   LONGLONG* newPosition)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   if (newPosition)
   {
      memset(newPosition, 0, sizeof(LONGLONG));
   }

   LARGE_INTEGER li;
   li.QuadPart = position;

   LARGE_INTEGER newPos;

   HRESULT hr = Win::SetFilePointerEx(handle, li, &newPos, whence);

   if (newPosition)
   {
      *newPosition = newPos.QuadPart;
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::GetFilePosition(HANDLE handle, LONGLONG& result)
{
   LOG_FUNCTION(FS::GetFilePosition);
   ASSERT(handle != INVALID_HANDLE_VALUE);

   memset(&result, 0, sizeof(result));

   LONGLONG position;
   memset(&position, 0, sizeof(position));

   return mySeek(handle, position, FILE_CURRENT, &result);
}



HRESULT
FS::GetFileSize(HANDLE handle, LONGLONG& result)
{
   LOG_FUNCTION(FS::GetFileSize);
   ASSERT(handle != INVALID_HANDLE_VALUE);

   memset(&result, 0, sizeof(LONGLONG));

   LARGE_INTEGER li;
   HRESULT hr = Win::GetFileSizeEx(handle, li);
   if (SUCCEEDED(hr))
   {
      result = li.QuadPart;
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Read(HANDLE handle, int bytesToRead, AnsiString& text)
{
   LOG_FUNCTION(FS::Read);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(bytesToRead);

   text.erase();

   HRESULT hr = S_OK;
   do
   {
      // figure out how much to read

      LONGLONG size;
      memset(&size, 0, sizeof(size));

      hr = FS::GetFileSize(handle, size);
      BREAK_ON_FAILED_HRESULT(hr);

      LONGLONG pos;
      memset(&pos, 0, sizeof(pos));

      hr = FS::GetFilePosition(handle, pos);
      BREAK_ON_FAILED_HRESULT(hr);

      if (bytesToRead == -1)
      {
         bytesToRead = INT_MAX;
      }

      // the most you can read is all that's left...

      LONGLONG btr = min(bytesToRead, size - pos);

      if (btr > INT_MAX)
      {
         // too much!  You'll never have enough memory

         hr = E_OUTOFMEMORY;
         break;
      }

      if (btr == 0)
      {
         // nothing to read

         break;
      }

      // altering the string should ensure that we are not sharing any
      // copies of the string data.

      //lint -e(922) for x86 LONGLONG is a double

      text.resize(static_cast<size_t>(btr));

      BYTE* buffer = reinterpret_cast<BYTE*>(const_cast<char*>(text.data()));

      DWORD bytesRead = 0;

      hr =
         Win::ReadFile(
            handle,
            buffer,

            //lint -e(922) for x86 LONGLONG is a double

            static_cast<DWORD>(btr),
            bytesRead,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      // the buffer contains all the bytes read.  now look for the first
      // null in the buffer, and truncate the string if necessary

      size_t len = strlen(text.data());
      if (len != text.length())
      {
         text.resize(len);
      }
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Seek(HANDLE handle, LONGLONG position)
{
   LOG_FUNCTION(FS::Seek);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   LONGLONG newpos;
   memset(&newpos, 0, sizeof(newpos));

   HRESULT hr = mySeek(handle, position, FILE_BEGIN, &newpos);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::SeekToEnd(HANDLE handle)
{
   LOG_FUNCTION(FS::SeekToEnd);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   LARGE_INTEGER li;
   memset(&li, 0, sizeof(li));

   return Win::SetFilePointerEx(handle, li, 0, FILE_END);
}



HRESULT
WriteHelper(HANDLE handle, void* buf, size_t bytesToWrite)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(buf);
   ASSERT(bytesToWrite);

   // on win64, size_t is 64 bits.
      
   ASSERT(bytesToWrite < ULONG_MAX);

   DWORD bytesWritten = 0;
   HRESULT hr =
      Win::WriteFile(
         handle,
         buf,
         static_cast<DWORD>(bytesToWrite),
         &bytesWritten);

   ASSERT(bytesWritten == bytesToWrite);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Write(HANDLE handle, const String& text)
{
   LOG_FUNCTION(FS::Write);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(!text.empty());

   size_t bytesToWrite = text.length() * sizeof(wchar_t);
   return
      WriteHelper(
         handle,
         reinterpret_cast<void*>(
            const_cast<wchar_t*>(text.data())),
         bytesToWrite);
}



HRESULT
FS::WriteLine(HANDLE handle, const String& text)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   return FS::Write(handle, text + L"\r\n");
}



HRESULT
FS::Write(HANDLE handle, const AnsiString& buf)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(!buf.empty());

   return
      WriteHelper(
         handle,
         reinterpret_cast<void*>(const_cast<char*>(buf.data())),
         buf.length());
}



FS::FSType
FS::GetFileSystemType(const String& path)
{
   LOG_FUNCTION(FS::GetFileSystemType);
   ASSERT(IsValidPath(path));

   String vol = FS::GetRootFolder(path);
   String filesysName;
   DWORD flags = 0;

   HRESULT hr =
      Win::GetVolumeInformation(vol, 0, 0, 0, &flags, &filesysName);

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      return FAT;
   }

   if (filesysName.icompare(L"CDFS") == 0)
   {
      return CDFS;
   }
   else if (filesysName.icompare(L"FAT") == 0)
   {
      return FAT;
   }
   else if (filesysName.icompare(L"NTFS") == 0)
   {
      if (flags & FILE_SUPPORTS_SPARSE_FILES)
      {
         // NTFS 5.0 supports this

         return NTFS5;
      }

//       // adapted from code from Keith Kaplan
// 
//       String objectName = L"\\DosDevices\\" + vol.substr(0, 2);
//       UNICODE_STRING unicodeName;
//       memset(&unicodeName, 0, sizeof(unicodeName));
//       ::RtlInitUnicodeString(&unicodeName, objectName.c_str());
// 
//       OBJECT_ATTRIBUTES objAttr;
//       memset(&objAttr, 0, sizeof(objAttr));
//       objAttr.Length     = sizeof(OBJECT_ATTRIBUTES);
//       objAttr.ObjectName = &unicodeName;             
//       objAttr.Attributes = OBJ_CASE_INSENSITIVE;     
// 
//       IO_STATUS_BLOCK block;
//       memset(&block, 0, sizeof(block));
//       HANDLE volume = 0;
//       NTSTATUS status =
//          ::NtOpenFile(
//             &volume,
//             SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
//             &objAttr,
//             &block,
//             FILE_SHARE_READ | FILE_SHARE_WRITE,
//             FILE_SYNCHRONOUS_IO_ALERT);
//       if (volume != INVALID_HANDLE_VALUE)
//       {
//          static const int BUFSIZE = 0x100;
//          char buf[BUFSIZE];
//          memset(buf, 0, sizeof(buf));
// 
//          status =
//             ::NtQueryVolumeInformationFile(
//                volume,
//                &block,
//                &buf,
//                BUFSIZE,
//                ::FileFsAttributeInformation);
//          Win::CloseHandle(volume);
//          if (status == STATUS_SUCCESS)
//          {
//             FILE_FS_ATTRIBUTE_INFORMATION* info =
//                reinterpret_cast<FILE_FS_ATTRIBUTE_INFORMATION*>(buf);
//             if (info->FileSystemAttributes & FILE_SUPPORTS_SPARSE_FILES)
//             {
//                // this implies NTFS 5.0
//                return NTFS5;
//             }
//          }
//       }

      return NTFS4;
   }

   return FAT;
}



bool
FS::IsParentFolder(const String& parent, const String& child)
{
   LOG_FUNCTION(FS::IsParentFolder);
   ASSERT(FS::IsValidPath(parent));
   ASSERT(FS::IsValidPath(child));

   if (child.length() <= parent.length())
   {
      // if child is shorter than parent, then no way parent is parent
      // folder
      return false;
   }

   // tokenize both paths, then compare the tokens one-by-one.  parent
   // is really a parent directory if all it's tokens are at the beginning
   // of child

   static const String DELIMS(L":\\");

   StringVector parentTokens;
   StringVector childTokens;
   parent.tokenize(std::back_inserter(parentTokens), DELIMS.c_str());
   child.tokenize(std::back_inserter(childTokens),   DELIMS.c_str());

   if (parentTokens.size() >= childTokens.size())
   {
      // if child has same or fewer tokens than parent, then no way is
      // parent the parent folder.
      return false;
   }

   for (
      size_t i = 0;
      i < parentTokens.size();
      ++i)
   {
      if (parentTokens[i].icompare(childTokens[i]))
      {
         // not equal tokens
         return false;
      }
   }

   return true;
}



HRESULT
FS::GetVolumePathName(const String& path, String& result)
{
   result.erase();
   HRESULT hr = S_OK;

   TCHAR* buf = new TCHAR[MAX_PATH];
   memset(buf, 0, sizeof(TCHAR) * MAX_PATH);
            
   if (::GetVolumePathName(path.c_str(), buf, MAX_PATH - 1))
   {
      result = buf;
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   delete[] buf;

   return hr;
}



String
FS::NormalizePath(const String& abnormalPath)
{
   LOG_FUNCTION2(FS::NormalizePath, abnormalPath);
   ASSERT(!abnormalPath.empty());

   String result;
   HRESULT hr = Win::GetFullPathName(abnormalPath, result);
   if (SUCCEEDED(hr))
   {
      return result;
   }

   LOG_HRESULT(hr);

   return abnormalPath;
}


   
HRESULT
FS::MoveFile(
   const String&  srcPath,
   const String&  dstPath)
{
   LOG_FUNCTION(FS::MoveFile);
   ASSERT(FS::PathExists(srcPath));
   ASSERT(FS::IsValidPath(dstPath));

   DWORD flags = 0;

   if (FS::GetRootFolder(srcPath).icompare(FS::GetRootFolder(dstPath)))
   {
      // paths are on different volumes, so include the copy option
      flags |= MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH;
   }

   return Win::MoveFileEx(srcPath, dstPath, flags);
}



void
FS::SplitPath(
   const String&  fullpath,
   String&        drive,
   String&        folderPath,
   String&        fileName,
   String&        extension)
{
   LOG_FUNCTION2(FS::SplitPath, fullpath);
   ASSERT(!fullpath.empty());

   wchar_t driveBuf[_MAX_DRIVE];
   memset(driveBuf, 0, sizeof(driveBuf));

   wchar_t folderBuf[_MAX_DIR];
   memset(folderBuf, 0, sizeof(folderBuf));

   wchar_t fileBuf[_MAX_FNAME];
   memset(fileBuf, 0, sizeof(fileBuf));

   wchar_t extBuf[_MAX_EXT];
   memset(extBuf, 0, sizeof(extBuf));

   _wsplitpath(fullpath.c_str(), driveBuf, folderBuf, fileBuf, extBuf);

   drive      = driveBuf; 
   folderPath = folderBuf;
   fileName   = fileBuf;  
   extension  = extBuf;   
}

String
FS::AppendPath(
   const String& base, 
   const String& additional)
{
   LOG_FUNCTION2(FS::AppendPath, base);
   ASSERT(!base.empty());
   ASSERT(!additional.empty());


   String path = base;
   
   if (*(path.rbegin()) != L'\\' &&
       *(additional.begin()) != L'\\')
   {
      path += L'\\';
   }

   path += additional;

   return path;
}


String
FS::GetParentFolder(const String& fullpath)
{
   LOG_FUNCTION2(FS::GetFolder, fullpath);
   ASSERT(!fullpath.empty());

   String drive;
   String folder;
   String filename;
   String extension;

   SplitPath(fullpath, drive, folder, filename, extension);

   String result = drive + folder;

   if (folder.length() > 1)
   {
      // the folder is not the root folder, which means it also has a
      // trailing \ which we want to remove

      ASSERT(folder[folder.length() - 1] == L'\\');

      result.resize(result.length() - 1);
   }

   return result;
}



String
FS::GetPathLeafElement(const String& fullpath)
{
   LOG_FUNCTION(FS::GetPathLeafElement);

   ASSERT(!fullpath.empty());

   String drive;
   String folder;
   String filename;
   String extension;

   SplitPath(fullpath, drive, folder, filename, extension);

   String result = filename + extension;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\sources.inc ===
# BURNSLIB project support code 
#
# Copyright (c) 1997-2000 Microsoft Corporation
#
# 06 Jan 2000 sburns

# common definitions to be included in the sources file(s) of subfolders


MAJORCOMP=admin
MINORCOMP=burnslib

TARGETNAME=burnslib
TARGETPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETLIBPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

UMTYPE=windows

# ISOLATION_AWARE_ENABLED ==> use ui themes. The sources for your binary
# that links to burnslib will also need to define this flag.

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DISOLATION_AWARE_ENABLED
USE_MSVCRT=1
USE_NATIVE_EH=1
USE_RTTI=1
USE_STD=1
USE_STL=1

PRECOMPILED_INCLUDE=..\headers.hxx
PRECOMPILED_CXX=1

MSC_WARNING_LEVEL=/W4

INCLUDES=..\;$(PROJECT_ROOT)\burnslib\inc;$(DS_INC_PATH);$(NET_INC_PATH);

UMLIBS= \
 	$(SDK_LIB_PATH)\kernel32.lib \
 	$(SDK_LIB_PATH)\user32.lib   \
 	$(SDK_LIB_PATH)\comctl32.lib \


SOURCES= \
	..\args.cpp     \
	..\computer.cpp \
	..\ControlSubclasser.cpp \
	..\dialog.cpp   \
	..\DiagnoseDcNotFound.cpp \
	..\dllref.cpp   \
	..\dns.cpp      \
	..\dsutil.cpp   \
	..\EncodedString.cpp \
	..\error.cpp    \
	..\extract.cpp  \
	..\filesys.cpp  \
	..\netutil.cpp  \
	..\proppage.cpp \
	..\popup.cpp    \
	..\registry.cpp \
	..\safedll.cpp  \
	..\service.cpp  \
	..\utility.cpp  \
	..\win.cpp      \
	..\winerror.cpp \
	..\wizard.cpp   \
	..\wizpage.cpp  \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\proppage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Property Page base class class
// 
// 9-9-97 sburns



#include "headers.hxx"



PropertyPage::PropertyPage(
   unsigned    dialogResID,
   const DWORD helpMap_[],
   bool        deleteOnRelease_)
   :
   Dialog(dialogResID, helpMap_),
   deleteOnRelease(deleteOnRelease_)
{
//   LOG_CTOR(PropertyPage);
}



PropertyPage::~PropertyPage()
{
//   LOG_DTOR(PropertyPage);
}



UINT CALLBACK 
PropertyPage::PropSheetPageCallback(
   HWND           /* hwnd */ ,
   UINT           uMsg,
   PROPSHEETPAGE* page)
{
   if (uMsg == PSPCB_RELEASE)
   {
      // deletes the PropertyPage instance if it was created with the
      // appropriate flag
      PropertyPage* p = reinterpret_cast<PropertyPage*>(page->lParam);
      if (p)
      {
         if (p->deleteOnRelease)
         {
            delete p;
         }
      }
   }

   return TRUE;
}



HPROPSHEETPAGE
PropertyPage::Create()
{
   LOG_FUNCTION(PropertyPage::Create);

   PROPSHEETPAGE page;
   memset(&page, 0, sizeof(page));
      
   page.dwSize       = sizeof(page);
   page.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK;
   page.hInstance    = GetResourceModuleHandle();
   page.pszTemplate  = reinterpret_cast<PCTSTR>(MAKEINTRESOURCEW(GetResID()));
   page.pfnDlgProc   = PropertyPage::propPageDialogProc;
   page.pfnCallback  = PropertyPage::PropSheetPageCallback;

   // this pointer is retrieved by the dialog proc 
   page.lParam       = reinterpret_cast<LPARAM>(this);

   HPROPSHEETPAGE result = 0;
   HRESULT hr = Win::CreatePropertySheetPage(page, result);
   ASSERT(SUCCEEDED(hr));

   return result;
}



bool
PropertyPage::OnApply(bool /* isClosing */ )
{
   // LOG_FUNCTION2(
   //    PropertyPage::OnApply,
   //    isClosing ? L"closing" : L"not closing");

   return false;
}



bool
PropertyPage::OnHelp()
{
   LOG_FUNCTION(PropertyPage::OnHelp);

   return false;
}



bool
PropertyPage::OnKillActive()
{
//   LOG_FUNCTION(PropertyPage::OnKillActive);

   return false;
}



bool
PropertyPage::OnSetActive()
{
//   LOG_FUNCTION(PropertyPage::OnSetActive);

   return false;
}



bool
PropertyPage::OnQueryCancel()
{
//   LOG_FUNCTION(PropertyPage::OnQueryCancel);

   return false;
}



bool
PropertyPage::OnReset()
{
//   LOG_FUNCTION(PropertyPage::OnReset);

   return false;
}



bool
PropertyPage::OnWizBack()
{
//   LOG_FUNCTION(PropertyPage::OnWizBack);

   return false;
}



bool
PropertyPage::OnWizNext()
{
//   LOG_FUNCTION(PropertyPage::OnWizNext);

   return false;
}



bool
PropertyPage::OnWizFinish()
{
//   LOG_FUNCTION(PropertyPage::OnWizFinish);

   return false;
}



// bool
// PropertyPage::OnHelp(const HELPINFO& helpinfo)
// {
//    LOG_FUNCTION(PropertyPage::OnHelp);
// 
//    return false;
// }



PropertyPage*
PropertyPage::getPage(HWND pageDialog)
{
//    LOG_FUNCTION(getPage);
   ASSERT(Win::IsWindow(pageDialog));

   Dialog* result = Dialog::GetInstance(pageDialog);

   // don't assert ptr, it may not have been set.  Some messages are
   // sent before WM_INITDIALOG, which is the earliest we can set the
   // pointer.
   //
   // for example, the LinkWindow control sends NM_CUSTOMDRAW before
   // WM_INITDIALOG

   return dynamic_cast<PropertyPage*>(result);
}


      
INT_PTR APIENTRY
PropertyPage::propPageDialogProc(
   HWND     dialog,
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
   switch (message)
   {
      case WM_INITDIALOG:
      {
         // a pointer to the PropertyPage is in the lparam of the page struct,
         // which is in the lparam to this function.  Save this in the window
         // structure so that it can later be retrieved by getPage.

         ASSERT(lparam);
         PROPSHEETPAGE* psp = reinterpret_cast<PROPSHEETPAGE*>(lparam);
         ASSERT(psp);

         if (psp)
         {
            Win::SetWindowLongPtr(dialog, DWLP_USER, psp->lParam);

            PropertyPage* page = getPage(dialog);
            if (page)      // 447770 prefix warning
            {
               page->SetHWND(dialog);
               page->OnInit();
            }
         }
   
         return TRUE;
      }
      case WM_NOTIFY:
      {
         NMHDR* nmhdr = reinterpret_cast<NMHDR*>(lparam);
         PropertyPage* page = getPage(dialog);

         if (page)
         {
            ASSERT(page->hwnd == dialog);
            bool result = false;

            // LOG(String::format(L"%1!x!", nmhdr->code));
            
            switch (nmhdr->code)
            {
               case PSN_APPLY:
               {
                  PSHNOTIFY* pshn = reinterpret_cast<PSHNOTIFY*>(nmhdr);
                  result = page->OnApply(pshn->lParam ? true : false);
                  break;
               }
               case PSN_KILLACTIVE:
               {
                  result = page->OnKillActive();
                  break;
               }
               case PSN_QUERYCANCEL:
               {
                  result= page->OnQueryCancel();
                  break;
               }
               case PSN_RESET:
               {
                  result = page->OnReset();
                  break;
               }
               case PSN_SETACTIVE:
               {
                  result = page->OnSetActive();
                  break;
               }
               case PSN_WIZBACK:
               {
                  result = page->OnWizBack();
                  break;
               }
               case PSN_WIZNEXT:
               {
                  result = page->OnWizNext();
                  break;
               }
               case PSN_WIZFINISH:
               {
                  result = page->OnWizFinish();

                  // DONT DO THIS!!! - the result is just there to mean that we have
                  //                   handled the message.  It does reveal whether or
                  //                   not the OnWizFinish was successful.  The
                  //                   the handler of OnWizFinish should call
                  //                   SetWindowLongPtr to set its result value

                  //Win::SetWindowLongPtr(dialog, DWLP_MSGRESULT, result ? TRUE : FALSE);
                  break;
               }
               case PSN_HELP:
               {
                  result = page->OnHelp();
                  break;
               }
               case PSN_QUERYINITIALFOCUS:
               case PSN_TRANSLATEACCELERATOR:
               default:
               {
                  result = 
                     page->OnNotify(
                        nmhdr->hwndFrom,
                        nmhdr->idFrom,
                        nmhdr->code,
                        lparam);
                  break;
               }
            }

            return result ? TRUE : FALSE;
         }

         return FALSE;
      }
      default:
      {
         return dialogProc(dialog, message, wparam, lparam);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\safedll.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Self-freeing DLL class
// 
// 10-9-98 sburns



#include "headers.hxx"



SafeDLL::SafeDLL(const String& dllName)
   :
   module(0),
   name(dllName)
{
   LOG_CTOR(SafeDLL);
   ASSERT(!name.empty());
}



SafeDLL::~SafeDLL()
{
   LOG_DTOR(SafeDLL);

   if (module)
   {
      HRESULT unused = Win::FreeLibrary(module);

      ASSERT(SUCCEEDED(unused));
   }
}



HRESULT
SafeDLL::GetProcAddress(const String& functionName, FARPROC& result) const
{
   LOG_FUNCTION2(SafeDLL::GetProcAddress, functionName);
   ASSERT(!functionName.empty());

   result = 0;
   HRESULT hr = S_OK;

   do
   {
      // load the dll if not already loaded.         
      if (!module)
      {
         hr = Win::LoadLibrary(name, module);
      }
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::GetProcAddress(module, functionName, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\registry.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// System Registry Class
//
// 7-9-98 sburns



#include "headers.hxx"



RegistryKey::RegistryKey()
   :
   key(0)
{
   LOG_CTOR(RegistryKey);
}



RegistryKey::~RegistryKey()
{
   LOG_DTOR(RegistryKey);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
      key = 0;
   }
}



HRESULT
RegistryKey::Close()
{
   HRESULT hr = Win::RegCloseKey(key);
   key = 0;

   return hr;
}



HRESULT
RegistryKey::Create(
   HKEY                 parentKey,
   const String&        subkeyName,
   DWORD                options,
   REGSAM               desiredAccess,
   SECURITY_ATTRIBUTES* securityAttrs,
   DWORD*               disposition)
{
   LOG_FUNCTION2(RegistryKey::Create, subkeyName);
   ASSERT(parentKey);
   ASSERT(!subkeyName.empty());
   ASSERT(desiredAccess);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
   }

   return
      Win::RegCreateKeyEx(
         parentKey,
         subkeyName,
         options,
         desiredAccess,
         securityAttrs,
         key,
         disposition);
}



HRESULT
RegistryKey::Open(
   HKEY           parentKey,
   const String&  subkeyName,
   REGSAM         desiredAccess)
{
   LOG_FUNCTION2(RegistryKey::Open, subkeyName);
   ASSERT(parentKey);
   ASSERT(!subkeyName.empty());
   ASSERT(desiredAccess);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
   }

   return Win::RegOpenKeyEx(parentKey, subkeyName, desiredAccess, key);
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   DWORD&         value)
{
   LOG_FUNCTION2(RegistryKey::GetValue-DWORD, valueName);
   ASSERT(!valueName.empty());
   ASSERT(key);

   value = 0;
   DWORD dataSize = sizeof(DWORD);
   DWORD type = 0;

   HRESULT hr = 
      Win::RegQueryValueEx(
         key,
         valueName,
         &type,
         reinterpret_cast<BYTE*>(&value),
         &dataSize);

   if (SUCCEEDED(hr))
   {
      if (
            type != REG_DWORD
         && type != REG_DWORD_LITTLE_ENDIAN
         && type != REG_DWORD_BIG_ENDIAN)
      {
         // wrong type
         hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
      }
   }

   return hr;
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   String&        value,
   bool&          isExpandSz)
{
   LOG_FUNCTION2(RegistryKey::GetValue-String, valueName);
   ASSERT(!valueName.empty());
   ASSERT(key);

   value.erase();
   isExpandSz = false;

   DWORD type = 0;
   DWORD size = 0;
   HRESULT hr = Win::RegQueryValueEx(key, valueName, &type, 0, &size);
   if (SUCCEEDED(hr))
   {
      if (type == REG_SZ || type == REG_EXPAND_SZ)
      {
         // now that we know the size, read the contents

         BYTE* buf = new BYTE[size];   // a bitesized buffer!  Ha Ha!
         memset(buf, 0, size);

         type = 0;
         hr = Win::RegQueryValueEx(key, valueName, &type, buf, &size);
         if (SUCCEEDED(hr))
         {
            value = reinterpret_cast<wchar_t*>(buf);
            delete[] buf;
            isExpandSz = (type == REG_EXPAND_SZ);
         }
      }
      else
      {
         // caller requested a string from a non-string key

         hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
      }
   }

   return hr;
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   String&        value)
{
   bool unused = false;
   return GetValue(valueName, value, unused);
}



HRESULT
RegistryKey::SetValue(
   const String&  valueName,
   DWORD          value)
{
   LOG_FUNCTION2(RegistryKey::SetValue-DWORD, valueName);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   return
      Win::RegSetValueEx(
         key,
         valueName,
         REG_DWORD,
         reinterpret_cast<BYTE*>(&value),
         sizeof(DWORD));
}



HRESULT
RegistryKey::SetValue(
   const String&  valueName,
   const String&  value,
   bool           expand)
{
   LOG_FUNCTION2(
      RegistryKey::SetValue-String,
      valueName + L"=" + value);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   // add 1 to include null terminator

   DWORD bytes = static_cast<DWORD>((value.length() + 1) * sizeof(wchar_t));

   return
      Win::RegSetValueEx(
         key,
         valueName,
         expand ? REG_EXPAND_SZ : REG_SZ,
         reinterpret_cast<BYTE*>(
            const_cast<wchar_t*>(value.c_str())),
         bytes);
}



String
RegistryKey::GetString(const String& valueName)
{
   LOG_FUNCTION2(RegistryKey::GetString, valueName);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   String s;
   LONG result = GetValue(valueName, s);
   if (result != ERROR_SUCCESS)
   {
      s.erase();
   }

   return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\service.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Service Control Manager wrapper class
// 
// 10-6-98 sburns




#include "headers.hxx"



NTService::NTService(const String& machine_, const String& serviceName)
   :
   machine(machine_),
   name(serviceName)
{
   LOG_CTOR(NTService);
   ASSERT(!serviceName.empty());

   // machine name may be empty
}



NTService::NTService(const String& serviceName)
   :
   machine(),
   name(serviceName)
{
   LOG_CTOR(NTService);
   ASSERT(!serviceName.empty());

   // machine name may be empty
}



NTService::~NTService()
{
   LOG_DTOR(NTService);
}



HRESULT
MyOpenService(
   const String&  machine,
   const String&  name,
   DWORD          access,
   SC_HANDLE&     result)
{
   LOG_FUNCTION(MyOpenService);
   ASSERT(!name.empty());
   ASSERT(access);

   result = 0;

   HRESULT hr = S_OK;

   SC_HANDLE handle = 0;

   do
   {
      hr = Win::OpenSCManager(machine, GENERIC_READ, handle);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::OpenService(handle, name, access, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (handle)
   {
      Win::CloseServiceHandle(handle);
   }

   return hr;
}   



bool
NTService::IsInstalled()
{
   LOG_FUNCTION2(NTService::IsInstalled, name);

   SC_HANDLE handle = 0;
   HRESULT hr = MyOpenService(machine, name, SERVICE_QUERY_STATUS, handle);

   if (SUCCEEDED(hr))
   {
      Win::CloseServiceHandle(handle);
      return true;
   }

   return false;
}



HRESULT
NTService::GetCurrentState(DWORD& state)
{
   LOG_FUNCTION2(NTService::GetCurrentState, name);

   state = 0;
   SC_HANDLE handle = 0;
   HRESULT hr = S_OK;
   do
   {
      hr = MyOpenService(machine, name, SERVICE_QUERY_STATUS, handle);
      BREAK_ON_FAILED_HRESULT(hr);

      SERVICE_STATUS status;
      memset(&status, 0, sizeof(status));

      hr = Win::QueryServiceStatus(handle, status); 
      BREAK_ON_FAILED_HRESULT(hr);

      state = status.dwCurrentState;
   }
   while (0);

   if (handle)
   {
      Win::CloseServiceHandle(handle);
   }
      
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\utility.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// global utility functions
//
// 8-14-97 sburns



#include "headers.hxx"



HRESULT
Reboot()
{
   LOG_FUNCTION(Reboot);

   HRESULT hr = S_OK;
   HANDLE htoken = INVALID_HANDLE_VALUE;

   do
   {
      // twiddle our process privileges to enable SE_SHUTDOWN_NAME

      LOG(L"OpenProcessToken");

      hr =
         Win::OpenProcessToken(
            Win::GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES,
            htoken);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"LookupPrivilegeValue");

      LUID luid;
      memset(&luid, 0, sizeof(luid));
      hr = Win::LookupPrivilegeValue(0, SE_SHUTDOWN_NAME, luid);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"AdjustTokenPrivileges");

      TOKEN_PRIVILEGES privs;
      memset(&privs, 0, sizeof(privs));
      privs.PrivilegeCount = 1;
      privs.Privileges[0].Luid = luid;
      privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

      hr = Win::AdjustTokenPrivileges(htoken, 0, &privs, 0, 0, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"ExitWindowsEx");

      hr = Win::ExitWindowsEx(EWX_REBOOT);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (htoken != INVALID_HANDLE_VALUE)
   {
      Win::CloseHandle(htoken);
   }

   return S_OK;
}



bool
IsCurrentUserAdministrator()
{
   LOG_FUNCTION(IsCurrentUserAdministrator);

   HRESULT hr = S_OK;

   bool result = false;
   do
   {
      // Create a SID for the local Administrators group
      SID_IDENTIFIER_AUTHORITY authority = {SECURITY_NT_AUTHORITY};
      PSID adminGroupSid = 0;
      hr =
         Win::AllocateAndInitializeSid(
            authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            adminGroupSid);
      BREAK_ON_FAILED_HRESULT(hr);

      BOOL isMember = FALSE;
      if (::CheckTokenMembership(0, adminGroupSid, &isMember))
      {
         result = isMember ? true : false;
      }

      Win::FreeSid(adminGroupSid);
   }
   while (0);

   LOG(
      String::format(
         L"Current user %1 an admin",
         result ? L"is" : L"is NOT"));

   return result;
}



NetbiosValidationResult
NetbiosValidationHelper(const String& name, DWORD nameType, int maxLength)
{
   LOG_FUNCTION(NetbiosValidationHelper);

   if (name.empty())
   {
      LOG(L"empty name");
      return INVALID_NAME;
   }

   // check that the name is not longer than the max bytes in the oem
   // character set.
   wchar_t* ps = const_cast<wchar_t*>(name.c_str());
   int oembytes =
      ::WideCharToMultiByte(
         CP_OEMCP,
         0,
         ps,
         static_cast<int>(name.length()),
         0,
         0,
         0,
         0);
   if (oembytes > maxLength)
   {
      LOG(L"name too long");
      return NAME_TOO_LONG;
   }

   // this checks length in oem bytes, and illegal characters.  Unfortunately,
   // it does not distinguish between those two.  That's why we checked the
   // length ourselves (above).

   LOG(L"Calling I_NetNameValidate");

   NET_API_STATUS err =
      I_NetNameValidate(
         0,
         ps,
         nameType,
         LM2X_COMPATIBLE);
   if (err != NERR_Success)
   {
      LOG(L"invalid name");
      return INVALID_NAME;
   }

   LOG(L"valid name");
   return VALID_NAME;
}



NetbiosValidationResult
ValidateNetbiosDomainName(const String& s)
{
   LOG_FUNCTION2(ValidateNetbiosDomainName, s);
   ASSERT(!s.empty());

   return
      NetbiosValidationHelper(
         s,
         NAMETYPE_DOMAIN,
         DNLEN);
}



NetbiosValidationResult
ValidateNetbiosComputerName(const String& s)
{
   LOG_FUNCTION2(ValidateNetbiosComputerName, s);
   ASSERT(!s.empty());

   return
      NetbiosValidationHelper(
         s,
         NAMETYPE_COMPUTER,
         MAX_COMPUTERNAME_LENGTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\win.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrappers of Win APIs
//
// 8-14-97 sburns



#include "headers.hxx"



static const int ROOTDIR_SIZE = 3;



Win::CursorSetting::CursorSetting(const String& newCursorName)
   :
   oldCursor(0)
{
   init(newCursorName.c_str(), false);
}



Win::CursorSetting::CursorSetting(
   const TCHAR* newCursorName,
   bool         isSystemCursor)
   :
   oldCursor(0)
{
   init(newCursorName, isSystemCursor);
}



Win::CursorSetting::CursorSetting(HCURSOR newCursor)
   :
   oldCursor(0)
{
   oldCursor = Win::SetCursor(newCursor);
}



void
Win::CursorSetting::init(
   const TCHAR* newCursorName,
   bool         isSystemCursor)
{
   ASSERT(newCursorName);

   HCURSOR newCursor = 0;
   HRESULT hr = Win::LoadCursor(newCursorName, newCursor, isSystemCursor);

   ASSERT(SUCCEEDED(hr));

   oldCursor = Win::SetCursor(newCursor);

   // oldCursor may be null if no cursor was in effect
}



Win::CursorSetting::~CursorSetting()
{
   // restore the old cursor

   Win::SetCursor(oldCursor);
}



HRESULT
Win::AdjustTokenPrivileges(
   HANDLE             tokenHandle,
   bool               disableAllPrivileges,
   TOKEN_PRIVILEGES   newState[],
   DWORD              bufferLength,
   TOKEN_PRIVILEGES*  previousState,
   DWORD*             returnLength)
{
   ASSERT(tokenHandle);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::AdjustTokenPrivileges(
         tokenHandle,
         disableAllPrivileges ? TRUE : FALSE,
         newState,
         bufferLength,
         previousState,
         returnLength);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::AllocateAndInitializeSid(
   SID_IDENTIFIER_AUTHORITY&  authority,
   BYTE                       subAuthorityCount,
   DWORD                      subAuthority0,
   DWORD                      subAuthority1,
   DWORD                      subAuthority2,
   DWORD                      subAuthority3,
   DWORD                      subAuthority4,
   DWORD                      subAuthority5,
   DWORD                      subAuthority6,
   DWORD                      subAuthority7,
   PSID&                      sid)
{
   ASSERT(subAuthorityCount && subAuthorityCount <= UCHAR_MAX);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::AllocateAndInitializeSid(
         &authority,
         subAuthorityCount,
         subAuthority0,
         subAuthority1,
         subAuthority2,
         subAuthority3,
         subAuthority4,
         subAuthority5,
         subAuthority6,
         subAuthority7,
         &sid);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Animate_Open(HWND animation, const TCHAR* animationNameOrRes)
{
   ASSERT(Win::IsWindow(animation));
   ASSERT(animationNameOrRes);

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            animation,
            ACM_OPEN,
            0,
            reinterpret_cast<LPARAM>(animationNameOrRes)));

   ASSERT(result);
}



void
Win::Animate_Stop(HWND animation)
{
   ASSERT(Win::IsWindow(animation));

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            animation,
            ACM_STOP,
            0,
            0));
   ASSERT(result);
}



HRESULT
Win::AppendMenu(
   HMENU    menu,     
   UINT     flags,    
   UINT_PTR idNewItem,
   PCTSTR   newItem)
{
   ASSERT(menu);
   ASSERT(idNewItem);
   ASSERT(newItem);

   HRESULT hr = S_OK;

   BOOL err = ::AppendMenu(menu, flags, idNewItem, newItem);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Button_SetCheck(HWND button, int checkState)
{
   ASSERT(Win::IsWindow(button));

   Win::SendMessage(button, BM_SETCHECK, static_cast<WPARAM>(checkState), 0);
}

bool
Win::Button_GetCheck(HWND button)
{
   ASSERT(Win::IsWindow(button));

   bool result = BST_CHECKED ==
      Win::SendMessage(
         button,
         BM_GETCHECK,
         0,
         0);

   return result;
}

void
Win::Button_SetStyle(HWND button, int style, bool redraw)
{
   ASSERT(Win::IsWindow(button));

   Win::SendMessage(
      button,
      BM_SETSTYLE,
      static_cast<WPARAM>(LOWORD(style)),
      MAKELPARAM((redraw ? TRUE : FALSE), 0));
}



void
Win::CheckDlgButton(
   HWND     parentDialog,
   int      buttonID,
   UINT     buttonState)
{
   // ensure that our type substitution is valid
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(buttonID);
   ASSERT(
         buttonState == BST_CHECKED
      || buttonState == BST_UNCHECKED
      || buttonState == BST_INDETERMINATE);

   BOOL result =
      ::CheckDlgButton(parentDialog, buttonID, buttonState);
   ASSERT(result);
}



void
Win::CheckRadioButton(
   HWND  parentDialog,
   int   firstButtonInGroupID,
   int   lastButtonInGroupID,
   int   buttonInGroupToCheckID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(firstButtonInGroupID);
   ASSERT(lastButtonInGroupID);
   ASSERT(buttonInGroupToCheckID);

   BOOL result =
      ::CheckRadioButton(
         parentDialog,
         firstButtonInGroupID,
         lastButtonInGroupID,
         buttonInGroupToCheckID);

   ASSERT(result);
}



void
Win::CloseHandle(HANDLE& handle)
{

// don't assert.  Closing an invalid handle is a no-op.
//    ASSERT(handle != INVALID_HANDLE_VALUE);

   if (handle != INVALID_HANDLE_VALUE)
   {
      BOOL result = ::CloseHandle(handle);
      ASSERT(result);
   }

   handle = INVALID_HANDLE_VALUE;
}



void
Win::CloseServiceHandle(SC_HANDLE handle)
{
   ASSERT(handle);

   BOOL result = ::CloseServiceHandle(handle);
   ASSERT(result);
}



int
Win::ComboBox_AddString(HWND combo, const String& s)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(!s.empty());

   int result =
      static_cast<int>(
         Win::SendMessage(
            combo,
            CB_ADDSTRING,
            0,
            reinterpret_cast<LPARAM>(s.c_str())));
   ASSERT(result != CB_ERR);
   ASSERT(result != CB_ERRSPACE);

   return result;
}



int
Win::ComboBox_GetCurSel(HWND combo)
{
   ASSERT(Win::IsWindow(combo));

   int result = (int) (DWORD) Win::SendMessage(combo, CB_GETCURSEL, 0, 0);

   // don't assert: it's legal that the listbox not have any selection

   return result;
}



String
Win::ComboBox_GetCurText(HWND combo)
{
   ASSERT(Win::IsWindow(combo));

   int sel = Win::ComboBox_GetCurSel(combo);
   if (sel != CB_ERR)
   {
      return Win::ComboBox_GetLBText(combo, sel);
   }

   return String();
}



String
Win::ComboBox_GetLBText(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   String s;
   do
   {
      int maxlen = Win::ComboBox_GetLBTextLen(combo, index);
      if (maxlen == CB_ERR)
      {
         break;
      }

      s.resize(maxlen + 1);
      int len =
         (int) Win::SendMessage(
            combo,
            CB_GETLBTEXT,
            index,
            reinterpret_cast<LPARAM>(const_cast<wchar_t*>(s.c_str())));
      if (len == CB_ERR)
      {
         break;
      }

      s.resize(len);
   }
   while (0);

   return s;
}
   

      
int
Win::ComboBox_GetLBTextLen(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   return (int) Win::SendMessage(combo, CB_GETLBTEXTLEN, index, 0);
}



int
Win::ComboBox_SelectString(HWND combo, const String& str)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(!str.empty());

   int result =
      (int) Win::SendMessage(
         combo,
         CB_SELECTSTRING,
         static_cast<WPARAM>(-1),   // search entire list
         reinterpret_cast<LPARAM>(const_cast<wchar_t*>(str.c_str())));

   // don't assert the result: if the item is not in the list, that's
   // not necessarily a logic failure

   return result;
}



void
Win::ComboBox_SetCurSel(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   int result =
      (int) (DWORD) Win::SendMessage(
         combo,
         CB_SETCURSEL,
         static_cast<WPARAM>(index),
         0);
   ASSERT(result != CB_ERR);
}



int
Win::CompareString(
   LCID  locale,
   DWORD flags,
   const String& string1,
   const String& string2)
{
   int len1 = static_cast<int>(string1.length());
   int len2 = static_cast<int>(string2.length());

   int result =
      ::CompareString(
         locale,
         flags,
         string1.c_str(),
         len1,
         string2.c_str(),
         len2);
   ASSERT(result);

   return result;
}



HRESULT
Win::ConvertSidToStringSid(PSID sid, String& result)
{
   ASSERT(sid);

   result.erase();

   HRESULT hr = S_OK;

   PTSTR sidstr = 0;
   BOOL b = ::ConvertSidToStringSid(sid, &sidstr);
   if (b)
   {
      result = sidstr;
      ::LocalFree(sidstr);
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::CopyFileEx(
   const String&        existingFileName,
   const String&        newFileName,
   LPPROGRESS_ROUTINE   progressRoutine,
   void*                progressParam,
   BOOL*                cancelFlag,
   DWORD                flags)
{
   ASSERT(!existingFileName.empty());
   ASSERT(!newFileName.empty());

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::CopyFileEx(
         existingFileName.c_str(),
         newFileName.c_str(),
         progressRoutine,
         progressParam,
         cancelFlag,
         flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as there are any number of reasons this may
   // fail that are not unexpected and should be explicitly checked for
   // by the caller.

   return hr;
}



HRESULT
Win::CopySid(DWORD destLength, PSID dest, PSID source)
{
   ASSERT(destLength);
   ASSERT(dest);
   ASSERT(source);

   HRESULT hr = S_OK;
   
   BOOL succeeded = ::CopySid(destLength, dest, source);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));
   
   return hr;
}



HRESULT
Win::CreateDialogParam(
   HINSTANCE      hInstance,	
   const TCHAR*   templateName,
   HWND           owner,
   DLGPROC        dialogProc,
   LPARAM         param,
   HWND&          result)
{
   ASSERT(hInstance);
   ASSERT(templateName);
   ASSERT(dialogProc);
   ASSERT(owner == 0 || Win::IsWindow(owner));

   HRESULT hr = S_OK;

   result =
      ::CreateDialogParam(
         hInstance,
         templateName,
         owner,
         dialogProc,
         param);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));
   ASSERT(Win::IsWindow(result));

   return hr;
}



HRESULT
Win::CreateDirectory(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::CreateDirectory(path.c_str(), 0);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as there are any number of reasons this may
   // fail that are not unexpected and should be explicitly checked for
   // by the caller.

   return hr;
}



HRESULT
Win::CreateEvent(
   SECURITY_ATTRIBUTES* securityAttributes,
   bool                 manualReset,
   bool                 initiallySignaled,
   HANDLE&              result)
{
   // securityAttributes may be null

   HRESULT hr = S_OK;

   result =
      ::CreateEvent(
         securityAttributes,
         manualReset ? TRUE : FALSE,
         initiallySignaled ? TRUE : FALSE,
         0);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateEvent(
   SECURITY_ATTRIBUTES* securityAttributes,
   bool                 manualReset,
   bool                 initiallySignaled,
   const String&        name,
   HANDLE&              result)
{
   // securityAttributes may be null

   ASSERT(!name.empty());

   HRESULT hr = S_OK;

   result =
      ::CreateEvent(
         securityAttributes,
         manualReset ? TRUE : FALSE,
         initiallySignaled ? TRUE : FALSE,
         name.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateFile(
   const String&        fileName,
   DWORD                desiredAccess,	
   DWORD                shareMode,
   SECURITY_ATTRIBUTES* securityAttributes,	
   DWORD                creationDistribution,
   DWORD                flagsAndAttributes,
   HANDLE               hTemplateFile,
   HANDLE&              result)
{
   // securityAttributes may be null

   ASSERT(!fileName.empty());

   HRESULT hr = S_OK;

   result =
      ::CreateFile(
         fileName.c_str(),
         desiredAccess,	
         shareMode,
         securityAttributes,	
         creationDistribution,
         flagsAndAttributes,
         hTemplateFile);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateFontIndirect(
   const LOGFONT& logFont,
   HFONT&         result)
{
   HRESULT hr = S_OK;

   result = ::CreateFontIndirect(&logFont);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateMailslot(
   const String&        name,
   DWORD                maxMessageSize,
   DWORD                readTimeout,
   SECURITY_ATTRIBUTES* attributes,
   HANDLE&              result)
{
   ASSERT(!name.empty());
   ASSERT(readTimeout == 0 or readTimeout == MAILSLOT_WAIT_FOREVER);

   // attributes may be null

   HRESULT hr = S_OK;
   result =
      ::CreateMailslot(
         name.c_str(),
         maxMessageSize,
         readTimeout,
         attributes);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }
      
   // don't assert, as the caller may be explicitly testing for an error.      

   return hr;
}



HRESULT
Win::CreateMutex(
   SECURITY_ATTRIBUTES* attributes,
   bool                 isInitialOwner,
   const String&        name,
   HANDLE&              result)
{
   // securityAttributes may be null

   HRESULT hr = S_OK;
      
   ::SetLastError(0);

   result =
      ::CreateMutex(
         attributes,
         isInitialOwner ? TRUE : FALSE,
         name.empty() ? 0 : name.c_str());

   // If the create fails, then the last error is why it failed.  If it
   // succeeded, then the mutex may have already existed, in which case the
   // last error is ERROR_ALREADY_EXISTS.  If it succeeds, and the mutex
   // didn't already exist, then the last error is 0.

   hr = Win::GetLastErrorAsHresult();

   // don't assert, as the caller may be explicitly testing for an error.      

   return hr;
}



HRESULT
Win::CreatePopupMenu(HMENU& result)
{
   HRESULT hr = S_OK;

   result = ::CreatePopupMenu();
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateProcess(
   String&              commandLine,
   SECURITY_ATTRIBUTES* processAttributes,
   SECURITY_ATTRIBUTES* threadAttributes,
   bool                 inheritHandles,
   DWORD                creationFlags,
   void*                environment,
   const String&        currentDirectory,
   STARTUPINFO&         startupInformation,
   PROCESS_INFORMATION& processInformation)
{
   ASSERT(!commandLine.empty());

   HRESULT hr = S_OK;

   startupInformation.cb = sizeof(STARTUPINFO);
   startupInformation.lpReserved = 0;
   startupInformation.cbReserved2 = 0;
   startupInformation.lpReserved2 = 0;

   memset(&processInformation, 0, sizeof(processInformation));

   size_t len = commandLine.length();
   WCHAR* tempCommandLine = new WCHAR[len + 1];
   memset(tempCommandLine, 0, sizeof(WCHAR) * (len + 1));
   commandLine.copy(tempCommandLine, len);
   BOOL result =
      ::CreateProcessW(
         0,
         tempCommandLine,
         processAttributes,
         threadAttributes,
         inheritHandles ? TRUE : FALSE,
         creationFlags,
         environment,
         currentDirectory.empty() ? 0 : currentDirectory.c_str(),
         &startupInformation,
         &processInformation);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // The api may have modified the command line

   commandLine = tempCommandLine;
   delete[] tempCommandLine;

   return hr;
}



HRESULT
Win::CreatePropertySheetPage(
   const PROPSHEETPAGE& pageInfo,
   HPROPSHEETPAGE&      result)
{
   HRESULT hr = S_OK;

   result = ::CreatePropertySheetPage(&pageInfo);
   if (!result)
   {
      // then what?  The SDK docs don't mention any error code, and an
      // inspection of the code indicates that SetLastError is not called.

      hr = E_FAIL;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateSolidBrush(
   COLORREF color,
   HBRUSH&  result)
{
   HRESULT hr = S_OK;

	result = ::CreateSolidBrush(color);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateStreamOnHGlobal(
   HGLOBAL     hglobal,
   bool        deleteOnRelease,
   IStream*&   result)
{
   ASSERT(hglobal);

   HRESULT hr =
      ::CreateStreamOnHGlobal(
         hglobal,
         deleteOnRelease ? TRUE : FALSE,
         &result);

   ASSERT(SUCCEEDED(hr));
   ASSERT(result);

   return hr;
}



HRESULT
Win::CreateWindowEx(
   DWORD          exStyle,
   const String&  className,
   const String&  windowName,
   DWORD          style,
   int            x,
   int            y,
   int            width,
   int            height,
   HWND           parent,
   HMENU          menuOrChildID,
   void*          param,
   HWND&          result)
{
   // parent may be null

   HRESULT hr = S_OK;

   result =
      ::CreateWindowEx(
         exStyle,
         className.c_str(),
         windowName.c_str(),
         style,
         x,
         y,
         width,
         height,
         parent,
         menuOrChildID,
         GetResourceModuleHandle(),
         param);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::DeleteFile(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL result = ::DeleteFile(path.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure to delete a file is not necessarily a program
   // logic problem.

   return hr;
}



HRESULT
Win::DeleteObject(HGDIOBJ& object)
{
	ASSERT(object);

   HRESULT hr = S_OK;

	BOOL result = ::DeleteObject(object);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // why would you care if the delete failed?  because it might fail if
   // the object was selected into a DC, and that would indicate a bug.

	ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   object = 0;

   return hr;
}



HRESULT
Win::DeleteObject(HFONT& object)
{
   HGDIOBJ o = reinterpret_cast<HGDIOBJ>(object);

   HRESULT hr = Win::DeleteObject(o);

   object = 0;

   return hr;
}



HRESULT
Win::DeleteObject(HBITMAP& object)
{
   HGDIOBJ o = reinterpret_cast<HGDIOBJ>(object);

   HRESULT hr = Win::DeleteObject(o);

   object = 0;

   return hr;
}



HRESULT
Win::DestroyIcon(HICON& icon)
{
   ASSERT(icon);

   HRESULT hr = S_OK;

   BOOL result = ::DestroyIcon(icon);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   icon = 0;

   return hr;
}



HRESULT
Win::DestroyMenu(HMENU& menu)
{
   ASSERT(menu);

   HRESULT hr = S_OK;

   BOOL err = ::DestroyMenu(menu);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   menu = 0;

   return hr;
}



HRESULT
Win::DestroyPropertySheetPage(HPROPSHEETPAGE& page)
{
   ASSERT(page);

   HRESULT hr = S_OK;

   BOOL result = ::DestroyPropertySheetPage(page);
   if (!result)
   {
      // There is no documentation indicating that there is an error code,
      // and looking at the source, it appears that the delete will always
      // return true.  So this is probably dead code.

      hr = E_FAIL;
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   page = 0;

   return hr;
}



HRESULT
Win::DestroyWindow(HWND& window)
{
   ASSERT(window == 0 || Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL result = ::DestroyWindow(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   window = 0;

   return hr;
}



// templateName must be TCHAR* to support MAKEINTRESOURCE usage

// threadsafe

INT_PTR
Win::DialogBoxParam(
   HINSTANCE      hInstance,	
   const TCHAR*   templateName,
   HWND           owner,
   DLGPROC        dialogProc,
   LPARAM         param)
{
   ASSERT(hInstance);
   ASSERT(templateName);
   ASSERT(dialogProc);
   ASSERT(owner == 0 || Win::IsWindow(owner));

   INT_PTR result =
      ::DialogBoxParam(
         hInstance,
         templateName,
         owner,
         dialogProc,
         param);
   ASSERT(result != -1);

   return result;
}



HRESULT
Win::DrawFocusRect(HDC dc, const RECT& rect)
{
	ASSERT(dc);

   HRESULT hr = S_OK;

	BOOL result = ::DrawFocusRect(dc, &rect);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Edit_AppendText(
   HWND           editbox,
   const String&  text,
   bool           preserveSelection,
   bool           canUndo)
{
   ASSERT(Win::IsWindow(editbox));
   ASSERT(!text.empty());

   // save the current selection
   int start = 0;
   int end = 0;
   if (preserveSelection)
   {
      Win::Edit_GetSel(editbox, start, end);
   }

   // move the selection to the end
   Win::Edit_SetSel(editbox, INT_MAX, INT_MAX);

   // insert the text
   Win::Edit_ReplaceSel(editbox, text, canUndo);

   // restore the selection
   if (preserveSelection)
   {
      Win::Edit_SetSel(editbox, start, end);
   }
}



void
Win::Edit_GetSel(HWND editbox, int& start, int& end)
{
   ASSERT(Win::IsWindow(editbox));

   LRESULT result =
         Win::SendMessage(
            editbox,
            EM_GETSEL,
            0,
            0);

   ASSERT(result != -1);

   start = LOWORD(result);
   end = HIWORD(result);
}



void
Win::Edit_LimitText(HWND editbox, int limit)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(editbox, EM_LIMITTEXT, static_cast<WPARAM>(limit), 0);
}



void
Win::Edit_ReplaceSel(HWND editbox, const String& newText, bool canUndo)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(
      editbox,
      EM_REPLACESEL,
      canUndo ? TRUE : FALSE,
      reinterpret_cast<LPARAM>(newText.c_str()));
}



void
Win::Edit_SetSel(HWND editbox, int start, int end)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(editbox, EM_SETSEL, start, end);
}



bool
Win::EqualSid(PSID sid1, PSID sid2)
{
   ASSERT(IsValidSid(sid1));
   ASSERT(IsValidSid(sid2));

   return ::EqualSid(sid1, sid2) ? true : false;
}



// @@ hresult?  What possible value would it be?

void
Win::EnableWindow(HWND window, bool state)
{
   ASSERT(Win::IsWindow(window));

   // the return value here is of no use.
   ::EnableWindow(window, state ? TRUE : FALSE);
}



HRESULT
Win::EndDialog(HWND dialog, int result)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(result != -1);

   HRESULT hr = S_OK;

   BOOL r = ::EndDialog(dialog, result);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::EnumUILanguages(
   UILANGUAGE_ENUMPROCW proc,
   DWORD                flags,
   LONG_PTR             lParam)
{
   ASSERT(proc);

   HRESULT hr = S_OK;

   BOOL result = ::EnumUILanguagesW(proc, flags, lParam);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ExitWindowsEx(UINT options)
{
   HRESULT hr = S_OK;

   BOOL result = ::ExitWindowsEx(options, 0);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::ExpandEnvironmentStrings(const String& s)
{
   if (s.empty())
   {
      return s;
   }

   // determine the length of the expanded string
   DWORD len = ::ExpandEnvironmentStrings(s.c_str(), 0, 0);
   ASSERT(len);

   if (!len)
   {
      return s;
   }

   String result(len, 0);
   DWORD len1 =
      ::ExpandEnvironmentStrings(
         s.c_str(),
         const_cast<wchar_t*>(result.data()),
         len);
   ASSERT(len1 == len);

   if (!len1)
   {
      return s;
   }

   return result;
}



HRESULT
Win::FindFirstFile(
   const String&     fileName,
   WIN32_FIND_DATA&  data,
   HANDLE&           result)
{
   ASSERT(!fileName.empty());

   memset(&data, 0, sizeof(WIN32_FIND_DATA));
   result = INVALID_HANDLE_VALUE;

   HRESULT hr = S_OK;

   result = ::FindFirstFile(fileName.c_str(), &data);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert:  not necessarily a program logic error

   return hr;
}



HRESULT
Win::FindClose(HANDLE& findHandle)
{
   ASSERT(findHandle);

   HRESULT hr = S_OK;

   BOOL result = ::FindClose(findHandle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   findHandle = 0;

   return hr;      
}



HRESULT
Win::FindNextFile(HANDLE& findHandle, WIN32_FIND_DATA& data)
{
   ASSERT(findHandle != 0 && findHandle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result = ::FindNextFile(findHandle, &data);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as caller may be looking for ERROR_NO_MORE_FILES

   return hr;
}



HRESULT
Win::FlushFileBuffers(HANDLE handle)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result = ::FlushFileBuffers(handle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::FrameRect(HDC dc, const RECT& rect, HBRUSH brush)
{
	ASSERT(dc);
	ASSERT(brush);

   HRESULT hr = S_OK;

	int result = ::FrameRect(dc, &rect, brush);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::FreeLibrary(HMODULE& module)
{
   ASSERT(module);

   HRESULT hr = S_OK;

   BOOL result = ::FreeLibrary(module);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the module so we don't reuse it

   module = 0;

   return hr;
}



void
Win::FreeSid(PSID sid)
{
   ASSERT(sid);

   ::FreeSid(sid);
}



HWND
Win::GetActiveWindow()
{
   return ::GetActiveWindow();
}



HRESULT
Win::GetClassInfoEx(const String& className, WNDCLASSEX& info)
{
   return Win::GetClassInfoEx(0, className, info);
}



HRESULT
Win::GetClassInfoEx(
   HINSTANCE      hInstance,
   const String&  className,
   WNDCLASSEX&    info)
{
   ASSERT(!className.empty());
   memset(&info, 0, sizeof(WNDCLASS));
   info.cbSize = sizeof(WNDCLASSEX);

   HRESULT hr = S_OK;

   BOOL result = ::GetClassInfoEx(hInstance, className.c_str(), &info);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetClassName(HWND window)
{
   ASSERT(Win::IsWindow(window));

   TCHAR name[256 + 1];
   memset(name, 0, sizeof(name));
   int result =
      ::GetClassName(
         window,
         name,
         256);
   ASSERT(result);

   return String(name);
}



String
Win::GetClipboardFormatName(UINT format)
{
   ASSERT(format);

   String s(256 + 1, 0);
   int result =
      ::GetClipboardFormatName(
         format,
         const_cast<wchar_t*>(s.c_str()),
         256);
   ASSERT(result);
   s.resize(result);

   return s;
}



HRESULT
Win::GetClientRect(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL result = ::GetClientRect(window, &rect);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetColorDepth(int& result)
{
   result = 0;

   HRESULT hr = S_OK;

   do
   {
      HDC hdc = 0;
      hr = Win::GetDC(NULL, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      result = Win::GetDeviceCaps(hdc, BITSPIXEL);
      Win::ReleaseDC(NULL, hdc);
   }
   while (0);

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetCommandLine()
{
   PTSTR line = ::GetCommandLine();
   ASSERT(line);

   return String(line);
}



// ISSUE-2000/10/31-sburns CODEWORK: this usage should be preferred, as in the case of DNS names,
// if tcp/ip is not installed, GetComputerNameEx will fail.

HRESULT
Win__GetComputerNameEx(COMPUTER_NAME_FORMAT format, String& result)
{
   result.erase();

   HRESULT hr = S_OK;
   TCHAR* buf = 0;

   do
   {   
      // first call to determine buffer size

      DWORD bufSize = 0;
      BOOL succeeded = ::GetComputerNameEx(format, 0, &bufSize);

      // we expect it to fail with ERROR_MORE_DATA

      ASSERT(!succeeded);

      // second call to retrieve the name

      DWORD bufSize2 = bufSize + 1;   
      buf = new TCHAR[bufSize2];
      memset(buf, 0, sizeof(TCHAR) * (bufSize2));

      succeeded = ::GetComputerNameEx(format, buf, &bufSize);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      ASSERT(bufSize <= bufSize2);

      result = buf;
   }
   while (0);

   if (buf)
   {
      delete[] buf;
   }

   return hr;
}



String
Win::GetComputerNameEx(COMPUTER_NAME_FORMAT format)
{
   String result;

   Win__GetComputerNameEx(format, result);

   // don't assert success: the given name type may not be present (e.g.
   // if tcp/ip is not installed, no DNS names are available)

   return result;
}



HRESULT
Win::GetCurrentDirectory(String& result)
{
   wchar_t buf[MAX_PATH + 1];
   memset(buf, 0, (MAX_PATH + 1) * sizeof(wchar_t));

   result.erase();
   HRESULT hr = S_OK;
   DWORD r = ::GetCurrentDirectory(MAX_PATH, buf);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else
   {
      result = buf;
   }

   return hr;
}



HANDLE
Win::GetCurrentProcess()
{
   HANDLE result = ::GetCurrentProcess();
   ASSERT(result);

   return result;
}



HRESULT
Win::GetCursorPos(POINT& result)
{
   HRESULT hr = S_OK;
   result.x = 0;
   result.y = 0;
   BOOL err = ::GetCursorPos(&result);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetDC(HWND window, HDC& result)
{
   ASSERT(window == 0 || Win::IsWindow(window));

   HRESULT hr = S_OK;

   result = ::GetDC(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::GetDesktopWindow()
{
   return ::GetDesktopWindow();
}



int
Win::GetDeviceCaps(HDC hdc, int index)
{
   ASSERT(hdc);
   ASSERT(index > 0);

   return ::GetDeviceCaps(hdc, index);
}



HRESULT
Win::GetDiskFreeSpaceEx(
   const String&     path,
   ULARGE_INTEGER&   available,
   ULARGE_INTEGER&   total,
   ULARGE_INTEGER*   freespace)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL result =
      ::GetDiskFreeSpaceEx(path.c_str(), &available, &total, freespace);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::GetDlgItem(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HWND item = ::GetDlgItem(parentDialog, itemResID);
   ASSERT(item);

   return item;
}



String
Win::GetDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID);

   HWND h = Win::GetDlgItem(parentDialog, itemResID);
   ASSERT(Win::IsWindow(h));

   return Win::GetWindowText(h);
}


int
Win::GetDlgItemInt(HWND parentDialog, int itemResID, bool isSigned)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID);

   BOOL success = TRUE;
   int result = ::GetDlgItemInt(
                   parentDialog, 
                   itemResID,
                   &success,
                   isSigned);

   ASSERT(success);
   return result;
}


UINT
Win::GetDriveType(const String& path)
{
   ASSERT(path[1] == L':');

   // The Win32 function requires a path containing just the root directory,
   // so determine what that is

   String rootDir;
   if (path.length() > ROOTDIR_SIZE)
   {
      rootDir = path.substr(0, ROOTDIR_SIZE);
   }
   else
   {
      rootDir = path;
   }
      
   return ::GetDriveType(rootDir.c_str());
}



EncodedString
Win::GetEncodedDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   EncodedString retval;
   WCHAR* cleartext = 0;
   int length = 0;
   
   do
   {
      HWND item = Win::GetDlgItem(parentDialog, itemResID);
      if (!item)
      {
         break;
      }

      length = ::GetWindowTextLength(item);
      if (!length)
      {
         break;
      }

      // add 1 to length for null-terminator
   
      ++length;
      cleartext = new WCHAR[length];
      ::ZeroMemory(cleartext, sizeof(WCHAR) * length);

      int result = ::GetWindowText(item, cleartext, length);

      ASSERT(result == length - 1);

      if (!result)
      {
         break;
      }

      retval.Encode(cleartext);
   }
   while (0);
   
   // make sure we scribble out the cleartext.

   if (cleartext)
   {
      ::ZeroMemory(cleartext, sizeof(WCHAR) * length);
      delete[] cleartext;
   }

   return retval;
}

   
   
String
Win::GetEnvironmentVariable(const String& name)
{
   ASSERT(!name.empty());

   // determine the size of the result, in characters
   DWORD chars = ::GetEnvironmentVariable(name.c_str(), 0, 0);

   if (chars)
   {
      // don't include the null terminator in the String size
      String retval(chars - 1, 0);

      DWORD result =
         ::GetEnvironmentVariable(
            name.c_str(),
            const_cast<TCHAR*>(retval.c_str()),
            chars);

      // -1 because the first call includes the null terminator, the
      // second does not
      ASSERT(result == (chars - 1));

      return retval;
   }

   return String();
}



HRESULT
Win::GetExitCodeProcess(HANDLE hProcess, DWORD& exitCode)
{
   ASSERT(hProcess);

   HRESULT hr = S_OK;

   exitCode = 0;
   BOOL result = ::GetExitCodeProcess(hProcess, &exitCode);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetFileAttributes(const String& path, DWORD& result)
{
   ASSERT(!path.empty());

   result = 0;

   HRESULT hr = S_OK;

   result = ::GetFileAttributes(path.c_str());
   if (result == 0xFFFFFFFF)
   {
      result = 0;
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: caller may be testing for the presence of a file.

   return hr;
}



HRESULT
Win::GetFileSizeEx(HANDLE handle, LARGE_INTEGER& result)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   memset(&result, 0, sizeof(result));

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetFileSizeEx(handle, &result);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



DWORD
Win::GetFileType(HANDLE handle)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   return ::GetFileType(handle);
}



HRESULT
Win::GetFullPathName(const String& path, String& result)
{
   ASSERT(!path.empty());
   ASSERT(path.length() <= MAX_PATH);

   result.erase();

   HRESULT hr = S_OK;
   unsigned bufchars = MAX_PATH;
   wchar_t* buf = 0;

   // don't retry more than 3 times...

   while (bufchars < MAX_PATH * 4)
   {
      buf = new wchar_t[bufchars];
      memset(buf, 0, sizeof(wchar_t) * (bufchars));

      wchar_t* unused = 0;
      DWORD x =
         ::GetFullPathName(
            path.c_str(),
            bufchars,
            buf,
            &unused);
      if (x == 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }
      if (x > MAX_PATH)
      {
         // buffer too small.  Not likely, as we passed in MAX_PATH characters.

         ASSERT(false);

         delete[] buf;
         buf = 0;
         bufchars *= 2;
         continue;
      }

      result = buf;
      break;
   }

   delete[] buf;

   return hr;
}



HRESULT
Win::GetLastErrorAsHresult()
{
   DWORD err = ::GetLastError();
   return HRESULT_FROM_WIN32(err);
}



void
Win::GetLocalTime(SYSTEMTIME& time)
{
   memset(&time, 0, sizeof(time));

   ::GetLocalTime(&time);
}



HRESULT
Win::GetLogicalDriveStrings(size_t bufChars, TCHAR* buf, DWORD& result)
{

#ifdef DBG
   // if buf == 0, then bufChars must also (this would be the case where
   // the caller is attempting to determine the size of the buffer needed.
   // (if C++ supported a logical xor, denoted by ^^, then this expression
   // would be: ASSERT(!(bufChars ^^ buf)

   if (!buf)
   {
      ASSERT(!bufChars);
   }

   ASSERT(bufChars < ULONG_MAX);

#endif

   HRESULT hr = S_OK;

   DWORD buflen = static_cast<DWORD>(bufChars);
   result = ::GetLogicalDriveStrings(buflen, buf);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetMailslotInfo(
   HANDLE   mailslot,
   DWORD*   maxMessageSize,
   DWORD*   nextMessageSize,
   DWORD*   messageCount,
   DWORD*   readTimeout)
{
   ASSERT(mailslot != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result =
      ::GetMailslotInfo(
         mailslot,
         maxMessageSize,
         nextMessageSize,
         messageCount,
         readTimeout);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetModuleFileName(HMODULE hModule)
{
   ASSERT(hModule);

   String s(MAX_PATH + 1, 0);
   DWORD result =
      ::GetModuleFileName(
         hModule,
         const_cast<wchar_t*>(s.c_str()),
         MAX_PATH);
   ASSERT(result);
   s.resize(result);

   return s;
}



HINSTANCE
Win::GetModuleHandle()
{
   HINSTANCE result = ::GetModuleHandle(0);
   ASSERT(result);

   return result;
}



HWND
Win::GetParent(HWND child)
{
   ASSERT(Win::IsWindow(child));

   HWND retval = ::GetParent(child);

   // you probably are doing something wrong if you ask for the
   // parent of an orphan.
   ASSERT(retval);

   return retval;
}



String
Win::GetPrivateProfileString(
   const String& section,
   const String& key,
   const String& defaultValue,
   const String& filename)
{
   ASSERT(!section.empty());
   ASSERT(!key.empty());
   ASSERT(!filename.empty());

   // our first call is with a large buffer, hoping that it will suffice...

   String retval;
   unsigned bufSize = 1023;
   PTSTR buffer = 0;

   do
   {
      buffer = new TCHAR[bufSize + 1];
      memset(buffer, 0, (bufSize + 1) * sizeof(TCHAR));

      DWORD result =
         ::GetPrivateProfileString(
            section.c_str(),
            key.c_str(),
            defaultValue.c_str(),
            buffer,
            bufSize,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // a value was found.  check to see if it was truncated.

      if (result == bufSize - 1)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         delete[] buffer;
         bufSize *= 2;
         continue;
      }

      // copy the result

      retval = buffer;
      break;
   }

   //lint -e506   ok that this looks like "loop forever"
      
   while (true);

   delete[] buffer;
   return retval;
}



HRESULT
Win::GetProcAddress(
   HMODULE        module,
   const String&  procName,
   FARPROC&       result)
{
   ASSERT(module);
   ASSERT(!procName.empty());

   HRESULT hr = S_OK;

   result = 0;

   // convert the name from unicode to ansi

   AnsiString pn;
   String::ConvertResult r = procName.convert(pn);
   ASSERT(r == String::CONVERT_SUCCESSFUL);

   result = ::GetProcAddress(module, pn.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetStringTypeEx(
   LCID           localeId,
   DWORD          infoTypeOptions,
   const String&  sourceString,
   WORD*          charTypeInfo)
{
   ASSERT(localeId);
   ASSERT(infoTypeOptions);
   ASSERT(!sourceString.empty());
   ASSERT(charTypeInfo);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::GetStringTypeEx(
         localeId,
         infoTypeOptions,
         sourceString.c_str(),
         static_cast<int>(sourceString.length()),
         charTypeInfo);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetSysColor(int element, DWORD& result)
{
	ASSERT(element);

   result = 0;

   HRESULT hr = S_OK;

	result = ::GetSysColor(element);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



int
Win::GetSystemMetrics(int index)
{
   // should assert that index is an SM_ value

   int result = ::GetSystemMetrics(index);
   ASSERT(result);

   return result;
}



String
Win::GetSystemDirectory()
{
   wchar_t buf[MAX_PATH + 1];

   UINT result = ::GetSystemDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);
   if (result == 0 || result > MAX_PATH)
   {
      // fall back to a reasonable default
      return
            Win::GetSystemWindowsDirectory()
         +  L"\\"
         +  String::load(IDS_SYSTEM32);
   }

   return String(buf);
}


// should use GetSystemWindowsDirectory instead

// String
// Win::GetSystemRootDirectory()
// {
//    static const wchar_t* SYSTEMROOT = L"%systemroot%";
// 
//    wchar_t buf[MAX_PATH + 1];
// 
//    DWORD result =
//       ::ExpandEnvironmentStrings(
//          SYSTEMROOT,
//          buf,
//          MAX_PATH + 1);
//    ASSERT(result != 0 && result <= MAX_PATH);
//    if (result == 0 || result > MAX_PATH)
//    {
//       return String();
//    }
// 
//    return String(buf);
// }



// CODEWORK: should replace this with a version that returns an HRESULT
// like GetTempPath

String
Win::GetSystemWindowsDirectory()
{
   wchar_t buf[MAX_PATH + 1];
   ::ZeroMemory(buf, sizeof(buf));

   UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   return String(buf);
}



HRESULT
Win::GetTempPath(String& result)
{
   wchar_t buf[MAX_PATH + 1];
   ::ZeroMemory(buf, sizeof(buf));

   HRESULT hr = S_OK;
   result.erase();
   
   DWORD err = ::GetTempPathW(MAX_PATH, buf);
   ASSERT(err != 0 && err <= MAX_PATH);

   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else if (err > MAX_PATH)
   {
      // buffer too small: unlikely!

      hr = Win32ToHresult(ERROR_INSUFFICIENT_BUFFER);
   }
   else
   {
      result = buf;
   }

   return hr;
}
      
   
   
HRESULT
Win::GetTextExtentPoint32(
   HDC            hdc,
   const String&  str,
   SIZE&          size)
{
   ASSERT(hdc);
   ASSERT(hdc != INVALID_HANDLE_VALUE);

   memset(&size, 0, sizeof(SIZE));

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::GetTextExtentPoint32(
         hdc,
         str.c_str(),
         static_cast<int>(str.length()),
         &size);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetTextMetrics(HDC hdc, TEXTMETRIC& tmet)
{
   ASSERT(hdc);
   ASSERT(hdc != INVALID_HANDLE_VALUE);

   memset(&tmet, 0, sizeof(TEXTMETRIC));

   HRESULT hr = S_OK;

   BOOL succeeded =::GetTextMetrics(hdc, &tmet);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::FreeTokenInformation(TOKEN_USER* userInfo)
{
   delete[] reinterpret_cast<BYTE*>(userInfo);
}



// caller should free the result with Win::FreeTokenInformation

HRESULT
GetTokenInformationHelper(
   HANDLE                  hToken,   
   TOKEN_INFORMATION_CLASS infoClass,
   BYTE*&                  result)   
{
   ASSERT(hToken != INVALID_HANDLE_VALUE);
   ASSERT(!result);

   HRESULT hr = S_OK;
   result = 0;

   do
   {
      // first, determine the size of the buffer we'll need

      DWORD bufSize = 0;
      BOOL succeeded =
         ::GetTokenInformation(hToken, infoClass, 0, 0, &bufSize);

      if (succeeded)
      {
         // we expect failure...

         ASSERT(false);
         hr = E_UNEXPECTED;
         break;
      }

      hr = Win::GetLastErrorAsHresult();
      if (hr != Win32ToHresult(ERROR_INSUFFICIENT_BUFFER))
      {
         // we failed for some other reason than buffer too small.

         break;
      }

      ASSERT(bufSize);

      // erase the last error (the insuff. buffer error)
      
      hr = S_OK;
      
      result = new BYTE[bufSize];
      ::ZeroMemory(result, bufSize);

      succeeded =
         ::GetTokenInformation(hToken, infoClass, result, bufSize, &bufSize);
      if (!succeeded)
      {
         delete[] result;
         result = 0;
         hr = Win::GetLastErrorAsHresult();
         break;
      }
   }
   while (0);

   return hr;
}



HRESULT
Win::GetTokenInformation(HANDLE hToken, TOKEN_USER*& userInfo)
{
   ASSERT(hToken != INVALID_HANDLE_VALUE);
   ASSERT(!userInfo);

   userInfo = 0;

   BYTE* result = 0;
   HRESULT hr = GetTokenInformationHelper(hToken, TokenUser, result);
   if (SUCCEEDED(hr))
   {
      userInfo = reinterpret_cast<TOKEN_USER*>(result);
   }
   else
   {
      ASSERT(false);
   }

   return hr;
}



String
Win::GetTrimmedDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HWND item = Win::GetDlgItem(parentDialog, itemResID);
   if (!item)
   {
      // The empty string
      return String();
   }

   return Win::GetWindowText(item).strip(String::BOTH);
}



String
Win::GetTrimmedWindowText(HWND window)
{
   // Win::GetWindowText does validation of the window
   return Win::GetWindowText(window).strip(String::BOTH);
}



HRESULT
Win::GetVersionEx(OSVERSIONINFO& info)
{
   memset(&info, 0, sizeof(OSVERSIONINFO));
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetVersionEx(&info);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetVersionEx(OSVERSIONINFOEX& info)
{
   memset(&info, 0, sizeof(OSVERSIONINFOEX));
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&info));
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}

void
Win::GetSystemInfo(SYSTEM_INFO& info)
{
   memset(&info, 0, sizeof(SYSTEM_INFO));

   ::GetSystemInfo(reinterpret_cast<SYSTEM_INFO*>(&info));
}



HRESULT
Win::GetVolumeInformation(
   const String&  volume,
   String*        name,
   DWORD*         serialNumber,
   DWORD*         maxFilenameLength,
   DWORD*         flags,
   String*        fileSystemName)
{
   ASSERT(volume.length() >= ROOTDIR_SIZE);

   HRESULT hr = S_OK;

   if (name)
   {
      name->erase();
   }
   if (serialNumber)
   {
      *serialNumber = 0;
   }
   if (maxFilenameLength)
   {
      *maxFilenameLength = 0;
   }
   if (flags)
   {
      *flags = 0;
   }
   if (fileSystemName)
   {
      fileSystemName->erase();
   }

   TCHAR volNameBuf[MAX_PATH + 1];
   memset(volNameBuf, 0, sizeof(volNameBuf));

   TCHAR filesysName[MAX_PATH + 1];
   memset(filesysName, 0, sizeof(filesysName));

   BOOL succeeded =
      ::GetVolumeInformation(
         volume.c_str(),
         volNameBuf,
         MAX_PATH,
         serialNumber,
         maxFilenameLength,
         flags,
         filesysName,
         MAX_PATH);
   if (succeeded)
   {
      if (name)
      {
         name->assign(volNameBuf);
      }
      if (fileSystemName)
      {
         fileSystemName->assign(filesysName);
      }
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: some devices (like floppy drives) may respond with
   // not ready, and that's not necessarily a logic error.

   return hr;
}



HRESULT
Win::GetWindowDC(HWND window, HDC& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;

   result = ::GetWindowDC(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HFONT
Win::GetWindowFont(HWND window)
{
   ASSERT(Win::IsWindow(window));

   return
      reinterpret_cast<HFONT>(
         Win::SendMessage(window, WM_GETFONT, 0, 0));
}



HRESULT
Win::GetWindowPlacement(HWND window, WINDOWPLACEMENT& placement)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   memset(&placement, 0, sizeof(WINDOWPLACEMENT));
   placement.length = sizeof(WINDOWPLACEMENT);

   BOOL succeeded = ::GetWindowPlacement(window, &placement);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetWindowRect(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   memset(&rect, 0, sizeof(RECT));

   BOOL succeeded = ::GetWindowRect(window, &rect);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetWindowsDirectory()
{
   wchar_t buf[MAX_PATH + 1];
   memset(buf, 0, sizeof(wchar_t) * (MAX_PATH + 1));

   UINT result = ::GetWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   return String(buf);
}



HRESULT
Win::GetWindowLong(HWND window, int index, LONG& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;

   ::SetLastError(NO_ERROR);

   result = ::GetWindowLongW(window, index);
   if (!result)
   {
      // in the event that the value extracted really is 0, this will
      // return NO_ERROR, which equals S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetWindowLongPtr(HWND window, int index, LONG_PTR& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;
      
   ::SetLastError(NO_ERROR);

   result = ::GetWindowLongPtrW(window, index);
   if (!result)
   {
      // in the event that the value extracted really is 0, this will
      // return NO_ERROR, which equals S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetWindowText(HWND window)
{
   ASSERT(Win::IsWindow(window));

   size_t length = ::GetWindowTextLength(window);
   if (length == 0)
   {
      return String();
   }

   String s(length + 1, 0);
   size_t result =
      ::GetWindowText(
         window,
         const_cast<wchar_t*>(s.c_str()),
         static_cast<int>(length + 1));
   ASSERT(result == length);
   if (!result)
   {
      return String();
   }
   s.resize(result);
   return s;
}



HRESULT
Win::GlobalAlloc(UINT flags, size_t bytes, HGLOBAL& result)
{
   ASSERT(flags);
   ASSERT(bytes);

   result = 0;

   HRESULT hr = S_OK;

   result = ::GlobalAlloc(flags, bytes);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalFree(HGLOBAL mem)
{
   ASSERT(mem);

   HRESULT hr = S_OK;

   HGLOBAL result = ::GlobalFree(mem);

   // note that success == null

   if (result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalLock(HGLOBAL mem, PVOID& result)
{
   ASSERT(mem);

   result = 0;

   HRESULT hr = S_OK;

   result = ::GlobalLock(mem);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalUnlock(HGLOBAL mem)
{
   ASSERT(mem);

   HRESULT hr = S_OK;

   BOOL succeeded = ::GlobalUnlock(mem);
   if (!succeeded)
   {
      // if there was no error, then this will be S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



void
Win::HtmlHelp(
   HWND           caller,
   const String&  file,
   UINT           command,
   DWORD_PTR      data)
{
   ASSERT(Win::IsWindow(caller));
   ASSERT(!file.empty());

   (void) ::HtmlHelpW(caller, file.c_str(), command, data);

   // This return value is not a reliable indicator of success or failure,
   // as according to the docs, what's returned depends on the command.
   // 
}


int
Win::ImageList_Add(HIMAGELIST list, HBITMAP image, HBITMAP mask)
{
   ASSERT(list);
   ASSERT(image);

   int result = ::ImageList_Add(list, image, mask);
   ASSERT(result != -1);

   return result;
}

int
Win::ImageList_AddIcon(HIMAGELIST hlist, HICON hicon)
{
   ASSERT(hlist);
   ASSERT(hicon);

   int result = ::ImageList_ReplaceIcon(hlist, -1, hicon);
   ASSERT(result != -1);

   return result;
}

int
Win::ImageList_AddMasked(HIMAGELIST list, HBITMAP bitmap, COLORREF mask)
{
   ASSERT(list);
   ASSERT(bitmap);

   int result = ::ImageList_AddMasked(list, bitmap, mask);

   ASSERT(result != -1);

   return result;
}


HIMAGELIST
Win::ImageList_Create(
   int      pixelsx, 	
   int      pixelsy, 	
   UINT     flags, 	
   int      initialSize, 	
   int      reserve)
{
   ASSERT(pixelsy == pixelsx);
   ASSERT(initialSize);

   HIMAGELIST result =
      ::ImageList_Create(pixelsx, pixelsy, flags, initialSize, reserve);
   ASSERT(result);

   return result;
}



LONG
Win::InterlockedDecrement(LONG& addend)
{
   return ::InterlockedDecrement(&addend);
}



LONG
Win::InterlockedIncrement(LONG& addend)
{
   return ::InterlockedIncrement(&addend);
}



bool
Win::IsDlgButtonChecked(HWND parentDialog, int buttonResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(buttonResID > 0);

   if (
      ::IsDlgButtonChecked(
         parentDialog,
         buttonResID) == BST_CHECKED)
   {
      return true;
   }

   return false;
}



bool
Win::IsWindow(HWND candidate)
{
   return ::IsWindow(candidate) ? true : false;
}



bool
Win::IsWindowEnabled(HWND window)
{
   ASSERT(Win::IsWindow(window));

   return ::IsWindowEnabled(window) ? true : false;
}



int
Win::ListBox_AddString(HWND box, const String& s)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(!s.empty());

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_ADDSTRING,
               0,
               reinterpret_cast<LPARAM>(s.c_str()))));

   ASSERT(result != LB_ERR);
   ASSERT(result != LB_ERRSPACE);

   return result;
}


int 
Win::ListBox_SetItemData(HWND box, int index, LPARAM value)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_SETITEMDATA,
               index,
               value)));
   
   ASSERT(result != LB_ERR);

   return result;
}

int 
Win::ListBox_SetCurSel(HWND box, int index)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_SETCURSEL,
               index,
               0)));
   
   ASSERT(result != LB_ERR);

   return result;
}

int 
Win::ListBox_GetCurSel(HWND box)
{
   ASSERT(Win::IsWindow(box));

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_GETCURSEL,
               0,
               0)));
   
   // Don't assert that result != LB_ERR because
   // it is LB_ERR if nothing is selected which
   // may be correct for some uses

   return result;
}

LPARAM 
Win::ListBox_GetItemData(HWND box, int index)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   LPARAM result =
      static_cast<LPARAM>(
         Win::SendMessage(
            box,
            LB_GETITEMDATA,
            index,
            0));
   
   ASSERT(result != LB_ERR);

   return result;
}


bool
Win::ListView_DeleteItem(HWND listview, int item)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(item >= 0);

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            listview,
            LVM_DELETEITEM,
            static_cast<WPARAM>(item),
            0));

   ASSERT(result);

   return result ? true : false;
}



bool
Win::ListView_GetItem(HWND listview, LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      static_cast<BOOL>(
            Win::SendMessage(
            listview,
            LVM_GETITEM,
            0,
            reinterpret_cast<LPARAM>(&item)));

   // You shouldn't ask for items that don't exist!

   ASSERT(result);

   return result ? true : false;
}



int
Win::ListView_GetItemCount(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(Win::SendMessage(listview, LVM_GETITEMCOUNT, 0, 0));

   ASSERT(result >= 0);

   return result;
}



UINT
Win::ListView_GetItemState(HWND listview, int index, UINT mask)
{
   ASSERT(Win::IsWindow(listview));

   return (UINT) Win::SendMessage(listview, LVM_GETITEMSTATE, index, mask);
}



int
Win::ListView_GetSelectedCount(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result = (int) Win::SendMessage(listview, LVM_GETSELECTEDCOUNT, 0, 0);

   return result;
}



int
Win::ListView_GetSelectionMark(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(listview, LVM_GETSELECTIONMARK, 0, 0));

   return result;
}



int
Win::ListView_InsertColumn(HWND listview, int index, const LVCOLUMN& column)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(
            listview,
            LVM_INSERTCOLUMN,
            static_cast<WPARAM>(index),
            reinterpret_cast<LPARAM>(&column)));
   ASSERT(result != -1);

   return result;
}



int
Win::ListView_InsertItem(HWND listview, const LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(
            listview,
            LVM_INSERTITEM,
            0,
            reinterpret_cast<LPARAM>(&item)));
   ASSERT(result != -1);

   return result;
}



HIMAGELIST
Win::ListView_SetImageList(HWND listview, HIMAGELIST images, int type)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(images);
   ASSERT(
         type == LVSIL_NORMAL
      || type == LVSIL_SMALL
      || type == LVSIL_STATE);

   HIMAGELIST result =
      (HIMAGELIST) Win::SendMessage(
         listview,
         LVM_SETIMAGELIST,
         static_cast<WPARAM>(type),
         (LPARAM) images);

   // can't assert result: if this is the first time the image list has been
   // set, the return value is the same as the error value!

   return result;
}



void
Win::ListView_SetItem(HWND listview, const LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      (BOOL) Win::SendMessage(
         listview,
         LVM_SETITEM,
         0,
         (LPARAM) &item);
   ASSERT(result);
}

void
Win::ListView_SetItemText(HWND listview, int item, int subItem, const String& text)
{
   ASSERT(Win::IsWindow(listview));

   LVITEM lvitem;
   ZeroMemory(&lvitem, sizeof(LVITEM));

   lvitem.iSubItem = subItem;
   lvitem.mask = LVIF_TEXT;
   lvitem.pszText = const_cast<wchar_t*>(text.c_str());

   BOOL result =
      (BOOL) Win::SendMessage(
         listview,
         LVM_SETITEMTEXT,
         item,
         (LPARAM) &lvitem);
   ASSERT(result);
}

// needs to support TCHAR* because of that MAKEINTRESOURCE junk.

HRESULT
Win::LoadBitmap(unsigned resId, HBITMAP& result)
{
   ASSERT(resId);

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadBitmap(GetResourceModuleHandle(), MAKEINTRESOURCE(resId));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadCursor(const String& cursorName, HCURSOR& result)
{
   return Win::LoadCursor(cursorName.c_str(), result, false);
}



// provided for MAKEINTRESOURCE versions of cursorName
// CODEWORK: result should be the final parameter

HRESULT
Win::LoadCursor(
   const TCHAR*   cursorName,
   HCURSOR&       result,
   bool           isSystemCursor)
{
   result = 0;

   HRESULT hr = S_OK;

   result =
      ::LoadCursor(
         isSystemCursor ? 0 : GetResourceModuleHandle(),
         cursorName);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadIcon(int resID, HICON& result)
{
   ASSERT(resID);

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadIcon(GetResourceModuleHandle(), MAKEINTRESOURCE(resID));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, unsigned type, HANDLE& result)
{
   ASSERT(resID);
   ASSERT(type == IMAGE_BITMAP || type == IMAGE_CURSOR || type == IMAGE_ICON);

   result = 0;

   HRESULT hr = S_OK;

   result =
      ::LoadImage(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         type,
         0,
         0,

         // do NOT pass LR_DEFAULTSIZE here, so we get the actual size of
         // the resource.
         LR_DEFAULTCOLOR);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, HICON& result)
{
   result = 0;
   HANDLE h = 0;
   HRESULT hr = Win::LoadImage(resID, IMAGE_ICON, h);
   if (SUCCEEDED(hr))
   {
      result = reinterpret_cast<HICON>(h);
   }

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, HBITMAP& result)
{
   result = 0;
   HANDLE h = 0;
   HRESULT hr = Win::LoadImage(resID, IMAGE_BITMAP, h);
   if (SUCCEEDED(hr))
   {
      result = reinterpret_cast<HBITMAP>(h);
   }

   return hr;
}



HRESULT
Win::LoadLibrary(const String& libFileName, HINSTANCE& result)
{
   ASSERT(!libFileName.empty());

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadLibrary(libFileName.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadLibraryEx(
   const String&  libFileName,
   DWORD          flags,
   HINSTANCE&     result)
{
   ASSERT(!libFileName.empty());

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadLibraryEx(libFileName.c_str(), 0, flags);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadMenu(unsigned resID, HMENU& result)
{
   ASSERT(resID);

   HRESULT hr = S_OK;
   result = ::LoadMenu(GetResourceModuleHandle(), MAKEINTRESOURCEW(resID));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}
      


String
Win::LoadString(unsigned resID)
{
   return String::load(resID);
}



String
Win::LoadString(unsigned resID, HINSTANCE hInstance)
{
   return String::load(resID, hInstance);
}



HRESULT
Win::LocalFree(HLOCAL mem)
{
   HRESULT hr = S_OK;
      
   HLOCAL result = ::LocalFree(mem);
   if (result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



// moved to Win namespace, as it is used in that namespace

bool
Win::IsLocalComputer(const String& computerName)
{
   ASSERT(!computerName.empty());

   String netbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);

   if (computerName.icompare(netbiosName) == 0)
   {
      return true;
   }
   
   String dnsName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

   if (computerName.icompare(dnsName) == 0)
   {
      return true;
   }

   return false;
}



HRESULT
Win::LookupAccountSid(
   const String&  machineName,
   PSID           sid,
   String&        accountName,
   String&        domainName)
{
   ASSERT(sid);

   accountName.erase();
   domainName.erase();

   TCHAR* boxName = const_cast<wchar_t*>(machineName.c_str());
   if (machineName.empty() || Win::IsLocalComputer(machineName))
   {
      // local machine
      boxName = 0;
   }

   // Make the first call to determine the sizes of required buffers

   DWORD nameSize = 0;
   DWORD domainSize = 0;
   SID_NAME_USE use = SidTypeUnknown;

   if (
      !::LookupAccountSid(
         boxName,
         sid,
         0,
         &nameSize,
         0,
         &domainSize,
         &use))
   {
      // failed, but this is ok as long as the error is not
      // ERROR_NONE_MAPPED

      DWORD err = ::GetLastError();
      ASSERT(err != ERROR_NONE_MAPPED);
      ASSERT(err == ERROR_INSUFFICIENT_BUFFER);

      if (err == ERROR_NONE_MAPPED)
      {
         return Win32ToHresult(err);
      }
   }

   ASSERT(nameSize);
   ASSERT(domainSize);

   HRESULT hr = S_OK;
   TCHAR* an = new TCHAR[nameSize + 1];
   TCHAR* dn = new TCHAR[domainSize + 1];
   memset(an, 0, sizeof(TCHAR) * (nameSize + 1));
   memset(dn, 0, sizeof(TCHAR) * (domainSize + 1));

   if (
      ::LookupAccountSid(
         boxName,
         sid,
         an,
         &nameSize,
         dn,
         &domainSize,
         &use))
   {
      accountName = an;
      domainName = dn;
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   delete[] an;
   delete[] dn;

   return hr;
}



HRESULT
Win::LookupPrivilegeValue(
   const TCHAR* systemName,
   const TCHAR* privName,
   LUID& luid)
{
   // systemName may be 0
   ASSERT(privName && privName[0]);

   memset(&luid, 0, sizeof(LUID));

   HRESULT hr = S_OK;

   BOOL succeeded = ::LookupPrivilegeValueW(systemName, privName, &luid);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



int
Win::MessageBox(
   HWND           owner,
   const String&  text,
   const String&  title,
   UINT           flags)
{
   ASSERT(owner == 0 || Win::IsWindow(owner));
   ASSERT(!text.empty());

   // don't assert flags, MB_OK == 0

   const TCHAR* t = title.empty() ? 0 : title.c_str();

   LOG(String::format(L"MessageBox: %1 : %2", t, text.c_str()));

   int result = ::MessageBox(owner, text.c_str(), t, flags);
   ASSERT(result);

   return result;
}



HRESULT
Win::MoveFileEx(
   const String& srcPath,
   const String& dstPath,
   DWORD         flags)
{
   ASSERT(!srcPath.empty());
   ASSERT(!dstPath.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::MoveFileEx(srcPath.c_str(), dstPath.c_str(), flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::MoveWindow(
   HWND  window,
   int   x,
   int   y,
   int   width,
   int   height,
   bool  shouldRepaint)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::MoveWindow(window, x, y, width, height, shouldRepaint ? TRUE : FALSE);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::OpenProcessToken(
   HANDLE   processHandle,
   DWORD    desiredAccess,
   HANDLE&  tokenHandle)
{
   ASSERT(processHandle);

   tokenHandle = 0;

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::OpenProcessToken(processHandle, desiredAccess, &tokenHandle);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::OpenSCManager(
   const String&  machine,
   DWORD          desiredAccess,
   SC_HANDLE&     result)
{
   LOG_FUNCTION2(Win::OpenSCManager, machine);

   HRESULT hr = S_OK;
   PCWSTR m = machine.empty() ? 0 : machine.c_str();   

   result = ::OpenSCManager(m, 0, desiredAccess);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure could be due to access denied, etc.

   return hr;
}



HRESULT
Win::OpenService(
   SC_HANDLE      managerHandle,
   const String&  serviceName,
   DWORD          desiredAccess,
   SC_HANDLE&     result)
{
   LOG_FUNCTION2(Win::OpenService, serviceName);
   ASSERT(managerHandle);
   ASSERT(!serviceName.empty());

   HRESULT hr = S_OK;

   result = ::OpenService(managerHandle, serviceName.c_str(), desiredAccess);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure could be due to access denied, etc.

   return hr;
}



void
Win::OutputDebugString(const String& str)
{
   ASSERT(!str.empty());

   ::OutputDebugString(str.c_str());
}



HRESULT
Win::PostMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = ::PostMessage(window, msg, wParam, lParam);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::PropertySheet(PROPSHEETHEADER* header, INT_PTR& result)
{
   ASSERT(header);

   result = 0;

   HRESULT hr = S_OK;

   result = ::PropertySheetW(header);
   if (result == -1)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::PropSheet_Changed(HWND propSheet, HWND page)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(Win::IsWindow(page));

   Win::SendMessage(propSheet, PSM_CHANGED, reinterpret_cast<WPARAM>(page), 0);
}



void
Win::PropSheet_Unchanged(HWND propSheet, HWND page)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(Win::IsWindow(page));

   Win::SendMessage(propSheet, PSM_UNCHANGED, reinterpret_cast<WPARAM>(page), 0);
}



void
Win::PropSheet_RebootSystem(HWND propSheet)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::SendMessage(propSheet, PSM_REBOOTSYSTEM, 0, 0);
}



void
Win::PropSheet_SetTitle(
   HWND propSheet,
   DWORD style,
   const String& title)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::SendMessage(
      propSheet,
      PSM_SETTITLE,
      style,
      reinterpret_cast<LPARAM>(title.c_str()));
}



void
Win::PropSheet_SetWizButtons(HWND propSheet, DWORD buttonFlags)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::PostMessage(
      propSheet,
      PSM_SETWIZBUTTONS,
      0,
      buttonFlags);
}



HRESULT
Win::QueryServiceStatus(
   SC_HANDLE       handle,
   SERVICE_STATUS& status)
{
   ASSERT(handle);

   memset(&status, 0, sizeof(SERVICE_STATUS));

   HRESULT hr = S_OK;

   BOOL succeeded = ::QueryServiceStatus(handle, &status);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ReadFile(
   HANDLE      handle,
   void*       buffer,
   DWORD       bytesToRead,
   DWORD&      bytesRead,
   OVERLAPPED* overlapped)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(bytesToRead);
   ASSERT(buffer);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::ReadFile(handle, buffer, bytesToRead, &bytesRead, overlapped);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success -- there may be any number of normal reasons
   // why this might legitimately fail.

   return hr;
}



HRESULT
Win::RegCloseKey(HKEY hKey)
{
   // don't assert hKey: we support closing a null key.

   HRESULT hr = S_OK;

   if (hKey)
   {
      hr = Win32ToHresult(::RegCloseKey(hKey));
      ASSERT(SUCCEEDED(hr));
   }
   else
   {
      hr = S_FALSE;
   }

   return hr;
}



HRESULT
Win::RegConnectRegistry(
   const String&  machine,
   HKEY           hKey,
   HKEY&          result)
{
   // machine may be empty

   ASSERT(hKey);

   HRESULT hr =
      Win32ToHresult(
         ::RegConnectRegistry(
            machine.empty() ? 0 : machine.c_str(),
            hKey,
            &result));

   // don't assert: it may be normal not to be able to access the remote
   // machine's registry.

   return hr;
}



HRESULT
Win::RegCreateKeyEx(
   HKEY                 hKey,
   const String&        subkeyName,
   DWORD                options,
   REGSAM               access,
   SECURITY_ATTRIBUTES* securityAttrs,
   HKEY&                result,
   DWORD*               disposition)
{
   ASSERT(hKey);
   ASSERT(!subkeyName.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegCreateKeyEx(
            hKey,
            subkeyName.c_str(),
            0,
            0,
            options,
            access,
            securityAttrs,
            &result,
            disposition));

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::RegDeleteValue(
   HKEY          hKey,
   const String& valueName)
{
   ASSERT(hKey);
   ASSERT(!valueName.empty());

   HRESULT hr = Win32ToHresult(::RegDeleteValue(hKey, valueName.c_str()));

   // don't assert the result, the value might not be present

   return hr;
}



HRESULT
Win::RegOpenKeyEx(
   HKEY           hKey,
   const String&  subKey,
   REGSAM         accessDesired,
   HKEY&          result)
{
   ASSERT(hKey);
   ASSERT(!subKey.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegOpenKeyEx(hKey, subKey.c_str(), 0, accessDesired, &result));

   // don't assert the result, the key may not be present...caller may be
   // testing for this state

   return hr;
}



// ptrs are used to allow nulls

HRESULT
Win::RegQueryValueEx(
   HKEY           hKey,
   const String&  valueName,
   DWORD*         type,
   BYTE*          data,
   DWORD*         dataSize)
{
   ASSERT(hKey);
   ASSERT(!valueName.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegQueryValueEx(
            hKey,
            valueName.c_str(),
            0,
            type,
            data,
            dataSize));

   // don't assert the result, the key may not be present...caller may be
   // testing for this state

   return hr;
}



HRESULT
Win::RegSetValueEx(
   HKEY           hKey,
   const String&  valueName,
   DWORD          type,
   const BYTE*    data,
   size_t         dataSize)
{
   ASSERT(hKey);
   ASSERT(dataSize < ULONG_MAX);

   // value may be null.

   HRESULT hr =
      Win32ToHresult(
         ::RegSetValueEx(
            hKey,
            valueName.c_str(),
            0,
            type,
            data,
            static_cast<DWORD>(dataSize)));

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::RegisterClassEx(const WNDCLASSEX& wndclass, ATOM& result)
{
   HRESULT hr = S_OK;

   result = ::RegisterClassEx(&wndclass);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
      
   ASSERT(SUCCEEDED(hr));

   return hr;
}



CLIPFORMAT
Win::RegisterClipboardFormat(const String& name)
{
   ASSERT(!name.empty());

   CLIPFORMAT result = (CLIPFORMAT) ::RegisterClipboardFormat(name.c_str());
   ASSERT(result);

   return result;
}



void
Win::ReleaseDC(HWND window, HDC dc)
{
   ASSERT(window == 0 || Win::IsWindow(window));
   ASSERT(dc && dc != INVALID_HANDLE_VALUE);

   int result = 1;

   if (dc)
   {
      result = ::ReleaseDC(window, dc);
   }

   ASSERT(result);
}



HRESULT
Win::ReleaseMutex(HANDLE mutex)
{
   ASSERT(mutex && mutex != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::ReleaseMutex(mutex);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // releasing a mutex you don't hold is probably a program logic bug.

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::ReleaseStgMedium(STGMEDIUM& medium)
{
   ::ReleaseStgMedium(&medium);
}



HRESULT
Win::RemoveDirectory(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::RemoveDirectory(path.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // Don't assert: failure does not necessarily indicate a program logic
   // error.

   return hr;
}

   
   
HRESULT
Win::ResetEvent(HANDLE event)
{
   ASSERT(event && event != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::ResetEvent(event);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ScreenToClient(HWND window, POINT& point)
{
	ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

	BOOL succeeded = ::ScreenToClient(window, &point);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ScreenToClient(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   // this evil hack takes advantage of the fact that a RECT is the
   // catentation of two points.

   POINT* pt = reinterpret_cast<POINT*>(&rect);

   HRESULT hr = S_OK;

   do
   {
      BOOL succeeded = ::ScreenToClient(window, pt);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      succeeded = ::ScreenToClient(window, pt + 1);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }
   }
   while (0);

   ASSERT(SUCCEEDED(hr));

   return hr;
}

	

HGDIOBJ
Win::SelectObject(HDC hdc, HGDIOBJ hobject)
{
   ASSERT(hdc);
   ASSERT(hobject);
   ASSERT(hdc != INVALID_HANDLE_VALUE);
   ASSERT(hobject != INVALID_HANDLE_VALUE);

   HGDIOBJ result = ::SelectObject(hdc, hobject);

#pragma warning(push)
#pragma warning(disable: 4312)
   
   ASSERT(result != 0 && result != HGDI_ERROR);

#pragma warning(pop)

   return result;
}



LRESULT
Win::SendMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam)
{
   ASSERT(Win::IsWindow(window));

   return ::SendMessage(window, msg, wParam, lParam);
}



HRESULT
Win::SetComputerNameEx(COMPUTER_NAME_FORMAT format, const String& newName)
{
   HRESULT hr = S_OK;

   BOOL result =
      ::SetComputerNameEx(
         format,
         newName.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HCURSOR
Win::SetCursor(HCURSOR newCursor)
{
   return ::SetCursor(newCursor);
}



HRESULT
Win::SetDlgItemText(
   HWND           parentDialog,
   int            itemResID,
   const String&  text)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetDlgItemText(parentDialog, itemResID, text.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetDlgItemText(
   HWND                  parentDialog,
   int                   itemResID,
   const EncodedString&  cypherText)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HRESULT hr = S_OK;

   WCHAR* cleartext = cypherText.GetDecodedCopy();
   
   BOOL succeeded = ::SetDlgItemText(parentDialog, itemResID, cleartext);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ::ZeroMemory(cleartext, sizeof(WCHAR) * cypherText.GetLength());
   delete[] cleartext;
   
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetEvent(HANDLE event)
{
   ASSERT(event && event != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetEvent(event);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetFilePointerEx(
   HANDLE               handle,
   const LARGE_INTEGER& distanceToMove,
   LARGE_INTEGER*       newPosition,
   DWORD                moveMethod)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   if (newPosition)
   {
      memset(newPosition, 0, sizeof(LARGE_INTEGER));
   }

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::SetFilePointerEx(handle, distanceToMove, newPosition, moveMethod);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::SetFocus(HWND window)
{
   ASSERT(Win::IsWindow(window));

   ::SetLastError(0);

   HWND result = ::SetFocus(window);
   if (result == NULL)
   {
      // do MT SetFocus
      HWND focus = ::GetFocus();
      if (focus == NULL)
      {
         // window with focus is in another thread.
         HWND current = ::GetForegroundWindow();
         DWORD thread1 = ::GetWindowThreadProcessId(current, 0);
         DWORD thread2 = ::GetWindowThreadProcessId(window, 0);
         ASSERT(thread1 != thread2);
         BOOL b = ::AttachThreadInput(thread2, thread1, TRUE);
         ASSERT(b);
         result = ::SetFocus(window);
         ASSERT(result);
         b = ::AttachThreadInput(thread2, thread1, FALSE);
         ASSERT(b);
         return result;
      }
   }

//   ASSERT(result);
   return result;
}



bool
Win::SetForegroundWindow(HWND window)
{
   ASSERT(Win::IsWindow(window));

   BOOL result = ::SetForegroundWindow(window);

   // don't assert the result, as the window may not be set to the forground
   // under "normal" circumstances.

   return result ? true : false;
}
      


void
Win::SetWindowFont(HWND window, HFONT font, bool redraw)
{
   ASSERT(Win::IsWindow(window));
   ASSERT(font);

   BOOL r = redraw ? 1 : 0;
   Win::SendMessage(
      window,
      WM_SETFONT,
      reinterpret_cast<WPARAM>(font),
      static_cast<LPARAM>(r) );
}



HRESULT
Win::SetWindowLong(
   HWND  window,  
   int   index,   
   LONG  value,   
   LONG* oldValue)
{
   ASSERT(Win::IsWindow(window));

   if (oldValue)
   {
      *oldValue = 0;
   }

   HRESULT hr = S_OK;

   // need to clear this as the prior value may have been 0.

   ::SetLastError(0);

   LONG result = ::SetWindowLongW(window, index, value);

   if (!result)
   {
      // maybe the previous value was zero, or maybe an error occurred.  If
      // the prior value really was zero, then this will leave hr == S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   if (oldValue)
   {
      *oldValue = result;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowLongPtr(
   HWND      window,   
   int       index,    
   LONG_PTR  value,    
   LONG_PTR* oldValue)
{
   ASSERT(Win::IsWindow(window));

   if (oldValue)
   {
      *oldValue = 0;
   }

   HRESULT hr = S_OK;

   // need to clear this as the prior value may have been 0.

   ::SetLastError(0);

   LONG_PTR result = ::SetWindowLongPtrW(window, index, value);
   if (!result)
   {
      // maybe the previous value was zero, or maybe an error occurred.  If
      // the prior value really was zero, then this will leave hr == S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   if (oldValue)
   {
      *oldValue = result;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowText(HWND window, const String& text)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetWindowText(window, text.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



LPITEMIDLIST
Win::SHBrowseForFolder(BROWSEINFO& bi)
{
   return ::SHBrowseForFolder(&bi);
}



HRESULT
Win::SHGetMalloc(LPMALLOC& pMalloc)
{
   pMalloc = 0;
   HRESULT hr = ::SHGetMalloc(&pMalloc);

   ASSERT(SUCCEEDED(hr));

   if (FAILED(hr))
   {
      pMalloc = 0;
   }

   return hr;
}



String
Win::SHGetPathFromIDList(LPCITEMIDLIST pidl)
{
   wchar_t buf[MAX_PATH];

   BOOL result = ::SHGetPathFromIDList(pidl, buf);

   // don't assert, list could be empty

   if (!result)
   {
      *buf = 0;
   }

   return String(buf);
}



HRESULT
Win::SHGetSpecialFolderLocation(
    HWND          hwndOwner, 	
    int           nFolder, 	
    LPITEMIDLIST& pidl)
{
   ASSERT(Win::IsWindow(hwndOwner));

   pidl = 0;
   HRESULT hr =
      ::SHGetSpecialFolderLocation(
         hwndOwner,
         nFolder,
         &pidl);

   ASSERT(SUCCEEDED(hr));

   if (FAILED(hr))
   {
      pidl = 0;
   }

   return hr;
}



void
Win::ShowWindow(HWND window, int swOption)
{
   ASSERT(Win::IsWindow(window));

   // the return value is of no use.
   ::ShowWindow(window, swOption);
}



void
Win::Spin_GetRange(HWND spinControl, int* low, int* high)
{
   ASSERT(Win::IsWindow(spinControl));

   Win::SendMessage(
      spinControl,
      UDM_GETRANGE32,
      reinterpret_cast<WPARAM>(low),
      reinterpret_cast<LPARAM>(high));

   return;
}



void
Win::Spin_SetRange(HWND spinControl, int low, int high)
{
   ASSERT(Win::IsWindow(spinControl));

   Win::SendMessage(
      spinControl,
      UDM_SETRANGE32,
      static_cast<WPARAM>(low),
      static_cast<LPARAM>(high));

   return;
}



int
Win::Spin_GetPosition(HWND spinControl)
{
   ASSERT(Win::IsWindow(spinControl));

   LRESULT result = Win::SendMessage(spinControl, UDM_GETPOS, 0, 0);

   // according to the docs, the high order word is non-zero on error.  But
   // how can this be if the range is 32 bits?

   ASSERT(!HIWORD(result));

   // we are truncating the 32 bit value.

   return LOWORD(result);
}



void
Win::Spin_SetPosition(HWND spinControl, int position)
{
   ASSERT(Win::IsWindow(spinControl));

#ifdef DBG
   // first, get the range and test that it encompasses the new range

   int low = 0;
   int high = 0;
   Win::Spin_GetRange(spinControl, &low, &high);
   ASSERT(low <= position && position <= high);
#endif

   Win::SendMessage(
      spinControl,
      UDM_SETPOS,
      0,
      static_cast<LPARAM>(position));
}



void
Win::Static_SetIcon(HWND staticText, HICON icon)
{
   ASSERT(Win::IsWindow(staticText));
   ASSERT(icon);
   ASSERT(icon != INVALID_HANDLE_VALUE);

   Win::SendMessage(
      staticText,
      STM_SETICON,
      reinterpret_cast<WPARAM>(icon),
      0);
}



String
Win::StringFromCLSID(const CLSID& clsID)
{
	LPOLESTR ole = 0;
   String retval;

	HRESULT hr = ::StringFromCLSID(clsID, &ole);

	ASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
   {
      retval = ole;
   	::CoTaskMemFree(ole);
   }

   return retval;
}



String
Win::StringFromGUID2(const GUID& guid)
{
   static const size_t GUID_LEN = 39;   // includes null
	String retval(GUID_LEN, 0);
   int result =
      ::StringFromGUID2(
         guid,
         const_cast<wchar_t*>(retval.c_str()),
         GUID_LEN);
   ASSERT(result);
   retval.resize(GUID_LEN - 1);

   return retval;
}



HRESULT
Win::SystemParametersInfo(
   UINT  action,
   UINT  param,
   void* vParam,
   UINT  winIni)
{
   // this API is so ambiguous that no parameters can be
   // reasonably asserted.

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::SystemParametersInfo(action, param, vParam, winIni);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::TlsAlloc(DWORD& result)
{
   HRESULT hr = S_OK;
   result = ::TlsAlloc();
   if (result == static_cast<DWORD>(-1))
   {
      hr = Win::GetLastErrorAsHresult();
      ASSERT(false);
   }

   return hr;
}



HRESULT
Win::TlsFree(DWORD index)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   HRESULT hr = S_OK;
   BOOL result = ::TlsFree(index);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(result);

   return hr;
}



HRESULT
Win::TlsGetValue(DWORD index, PVOID& result)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   result = ::TlsGetValue(index);

   return Win::GetLastErrorAsHresult();
}



HRESULT
Win::TlsSetValue(DWORD index, PVOID value)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   HRESULT hr = S_OK;

   BOOL result = ::TlsSetValue(index, value);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(result);

   return hr;
}



HRESULT
Win::UnregisterClass(const String& classname, HINSTANCE module)
{
   ASSERT(!classname.empty());
   ASSERT(module);

   HRESULT hr = S_OK;

   BOOL succeeded = ::UnregisterClass(classname.c_str(), module);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::UpdateWindow(HWND winder)
{
   ASSERT(Win::IsWindow(winder));

   HRESULT hr = S_OK;

   BOOL succeeded = ::UpdateWindow(winder);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WaitForSingleObject(
   HANDLE   object,       
   unsigned timeoutMillis,
   DWORD&   result)       
{
   ASSERT(object && object != INVALID_HANDLE_VALUE);

   result = WAIT_FAILED;

   HRESULT hr = S_OK;

   result = ::WaitForSingleObject(object, timeoutMillis);
   if (result == WAIT_FAILED)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WideCharToMultiByte(
   DWORD          flags,
   const String&  str,
   char*          buffer,
   size_t         bufferSize,
   size_t&        result)
{
   ASSERT(!str.empty());

   result = 0;

   HRESULT hr = S_OK;

   int r =
      ::WideCharToMultiByte(
         CP_ACP,
         flags,
         str.c_str(),
         static_cast<int>(str.length()),
         buffer,
         static_cast<int>(bufferSize),
         0,
         0);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   result = static_cast<size_t>(r);

   return hr;
}



HRESULT
Win::WinHelp(
   HWND           window,
   const String&  helpFileName,
   UINT           command,
   ULONG_PTR      data)
{
   ASSERT(Win::IsWindow(window));
   ASSERT(!helpFileName.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::WinHelp(window, helpFileName.c_str(), command, data);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WriteFile(
   HANDLE      handle,
   const void* buffer,
   DWORD       numberOfBytesToWrite,
   DWORD*      numberOfBytesWritten)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(buffer);
   ASSERT(numberOfBytesToWrite);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::WriteFile(
         handle,
         buffer,
         numberOfBytesToWrite,
         numberOfBytesWritten,
         0);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WritePrivateProfileString(
   const String& section,
   const String& key,
   const String& value,
   const String& filename)
{
   ASSERT(!section.empty());
   ASSERT(!key.empty());
   ASSERT(!filename.empty());

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::WritePrivateProfileString(
         section.c_str(),
         key.c_str(),
         value.c_str(),
         filename.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::InitializeSecurityDescriptor(SECURITY_DESCRIPTOR& sd)
{
   HRESULT hr = S_OK;

   memset(&sd, 0, sizeof(SECURITY_DESCRIPTOR));

   if (!::InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::SetSecurityDescriptorDacl(
   SECURITY_DESCRIPTOR& sd,
   bool                 daclPresent,
   ACL*                 dacl,             // ptr not ref to allow null dacl
   bool                 daclDefaulted)
{
   HRESULT hr = S_OK;

   if (
      !::SetSecurityDescriptorDacl(
         &sd,
         daclPresent ? TRUE : FALSE,
         dacl,
         daclDefaulted ? TRUE : FALSE) )
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateNamedPipe(
   const String&        name,
   DWORD                openMode,
   DWORD                pipeMode,
   DWORD                maxInstances,
   DWORD                outBufferSizeInBytes,
   DWORD                inBufferSizeInBytes,
   DWORD                defaultTimeout,
   SECURITY_ATTRIBUTES* sa,
   HANDLE&              result)
{
   ASSERT(!name.empty());
   ASSERT(maxInstances and maxInstances < PIPE_UNLIMITED_INSTANCES);

   HRESULT hr = S_OK;

   result =
      ::CreateNamedPipe(
         name.c_str(),
         openMode,
         pipeMode,
         maxInstances,
         outBufferSizeInBytes,
         inBufferSizeInBytes,
         defaultTimeout,
         sa);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::ConnectNamedPipe(
   HANDLE      pipe,
   OVERLAPPED* overlapped)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   // overlapped may be null

   HRESULT hr = S_OK;

   if (!::ConnectNamedPipe(pipe, overlapped))
   {
      // client may already connected, in which case the call might fail
      // with ERROR_PIPE_CONNECTED.  We consider that a successful connect.

      hr = Win::GetLastErrorAsHresult();
      if (hr == Win32ToHresult(ERROR_PIPE_CONNECTED))
      {
         hr = S_OK;
      }
   }

   return hr;
}



HRESULT
Win::PeekNamedPipe(
   HANDLE pipe,                     
   void*  buffer,                   
   DWORD  bufferSize,               
   DWORD* bytesRead,                
   DWORD* bytesAvailable,           
   DWORD* bytesRemainingThisMessage)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   // all other params may be null

   HRESULT hr = S_OK;

   if (
      !::PeekNamedPipe(
         pipe,
         buffer,
         bufferSize,
         bytesRead,
         bytesAvailable,
         bytesRemainingThisMessage) )
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::DisconnectNamedPipe(HANDLE pipe)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   if (!::DisconnectNamedPipe(pipe))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowPos(
   HWND  window,
   HWND  insertAfter,
   int   x,
   int   y,
   int   width,
   int   height,
   UINT  flags)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   if (!::SetWindowPos(window, insertAfter, x, y, width, height, flags))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::MapWindowPoints(
   HWND  from,
   HWND  to,
   RECT& rect,
   int*  dh,      // number of pixels added to horizontal coord
   int*  dv)      // number of pixels added to vertical coord
{
   // either from or to may be null

   HRESULT hr = S_OK;

   if (dh)
   {
      *dh = 0;
   }
   if (dv)
   {
      *dv = 0;
   }

   int result =
      ::MapWindowPoints(
         from,
         to,
         reinterpret_cast<PPOINT>(&rect),
         2);

   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else
   {
      if (dh)
      {
         *dh = LOWORD(result);
      }
      if (dv)
      {
         *dv = HIWORD(result);
      }
   }

   return hr;
}



bool
Win::ToolTip_AddTool(HWND toolTip, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_ADDTOOL,
            0,
            reinterpret_cast<LPARAM>(&info)));

   ASSERT(result);
            
   return result ? true : false;
}
   


bool
Win::ToolTip_GetToolInfo(HWND toolTip, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_GETTOOLINFO,
            0,
            reinterpret_cast<LPARAM>(&info)));

   ASSERT(result);
            
   return result ? true : false;
}


   
bool
Win::ToolTip_SetTitle(HWND toolTip, int icon, const String& title)
{
   ASSERT(Win::IsWindow(toolTip));
   ASSERT(!title.empty());

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_SETTITLE,
            icon,
            reinterpret_cast<LPARAM>(title.c_str())));

   ASSERT(result);

   return result ? true : false;
}



void
Win::ToolTip_TrackActivate(HWND toolTip, bool activate, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   Win::SendMessage(
      toolTip,
      TTM_TRACKACTIVATE,
      activate ? TRUE : FALSE,
      reinterpret_cast<LPARAM>(&info));
}



void
Win::ToolTip_TrackPosition(HWND toolTip, int xPos, int yPos)
{
   ASSERT(Win::IsWindow(toolTip));

   Win::SendMessage(
      toolTip,
      TTM_TRACKPOSITION,
      0,
      static_cast<LPARAM>(MAKELONG(xPos, yPos)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\winerror.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// subclass of Error that understands Win32 error codes.  See
// winerror.h, lmerr.h in the Win32 SDK.
// 
// 8-14-97 sburns



#include "headers.hxx"



Win::Error::Error(HRESULT hr_, const String& message_, const String& summary_)
   :
   ::Error(),
   hr(hr_),
   message(message_),
   summary(summary_),
   summaryResId(0)
{
   ASSERT(!message.empty());
   ASSERT(!summary.empty());
}
   


Win::Error::Error(HRESULT hr_, int summaryResID)
   :
   ::Error(),
   hr(hr_),
   message(),
   summary(),
   summaryResId(summaryResID)
{
}



HRESULT
Win::Error::GetHresult() const
{
   return hr;
}



HelpContext
Win::Error::GetHelpContext() const
{
   return static_cast<HelpContext>(hr);
}

   

String
Win::Error::GetMessage() const
{
   if (message.empty() && hr)
   {
      message = GetErrorMessage(hr);
   }

   return message;
}



String
Win::Error::GetSummary() const
{
   if (summary.empty() && summaryResId)
   {
      summary = String::load(summaryResId);
   }

   return summary;
}



const Win::Error&
Win::Error::operator=(const Win::Error& rhs)
{
   if (&rhs != this)
   {
      message      = rhs.message;     
      summary      = rhs.summary;     
      hr           = rhs.hr;          
      summaryResId = rhs.summaryResId;
   }

   return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\wizpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#include "headers.hxx"



static const DWORD HELP_MAP[] =
{
   0, 0
};



WizardPage::WizardPage(
   unsigned dialogResID,
   unsigned titleResID,
   unsigned subtitleResID,   
   bool     isInteriorPage,
   bool     enableHelp)
   :
   PropertyPage(dialogResID, HELP_MAP, false),
   hasHelp(enableHelp),
   isInterior(isInteriorPage),
   titleResId(titleResID),
   subtitleResId(subtitleResID),
   wizard(0)
{
//   LOG_CTOR(WizardPage);
}



WizardPage::~WizardPage()
{
//   LOG_DTOR(WizardPage);

   wizard = 0;
}



Wizard&
WizardPage::GetWizard() const
{
   ASSERT(wizard);

   return *wizard;
}



HPROPSHEETPAGE
WizardPage::Create()
{
//   LOG_FUNCTION(WizardPage::Create);
   ASSERT(wizard);

   String title = String::load(titleResId);
   String subtitle = String::load(subtitleResId);

   PROPSHEETPAGE page;
   memset(&page, 0, sizeof(page));
      
   page.dwSize       = sizeof(page);
   page.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK | PSP_USETITLE;
   if (isInterior)
   {
      page.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
   }
   else
   {
      page.dwFlags |= PSP_HIDEHEADER;
   }

   if (hasHelp)
   {
      page.dwFlags |= PSP_HASHELP;
   }

   page.hInstance          = GetResourceModuleHandle();
   page.pszTemplate        = MAKEINTRESOURCE(GetResID());
   page.pfnDlgProc         = PropertyPage::propPageDialogProc;
   page.pfnCallback        = PropertyPage::PropSheetPageCallback;
   page.pszHeaderTitle     = title.c_str();
   page.pszHeaderSubTitle  = subtitle.c_str();

   // this pointer is retrieved by the dialog proc 
   page.lParam             = reinterpret_cast<LPARAM>(this);

   HPROPSHEETPAGE result = 0;
   HRESULT hr = Win::CreatePropertySheetPage(page, result);
   ASSERT(SUCCEEDED(hr));

   return result;
}



bool
WizardPage::OnWizBack()
{
//   LOG_FUNCTION(WizardPage::OnWizBack);

   GetWizard().Backtrack(hwnd);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-computer.cpp ===
// Test Burnslib::Computer



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



const String ARG_COMPUTER(L"c");



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



AnsiString
GetRoleDescription(const Computer& c)
{
   AnsiString role;
   switch (c.GetRole())
   {
      case Computer::STANDALONE_WORKSTATION:
      {
         role = "StandaloneWorkstation";
         break;
      }
      case Computer::MEMBER_WORKSTATION:
      {
         role = "MemberWorkstation";
         break;
      }
      case Computer::STANDALONE_SERVER:
      {
         role = "StandaloneServer";
         break;
      }
      case Computer::MEMBER_SERVER:
      {
         role = "MemberServer";
         break;
      }
      case Computer::PRIMARY_CONTROLLER:
      {
         role = "PrimaryDomainController";
         break;
      }
      case Computer::BACKUP_CONTROLLER:
      {
         role = "BackupDomainController";
         break;
      }
      default:
      {
         role = "unknown";
         break;
      }
   }

   return role;
}



void
DumpComputer(const Computer& c)
{
   std::cout << "NetBIOS Name       : ";    AnsiOutLn(c.GetNetbiosName());
   std::cout << "DNS Name           : ";    AnsiOutLn(c.GetFullDnsName());
   std::cout << "Domain NetBIOS Name: ";    AnsiOutLn(c.GetDomainNetbiosName());
   std::cout << "Domain DNS Name    : ";    AnsiOutLn(c.GetDomainDnsName());
   std::cout << "Domain Forest Name : ";    AnsiOutLn(c.GetForestDnsName());
   std::cout << "Role               : " << GetRoleDescription(c) << std::endl;
   std::cout << (c.IsLocal()             ? "Is" : "Is NOT") << " local computer" << std::endl;
   std::cout << (c.IsJoinedToDomain()    ? "Is" : "Is NOT") << " domain joined" << std::endl;
   std::cout << (c.IsDomainController()  ? "Is" : "Is NOT") << " domain controller" << std::endl;
   std::cout << (c.IsJoinedToWorkgroup() ? "Is" : "Is NOT") << " workgroup joined" << std::endl;
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   // unit test of the Computer object

   //                                   local             remote
   // worksta svc not running          X ok               X err
   // net connection disabled          X ok               X err
   // not joined to domain             X ok               X ok
   // joined to downlevel domain         ok                 ok
   // no networking                    X ok                 err
   // non-tcp/ip networking            X ok                 ok
   // access denied                      possible?        X err
   // named by netbios name            X ok               X ok
   // named by dns name                X ok               X ok
   // named by ip address              X ok               X ok

   ArgMap clmap;
   MapCommandLineArgs(clmap);

   Computer comp(clmap[ARG_COMPUTER]);

   HRESULT hr = comp.Refresh();

   if (SUCCEEDED(hr))
   {
      DumpComputer(comp);
   }
   else
   {
      AnsiOutLn(String::format(L"error 0x%1!08X!", hr));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\wizard.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#include "headers.hxx"



Wizard::Wizard(
   unsigned titleStringResID,
   unsigned banner16BitmapResID,
   unsigned banner256BitmapResID,
   unsigned watermark16BitmapResID,
   unsigned watermark1256BitmapResID)
   :
   banner16ResId(banner16BitmapResID),
   banner256ResId(banner256BitmapResID),
   isBacktracking(false),
   pageIdHistory(),
   pages(),
   titleResId(titleStringResID),
   watermark16ResId(watermark16BitmapResID),
   watermark256ResId(watermark1256BitmapResID)
{
   LOG_CTOR(Wizard);
   ASSERT(titleResId);
   ASSERT(banner16ResId);
   ASSERT(banner256ResId);
   ASSERT(watermark16ResId);
   ASSERT(watermark256ResId);
}



Wizard::~Wizard()
{
   LOG_DTOR(Wizard);

   for (
      PageList::iterator i = pages.begin();
      i != pages.end();
      ++i)
   {
      // we can delete the pages because they were created with the
      // deleteOnRelease flag = false;
      delete *i;
   }
}



void
Wizard::AddPage(WizardPage* page)
{
   LOG_FUNCTION(Wizard::AddPage);
   ASSERT(page);

   if (page)
   {
      pages.push_back(page);
      page->wizard = this;
   }
}



INT_PTR
Wizard::ModalExecute(HWND parentWindow)
{
   LOG_FUNCTION(Wizard::ModalExecute);

   if (!parentWindow)
   {
      parentWindow = Win::GetDesktopWindow();
   }

   // build the array of prop sheet pages.

   size_t pageCount = pages.size();
   HPROPSHEETPAGE* propSheetPages = new HPROPSHEETPAGE[pageCount];
   memset(propSheetPages, 0, sizeof(HPROPSHEETPAGE) * pageCount);

   int j = 0;
   for (
      PageList::iterator i = pages.begin();
      i != pages.end();
      ++i, ++j)
   {
      propSheetPages[j] = (*i)->Create();
   }

   bool deletePages = false;
   INT_PTR result = -1;

   // ensure that the pages were created

   for (size_t k = 0; k < pageCount; ++k)
   {
      if (propSheetPages[k] == 0)
      {
         deletePages = true;
         break;
      }
   }

   if (!deletePages)
   {
      PROPSHEETHEADER header;
      memset(&header, 0, sizeof(header));

      String title = String::load(titleResId);

      header.dwSize           = sizeof(header);                                  
      header.dwFlags          =
            PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
      header.hwndParent       = parentWindow;
      header.hInstance        = GetResourceModuleHandle();
      header.hIcon            = 0;
      header.pszCaption       = title.c_str();
      header.nPages           = static_cast<UINT>(pageCount);
      header.nStartPage       = 0;               
      header.phpage           = propSheetPages;
      header.pfnCallback      = 0;

      int colorDepth = 0;
      HRESULT hr = Win::GetColorDepth(colorDepth);

      ASSERT(SUCCEEDED(hr));

      bool use256ColorBitmaps = colorDepth >= 8;

      header.pszbmWatermark   =
         use256ColorBitmaps
         ? MAKEINTRESOURCEW(watermark256ResId)
         : MAKEINTRESOURCEW(watermark16ResId);
      header.pszbmHeader      =
         use256ColorBitmaps
         ? MAKEINTRESOURCEW(banner256ResId)
         : MAKEINTRESOURCEW(banner16ResId);      

      hr = Win::PropertySheet(&header, result);
      ASSERT(SUCCEEDED(hr));

      if (result == -1)
      {
         deletePages = true;
      }
   }

   if (deletePages)
   {
      // Manually destroy the pages if something failed.  (otherwise,
      // ::PropertySheet will have destroyed them)

      for (size_t i = 0; i < pageCount; i++)
      {
         if (propSheetPages[i])
         {
            HRESULT hr = Win::DestroyPropertySheetPage(propSheetPages[i]);

            ASSERT(SUCCEEDED(hr));
         }
      }
   }

   delete[] propSheetPages;

   return result;
}



void
Wizard::SetNextPageID(HWND wizardPage, int pageResID)
{
   LOG_FUNCTION2(
      Wizard::SetNextPageID,
      String::format(L"id = %1!d!", pageResID));
   ASSERT(Win::IsWindow(wizardPage));

   if (pageResID != -1)
   {
      Dialog* dlg = Dialog::GetInstance(wizardPage);
      ASSERT(dlg);

      if (dlg)
      {
         pageIdHistory.push(dlg->GetResID());
      }
   }

   isBacktracking = false;
   Win::SetWindowLongPtr(wizardPage, DWLP_MSGRESULT, pageResID);
}



void
Wizard::Backtrack(HWND wizardPage)
{
   LOG_FUNCTION(Wizard::Backtrack);
   ASSERT(Win::IsWindow(wizardPage));
   
   isBacktracking = true;
   unsigned topPage = pageIdHistory.top();

   ASSERT(topPage > 0);
   LOG(String::format(L" id = %1!u!", topPage));

   if (pageIdHistory.size())
   {
      pageIdHistory.pop();
   }

   Win::SetWindowLongPtr(
      wizardPage,
      DWLP_MSGRESULT,
      static_cast<LONG_PTR>(topPage));
}



bool
Wizard::IsBacktracking()
{
   return isBacktracking;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-fs-1.cpp ===
// Test miscellaneous FS:: stuff



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-1";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
testGetParentFolder()
{
   LOG_FUNCTION(testGetParentFolder);

   HRESULT hr = S_OK;

   String root = L"e:\\";

   // parent of root folder is the root folder

   AnsiOutLn(FS::GetParentFolder(root));
   ASSERT(FS::GetParentFolder(root) == root);

   // parent of files in root folder is root folder

   String file = root + L"rootfile.ext";

   HANDLE h = INVALID_HANDLE_VALUE;
   hr = FS::CreateFile(file, h);
   Win::CloseHandle(h);

   AnsiOutLn(FS::GetParentFolder(file));
   ASSERT(FS::GetParentFolder(file) == root);

   hr = Win::DeleteFile(file);

   // parent of a folder is a folder

   String folder = root + L"rootdir";

   hr = FS::CreateFolder(folder);

   AnsiOutLn(FS::GetParentFolder(folder));
   ASSERT(FS::GetParentFolder(folder) == root);

   hr = Win::RemoveFolder(folder);

   // parent of a sub folder

   String subfolder = folder + L"\\subfolder";

   AnsiOutLn(FS::GetParentFolder(subfolder));
   ASSERT(FS::GetParentFolder(subfolder) == folder);

   // parent folder of a wildcard spec can be found

   String wild = root + L"*.???";

   AnsiOutLn(FS::GetParentFolder(wild));
   ASSERT(FS::GetParentFolder(wild) == root);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

//    StringVector args;
//    int argc = Win::GetCommandLineArgs(std::back_inserter(args));
// 
//    if (argc < 2)
//    {
//       AnsiOutLn(L"missing filespec - path w/ wildcards to iterate over (non-destructive)");
//       exit(0);
//    }
// 
//    String sourceDir = args[1];
//    AnsiOutLn(sourceDir);

   testGetParentFolder();


   // test that IsParentFolder is not fooled by "c:\a\b\c", "c:\a\b\cde"

   // test that CopyFile, when cancelled, returns an HRESULT that indicates
   // cancellation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-fs-2.cpp ===
// Test miscellaneous FS:: stuff



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-2";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
testIsValidPath(const String& sourceDir)
{
   LOG_FUNCTION(testIsValidPath);

   AnsiOutLn(
      String::format(
         L"%1 %2 a valid path.",
         sourceDir.c_str(),
         FS::IsValidPath(sourceDir) ? L"is" : L"is NOT"));
}



void
testPathExists(const String& sourceDir)
{
   LOG_FUNCTION(testPathExists);

   AnsiOutLn(
      String::format(
         L"%1 %2 exist.",
         sourceDir.c_str(),
         FS::PathExists(sourceDir) ? L"does" : L"does NOT"));
}



void
testGetFileSystemType(const String& sourceDir)
{
   LOG_FUNCTION(testGetFileSystemType);

   typedef
      std::map<
         FS::FSType,
         String,
         std::less<FS::FSType>,
         Burnslib::Heap::Allocator<String> >
      TypeDescMap;

   TypeDescMap tdMap;

   tdMap[FS::FAT]   = L"FAT";  
   tdMap[FS::CDFS]  = L"CDFS"; 
   tdMap[FS::NTFS4] = L"NTFS4";
   tdMap[FS::NTFS5] = L"NTFS5";

   AnsiOutLn(
      String::format(
         L"%1 is on a volume formatted for %2.",
         sourceDir.c_str(),
         tdMap[FS::GetFileSystemType(sourceDir)].c_str()));
}



void
testGetRootFolder(const String& sourceDir)
{
   LOG_FUNCTION(testGetRootFolder);

   AnsiOutLn(
      String::format(
         L"root folder = %1",
         FS::GetRootFolder(sourceDir).c_str()));
}



void
testSplitPath(const String& sourceDir)
{
   LOG_FUNCTION(testSplitPath);

   String drive;
   String folderPath;
   String fileName;
   String extension;

   FS::SplitPath(sourceDir, drive, folderPath, fileName, extension);

   AnsiOutLn(L"SplitPath:");
   AnsiOutLn(L"drive     : " + drive);
   AnsiOutLn(L"folderPath: " + folderPath);
   AnsiOutLn(L"fileName  : " + fileName);
   AnsiOutLn(L"extension : " + extension);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      AnsiOutLn(L"missing filespec - path to validate.  may be UNC or absolute");
      exit(0);
   }

   String sourceDir = args[1];
   AnsiOutLn(sourceDir);
   AnsiOutLn(L"=================");

   testIsValidPath(sourceDir);
   testPathExists(sourceDir);
   testSplitPath(sourceDir);
   testGetRootFolder(sourceDir);
   testGetFileSystemType(sourceDir);


   // test that IsParentFolder is not fooled by "c:\a\b\c", "c:\a\b\cde"

   // test that CopyFile, when cancelled, returns an HRESULT that indicates
   // cancellation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-fs-iterator.cpp ===
// Test FS::Iterator



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
iterate(FS::Iterator& iter)
{
   LOG_FUNCTION(iterate);

   HRESULT hr = S_OK;

   int count = 0;

   String current;

   while ((hr = iter.GetCurrent(current)) == S_OK)
   {
      AnsiOutLn(current);
      count++;

      hr = iter.Increment();
      BREAK_ON_FAILED_HRESULT(hr);
   }

   AnsiOutLn(String::format(L"%1!d!", count));
}
   


void
testIterator1(const String& sourceDir)
{
   LOG_FUNCTION(testIterator1);

   AnsiOutLn(L"test 1: files and directories, no dot paths, relative paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::INCLUDE_FOLDERS);

   iterate(iter);
}



void
testIterator2(const String& sourceDir)
{
   LOG_FUNCTION(testIterator2);

   AnsiOutLn(L"test 1: files and directories, dot paths, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::INCLUDE_FOLDERS
      |  FS::Iterator::INCLUDE_DOT_PATHS
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



void
testIterator3(const String& sourceDir)
{
   LOG_FUNCTION(testIterator3);

   AnsiOutLn(L"test 1: files only, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



void
testIterator4(const String& sourceDir)
{
   LOG_FUNCTION(testIterator4);

   AnsiOutLn(L"test 4: folders only, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FOLDERS
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      AnsiOutLn(L"missing filespec - path w/ wildcards to iterate over (non-destructive)");
      exit(0);
   }

   String sourceDir = args[1];
   AnsiOutLn(sourceDir);

   testIterator1(sourceDir);
   testIterator2(sourceDir);
   testIterator3(sourceDir);
   testIterator4(sourceDir);


   // test that iterator without wildcard includes just the one file or folder,
   // and that if the filter options so indicate, that one is not returned.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-reboot.cpp ===
// test Reboot()



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   Reboot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\burnslib\src\test\test-fs-createfolder.cpp ===
// Test miscellaneous (possibly destuctive) FS:: stuff 



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-3";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
doCannedTests()
{
   LOG_FUNCTION(doCannedTests);

   StringVector paths;

   paths.push_back(L"c:\\temp");
   paths.push_back(L"c:\\temp\\a");
   paths.push_back(L"c:\\temp\\a\\b\\c\\d");
   paths.push_back(L"c:\\temp\\a\\b\\c\\d");

   String server = Win::GetComputerNameEx(ComputerNameNetBIOS);
   String share = L"\\\\" + server + L"\\c$\\temp\\unc\\";

   paths.push_back(share + L"a");
   paths.push_back(share + L"a\\b\\c\\d");
   paths.push_back(share + L"a\\b\\c\\d");

   HRESULT hr = S_OK;
   for (
      StringVector::iterator i = paths.begin();
      i != paths.end();
      ++i)
   {
      AnsiOut(String::format(L"creating %1", i->c_str()));

      hr = FS::CreateFolder(*i);

      AnsiOut(
         String::format(
            L" \t\t%1",
            SUCCEEDED(hr) ? L"succeeded" : L"failed"));

      AnsiOutLn(
         String::format(
            L" \t\t%1",
            FS::PathExists(*i) ? L"exists" : L"absent"));
   }
}


         
void
testCreateFolder(const String& path)
{
   LOG_FUNCTION(testCreateFolder);

   HRESULT hr = FS::CreateFolder(path);
   AnsiOutLn(
      String::format(
         L"CreateFolder(%1) %2.",
         path.c_str(),
         SUCCEEDED(hr) ? L"succeeded" : L"failed"));
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      doCannedTests();
   }
   else
   {
      String sourceDir = args[1];
      AnsiOutLn(sourceDir);
      AnsiOutLn(L"=================");

      testCreateFolder(sourceDir);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\bootcfg.h ===
#ifndef __BOOTINI_H
#define __BOOTINI_H
#endif // __BOOTINI_H




//
// constants / defines / enumerations
//

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

// Error constants
#define ERROR_CONNECT_SERVERNOTFOUND		0xFFFF0001
#define ERROR_CONNECT_LOGINFAIL				0xFFFF0002
#define ERROR_CONNECT_UNKNOWNERROR			0xFFFF0003
#define ERROR_FMT_INVALID_OPTIONVALUE       _T( "ERROR: Invalid value specified for the option '%s'.\n" ) 
#define ERROR_FMT_INVALIDOSENTRY            _T( "ERROR: Invalid OS entry line number specified.\nThere are only '%s' OS keys.\n" )

// Exit values
#define EXIT_SUCCESS                        0
#define EXIT_FAILURE                        1  
#define MALLOC_FAILURE						-1

// Null
#define NULL_STRING							_T( "\0" )
#define NULL_CHAR							_T( '\0' )

#define STRING20  20
#define STRING3 3

#define ON_OFF								_T("ON|OFF")

#define MAX_CMD_LENGTH							4096

// Options
#define CMDOPTION_QUERY						_T( "query" )
#define CMDOPTION_COPY						_T( "copy" )
#define CMDOPTION_DELETE				    _T( "delete" )
#define CMDOPTION_USAGE						_T( "?|h" )
#define CMDOPTION_DEFAULT					_T( "" )
#define CMDOPTION_RAW						_T("raw")
#define CMDOPTION_DEFAULTOS					_T("default")
#define CMDOPTION_TIMEOUT					_T("timeout")
#define CMDOPTION_DEBUG						_T("debug")
#define CMDOPTION_EMS						_T("ems")
#define CMDOPTION_DBG1394						_T("dbg1394")
#define CMDOPTION_ADDSW						_T("addsw")
#define CMDOPTION_RMSW						_T("rmsw")
#define CMDOPTION_APPEND					_T("a")
#define CMDOPTION_MIRROR					_T("mirror")
#define CMDOPTION_CHANNEL					_T("ch")
#define CMDOPTION_LIST						_T("list")
#define CMDOPTION_ADD						_T("add")
#define CMDOPTION_UPDATE					_T("update")



#define CMDOTHEROPTIONS                     _T( "s|server|u|user|p|password|description|descrip|defaultos|basevideo|baudrate|debugport|maxmem|nodebug|crashdebug|noserialmice|sos|redirect" )

#define BAUD_RATE_VALUES_EMS		  _T("9600|19200|57600|115200")
#define BAUD_RATE_VALUES_DEBUG		  _T("9600|19200|38400|57600|115200")

#define COM_PORT_RANGE			  _T("COM1|COM2|COM3|COM4")


#define EMS_PORT_VALUES			  _T("COM1|COM2|COM3|COM4|BIOSSET")				

#define CMDOPTION_DEBUG_VALUES    _T("ON|OFF|EDIT")
#define CMDOPTION_EMS_VALUES    _T("ON|OFF|EDIT")

#define CMDOPTION_EMS_VALUES_IA64    _T("ON|OFF")

#define TOKEN_ASTERIX   _T("*")

#define CMDRAWSTRING			    _T("raw")

#define DEBUGPORT_1394		_T("/debugport=1394")

#define DEBUGPORT		_T("/debugport=")

#define TOKEN_CHANNEL		_T("/channel")	

#define TOKEN_BACKSLASH4  _T("\\\\")
#define TOKEN_BACKSLASH6  _T("\\\\\\")


// Other switches or sub-options
#define SWITCH_SERVER                       _T( "s" )
#define SWITCH_USER			    _T( "u" )	
#define SWITCH_PASSWORD			    _T( "p" )
#define SWITCH_TIMEOUT			    _T( "to" )
#define SWITCH_DEFAULTOS		    _T( "do" )
#define SWITCH_BASEVIDEO		    _T( "bv" )
#define SWITCH_DEBUG			    _T( "dbg" )
#define SWITCH_BAUDRATE			    _T( "br" )
#define SWITCH_DEBUGPORT		    _T( "dp" )
#define SWITCH_MAXMEM			    _T( "mm" )
#define SWITCH_NODEBUG			    _T( "nd" )
#define SWITCH_CRASHDEBUG		    _T( "cd" )	
#define SWITCH_NOSERIALMICE		    _T( "ns" )
#define SWITCH_SOS			    _T( "so" )
#define SWITCH_REDIRECT			    _T( "re" )
#define SWITCH_DESCRIPTION		    _T( "d" )
#define SWITCH_RAWSTRING		    _T("raw")	
#define TIMEOUT_SWITCH 				_T("timeout")
#define SWITCH_PORT					_T("port")
#define	SWITCH_BAUD				  _T("baud")
#define SWITCH_NOGUIBOOT		  _T("ng")	


#define SWITCH_ID			    _T("id")	
#define SWITCH_EDIT				_T("edit")

// Strings
#define OFF_STRING							_T( "OFF" )
#define ON_STRING							_T( "ON" )
#define COM_STRING                          _T( "COM" )
#define INIPATH                             _T( "c:\\boottest.ini" )
#define OPERATINGSYSTEMSECTION              _T( "operating systems" )
#define BOOTLOADERSECTION		    _T( "boot loader" )

#define	 COL_FRIENDLYNAME		    			GetResString(IDS_COL_FRIENDLYNAME)	
#define	 COL_BOOTID		    	    			GetResString(IDS_COL_BOOTID)	
#define	 COL_BOOTOPTION		    	    			GetResString(IDS_COL_COL_BOOTOPTION)	
#define  COL_ARCPATH						GetResString(IDS_COL_ARCPATH)
#define  OS_HEADER  						GetResString(IDS_OS_HEADER)
#define  DASHES_OS	     					GetResString(IDS_DASHES_OS)
#define  BOOT_HEADER						GetResString(IDS_BOOT_HEADER)
#define  DASHES_BOOTOS						GetResString(IDS_DASHES_BOOTOS)
#define TIMEOUT_VAL						GetResString(IDS_TIMEOUT)
#define DEFAULT_OS						GetResString(IDS_DEFAULT_OS)
#define DEFAULT_ARC						GetResString(IDS_DEFAULT_ARC)

#define COL_FRIENDLYNAME_WIDTH			AsLong(GetResString(IDS_COL_FRIENDLYNAME_SIZE),10)		
#define COL_BOOTID_WIDTH			AsLong(GetResString(IDS_COL_BOOTID_SIZE),10)
#define COL_BOOTOPTION_WIDTH			AsLong(GetResString(IDS_COL_BOOTOPTION_SIZE),10)
#define COL_ARC_WIDTH				AsLong(GetResString(IDS_COL_ARCPATH_SIZE),10)

#define TIMEOUT_WIDTH				AsLong(GetResString(IDS_TIMEOUT_SIZE),10) 
#define DEFAULT_ARC_WIDTH			AsLong(GetResString(IDS_DEFAULT_ARC_SIZE),10)


#define PATH_BOOTINI                        _T("c:\\boot.ini")
#define KEY_DEFAULT                         _T("default")  
#define ONOFFVALUES                         _T(" on off ") 
#define KEY_REDIRECT						_T("redirect")




// Typedefs of standard string sizes
typedef TCHAR STRING100 [ 100 ];
typedef TCHAR STRING256 [ 256 ];

#define ID_DEL_HELP_BEGIN			IDS_DELETE_HELP_BEGIN
#define ID_DEL_HELP_END				IDS_DELETE_HELP_END

#define ID_CHANGE_HELP_BEGIN		IDS_CHANGE_HELP_BEGIN
#define ID_CHANGE_HELP_END			IDS_CHANGE_HELP_END

#define ID_QUERY_HELP_BEGIN			IDS_QUERY_HELP_BEGIN
#define ID_QUERY_HELP_END			IDS_QUERY_HELP_END

#define ID_COPY_HELP_BEGIN			IDS_COPY_HELP_BEGIN
#define ID_COPY_HELP_END			IDS_COPY_HELP_END

#define ID_MAIN_HELP_BEGIN			IDS_MAIN_HELP_BEGIN					
#define ID_MAIN_HELP_END			IDS_MAIN_HELP_END					


#define RAW_HELP_BEGIN				IDS_RAW_HELP_BEGIN
#define RAW_HELP_END      			IDS_RAW_HELP_END

#define TIMEOUT_HELP_BEGIN 			IDS_TIMOUTHELP_BEGIN
#define TIMEOUT_HELP_END			IDS_TIMOUTHELP_END			

#define DEFAULT_BEGIN 				IDS_DEFAULT_BEGIN
#define DEFAULT_END					IDS_DEFAULT_END

#define ID_MAIN_HELP_BEGIN1			IDS_MAIN_HELP_BEGIN1
#define ID_MAIN_HELP_END1			IDS_MAIN_HELP_END1

#define ID_MAIN_HELP_IA64_BEGIN		IDS_MAIN_HELP_IA64_BEGIN					
#define ID_MAIN_HELP_IA64_END		IDS_MAIN_HELP_IA64_END					
#define RAW_HELP_IA64_BEGIN			IDS_RAW_HELP_IA64_BEGIN
#define RAW_HELP_IA64_END      		IDS_RAW_HELP_IA64_END
#define ID_QUERY_HELP64_BEGIN 		IDS_QUERY_HELP64_BEGIN
#define ID_QUERY_HELP64_END 		IDS_QUERY_HELP64_END
#define ID_DEL_HELP_IA64_BEGIN		IDS_DELETE_HELP_IA64_BEGIN
#define ID_DEL_HELP_IA64_END      	IDS_DELETE_HELP_IA64_END
#define ID_COPY_HELP_IA64_BEGIN		IDS_COPY_HELP_IA64_BEGIN
#define ID_COPY_HELP_IA64_END		IDS_COPY_HELP_IA64_END
#define TIMEOUT_HELP_IA64_BEGIN 	IDS_TIMOUTHELP_IA64_BEGIN
#define TIMEOUT_HELP_IA64_END		IDS_TIMOUTHELP_IA64_END			
#define DEFAULT_IA64_BEGIN 			IDS_DEFAULT_IA64_BEGIN
#define DEFAULT_IA64_END			IDS_DEFAULT_IA64_END



#define SAFEFREE(pVal) \
if(pVal != NULL) \
{ \
	free(pVal); \
	pVal = NULL ;\
}

#define SAFECLOSE(stream) \
{ \
	if(stream != NULL)  \
	fclose(stream);\
	stream = NULL ; \
}



// function prototypes

// Main functions
DWORD ChangeBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD CopyBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD DeleteBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD QueryBootIniSettings(DWORD argc, LPCTSTR argv[]);

DWORD ChangeTimeOut(DWORD argc,LPCTSTR argv[]);
DWORD ChangeDefaultOs(DWORD argc,LPCTSTR argv[]);


// Function used to get all the keys of a specified section in 
// the specified INI file
TARRAY getKeysOfINISection( LPTSTR szinifile, LPTSTR sziniSection );

// Function used to get all the key-value pairs of a specified section in 
// the specified INI file
TARRAY getKeyValueOfINISection( LPTSTR szinifile, LPTSTR sziniSection );

// Function used to delete a key from a specifed section of the
// specified ini file
BOOL deleteKeyFromINISection( LPTSTR szkey, LPTSTR szinifile, LPTSTR sziniSection );

// Function used to build the INI string containing all the key-value pairs.
LPTSTR stringFromDynamicArray( TARRAY arrKeyValuePairs );

// Function used to remove a sub-string from a given string
VOID removeSubString( LPTSTR szString, LPCTSTR szSubString );

// Function used to connect to the specified server with the given credentials
// and return the file pointer of the boot.ini file
BOOL openConnection(LPTSTR server, LPTSTR user,
					 LPTSTR password, LPTSTR filepath,BOOL bNeedPwd,FILE *stream,PBOOL pbConnFlag);

VOID FormHeader1(BOOL bHeader,TCOLUMNS *ResultHeader);

// Exit function
VOID properExit( DWORD dwExitCode, LPTSTR szFilePath );

// Usage functions
VOID displayChangeUsage();
VOID displayDeleteUsage();
VOID displayQueryUsage();
VOID displayRawUsage_X86();
VOID displayRawUsage_IA64();
DWORD displayMainUsage_X86();
VOID displayMainUsage_IA64();
VOID displayChangeOSUsage_X86();
VOID displayDefaultEntryUsage_IA64();
VOID displayRmSwUsage_X86();
VOID displayAddSwUsage_X86();

VOID displayQueryUsage_IA64();
VOID displayQueryUsage_X86();
VOID displayCopyUsage_IA64();
VOID displayCopyUsage_X86();
VOID displayChangeUsage_IA64();
VOID displayChangeUsage_X86();
VOID displayDeleteUsage_IA64();
VOID displayDeleteUsage_X86();
VOID displayTimeOutUsage_IA64();

VOID displayTimeOutUsage_X86();
VOID displayEmsUsage_X86();
VOID displayDebugUsage_X86();
VOID displayDebugUsage_IA64();
VOID displayEmsUsage_IA64();
VOID displayRmSwUsage_IA64();
VOID displayAddSwUsage_IA64();

VOID displayDbg1394Usage_X86();
VOID displayDbg1394Usage_IA64();
VOID displayMirrorUsage_IA64() ;

// Function used to process the main options

DWORD preProcessOptions( DWORD argc, LPCTSTR argv[],
					    PBOOL pbUsage, 
						PBOOL pbCopy, 
						PBOOL pbQuery,
						PBOOL pbDelete,
						PBOOL pbRawString,
						PBOOL pbDefault,
						PBOOL pbTimeOut,
						PBOOL pbDebug,
						PBOOL pbEms,
						PBOOL pbAddSw,
						PBOOL pbRmSw,
						PBOOL pbDbg1394,	
						PBOOL pbMirror	
						); 


BOOL resetFileAttrib( LPTSTR szFilePath );

BOOL stringFromDynamicArray1( TARRAY arrKeyValuePairs ,LPTSTR szFinalStr );

BOOL EnumerateOsEntries(PBOOT_ENTRY_LIST *ntBootEntries,PULONG ulLength );

VOID FormHeader(BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose);

DWORD AppendRawString(  DWORD argc, LPCTSTR argv[] );

DWORD ProcessDebugSwitch(  DWORD argc, LPCTSTR argv[] );

DWORD ProcessEmsSwitch(  DWORD argc, LPCTSTR argv[] );

VOID GetComPortType(LPTSTR  szString,LPTSTR szTemp );

VOID GetBaudRateVal(LPTSTR  szString, LPTSTR szTemp);

DWORD getKeysOfSpecifiedINISection( LPTSTR sziniFile, LPTSTR sziniSection,LPCWSTR szKeyName ,LPTSTR szValue );

DWORD ValidateSwitches(PBOOT_ENTRY bootEntry, LPTSTR szNewFriendlyName ,LPTSTR szRawString);

DWORD ProcessAddSwSwitch(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessRmSwSwitch(  DWORD argc, LPCTSTR argv[] );

DWORD GetSubString(LPTSTR szString,LPTSTR szPartString,LPTSTR szFullString);

DWORD ProcessDbg1394Switch(  DWORD argc, LPCTSTR argv[] );

BOOL IsWin64(void) ;

DWORD GetCPUInfo(LPTSTR szComputerName);
DWORD CheckSystemType(LPTSTR szServer);
VOID SafeCloseConnection(LPTSTR szServer,BOOL bFlag) ;


#define ERROR_TAG				GetResString(IDS_ERROR_TAG)
#define ERROR_LOAD_DLL				GetResString(IDS_ERROR_LOAD)
#define ERROR_NO_NVRAM				GetResString(IDS_ERROR_NO_NVRAM)
#define ERROR_UNEXPECTED			GetResString(IDS_UNEXPECTED_ERROR)
#define ERROR_NO_PRIVILAGE			GetResString(IDS_NO_PRIVILAGE)
#define DELETE_SUCCESS				GetResString(IDS_DELETE_SUCCESS)
#define DELETE_FAILURE				GetResString(IDS_DELETE_FAILURE)


#define IDENTIFIER_VALUE  _T("Identifier")
#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0")

#define IDENTIFIER_VALUE2 _T("SystemPartition")
#define IDENTIFIER_VALUE3 _T("OsLoaderPath")


#define X86_MACHINE _T("x86")

#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3
#define ERROR_RETREIVE_REGISTRY	4



#define NODEBUG_SWITCH _T("/nodebug")
#define BASEVIDEO_SWITCH _T("/basevideo")
#define DEBUG_SWITCH _T("/debug")
#define DEBUG_SWITCH1 _T("/DEBUG")

#define COM_SWITCH _T("COM")
#define CRASHDEBUG_SWITCH _T("/crashdebug")
#define SOS_SWITCH _T("/sos")
#define REDIRECT_SWITCH _T("/redirect")
#define OS_FIELD _T( "operating systems" )

#define SOS_VALUE _T("/sos")
#define NOGUI_VALUE  _T("/noguiboot")
#define BASEVIDEO_VALUE _T("/basevideo")

#define MAXMEM_VALUE _T("/MAXMEM")
#define MAXMEM_VALUE1 _T("/maxmem")

#define NTDLL_FIELD _T("\\ntdll.dll")

#define TOKEN_EQUAL _T("=")
#define TOKEN_BACKSLASH _T("\"")
#define TOKEN_BRACKET _T('[') 
#define TOKEN_DELIM _T('\0')
#define TOKEN_EMPTYSPACE _T(" ")

#define TOKEN_SINGLEQUOTE _T("\"")

#define TOKEN_BACKSLASH4 _T("\\\\")
#define TOKEN_BACKSLASH2 _T("\\")
#define TOKEN_FWDSLASH1 _T("/")
#define TOKEN_C_DOLLAR _T("C$")
#define TOKEN_STAR    _T("*")

#define TOKEN_BOOTINI_PATH _T("boot.ini")
#define TOKEN_DOLLAR _T('$')
#define TOKEN_PATH _T("c:\\boot.ini")
#define TOKEN_COLON _T(':')
#define TOKEN_COLONSYMBOL _T(":")

#define TOKEN_50SPACES _T("                                                 ")
#define TOKEN_1394   _T("1394")

#define TOKEN_NA _T("N/A")
#define TOKEN_NEXTLINE _T("\n")
#define MAX_COLUMNS 4

#define TIMEOUT_MAX 999
#define TIMEOUT_MIN 0

#define READ_MODE  _T("r")
#define READWRITE_MODE _T("r+")

#define BOOT_COLUMNS 2

#define COL0	    0
#define COL1	    1
#define COL2	    2
#define COL3	    3
	
#define TABLE_FORMAT						GetResString(IDS_FORMAT_TABLE)
#define LIST_FORMAT						GetResString(IDS_FORMAT_LIST)
#define CSV_FORMAT						GetResString(IDS_FORMAT_CSV)

#define MAX_INI_LENGTH  2500
#define MAX_STRING_LENGTH1 5000


#define ON_OFF_EDIT _T("ON|OFF|EDIT")

#define TOKEN_DEBUGPORT _T("/debugport")


#define PORT_COM1  _T("/debugport=com1")
#define PORT_COM2  _T("/debugport=com2")
#define PORT_COM3  _T("/debugport=com3")
#define PORT_COM4  _T("/debugport=com4")
#define PORT_1394  _T("/debugport=1394")


#define BAUD_VAL6  _T("/baudrate=19200")
#define BAUD_VAL7  _T("/baudrate=38400")
#define BAUD_VAL8  _T("/baudrate=57600")
#define BAUD_VAL9  _T("/baudrate=115200")
#define BAUD_VAL10  _T("/baudrate=9600")

#define BAUD_RATE		_T("/baudrate")
#define REDIRECT	_T("/redirect")

#define VALUE_OFF _T("off")
#define VALUE_ON _T("on")

#define EDIT_STRING _T("EDIT")

#define KEY_BAUDRATE  _T("redirectbaudrate")

#define USEBIOSSET _T("biosset")

#define USEBIOSSETTINGS _T("USEBIOSSETTINGS")

#define ERROR_PROFILE_STRING _T("ERROR:")

#define ERROR_PROFILE_STRING1 _T("")

#define REDIRECT_STRING	_T("redirect")

#define BAUDRATE_STRING	_T("redirectbaudrate")

#define MAX_BOOTID_VAL	20

#define STRING255 255

#define STRING10 10


#define DRIVE_C 'C'
#define DRIVE_D 'D'
#define DRIVE_E 'E'
#define DRIVE_F 'F'
#define DRIVE_G 'G'
#define DRIVE_H 'H'
#define DRIVE_I 'I'
#define DRIVE_J 'J'
#define DRIVE_K 'K'
#define DRIVE_L 'L'
#define DRIVE_M 'M'
#define DRIVE_N 'N'
#define DRIVE_O 'O'
#define DRIVE_P 'P'
#define DRIVE_Q 'Q'
#define DRIVE_R 'R'
#define DRIVE_S 'S'
#define DRIVE_T 'T'
#define DRIVE_U 'U'
#define DRIVE_V 'V'
#define DRIVE_W 'W'
#define DRIVE_X 'X'
#define DRIVE_Y 'Y'
#define DRIVE_Z 'Z'


#define OI_SERVER 1 
#define OI_USER 2
#define OI_PASSWORD 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\bootcfg.c ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		BootCfg.cpp

	Abstract:

		This file is intended to have the functionality for
		configuring, displaying, changing and deleting boot.ini 
	    settings for the local host or a remote system.

	Author:

		J.S.Vasu  17/1/2001

	Revision History:

		J.S.Vasu			17/1/2001	      		Localisation,function headers
	
		SanthoshM.B			10/2/2001	      	Added 64 bit functionality Code.

		J.S.Vasu			15/2/2001			Added the functionality of 32 bit and 64 bit acc to the DCR's.

******************************************************************************/ 



// Include files

#include "pch.h"
#include "resource.h"
#include "BootCfg.h"
#include "BootCfg64.h"



// ***************************************************************************
//
//  Routine description	: Main function which calls all the other main functions depending on
//                        the option specified by the user.
//	     
//  Arguments:
//		  [in] argc     : argument count specified at the command prompt.
//		  [in] argv		: arguments specified at the command prompt.
//
//  Return Value        : DWORD
//         0            : If the utility successfully performs the specified operation.
//         1            : If the utility is unsuccessful in performing the specified operation.
// ***************************************************************************

// Main function of the program
DWORD _cdecl _tmain( DWORD argc, LPCTSTR argv[] )
{
	// Declaring the main option switches as boolean values
	BOOL bUsage  =  FALSE ;
	BOOL bCopy   =  FALSE ;
	BOOL bChange =  FALSE ;
	BOOL bQuery  =  FALSE ;
	BOOL bDelete =  FALSE ;
	BOOL bRawString = FALSE ;
	BOOL bResult =  FALSE ;
	BOOL bNeedPwd = FALSE ;
	DWORD dwExitcode = ERROR_SUCCESS;
	BOOL bProcess = FALSE ;
	BOOL bTimeOut = FALSE ;
	BOOL bDefault = FALSE ; 
	BOOL bDebug = FALSE ;
	BOOL bEms = FALSE ;
	BOOL bAddSw = FALSE ;
	BOOL bRmSw = FALSE ;
	BOOL bDbg1394 = FALSE ; 
	BOOL bMirror = FALSE ; 
	
	TCHAR szServer[MAX_RES_STRING] = NULL_STRING ; 
	DWORD dwRetVal = 0 ;

  
#ifdef _WIN64
	dwExitcode = InitializeEFI();
#endif

    
    if(argc == 1)
    {
        dwExitcode	= QueryBootIniSettings( argc, argv );
        return dwExitcode;
    }


	// Call the preProcessOptions function to find out the option selected by the user
	dwExitcode = preProcessOptions( argc, argv, &bUsage, &bCopy, &bQuery, &bDelete,&bRawString,&bDefault,&bTimeOut,&bDebug,&bEms,&bAddSw,&bRmSw,&bDbg1394,&bMirror);
	
	if(dwExitcode == EXIT_FAILURE)
	{
		ReleaseGlobals();
		return dwExitcode;	
		
	}

	
/*#ifdef _WIN64
	dwExitcode = InitializeEFI();
#endif
*/	
	
	if(bUsage && bTimeOut)
	{
#ifndef _WIN64
		
		//check the remote systemtype and display error
		//if it is a 64 bit 
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayTimeOutUsage_X86() ;	
		}
		else
		{
			return EXIT_FAILURE ;
		}
#else
		displayTimeOutUsage_IA64();
#endif
		ReleaseGlobals();
		return EXIT_SUCCESS ;
		
	}
	
	if(bUsage && bDefault)
	{
#ifndef _WIN64
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayChangeOSUsage_X86();
		}
		else
		{
			return EXIT_FAILURE ;
		}
#else
		displayDefaultEntryUsage_IA64();
#endif
		ReleaseGlobals();
		return EXIT_SUCCESS ;
	}
	


	// If BootIni.exe /? 
if( ( bUsage ==TRUE)&& ( bCopy==FALSE )&& (bQuery==FALSE)&&(bDelete==FALSE)&&(bRawString ==FALSE)
     &&(bDefault==FALSE)&&(bTimeOut==FALSE) && (bDebug==FALSE)&& (bEms==FALSE)&&(bAddSw==FALSE)
	 &&(bRmSw==FALSE)&&( bDbg1394==FALSE )&&(bMirror== FALSE) )
{
#ifndef _WIN64
		dwExitcode = displayMainUsage_X86();
#else
		displayMainUsage_IA64();
		return EXIT_SUCCESS ;
#endif
}

	if(bRawString)
	{
#ifndef _WIN64
		dwExitcode = AppendRawString(argc,argv);
#else
		dwExitcode = RawStringOsOptions_IA64(argc,argv);
#endif
	ReleaseGlobals();
	return dwExitcode;	

	}
	
	// If BootIni.exe -copy option is selected
	if( bCopy )
	{
#ifndef _WIN64
		dwExitcode = CopyBootIniSettings( argc, argv );
#else
		dwExitcode = CopyBootIniSettings_IA64( argc, argv);
#endif
	}
	
	// If BootIni.exe -delete option is selected
	if( bDelete )
	{
#ifndef _WIN64
		dwExitcode	= DeleteBootIniSettings( argc, argv );
#else
		dwExitcode	= DeleteBootIniSettings_IA64( argc, argv );
#endif
		
	}
	
	// If BootIni.exe -query option is selected
	if( bQuery )
	{
			dwExitcode	= QueryBootIniSettings( argc, argv );
	}
	
	if(bTimeOut)
	{
		
#ifndef _WIN64
			dwExitcode = ChangeTimeOut(argc,argv);
#else
			dwExitcode = ChangeTimeOut_IA64(argc,argv);
#endif
		
	}
	
	if(bDefault)
	{
#ifndef _WIN64
		dwExitcode = ChangeDefaultOs(argc,argv);
#else
		dwExitcode = ChangeDefaultBootEntry_IA64(argc,argv);
#endif
	}


	if(bDebug )
	{
#ifndef _WIN64
			dwExitcode = ProcessDebugSwitch(  argc, argv );
#else
			dwExitcode = ProcessDebugSwitch_IA64(argc,argv);
#endif
	}
	
	if(bEms )
	{
#ifndef _WIN64
			dwExitcode = ProcessEmsSwitch(  argc, argv );
#else
			dwExitcode = ProcessEmsSwitch_IA64(argc,argv);
#endif
	}
	
	if(bAddSw )
	{
#ifndef _WIN64
			dwExitcode = ProcessAddSwSwitch(  argc, argv );
#else
		   dwExitcode = ProcessAddSwSwitch_IA64(argc,argv);
#endif
	}

	if(bRmSw )
	{
#ifndef _WIN64
			dwExitcode = ProcessRmSwSwitch(  argc,  argv );
#else
			dwExitcode = ProcessRmSwSwitch_IA64(  argc,  argv );
#endif
	}

	if (bDbg1394 )
	{
		
#ifndef _WIN64
			dwExitcode = ProcessDbg1394Switch(argc,argv);
#else
			dwExitcode = ProcessDbg1394Switch_IA64(argc,argv);
#endif
	}

	if(bMirror)
	{
#ifdef _WIN64
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX));
		//dwExitcode = ProcessMirrorSwitch_IA64(argc,argv);
#else
		
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX));
#endif
	}
	
	// exit with the appropriate return value if there is no problem
	ReleaseGlobals();
	return dwExitcode;	
	
}


// ***************************************************************************
//
//
//  Routine Description : Function used to process the main options
//	      
//  Arguments:
//       [ in  ]  argc         : Number of command line arguments
//		 [ in  ]  argv         : Array containing command line arguments
//	   	 [ out ]  pbUsage      : Pointer to boolean variable which will indicate
//								 whether usage option is specified by the user.
//		 [ out ]  pbCopy       : Pointer to boolean variable which will indicate
//								 whether copy option is specified by the user.
//		 [ out ]  pbQuery      : Pointer to boolean variable which will indicate
//								 whether query option is specified by the user.
//		 [ out ]  pbChange     : Pointer to boolean variable which will indicate
//                               whether change option is specified by the user.
//		 [ out ]  pbDelete     : Pointer to boolean variable which will indicate
//							 	 whether delete option is specified by the user.
//		 [ out ]  pbRawString  : Pointer to the boolean indicating whether raw option 
//								 is specified by the user.	
//		 [ out ]  pbDefault    : Pointer to the boolean indicating whether default option 
// 								 is specified by the user.	
//		 [ out ]  pbTimeOut    : Pointer to the boolean indicating whether timeout option 
//			                     is specified by the user.	
//		 [ out ]  pbDebug      : Pointer to the boolean indicating whether debug option 
//								 is specified by the user.	
//		 [ out ]  pbEms        : Pointer to the boolean indicating whether ems option 
// 								 is specified by the user.	
//		 [ out ]  pbAddSw      : Pointer to the boolean indicating whether Addsw option 
//			                     is specified by the user.	
//		 [ out ]  pbRmSw       : Pointer to the boolean indicating whether rmsw option 
//								 is specified by the user.	
//		 [ out ]  pbDbg1394    : Pointer to the boolean indicating whether dbg1394 option 
// 								 is specified by the user.	
//		 [ out ]  pbMirror     : Pointer to the boolean indicating whether mirror option 
//			                     is specified by the user.	
//
//  Return Type	   : Bool
//		A Bool value indicating EXIT_SUCCESS on success else 
//		EXIT_FAILURE on failure
//  
// ***************************************************************************

DWORD preProcessOptions( DWORD argc, LPCTSTR argv[],
					    PBOOL pbUsage, 
						PBOOL pbCopy, 
						PBOOL pbQuery,
						PBOOL pbDelete,
						PBOOL pbRawString,
						PBOOL pbDefault,
						PBOOL pbTimeOut,
						PBOOL pbDebug,
						PBOOL pbEms,
						PBOOL pbAddSw,
						PBOOL pbRmSw,
						PBOOL pbDbg1394	,
						PBOOL pbMirror	
						)
{
	// Initialise a boolean variable bOthers to find out whether switches other
	// than the main swithces are selected by the user
	BOOL bOthers = FALSE;

	DWORD dwCount = 0;
	DWORD dwi = 0;

	BOOL bMainUsage = FALSE ;

	TCHAR szServer[MAX_RES_STRING] = NULL_STRING ; 
	DWORD dwRetVal = 0;
	BOOL bConnFlag = FALSE ;

	// Populate the TCMDPARSER structure and pass the structure to the DoParseParam
	// function. DoParseParam function populates the corresponding variables depending
	// upon the command line input.

	  TCMDPARSER cmdOptions[] = {
		{ CMDOPTION_COPY,     0,              1, 0, pbCopy,   NULL_STRING, NULL, NULL },
		{ CMDOPTION_QUERY,    0,              1, 0, pbQuery,  NULL_STRING, NULL, NULL },
		{ CMDOPTION_DELETE,   0,              1, 0, pbDelete, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,    CP_USAGE,       1, 0, pbUsage,  NULL_STRING, NULL, NULL },
		{ CMDOTHEROPTIONS,    CP_DEFAULT,     0, 0, &bOthers, NULL_STRING, NULL, NULL },
		{ CMDOPTION_RAW,	  0,1, 0, pbRawString, NULL_STRING, NULL, NULL },
		{ CMDOPTION_DEFAULTOS, 0,1,0,pbDefault,NULL_STRING,NULL,NULL},
		{ CMDOPTION_TIMEOUT,	0,1,0,pbTimeOut,NULL_STRING,NULL,NULL},
		{ CMDOPTION_DEBUG,	 0,1,0,pbDebug,NULL_STRING,NULL,NULL},
		{ CMDOPTION_EMS,	 0,1,0,pbEms,NULL_STRING,NULL,NULL},
		{ CMDOPTION_ADDSW,	 0,1,0,pbAddSw,NULL_STRING,NULL,NULL},
		{ CMDOPTION_RMSW,	 0,1,0,pbRmSw,NULL_STRING,NULL,NULL},
		{ CMDOPTION_DBG1394, 0,1,0,pbDbg1394,NULL_STRING,NULL,NULL},
		{ CMDOPTION_MIRROR, 0,1,0,pbMirror,NULL_STRING,NULL,NULL}
	}; 

	 dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	
	// If there is an error while parsing, display "Invalid Syntax"
	// If more than one main option is selected, then display error message
	// If usage is specified for sub-options
	// If none of the options are specified

	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) ) 
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		DISPLAY_MESSAGE(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	
	//checking if the user has entered more than 1 option.
		 
	 if (*pbCopy)
	 {
		dwCount++ ;
	 }

	 if (*pbQuery)
	 {
		dwCount++ ;
	 }

	 if (*pbDelete)
	 {
		dwCount++ ;
	 }
	 
	 if (*pbRawString)
	 {
		dwCount++ ;

		// Check if any of the other valid switches have been 
		// given as an input to the raw string
	       if( *pbTimeOut  || *pbDebug   || *pbAddSw 
			||*pbRmSw   || *pbDbg1394 || *pbEms 
			||*pbDelete || *pbCopy  || *pbQuery   
			||*pbDefault || *pbMirror)
		{
			// Check wether the usage switch has been entered
			if( *pbUsage )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_MAIN_USAGE));
				return ( EXIT_FAILURE );
			}

			// Check if the other option is specified after the
			// 'raw' option
			for( dwi = 0; dwi < argc; dwi++ )
			{
				if( lstrcmpi( argv[ dwi ], _T("-raw") ) == 0 
					|| lstrcmpi( argv[ dwi ], _T("/raw") ) == 0 )
				{
					if( (dwi+1) == argc )
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_MAIN_USAGE));
						return ( EXIT_FAILURE );
					}
					else if( _tcschr( argv[ dwi + 1 ], _T( '\"' ) ) != 0 )
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_MAIN_USAGE));
						return ( EXIT_FAILURE );
					}
				}
			}
	
			dwCount--;
		}
	}

	 if (*pbDefault)
	 {
		dwCount++ ;
	 }

	 if (*pbTimeOut)
	 {
		dwCount++ ;
	 }

	 if (*pbDebug)
	 {
		dwCount++ ;
	 }

	 if(*pbAddSw)
	 {
		dwCount++ ;

	 }
	 
	 if(*pbRmSw)
	 {
		dwCount++ ;

	 }

	 if(*pbDbg1394)
	 {
		dwCount++ ;
	 }

	 if(*pbEms)
	 {
		dwCount++ ;
	 }
	
	 if(*pbMirror)
	 {
		dwCount++ ;
	 }

		//display an  error message if the user enters more than 1 main option 
		if( (  ( dwCount > 1 ) ) ||  
		//display an  error message if the user enters  1 main option along with other junk
		 ( (*pbUsage) && bOthers ) || 
		 //display an  error message if the user does not enter any main option
		 (  !(*pbCopy) && !(*pbQuery) && !(*pbDelete) && !(*pbUsage) && !(*pbRawString)&& !(*pbDefault)&&!(*pbTimeOut)&&!(*pbDebug)&& !( *pbEms)&& !(*pbAddSw)&& !(*pbRmSw)&& !(*pbDbg1394)&& !(*pbMirror) ) )
	{
	
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAIN_USAGE));
		return ( EXIT_FAILURE );		
	}
		

	return ( EXIT_SUCCESS );		
}



/*****************************************************************************

	Routine Description:
		 This routine is to make another OS instance copy for which you
	     can add switches.

	Arguments:			
	[in]                : argc Number of command line arguments
    [in]                : argv Array containing command line arguments
	

	Return Value :
		DWORD
******************************************************************************/


DWORD CopyBootIniSettings( DWORD argc, LPCTSTR argv[] )
{
	// Declaring the main option switch and the usage switch as 
    // boolean values and initialising them
	BOOL bCopy = FALSE ;
	BOOL bUsage = FALSE;

	// size of the buffer and the key buffer storing the keys
	// Length of the buffer will be incremented dynamically based on
	// the number of keys present in the boot.ini file. First the length
	// is initialised to 100 TCHAR bytes.

	LPTSTR szBuf = NULL_STRING ; 

	// File pointer pointing to the boot.ini file
	FILE *stream = NULL;

	// dynamic array containing all the keys of the boot.ini file
	TARRAY arr = NULL;

	// The key for which a new OS instance is to be built
	TCHAR key[MAX_RES_STRING] = NULL_STRING;

	BOOL bRes = FALSE ; 

	// Variable storing the path of boot.ini file
	LPTSTR szPath = NULL_STRING ; 

	TCHAR szTmpPath[MAX_RES_STRING] = NULL_STRING ;

	// Variable which stores the new key-value pair
	TCHAR newInstance[500] = NULL_STRING ;

	// Variable to keep track the OS entry specified by the user
	DWORD dwDefault = 0;

	// It contains the return length of GetPrivateProfileSection API
	DWORD dwReturnLen = 0;

	// Number of keys present in the boot.ini file
	DWORD dwNumKeys = 0;

	BOOL bNeedPwd =FALSE;

	DWORD dwId = 0;

	TCHAR szMesgBuffer[MAX_RES_STRING] = NULL_STRING;

	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING256 szDescription	  = NULL_STRING;

	BOOL bFlag  = FALSE ;

	BOOL bMemFlag = FALSE ;

	DWORD dwLength = MAX_STRING_LENGTH1 ; 

	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;
	
	STRING256 szCopyStr = NULL_STRING ;

	LPCTSTR szToken1 = NULL ;


	// Builiding the TCMDPARSER structure
	
	 TCMDPARSER cmdOptions[] = {
		{ CMDOPTION_COPY,     CP_MAIN_OPTION,                      1, 0, &bCopy,         NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,      CP_TYPE_TEXT | CP_VALUE_MANDATORY,   1, 0, &szServer,      NULL_STRING, NULL, NULL },
		{ SWITCH_USER,        CP_TYPE_TEXT | CP_VALUE_MANDATORY,   1, 0, &szUser,        NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,    CP_TYPE_TEXT | CP_VALUE_OPTIONAL,   1, 0, &szPassword,    NULL_STRING, NULL, NULL },
		{ SWITCH_DESCRIPTION, CP_TYPE_TEXT | CP_VALUE_MANDATORY,   1, 0, &szDescription, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,    CP_USAGE,                   0, 0, &bUsage,        0, 0 },
		{ SWITCH_ID,          CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY  | CP_MANDATORY, 1, 0, &dwDefault, NULL_STRING, NULL, NULL }
	}; 

	dwRetVal = CheckSystemType( szServer);
	 if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}


	 szBuf = ( LPTSTR ) malloc( dwLength*sizeof( TCHAR ) );
	 if(szBuf == NULL)
	 {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		SAFEFREE(szBuf);
		return (EXIT_FAILURE);
	 }

	 // Variable storing the path of boot.ini file
	 szPath = (TCHAR*)malloc(MAX_RES_STRING* sizeof(TCHAR));
	 if(szPath == NULL)
	 {
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return (EXIT_FAILURE);
	 } 

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);


	 // Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return (EXIT_FAILURE);
	}


	// Displaying copy usage if user specified -? with -copy option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
			
		if(dwRetVal==EXIT_SUCCESS )	
		{
			SAFEFREE(szBuf);
			SAFEFREE(szPath);
			displayCopyUsage_X86();
			return (EXIT_SUCCESS);
		}
		else
		{
			SAFEFREE(szBuf);
			SAFEFREE(szPath);
			return (EXIT_FAILURE);
		}
	}

	//display an error message saying that Friendly name 
	// must be restricted ot 67 characters.
	if(lstrlen(szDescription) >= 67)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_FRIENDLY_NAME));
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return (EXIT_FAILURE);
	}


	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;

	}

	//display error message if the user enters password without entering username
	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;

	}

    // for prompting the password if the user enters 
	// * after -p option.
	
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	//display an error message if the server is empty.  	
	if( (cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))

	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;
	}
	
	
	
	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection

	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));

	}

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SAFECLOSE(stream);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

		
	// Getting the keys of the Operating system section in the boot.ini file
	arr = getKeyValueOfINISection( szPath, OS_FIELD );
	if(arr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	
	lstrcpy(szTmpPath,szPath);

	// Getting the total number of keys in the operating systems section
	dwNumKeys = DynArrayGetCount(arr);

	if((dwNumKeys >= MAX_BOOTID_VAL) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAX_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

	// Displaying error message if the number of keys is less than the OS entry
	// line number specified by the user
	if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

 	// Getting the key of the OS entry specified by the user	
	if(arr != NULL)
	{
		LPCWSTR pwsz = NULL ;
		pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
		if(pwsz != NULL)
		{
			_tcscpy( key,pwsz);
		}
		else
		{
			resetFileAttrib(szPath);
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			SAFEFREE(szBuf);
			SAFEFREE(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arr);
			SafeCloseConnection(szServer,bConnFlag);
			return (EXIT_FAILURE);

		}
	}
	else
	{
		resetFileAttrib(szPath);
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arr);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	 } 


	// Copying the key to a newInstance variable which will hold the new key-value pair.	
	lstrcpy(newInstance, key);
	szToken = _tcstok(newInstance,TOKEN_EQUAL);
	if(szToken == NULL)
	{
		DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
		resetFileAttrib(szPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arr);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	} 

	// Building the newInstance.
	lstrcat(newInstance, TOKEN_EQUAL ); 
	lstrcat(newInstance, TOKEN_SINGLEQUOTE);

	// Copying the description specified by the user as the value of the new key.
	lstrcat(newInstance, szDescription);
	lstrcat(newInstance, TOKEN_SINGLEQUOTE);

	//
	//concatenating the star so that the boundschecker does not 
	//give invalid argument exception
	//
	
	lstrcat(key,TOKEN_STAR);
	szToken = _tcstok(key,TOKEN_FWDSLASH1);
	if(szToken == NULL)
	{
		DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
		resetFileAttrib(szPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arr);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}	

	// get the Os Load options into the szToken1 string.
	szToken1 = _tcstok(NULL,TOKEN_STAR);
    lstrcpy(szCopyStr,szToken1);
   
	lstrcat(newInstance,TOKEN_EMPTYSPACE);
	lstrcat(newInstance,TOKEN_FWDSLASH1) ;
	lstrcat(newInstance,szCopyStr);
	newInstance[lstrlen(newInstance) + 1] = _T('\0'); 

	// Reallocating the buffer length depending on the return value and of the 
	// GetPrivateProfileSection API. Its return a value  2 less than the buffer size
	// if the buffer size is not enough to hold all the key-value pairs.
	while( 1 )
	{
		dwReturnLen = GetPrivateProfileSection(OS_FIELD, szBuf, dwLength, szTmpPath);
		
		// If buffer length is sufficient break
		if ( dwLength - 2 != dwReturnLen )
			break;

		// Increasing the buffer length and reallocate the size
		dwLength += 100;
		szBuf = ( LPTSTR ) realloc( szBuf, dwLength * sizeof( TCHAR ) );
		if (szBuf == NULL)
		{
			bMemFlag = TRUE ;
			break ;
		}	

		
	}

	//display error message if there is no enough memory	
	if (bMemFlag == TRUE)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		resetFileAttrib(szTmpPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}


	// Adding the new key-value pair
	lstrcat(szBuf + dwReturnLen, newInstance);

	// Appending the null character at the end
	*(szBuf + dwReturnLen + 1 + lstrlen(newInstance)) = '\0'; 

	
	// Writing to the profile section with new key-value pair
	if( WritePrivateProfileSection(OS_FIELD, szBuf, szTmpPath) != 0 )
	{
		_stprintf(szMesgBuffer,GetResString(IDS_COPY_SUCCESS),dwDefault);
		DISPLAY_MESSAGE(stdout,szMesgBuffer);
		bRes = resetFileAttrib(szPath);
		bRes = resetFileAttrib(szTmpPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arr);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return(bRes);
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_COPY_OS));
		resetFileAttrib(szPath);
		resetFileAttrib(szTmpPath);
		SAFEFREE(szBuf);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arr);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return (EXIT_FAILURE);
	}

	// Closing the opened boot.ini file handl
	SAFECLOSE(stream);
	bRes = resetFileAttrib(szPath);
	bRes = resetFileAttrib(szTmpPath);
	SAFEFREE(szBuf);
	SAFEFREE(szPath);
	DestroyDynamicArray(&arr);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes);
}



/*****************************************************************************

	Routine Description:
	  This routine is to delete an OS entry from the Operating systems
	  section of Boot.ini file in the specified machine.

	Arguments:			
	[in]                : argc Number of command line arguments
    [in]                : argv Array containing command line arguments
	

	Return Value :
		DWORD
******************************************************************************/
DWORD DeleteBootIniSettings(  DWORD argc, LPCTSTR argv[] )
{
	// Declaring the main option switch and the usage switch as 
    // boolean values and initialsing them
	BOOL bDelete = FALSE ;
	BOOL bUsage = FALSE;

	BOOL bRes = FALSE ;

	// dwDefault variable stores the OS entry specified by the user
	DWORD dwDefault = 0;

	// Variables containing the count of key-value pairs
	DWORD dwInitialCount = 0;

	// Variable which will store the final key-value pairs
	LPTSTR szFinalStr = NULL_STRING;

	// array storing all the keys of the operating systems section
	TARRAY arrKeyValue;

	// Variable storing the path of boot.ini file
	LPTSTR szPath = NULL_STRING ;
	
	// File pointer to the boot.ini file
	FILE *stream = NULL;

	BOOL bNeedPwd = FALSE ;

	BOOL bFlag = FALSE ;

	TCHAR szMesgBuffer[MAX_RES_STRING]  = NULL_STRING;

	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szDescription	  = NULL_STRING;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;

	// Builiding the TCMDPARSER structure
	
	 TCMDPARSER cmdOptions[] = {
		{ CMDOPTION_DELETE,  CP_MAIN_OPTION,                       1, 0, &bDelete,         NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    0, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,         CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwDefault,    NULL_STRING, NULL, NULL }
	}; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	szFinalStr =(TCHAR*)malloc(MAX_STRING_LENGTH1 *sizeof(TCHAR));
	if(szFinalStr == NULL )
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return EXIT_FAILURE ;
	}

	// Variable storing the path of boot.ini file
	szPath = (TCHAR*)malloc(MAX_RES_STRING * sizeof(TCHAR));
	if(szPath == NULL)
	{
		SAFEFREE(szFinalStr);
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);

	// Parsing the delete option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		return (EXIT_FAILURE);
	}


	// Displaying delete usage if user specified -? with -delete option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayDeleteUsage_X86();
			SAFEFREE(szFinalStr);
			SAFEFREE(szPath);
			return (EXIT_SUCCESS);
		}else
		{
			SAFEFREE(szFinalStr);
			SAFEFREE(szPath);
			return (EXIT_FAILURE);
		}
	}


   //display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;

	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;

	}

	
	//
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	//display an error message if the server is empty.  	
	if( (cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		return EXIT_FAILURE ;
	}
	

	// Searching the path of the boot.ini file in the specified system
	// In general the boot.ini file resides in c:\.
	// Search Path function can be used to trace out the path of boot.ini file
	// SearchPath( "\\", "boottest.ini", ".ini", 80, (LPTSTR)filepath, (LPTSTR*)&filepart  );

	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}
			else
			{
				lstrcpy(szServer,szToken);
			}
		}
	}

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
	}

	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag );
	if(bFlag == EXIT_FAILURE)
	{
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

		
	// Getting all the key-value pairs of the operating system into a dynamic
	// array for manipulation.
	arrKeyValue = getKeyValueOfINISection( szPath, OS_FIELD);
	if(arrKeyValue == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Getting the total no: of key-value pairs in the operating system section.
	dwInitialCount = DynArrayGetCount(arrKeyValue);

	// Checking whether the given OS entry is valid or not. If the OS entry given
	// is greater than the number of keys present, then display an error message
	
	if( ( dwDefault <= 0 ) || ( dwDefault > dwInitialCount ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arrKeyValue);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	// If only one OS entry is present and if the user tries to delete the OS entry, then
	// display an error message
	if( DynArrayGetCount(arrKeyValue) == 1)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ONLY_ONE_OS));
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arrKeyValue);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Remove the OS entry specified by the user from the dynamic array

	DynArrayRemove(arrKeyValue, dwDefault - 1);

	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs
	
	if (stringFromDynamicArray1( arrKeyValue,szFinalStr )  == EXIT_FAILURE)
	{
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arrKeyValue);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		_stprintf(szMesgBuffer,GetResString(IDS_DEL_SUCCESS),dwDefault);	
		DISPLAY_MESSAGE(stdout,szMesgBuffer);
		bRes = resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arrKeyValue);
		SafeCloseConnection(szServer,bConnFlag);
		return (bRes);
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_DELETE_OS));
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SAFEFREE(szFinalStr);
		SAFEFREE(szPath);
		DestroyDynamicArray(&arrKeyValue);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	// Closing the boot.ini stream
	SAFECLOSE(stream);
	bRes = resetFileAttrib(szPath);
	SAFEFREE(szFinalStr);
	SAFEFREE(szPath);
	DestroyDynamicArray(&arrKeyValue);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes);
}


/*****************************************************************************

	Routine Description:
      This routine is to display the current boot.ini file settings for 
      the specified system.	 

	Arguments:			
	[in]                : argc Number of command line arguments
    [in]                : argv Array containing command line arguments
	

	Return Value :
		DWORD
******************************************************************************/

DWORD QueryBootIniSettings(  DWORD argc, LPCTSTR argv[] )
{
	// File pointer pointing to the boot.ini file
	FILE *stream = NULL;

	// Declaring the main option switch and the usage switch as 
    // boolean values and initialsing them
	BOOL bQuery = FALSE ;
	BOOL bUsage = FALSE;
	BOOL bExitVal = TRUE;
	BOOL bNeedPwd = FALSE ;
	BOOL bVerbose = TRUE ;

	TCOLUMNS ResultHeader[ MAX_COLUMNS ];
	
	TARRAY arrResults = NULL ;
	TARRAY arrKeyValuePairs = NULL;
	TARRAY arrBootLoader = NULL;
	DWORD dwFormatType = 0;
	BOOL bHeader = TRUE ;
	DWORD dwLength = 0 ;	
	DWORD dwCnt = 0;
	TCHAR szValue[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szFriendlyName[MAX_CMD_LENGTH] = TOKEN_NA ;
	
	TCHAR szBootOptions[MAX_RES_STRING] = TOKEN_NA ;
	TCHAR szBootEntry[MAX_RES_STRING] = TOKEN_NA ;
	TCHAR szArcPath[MAX_RES_STRING] = TOKEN_NA ;
	TCHAR szTmpString[MAX_RES_STRING] = TOKEN_NA ;  
	PTCHAR psztok = NULL ;
	DWORD dwRow = 0;
	DWORD dwCount = 0;
	BOOL bRes = FALSE ;
	BOOL bFlag = FALSE ;

	DWORD dwIndex = 0 ;

	DWORD dwLength1 = 0 ;
	DWORD dwFinalLength = 0 ;

	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING;
	STRING256 szUser          = NULL_STRING;
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	

	LPCWSTR szKeyName[MAX_RES_STRING] ; 

	
	TCHAR szResults[MAX_RES_STRING][MAX_RES_STRING] ; 
	TCHAR szDisplay[MAX_RES_STRING] = NULL_STRING ;

	DWORD dwSectionFlag = 0 ;

	LPCTSTR szToken = NULL ;
	DWORD dwRetVal= 0 ;
	BOOL bConnFlag = FALSE ;
	BOOL bTokenFlag	 = FALSE ;
	BOOL bPasswdFlag = FALSE ;
			

	// Builiding the TCMDPARSER structure
	TCMDPARSER cmdOptions[] = {
		{ CMDOPTION_QUERY, CP_MAIN_OPTION,                    1, 0, &bQuery,          NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,   CP_TYPE_TEXT | CP_VALUE_MANDATORY, 1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY, 1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD, CP_TYPE_TEXT | CP_VALUE_OPTIONAL, 1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE, CP_USAGE,                 0, 0, &bUsage,              NULL_STRING, NULL, NULL }
	

	};  


	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);

	
	// Parsing all the switches specified with -query option
	if ( ! DoParseParam( argc, argv,SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) ) 
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	} 

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}


	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayQueryUsage();
			return (EXIT_SUCCESS);
		}
		else
		{
			return (EXIT_FAILURE);
		}
	}


	#ifdef _WIN64
		bExitVal = QueryBootIniSettings_IA64();
		return bExitVal;
	#endif

	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}


	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}


	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));

	}

	//set the default format as list
	dwFormatType = SR_FORMAT_LIST;

	//forms the header for the OS options 
	FormHeader(bHeader,ResultHeader,bVerbose);

	
	//create dynamic array to hold the results for the BootOptions
	arrResults = CreateDynamicArray();
	
	//create dynamic array to hold the results for the BootLoader section
	arrBootLoader = CreateDynamicArray();

	if(arrResults == NULL || arrBootLoader == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		if (arrResults!=NULL)
			DestroyDynamicArray(&arrResults);
		return (EXIT_FAILURE);
	}

	lstrcpy(szPath, PATH_BOOTINI );

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		DestroyDynamicArray(&arrBootLoader);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	//to store entries corresponding to Operating Systems sections
	arrKeyValuePairs = getKeyValueOfINISection( szPath, OS_FIELD );

	//to store entries corresponding to BootLoader section
	arrBootLoader = getKeysOfINISection(szPath,BOOTLOADERSECTION);
	
	if( (arrBootLoader == NULL)||(arrKeyValuePairs == NULL))
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		DestroyDynamicArray(&arrBootLoader);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	dwCount = DynArrayGetCount(arrBootLoader);
	
	
	//to display the Header Column  
	DISPLAY_MESSAGE(stdout,TOKEN_NEXTLINE);
	DISPLAY_MESSAGE(stdout,BOOT_HEADER);
	DISPLAY_MESSAGE(stdout,DASHES_BOOTOS);

	// this loop is for calculating the maximum width of the the keys which will be displayed.
	for(dwIndex=0;dwIndex < dwCount;dwIndex++)
	{
		szKeyName[dwIndex] = DynArrayItemAsString(arrBootLoader,dwIndex);

		//the value correspondin to the key is obtained.
		dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,szKeyName[dwIndex],szResults[dwIndex]);
		
		if (dwSectionFlag == MALLOC_FAILURE)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			DestroyDynamicArray(&arrBootLoader);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
	
		}
		
		dwLength1 = lstrlen(szKeyName[dwIndex]);

		if (dwLength1 > dwFinalLength)
		{
			dwFinalLength = dwLength1;
		}
	}


	// display the results of the bootloader section.
	for(dwIndex=0;dwIndex < dwCount;dwIndex++)
	{
		dwLength1 = dwFinalLength - lstrlen(szKeyName[dwIndex]) + 1;
		DISPLAY_MESSAGE(stdout,szKeyName[dwIndex]);
		_tcscpy(szDisplay,TOKEN_COLONSYMBOL);
		_tcsncat(szDisplay,TOKEN_50SPACES,dwLength1);
		DISPLAY_MESSAGE(stdout,szDisplay);
		DISPLAY_MESSAGE(stdout,szResults[dwIndex]);
		DISPLAY_MESSAGE(stdout,TOKEN_NEXTLINE);

		
	}

	DISPLAY_MESSAGE(stdout,TOKEN_NEXTLINE);

	psztok = NULL ;
	//getting the count of the number of boot entries
	dwLength = DynArrayGetCount(arrKeyValuePairs);

	for(dwCnt=0;dwCnt < dwLength;dwCnt++ )
	{
		dwRow =	DynArrayAppendRow(arrResults,MAX_COLUMNS) ;
		lstrcpy(szFriendlyName,NULL_STRING);
		lstrcpy(szBootOptions,NULL_STRING);
		lstrcpy(szTmpString,NULL_STRING);
		if(arrKeyValuePairs != NULL)
		{
			LPCWSTR pwsz = NULL;
			pwsz = DynArrayItemAsString( arrKeyValuePairs,dwCnt );
			if(pwsz != NULL)
			{
				lstrcpy(szValue,pwsz);
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);
				SAFECLOSE(stream);
				resetFileAttrib(szPath);
				DestroyDynamicArray(&arrBootLoader);
				DestroyDynamicArray(&arrKeyValuePairs);
				DestroyDynamicArray(&arrResults);
				
				SafeCloseConnection(szServer,bConnFlag);
				return (EXIT_FAILURE);

			}
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrBootLoader);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return (EXIT_FAILURE);
		}
		
		psztok =	_tcstok(szValue,TOKEN_EQUAL);
		if(psztok != NULL)
		{
			lstrcpy(szArcPath,psztok);
			psztok = _tcstok(NULL,TOKEN_FWDSLASH1 );
		
			if(psztok != NULL)
			{
				lstrcpy(szFriendlyName,psztok);
				lstrcat(szValue,TOKEN_STAR);
				psztok = _tcstok(NULL,TOKEN_STAR);
				if(psztok != NULL)
				{
					lstrcpy(szTmpString,psztok);
				}
				else
				{
					bTokenFlag = TRUE ;
				}

			}else
			{
				bTokenFlag = TRUE ;
			}

		}
		else
		{
			bTokenFlag = TRUE ;
		}



		_ltow(dwCnt+1,szBootEntry,10);
		DynArraySetString2( arrResults,dwRow ,COL0,szBootEntry,0 );  
		if(lstrlen(szFriendlyName)==0)
		{
			lstrcpy(szFriendlyName,TOKEN_NA);
		}
		DynArraySetString2( arrResults,dwRow ,COL1,szFriendlyName,0 );  
		DynArraySetString2(arrResults,dwRow,COL2,szArcPath,0);
		
		if(lstrlen(szTmpString) != 0)
		{
		 lstrcat(szBootOptions,TOKEN_FWDSLASH1);
		 lstrcat(szBootOptions,szTmpString);
		}
		else
		{
			lstrcpy(szBootOptions,TOKEN_NA);
		}
		DynArraySetString2( arrResults,dwRow ,COL3,szBootOptions,0 );  

	}

	DISPLAY_MESSAGE(stdout,OS_HEADER);
	DISPLAY_MESSAGE(stdout,DASHES_OS);
	
	ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType,arrResults ) ;

	// Closing the boot.ini stream and destroying the dynamic arrays.
	DestroyDynamicArray(&arrResults);
	DestroyDynamicArray(&arrBootLoader);
	DestroyDynamicArray(&arrKeyValuePairs);
	SAFECLOSE(stream);
	bRes = resetFileAttrib(szPath);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes);
}

/*****************************************************************************

	Routine Description:
	  This function gets all the keys present in the specified section of 
      an .ini file and then returns the dynamic array containing all the
      keys

	Arguments:			
	[in] sziniFile     :  Name of the ini file.
    [in] szinisection  :  Name of the section in the boot.ini.
	

	Return Value :
		TARRAY ( pointer to the dynamic array )
******************************************************************************/

TARRAY getKeysOfINISection( LPTSTR sziniFile, LPTSTR sziniSection )
{

	// Dynamic array which will hold all the keys
	TARRAY arrKeys = NULL;

	// Number of characters returned by the GetPrivateProfileString function
	DWORD len = 0 ;

	// Variables used in the loop
	DWORD i = 0 ;
	DWORD j = 0 ;

	// Buffer which will be populated by the GetPrivateProfileString function
	

	LPTSTR  inBuf = NULL ;
	DWORD dwLength = MAX_STRING_LENGTH1;

	// Temporary variable which will contain the individual keys
		
	LPTSTR szTemp = NULL ;

	inBuf = (LPTSTR)malloc(dwLength*sizeof(TCHAR));
	if(inBuf==NULL)
	{
		return NULL ;
	}

	szTemp = (LPTSTR)malloc(dwLength*sizeof(TCHAR));
	if((szTemp == NULL))
	{	
        SAFEFREE(inBuf);
		return NULL ;
	}

    memset(inBuf,0,dwLength);
    memset(szTemp,0,dwLength);
    
	while(1)
	{
		// Getting all the keys from the boot.ini file
		len = GetPrivateProfileString (sziniSection,
									   NULL, 
									   ERROR_PROFILE_STRING, 
									   inBuf,
									   dwLength, 
										sziniFile); 


		//if the size of the string is not sufficient then increment the size. 
		if(len == dwLength-2)
		{
			dwLength +=100 ;
			inBuf = (LPTSTR)realloc(inBuf,dwLength*sizeof(TCHAR));
			if(inBuf == NULL)
			{
				SAFEFREE(inBuf); 
                SAFEFREE(szTemp); 
				return NULL ;
			}

			szTemp = (LPTSTR)realloc(szTemp,dwLength*sizeof(TCHAR));
			if(szTemp == NULL)
			{
				SAFEFREE(inBuf); 
                SAFEFREE(szTemp);
				return NULL ;
			}
		}
		else
			break ;
	}

	// Creating a dynamic array by using the function in the DynArray.c module.
	// This dynamic array will contain all the keys.
	arrKeys = CreateDynamicArray();
	if(arrKeys == NULL)
	{
		SAFEFREE(inBuf);
		SAFEFREE(szTemp);
		return NULL ;
	}

	// Looping through the characters returned by the above function
	while(i<len)
	{

	  // Each individual key will be got in arrTest array
	  szTemp[ j++ ] = inBuf[ i ];
	  if( inBuf[ i ] == TOKEN_DELIM )
	  {
			// Setting j to 0 to start the next key.
			j = 0;

			// Appending each key to the dynamic array
			DynArrayAppendString( arrKeys, szTemp, 0 );
			if(lstrlen(szTemp)==0)
			{
                SAFEFREE(inBuf); 
                SAFEFREE(szTemp);
				return  NULL ;
			}
	  }

	  // Incrementing loop variable
	  i++;
	}

	SAFEFREE(inBuf); 
	SAFEFREE(szTemp);
	// returning the dynamic array containing all the keys
	return arrKeys;
}


/*****************************************************************************

	Routine Description:
		This function gets all the key-value pairs of the [operating systems]
        section and returns a dynamic array containing all the key-value pairs

	Arguments:			
	[in] sziniFile     :  Name of the ini file.
    [in] szinisection  :  Name of the section in the boot.ini.
	

	Return Value :
		TARRAY ( pointer to the dynamic array )
******************************************************************************/
TARRAY getKeyValueOfINISection( LPTSTR iniFile, LPTSTR sziniSection )
{

	// Dynamic array which will hold all the key-value pairs
	TARRAY arrKeyValue = NULL;

	// Number of characters returned by the GetPrivateProfileSection function
	DWORD len = 0;

	// Variables used in the loop
	DWORD i = 0 ;
	DWORD j = 0 ;
	
	LPTSTR inbuf = NULL;

	// Buffer which will be populated by the GetPrivateProfileSection function
	

	// Temporary variable which will contain the individual keys
	LPTSTR szTemp = NULL ;

	DWORD dwLength = MAX_STRING_LENGTH1 ;

	// Initialising loop variables
	i = 0;
	j = 0;

	//return NULL if failed to allocate memory.
	inbuf = (LPTSTR)malloc(dwLength*sizeof(TCHAR));
	if(inbuf==NULL)
	{
		return NULL ;
	}

	//return NULL if failed to allocate memory
	szTemp = (LPTSTR)malloc(dwLength*sizeof(TCHAR));
	if(szTemp == NULL)
	{
        SAFEFREE(inbuf);
    	return NULL ;
	}

	memset(inbuf,0,dwLength);

	while(1)
	{
		
	    // Getting all the key-value pairs from the boot.ini file
		len = GetPrivateProfileSection (sziniSection, inbuf,dwLength, iniFile); 
		
		if(len == dwLength -2)
		{
			dwLength +=100 ;
			
			inbuf = (LPTSTR)realloc(inbuf,dwLength*sizeof(TCHAR));
			szTemp = (LPTSTR)realloc(szTemp,dwLength*sizeof(TCHAR));
			if((inbuf== NULL)||(szTemp==NULL))
			{
				SAFEFREE(inbuf); 
				SAFEFREE(szTemp);
				return NULL ;
			} 

			
		}
		else
			break ;
	}

		
		inbuf[lstrlen(inbuf)] = '\0';

	// Creating a dynamic array by using the function in the DynArray.c module.
	// This dynamic array will contain all the key-value pairs.
	arrKeyValue = CreateDynamicArray();
	if(arrKeyValue == NULL)
	{
		SAFEFREE(inbuf); 
		SAFEFREE(szTemp);
		return NULL ;
	}

	// Looping through the characters returned by the above function
	while(i<len)
	{
	  // Each individual key will be got in arrTest array
	  szTemp[ j++ ] = inbuf[ i ];
	  if( inbuf[ i ] == TOKEN_DELIM)
	  {
			szTemp[j+1] = '\0';
	
			// Setting j to 0 to start the next key.
			j = 0;

			// Appending each key-value to the dynamic array
			DynArrayAppendString( arrKeyValue, szTemp, 0 );
			if(lstrlen(szTemp)==0)
			{
                SAFEFREE(inbuf); 
		        SAFEFREE(szTemp);
				return NULL ;
			}
			
	  }

	  // Incrementing loop variable
	  i++;
	}

	// returning the dynamic array containing all the key-value pairs
	SAFEFREE(inbuf); 
	SAFEFREE(szTemp);
	return arrKeyValue;
}


/*****************************************************************************

	Routine Description:
		This function deletes a key from an ini section of an ini file
	
	  Arguments:			
	[in] szKey			 :  Name of the key which has to be deleted
                            from the given section present in the
						    given ini file
    [in] sziniFile       :  Name of the ini file.
	[in] szinisection    :  Name of the section in the boot.ini.	

	Return Value :
		BOOL (TRUE if there is no error, else the value is FALSE)
******************************************************************************/

BOOL deleteKeyFromINISection( LPTSTR szKey, LPTSTR sziniFile, LPTSTR sziniSection )
{
	// If the third parameter (default value) is NULL, the key pointed to by 
	// the key parameter is deleted from the specified section of the specified
	// INI file
	if( WritePrivateProfileString( sziniSection, szKey, NULL, sziniFile ) == 0 )
	{
		// If there is an error while writing then return false
		return FALSE;
	}

	// If there is no error, then return true
	return TRUE;
}



/*****************************************************************************

	Routine Description:
		This function removes a sub-string from a string
	
	  Arguments:			
		 [in] szString			 :  Main string
		 [in] szSubString         : Sub-string

	Return Value :
		VOID 
******************************************************************************/

VOID removeSubString( LPTSTR szString, LPCTSTR szSubString )
{
	
	TCHAR szFinalStr[MAX_STRING_LENGTH1] = NULL_STRING ; 


	DWORD dwSize = 1;
	TCHAR sep[] = TOKEN_EMPTYSPACE;

	PTCHAR pszToken = NULL_STRING;

	// Character space is used for tokenising
	lstrcpy( sep, _T(" ") );

	// Getting the first token
	pszToken = _tcstok( szString, sep );
	while( pszToken != NULL )
	{
		// If the token is equal to the sub-string, then the token
		// is not added to the final string. The final string contains
		// all the tokens except the sub-string specified.
		if(lstrcmpi( pszToken, szSubString ) != 0 )
		{
			lstrcpy( szFinalStr + dwSize - 1, TOKEN_EMPTYSPACE);
			lstrcpy( szFinalStr + dwSize, pszToken );
			dwSize = dwSize + lstrlen(pszToken) + 1;
		}

		// Getting the next token
		pszToken = _tcstok( NULL, sep );
	}

	lstrcpy(szString,szFinalStr);

}


/*****************************************************************************

	Routine Description:
		This function establishes a connection to the specified system with
		the given credentials. 	
    Arguments:			
	[in] szServer	  :  server name to coonect to
    [in] szUser       :  User Name 
	[in] szPassword   :  password
	[in] bNeedPwd     :  Boolean for asking the password.
	[in] szPath       :  path of the ini file .
	
	Return Value :
	  BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
******************************************************************************/

BOOL openConnection( STRING256 szServer, STRING256 szUser,STRING256 szPassword,
					 STRING100 szPath,BOOL bNeedPwd,FILE *stream,PBOOL pbConnFlag)
{

	
	
	// Declaring the file path string which will hold the path of boot.ini file
	TCHAR filePath[MAX_RES_STRING] = NULL_STRING ;

	// Loop variable
	DWORD i = 0;

	// Position of the character we are searching for
	#ifndef _WIN64 
		DWORD dwPos = 0;
	#else
	  __int64 dwPos = 0;
	#endif

	// Boolean variable which will keep trach whether boot.ini file is present in
	// any drive of a system or not
	BOOL bFound = FALSE;
	
	DWORD dwRetVal = 0 ;


	// All the possible drive letters in a system
	// A and B are removed, since they are assigned for floppy disk drives.
	TCHAR szDrives[] = { DRIVE_C, DRIVE_D, DRIVE_E, DRIVE_F, DRIVE_G, DRIVE_H, DRIVE_I, DRIVE_J,DRIVE_K, DRIVE_L,
						   DRIVE_M, DRIVE_N, DRIVE_O, DRIVE_P,DRIVE_Q,DRIVE_R,DRIVE_S,DRIVE_T,DRIVE_U,
						   DRIVE_V,DRIVE_W,DRIVE_X,DRIVE_Y,DRIVE_Z};

	// Pointer to the first occurence of the character '$'
	TCHAR *pdest = NULL;
	
	BOOL bResult = FALSE;
	INT	  nRetVal = 0;
	*pbConnFlag = TRUE ;
	
	if( lstrcmpi(szServer, NULL_STRING) != 0 )
	{

			//bResult = EstablishConnection(szServer,szUser,SIZE_OF_ARRAY(szUser),szPassword,SIZE_OF_ARRAY(szPassword),bNeedPwd);
			bResult = EstablishConnection(szServer,szUser,256,szPassword,SIZE_OF_ARRAY(szPassword),bNeedPwd);
			
			if (bResult == FALSE)
			{
				DISPLAY_MESSAGE( stderr,ERROR_TAG );
				DISPLAY_MESSAGE( stderr, GetReason());
				return EXIT_FAILURE ;
			
			}
			else
			{
				switch( GetLastError() )
				{
				case I_NO_CLOSE_CONNECTION:
					*pbConnFlag = FALSE ;
					break;

				case E_LOCAL_CREDENTIALS:
				case ERROR_SESSION_CREDENTIAL_CONFLICT:
					{
						*pbConnFlag = FALSE ;
						break;
					}
				}
			}

			dwRetVal = CheckSystemType( szServer);
			if(dwRetVal==EXIT_FAILURE )	
			{
				return EXIT_FAILURE ;
			}
			
		// Building the file path of boot.ini file
		// File Path is in \\server\C$\boot.ini format.
		// Right now assuming that boot.ini file is in C Drive
		lstrcpy(filePath, TOKEN_BACKSLASH4);
		lstrcat(filePath, szServer);
		lstrcat(filePath, TOKEN_BACKSLASH2);
		lstrcat(filePath, TOKEN_C_DOLLAR);
		lstrcat(filePath, TOKEN_BACKSLASH2);
		lstrcat(filePath, TOKEN_BOOTINI_PATH);
		lstrcpy(szPath, filePath);

		// Finding the drive containing the boot.ini file
		// For remote computer the path will be in the format
		// \\MACHINE\DRIVELETTER$\boot.ini
		while( i < 25 )
		{
			pdest = _tcschr(filePath, TOKEN_DOLLAR);
			if (pdest==NULL)
			{
				return FALSE ;			
			}

			dwPos = pdest - filePath ;
			filePath[dwPos - 1] = szDrives[i];

			stream = _tfopen(filePath,READ_MODE);
				
			// If the boot.ini is found
			if( stream != NULL )
			{
				bFound = TRUE;
				fclose(stream);
				break;
			}
			i++;
		}

	}
	else
	{
			dwRetVal = CheckSystemType( szServer);
			if(dwRetVal==EXIT_FAILURE )	
			{
				return EXIT_FAILURE ;
			}
		
		
		lstrcpy(filePath, TOKEN_PATH);
		// Finding the drive containing the boot.ini file
		// For local computer the path will be in the format
		// DRIVELETTER:\boot.ini
		while( i < 25 )
		{
			pdest = _tcschr(filePath,_T(':'));
			if (pdest==NULL)
			{
				return FALSE ;			
			}

			dwPos = pdest - filePath + 1;
			filePath[dwPos - 2] = szDrives[i];

			stream = _tfopen(filePath, READ_MODE);

			// If the boot.ini is found
			if(stream != NULL )
			{
				fclose(stream);
				bFound = TRUE;
				break;
			}
			i++;
		}

	}

	// If boot.ini is not found in any drives, then display error message
	if( bFound == FALSE )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_BOOTINI));
		return EXIT_FAILURE ;
		
	}

	nRetVal = _tchmod(filePath, _S_IREAD | _S_IWRITE);
	// Changing the file permissions of the boot.ini file
	if( nRetVal != 0 )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_READWRITE_BOOTINI));
		return EXIT_FAILURE ;
		
	}
	else if (nRetVal == -1)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_FILE));
		return EXIT_FAILURE ;
	}	


	// Open the Boot.ini file with both read and write mode
	// If there is no error in opening the file, then return success
	// of the boot.ini file to the calling function
	return EXIT_SUCCESS ;
}


// ***************************************************************************
// Routine Description:
//		This function fetches 64 bit Delete Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
void displayDeleteUsage_IA64()
{
	DWORD dwIndex = ID_DEL_HELP_IA64_BEGIN;
	for(;dwIndex <= ID_DEL_HELP_IA64_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
	
}


// ***************************************************************************
// Routine Description:
//		This function fetches 32 bit Delete Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
void displayDeleteUsage_X86()
{
	DWORD dwIndex = ID_DEL_HELP_BEGIN;
	for(;dwIndex <= ID_DEL_HELP_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
	
}


// ***************************************************************************
// Routine Description:
//		This function fetches 64 bit Copy Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayCopyUsage_IA64()
{
	DWORD dwIndex = ID_COPY_HELP_IA64_BEGIN;
	for(;dwIndex <=ID_COPY_HELP_IA64_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
	
}


// ***************************************************************************
// Routine Description:
//		This function fetches 32 bit Copy Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayCopyUsage_X86()
{
	DWORD dwIndex = ID_COPY_HELP_BEGIN;
	for(;dwIndex <=ID_COPY_HELP_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//		This function fetches Query Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayQueryUsage()
{
#ifdef _WIN64
		displayQueryUsage_IA64();	
#else
		displayQueryUsage_X86();
#endif
}


// ***************************************************************************
// Routine Description:
//		This function fetches Query Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayQueryUsage_IA64()
{
	DWORD dwIndex = ID_QUERY_HELP64_BEGIN ;

	for(;dwIndex <= ID_QUERY_HELP64_END ;dwIndex++ )
	{
		
			DISPLAY_MESSAGE(stdout,GetResString(dwIndex));		
		
	}
	
}


// ***************************************************************************
// Routine Description:
//		This function fetches Query Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayQueryUsage_X86()
{
	DWORD dwIndex = ID_QUERY_HELP_BEGIN ;

	for(;dwIndex <= ID_QUERY_HELP_END;dwIndex++ )
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//		This function fetches Main Usage information from resource file and displays it
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
DWORD displayMainUsage_X86()
{

	TCHAR szServer[MAX_RES_STRING] = NULL_STRING ;
	DWORD dwRetVal = 0;

	DWORD dwIndex = ID_MAIN_HELP_BEGIN1 ;

	//display the error message if  the target system is a 64 bit system or if error occured in 
	//retreiving the information
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return (EXIT_FAILURE);
	}

	for(;dwIndex <= ID_MAIN_HELP_END1 ;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}

	return EXIT_SUCCESS ;
}


// ***************************************************************************
// Routine Description:
//		This function fetches Usage information for the 64 bit system 
//		  
// Arguments:
//		None
//  
// Return Value:
//		void
// ***************************************************************************
VOID displayMainUsage_IA64()
{
	DWORD dwIndex = ID_MAIN_HELP_IA64_BEGIN ;

	for(;dwIndex <= ID_MAIN_HELP_IA64_END ;dwIndex++)
	{
		if( (dwIndex == IDS_MAIN_HELP23_IA64 ) || (dwIndex == IDS_MAIN_HELP24_IA64) || (dwIndex == IDS_MAIN_HELP38_IA64) )
		{
			continue;
		}
		else
		{
			DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
		}
	}
}

/*****************************************************************************

	Routine Description:
		This function resets the permissions with the original set of
		permissions ( -readonly -hidden -system )
		and then exits with the given exit code.	  
	
	Arguments
	[in] szFilePath	  :  File Path of the boot.ini file
 
   
	Return Value :
	  BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
******************************************************************************/

BOOL resetFileAttrib( LPTSTR szFilePath )
{
	if(szFilePath==NULL)
	{
		return FALSE ;
	}

	// Resetting the file permission of the boot.ini file to its original
	// permission list( -r, -h, -s )
	if( _tchmod(szFilePath, _S_IREAD != 0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_RESET_ERROR));
		return EXIT_FAILURE ;
	}

	return EXIT_SUCCESS ;
}


/*****************************************************************************

	Routine Description:
		This function returns a string from a dynamic array .	
	
	Arguments
		[in]  arrKeyValuePairs	  :  Dynamic array which contains all the
									 key-value pairs. 
		[out] szFiinalStr			  :  String which is formed from all the key-value pairs 

    Return Value :
	  BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
******************************************************************************/

BOOL stringFromDynamicArray1( TARRAY arrKeyValuePairs ,LPTSTR szFinalStr )
{
	
	// Total number of elements in the array
	DWORD dwKeyValueCount = 0;

	// Variable used to keep track the current position while appending strings.
	DWORD dwStrSize = 0;


	// Loop variable
	DWORD i = 0;

	// Initialsing size and loop variables to 0
	dwStrSize = 0;
	i = 0;

	if( (arrKeyValuePairs ==NULL)||(szFinalStr==NULL))
	{
		return EXIT_FAILURE ;
	}


	// Getting the total number of key-value pairs

	if(arrKeyValuePairs != NULL)
	{
		dwKeyValueCount = DynArrayGetCount(arrKeyValuePairs);
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return (EXIT_FAILURE) ;
	}
		
	// Looping through all the key-value pairs and building the final string 
	// containing all the key value pairs. This string has to be passed to 
	// WriteProfileSection
	while( (i <= dwKeyValueCount - 1 )&& (arrKeyValuePairs != NULL) )
	{
		// Building the final string, by getting each key-value pair present in the
		// dynamic array
		if(arrKeyValuePairs != NULL)
		{
			LPCWSTR pwsz = NULL;
			pwsz = DynArrayItemAsString( arrKeyValuePairs, i ) ;
			if(pwsz != NULL)
			{
			   lstrcpy(szFinalStr + dwStrSize, pwsz );
			   dwStrSize = dwStrSize + lstrlen(pwsz) + 1;
			   i++;
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);
				return EXIT_FAILURE ;
			}
			
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			return EXIT_FAILURE ;
		}
	}

	return EXIT_SUCCESS ;
}



// ***************************************************************************
// Routine Description:
//		This function is used to build the header and also display the 
//		 result in the required format as specified by  the user.	
//		  
// Arguments:
//		[ in ] arrResults     : argument(s) count specified at the command prompt
//		[ in ] dwFormatType   : format flags 
//		[ in ] bHeader        : Boolean for specifying if the header is required or not.
//  
// Return Value:
//		none
//		
// ***************************************************************************

VOID FormHeader(BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose)
{

	
	//OS Entry 
	ResultHeader[COL0].dwWidth = COL_BOOTOPTION_WIDTH ;
	ResultHeader[COL0].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL0].pFunction = NULL;
	ResultHeader[COL0].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL0].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL0].szColumn,COL_BOOTOPTION );

	
	ResultHeader[COL1].dwWidth = COL_FRIENDLYNAME_WIDTH;
	ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL1].pFunction = NULL;
	ResultHeader[COL1].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL1].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL1].szColumn,COL_FRIENDLYNAME );


	ResultHeader[COL2].dwWidth =  COL_ARC_WIDTH;
	ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL2].pFunction = NULL;
	ResultHeader[COL2].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL2].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL2].szColumn,COL_ARCPATH );

	ResultHeader[COL3].dwWidth =  COL_BOOTID_WIDTH;
	ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
	ResultHeader[COL3].pFunction = NULL;
	ResultHeader[COL3].pFunctionData = NULL;
	lstrcpy( ResultHeader[COL3].szFormat, NULL_STRING );
	lstrcpy( ResultHeader[COL3].szColumn,COL_BOOTID );

}


// ***************************************************************************
// Routine Description:
//      This routine is to display the current boot.ini file settings for 
//		the specified system.	 
//				     			  
// Arguments:
//		[ in ] argc     : Number of command line arguments
//		[ in ] argv     : Array containing command line arguments
  
// Return Value:
//		DWORD 
//		
// ***************************************************************************

DWORD AppendRawString(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bRaw = FALSE ;

	DWORD dwId = 0;
	DWORD dwDefault = 0;

	TARRAY arr ;

	TCHAR szkey[MAX_RES_STRING] = NULL_STRING;
	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	STRING256 szRawString	  = NULL_STRING ;

	DWORD dwNumKeys = 0;
	BOOL bRes = FALSE ;
	PTCHAR pToken = NULL ;
	LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ; 

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;

	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;
	BOOL bAppendFlag = FALSE ;
	TCHAR szErrorMsg[MAX_RES_STRING] = NULL_STRING ;

	 // Building the TCMDPARSER structure
	   TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_RAW,     CP_MAIN_OPTION, 1, 0,&bRaw, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwDefault,    NULL_STRING, NULL, NULL },
		{ CMDOPTION_DEFAULT, CP_DEFAULT | CP_TYPE_TEXT | CP_MANDATORY, 1, 0, &szRawString,NULL_STRING, NULL, NULL },
		{ CMDOPTION_APPEND , 0, 1, 0, &bAppendFlag,NULL_STRING, NULL, NULL }
		
	 };	 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}
	
	szFinalStr = (TCHAR*) malloc(MAX_STRING_LENGTH1* sizeof(TCHAR) );
	if (szFinalStr== NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TAG));
		ShowLastError(stderr);
		return (EXIT_FAILURE);
		
	}

	
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);

	
	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		return (EXIT_FAILURE);
	}


	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayRawUsage_X86();
			SAFEFREE(szFinalStr);
			return (EXIT_SUCCESS);
		}
		else
		{
			SAFEFREE(szFinalStr);
			return (EXIT_FAILURE);
		}
	}

	// error checking in case the  
	// raw string does not start with a "/" .
	if(*szRawString != _T('/'))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_FWDSLASH));
		SAFEFREE(szFinalStr);
		return (EXIT_FAILURE);
	}

	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		return EXIT_FAILURE ;

	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		SAFEFREE(szFinalStr);
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}



	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		SAFEFREE(szFinalStr);
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		SAFEFREE(szFinalStr);
		return EXIT_FAILURE ;
	}
	
	
	
	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );
	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
	}

	 bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag );
	if(bFlag == EXIT_FAILURE)
	{
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

   
	// Getting the keys of the Operating system section in the boot.ini file
	arr = getKeyValueOfINISection( szPath, OS_FIELD );

	if(arr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	// Getting the total number of keys in the operating systems section
	dwNumKeys = DynArrayGetCount(arr);

	//
	if((dwNumKeys >= MAX_BOOTID_VAL)&&(dwDefault >= MAX_BOOTID_VAL ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAX_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

	// Displaying error message if the number of keys is less than the OS entry
	// line number specified by the user
	if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Getting the key of the OS entry specified by the user	
	if (arr != NULL)
	{
		LPCWSTR pwsz = NULL;
		pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
		if(pwsz != NULL)
		{
			_tcscpy( szkey,pwsz);
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	if(bAppendFlag == FALSE)
	{
		pToken = _tcstok(szkey ,TOKEN_FWDSLASH1);
		if(pToken == NULL)
		{
			DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
	}
	
	lstrcat(szkey , TOKEN_EMPTYSPACE);
	CharLower(szRawString);
	lstrcat(szkey ,szRawString);
    
	if( _tcslen(szkey) >= MAX_RES_STRING)
	{
		
		_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
		DISPLAY_MESSAGE( stderr,szErrorMsg);	
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	DynArrayRemove(arr, dwDefault - 1 );
	DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_RES_STRING);
	
	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs

	if (stringFromDynamicArray1( arr,szFinalStr) == EXIT_FAILURE)
	{
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		_stprintf(szBuffer,GetResString(IDS_SWITCH_ADD), dwDefault );
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_ADD_SWITCHES));
		DestroyDynamicArray(&arr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	//reset the file attributes and free the memory and close the connection to the server.

	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arr);
	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	SafeCloseConnection(szServer,bConnFlag);
	return (EXIT_SUCCESS);

}



// ***************************************************************************
// Routine Description:
//      This routine is to display the current boot.ini file settings for 
//		the specified system.	 
//				     			  
// Arguments:
//		none
// Return Value:
//		VOID 
//		
// ***************************************************************************

VOID displayRawUsage_X86()
{

	DWORD dwIndex = RAW_HELP_BEGIN;
	for(;dwIndex <= RAW_HELP_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//	Display the help for the 64 bit raw option.	 
//				     			  
// Arguments:
//		none
// Return Value:
//		VOID 
//		
// ***************************************************************************

VOID displayRawUsage_IA64()
{

	DWORD dwIndex = RAW_HELP_IA64_BEGIN;
	for(;dwIndex <= RAW_HELP_IA64_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//		This routine is to change the timout of the boot.ini file settings for 
//		the specified system.	 				     			  
// Arguments:
//	 [in ]   argc  : Number of command line arguments
//	 [in ]   argv  : Array containing command line arguments
//
// Return Value:
//		DWORD 
//		
// ***************************************************************************

DWORD ChangeTimeOut(DWORD argc,LPCTSTR argv[])
{
	
	STRING256 szServer = NULL_STRING;
	STRING256 szUser = NULL_STRING;
	STRING256 szPassword = NULL_STRING;
	STRING100 szPath = NULL_STRING;	
	
	FILE *stream = NULL;

	
	BOOL bNeedPwd = FALSE ;
	TARRAY arrResults;
	BOOL bRes= FALSE ;
	DWORD dwCount = 0;
	DWORD dwTimeOut = 0 ;
	BOOL bFlag = 0 ;
	TCHAR timeOutstr[STRING20] = NULL_STRING;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;

	TCMDPARSER cmdOptions[] = 
	{
		{ CMDOPTION_TIMEOUT, CP_MAIN_OPTION | CP_TYPE_UNUMERIC | CP_VALUE_OPTIONAL|CP_VALUE_MANDATORY,	1,	0,&dwTimeOut,NULL_STRING, NULL, NULL},
		{ SWITCH_SERVER,CP_TYPE_TEXT|CP_VALUE_MANDATORY,1,0,&szServer,NULL_STRING,NULL,NULL},
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
	}; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);


	if( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		
		return EXIT_FAILURE ;
	}



	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}
	
	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if( (cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}
	
	
	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	//display a warning message if it is a local system and set the server name to empty.

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));

	}

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

		
	arrResults = CreateDynamicArray();

	if(arrResults == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		resetFileAttrib(szPath);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return (EXIT_FAILURE);					
	}
		
	dwCount = DynArrayGetCount(arrResults);

	if(dwTimeOut > TIMEOUT_MAX) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_TIMEOUT_RANGE));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return (EXIT_FAILURE);					
	}
	
	// Converting the numeric value to string because the WritePrivateProfileString
	// takes only string value as the value for a particular key
	_itot( dwTimeOut, timeOutstr, 10 );

	// Changing the timeout value
	if( WritePrivateProfileString( BOOTLOADERSECTION,TIMEOUT_SWITCH, 
		timeOutstr, szPath ) != 0 )
	{
		DestroyDynamicArray(&arrResults);
		DISPLAY_MESSAGE(stdout,GetResString(IDS_TIMEOUT_CHANGE));
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_SUCCESS ;
	}
	
	// DISPLAY Error message and exit with Error code of 1.
	
	DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TIMEOUT));
	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arrResults);
	SafeCloseConnection(szServer,bConnFlag);
	SAFECLOSE(stream);
	return EXIT_FAILURE ;

}



// ***************************************************************************
// Routine Description:
//		Display the help for the timeout option.
// Arguments:
//		NONE.
// Return Value:
//		VOID 
//		
// ***************************************************************************


VOID displayTimeOutUsage_X86()
{
	DWORD dwIndex = TIMEOUT_HELP_BEGIN;
	
	
	for(;dwIndex <= TIMEOUT_HELP_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}

}


// ***************************************************************************
// Routine Description:
//		Display the help for the 64 BIT timeout option.
// Arguments:
//		NONE.
// Return Value:
//		VOID 
//		
// ***************************************************************************

VOID displayTimeOutUsage_IA64()
{
	DWORD dwIndex = TIMEOUT_HELP_IA64_BEGIN;
	

	for(;dwIndex <= TIMEOUT_HELP_IA64_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//        This routine is to change the Default OS  boot.ini file settings for 
//						 the specified system.
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.
//		
// ***************************************************************************

DWORD ChangeDefaultOs(DWORD argc,LPCTSTR argv[])
{

	STRING256 szServer = NULL_STRING ;
	STRING256 szUser = NULL_STRING ;
	STRING256 szPassword = NULL_STRING ;

	DWORD dwId = 0;
	BOOL bDefaultOs = FALSE ;
	

	STRING100 szPath ;
	FILE *stream = NULL;
	BOOL bNeedPwd = FALSE ;
	TARRAY arrResults ;
	DWORD dwCount = 0;
	BOOL bFlag = FALSE ;
	PTCHAR psztok = NULL ;

	TCHAR szTmp[MAX_RES_STRING] = NULL_STRING ;  
    TCHAR szTmpBootId[MAX_RES_STRING] = NULL_STRING ;  
	TCHAR szDefaultId[MAX_RES_STRING] = NULL_STRING ;  

	DWORD dwValue = 0 ;
	BOOL bExitFlag = FALSE ;
	LPCWSTR pwsz[MAX_RES_STRING]  ;  
	LPCWSTR pwszBootId [MAX_RES_STRING]  ; 
	LPTSTR szFinalStr = NULL  ;
    	
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;
	BOOL bRes = FALSE;
	
	TCMDPARSER cmdOptions[] = 
	{
		{ CMDOPTION_DEFAULTOS, CP_MAIN_OPTION, 1, 0,&bDefaultOs, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,CP_TYPE_TEXT|CP_VALUE_MANDATORY,1,0,&szServer,NULL_STRING,NULL,NULL},
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ SWITCH_ID,CP_TYPE_NUMERIC | CP_VALUE_MANDATORY| CP_MANDATORY, 1, 0, &dwId,    NULL_STRING, NULL, NULL }
	}; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);


	if( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if(dwId <= 0)
	{
		SetReason(GetResString(	IDS_INVALID_OSID));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}

	

	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
	}

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}


	arrResults = CreateDynamicArray();
	//return failure if failed to allocate memory
	if(arrResults == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return (EXIT_FAILURE);					
	}

	arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
	if(arrResults == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;

	}
	
	dwCount = DynArrayGetCount(arrResults);
	if(dwId<=0 || dwId > dwCount )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_OSID));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;
	}

	if(arrResults !=NULL)
	{
		pwsz[0] = DynArrayItemAsString(arrResults, dwId - 1);
		pwszBootId[0]  = DynArrayItemAsString(arrResults, 0);
		if( (pwsz != NULL) || (pwszBootId != NULL) )
		{
			lstrcpy(szTmp,pwsz[0]) ;
			lstrcpy(szDefaultId,pwsz[0]);
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			SAFECLOSE(stream);
			return EXIT_FAILURE ;
		}
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;
	}

	szFinalStr = (LPTSTR)malloc(MAX_STRING_LENGTH1*sizeof(TCHAR));
	if(szFinalStr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;	
	}

	//loop through all the  Boot entries and 
	for(dwValue = dwId -1 ; dwValue > 0  ; dwValue-- )
	{
			pwszBootId[dwValue]  = DynArrayItemAsString(arrResults,dwValue );
			pwsz[dwValue] = DynArrayItemAsString(arrResults, dwValue - 1);
			
			DynArrayRemove(arrResults, dwValue );
			if (pwsz[dwValue] != NULL) 
			{
				lstrcpy(szTmpBootId,pwsz[dwValue]) ;
			}
			else
			{
				bExitFlag = TRUE ;
				break ;
			}
			DynArrayInsertString(arrResults, dwValue, szTmpBootId, MAX_RES_STRING);		
	}

	if (bExitFlag == TRUE  )
	{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			return EXIT_FAILURE ;
	}
	
	DynArrayRemove(arrResults, 0 );
	DynArrayInsertString(arrResults, 0, szDefaultId, MAX_RES_STRING);		

	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);
	if(stringFromDynamicArray1( arrResults,szFinalStr) == EXIT_FAILURE )
	{
				bExitFlag = TRUE ;
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( ( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) == 0 ) || (bExitFlag == TRUE ) )
	{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERR_CHANGE));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			return EXIT_FAILURE ;
	}

		//to strip of the unwanted string from the string and save the required part in the Boot Loader section.
		szToken = _tcstok(szTmp,TOKEN_EQUAL);
		if(szToken == NULL)
		{
			DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			return (EXIT_FAILURE);
		}

		if( WritePrivateProfileString( BOOTLOADERSECTION, KEY_DEFAULT, szTmp,
							      szPath ) != 0 )
		{
			DISPLAY_MESSAGE(stdout,GetResString(IDS_DEF_CHANGE));	
		}
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERR_CHANGE));
			DestroyDynamicArray(&arrResults);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			return EXIT_FAILURE ;
		}

	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arrResults);
	SafeCloseConnection(szServer,bConnFlag);
	SAFECLOSE(stream);
	SAFEFREE(szFinalStr);
	return bRes ;
}


// ***************************************************************************
//  Routine Description		   :  Display the help for the default entry option (x86).
//
//  Parameters		   : none
//				         
//  Return Type	       : VOID
//
// ***************************************************************************
VOID displayChangeOSUsage_X86()
{
	DWORD dwIndex = DEFAULT_BEGIN;
	

	for(;dwIndex <=DEFAULT_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//
//  Routine Description		   :  Display the help for the default entry option (IA64).
//
//  Parameters				   : none
//				         
//  Return Type			       : VOID
//  
// ***************************************************************************
VOID displayDefaultEntryUsage_IA64()
{
	DWORD dwIndex = DEFAULT_IA64_BEGIN;
	
	for(;dwIndex <=DEFAULT_IA64_END;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
// Routine Description:
//		Implement the Debug switch.
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
//		
// ***************************************************************************
DWORD ProcessDebugSwitch(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bDebug = FALSE ;

	DWORD dwId = 0;
	TARRAY arrResults ;
	
	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	

	TCHAR szDebug[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szPort[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szBoot[MAX_RES_STRING] = NULL_STRING ;

	BOOL bRes = FALSE ;
	LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ; 

	DWORD dwBaudRate = 0 ;
	DWORD dwCount = 0 ;
	DWORD dwSectionFlag = 0 ;

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szTmpBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szBaudRate[MAX_RES_STRING] = NULL_STRING ;

	TCHAR szString[MAX_STRING_LENGTH1] = NULL_STRING ;

	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ;

	_TCHAR *szValues[2] = {NULL};	

	 TCHAR szMessage[MAX_STRING_LENGTH] = NULL_STRING;   

	 TCHAR szErrorMsg[MAX_RES_STRING] = NULL_STRING ;

	 DWORD dwCode = 0 ;
	 LPCTSTR szToken = NULL ;
	 DWORD dwRetVal = 0 ;
	 BOOL bConnFlag = FALSE ;

	 // Building the TCMDPARSER structure
	  TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_DEBUG,     CP_MAIN_OPTION, 1, 0,&bDebug, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwId,    NULL_STRING, NULL, NULL },
		{ SWITCH_PORT,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY|CP_MODE_VALUES,1,0,&szPort,COM_PORT_RANGE,NULL,NULL},
		{ SWITCH_BAUD,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY |CP_MODE_VALUES,1,0,&szBaudRate,BAUD_RATE_VALUES_DEBUG,NULL,NULL},
		{ CMDOPTION_DEFAULT, CP_DEFAULT | CP_TYPE_TEXT | CP_MANDATORY , 1, 0, &szDebug,NULL_STRING, NULL, NULL }
	 }; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	}

	
	if(bUsage)
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayDebugUsage_X86();		
			return (EXIT_SUCCESS);
		}else
		{
			return (EXIT_FAILURE);
		}

	}

	if(dwId <= 0)
	{
		SetReason(GetResString(	IDS_INVALID_OSID));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}
	
	//display an error message if the server is empty.  	
	if( (cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if( (cmdOptions[2].dwActuals!=0) && (lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}
	
	
	//display an error message if the user specifies any string other than on,off,edit.
	if( !( ( lstrcmpi(szDebug,VALUE_ON)== 0)|| (lstrcmpi(szDebug,VALUE_OFF)== 0) ||(lstrcmpi(szDebug,EDIT_STRING)== 0) ))
	{
		szValues[0]= (_TCHAR *)szDebug ;
		szValues[1]= (_TCHAR *)CMDOPTION_DEBUG ;
		
		FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
        GetResString(IDS_OPTION_SNTAX_ERROR),0,MAKELANGID(LANG_NEUTRAL,
        SUBLANG_DEFAULT),szMessage, MAX_STRING_LENGTH,(va_list*)szValues);

		DISPLAY_MESSAGE(stderr,szMessage);
		return EXIT_FAILURE;
	}	

	if( (lstrcmpi(szDebug,EDIT_STRING)== 0)&& (lstrlen(szPort)==0) && (lstrlen(szBaudRate)==0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_EDIT_SYNTAX));
		return EXIT_FAILURE;
	}	
	

	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection

	arrResults = CreateDynamicArray();
	
	//return failure if failed to allocate memory
	if(arrResults == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return (EXIT_FAILURE);					
	} 


	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}
			lstrcpy(szServer,szToken);
		}
	}

	// display a warning message if it is a local system and set the 
	// server name to empty.
	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		lstrcpy(szServer,_T(""));

	}

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	
	arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
	if(arrResults == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;

	}

	//getting the number of boot entries 
	dwCount = DynArrayGetCount(arrResults);
	if(dwId<=0 || dwId > dwCount )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_OSID));
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}


	lstrcpy(szString ,DynArrayItemAsString(arrResults, dwId - 1 ));

	if(lstrlen(szString) == 0) 
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	
	// check if the user entered the value of debug as on and do accordingly
	if( lstrcmpi(szDebug,VALUE_ON)== 0) 
	{
		
		//display error message if the user specifies Baud rate with out specifying COM port.
		if((lstrlen(szPort)== 0) && (lstrlen(szBaudRate)!= 0))
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;

		}
		
		//check if the debug switch is already present and if so display a error message.
		if( (_tcsstr(szString,DEBUG_SWITCH) != NULL ) && ( (lstrlen(szPort)== 0)&&(lstrlen(szBaudRate)== 0) ) ) 
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_DEBUG));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
		else
		{
			if(_tcsstr(szString,DEBUG_SWITCH) == NULL )
			{
				lstrcat(szString,TOKEN_EMPTYSPACE);
				lstrcat(szString,DEBUG_SWITCH);
			}
		}
		
	
		// get the type of the Com port present
		dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);
		
		if((lstrlen(szTemp )!= 0)&& (lstrlen(szPort)!= 0))
		{
			_stprintf(szBuffer,GetResString(IDS_ERROR_DUPLICATE_COM_PORT), dwId );
			DISPLAY_MESSAGE(stderr,szBuffer);
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
					
		}

		// if the debug port is specified by the user.
		if(lstrlen(szPort)!= 0)
		{
			
			dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
			if (dwSectionFlag == MALLOC_FAILURE)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);	
				resetFileAttrib(szPath);
				SAFECLOSE(stream);
				DestroyDynamicArray(&arrResults);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
			}
			
			if(lstrlen(szBoot)!= 0)
			{
				if (lstrcmpi(szBoot,szPort)==0)
				{
					DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_REDIRECT_PORT));
					resetFileAttrib(szPath);
					SAFECLOSE(stream);
					DestroyDynamicArray(&arrResults);
					SafeCloseConnection(szServer,bConnFlag);
					return EXIT_FAILURE ;

				}

			}


			lstrcat(szTmpBuffer,TOKEN_EMPTYSPACE);
			lstrcat(szTmpBuffer,TOKEN_DEBUGPORT) ;
			lstrcat(szTmpBuffer,TOKEN_EQUAL) ;
			CharLower(szPort);
			lstrcat(szTmpBuffer,szPort);
			lstrcat(szString,szTmpBuffer);
		}

		
		lstrcpy(szTemp,NULL_STRING);
	
		//to add the Baud rate value specified by the user. 
		GetBaudRateVal(szString,szTemp)	;
	
		
		if(lstrlen(szBaudRate)!=0)
		{
			if(lstrlen(szTemp )!= 0)
			{
				_stprintf(szBuffer,GetResString(IDS_ERROR_DUPLICATE_BAUD_VAL), dwId );
				DISPLAY_MESSAGE(stderr,szBuffer);
				resetFileAttrib(szPath);
				SAFECLOSE(stream);
				DestroyDynamicArray(&arrResults);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
				
			}else
			{

				//forming the string to be concatenated to the BootEntry string
				lstrcpy(szTemp,BAUD_RATE);
				lstrcat(szTemp,TOKEN_EQUAL);
				lstrcat(szTemp,szBaudRate);

				//append the string containing the modified  port value to the string
				lstrcat(szString,TOKEN_EMPTYSPACE);
				lstrcat(szString,szTemp);

			}
		}
	
	}
	
	else if( lstrcmpi(szDebug,VALUE_OFF)== 0) 
	{
		if((lstrlen(szPort)!= 0) || (lstrlen(szBaudRate)!= 0))
		{
			DestroyDynamicArray(&arrResults);
			DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}

		if (_tcsstr(szString,DEBUG_SWITCH) == 0 )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DEBUG_ABSENT));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
		else
		{
			// remove the /debug switch.
			removeSubString(szString,DEBUG_SWITCH);
				
			lstrcpy(szTemp,NULL_STRING);
	
			// get the type of the Com port present
			dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);
			if(lstrcmpi(szTemp,PORT_1394)==0)
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_1394_REMOVE));
				resetFileAttrib(szPath);
				SAFECLOSE(stream);
				DestroyDynamicArray(&arrResults);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
			}

			// remove the /debugport=comport switch if it is present from the Boot Entry
			if (lstrlen(szTemp )!= 0)
			{
				removeSubString(szString,szTemp);
			}

			lstrcpy(szTemp , NULL_STRING );
				
			//remove the baud rate switch if it is present.
			GetBaudRateVal(szString,szTemp)	;
			if (lstrlen(szTemp )!= 0)
			{
				removeSubString(szString,szTemp);
				
			}	

		}
	
	}
	// if the user enters the EDIT  option
	else if(lstrcmpi(szDebug,SWITCH_EDIT)== 0)
	{
	
		//display error message if the /debugport=1394 switch is present already.
		if(_tcsstr(szString,DEBUGPORT_1394)!=0)
		{

			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_EDIT_1394_SWITCH));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;

		}

		if (_tcsstr(szString,DEBUG_SWITCH) == 0 )
		{
			_stprintf(szBuffer,GetResString(IDS_ERROR_NO_DBG_SWITCH), dwId );
			DISPLAY_MESSAGE(stderr,szBuffer);
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}

			lstrcpy(szTemp,NULL_STRING);
			dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);
			
		//display an error message if user is trying to add baudrate value
		// when there is no COM port present in the boot options.

		if( (lstrlen(szTemp)==0)&&(lstrlen(szPort)== 0)&&(lstrlen(szBaudRate)!= 0) )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_COM_PORT));
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			DestroyDynamicArray(&arrResults);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
		else
		{
			// chk if the port has been spec by the user
			
			if((lstrlen(szPort)== 0)&&(lstrlen(szBaudRate)== 0))
			{
				DestroyDynamicArray(&arrResults);
				DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
				resetFileAttrib(szPath);
				SAFECLOSE(stream);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
			}
		
						
			if(lstrlen(szPort)!= 0)
			{
				lstrcpy(szTemp , NULL_STRING );

				// get the type of the Com port present
						
				lstrcpy(szTemp,NULL_STRING);
				dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);
				
			
				//display error message if there is no COM port found at all in the OS option
				//changed for displaying error
				if(lstrlen(szTemp )== 0 )  
				{
					_stprintf(szBuffer,GetResString(IDS_ERROR_NO_COM_PORT), dwId );
					DISPLAY_MESSAGE(stderr,szBuffer);
					bRes = resetFileAttrib(szPath);
					SAFECLOSE(stream);
					DestroyDynamicArray(&arrResults);
					SafeCloseConnection(szServer,bConnFlag);
					return EXIT_FAILURE ;
					
				} 
			
				// remove the /debugport=comport switch if it is present from the Boot Entry
				removeSubString(szString,szTemp);
				lstrcpy(szTemp,TOKEN_DEBUGPORT) ;
				lstrcat(szTemp,TOKEN_EQUAL);
				
				CharUpper(szPort) ;
				lstrcat(szTemp,szPort);
								
				dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
				if (dwSectionFlag == MALLOC_FAILURE)
				{
					SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					DISPLAY_MESSAGE( stderr, ERROR_TAG);
					ShowLastError(stderr);	
					resetFileAttrib(szPath);
					SAFECLOSE(stream);
					DestroyDynamicArray(&arrResults);
					SafeCloseConnection(szServer,bConnFlag);
					return EXIT_FAILURE ;
				}
				
				if(lstrlen(szBoot)!= 0)
				{
					if (lstrcmpi(szBoot,szPort)==0)
					{
						DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_REDIRECT_PORT));
						resetFileAttrib(szPath);
						SAFECLOSE(stream);
						DestroyDynamicArray(&arrResults);
						SafeCloseConnection(szServer,bConnFlag);
						return EXIT_FAILURE ;

					}

				}

				

				//append the string containing the modified  port value to the string
				lstrcat(szString,TOKEN_EMPTYSPACE);
				lstrcat(szString,szTemp);

			}

			//to edit the baud rate value 
			if(lstrlen(szBaudRate)!= 0)
			{
			
				lstrcpy(szTemp , NULL_STRING );
				
				//remove the baud rate switch if it is present.
				GetBaudRateVal(szString,szTemp)	;
				
				// remove the swithc to be changed.
				removeSubString(szString,szTemp);
				
				//forming the string to be concatenated to the BootEntry string
				lstrcpy(szTemp,BAUD_RATE);
				lstrcat(szTemp,TOKEN_EQUAL);
				lstrcat(szTemp,szBaudRate);

				//append the string containing the modified  port value to the string
				lstrcat(szString,TOKEN_EMPTYSPACE);
				lstrcat(szString,szTemp);

			}

		}

	}

	//display an error message if the Os Load Options string is more than 
	// 254 characters in length.
	if( _tcslen(szString) >= MAX_RES_STRING)
	{		
		_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
		DISPLAY_MESSAGE( stderr,szErrorMsg);	
		SAFEFREE(szFinalStr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	DynArrayRemove(arrResults, dwId - 1 ); 
	DynArrayInsertString(arrResults, dwId - 1, szString, MAX_STRING_LENGTH1);

	// Variable storing the path of boot.ini file
	 szFinalStr = (TCHAR*)malloc(MAX_STRING_LENGTH1* sizeof(TCHAR));
	 if (szFinalStr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		SAFEFREE(szFinalStr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		ShowLastError(stderr);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	} 

	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs
	if (stringFromDynamicArray1( arrResults,szFinalStr) == EXIT_FAILURE)
	{
		DestroyDynamicArray(&arrResults);
		SAFEFREE(szFinalStr);
		resetFileAttrib(szPath);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}


	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		_stprintf(szBuffer,GetResString(IDS_SWITCH_CHANGE), dwId );
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_ADD_SWITCHES));
		DestroyDynamicArray(&arrResults);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	bRes = resetFileAttrib(szPath);

	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	SafeCloseConnection(szServer,bConnFlag);
	DestroyDynamicArray(&arrResults);
	return (bRes) ;
}



					
// ***************************************************************************
//
//  Routine Description	   :  Get the Type of Baud Rate  present in Boot Entry 
//
//  Parameters			   : szString : The String  which is to be searched.
//							 szTemp : String which will get the com port type
//  Return Type			   : VOID
//
// ***************************************************************************
VOID GetBaudRateVal(LPTSTR  szString, LPTSTR szTemp)
{
	
	if(_tcsstr(szString,BAUD_VAL6)!=0)
	{
	 	lstrcpy(szTemp,BAUD_VAL6);
	}
	else if(_tcsstr(szString,BAUD_VAL7)!=0)
	{
	 	lstrcpy(szTemp,BAUD_VAL7);
	}
	else if(_tcsstr(szString,BAUD_VAL8)!=0)
	{
	 	lstrcpy(szTemp,BAUD_VAL8);
	}
	else if(_tcsstr(szString,BAUD_VAL9)!=0)
	{
	 	lstrcpy(szTemp,BAUD_VAL9);
	}
	else if(_tcsstr(szString,BAUD_VAL10)!=0)
	{
	 	lstrcpy(szTemp,BAUD_VAL10);
	}

}
				

// ***************************************************************************
// Routine Description:
//		Implement the ProcessEmsSwitch switch.
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
//		
// ***************************************************************************

DWORD ProcessEmsSwitch(  DWORD argc, LPCTSTR argv[] )
{
	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bEms = FALSE ;

	DWORD dwId = 0;
	
	TARRAY arrResults ;
	TARRAY arrBootIni ;
	
	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	

	
	TCHAR szPort[MAX_RES_STRING] = NULL_STRING ;

	BOOL bRes = FALSE ;
	BOOL bFlag = FALSE ; 
	DWORD dwCount = 0 ;

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szDefault[MAX_RES_STRING] = NULL_STRING ;	
	TCHAR szString[MAX_STRING_LENGTH1] = NULL_STRING ;
	TCHAR  szBaudRate[MAX_RES_STRING] = NULL_STRING ;
	TCHAR  szBoot[MAX_RES_STRING] = NULL_STRING ;
	LPTSTR szFinalStr = NULL ;
	BOOL bRedirectFlag = FALSE ;
	TCHAR szRedirectBaudrate[MAX_RES_STRING] = NULL_STRING ;	

	BOOL bRedirectBaudFlag = FALSE ;

	TCHAR szErrorMsg[MAX_RES_STRING] = NULL_STRING ;	

	DWORD dwSectionFlag = FALSE ;

	TCHAR szDebugPort[MAX_RES_STRING] = NULL_STRING ;

	TCHAR szBootString[MAX_RES_STRING] = NULL_STRING ;
	DWORD dwI = 0 ;

	BOOL bMemFlag = FALSE ;
	BOOL bDefault = FALSE ;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;

	 TCMDPARSER cmdOptions[] = 
	 {
	
		{ CMDOPTION_EMS,     CP_MAIN_OPTION, 1, 0,&bDefault, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY , 1, 0, &dwId,    NULL_STRING, NULL, NULL },
		{ SWITCH_PORT,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY|CP_MODE_VALUES,1,0,&szPort,EMS_PORT_VALUES,NULL,NULL},
		{ SWITCH_BAUD,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY |CP_MODE_VALUES,1,0,&szBaudRate,BAUD_RATE_VALUES_EMS,NULL,NULL},
		{ CMDOPTION_DEFAULT, CP_DEFAULT | CP_TYPE_TEXT | CP_MANDATORY , 1, 0, &szDefault,NULL_STRING, NULL, NULL }
	 }; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{

		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	}

	
	if(bUsage)
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayEmsUsage_X86() ;
			return (EXIT_SUCCESS) ;
		}else
		{
			return (EXIT_FAILURE);
		}

	}

	
	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);
		}
	}
		
	//display an error message if the server is empty.  	
	if( (cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}
	
	
	//display error message if the user enters any invalid string.
	if( !( ( lstrcmpi(szDefault,VALUE_ON)== 0) || (lstrcmpi(szDefault,VALUE_OFF)== 0 ) ||(lstrcmpi(szDefault,EDIT_STRING)== 0) ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
		return EXIT_FAILURE;

	} 


	if( (lstrcmpi(szDefault,EDIT_STRING)== 0)&& (lstrlen(szPort)==0) && (lstrlen(szBaudRate)==0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_EDIT_SYNTAX));
		return EXIT_FAILURE;
	}

	if( ( (lstrcmpi(szDefault,ON_STRING)== 0) || (lstrcmpi(szDefault,OFF_STRING)== 0) )&& (cmdOptions[5].dwActuals==0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ID_MISSING));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_EMS_HELP));
		return EXIT_FAILURE;
	}


	
	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection

	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}


	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
	}


	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	
	arrResults = CreateDynamicArray();
 
	//return failure if failed to allocate memory
	if(arrResults == NULL) 
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return (EXIT_FAILURE);					
	} 


	arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
	if(arrResults != NULL)
	{
		lstrcpy(szString ,DynArrayItemAsString(arrResults, dwId - 1 ));
	}
	else
	{
		bMemFlag = TRUE ;
	}

	if((szString == NULL)||(bMemFlag == TRUE ))
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arrResults);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;

	}
 
	//getting the number of boot entries 
	dwCount = DynArrayGetCount(arrResults);
	if((dwId<=0 || dwId > dwCount ) && (lstrcmpi(szDefault,SWITCH_EDIT)!= 0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_OSID));
		DestroyDynamicArray(&arrResults);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		SAFECLOSE(stream);
		return EXIT_FAILURE ;
	}

	// common code till here . from here process acc to the ON/OFF/EDIT flag.
 	if(lstrcmpi(szDefault,ON_STRING)==0)
	{ 
		if((_tcsstr(szString,REDIRECT) != 0))
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_REDIRECT_SWITCH));
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;

		}
		

		//Display an error message if there is no redirect port present in the
		// bootloader section and the user also does not specify the COM port.
		if ((lstrlen(szPort)== 0))
		{
			dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
			if (dwSectionFlag == MALLOC_FAILURE)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);
				DestroyDynamicArray(&arrResults);
				SAFECLOSE(stream);
				resetFileAttrib(szPath);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE;
		
			}
			if(lstrlen(szBoot)== 0 )
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NO_PORT));
				DestroyDynamicArray(&arrResults);
				SAFECLOSE(stream);
				resetFileAttrib(szPath);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE;
			}

		}
		

		if(lstrlen(szPort)!= 0)
		{
			
			dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,BAUDRATE_STRING,szRedirectBaudrate);
			if (dwSectionFlag == MALLOC_FAILURE)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);
				DestroyDynamicArray(&arrResults);
				SAFECLOSE(stream);
				resetFileAttrib(szPath);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE;
		
			}

			dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
			if (dwSectionFlag == MALLOC_FAILURE)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE( stderr, ERROR_TAG);
				ShowLastError(stderr);
				DestroyDynamicArray(&arrResults);
				SAFECLOSE(stream);
				resetFileAttrib(szPath);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE;
		
			}

			//display warning message if the redirect=COMX entry is already present in the BootLoader section.	
			if(lstrlen(szBoot)!= 0 )
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_WARN_REDIRECT));
				bRedirectFlag = TRUE ;
			}

			if( (lstrlen(szRedirectBaudrate)!=0)&&(lstrlen(szBaudRate)!= 0 ))
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_WARN_REDIRECTBAUD));
				bRedirectBaudFlag = TRUE ;
			}


			// if the Boot loader section does not
			// contain any port for redirection.
			if(!bRedirectFlag)
			{
				if (lstrcmpi(szPort,USEBIOSSET)== 0)
				{
					lstrcpy(szPort,USEBIOSSETTINGS);
				}


				
				// scan the entire BOOT.INI and check if the specified Port 
				lstrcpy(szDebugPort,DEBUGPORT);
				lstrcat(szDebugPort,szPort);

				arrBootIni = getKeyValueOfINISection( szPath, OS_FIELD );
				if(arrBootIni == NULL)
				{
					SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					DISPLAY_MESSAGE( stderr, ERROR_TAG);
					ShowLastError(stderr);
					resetFileAttrib(szPath);
					SafeCloseConnection(szServer,bConnFlag);
					DestroyDynamicArray(&arrResults);
					SAFECLOSE(stream);
					return EXIT_FAILURE ;
				}

				//
				//loop through all the OS entries and check if any of the
				// 
				for(dwI = 0 ;dwI < dwCount-1 ; dwI++ )
				{
					lstrcpy(szBootString ,DynArrayItemAsString(arrBootIni,dwI));
					CharLower(szDebugPort);
					if(_tcsstr(szBootString,szDebugPort)!= 0)
					{
						DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_DEBUG_PORT));
						resetFileAttrib(szPath);
						SafeCloseConnection(szServer,bConnFlag);
						DestroyDynamicArray(&arrResults);
						DestroyDynamicArray(&arrBootIni);
						SAFECLOSE(stream);
						return EXIT_FAILURE ;
					}

				}

				

				//convert the com port value specified by user to upper case for storing into the ini file.
				CharUpper(szPort);
				if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_REDIRECT,szPort, szPath ) != 0 )
				{
					DISPLAY_MESSAGE(stdout,GetResString(IDS_EMS_CHANGE_BOOTLOADER));
				}
				else
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BLOADER));
					resetFileAttrib(szPath);
					SafeCloseConnection(szServer,bConnFlag);
					DestroyDynamicArray(&arrResults);
					DestroyDynamicArray(&arrBootIni);
					SAFECLOSE(stream);
					return EXIT_FAILURE ;
				}
			}

		}

		if(!bRedirectBaudFlag)
		{
			// to add the baudrate to the BOOTLOADER section. 
			if(lstrlen(szBaudRate) != 0 )
			{
				
				if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_BAUDRATE,szBaudRate, szPath ) != 0 )
				{
					DISPLAY_MESSAGE(stdout,GetResString(IDS_EMS_CHANGE_BAUDRATE));
				}
				else
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BAUDRATE));
					resetFileAttrib(szPath);
					SafeCloseConnection(szServer,bConnFlag);
					DestroyDynamicArray(&arrResults);
					DestroyDynamicArray(&arrBootIni);
					SAFECLOSE(stream);
					return EXIT_FAILURE ;
				}
			}

		}

		//add the /redirect into the OS options.

		lstrcat(szString,TOKEN_EMPTYSPACE);
		lstrcat(szString,REDIRECT);

		//display an error message if the Os Load Options string is more than 
		// 254 characters in length.
		if( _tcslen(szString) >= MAX_RES_STRING)
		{		
			_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
			DISPLAY_MESSAGE( stderr,szErrorMsg);	
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			DestroyDynamicArray(&arrBootIni);
			SAFECLOSE(stream);
			return (EXIT_FAILURE);

		}
	

		DynArrayRemove(arrResults, dwId - 1 ); 
		DynArrayInsertString(arrResults, dwId - 1, szString, MAX_STRING_LENGTH1);

		szFinalStr = (TCHAR*)malloc(MAX_STRING_LENGTH1* sizeof(TCHAR));
		if (szFinalStr == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			DestroyDynamicArray(&arrBootIni);
			SAFECLOSE(stream);
			return (EXIT_FAILURE);
		} 

		// Setting the buffer to 0, to avoid any junk value
		memset(szFinalStr, 0, MAX_STRING_LENGTH1);

		// Forming the final string from all the key-value pairs
		if (stringFromDynamicArray1( arrResults,szFinalStr) == EXIT_FAILURE)
		{
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			DestroyDynamicArray(&arrBootIni);
			SAFECLOSE(stream);
			return EXIT_FAILURE;
		}

		 // Writing to the profile section with new key-value pair
		 // If the return value is non-zero, then there is an error.
		 if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
		 {
			_stprintf(szBuffer,GetResString(IDS_SWITCH_CHANGE), dwId );
			DISPLAY_MESSAGE(stdout,szBuffer);
		 }
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_ADD_SWITCHES));
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			DestroyDynamicArray(&arrBootIni);
			SAFECLOSE(stream);
			return (EXIT_FAILURE);	
		}

	}

	if(lstrcmpi(szDefault,EDIT_STRING)==0)
	{
		//display error message if user enters a id for the edit option.
		if(dwId!=0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			return EXIT_FAILURE ;
		}
		
		if (lstrcmpi(szPort,USEBIOSSET)== 0)
		{
			lstrcpy(szPort,USEBIOSSETTINGS);
		}
		
		//get the keys of the specified ini section.
		dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,BAUDRATE_STRING,szRedirectBaudrate);
		if (dwSectionFlag == MALLOC_FAILURE)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
	
		}

		//get the keys of the specified ini section.
		dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
		if (dwSectionFlag == MALLOC_FAILURE)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
	
		}

		if( (lstrlen(szBoot) == 0 ) && ((cmdOptions[6].dwActuals!=0)) )
		{
			DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_COM_PORT));
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
		
		}
	
		if( (lstrlen(szRedirectBaudrate) == 0 ) && ((cmdOptions[7].dwActuals!=0)) )
		{
			
			DISPLAY_MESSAGE( stderr,GetResString(IDS_ERROR_BAUDRATE_HELP));
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
		
		}

		
		
		lstrcpy(szDebugPort,DEBUGPORT);
		lstrcat(szDebugPort,szPort);

		arrBootIni = getKeyValueOfINISection( szPath, OS_FIELD );
		if(arrBootIni == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			DestroyDynamicArray(&arrResults);
			SAFECLOSE(stream);
			return EXIT_FAILURE ;
		}

		//
		//loop through all the OS entries and check if any of the
		// 
		for(dwI = 0 ;dwI < dwCount-1 ; dwI++ )
		{
			lstrcpy(szBootString ,DynArrayItemAsString(arrBootIni,dwI));
			CharLower(szDebugPort);
			if(_tcsstr(szBootString,szDebugPort)!= 0)
			{
				DISPLAY_MESSAGE( stderr, GetResString(IDS_ERROR_DEBUG_PORT));
				resetFileAttrib(szPath);
				SafeCloseConnection(szServer,bConnFlag);
				DestroyDynamicArray(&arrResults);
				DestroyDynamicArray(&arrBootIni);
				SAFECLOSE(stream);
				return EXIT_FAILURE ;
			}

		} 


		// edit the Boot loader section with the redirect values entered by the user.
		CharUpper(szPort);
		if(lstrlen(szPort)!= 0)
		{
			if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_REDIRECT, 
			szPort, szPath ) != 0 )
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_EMS_CHANGE_BOOTLOADER));
			}
			else
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BLOADER));
				resetFileAttrib(szPath);
				SAFEFREE(szFinalStr);
				DestroyDynamicArray(&arrResults);
				DestroyDynamicArray(&arrBootIni);
				SafeCloseConnection(szServer,bConnFlag);
				SAFECLOSE(stream);
				return EXIT_FAILURE ;
			}
		}

		// edit the Boot loader section with the baudrate values entered by the user.
		if(lstrlen(szBaudRate)!= 0)
		{
			
			if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_BAUDRATE, 
				szBaudRate, szPath ) != 0 )
			{
					DISPLAY_MESSAGE(stdout,GetResString(IDS_EMS_CHANGE_BAUDRATE));
			}
			else
			{
				DISPLAY_MESSAGE(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BAUDRATE));
				resetFileAttrib(szPath);
				SAFEFREE(szFinalStr);
				DestroyDynamicArray(&arrResults);
				DestroyDynamicArray(&arrBootIni);
				SAFECLOSE(stream);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
			}


		}

	}

	// if the option value is off.
	if(lstrcmpi(szDefault,VALUE_OFF)==0)
	{
	
		//display an error message if either the com port or baud rate is typed in the command line
		if((lstrlen(szBaudRate)!=0)||(lstrlen(szPort)!=0))
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));		
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
		}
		
		// display error message if the /redirect  switch is not present in the Boot.ini
		if((_tcsstr(szString,REDIRECT) == 0))
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_REDIRECT_SWITCH));
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;

		}
		

		
		

		//remove the /redirect switch from the OS entry specified .
		removeSubString(szString,REDIRECT);

		//display an error message if the Os Load options string is more than 
		// 255 characters in length.

		if( _tcslen(szString) >= MAX_RES_STRING)
		{		
			_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
			DISPLAY_MESSAGE( stderr,szErrorMsg);	
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return (EXIT_FAILURE);
		
		}

		DynArrayRemove(arrResults, dwId - 1 ); 
		DynArrayInsertString(arrResults, dwId - 1, szString, MAX_STRING_LENGTH1);

		szFinalStr = (TCHAR*)malloc(MAX_STRING_LENGTH1* sizeof(TCHAR));
		if (szFinalStr == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return (EXIT_FAILURE);
		} 

		// Setting the buffer to 0, to avoid any junk value
		memset(szFinalStr, 0, MAX_STRING_LENGTH1);

		// Forming the final string from all the key-value pairs
		if (stringFromDynamicArray1( arrResults,szFinalStr) == EXIT_FAILURE)
		{
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			resetFileAttrib(szPath);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE;
		}

		 // Writing to the profile section with new key-value pair
		 // If the return value is non-zero, then there is an error.
		if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
		{
			_stprintf(szBuffer,GetResString(IDS_SWITCH_CHANGE), dwId );
			DISPLAY_MESSAGE(stdout,szBuffer);
		}
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_ADD_SWITCHES));
			DestroyDynamicArray(&arrResults);
			SAFEFREE(szFinalStr);
			resetFileAttrib(szPath);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return (EXIT_FAILURE);	
		}
	

	}

	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arrResults);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes) ; 
}


// ***************************************************************************
//  Routine Description		   :  Display the help for the Ems entry option (X86).
//
//  Parameters				   : none
//				         
//  Return Type				   : VOID
//  
// ***************************************************************************

VOID displayEmsUsage_X86()
{
	DWORD dwIndex = IDS_EMS_BEGIN_X86 ; 
	

	for(;dwIndex <=IDS_EMS_END_X86;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}



// ***************************************************************************
//   Routine Description		   :  Display the help for the Debug  entry option (X86).
//
//  Parameters					   : none
//				         
//  Return Type					   : VOID
// ***************************************************************************
VOID displayDebugUsage_X86()
{
	DWORD dwIndex = IDS_DEBUG_BEGIN_X86 ;
	

	for(;dwIndex <=IDS_DEBUG_END_X86;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//  Routine Description		   :  Display the help for the Ems entry option (IA64).
//
//  Parameters		   : none
//				         
//  Return Type	       : VOID
//  
// ***************************************************************************
VOID displayEmsUsage_IA64()
{
	DWORD dwIndex = IDS_EMS_BEGIN_IA64 ; 
	

	for(;dwIndex <=IDS_EMS_END_IA64;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
} 


// ***************************************************************************
//  Routine Description		   :  Display the help for the Debug  entry option (IA64).
//
//  Parameters		   : none
//				         
//  Return Type	       : VOID
// ***************************************************************************
VOID displayDebugUsage_IA64()
{
	DWORD dwIndex = IDS_DEBUG_BEGIN_IA64 ; 
	

	for(;dwIndex <= IDS_DEBUG_END_IA64 ;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}



// ***************************************************************************
//  Routine Description		   : This function gets all the keys present in the specified section of 
//								 an .ini file and then returns the dynamic array containing all the
//								 keys
//	     
//  Parameters				   : LPTSTR sziniFile (in)    - Name of the ini file.
//								 LPTSTR szinisection (in) - Name of the section in the boot.ini.
//
//  Return Type	       : TARRAY ( pointer to the dynamic array )
//  
// ***************************************************************************
 
DWORD getKeysOfSpecifiedINISection( LPTSTR sziniFile, LPTSTR sziniSection,LPCWSTR szKeyName ,LPTSTR szValue)
{

	
	// Number of characters returned by the GetPrivateProfileString function
	DWORD len = 0;


	DWORD dwLength = MAX_STRING_LENGTH1 ;

		// Buffer which will be populated by the GetPrivateProfileString function
	LPTSTR inBuf = NULL ; 

	inBuf = (LPTSTR)malloc(dwLength*sizeof(TCHAR));

	if(inBuf == NULL)
	{
		return MALLOC_FAILURE ; 
	}


	while(1)
	{
		// Getting all the keys from the boot.ini file
		len = GetPrivateProfileString 
							(sziniSection, 
							 szKeyName, 
						     ERROR_PROFILE_STRING1, 
						     inBuf,
						     dwLength, 
						     sziniFile); 
	
			
		//if the size of the string is not sufficient then increment the size. 
		if(len == dwLength-2)
		{
			dwLength +=100 ;

			inBuf = (LPTSTR)realloc(inBuf,dwLength*sizeof(TCHAR));
			if(inBuf == NULL)
			{
                SAFEFREE(inBuf);
				return MALLOC_FAILURE;
			}
		}
		else
			break ;
	}
		
	//copy the value into the destination buffer only if
    // the size is less than 255 else return FAILURE.
    //
    if(lstrlen(inBuf) <= MAX_RES_STRING)
    {
	    lstrcpy(szValue,inBuf);
    }
    else
    {
        SAFEFREE(inBuf);
        return MALLOC_FAILURE;
    }

	SAFEFREE(inBuf);
	return EXIT_SUCCESS ;
}


// ***************************************************************************
// Routine Description:
//		Implement the Add Switch switch.
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
//		
// ***************************************************************************

DWORD ProcessAddSwSwitch(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bAddSw = FALSE ;

	DWORD dwDefault = 0;
	

	TARRAY arr ;
	TCHAR szkey[MAX_STRING_LENGTH1] = NULL_STRING;

	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	
	
	DWORD dwNumKeys = 0;
	BOOL bRes = FALSE ;
	LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ; 
	TCHAR szMaxmem[10] = NULL_STRING ; 

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szErrorMsg[MAX_RES_STRING] = NULL_STRING ;
	BOOL bBaseVideo = FALSE ;
	BOOL bSos = FALSE ;
	BOOL bNoGui = FALSE ;
	DWORD dwMaxmem = 0 ;
	BOOL bErrorFlag = FALSE ;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;

	  TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_ADDSW,     CP_MAIN_OPTION, 1, 0,&bAddSw, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY|CP_MANDATORY , 1, 0, &dwDefault,    NULL_STRING, NULL, NULL },
		{ SWITCH_MAXMEM,		 CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY,1,0,&dwMaxmem,NULL_STRING,NULL,NULL},
		{ SWITCH_BASEVIDEO,		 0,1,0,&bBaseVideo,NULL_STRING,NULL,NULL},
		{ SWITCH_NOGUIBOOT,		 0,1,0,&bNoGui,NULL_STRING,NULL,NULL},
		{ SWITCH_SOS,		 0,1,0,&bSos,NULL_STRING,NULL,NULL},
	 }; 

	 //
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);
  

	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	}


	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayAddSwUsage_X86();
			return (EXIT_SUCCESS);
		}else
		{
			return (EXIT_FAILURE);
		}
	}


	if( (cmdOptions[6].dwActuals!=0) && (dwMaxmem < 32 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
		return EXIT_FAILURE ; 

	} 

	//display an error message if the user does not enter even one of 
	if((dwMaxmem==0)&& (!bBaseVideo)&& (!bNoGui)&&(!bSos) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
		return EXIT_FAILURE ;
	}


	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}

	

	szFinalStr = (TCHAR*) malloc(MAX_STRING_LENGTH1* sizeof(TCHAR) );
	if (szFinalStr== NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TAG));
		ShowLastError(stderr);
		return (EXIT_FAILURE);
		
	}


	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				SAFEFREE(szFinalStr);
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));

	}


	 bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

		
	// Getting the keys of the Operating system section in the boot.ini file
	arr = getKeyValueOfINISection( szPath, OS_FIELD );

	if(arr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	// Getting the total number of keys in the operating systems section
	dwNumKeys = DynArrayGetCount(arr);

	 
	if((dwNumKeys >= MAX_BOOTID_VAL)&& (dwDefault >= MAX_BOOTID_VAL ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAX_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

	// Displaying error message if the number of keys is less than the OS entry
	// line number specified by the user
	if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Getting the key of the OS entry specified by the user	
	if (arr != NULL)
	{
		LPCWSTR pwsz = NULL;
		pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
		if(pwsz != NULL)
		{
			_tcscpy( szkey,pwsz);
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	//if the  max mem switch is specified by the user.
	if(dwMaxmem != 0)
	{

		if(_tcsstr(szkey,MAXMEM_VALUE1) != 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_MAXMEM_SWITCH));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
			lstrcat(szkey , TOKEN_EMPTYSPACE);
			lstrcat(szkey ,MAXMEM_VALUE1);
			lstrcat(szkey,TOKEN_EQUAL);
			_ltow(dwMaxmem,szMaxmem,10);
			lstrcat(szkey,szMaxmem);
		}
	}

	// if the base video is specified by the user.
	if (bBaseVideo)
	{
		if(_tcsstr(szkey,BASEVIDEO_VALUE) != 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_BASEVIDEO_SWITCH));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
			lstrcat(szkey , TOKEN_EMPTYSPACE);
			lstrcat(szkey ,BASEVIDEO_SWITCH);
		}

	}

	// if the SOS is specified by the user.
   if(bSos)
	{
		if(_tcsstr(szkey,SOS_VALUE) != 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_SOS_SWITCH ) );
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
			lstrcat(szkey , TOKEN_EMPTYSPACE);
			lstrcat(szkey ,SOS_SWITCH);
		}
	}

   // if the noguiboot  is specified by the user.
   if(bNoGui)
	{
		if(_tcsstr(szkey,NOGUI_VALUE) != 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_NOGUI_SWITCH));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{	
			lstrcat(szkey , TOKEN_EMPTYSPACE);
			lstrcat(szkey ,NOGUI_VALUE );
		}
	}
	
	if( _tcslen(szkey) >= MAX_RES_STRING)
	{		
		_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
		DISPLAY_MESSAGE( stderr,szErrorMsg);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}

	DynArrayRemove(arr, dwDefault - 1 );
	DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_STRING_LENGTH1);


	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs

	if (stringFromDynamicArray1( arr,szFinalStr) == EXIT_FAILURE)
	{
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		
		_stprintf(szBuffer,GetResString(IDS_SWITCH_ADD), dwDefault );
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}
	else
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_ADD_SWITCHES));
		DestroyDynamicArray(&arr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	//reset the file attributes and free the memory and close the connection to the server.
	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arr);
	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes);

}

// ***************************************************************************
// Routine Description:
//		This routine is to remove  the switches to the  boot.ini file settings for 
//		the specified system.
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
//		
// ***************************************************************************

DWORD ProcessRmSwSwitch(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bRmSw = FALSE ;

	DWORD dwDefault = 0;

	TARRAY arr = NULL ;
	

	TCHAR szkey[MAX_STRING_LENGTH1] = NULL_STRING;

	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	
	

	TCHAR szTmp[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szChangeKeyValue[MAX_RES_STRING] = NULL_STRING ;

	DWORD dwNumKeys = 0;
	BOOL bRes = FALSE ;
	PTCHAR pToken = NULL ;
	LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ; 
	TCHAR szMaxmem[STRING10] = NULL_STRING ; 

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szDefault[MAX_RES_STRING] = NULL_STRING ;
	BOOL bBaseVideo = FALSE ;
	BOOL bSos = FALSE ;
	BOOL bNoGui = FALSE ;
	

	DWORD bMaxmem = FALSE ;
	BOOL bErrorFlag = FALSE ;
	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ;

	TCHAR szString[MAX_RES_STRING] = NULL_STRING ;


	LPTSTR szSubString = NULL ; 

	DWORD dwCode = 0;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0;
	BOOL bConnFlag = FALSE ;

	 TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_RMSW,     CP_MAIN_OPTION, 1, 0,&bRmSw, NULL_STRING, NULL, NULL },
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY|CP_MANDATORY , 1, 0, &dwDefault,    NULL_STRING, NULL, NULL },
		{ SWITCH_MAXMEM,     0,1,0,&bMaxmem,NULL_STRING,NULL,NULL},
		{ SWITCH_BASEVIDEO,	 0,1,0,&bBaseVideo,NULL_STRING,NULL,NULL},
		{ SWITCH_NOGUIBOOT,	 0,1,0,&bNoGui,NULL_STRING,NULL,NULL},
		{ SWITCH_SOS,		 0,1,0,&bSos,NULL_STRING,NULL,NULL},
	 }; 

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}

	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);

	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	}

	
	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayRmSwUsage_X86();
			return (EXIT_SUCCESS);
		}else
		{
			return (EXIT_FAILURE);
		}

	}


	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}
	
	
	//display an error mesage if none of the options are specified.
	if((!bSos)&&(!bBaseVideo)&&(!bNoGui)&&(!bMaxmem))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_RMSW));
		return EXIT_FAILURE ;
	}

	
	//display a warning message if the user specifies local system name 
	// with -s.
	

	szFinalStr = (TCHAR*) malloc(MAX_STRING_LENGTH1* sizeof(TCHAR) );
	if (szFinalStr== NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TAG));
		ShowLastError(stderr);
		return (EXIT_FAILURE);
		
	}


	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );

	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				SAFEFREE(szFinalStr);
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	
	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
		
	}


	 bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}



	// Getting the keys of the Operating system section in the boot.ini file
	arr = getKeyValueOfINISection( szPath, OS_FIELD );

	if(arr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	// Getting the total number of keys in the operating systems section
	dwNumKeys = DynArrayGetCount(arr);

	 
	if( (dwNumKeys >= MAX_BOOTID_VAL)&&(dwDefault >= MAX_BOOTID_VAL ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAX_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

	// Displaying error message if the number of keys is less than the OS entry
	// line number specified by the user
	if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Getting the key of the OS entry specified by the user	
	if (arr != NULL)
	{
		LPCWSTR pwsz = NULL;
		pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
		if(pwsz != NULL)
		{
			_tcscpy( szkey,pwsz);
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			bRes = resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		bRes = resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}


	//if the  max mem switch is specified by the user.
	if(bMaxmem==TRUE)
	{
			
		if(_tcsstr(szkey,MAXMEM_VALUE1) == 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_MAXMEM_SWITCH));
			bRes = resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
		
			szSubString = ( LPTSTR ) malloc( MAX_RES_STRING*sizeof( TCHAR ) );
			if(szSubString == NULL)
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
				DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TAG));
				ShowLastError(stderr);
				bRes = resetFileAttrib(szPath);
				DestroyDynamicArray(&arr);
				SAFEFREE(szFinalStr);
				SAFECLOSE(stream);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE;
			}

			lstrcpy(szTemp,NULL_STRING);
			dwCode = GetSubString(szkey,MAXMEM_VALUE1,szSubString);
				
			//remove the substring specified.
			if(dwCode == EXIT_SUCCESS)
			{
				removeSubString(szkey,szSubString);
			}

		}
	}

	// if the base video is specified by the user.
	if (bBaseVideo==TRUE)
	{
		if(_tcsstr(szkey,BASEVIDEO_VALUE) == 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_BV_SWITCH));
			bRes = resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
			removeSubString(szkey,BASEVIDEO_VALUE);
		}
	}

	// if the SOS is specified by the user.
   if(bSos==TRUE)
	{
	   	if(_tcsstr(szkey,SOS_VALUE) == 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_SOS_SWITCH ) );
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{
			removeSubString(szkey,SOS_VALUE);
		}
	}

   // if the noguiboot  is specified by the user.
   if(bNoGui==TRUE)
	{
	   	
		if(_tcsstr(szkey,NOGUI_VALUE) == 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_NOGUI_SWITCH));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ; 
		}
		else
		{	
				removeSubString(szkey,NOGUI_VALUE);
		}
	}
	
	DynArrayRemove(arr, dwDefault - 1 );
	DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_STRING_LENGTH1);


	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs

	if (stringFromDynamicArray1( arr,szFinalStr) == EXIT_FAILURE)
	{
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		
		_stprintf(szBuffer,GetResString(IDS_SWITCH_DELETE), dwDefault );
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}
	else
	{
		_stprintf(szBuffer,GetResString(IDS_NO_SWITCH_DELETE), dwDefault );
		DISPLAY_MESSAGE(stderr,szBuffer);
		DestroyDynamicArray(&arr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	//reset the file attributes and free the memory and close the connection to the server.
	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arr);
	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	SafeCloseConnection(szServer,bConnFlag);
	return (EXIT_SUCCESS);

}


// ***************************************************************************
//  Routine Description	 :  Display the help for the AddSw entry option (X86).
//
//  Parameters			 : none
//				         
//  Return Type	         : VOID
//  
// ***************************************************************************
VOID displayAddSwUsage_X86()
{
	DWORD dwIndex = IDS_ADDSW_BEGIN_X86 ; 
	for(;dwIndex <=IDS_ADDSW_END_X86;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//  Routine Description	 :  Display the help for the AddSw entry option (IA64).
//
//  Arguments				: none
//				         
//  Return Type			     : VOID
//  
// ***************************************************************************
VOID displayAddSwUsage_IA64()
{
	DWORD dwIndex = IDS_ADDSW_BEGIN_IA64 ; 
	

	for(;dwIndex <=IDS_ADDSW_END_IA64;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//
//  Routine Description	 :  Display the help for the RmSw entry option (IA64).
//
//  Arguments		   : none
//				         
//  Return Type	       : VOID
//
// ***************************************************************************
VOID displayRmSwUsage_IA64()
{
	DWORD dwIndex = IDS_RMSW_BEGIN_IA64 ; 
	

	for(;dwIndex <=IDS_RMSW_END_IA64;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//
//  Routine Description	 :  Display the help for the RmSw entry option (X86).
//
//  Arguments		   : none
//				         
//  Return Type	       : VOID
//
// ***************************************************************************
VOID displayRmSwUsage_X86()
{
	DWORD dwIndex = IDS_RMSW_BEGIN_X86 ; 
	

	for(;dwIndex <=IDS_RMSW_END_X86;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}



// ***************************************************************************
//
//  Routine Description			:  This function retreives a part of the string.
//
//  Parameters					: 
//			LPTSTR szString (in)  - String in which substring is to be found.
//          LPTSTR szPartString (in)  - Part String whose remaining substring is to be found.
//			LPTSTR pszFullString (out)  - String in which substring is to be found. 
// 
//				         
//  Return Type	       : DWORD
//
//  
// ***************************************************************************
DWORD GetSubString(LPTSTR szString,LPTSTR szPartString,LPTSTR pszFullString)
{

	TCHAR szTemp[MAX_RES_STRING]= NULL_STRING ;
	PTCHAR pszMemValue = NULL ;
	PTCHAR pszdest = NULL ;
	
#ifndef _WIN64
	DWORD dwPos = 0;
#else
	INT64 dwPos = 0;
#endif

	pszMemValue = _tcsstr(szString,szPartString);
	if(pszMemValue == NULL)
	{
		return EXIT_FAILURE ;
	}
	
	//copy the remaining part of the string into a buffer
	lstrcpy(szTemp,pszMemValue);
	
	
	//search for the empty space.
	pszdest = _tcschr(szTemp,_T(' '));
	if (pszdest==NULL)
	{
		//the api returns NULL if it is not able to find the 
		// character . This means that the required switch is at the end 
		//of the string . so we are copying it fully
		lstrcpy(pszFullString,szTemp);
		return EXIT_SUCCESS ;			
	}

	dwPos = pszdest - szTemp ;
	szTemp[dwPos] = _T('\0');


	lstrcpy(pszFullString,szTemp);

	return EXIT_SUCCESS ;
}


// ***************************************************************************
// Routine Description:
//		This routine is to add/remove  the /debugport=1394 
//		switches to the  boot.ini file settings for the specified system.	 
// Arguments:
//		[IN]	argc  Number of command line arguments
//		[IN]	argv  Array containing command line arguments
//
// Return Value:
//		DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
//		
// ***************************************************************************
DWORD ProcessDbg1394Switch(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bNeedPwd = FALSE ;
	BOOL bDbg1394 = FALSE ;

	DWORD dwDefault = 0;
	TARRAY arr ;
	TCHAR szkey[MAX_RES_STRING] = NULL_STRING;

	FILE *stream = NULL;
	
	// Initialising the variables that are passed to TCMDPARSER structure
	STRING256 szServer        = NULL_STRING; 
	STRING256 szUser          = NULL_STRING; 
	STRING256 szPassword      = NULL_STRING;
	STRING100 szPath          = NULL_STRING;	
	
	
	DWORD dwNumKeys = 0;
	BOOL bRes = FALSE ;
	
	
	LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ; 
	TCHAR szMaxmem[STRING10] = NULL_STRING ; 

	TCHAR szBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szDefault[MAX_RES_STRING] = NULL_STRING ;
	
	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ;

	TCHAR szErrorMsg[MAX_RES_STRING] = NULL_STRING ;

	LPTSTR szSubString = NULL ; 

	DWORD dwCode = 0;

	DWORD dwChannel = 0;

	TCHAR szChannel[MAX_RES_STRING] = NULL_STRING ;
	LPCTSTR szToken = NULL ;
	DWORD dwRetVal = 0 ;
	BOOL bConnFlag = FALSE ;

	TCMDPARSER cmdOptions[] = 
	 {
	
		{ CMDOPTION_DBG1394, CP_MAIN_OPTION, 1, 0,&bDbg1394,NULL_STRING , NULL, NULL }, 
		{ SWITCH_SERVER,     CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szServer,   NULL_STRING, NULL, NULL },
		{ SWITCH_USER,       CP_TYPE_TEXT | CP_VALUE_MANDATORY,    1, 0, &szUser,     NULL_STRING, NULL, NULL },
		{ SWITCH_PASSWORD,   CP_TYPE_TEXT | CP_VALUE_OPTIONAL,    1, 0, &szPassword, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY| CP_MANDATORY , 1, 0, &dwDefault,    NULL_STRING, NULL, NULL }, 
		{ CMDOPTION_CHANNEL, CP_TYPE_NUMERIC | CP_VALUE_MANDATORY,1,0,&dwChannel,NULL_STRING,NULL,NULL},
		{ CMDOPTION_DEFAULT, CP_DEFAULT|CP_TYPE_TEXT | CP_MANDATORY, 1, 0, &szDefault,NULL_STRING, NULL, NULL } 
	 
	};  

	//
	//check if the remote system is 64 bit and if so
    // display an error.
	//
	dwRetVal = CheckSystemType( szServer);
	if(dwRetVal==EXIT_FAILURE )	
	{
		return EXIT_FAILURE ;
	}
	
	//copy the Asterix token which is required for password prompting.
	_tcscpy(cmdOptions[3].szValues,TOKEN_ASTERIX) ;	
	_tcscpy(szPassword,TOKEN_ASTERIX);

	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (EXIT_FAILURE);
	}


	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		dwRetVal = CheckSystemType( szServer);
		if(dwRetVal==EXIT_SUCCESS )	
		{
			displayDbg1394Usage_X86();
			return (EXIT_SUCCESS);
		}else
		{
			return (EXIT_FAILURE);
		}
	}

	//
	//display error message if user enters a value
	// other than on or off
	//
	if( ( lstrcmpi(szDefault,OFF_STRING)!=0 ) && (lstrcmpi(szDefault,ON_STRING)!=0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DEFAULT_MISSING));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_1394_HELP));
		return (EXIT_FAILURE);
	}

	if((cmdOptions[5].dwActuals == 0) &&(dwDefault == 0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ID_MISSING));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_1394_HELP));
		return (EXIT_FAILURE);
	}

	if(( lstrcmpi(szDefault,OFF_STRING)==0 ) &&(dwChannel != 0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
		return (EXIT_FAILURE);
	}
	
	
	if( ( lstrcmpi(szDefault,ON_STRING)==0 ) && (cmdOptions[6].dwActuals != 0) && ( (dwChannel < 1) ||(dwChannel > 64 )) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_CH_RANGE));
		return (EXIT_FAILURE);
	}
	
	
	//display error message if the username is entered with out a machine name
	if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
	{
		SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;
	}

	if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
	{
		SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
		ShowMessage(stderr,GetReason());
		return EXIT_FAILURE ;

	}

	
	//for setting the bNeedPwd 
	if( ( _tcscmp(szPassword,TOKEN_ASTERIX )==0 ) && (IsLocalSystem(szServer)==FALSE )) 
	{
		bNeedPwd = TRUE ;

	}

	//set the bneedpassword to true if the server name is specified and password is not specified.
	if((cmdOptions[1].dwActuals!=0)&&(cmdOptions[3].dwActuals==0))
	{
		if( (lstrlen( szServer ) != 0) && (IsLocalSystem(szServer)==FALSE) )
		{
			bNeedPwd = TRUE ;
		}
		else
		{
			bNeedPwd = FALSE ;
		}

		if(_tcslen(szPassword)!= 0 )
		{
			_tcscpy(szPassword,NULL_STRING);

		}
	}


	//display an error message if the server is empty.  	
	if((cmdOptions[1].dwActuals!=0)&&(lstrlen(szServer)==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_SERVER));
		return EXIT_FAILURE ;
	}

	//display an error message if the user is empty.  	
	if((cmdOptions[2].dwActuals!=0)&&(lstrlen(szUser)==0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_NULL_USER));
		return EXIT_FAILURE ;
	}
	
			
	if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
	{
		if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
		{
			szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
			if(szToken == NULL)
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				return (EXIT_FAILURE);
			}

			lstrcpy(szServer,szToken);
		}
	}

	szFinalStr = (TCHAR*) malloc(MAX_STRING_LENGTH1* sizeof(TCHAR) );
	if (szFinalStr== NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_TAG));
		ShowLastError(stderr);
		return (EXIT_FAILURE);
		
	}

	// Establishing connection to the specified machine and getting the file pointer
	// of the boot.ini file if there is no error while establishing connection
	lstrcpy(szPath, PATH_BOOTINI );

	//display a warning message if the user specifies local system name 
	// with -s.
	if( (IsLocalSystem(szServer)==TRUE)&&(lstrlen(szUser)!=0))
	{
		DISPLAY_MESSAGE(stdout,GetResString(WARN_LOCALCREDENTIALS));
		_tcscpy(szServer,_T(""));
	}

	bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
	if(bFlag == EXIT_FAILURE)
	{
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);
	}

	
	
	// Getting the keys of the Operating system section in the boot.ini file
	arr = getKeyValueOfINISection( szPath, OS_FIELD );

	if(arr == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}

	// Getting the total number of keys in the operating systems section
	dwNumKeys = DynArrayGetCount(arr);
	if( (dwNumKeys >= MAX_BOOTID_VAL) && (dwDefault >= MAX_BOOTID_VAL )  )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_MAX_BOOTID));
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		DestroyDynamicArray(&arr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	

	}

	// Displaying error message if the number of keys is less than the OS entry
	// line number specified by the user
	if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);

	}

	// Getting the key of the OS entry specified by the user	
	if (arr != NULL)
	{
		LPCWSTR pwsz = NULL;
		pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
		if(pwsz != NULL)
		{
			_tcscpy( szkey,pwsz);
		}
		else
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;
		}
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}


	if(lstrcmpi(szDefault,ON_STRING)==0 )
	{
		if(_tcsstr(szkey,DEBUGPORT) != 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPLICATE_ENTRY)); 
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;

		}
	
		if((_tcsstr(szkey,DEBUG_SWITCH) == 0))
		{
			lstrcat(szkey,TOKEN_EMPTYSPACE);
			lstrcat(szkey,DEBUG_SWITCH);
		}

		lstrcat(szkey,TOKEN_EMPTYSPACE);
		lstrcat(szkey,DEBUGPORT_1394) ;
		
		if(dwChannel!=0)
		{

			//frame the string and concatenate to the Os Load options.
			lstrcat(szkey,TOKEN_EMPTYSPACE);
			lstrcat(szkey,TOKEN_CHANNEL);
			lstrcat(szkey,TOKEN_EQUAL);
			_ltow(dwChannel,szChannel,10);
			lstrcat(szkey,szChannel);
	
		}

	}

	if(lstrcmpi(szDefault,OFF_STRING)==0 )
	{
		if(_tcsstr(szkey,DEBUGPORT_1394) == 0)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_1394_SWITCH));
			resetFileAttrib(szPath);
			DestroyDynamicArray(&arr);
			SAFEFREE(szFinalStr);
			SAFECLOSE(stream);
			SafeCloseConnection(szServer,bConnFlag);
			return EXIT_FAILURE ;

		}

		removeSubString(szkey,DEBUGPORT_1394);
		removeSubString(szkey,DEBUG_SWITCH);
		
		if(_tcsstr(szkey,TOKEN_CHANNEL)!=0)
		{
			lstrcpy(szTemp,NULL_STRING);
			dwCode = GetSubString(szkey,TOKEN_CHANNEL,szTemp);			
			if(dwCode == EXIT_FAILURE )
			{
				DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_TOKENS));	
				resetFileAttrib(szPath);
				DestroyDynamicArray(&arr);
				SAFEFREE(szFinalStr);
				SAFECLOSE(stream);
				SafeCloseConnection(szServer,bConnFlag);
				return EXIT_FAILURE ;
			
			}
			
			if(lstrlen(szTemp)!=0)
			{
				removeSubString(szkey,szTemp);
			}

		}
		
	}

	if( _tcslen(szkey) >= MAX_RES_STRING)
	{		
		_stprintf(szErrorMsg,GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
		DISPLAY_MESSAGE( stderr,szErrorMsg);
		resetFileAttrib(szPath);
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE ;
	}
	
	DynArrayRemove(arr, dwDefault - 1 );
	DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_RES_STRING);


	// Setting the buffer to 0, to avoid any junk value
	memset(szFinalStr, 0, MAX_STRING_LENGTH1);

	// Forming the final string from all the key-value pairs

	if (stringFromDynamicArray1( arr,szFinalStr) == EXIT_FAILURE)
	{
		DestroyDynamicArray(&arr);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		resetFileAttrib(szPath);
		SafeCloseConnection(szServer,bConnFlag);
		return EXIT_FAILURE;
	}

	// Writing to the profile section with new key-value pair
	// If the return value is non-zero, then there is an error.
	if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
	{
		
		_stprintf(szBuffer,GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS), dwDefault );
		DISPLAY_MESSAGE(stdout,szBuffer);
		
	}
	else
	{
		_stprintf(szBuffer,GetResString(IDS_ERROR_LOAD_OSOPTIONS), dwDefault );
		DISPLAY_MESSAGE(stderr,szBuffer);
		DestroyDynamicArray(&arr);
		resetFileAttrib(szPath);
		SAFEFREE(szFinalStr);
		SAFECLOSE(stream);
		SafeCloseConnection(szServer,bConnFlag);
		return (EXIT_FAILURE);	
	}

	//reset the file attributes and free the memory and close the connection to the server.
	bRes = resetFileAttrib(szPath);
	DestroyDynamicArray(&arr);
	SAFEFREE(szFinalStr);
	SAFECLOSE(stream);
	SafeCloseConnection(szServer,bConnFlag);
	return (bRes);

}

// ***************************************************************************
//
//  Routine Description	 :  Display the help for the Dbg1394 entry option (X86).
//
//  Arguments		   : none
//				         
//  Return Type	       : VOID
//
// ***************************************************************************

VOID displayDbg1394Usage_X86()
{
	DWORD dwIndex = IDS_DBG1394_BEGIN_X86 ; 
	

	for(;dwIndex <=IDS_DBG1394_END_X86;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}

// ***************************************************************************
//
//  Routine Description	 :  Display the help for the Dbg1394 entry option (IA64).
//
//  Arguments		   : none
//				         
//  Return Type	       : VOID
//
// ***************************************************************************
VOID displayDbg1394Usage_IA64()
{
	DWORD dwIndex = IDS_DBG1394_BEGIN_IA64 ; 
	

	for(;dwIndex <=IDS_DBG1394_END_IA64 ;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}


// ***************************************************************************
//
//   Routine Description			: determines if the computer is 32 bit system or 64 bit 
//   Arguments						: 
//		[ in ] szComputerName	: System name
//   Return Type					: DWORD
//		TRUE  :   if the system is a  32 bit system
//		FALSE :   if the system is a  64 bit system 		
// ***************************************************************************

DWORD GetCPUInfo(LPTSTR szComputerName)
{
  HKEY     hKey1 = 0;

  HKEY     hRemoteKey = 0;
  TCHAR    szPath[MAX_STRING_LENGTH + 1] = SUBKEY ; 
  DWORD    dwValueSize = MAX_STRING_LENGTH + 1;
  DWORD    dwRetCode = ERROR_SUCCESS;
  DWORD    dwError = 0;
  TCHAR szTmpCompName[MAX_STRING_LENGTH+1] = NULL_STRING;
  
   TCHAR szTemp[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD len = lstrlen(szTemp);
   TCHAR szVal[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD dwLength = MAX_STRING_LENGTH ;
   LPTSTR szReturnValue = NULL ;
   DWORD dwCode =  0 ;
   szReturnValue = ( LPTSTR ) malloc( dwLength*sizeof( TCHAR ) );
   if(szReturnValue == NULL)
   {
		return ERROR_RETREIVE_REGISTRY ;
   }

   if(lstrlen(szComputerName)!= 0 )
	{
	lstrcpy(szTmpCompName,TOKEN_BACKSLASH4);
	lstrcat(szTmpCompName,szComputerName);
  }
  else
  {
	lstrcpy(szTmpCompName,szComputerName);
  }
  
  // Get Remote computer local machine key
  dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
  if (dwError == ERROR_SUCCESS)
  {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if (dwError == ERROR_SUCCESS)
     {
		dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
		
		if (dwRetCode == ERROR_MORE_DATA)
		{
				szReturnValue 	 = ( LPTSTR ) realloc( szReturnValue 	, dwValueSize * sizeof( TCHAR ) );
				dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
		}
		if(dwRetCode != ERROR_SUCCESS)
		{
			RegCloseKey(hKey1);			
			RegCloseKey(hRemoteKey);
            SAFEFREE(szReturnValue);
			return ERROR_RETREIVE_REGISTRY ;
		}
	 }
	 else
	 {
		RegCloseKey(hRemoteKey);
        SAFEFREE(szReturnValue);
		return ERROR_RETREIVE_REGISTRY ;

	 }
    
    RegCloseKey(hKey1);
  }
  else
  {
	  RegCloseKey(hRemoteKey);
      SAFEFREE(szReturnValue);
	  return ERROR_RETREIVE_REGISTRY ;
  }
 
  RegCloseKey(hRemoteKey);
 
  lstrcpy(szVal,X86_MACHINE);

  //check if the specified system contains the words x86 (belongs to the 32 )
  // set the flag to true if the specified system is 64 bit .
	
  if( !_tcsstr(szReturnValue,szVal))
	  {
		dwCode = SYSTEM_64_BIT ;
	  }
	 else
	  {
		dwCode =  SYSTEM_32_BIT ;
	  }

    	
  SAFEFREE(szReturnValue);
  return dwCode ;

}//GetCPUInfo


// ***************************************************************************
//
//   Routine Description			: determines if the computer is 32 bit system or 64 bit 
//   Arguments						: 
//		[ in ] szServer				: System name
//   Return Type					: DWORD
//		EXIT_FAILURE  :   if the system is a  32 bit system
//		EXIT_SUCCESS  :   if the system is a  64 bit system 		
// ***************************************************************************

DWORD CheckSystemType(LPTSTR szServer)
{
	
	DWORD dwSystemType = 0 ;
#ifndef _WIN64

	//display the error message if  the target system is a 64 bit system or if error occured in 
	 //retreiving the information
	 dwSystemType = GetCPUInfo(szServer);
	if(dwSystemType == ERROR_RETREIVE_REGISTRY)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
		return (EXIT_FAILURE);
	
	}
	if(dwSystemType == SYSTEM_64_BIT)
	{
		if(lstrlen(szServer)== 0 )
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH));
		}
		else
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED));
		}
		return (EXIT_FAILURE);

	}

#endif
		return EXIT_SUCCESS ;
}

// ***************************************************************************
//
//   Routine Description			: determines if the computer is 32 bit system or 64 bit 
//   Arguments						: 
//		[ in ] szServer				: System name
//      [ in ] bFlag				: Flag 
//   Return Type					: VOID
//								
//
// ***************************************************************************
VOID SafeCloseConnection(LPTSTR szServer,BOOL bFlag)
{
	
	if (bFlag )
	{
		CloseConnection(szServer);
	}

}


// ***************************************************************************
//
//   Routine Description			: Display the help for the mirror option (IA64).
//   Arguments						: 
//									: NONE		
//
//   Return Type					: VOID
//								
//
// ***************************************************************************

VOID displayMirrorUsage_IA64()
{
	DWORD dwIndex = IDS_MIRROR_BEGIN_IA64 ; 
	

	for(;dwIndex <=IDS_MIRROR_END_IA64 ;dwIndex++)
	{
		DISPLAY_MESSAGE(stdout,GetResString(dwIndex));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once		

//
// public Windows header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <limits.h>
#include "Shlwapi.h"
#include "winbase.h"

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>
#include <ntexapi.h>


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <Winioctl.h>
#include <Rpcdce.h>
#include <crtdbg.h>
#include <diskguid.h>
#include <rpc.h>

#include "cmdline.h"
#include "cmdlineres.h"

//
// private Common header files
//

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\global.h ===
/*++

Copyright (c)  Microsoft Corporation

Module Name:

	global.h

Abstract:

  This file has all global variable declarations

Author:

	sivaraja 8/5/2000
	
Evironment:

	User Mode
	
Revision Hisory:

--*/


#pragma once

#include "winioctl.h"

UINT32 Crc32Table[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

#define PARTITION_TABLE_OFFSET 446
#define PART_NAME_LEN 36
#define GPT_PART_SIGNATURE 0x5452415020494645;

typedef struct _GPT_ENTRY
{
    GUID	PartitionTypeGUID;  // declartion of this partition's type
    GUID	UniquePartitionGUID;    // Unique ID for this particular partition
                                // (unique to this instance)
    UINT64	StartingLBA;    // 0 based block (sector) address of the
                                // first block included in the partition.
    UINT64	EndingLBA;      // 0 based block (sector) address of the
                                // last block included in the partition.
                                // If StartingLBA == EndingLBA then the
                                // partition is 1 block long.  this is legal.
    UINT64	Attributes;     // Always ZERO for now
    WCHAR	PartitionName[PART_NAME_LEN];  // 36 unicode characters of name
	_GPT_ENTRY *NextGPTEntry;
} GPT_ENTRY, *PGPT_ENTRY;

typedef struct _GPT_HEADER
{
    UINT64	Signature;      // GPT PART
    UINT32	Revision;
    UINT32	HeaderSize;
    UINT32	HeaderCRC32;    // computed using 0 for own init value
    UINT32	Reserved0;
    UINT64	MyLBA;          // 0 based sector number of the first
                                // sector of this structure
    UINT64	AlternateLBA;   // 0 based sector (block) number of the
                                // first sector of the secondary
                                // GPT_HEADER, or 0 if this is the
                                // secondary.
    UINT64	FirstUsableLBA; // 0 based sector number of the first
                                // sector that may be included in a partition.
    UINT64	LastUsableLBA;  // last legal LBA, inclusive.
    GUID	DiskGUID;       // The unique ID of this LUN/spindle/disk
    UINT64	PartitionEntryLBA;       // The start of the table of entries...
    UINT32	NumberOfPartitionEntries; // Number of entries in the table, this is
                                  // how many allocated, NOT how many used.
    UINT32	SizeOfPartitionEntry;    // sizeof(GPT_ENTRY) always mult. of 8
    UINT32	PartitionEntryArrayCRC32;      // CRC32 of the table.
    // Reserved and zeros to the end of the block
    // Don't declare an array or sizeof() gives a nonsense answer..

	// Computed data
	UINT32  ComputedHeaderCRC32;
	UINT32	ComputedPartitionEntryArrayCRC32;
	UINT32  UsedPartitionEntries;
	PGPT_ENTRY FirstGPTEntry;
	BOOLEAN Healthy;
} GPT_HEADER, *PGPT_HEADER;


//
// Global Variables
//

HANDLE g_hDisk;
DWORD  g_nBytesPerSector;
DISK_GEOMETRY_EX g_sDiskGeometry;
BOOLEAN g_bProtectiveMBRFound;
GPT_HEADER g_sGPTHeader;
GPT_HEADER g_sBackupGPTHeader;
PGPT_ENTRY g_pGPTEntryHead;
PGPT_ENTRY g_pBackupGPTEntryHead;
DWORD g_nTotalGPTEntries;
DWORD g_nTotalBackupGPTEntries;
UINT32 g_nComputedCRCGPTHeader;
UINT32 g_nComputedCRCBackupGPTHeader;
UINT32 g_nComputedCRCGPTEntries;
UINT32 g_nComputedCRCBackupGPTEntries;

//
// Global UI Variables
//
PCHAR pReportBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\bootcfg64.h ===
#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)


#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))


#define MBE_STATUS_IS_NT        0x00000001

#define MBE_IS_NT(_be) (((_be)->Status & MBE_STATUS_IS_NT) != 0)
#define MBE_SET_IS_NT(_be) ((_be)->Status |= MBE_STATUS_IS_NT)

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PUCHAR AllocationEnd;
	ULONG Ordered;
	ULONG Status;
	ULONG myId;
    ULONG Id;
    ULONG Attributes;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    PUCHAR ForeignOsOptions;
    ULONG ForeignOsOptionsLength;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;



DWORD InitializeEFI(void);
BOOL  QueryBootIniSettings_IA64();
DWORD DeleteBootIniSettings_IA64(DWORD argc, LPCTSTR argv[]);
DWORD CopyBootIniSettings_IA64(DWORD argc, LPCTSTR argv[]);
DWORD ChangeTimeOut_IA64(DWORD argc, LPCTSTR argv[]);
DWORD RawStringOsOptions_IA64(DWORD argc, LPCTSTR argv[]);
DWORD ChangeDefaultBootEntry_IA64(DWORD argc, LPCTSTR argv[]);

NTSTATUS BootCfg_EnumerateBootEntries(PBOOT_ENTRY_LIST *ntBootEntries);
NTSTATUS BootCfg_QueryBootOptions(PBOOT_OPTIONS *ppBootOptions);

PWSTR GetNtNameForFilePath (IN PFILE_PATH FilePath);
DWORD ChangeBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName, LPTSTR lpOSLoadOptions);
DWORD CopyBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName);
DWORD ModifyBootOptions(ULONG Timeout, LPTSTR pHeadlessRedirection, ULONG NextBootEntryID, ULONG Flag);

PMY_BOOT_ENTRY CreateBootEntryFromBootEntry (IN PMY_BOOT_ENTRY OldBootEntry);

BOOL IsBootEntryWindows(PBOOT_ENTRY bootEntry);

PWSTR
GetNtNameForFilePath (IN PFILE_PATH FilePath);

DWORD ConvertBootEntries (PBOOT_ENTRY_LIST BootEntries);
VOID DisplayBootEntry();
DWORD DisplayBootOptions();
DWORD GetCurrentBootEntryID(DWORD Id);

DWORD ProcessDebugSwitch_IA64(  DWORD argc, LPCTSTR argv[] );

VOID  GetComPortType_IA64( LPTSTR  szString,LPTSTR szTemp );
DWORD ProcessEmsSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessAddSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessRmSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessDbg1394Switch_IA64(DWORD argc,LPCTSTR argv[]);


#define PORT_COM1A  _T("/debugport=COM1")
#define PORT_COM2A  _T("/debugport=COM2")
#define PORT_COM3A  _T("/debugport=COM3")
#define PORT_COM4A  _T("/debugport=COM4")
#define PORT_1394A  _T("/debugport=1394")


//#ifdef _WIN64

#define PARTITION_TABLE_OFFSET 446
#define PART_NAME_LEN 36
#define GPT_PART_SIGNATURE 0x5452415020494645

#define TOKEN_BACKSLASH4 _T("\\\\")
#define SUBKEY1 _T("SYSTEM\\SETUP")

#define IDENTIFIER_VALUE2 _T("SystemPartition")
#define IDENTIFIER_VALUE3 _T("OsLoaderPath")


 typedef struct _GPT_ENTRY
{
    GUID	PartitionTypeGUID;  // declartion of this partition's type
    GUID	UniquePartitionGUID;    // Unique ID for this particular partition
                                // (unique to this instance)
    UINT64	StartingLBA;    // 0 based block (sector) address of the
                                // first block included in the partition.
    UINT64	EndingLBA;      // 0 based block (sector) address of the
                                // last block included in the partition.
                                // If StartingLBA == EndingLBA then the
                                // partition is 1 block long.  this is legal.
    UINT64	Attributes;     // Always ZERO for now
    WCHAR	PartitionName[PART_NAME_LEN];  // 36 unicode characters of name
    struct _GPT_ENTRY *NextGPTEntry;
} GPT_ENTRY, *PGPT_ENTRY;

typedef struct _GPT_HEADER
{
    UINT64	Signature;      // GPT PART
    UINT32	Revision;
    UINT32	HeaderSize;
    UINT32	HeaderCRC32;    // computed using 0 for own init value
    UINT32	Reserved0;
    UINT64	MyLBA;          // 0 based sector number of the first
                                // sector of this structure
    UINT64	AlternateLBA;   // 0 based sector (block) number of the
                                // first sector of the secondary
                                // GPT_HEADER, or 0 if this is the
                                // secondary.
    UINT64	FirstUsableLBA; // 0 based sector number of the first
                                // sector that may be included in a partition.
    UINT64	LastUsableLBA;  // last legal LBA, inclusive.
    GUID	DiskGUID;       // The unique ID of this LUN/spindle/disk
    UINT64	PartitionEntryLBA;       // The start of the table of entries...
    UINT32	NumberOfPartitionEntries; // Number of entries in the table, this is
                                  // how many allocated, NOT how many used.
    UINT32	SizeOfPartitionEntry;    // sizeof(GPT_ENTRY) always mult. of 8
    UINT32	PartitionEntryArrayCRC32;      // CRC32 of the table.
    // Reserved and zeros to the end of the block
    // Don't declare an array or sizeof() gives a nonsense answer..

	// Computed data
	UINT32  ComputedHeaderCRC32;
	UINT32	ComputedPartitionEntryArrayCRC32;
	UINT32  UsedPartitionEntries;
	PGPT_ENTRY FirstGPTEntry;
	BOOLEAN Healthy;
} GPT_HEADER, *PGPT_HEADER;

UINT32	ScanGPT(DWORD nPhysicalDisk);
DWORD ProcessMirrorSwitch_IA64(DWORD argc,LPCTSTR argv[]) ;
DWORD GetBootFilePath(LPTSTR szComputerName,LPTSTR szBootPath);
BOOL GetARCSignaturePath(LPTSTR szString,LPTSTR szFinalPath);

//DWORD ProcessMirrorBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpBootFilePath,LPTSTR OsFilePath);

DWORD ProcessMirrorBootEntry(PBOOT_ENTRY bootEntry, PWSTR lpBootFilePath,LPTSTR OsFilePath);
DWORD GetDeviceInfo(LPTSTR szGUID,LPTSTR szFinalStr);

PBOOT_ENTRY FillBootEntry(PBOOT_ENTRY bootEntry,LPTSTR szBootPath,LPTSTR szArcPath);	

LPVOID MEMALLOC( ULONG size );

VOID MEMFREE ( LPVOID block );

LONG LowNtAddBootEntry(
    IN WCHAR *pwszLoaderPath,
    IN WCHAR *pwszArcString
    );

	
DWORD FormARCPath(LPTSTR szGUID,LPTSTR szFinalStr);

LONG LowNtAddBootEntry( IN WCHAR *pwszLoaderPath,IN WCHAR *pwszArcString) ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\guid.c ===
/******************************************************************************

	Copyright(c)  Microsoft Corporation

	Module Name:

		guid.cpp

	Abstract:

		
		This file is written for the implementation of functionality 
		of the mirror plex List operation.
		
	Author:

		J.S.Vasu		    9/5/2001 .

	Revision History:

		
		J.S.Vasu			9/5/2001	     Created it.
	

NOTE : This File is no longer being used . All the required properties 
       for the Mirror Plex List operation are available from the 
       DeviceIoControl API .
         
******************************************************************************/ 



#pragma once

#include <pch.h>

#include <diskguid.h>
#include <rpc.h>
#include <TCHAR.H>
#include "BootCfg.h"
#include "BootCfg64.h"
#include "resource.h"



UINT32 Crc32Table[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};



//
// Global Variables
//

 HANDLE g_hDisk;
DWORD  g_nBytesPerSector;
DISK_GEOMETRY_EX g_sDiskGeometry;
BOOLEAN g_bProtectiveMBRFound ;

GPT_HEADER g_sGPTHeader ;
GPT_HEADER g_sBackupGPTHeader;
PGPT_ENTRY g_pGPTEntryHead;
PGPT_ENTRY g_pBackupGPTEntryHead;


DWORD g_nTotalGPTEntries;
DWORD g_nTotalBackupGPTEntries;
UINT32 g_nComputedCRCGPTHeader;
UINT32 g_nComputedCRCBackupGPTHeader;
UINT32 g_nComputedCRCGPTEntries;
UINT32 g_nComputedCRCBackupGPTEntries;

//
// Global UI Variables
//
PCHAR pReportBuffer;

GUID g_GuidArr[256] ;
DWORD g_dwCnt = 0 ;

HANDLE	OpenDisk(DWORD nPhysicalDrive);
void	CloseDisk(HANDLE hDisk);
UINT32	ReadBlock(HANDLE hDisk, UINT64 nStart, UINT32 nSize, PVOID lpBuffer);
UINT32	WriteBlock(HANDLE hDisk, UINT64 nStart, UINT32 nSize, PVOID lpBuffer);

UINT32	GetGPTHeaderAndEntries(HANDLE hDisk, GPT_HEADER *pGPTHeader, UINT64 nHeaderSector);
UINT32	DumpGPTHeader(PGPT_HEADER pGPTHeader);
UINT32	DumpPartitionEntries(PGPT_ENTRY pGPTEntryHead);
UINT32	ComputeCRC32(UCHAR *pBuffer, UINT32 nLength);
void	AddReportSection(PTCHAR pString);
void	FreeGPTEntries(PGPT_ENTRY pGPTEntryHead);
UINT32  GetDriveGeometry(HANDLE hDisk, PDISK_GEOMETRY_EX pDiskGeometry);
UINT32	CheckProtectiveMBR(HANDLE hDisk);
void AddReport1(PTCHAR pString);
void GetSystemDrivePath();

// ***************************************************************************
//
//  Name			   : OpenDisk
//
//  Synopsis		   : This routine is used to open a disk and get a handle to it.	 
//				     				 
//  Parameters		   : DWORD nPhysicalDrive (in) - Drive to be opened.
//
//
//  Return Type	       : HANDLE -- handle of the opened drive.
//
//
//  Global Variables   : None
//  
// ***************************************************************************

HANDLE OpenDisk(DWORD nPhysicalDrive)
{
    TCHAR szDriveName[50];
    
	_stprintf(szDriveName, _T("\\\\.\\physicaldrive%d"), nPhysicalDrive);
	
	return CreateFile(szDriveName,
			GENERIC_READ|GENERIC_WRITE, 
			FILE_SHARE_READ|FILE_SHARE_WRITE, 
			NULL,
			OPEN_EXISTING,
			0,
			NULL);
}


// ***************************************************************************
//
//  Routine description	: This routine is used to close a disk .
//	     
//  Arguments:
//		  [in] HANDLE     : Handle to the Specified Disk.
//
//  Return Value        : VOID
//
//
// ***************************************************************************

void CloseDisk(HANDLE hDisk)
{
	CloseHandle(hDisk);
}

// ***************************************************************************
//
//  Routine description	: This routine is used to read a specified block	 
//	     
//  Arguments:
//		  [in] HANDLE     : 
//		  [in] nStart     : starting position of the block., 
//        [in] nSize      :ending position of the block. 
//        [out] lpBuffer  : output buffer. Handle to the Specified Disk.
//
//  Return Value          : VOID
//
// ***************************************************************************


UINT32 ReadBlock(HANDLE hDisk, UINT64 nStart, UINT32 nSize, PVOID lpBuffer)
{
	UINT64 nPosition;
	DWORD  nBytesRead;
	UINT32 pLoHi[2];

	nPosition = nStart * 512;
	
	//assign the lsb of 64 bit no to the zero array and MSB to the first array element.
	*((PUINT64)pLoHi) = nPosition;

	nBytesRead = 0;
	SetFilePointer(hDisk, (LONG) pLoHi[0], (long *) &pLoHi[1], FILE_BEGIN);
	
	if(!ReadFile(hDisk, lpBuffer, nSize * 512, &nBytesRead, NULL) )
    {
        return 0 ;
    }
	
	return nBytesRead;
}

// ***************************************************************************
//
//  Routine description	: This routine is used to write a specified block	 
//	     
//  Arguments:
//		  [in] HANDLE     : handle of the opened disk.
//		  [in] nStart     : starting position of the block., 
//        [in] nSize      :ending position of the block. 
//        [out] lpBuffer  : output buffer. Handle to the Specified Disk.
//
//  Return Value          : VOID
//
// ***************************************************************************

UINT32 WriteBlock(HANDLE hDisk, UINT64 nStart, UINT32 nSize, PVOID lpBuffer)
{
	UINT64 nPosition;
	DWORD  nBytesRead;
	UINT32 pLoHi[2];

	nPosition = nStart * 512;
	
	//assign the lsb of 64 bit no to the zero array and MSB to the first array element.

	*((PUINT64)pLoHi) = nPosition;

	nBytesRead = 0;
	SetFilePointer(hDisk, (LONG) pLoHi[0], (long *) &pLoHi[1], FILE_BEGIN);
	if(!WriteFile(hDisk, lpBuffer, nSize * 512, &nBytesRead, NULL))
    {
        return 0 ;
    }
	
	return nBytesRead;
}

// ***************************************************************************
//
//  Routine description	: This routine is used to write a specified block	 
//	     
//  Arguments:
//		  [in] Drive     : Drive to be scanned
//
//  Return Value          : UINT32
//
// ***************************************************************************

UINT32 ScanGPT(DWORD nPhysicalDrive)
{
	UINT64 nAlternateLBA;
    UINT32 Result = 0;
	TCHAR szMessage[MAX_RES_STRING] = NULL_STRING ;

	//
	// Get a handle to the physical drive
	//
	
	g_hDisk = OpenDisk(nPhysicalDrive);
	if (g_hDisk == INVALID_HANDLE_VALUE)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DRIVE) );
		return EXIT_FAILURE;
	}
     if (GetDriveGeometry(g_hDisk, &g_sDiskGeometry)== EXIT_FAILURE )
    {
		return EXIT_FAILURE;
    }


	//
	// Get primary GPT Header and its partition entries
	//
	if (GetGPTHeaderAndEntries(g_hDisk, &g_sGPTHeader, 1))
	{
		g_sGPTHeader.Healthy = TRUE;
	}
	else
	{
		//
		// This can happen if we have junk value in GPT header.
		// In this case we dont perform certain tests
		//
		g_sGPTHeader.Healthy = FALSE;
	}


	//
	// Get backup GPT Header and its partition entries
	//
	nAlternateLBA = (g_sDiskGeometry.DiskSize.QuadPart / g_sDiskGeometry.Geometry.BytesPerSector) - 1;

	if (GetGPTHeaderAndEntries(g_hDisk, &g_sBackupGPTHeader, nAlternateLBA))
	{
		g_sBackupGPTHeader.Healthy = TRUE;
	}
	else
	{
		//
		// This can happen if we have junk value in Backup GPT Header
		// In this case we dont perform certain tests
		//
		g_sBackupGPTHeader.Healthy = FALSE;
	}

	// display the header 
	DISPLAY_MESSAGE(stdout,GetResString(IDS_HEADER1));
	DISPLAY_MESSAGE(stdout,GetResString(IDS_HEADER_DASH1));

    Result = DumpGPTHeader(&g_sGPTHeader);

	if (Result == EXIT_FAILURE)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DISPLAY));
		return EXIT_FAILURE;
	}
	

    
	DISPLAY_MESSAGE(stdout,GetResString(IDS_HEADER2));
	DISPLAY_MESSAGE(stdout,GetResString(IDS_HEADER2_DASH));

    Result = DumpPartitionEntries(g_sGPTHeader.FirstGPTEntry);
	if (Result == EXIT_FAILURE)
	{
       DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DISPLAY));
	   return EXIT_FAILURE;
	} 

	//
	// Clean up
	//
	FreeGPTEntries(g_sGPTHeader.FirstGPTEntry);
	FreeGPTEntries(g_sBackupGPTHeader.FirstGPTEntry);
	CloseDisk(g_hDisk);
	return EXIT_SUCCESS;
}

// ***************************************************************************
//
//  Routine description	: This routine is used to read GPT Header and entries	 
//	     
//  Arguments:
//		  [in] hDisk      : Drive to be scanned
//		  [in] pGPTHeader : GPT Header to be scanned.
//		  [in] nHeaderSector : Sector to be read.
//
//  Return Value          : UINT32
//
// ***************************************************************************
UINT32 GetGPTHeaderAndEntries(HANDLE hDisk, GPT_HEADER *pGPTHeader, UINT64 nHeaderSector)
{
	UCHAR *lpSectorBuffer;
	DWORD nBytesReturned;
	DWORD ti, tj;
	PGPT_ENTRY pGPTEntry, pPrevGPTEntry;
	UINT32 nTempCRC, nTempCount;
	char sStr[200];
	TCHAR szString[256];

    if (!hDisk || INVALID_HANDLE_VALUE == hDisk || !pGPTHeader) 
    {
        return EXIT_FAILURE;
    }

	//
	// Allocate memory for sector
	//
	lpSectorBuffer = (UCHAR *) GlobalAlloc(GPTR, g_nBytesPerSector);
    if (!lpSectorBuffer) 
    {
        return EXIT_FAILURE;
    }

	nBytesReturned = ReadBlock(g_hDisk, nHeaderSector, 1, lpSectorBuffer);
	if (nBytesReturned != g_nBytesPerSector)
	{
		_stprintf(szString,GetResString(IDS_ERROR_READ), nHeaderSector);
		DISPLAY_MESSAGE(stderr,szString);

        if(lpSectorBuffer)
        {
            GlobalFree(lpSectorBuffer);
        }
		return EXIT_FAILURE;
	}
	//
	// Unpack the values
	//
	ti = 0;

	// dest,source , sizeof destination datatype.
	memcpy((void *)&pGPTHeader->Signature, 
		(void *) lpSectorBuffer, 
		sizeof(pGPTHeader->Signature) );

	ti += sizeof(pGPTHeader->Signature);
	
	memcpy((void *)&pGPTHeader->Revision, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->Revision));
	ti += sizeof(pGPTHeader->Revision);
	
	memcpy((void *)&pGPTHeader->HeaderSize, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->HeaderSize));
	ti += sizeof(pGPTHeader->HeaderSize);
	
	memcpy((void *)&pGPTHeader->HeaderCRC32, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->HeaderCRC32));
	ti += sizeof(pGPTHeader->HeaderCRC32);
	
	memcpy((void *)&pGPTHeader->Reserved0, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->Reserved0));
	ti += sizeof(pGPTHeader->Reserved0);
	
	memcpy((void *)&pGPTHeader->MyLBA, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->MyLBA));
	ti += sizeof(pGPTHeader->MyLBA);
	
	memcpy((void *)&pGPTHeader->AlternateLBA, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->AlternateLBA));
	ti += sizeof(pGPTHeader->AlternateLBA);
	
	memcpy((void *)&pGPTHeader->FirstUsableLBA, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->FirstUsableLBA));
	ti += sizeof(pGPTHeader->FirstUsableLBA);
	
	memcpy((void *)&pGPTHeader->LastUsableLBA, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->LastUsableLBA));
	ti += sizeof(pGPTHeader->LastUsableLBA);
	
	memcpy((void *)&pGPTHeader->DiskGUID, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->DiskGUID));
	ti += sizeof(pGPTHeader->DiskGUID);
	
	memcpy((void *)&pGPTHeader->PartitionEntryLBA, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->PartitionEntryLBA));
	ti += sizeof(pGPTHeader->PartitionEntryLBA);
	
	memcpy((void *)&pGPTHeader->NumberOfPartitionEntries, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->NumberOfPartitionEntries));
	ti += sizeof(pGPTHeader->NumberOfPartitionEntries);
	
	memcpy((void *)&pGPTHeader->SizeOfPartitionEntry, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->SizeOfPartitionEntry));
	ti += sizeof(pGPTHeader->SizeOfPartitionEntry);
	
	memcpy((void *)&pGPTHeader->PartitionEntryArrayCRC32, (void *) (lpSectorBuffer+ti), sizeof(pGPTHeader->PartitionEntryArrayCRC32));
	ti += sizeof(pGPTHeader->PartitionEntryArrayCRC32);

	//
	// Compute HeaderCRC32
	//
	nTempCRC = pGPTHeader->HeaderCRC32;
	pGPTHeader->HeaderCRC32 = 0;
	if (pGPTHeader->HeaderSize > sizeof(GPT_HEADER))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_GPT));
        if(lpSectorBuffer)
        {
            GlobalFree(lpSectorBuffer);
        }
		return EXIT_FAILURE;
	}
	pGPTHeader->ComputedHeaderCRC32 = ComputeCRC32((PUCHAR) pGPTHeader, pGPTHeader->HeaderSize);
	pGPTHeader->HeaderCRC32 = nTempCRC;

	//
	// Free this memory
	//
	GlobalFree(lpSectorBuffer);

	//
	// Preliminary checks
	//
	if (!pGPTHeader->SizeOfPartitionEntry || !pGPTHeader->NumberOfPartitionEntries)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_GPT_HEADER));
        return EXIT_FAILURE;
	}

	// 
	// Allocate memory for GPT Entries
	//
	nTempCount = (pGPTHeader->SizeOfPartitionEntry * pGPTHeader->NumberOfPartitionEntries) / g_nBytesPerSector;
	if ((pGPTHeader->SizeOfPartitionEntry * pGPTHeader->NumberOfPartitionEntries) % g_nBytesPerSector)
	{
		nTempCount++;
	}

	if (!nTempCount)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_GPT_HEADER));
		return EXIT_FAILURE;
	}

	lpSectorBuffer = (UCHAR *) GlobalAlloc(GPTR, nTempCount * g_nBytesPerSector);
	if (!lpSectorBuffer)
	{
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MEM_GPT));
		return EXIT_FAILURE;
	}

	//
	// Build partition entries info based on g_sGPTHeader
	//
	nBytesReturned = ReadBlock(g_hDisk, 
							pGPTHeader->PartitionEntryLBA,
							nTempCount,
							lpSectorBuffer);

	if (nBytesReturned != nTempCount * g_nBytesPerSector)
	{
		if(lpSectorBuffer)
        {
            GlobalFree(lpSectorBuffer);
        }
		
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_READ_GPT_ENTRIES));
		return EXIT_FAILURE;
	}

	ti = 0;
	while (lpSectorBuffer[ti])
	{
		//
		// Create a linked list of GPT_ENTRY
		//
		pGPTEntry = (PGPT_ENTRY) GlobalAlloc(GPTR, sizeof(GPT_ENTRY));
		if (ti == 0)
		{
			pGPTHeader->FirstGPTEntry = pGPTEntry;
		}
		else
		{
			pPrevGPTEntry->NextGPTEntry = pGPTEntry;
		}
		pPrevGPTEntry = pGPTEntry;
		pGPTEntry->NextGPTEntry = NULL;
		//
		// Get the values
		// 
		tj = 0;
		memcpy((void *) &pGPTEntry->PartitionTypeGUID, (void *) (lpSectorBuffer + ti) , sizeof(pGPTEntry->PartitionTypeGUID));
		tj = tj + sizeof(pGPTEntry->PartitionTypeGUID);
		memcpy((void *) &pGPTEntry->UniquePartitionGUID, (void *) (lpSectorBuffer + ti + tj) , sizeof(pGPTEntry->UniquePartitionGUID));
		tj = tj + sizeof(pGPTEntry->UniquePartitionGUID);
		memcpy((void *) &pGPTEntry->StartingLBA, (void *) (lpSectorBuffer + ti + tj) , sizeof(pGPTEntry->StartingLBA));
		tj = tj + sizeof(pGPTEntry->StartingLBA);
		memcpy((void *) &pGPTEntry->EndingLBA, (void *) (lpSectorBuffer + ti + tj) , sizeof(pGPTEntry->EndingLBA));
		tj = tj + sizeof(pGPTEntry->EndingLBA);
		memcpy((void *) &pGPTEntry->Attributes, (void *) (lpSectorBuffer + ti + tj) , sizeof(pGPTEntry->Attributes));
		tj = tj + sizeof(pGPTEntry->Attributes);
		memcpy((void *) &pGPTEntry->PartitionName, (void *) (lpSectorBuffer + ti + tj) , sizeof(pGPTEntry->PartitionName));
		tj = tj + sizeof(pGPTEntry->PartitionName);

		ti += pGPTHeader->SizeOfPartitionEntry;
		if (ti >= pGPTHeader->NumberOfPartitionEntries * pGPTHeader->SizeOfPartitionEntry)
		{
			//
			// Just be safe
			//
			break;
		}
	}
	//
	// Compute CRC32 for backup GPT Entries
	//
	pGPTHeader->ComputedPartitionEntryArrayCRC32 = ComputeCRC32(lpSectorBuffer, pGPTHeader->SizeOfPartitionEntry *
															pGPTHeader->NumberOfPartitionEntries);

	//
	// Used partition entries
	//
	pGPTHeader->UsedPartitionEntries = ti / pGPTHeader->SizeOfPartitionEntry;

    if(lpSectorBuffer)
    {
	    GlobalFree(lpSectorBuffer);
    }
	return EXIT_SUCCESS;
}

// ***************************************************************************
//
//  Routine description	: This routine is used to dump  GPT Header 
//	     
//  Arguments:
//		  [in] pGPTHeader : GPT Header to be dumped.
//
//
//  Return Value          : UINT32
//
// ***************************************************************************

UINT32 DumpGPTHeader(PGPT_HEADER pGPTHeader)
{
	
	TCHAR *pGUIDStr;
	
	TCHAR szString[256] = NULL_STRING ;

    if ( !pGPTHeader ) 
    {
        return EXIT_FAILURE;
    }

	//
	// Disk GUID
	//
	_tcscpy(szString,GetResString(IDS_PARTITION1));
	if (( UuidToString((UUID *)&pGPTHeader->DiskGUID, &pGUIDStr) != RPC_S_OK) || ( !pGUIDStr ) )
    {
          return EXIT_FAILURE;
    }
    
    
	_tcscat(szString,(PTCHAR)pGUIDStr);
	_tcscat(szString,GetResString(IDS_PARTITION2));
	
	DISPLAY_MESSAGE(stdout,szString);	

    if(pGUIDStr)
    {
	    RpcStringFree(&pGUIDStr);
    }

	return EXIT_SUCCESS;
}


// ***************************************************************************
//
//  Routine description	: This routine is used to dump  GPT Partition entries. 
//	     
//  Arguments:
//		  [in] pGPTEntryHead : GPT Header to be dumped.
//
//
//  Return Value          : UINT32
//
// ***************************************************************************

UINT32 DumpPartitionEntries(PGPT_ENTRY pGPTEntryHead)
{
	PTCHAR pGUIDStr;
	
	PGPT_ENTRY pEntryStep;
	char sStr[100];
	char *sStr2;

	TCHAR szString[256] ; //= NULL_STRING ;

    if (!pGPTEntryHead) {
        return EXIT_FAILURE;
    }

	sStr2 = (char *) GlobalAlloc(GPTR, 1024);
	if (!sStr2)
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DUMP_GPT_ENTRIES));
		return EXIT_FAILURE;
	}

	pEntryStep = pGPTEntryHead;
	if (!pEntryStep)
	{
		DISPLAY_MESSAGE(stdout,GetResString(IDS_INFO_DUMP_GPT_ENTRIES));
        if(sStr2)
        {
            GlobalFree(sStr2);
        }
		return EXIT_FAILURE;
	}
	
	while (pEntryStep)
	{

		_tcscpy(szString,GetResString(IDS_PARTITION1));
		if( UuidToString((UUID *)&pEntryStep->UniquePartitionGUID, &pGUIDStr) != RPC_S_OK )
        {
            if(sStr2)
            {
                GlobalFree(sStr2);
            }
            return EXIT_FAILURE;

        }
		
        _tcscat(szString,(PTCHAR)pGUIDStr);
		_tcscat(szString,GetResString(IDS_PARTITION2));

		RpcStringFree(&pGUIDStr);
		DISPLAY_MESSAGE(stdout,szString);

		_tcscpy(szString,GetResString(IDS_PARTITION3));
		
		if( UuidToString((UUID *)&pEntryStep->PartitionTypeGUID, &pGUIDStr)!= RPC_S_OK )
        {
            if(sStr2)
            {
                GlobalFree(sStr2);
            }
            return EXIT_FAILURE;

        }
		_tcscat(szString,(PTCHAR)pGUIDStr);
		_tcscat(szString,GetResString(IDS_PARTITION2));
		RpcStringFree(&pGUIDStr);
		DISPLAY_MESSAGE(stdout,szString);
		
		_stprintf(szString ,GetResString(IDS_START_LBA), pEntryStep->StartingLBA);
		
		_tcscpy(szString,GetResString(IDS_PARTITION4));
		
		_tcscat(szString, pEntryStep->PartitionName);
		_tcscat(szString,_T("\r\n"));
		DISPLAY_MESSAGE(stdout,szString);

		pEntryStep = pEntryStep->NextGPTEntry;
	}
    if(sStr2)
    {
	    GlobalFree(sStr2);
    }
	return EXIT_SUCCESS;
}

// ***************************************************************************
//
//  Routine description	: This routine is used to compute CRC32
//	     
//  Arguments:
//		  [in] pBuffer : buffer.
//		  [in] nLength : Length .
//
//  Return Value          : UINT32
//
// ***************************************************************************
UINT32 ComputeCRC32(UCHAR *pBuffer, UINT32 nLength)
{
	//
	// Code taken from RtlComputeCRC32, but the parameters have been modified to force PartitionCrc to 0
	//

    UINT32 Crc;
    UINT32 ti;
	UINT32 PartialCrc;

    //
    // Compute the CRC32 checksum.
    //
    
	PartialCrc = 0;

    Crc = PartialCrc ^ 0xffffffffL;
    
    for (ti = 0; ti < nLength; ti++) {
        Crc = Crc32Table [(Crc ^ pBuffer[ti]) & 0xff] ^ (Crc >> 8);
    }

    return (Crc ^ 0xffffffffL);
}

// ***************************************************************************
//
//  Routine description	: This routine is free GPT entries
//	     
//  Arguments:
//		  [in] pGPTEntryHead : GPT Header to be freed..
//		  [in] nLength : Length .
//
//  Return Value          : UINT32
//
// ***************************************************************************
void FreeGPTEntries(PGPT_ENTRY pGPTEntryHead)
{
	PGPT_ENTRY pFreeGPTEntry;

	while (pGPTEntryHead)
	{
		pFreeGPTEntry = pGPTEntryHead;
		pGPTEntryHead = pGPTEntryHead->NextGPTEntry;
		GlobalFree(pFreeGPTEntry);
	}
}

// ***************************************************************************
//
//  Routine description	: This routine is determine Drive Geometry
//	     
//  Arguments:
//		  [in] hDisk : disk whose geometry has to be found.
//		  [in] pDiskGeometry : structure containing the drive details. .
//
//  Return Value          : UINT32
//
// ***************************************************************************
UINT32 GetDriveGeometry(HANDLE hDisk, PDISK_GEOMETRY_EX pDiskGeometry)
{
	UINT32 nBytesReturned;
	//
	// Get drive goemetry
	//
	if (!DeviceIoControl(hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY_EX,
					NULL,
					0,
					pDiskGeometry,
                    sizeof(DISK_GEOMETRY_EX),
					(PULONG) &nBytesReturned,
					NULL))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_READ_GEOMETRY));
		return EXIT_FAILURE;
	}
        g_nBytesPerSector = pDiskGeometry->Geometry.BytesPerSector;
	return EXIT_SUCCESS;
}


        
// ***************************************************************************
//
//  Routine description	: This routine is display the results.
//	     
//  Arguments:
//		  [in] pString : pointer to the string to be displayed.
//
//
//  Return Value          : VOID
//
// ***************************************************************************

void AddReportSection(PTCHAR pString)
{
	TCHAR StringLine[100];

	int ti, tj;

	AddReport1(pString);
	tj = _tcslen(pString);
	//
	// Make a line like "========" about the size of the string to be displayed as title
	//
	for (ti = 0; (ti < tj) && (ti < 97); ti++)
	{
		StringLine[ti] = _T('-');
	}
	StringLine[ti] = '\r';
	StringLine[ti+1] = '\n';
	StringLine[ti+2] = 0;
	AddReport1(StringLine);
}

// ***************************************************************************
//
//  Routine description	: This routine is display the results.
//	     
//  Arguments:
//		[in]  pString : string to be displayed.
//
//
//  Return Value          : UINT32
//
// ***************************************************************************

void AddReport1(PTCHAR pString)
{
	DISPLAY_MESSAGE(stdout,pString);
}


// ***************************************************************************
//
//   Routine Description			: Frames the Boot File path.
//   Arguments						: 
//		[ in ] szComputerName	: System name
//
//   Return Type					: DWORD 
// ***************************************************************************

DWORD GetBootFilePath(LPTSTR szComputerName,LPTSTR szBootPath)
{
  HKEY     hKey1 = 0;

  HKEY     hRemoteKey = 0;
  TCHAR    szCurrentPath[MAX_STRING_LENGTH + 1] = NULL_STRING;
  TCHAR    szPath[MAX_STRING_LENGTH + 1] = SUBKEY1 ; 
  

  DWORD    dwValueSize = MAX_STRING_LENGTH + 1;
  DWORD    dwRetCode = ERROR_SUCCESS;
  DWORD    dwError = 0;
  TCHAR szTmpCompName[MAX_STRING_LENGTH+1] = NULL_STRING;
  
   TCHAR szTemp[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD len = lstrlen(szTemp);
   TCHAR szVal[MAX_RES_STRING+1] = NULL_STRING ;
   DWORD dwLength = MAX_STRING_LENGTH ;
   LPTSTR szReturnValue = NULL ;
   DWORD dwCode =  0 ;
   LPTSTR szOsLoaderPath = NULL;


   szReturnValue = ( LPTSTR ) malloc( dwLength*sizeof( TCHAR ) );
   szOsLoaderPath = ( LPTSTR ) malloc( dwLength*sizeof( TCHAR ) );
   if((szReturnValue == NULL) || (szOsLoaderPath == NULL ) )
   {
        SAFEFREE(szReturnValue);
		return ERROR_RETREIVE_REGISTRY ;
   }

   if(lstrlen(szComputerName)!= 0 )
	{
	lstrcpy(szTmpCompName,TOKEN_BACKSLASH4);
	lstrcat(szTmpCompName,szComputerName);
  }
  else
  {
	lstrcpy(szTmpCompName,szComputerName);
  }
  
  // Get Remote computer local machine key
  dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
  if (dwError == ERROR_SUCCESS)
  {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if (dwError == ERROR_SUCCESS)
     {
		dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE2, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
		
		if (dwRetCode == ERROR_MORE_DATA)
		{
				dwValueSize += 1024 ;
				szReturnValue = ( LPTSTR ) realloc( szReturnValue , dwValueSize * sizeof( TCHAR ) );
				if(szReturnValue == NULL)
				{
                    SAFEFREE(szOsLoaderPath);
                    SAFEFREE(szReturnValue);
					return ERROR_RETREIVE_REGISTRY ;
				}
				dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE2, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);

		}
		if(dwRetCode != ERROR_SUCCESS)
		{
			RegCloseKey(hKey1);			
			RegCloseKey(hRemoteKey);
            SAFEFREE(szOsLoaderPath);
            SAFEFREE(szReturnValue);
			return ERROR_RETREIVE_REGISTRY ;
		}


		dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE3, NULL, NULL,(LPBYTE) szOsLoaderPath, &dwValueSize);
		if (dwRetCode == ERROR_MORE_DATA)
		{
				dwValueSize += 1024 ;
				szOsLoaderPath 	 = ( LPTSTR ) realloc( szOsLoaderPath, dwValueSize * sizeof( TCHAR ) );
				if(szOsLoaderPath == NULL)
				{
                    SAFEFREE(szOsLoaderPath);
                    SAFEFREE(szReturnValue);
					return ERROR_RETREIVE_REGISTRY ;
				}
				dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE3, NULL, NULL,(LPBYTE) szOsLoaderPath, &dwValueSize);

		}
		if(dwRetCode != ERROR_SUCCESS)
		{
			RegCloseKey(hKey1);			
			RegCloseKey(hRemoteKey);
            SAFEFREE(szOsLoaderPath);
            SAFEFREE(szReturnValue);
			return ERROR_RETREIVE_REGISTRY ;
		}

	 }
	 else
	 {
		RegCloseKey(hRemoteKey);
        SAFEFREE(szOsLoaderPath);
        SAFEFREE(szReturnValue);
		return ERROR_RETREIVE_REGISTRY ;

	 }
		
		_tcscat(szReturnValue,szOsLoaderPath);
		
		lstrcpy(szBootPath,szReturnValue);
	    RegCloseKey(hKey1);
  }
  else
  {
	  RegCloseKey(hRemoteKey);
      SAFEFREE(szOsLoaderPath);
      SAFEFREE(szReturnValue);
	  return ERROR_RETREIVE_REGISTRY ;
  }
 
  RegCloseKey(hRemoteKey);
  SAFEFREE(szOsLoaderPath);
  SAFEFREE(szReturnValue);
  return dwCode ;

}//GetBootFilePath


// ***************************************************************************
//
//   Routine Description			: Retreives the ARC signature path.
//   Arguments						: 
//		[ in ] szComputerName	    : System name
//	    [ out ] szFinalPath         : Final OutPut string.
//
//   Return Type					: DWORD 
// ***************************************************************************

BOOL GetARCSignaturePath(LPTSTR szString,LPTSTR szFinalPath)
{
	TCHAR szSystemPath[256] = NULL_STRING ;  	
	UINT RetVal = 0;
	DWORD dwSize = 256;
	PTCHAR pszTok = NULL ;


	RetVal = GetWindowsDirectory(szSystemPath,256);

	//concatenate some charater which we are sure will not occur 
	//in the string.

	_tcscat(szSystemPath,_T("*"));
	
	pszTok = _tcstok(szSystemPath,TOKEN_BACKSLASH2);
	if(pszTok == NULL)
	{
		return FALSE ;
	}

	pszTok = _tcstok(NULL,_T("*"));
	if(pszTok == NULL)
	{
		return FALSE ;
	}

	lstrcpy(szFinalPath,szString);//szString

	lstrcat(szFinalPath,_T("\\"));
	lstrcat(szFinalPath,pszTok);
	
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\bootcfg64.c ===
/******************************************************************************

	Copyright(c) Microsoft Corporation

	Module Name:

		BootCfg64.cpp

	Abstract:

		
		This file is intended to have the functionality for
		configuring, displaying, changing and deleting boot.ini 
	    settings for the local host for a 64 bit system.

	Author:

		J.S.Vasu		   17/1/2001 .

	Revision History:

		
		J.S.Vasu			17/1/2001	     Created it.
	
		SanthoshM.B			10/2/2001	     Modified it.

		J.S.Vasu			15/2/2001		 Modified it.



******************************************************************************/ 

#include "pch.h"
#include "resource.h"
#include "BootCfg.h"
#include "BootCfg64.h"





//Global Linked lists for storing the boot entries
LIST_ENTRY BootEntries;
LIST_ENTRY ActiveUnorderedBootEntries;
LIST_ENTRY InactiveUnorderedBootEntries;

// ***************************************************************************
//
//  Name			: InitializeEfi
//
//  Synopsis		: This routine initializes the EFI environment required	 
//					  Initializes the function pointers for the
//					  NT Boot Entry Management API's
//				     				 
//  Parameters		: None
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//						LIST_ENTRY ActiveUnorderedBootEntries;
//						LIST_ENTRY InactiveUnorderedBootEntries;
//  
// ***************************************************************************

DWORD InitializeEFI(void)
{
	DWORD error;
    NTSTATUS status;
    BOOLEAN wasEnabled;
    HMODULE hModule;
    PBOOT_ENTRY_LIST ntBootEntries = NULL;
	PMY_BOOT_ENTRY bootEntry;
	PLIST_ENTRY listEntry;
	
	PULONG BootEntryOrder;
	ULONG BootEntryOrderCount;
	PULONG OriginalBootEntryOrder;
	ULONG OriginalBootEntryOrderCount;
    ULONG length, i, myId;

	TCHAR dllName[MAX_PATH]; 
	
    // Enable the privilege that is necessary to query/set NVRAM.
    status = RtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
								TRUE,
								FALSE,
								&wasEnabled
								);
    if (!NT_SUCCESS(status)) 
	{
        error = RtlNtStatusToDosError( status );
		DISPLAY_MESSAGE( stderr, GetResString(IDS_INSUFF_PRIV));

        
	}
	
	// Load ntdll.dll from the system directory. This is used to get the
	// function addresses for the various NT Boot Entry Management API's used by
	// this tool.
    
    if(!GetSystemDirectory( dllName, MAX_PATH ))
	{
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return FALSE;
	}

    lstrcat(dllName, _T("\\ntdll.dll"));

    hModule = LoadLibrary( dllName );
    if ( hModule == NULL )
	{
        DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
        return FALSE;
    }
	
	
    // Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );
	
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{
        if ( status == STATUS_SUCCESS )
		{
            length = 0;
        }
		else
		{
            error = RtlNtStatusToDosError( status );
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );

			return FALSE;
        }
    }
	
    if ( length != 0 )
	{
		
        BootEntryOrder = (PULONG)malloc( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			return FALSE;

		}
		
        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
		{
            error = RtlNtStatusToDosError( status );
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );
			if(BootEntryOrder)
				free(BootEntryOrder);
			return FALSE;
        }
		       
    }
	
    BootEntryOrderCount = length;
    
	//Enumerate all the boot entries
	status = BootCfg_EnumerateBootEntries(&ntBootEntries);
	if ( status != STATUS_SUCCESS )
	{
		error = RtlNtStatusToDosError( status );
		//free the ntBootEntries list
		if(ntBootEntries)
			free(ntBootEntries);
		if(BootEntryOrder)
			free(BootEntryOrder);
        return FALSE;
    }

	//Initialize the various head pointers
	InitializeListHead( &BootEntries );
    InitializeListHead( &ActiveUnorderedBootEntries );
    InitializeListHead( &InactiveUnorderedBootEntries );

	//Convert the bootentries into our know format -- MY_BOOT_ENTRIES.
	if(ConvertBootEntries( ntBootEntries ) == EXIT_FAILURE)
	{
		if(ntBootEntries)
			free(ntBootEntries);
		if(BootEntryOrder)
			free(BootEntryOrder);
		return FALSE;
	}
	
	//free the memory allocated for the enumeration
	if(ntBootEntries)
		free(ntBootEntries);

    // Build the ordered boot entry list.

	myId = 1;

    for ( i = 0; i < BootEntryOrderCount; i++ ) 
	{
        ULONG id = BootEntryOrder[i];
        for ( listEntry = ActiveUnorderedBootEntries.Flink;
		listEntry != &ActiveUnorderedBootEntries;
		listEntry = listEntry->Flink )
		{
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) 
			{
				//Mark this entry as "Ordered" as the ordered id is found
				bootEntry->Ordered = 1;
				//Assign the internal ID
				bootEntry->myId = myId++;
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
		}
        for ( listEntry = InactiveUnorderedBootEntries.Flink;
		listEntry != &InactiveUnorderedBootEntries;
		listEntry = listEntry->Flink ) 
		{
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id ) 
			{
				//Mark this entry as ordered as the ordered id is found
				bootEntry->Ordered = 1;
				//Assign the internal ID
				bootEntry->myId = myId++;
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
    }
	
	//Now add the boot entries that are not a part of the ordered list
	
    for (listEntry = ActiveUnorderedBootEntries.Flink;
	listEntry != &ActiveUnorderedBootEntries;
	listEntry = listEntry->Flink )
	{
		bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		if ( bootEntry->Ordered != 1 ) 
		{
			//Assign the internal ID
			bootEntry->myId = myId++;
			listEntry = listEntry->Blink;
			RemoveEntryList( &bootEntry->ListEntry );
			InsertTailList( &BootEntries, &bootEntry->ListEntry );
			bootEntry->ListHead = &BootEntries;
		}
		
	}
    for (listEntry = InactiveUnorderedBootEntries.Flink;
	listEntry != &InactiveUnorderedBootEntries;
	listEntry = listEntry->Flink) 
	{
		bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		if ( bootEntry->Id != 1 ) 
		{
			//Assign the internal ID
			bootEntry->myId = myId++;
			listEntry = listEntry->Blink;
			RemoveEntryList( &bootEntry->ListEntry );
			InsertTailList( &BootEntries, &bootEntry->ListEntry );
			bootEntry->ListHead = &BootEntries;
		}
	}
	
	if(BootEntryOrder)
		free(BootEntryOrder);
	
		return TRUE;
	
}


// ***************************************************************************
//
//  Name			: QueryBootIniSettings_IA64
//
//  Synopsis		: This routine is displays the boot entries and their settings
//					  for an EFI based machine
//				     				 
//  Parameters		: None
//
//  Return Type		: VOID
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
BOOL QueryBootIniSettings_IA64(void)
{

   	if(DisplayBootOptions() == EXIT_FAILURE)
		return EXIT_FAILURE;

	DisplayBootEntry();

	//Remember to free the memory for the linked lists here
	
	return EXIT_SUCCESS;
} 


// ***************************************************************************
//
//  Name			: BootCfg_EnumerateBootEntries
//
//  Synopsis		: This routine enumerates the boot entries and fills the
//					  BootEntryList
//					  This routine will fill in the Boot entry list. The caller
//					  of this function needs to free the memory for ntBootEntries.
//				     				 
//  Parameters		: Pointer to the BOOT_ENTRY_LIST structure
//
//  Return Type		: NTSTATUS
//
//  Global Variables: None
//  
// ***************************************************************************


NTSTATUS BootCfg_EnumerateBootEntries(PBOOT_ENTRY_LIST *ntBootEntries)
{
	DWORD error;
    NTSTATUS status;
	ULONG length = 0;

    // Query all existing boot entries.
	status = NtEnumerateBootEntries( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{
        if ( status == STATUS_SUCCESS )
		{
            length = 0;
        }
		else
		{
            error = RtlNtStatusToDosError( status );
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ENUM_BOOTENTRY) );
        }
    }
	
    if ( length != 0 ) 
	{
		
        *ntBootEntries = (PBOOT_ENTRY_LIST)malloc( length );
		if(*ntBootEntries == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			return STATUS_UNSUCCESSFUL;
		}
		
        status = NtEnumerateBootEntries( *ntBootEntries, &length );
        if ( status != STATUS_SUCCESS )
		{
            error = RtlNtStatusToDosError( status );
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ENUM_BOOTENTRY) );
        }
	}

	return status;
}


// ***************************************************************************
//
//  Name			: BootCfg_QueryBootOptions
//
//  Synopsis		: This routine enumerates the boot options and fills the
//					  BOOT_OPTIONS
//					  The caller of this function needs to free the memory for
//					  BOOT_OPTIONS.
//				     				 
//  Parameters		: Pointer to the BOOT_ENTRY_LIST structure
//
//  Return Type		: NTSTATUS
//
//  Global Variables: NONE
//  
// ***************************************************************************

NTSTATUS BootCfg_QueryBootOptions(PBOOT_OPTIONS *ppBootOptions)
{
	DWORD error;
    NTSTATUS status;
	ULONG length = 0;

	//Querying the Boot options
	    
    status = NtQueryBootOptions( NULL, &length );
	if ( status == STATUS_NOT_IMPLEMENTED )
	{        
		DISPLAY_MESSAGE( stderr,GetResString(IDS_NO_EFINVRAM) );
    }
	
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{
        error = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTOPTIONS) );
    }
	
    *ppBootOptions = (PBOOT_OPTIONS)malloc(length);
	if(*ppBootOptions == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		return STATUS_UNSUCCESSFUL;
	}
    
    status = NtQueryBootOptions( *ppBootOptions, &length );
    if ( status != STATUS_SUCCESS )
	{
        error = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTOPTIONS) );
    }
   
	return status;
}


// ***************************************************************************
//
//  Name			   : RawStringOsOptions_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 as a raw string at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************

DWORD RawStringOsOptions_IA64(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bRaw = FALSE ;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	
	STRING256 szRawString	  = NULL_STRING ;
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;
	BOOL bAppendFlag = FALSE ;

	STRING256 szAppendString = NULL_STRING ;
	PWINDOWS_OS_OPTIONS pWindowsOptions;

	
	// Building the TCMDPARSER structure

	TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_RAW,     CP_MAIN_OPTION, 1, 0,&bRaw, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE, 1, 0, &bUsage, NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwBootID, NULL_STRING, NULL, NULL },
		{ CMDOPTION_DEFAULT, CP_DEFAULT | CP_TYPE_TEXT | CP_MANDATORY, 1, 0, &szRawString,NULL_STRING, NULL, NULL },
		{ CMDOPTION_APPEND , 0, 1, 0, &bAppendFlag,NULL_STRING, NULL, NULL }
	}; 	 

	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) ) 
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (dwExitCode);
	}

	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		displayRawUsage_IA64();
		return (EXIT_SUCCESS);
	}


	// error checking in case the  
	// raw string does not start with a "/" .
	if(*szRawString != _T('/'))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_FWDSLASH));
		return (EXIT_FAILURE);
	}
	
	//Trim any leading or trailing spaces
	if(szRawString)
		StrTrim(szRawString, _T(" "));
	
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;
			
			
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			}

			
			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;
						
			if(bAppendFlag == TRUE )
			{
				lstrcpy(szAppendString,pWindowsOptions->OsLoadOptions);
				lstrcat(szAppendString,TOKEN_EMPTYSPACE);
				lstrcat(szAppendString,szRawString);
			}
			else
			{
				lstrcpy(szAppendString,szRawString);
			}
			

			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szAppendString) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

			//
			//Change the OS load options. 
			//Pass NULL to friendly name as we are not changing the same
			//szAppendString is the Os load options specified by the user
			//to be appended or to be overwritten over the existing options
			//
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szAppendString);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

		
	//Remember to free memory allocated for the linked lists

	return (dwExitCode);

}


// ***************************************************************************
//
//  Name			   : ChangeBootEntry
//
//  Synopsis		   : This routine is used to change the FriendlyName and the
//						 OS Options for a boot entry.	 
//				     				 
//  Parameters		   : PBOOT_ENTRY bootEntry (in) - Pointer to a BootEntry structure
//						 for which the changes needs to be made
//				         LPTSTR lpNewFriendlyName (in) - String specifying the new friendly name.
//						 LPTSTR lpOSLoadOptions (in) - String specifying the OS load options.
//
//  Return Type	       : DWORD -- ERROR_SUCCESS on success
//							   -- ERROR_FAILURE on failure
//
//  Global Variables   : None
//  
// ***************************************************************************


DWORD ChangeBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName, LPTSTR lpOSLoadOptions)
{
	
	PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;
	PMY_BOOT_ENTRY myChBootEntry;
	NTSTATUS status;
	DWORD error, dwErrorCode = ERROR_SUCCESS;
	
	// Calculate the length of our internal structure. This includes
	// the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
	//
	length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
	myBootEntry = (PMY_BOOT_ENTRY)malloc(length);
	if(myBootEntry == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		dwErrorCode = EXIT_FAILURE;
		return dwErrorCode;
	}
	
	RtlZeroMemory(myBootEntry, length);
	
	//
	// Copy the NT BOOT_ENTRY into the allocated buffer.
	//
	bootEntryCopy = &myBootEntry->NtBootEntry;
	memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
	
	
	myBootEntry->Id = bootEntry->Id;
	myBootEntry->Attributes = bootEntry->Attributes;
	
	//Change the friendly name if lpNewFriendlyName is not NULL
	if(lpNewFriendlyName)
	{
		myBootEntry->FriendlyName = lpNewFriendlyName;
		myBootEntry->FriendlyNameLength = ((ULONG)wcslen(lpNewFriendlyName) + 1) * sizeof(WCHAR);
	}
	else
	{
		myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
		myBootEntry->FriendlyNameLength =
			((ULONG)wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
	}

	myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);
	
	// If this is an NT boot entry, capture the NT-specific information in
	// the OsOptions.
	
	osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;
	
	if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
		(strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
	{
		
		MBE_SET_IS_NT( myBootEntry );
		//To change the OS Load options

		if(lpOSLoadOptions)
		{
			myBootEntry->OsLoadOptions = lpOSLoadOptions;
			myBootEntry->OsLoadOptionsLength =
				((ULONG)wcslen(lpOSLoadOptions) + 1) * sizeof(WCHAR);
		}
		else
		{
			myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
			myBootEntry->OsLoadOptionsLength =
				((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
		}

		myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);
		
	}
	else
	{
		// Foreign boot entry. Just capture whatever OS options exist.
		//
		
		myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
		myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
	}
	
	myChBootEntry = CreateBootEntryFromBootEntry(myBootEntry);
	if(myChBootEntry == NULL)
	{
		dwErrorCode = EXIT_FAILURE;
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr, ERROR_TAG);
		ShowLastError(stderr);
		//free the memory
		if(myBootEntry)
			free(myBootEntry);
		return dwErrorCode;
	}
	//Call the modify API
	status = NtModifyBootEntry(&myChBootEntry->NtBootEntry);
	if ( status != STATUS_SUCCESS )
	{
		error = RtlNtStatusToDosError( status );
		dwErrorCode = error;
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_BOOTENTRY) );
	}

	//free the memory
	if(myChBootEntry)
		free(myChBootEntry);
	if(myBootEntry)
		free(myBootEntry);
	
	return dwErrorCode;
	
}


// ***************************************************************************
//
//  Name			   : CreateBootEntryFromBootEntry
//
//  Synopsis		   : This routine is used to create a new MY_BOOT_ENTRY struct.
//						 The caller of this function needs to free the memory allocated
//						 for the MY_BOOT_ENTRY struct.
//				     				 
//  Parameters		   : PBOOT_ENTRY bootEntry (in) - Pointer to a BootEntry structure
//						 for which the changes needs to be made
//				         LPTSTR lpNewFriendlyName (in) - String specifying the new friendly name.
//						 LPTSTR lpOSLoadOptions (in) - String specifying the OS load options.
//
//  Return Type	       : PMY_BOOT_ENTRY - Pointer to the new MY_BOOT_ENTRY strucure.
//						 NULL on failure
//
//
//  Global Variables   : None
//  
// ***************************************************************************


PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (IN PMY_BOOT_ENTRY OldBootEntry)
{
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY newBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;
	
    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
	
    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);
	
    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;
	
    if ( MBE_IS_NT( OldBootEntry ) ) 
	{

        // Add in base part of WINDOWS_OS_OPTIONS. Calculate length in
        // bytes of OsLoadOptions and add that in.
        //
        requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        osLoadOptionsLength = OldBootEntry->OsLoadOptionsLength;
        requiredLength += osLoadOptionsLength;
		
        // Round up to a ULONG boundary for the OS FILE_PATH in the
        // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Calculate length
        // in bytes of FILE_PATH and add that in. Calculate total length of 
        // WINDOWS_OS_OPTIONS.
        // 
        requiredLength = ALIGN_UP(requiredLength, ULONG);
        osLoadPathOffset = requiredLength;
        requiredLength += OldBootEntry->OsFilePath->Length;
        osLoadPathLength = requiredLength - osLoadPathOffset;
		
    }
	else
	{
		
        // Add in length of foreign OS options.
        //
        requiredLength += OldBootEntry->ForeignOsOptionsLength;
		
        osLoadOptionsLength = 0;
        osLoadPathOffset = 0;
        osLoadPathLength = 0;
    }
	
    osOptionsLength = requiredLength - osOptionsOffset;
	
    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = OldBootEntry->FriendlyNameLength;
    requiredLength += friendlyNameLength;
	
    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Calculate length in bytes of FILE_PATH
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += OldBootEntry->BootFilePath->Length;
    bootPathLength = requiredLength - bootPathOffset;
	
	
    // Allocate memory for the boot entry.
    //
    newBootEntry = (PMY_BOOT_ENTRY)malloc(requiredLength);
	if(newBootEntry == NULL)
		return NULL;
    
    RtlZeroMemory(newBootEntry, requiredLength);
	
    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &newBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)newBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)newBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)newBootEntry + bootPathOffset);
	
    // Fill in the internal-format structure.
    //
	//    newBootEntry->AllocationEnd = (PUCHAR)newBootEntry + requiredLength;
    newBootEntry->Status = OldBootEntry->Status & MBE_STATUS_IS_NT;
    newBootEntry->Attributes = OldBootEntry->Attributes;
    newBootEntry->Id = OldBootEntry->Id;
    newBootEntry->FriendlyName = friendlyName;
    newBootEntry->FriendlyNameLength = friendlyNameLength;
    newBootEntry->BootFilePath = bootPath;
    if ( MBE_IS_NT( OldBootEntry ) ) 
	{
        newBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        newBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
        newBootEntry->OsFilePath = osLoadPath;
    }
	
    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = OldBootEntry->Attributes;
    ntBootEntry->Id = OldBootEntry->Id;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;
	
    if ( MBE_IS_NT( OldBootEntry ) ) 
	{
		
        // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
        // OsLoadOptions.
        //
        strcpy((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE);
        osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
        osOptions->Length = osOptionsLength;
        osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
        wcscpy(osOptions->OsLoadOptions, OldBootEntry->OsLoadOptions);
		
        // Copy the OS FILE_PATH.
        //
        memcpy( osLoadPath, OldBootEntry->OsFilePath, osLoadPathLength );
		
    }
	else 
	{
		
        // Copy the foreign OS options.
        memcpy( osOptions, OldBootEntry->ForeignOsOptions, osOptionsLength );
    }
	
    // Copy the friendly name.
    wcscpy(friendlyName, OldBootEntry->FriendlyName);
	
	// Copy the boot FILE_PATH.
	memcpy( bootPath, OldBootEntry->BootFilePath, bootPathLength );
	
    return newBootEntry;
	
} // CreateBootEntryFromBootEntry



// ***************************************************************************
//
//  Name			: DeleteBootIniSettings_IA64
//
//  Synopsis		: This routine deletes an existing boot entry from an EFI
//					  based machine
//				 
//  Parameters		: DWORD argc (in) - Number of command line arguments
//				      LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
 
DWORD DeleteBootIniSettings_IA64( DWORD argc, LPCTSTR argv[] )
{
	
	BOOL bDelete = FALSE ;
	BOOL bUsage = FALSE;
	DWORD dwBootID = 0;
	
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;
	NTSTATUS status;
	
	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;

	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;

	// Building the TCMDPARSER structure
	
	 TCMDPARSER cmdOptions[] = 
	{
		{ CMDOPTION_DELETE,  CP_MAIN_OPTION,                           1, 0, &bDelete,         NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,         CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwBootID,    NULL_STRING, NULL, NULL }
	}; 
	
	
	// Parsing the delete option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return dwExitCode;
	}
	
	// Displaying delete usage if user specified -? with -delete option
	if( bUsage )
	{
		displayDeleteUsage_IA64();
		return EXIT_SUCCESS;
	}
	
	
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//
		//display an error message if there is only 1 boot entry saying 
		//that it cannot be deleted.
		//
		if (listEntry->Flink == NULL)
		{
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ONLY_ONE_OS));
			dwExitCode = EXIT_FAILURE;
			break ;

		}
		
		
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
	
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			
			//Delete the boot entry specified by the user.
			status = NtDeleteBootEntry(mybootEntry->Id);
			if(status == STATUS_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_DELETE_SUCCESS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_DELETE_FAILURE),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
			}
			break;
		}
	}
		
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}
	
	//Remember to free the memory allocated to the linked lists
	
	return (dwExitCode);
	
}


// ***************************************************************************
//
//  Name			: IsBootEntryWindows
//
//  Synopsis		: Checks whether the boot entry is a Windows or a foreign one
//				 
//  Parameters		: PBOOT_ENTRY bootEntry: Boot entry structure describing the 
//					  boot entry.
//
//  Return Type		: BOOL
//
//  Global Variables: None
//  
// ***************************************************************************


BOOL IsBootEntryWindows(PBOOT_ENTRY bootEntry)
{

    PWINDOWS_OS_OPTIONS osOptions;

	osOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;
	
	if ((bootEntry->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
		(strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
	{
		return TRUE;
	}

	return FALSE;
	
}


// ***************************************************************************
//
//  Name			: GetNtNameForFilePath
//
//  Synopsis		: Converts the FilePath into a NT file path.
//				 
//  Parameters		: PFILE_PATH FilePath: The File path.
//
//  Return Type		: PWSTR: The NT file path.
//
//  Global Variables: None
//  
// ***************************************************************************


PWSTR GetNtNameForFilePath(IN PFILE_PATH FilePath)
{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntPath;
    PWSTR osDeviceNtName;
    PWSTR osDirectoryNtName;
    PWSTR fullNtName;
	DWORD dwDeviceLength = 0;

    length = 0;
    status = NtTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{

        return NULL;
    }

    ntPath = (PFILE_PATH)malloc( length );
	if(ntPath == NULL)
		return NULL;
    status = NtTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntPath,
                &length
                );
    if ( !NT_SUCCESS(status) ) 
	{
		
        if(ntPath)
			free(ntPath);
        return NULL;
    }

	
	
    osDeviceNtName = (PWSTR)ntPath->FilePath;

	osDirectoryNtName = osDeviceNtName + wcslen(osDeviceNtName) + 1;


    length = (ULONG)(wcslen(osDeviceNtName) + wcslen(osDirectoryNtName) + 1) * sizeof(WCHAR);
    
	fullNtName = (PWSTR)malloc( length );
	if(fullNtName == NULL)
	{
		if(ntPath)
			free(ntPath);
		return NULL;
	}

    wcscpy( fullNtName, osDeviceNtName );
    wcscat( fullNtName, osDirectoryNtName );

	if(ntPath)
		free( ntPath );

    return fullNtName;

} // GetNtNameForFilePath



// ***************************************************************************
//
//  Name			: CopyBootIniSettings_IA64
//
//  Synopsis		: This routine copies and existing boot entry for an EFI
//					  based machine. The user can then add the various OS load
//					  options.
//				 
//  Parameters		: DWORD argc (in) - Number of command line arguments
//				      LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
 
DWORD CopyBootIniSettings_IA64( DWORD argc, LPCTSTR argv[] )
{

	BOOL bCopy = FALSE ;
	BOOL bUsage = FALSE;
	DWORD dwExitCode = EXIT_SUCCESS;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
		
	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;

	
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;
	STRING256 szDescription	  = NULL_STRING;

	// Builiding the TCMDPARSER structure
	
	TCMDPARSER cmdOptions[] = {
		{ CMDOPTION_COPY,     CP_MAIN_OPTION,                                   1, 0, &bCopy,         NULL_STRING, NULL, NULL },
		{ SWITCH_DESCRIPTION, CP_TYPE_TEXT | CP_VALUE_MANDATORY,   1, 0, &szDescription, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,    CP_USAGE,                            1, 0, &bUsage,        0, 0 },
		{ SWITCH_ID,          CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY,1, 0, &dwBootID, NULL_STRING, NULL, NULL }
	}; 
	 
	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return dwExitCode;
	}

	// Displaying copy usage if user specified -? with -copy option
	if( bUsage )
	{
		displayCopyUsage_IA64();
		dwExitCode = EXIT_SUCCESS;
		return dwExitCode;
	}
	

	//Query the boot entries till u get the BootID specified by the user
	
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;
			
			//Copy the boot entry specified by the user.
			dwExitCode = CopyBootEntry(bootEntry, szDescription);
			if(dwExitCode == EXIT_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_COPY_SUCCESS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_COPY_ERROR),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
			}
			break;
		}
		
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
		return EXIT_FAILURE ;
	}
	
	//Remember to free the memory allocated for the linked lists
	return EXIT_SUCCESS;
}



// ***************************************************************************
//
//  Name			   : CopyBootEntry
//
//  Synopsis		   : This routine is used to add / copy a boot entry.	 
//				     				 
//  Parameters		   : PBOOT_ENTRY bootEntry (in) - Pointer to a BootEntry structure
//						 for which the changes needs to be made
//				         LPTSTR lpNewFriendlyName (in) - String specifying the new friendly name.
//
//  Return Type	       : DWORD -- ERROR_SUCCESS on success
//							   -- EXIT_FAILURE on failure
//
//  Global Variables   : None
//  
// ***************************************************************************


DWORD CopyBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName)
{
	
	PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length, Id;
	PMY_BOOT_ENTRY myChBootEntry;
	NTSTATUS status;
	DWORD error, dwErrorCode = ERROR_SUCCESS;

	PULONG BootEntryOrder, NewBootEntryOrder, NewTempBootEntryOrder;
		
	// Calculate the length of our internal structure. This includes
	// the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
	//
	length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
	myBootEntry = (PMY_BOOT_ENTRY)malloc(length);
	if(myBootEntry == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		dwErrorCode = EXIT_FAILURE;
		return dwErrorCode;
	}
	
	RtlZeroMemory(myBootEntry, length);
	
	//
	// Copy the NT BOOT_ENTRY into the allocated buffer.
	//
	bootEntryCopy = &myBootEntry->NtBootEntry;
	memcpy(bootEntryCopy, bootEntry, bootEntry->Length);
	
	
	myBootEntry->Id = bootEntry->Id;
	myBootEntry->Attributes = bootEntry->Attributes;
	
	//Change the friendly name if lpNewFriendlyName is not NULL
	if(lpNewFriendlyName && (lstrlen(lpNewFriendlyName) != 0))
	{
		myBootEntry->FriendlyName = lpNewFriendlyName;
		myBootEntry->FriendlyNameLength = ((ULONG)wcslen(lpNewFriendlyName) + 1) * sizeof(WCHAR);
	}
	else
	{
        myBootEntry->FriendlyName = NULL_STRING;
		myBootEntry->FriendlyNameLength = 0;

	}

	myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);
	
	// If this is an NT boot entry, capture the NT-specific information in
	// the OsOptions.
	
	osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;
	
	if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
		(strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
	{
		
		MBE_SET_IS_NT( myBootEntry );
		//To change the OS Load options
		
		myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
		myBootEntry->OsLoadOptionsLength =
			((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
		
		myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);
		
	}
	else
	{
		// Foreign boot entry. Just capture whatever OS options exist.
		//
		
		myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
		myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
	}
	
	myChBootEntry = CreateBootEntryFromBootEntry(myBootEntry);
	if(myChBootEntry == NULL)
	{
		dwErrorCode = EXIT_FAILURE;
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE(stderr, ERROR_TAG);
        if(myBootEntry)
            free(myBootEntry);
		ShowLastError(stderr);
		return dwErrorCode;
	}

	//Call the NtAddBootEntry API
	status = NtAddBootEntry(&myChBootEntry->NtBootEntry, &Id);
	if ( status != STATUS_SUCCESS )
	{
		error = RtlNtStatusToDosError( status );
		dwErrorCode = error;
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_UNEXPECTED) );
	}

    // Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );
	
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{
        if ( status == STATUS_SUCCESS )
		{
            length = 0;
        }
		else
		{
            error = RtlNtStatusToDosError( status );
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );
            if(myBootEntry)
                free(myBootEntry);
            if(myChBootEntry)
				free(myChBootEntry);
		    return FALSE;
        }
    }
	
    if ( length != 0 )
	{
		
        BootEntryOrder = (PULONG)malloc( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			dwErrorCode = EXIT_FAILURE;
			
            if(myBootEntry)
                free(myBootEntry);
		    if(myChBootEntry)
				free(myChBootEntry);
			return dwErrorCode;

		}
		
        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
		{
            error = RtlNtStatusToDosError( status );
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY));
			dwErrorCode = error;
			
            if(myBootEntry)
                free(myBootEntry);
		    if(BootEntryOrder)
				free(BootEntryOrder);
			if(myChBootEntry)
				free(myChBootEntry);
			return dwErrorCode;
        }
		       
    }
	
    //Allocate memory for the new boot entry order.
	NewBootEntryOrder = (PULONG)malloc((length+1) * sizeof(ULONG));
	if(NewBootEntryOrder == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		dwErrorCode = EXIT_FAILURE;
		if(myBootEntry)
           free(myBootEntry);
        if(BootEntryOrder)
			free(BootEntryOrder);
		if(myChBootEntry)
			free(myChBootEntry);
		return dwErrorCode;
	}

	NewTempBootEntryOrder = NewBootEntryOrder;
	memcpy(NewTempBootEntryOrder,BootEntryOrder,length*sizeof(ULONG));
	NewTempBootEntryOrder = NewTempBootEntryOrder + length;
	*NewTempBootEntryOrder =  Id;

	status = NtSetBootEntryOrder(NewBootEntryOrder, length+1);
	if ( status != STATUS_SUCCESS )
	{
		error = RtlNtStatusToDosError( status );
		dwErrorCode = error;
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_SET_BOOTENTRY));
	}

	//free the memory

	if(NewBootEntryOrder)
		free(NewBootEntryOrder);

	if(BootEntryOrder)
		free(BootEntryOrder);

    if(myBootEntry)
           free(myBootEntry);

	if(myChBootEntry)
		free(myChBootEntry);
	
	return dwErrorCode;
	
}


// ***************************************************************************
//
//  Name			: ChangeTimeOut_IA64
//
//  Synopsis		: This routine chnages the Timeout value in the system
//					  global boot options.
//				 
//  Parameters		: DWORD argc (in) - Number of command line arguments
//				      LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type		: DOWRD
//
//  Global Variables: None
//  
// ***************************************************************************
 
DWORD ChangeTimeOut_IA64( DWORD argc, LPCTSTR argv[])
{

	BOOL bTimeOut = FALSE ;
	DWORD dwTimeOut = 0;
	DWORD dwExitCode = EXIT_SUCCESS;
	ULONG Flag = 0;

	
	 TCMDPARSER cmdOptions[] = 
	{
		{ CMDOPTION_TIMEOUT, CP_MAIN_OPTION | CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY,	1,	0,&dwTimeOut,NULL_STRING, NULL, NULL}
	}; 	

	if( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return dwExitCode ;
	}

	//Check for the limit of Timeout value entered by the user.
	if(dwTimeOut > TIMEOUT_MAX) 
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,GetResString(IDS_TIMEOUT_RANGE));
		return dwExitCode;					
	}

	//Call the ModifyBootOptions function with the BOOT_OPTIONS_FIELD_COUNTDOWN
	Flag |= BOOT_OPTIONS_FIELD_COUNTDOWN;

	dwExitCode = ModifyBootOptions(dwTimeOut, NULL, 0, Flag);
	
	return dwExitCode;
}


// ***************************************************************************
//
//  Name			: ModifyBootOptions
//
//  Synopsis		: This routine Modifies the Boot options
//							- Timeout
//							- NextBootEntryID
//							- HeadlessRedirection
//				 
//  Parameters		: ULONG Timeout (in) - The new Timeout value
//				      LPTSTR pHeadlessRedirection (in) - The Headless redirection string
//					  ULONG NextBootEntryID (in) - The NextBootEntryID
//					  ULONG Flag - The Flags indicating what fields that needs to be changed
//										BOOT_OPTIONS_FIELD_COUNTDOWN
//										BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
//										BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION
//  Return Type		: DOWRD
//
//  Global Variables: None
//  
// ***************************************************************************
DWORD ModifyBootOptions(ULONG Timeout, LPTSTR pHeadlessRedirection, ULONG NextBootEntryID, ULONG Flag)
{
	DWORD dwExitCode = EXIT_SUCCESS;
	DWORD error;
    NTSTATUS status;
    ULONG length, i;

	ULONG newlength=0;

	PBOOT_OPTIONS pBootOptions, pModifiedBootOptions;

	//Query the existing Boot options and modify based on the Flag value

	status =  BootCfg_QueryBootOptions(&pBootOptions);
	if(status != STATUS_SUCCESS)
	{
		error = RtlNtStatusToDosError( status );
		//free the ntBootEntries list
		if(pBootOptions)
			free(pBootOptions);
		dwExitCode = EXIT_FAILURE;
        return dwExitCode;

	}

	//Calculate the new length of the BOOT_OPTIONS struct based on the fields that needs to be changed.
	newlength = FIELD_OFFSET(BOOT_OPTIONS, HeadlessRedirection);

	if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
	{
		newlength = FIELD_OFFSET(BOOT_OPTIONS, HeadlessRedirection);
		newlength += lstrlen(pHeadlessRedirection);
		newlength = ALIGN_UP(newlength, ULONG);
	
	}
	else
		newlength = pBootOptions->Length;

	//Also allocate the memory for a new Boot option struct
	pModifiedBootOptions = (PBOOT_OPTIONS)malloc(newlength);
	if(pModifiedBootOptions == NULL)
	{
		dwExitCode = EXIT_FAILURE;
		
		//free the memory for the pBootOptions allocated by the 
		//BootCfg_QueryBootOptions function
		if(pBootOptions)
			free(pBootOptions);
		return dwExitCode;
	}

	//Fill in the new boot options struct

	pModifiedBootOptions->Version = BOOT_OPTIONS_VERSION;
	pModifiedBootOptions->Length = newlength;

	if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
		pModifiedBootOptions->Timeout = Timeout;
	else
		pModifiedBootOptions->Timeout = pBootOptions->Timeout;

	//Cannot change the CurrentBootEntryId.So just pass what u got.
	pModifiedBootOptions->CurrentBootEntryId = pBootOptions->CurrentBootEntryId;

	if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
		pModifiedBootOptions->NextBootEntryId = pBootOptions->NextBootEntryId;
	else
		pModifiedBootOptions->NextBootEntryId = pBootOptions->NextBootEntryId;

	if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
	{
		wcscpy(pModifiedBootOptions->HeadlessRedirection, pBootOptions->HeadlessRedirection);
	}
	else
		wcscpy(pModifiedBootOptions->HeadlessRedirection, pBootOptions->HeadlessRedirection);	
		
	//Set the boot options in the NVRAM
	status = NtSetBootOptions(pModifiedBootOptions, Flag);

	if(status != STATUS_SUCCESS)
	{
		dwExitCode = EXIT_SUCCESS;
		if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_TIMEOUT));
		if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_NEXTBOOTID));
		if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
			DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_HEADLESS));
		
	}
	else
	{
		dwExitCode = EXIT_SUCCESS;
		if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
			DISPLAY_MESSAGE(stdout,GetResString(IDS_SUCCESS_MODIFY_TIMEOUT));
		if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
			DISPLAY_MESSAGE(stdout,GetResString(IDS_SUCCESS_MODIFY_NEXTBOOTID));
		if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
			DISPLAY_MESSAGE(stdout,GetResString(IDS_SUCCESS_MODIFY_HEADLESS));

	}

	//free the memory
	if(pModifiedBootOptions)
		free(pModifiedBootOptions);
	if(pBootOptions)
		free(pBootOptions);

	return dwExitCode;

}


// ***************************************************************************
//
//  Name			: ConvertBootEntries
//
//  Synopsis		: Convert boot entries read from EFI NVRAM into our internal format.
//				 
//  Parameters		: PBOOT_ENTRY_LIST NtBootEntries - The boot entry list given by the enumeration
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//						LIST_ENTRY ActiveUnorderedBootEntries;
//						LIST_ENTRY InactiveUnorderedBootEntries;
//  
// ***************************************************************************

DWORD ConvertBootEntries (PBOOT_ENTRY_LIST NtBootEntries)
{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;
	DWORD dwErrorCode = EXIT_SUCCESS;

    bootEntryList = NtBootEntries;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
		//Remember to check for the NULL pointer
        myBootEntry = (PMY_BOOT_ENTRY)malloc(length);
		if(myBootEntry == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			dwErrorCode = EXIT_FAILURE;
			return dwErrorCode;
		}

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if ( (bootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) != 0 ) {
            InsertTailList( &ActiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &ActiveUnorderedBootEntries;
        } else {
            InsertTailList( &InactiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &InactiveUnorderedBootEntries;
        }

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;
        memcpy(bootEntryCopy, bootEntry, bootEntry->Length);

        //
        // Fill in the base part of the structure.
        //
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->Id = bootEntry->Id;
		//Assign 0 to the Ordered field currently so that 
		//once the boot order is known, we can assign 1 if this entry is a part of the ordered list.
		myBootEntry->Ordered = 0;
        myBootEntry->Attributes = bootEntry->Attributes;
        myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength =
            ((ULONG)wcslen(myBootEntry->FriendlyName) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
            (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0)) {

            MBE_SET_IS_NT( myBootEntry );
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength =
                ((ULONG)wcslen(myBootEntry->OsLoadOptions) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);

        } else {

            //
            // Foreign boot entry. Just capture whatever OS options exist.
            //

            myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
            myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = (PBOOT_ENTRY_LIST)ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    return dwErrorCode;

} // ConvertBootEntries


// ***************************************************************************
//
//  Name			: DisplayBootOptions
//
//  Synopsis		: Display the boot options
//				 
//  Parameters		: NONE
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************


DWORD DisplayBootOptions()
{
	DWORD error;
    NTSTATUS status;
	PBOOT_OPTIONS pBootOptions;
	TCHAR szDisplay[MAX_RES_STRING] = NULL_STRING; 

	//Query the boot options
	status =  BootCfg_QueryBootOptions(&pBootOptions);
	if(status != STATUS_SUCCESS)
	{
		error = RtlNtStatusToDosError( status );
		
		//free the ntBootEntries list
		if(pBootOptions)
			free(pBootOptions);
        return FALSE;

	}

	//Printout the boot options
	_tprintf(_T("\n"));
	
	DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64A));
	DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64B));
	
	_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64C), pBootOptions->Timeout);
	DISPLAY_MESSAGE(stdout,szDisplay);
	
	//Get the CurrentBootEntryId from the actual Id present in the boot options
	_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64D), GetCurrentBootEntryID(pBootOptions->CurrentBootEntryId));
	DISPLAY_MESSAGE(stdout,szDisplay);

#if 0
	if(lstrlen(pBootOptions->HeadlessRedirection) == 0)
	{
		DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64E));
	}
	else
	{
		_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64F), pBootOptions->HeadlessRedirection);
		DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64F));
	}
#endif //Commenting out the display of the Headless redirection 
	   //as we cannot query the same through API (its Firmware controlled)

	if(pBootOptions)
			free(pBootOptions);

	return EXIT_SUCCESS;
		
}

// ***************************************************************************
//
//  Name			: DisplayBootEntry
//
//  Synopsis		: Display the boot entries (in an order)
//				 
//  Parameters		: NONE
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//					  
// ***************************************************************************

VOID DisplayBootEntry()
{
	PLIST_ENTRY listEntry;
	PMY_BOOT_ENTRY bootEntry;
	PFILE_PATH OsLoadPath, BootFilePath;
	PWSTR NtFilePath;
	TCHAR szDisplay[MAX_RES_STRING] = NULL_STRING ;

	//Printout the boot entires
	DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64G));
	DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64H));

	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64I), bootEntry->myId);
		DISPLAY_MESSAGE(stdout,szDisplay);		


		//friendly name
			if(lstrlen(bootEntry->FriendlyName)!=0)
			{
				_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64J), bootEntry->FriendlyName);
				DISPLAY_MESSAGE(stdout,szDisplay);		
			}
			else
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64K));		
			}
		
		if(MBE_IS_NT(bootEntry))
		{
			//the OS load options
			if(lstrlen(bootEntry->OsLoadOptions)!=0)
			{
				_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64L), bootEntry->OsLoadOptions);
				DISPLAY_MESSAGE(stdout,szDisplay);		
			}
			else
			{
				DISPLAY_MESSAGE(stdout,GetResString(IDS_OUTPUT_IA64M));		
		
			}
			
			//Get the BootFilePath
		
			NtFilePath = GetNtNameForFilePath(bootEntry->BootFilePath);
			_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64N), NtFilePath);
			DISPLAY_MESSAGE(stdout,szDisplay);		
			
			//free the memory
			if(NtFilePath)
				free(NtFilePath);
			
			
			//Get the OS load path
			NtFilePath = GetNtNameForFilePath(bootEntry->OsFilePath);
			_stprintf(szDisplay,GetResString(IDS_OUTPUT_IA64O), NtFilePath);
			DISPLAY_MESSAGE(stdout,szDisplay);		

			//free the memory
			if(NtFilePath)
				free(NtFilePath);
		}
		else
		{
			_tprintf(_T("\n"));
		}

	}
	
}


// ***************************************************************************
//
//  Name			: GetCurrentBootEntryID
//
//  Synopsis		: Gets the Boot entry ID generated by us from the BootId given by the NVRAM
//				 
//  Parameters		: DWORD Id -- The current boot id (BootId given by the NVRAM)
//
//  Return Type		: DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//					  
// ***************************************************************************

DWORD GetCurrentBootEntryID(DWORD Id)
{
	PLIST_ENTRY listEntry;
	PMY_BOOT_ENTRY bootEntry;
	
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		if(bootEntry->Id == Id)
		{
			return bootEntry->myId;
		}
		
	}

	return 0;
}


// ***************************************************************************
//
//  Name			   : ChangeDefaultBootEntry_IA64
//
//  Synopsis		   : This routine is to change the Default boot entry in the NVRAM
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables   : None
//  
// ***************************************************************************

DWORD ChangeDefaultBootEntry_IA64(DWORD argc,LPCTSTR argv[])
{

	
	DWORD dwBootID = 0;
	BOOL bDefaultOs = FALSE ;
	DWORD dwExitCode = ERROR_SUCCESS;
	BOOL bBootIdFound = FALSE, bIdFoundInBootOrderList = FALSE;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	
	ULONG length, i, j, defaultId=0;
	NTSTATUS status;
	DWORD error;

	PULONG BootEntryOrder, NewBootEntryOrder, NewTempBootEntryOrder;
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;
	

	TCMDPARSER cmdOptions[] = 
	{
		{ CMDOPTION_DEFAULTOS, CP_MAIN_OPTION, 1, 0,&bDefaultOs, NULL_STRING, NULL, NULL },
		{ SWITCH_ID,CP_TYPE_NUMERIC | CP_VALUE_MANDATORY| CP_MANDATORY, 1, 0, &dwBootID, NULL_STRING, NULL, NULL }
	}; 	



	if( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		dwExitCode = EXIT_FAILURE;
		return dwExitCode ;
	}


	//Check whether the boot entry entered bu the user is a valid boot entry id or not.
		
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			//store the default ID
			defaultId = mybootEntry->Id;
			break;
		}
	}

	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
		return dwExitCode;
	}


	// Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );
	
    if ( status != STATUS_BUFFER_TOO_SMALL )
	{
        if ( status == STATUS_SUCCESS )
		{
            length = 0;
        }
		else
		{
            error = RtlNtStatusToDosError( status );
       		_stprintf(szMsgBuffer, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
			DISPLAY_MESSAGE(stderr,szMsgBuffer);
			dwExitCode = EXIT_FAILURE;
			return dwExitCode;
        }
    }
	
    if ( length != 0 )
	{
		
        BootEntryOrder = (PULONG)malloc( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			DISPLAY_MESSAGE( stderr, ERROR_TAG);
			ShowLastError(stderr);
			dwExitCode = EXIT_FAILURE;
			return dwExitCode;
			
		}
		
        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
		{
            error = RtlNtStatusToDosError( status );
			_stprintf(szMsgBuffer, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
			DISPLAY_MESSAGE(stderr,szMsgBuffer);
			dwExitCode = error;
			if(BootEntryOrder)
				free(BootEntryOrder);
			return dwExitCode;
        }
		
    }

	//Check if the boot id entered by the user is a part of the Boot entry order.
	//If not for the time being do not make it the default.

	for(i=0;i<length;i++)
	{
		if(*(BootEntryOrder+i) == defaultId)
		{
			bIdFoundInBootOrderList = TRUE;
			break;
		}
	}

	if(bIdFoundInBootOrderList == FALSE)
	{
		dwExitCode = EXIT_FAILURE;
		if(BootEntryOrder)
			free(BootEntryOrder);
		_stprintf(szMsgBuffer, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
		DISPLAY_MESSAGE(stderr,szMsgBuffer);
		return dwExitCode;
		
	}

    //Allocate memory for storing the new boot entry order.
	NewBootEntryOrder = (PULONG)malloc((length) * sizeof(ULONG));
	if(NewBootEntryOrder == NULL)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		DISPLAY_MESSAGE( stderr, ERROR_TAG);
		ShowLastError(stderr);
		dwExitCode = EXIT_FAILURE;
		if(BootEntryOrder)
			free(BootEntryOrder);
		return dwExitCode;
	}

	*NewBootEntryOrder =  defaultId;
	j=0;
	for(i=0;i<length;i++)
	{
		if(*(BootEntryOrder+i) == defaultId)
			continue;
		*(NewBootEntryOrder+(j+1)) = *(BootEntryOrder+i);
		j++;
	}


	status = NtSetBootEntryOrder(NewBootEntryOrder, length);
	if ( status != STATUS_SUCCESS )
	{
		error = RtlNtStatusToDosError( status );
		dwExitCode = error;
		_stprintf(szMsgBuffer, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
		DISPLAY_MESSAGE(stderr,szMsgBuffer);

	}
	else
	{
		_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_DEFAULT_ENTRY),dwBootID);
		DISPLAY_MESSAGE(stdout,szMsgBuffer);
	}

	//free the memory
	if(NewBootEntryOrder)
			free(NewBootEntryOrder);
	if(BootEntryOrder)
			free(BootEntryOrder);
		
	return dwExitCode;
}


// ***************************************************************************
//
//  Name			   : ProcessDebugSwitch_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 as a debug string at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
DWORD ProcessDebugSwitch_IA64(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	
	STRING100 szRawString	  = NULL_STRING ;
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szPort[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szBaudRate[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szDebug[MAX_RES_STRING] = NULL_STRING ;
	BOOL bDebug = FALSE ;
	DWORD dwId = 0;
	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR  szTemp[MAX_RES_STRING] = NULL_STRING ;  
	TCHAR  szTmpBuffer[MAX_RES_STRING] = NULL_STRING ;  

	// Building the TCMDPARSER structure


	TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_DEBUG,   CP_MAIN_OPTION | CP_TYPE_TEXT | CP_MODE_VALUES | CP_VALUE_OPTIONAL, 1, 0,&szDebug, CMDOPTION_DEBUG_VALUES, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwBootID,    NULL_STRING, NULL, NULL },
		{ SWITCH_PORT,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY|CP_MODE_VALUES,1,0,&szPort,COM_PORT_RANGE,NULL,NULL},
		{ SWITCH_BAUD,		 CP_TYPE_TEXT | CP_VALUE_MANDATORY |CP_MODE_VALUES,1,0,&szBaudRate,BAUD_RATE_VALUES_DEBUG,NULL,NULL},
	 }; 


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (dwExitCode);
	}

		
	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		displayDebugUsage_IA64();
		return (ERROR_SUCCESS);
	}

	//Trim any leading or trailing spaces
	if(szDebug)
		StrTrim(szDebug, _T(" "));

	if( !( ( lstrcmpi(szDebug,VALUE_ON)== 0) || (lstrcmpi(szDebug,VALUE_OFF)== 0 ) ||(lstrcmpi(szDebug,EDIT_STRING)== 0) ) )
	{
		
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
		return EXIT_FAILURE;

	}
	
    //Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
				
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID) 
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;

	
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			} 
			
			//Change the OS load options. Pass NULL to friendly name as we are not changing the same
			//szRawString is the Os load options specified by the user
			
			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

			// copy the existing OS Loadoptions into a string.
			lstrcpy(szOsLoadOptions,pWindowsOptions->OsLoadOptions);
					
			//check if the user has entered On option 
			if( lstrcmpi(szDebug,VALUE_ON)== 0) 
			{
				//display an error message 
				if ( (_tcsstr(szOsLoadOptions,DEBUG_SWITCH) != 0 )&& (lstrlen(szPort)==0) &&(lstrlen(szBaudRate)==0) )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_DEBUG));
					dwExitCode = EXIT_FAILURE;
					break;
				}

	
				//display a error message and exit if the 1394 port is already present.
				if(_tcsstr(szOsLoadOptions,DEBUGPORT_1394) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_1394_ALREADY_PRESENT));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				
				if( (lstrlen(szPort)==0) &&(lstrlen(szBaudRate)!=0) )
				{
					if( (_tcsstr(szOsLoadOptions,TOKEN_DEBUGPORT) == 0 ) )
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_CANNOT_ADD_BAUDRATE));
						dwExitCode = EXIT_FAILURE;
						break;
					}

				}
				
				//
				//display an duplicate entry error message if substring is already present.
				//
				if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_SUCCESS )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPLICATE_ENTRY));
					return EXIT_FAILURE ;
				}

		
				if(lstrlen(szTemp)!=0)
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPLICATE_ENTRY));
					dwExitCode = EXIT_FAILURE;
					break;
				} 

				
				//check if the Os load options already contains
				// debug switch
				if(_tcsstr(szOsLoadOptions,DEBUG_SWITCH) == 0 )
				{
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,DEBUG_SWITCH);

				}

				
				if(lstrlen(szPort)!= 0)
				{
					lstrcat(szTmpBuffer,TOKEN_EMPTYSPACE);
					lstrcat(szTmpBuffer,TOKEN_DEBUGPORT) ;
					lstrcat(szTmpBuffer,TOKEN_EQUAL) ;
					CharUpper(szPort);
					lstrcat(szTmpBuffer,szPort);
					lstrcat(szOsLoadOptions,szTmpBuffer);
				}
			
				//Check if the OS Load Options contains the baud rate already specified.
				if(lstrlen(szBaudRate)!=0)
				{
					GetBaudRateVal(szOsLoadOptions,szTemp)	;
					if(lstrlen(szTemp)!=0)
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPLICATE_BAUD_RATE));
						dwExitCode = EXIT_FAILURE;
						break;
					}
					else
					{
						lstrcpy(szTemp,BAUD_RATE);
						lstrcat(szTemp,TOKEN_EQUAL);
						lstrcat(szTemp,szBaudRate);
					}
				}
				
				//append the string containing the modified  port value to the string
				lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
				lstrcat(szOsLoadOptions,szTemp);
								
			}
			
			//check if the user has entered OFF  option
			if( lstrcmpi(szDebug,VALUE_OFF)== 0) 
			{
			
				// If the user enters either com port or  baud rate then display error message and exit.
				if ((lstrlen(szPort)!=0) ||(lstrlen(szBaudRate)!=0))
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				// If the user enters either com port or  baud rate then display error message and exit.
				if (_tcsstr(szOsLoadOptions,DEBUG_SWITCH) == 0 )
				{

					DISPLAY_MESSAGE(stderr,GetResString(IDS_DEBUG_ABSENT));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				//remove the debug switch from the OSLoad Options
				removeSubString(szOsLoadOptions,DEBUG_SWITCH);
				
				if(_tcsstr(szOsLoadOptions,DEBUGPORT_1394) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_1394_REMOVE));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				//display an error message if debug port doee not exist.
				if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_FAILURE)
				{

					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_DEBUGPORT));
					return EXIT_FAILURE ;
				}

				if(lstrlen(szTemp)!=0)
				{
					// remove the /debugport=comport switch if it is present from the Boot Entry
					removeSubString(szOsLoadOptions,szTemp);
				}
				
				lstrcpy(szTemp , NULL_STRING );
				//remove the baud rate switch if it is present.
				GetBaudRateVal(szOsLoadOptions,szTemp)	;
				
				// if the OSLoadOptions contains baudrate then delete it. 
				if (lstrlen(szTemp )!= 0)
				{
					removeSubString(szOsLoadOptions,szTemp);
				}

			}

			//if the user selected the edit option .
			if( lstrcmpi(szDebug,EDIT_STRING)== 0) 
			{
				//check if the debug switch is present in the Osload options else display error message. 
				if (_tcsstr(szOsLoadOptions,DEBUG_SWITCH) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DEBUG_ABSENT));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				if( _tcsstr(szOsLoadOptions,DEBUGPORT_1394) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_EDIT_1394_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				//check if the user enters COM port or baud rate else display error message. 
				if((lstrlen(szPort)==0)&&(lstrlen(szBaudRate)==0))
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
					dwExitCode = EXIT_FAILURE;
					break;

				}
				if( lstrlen(szPort)!=0 )
				{
					
					if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_FAILURE)
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_DEBUGPORT));
						return EXIT_FAILURE ;
					}
					
		
					if(lstrlen(szTemp)!=0)
					{
						//remove the existing entry from the OsLoadOptions String.
						removeSubString(szOsLoadOptions,szTemp);
					}
						
					//Add the port entry specified by user into the OsLoadOptions String.
					lstrcat(szTmpBuffer,TOKEN_EMPTYSPACE);
					lstrcat(szTmpBuffer,TOKEN_DEBUGPORT) ;
					lstrcat(szTmpBuffer,TOKEN_EQUAL) ;
					CharUpper(szPort);
					lstrcat(szTmpBuffer,szPort);
					lstrcat(szOsLoadOptions,szTmpBuffer);
								

				}
						
				//Check if the OS Load Options contains the baud rate already specified.
				if(lstrlen(szBaudRate)!=0)
				{
					
					if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_FAILURE)
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_DEBUGPORT));
						return EXIT_FAILURE ;
					}
					if(lstrlen(szTemp)==0)
					{						
						DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_DEBUGPORT));
						return EXIT_FAILURE ;
					}


					lstrcpy(szTemp,NULL_STRING);
					GetBaudRateVal(szOsLoadOptions,szTemp)	;
					if(lstrlen(szTemp)!=0)
					{
						removeSubString(szOsLoadOptions,szTemp);
					}
					lstrcpy(szTemp,BAUD_RATE);
					lstrcat(szTemp,TOKEN_EQUAL);
					lstrcat(szTemp,szBaudRate);
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,szTemp);
				
				}
			
			
			}

			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szOsLoadOptions) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

			// modify the Boot Entry with the modified OsLoad Options. 	
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

		
	//Remember to free memory allocated for the linked lists

	return (dwExitCode);

} 

// ***************************************************************************
//
//  Name			   : GetComPortType_IA64
//
//  Synopsis		   :  Get the Type of  Com Port present in Boot Entry 
//
//  Parameters		   : szString : The String  which is to be searched.
//				         szTemp : String which will get the com port type
//  Return Type	       : VOID
//
//  Global Variables   : None
//  
// ***************************************************************************
VOID  GetComPortType_IA64( LPTSTR  szString,LPTSTR szTemp )
{
	
	if(_tcsstr(szString,PORT_COM1A)!=0) 
	{
		lstrcpy(szTemp,PORT_COM1A);
	}
	else if(_tcsstr(szString,PORT_COM2A)!=0)
	{
		lstrcpy(szTemp,PORT_COM2A);
	}
	else if(_tcsstr(szString,PORT_COM3A)!=0)
	{
		lstrcpy(szTemp,PORT_COM3A);
	}
	else if(_tcsstr(szString,PORT_COM4A)!=0)
	{
		lstrcpy(szTemp,PORT_COM4A);
	}
	else if(_tcsstr(szString,PORT_1394A)!=0)
	{
	 	lstrcpy(szTemp,PORT_1394A);
	} 
}




// ***************************************************************************
//
//  Name			   : ProcessEmsSwitch_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 as a debug string at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
DWORD ProcessEmsSwitch_IA64(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING ;
	TCHAR szEms[MAX_RES_STRING] = NULL_STRING ;
	BOOL bEms = FALSE ;
	
	
	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	
	// Building the TCMDPARSER structure

	  TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_EMS,     CP_MAIN_OPTION | CP_TYPE_TEXT | CP_MODE_VALUES | CP_VALUE_OPTIONAL, 1, 0,&szEms,CMDOPTION_EMS_VALUES_IA64, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY, 1, 0, &dwBootID,    NULL_STRING, NULL, NULL },
	
	 }; 


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (dwExitCode);
	}

		
	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		displayEmsUsage_IA64(); 
		return (EXIT_SUCCESS);
	}

	//display error message if the user enters any other string other that on/off.
	if( !((lstrcmpi(szEms,VALUE_ON)== 0) || (lstrcmpi(szEms,VALUE_OFF)== 0))) 
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
		return EXIT_FAILURE ;
	}
		
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		if(mybootEntry->myId == dwBootID) 
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;

	
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			} 
			
			
			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

			// copy the existing OS Loadoptions into a string.
			lstrcpy(szOsLoadOptions,pWindowsOptions->OsLoadOptions);
					
			//check if the user has entered On option 
			if( lstrcmpi(szEms,VALUE_ON)== 0) 
			{
				if (_tcsstr(szOsLoadOptions,REDIRECT_SWITCH) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_REDIRECT));
					dwExitCode = EXIT_FAILURE;
					break;
				}
	
				// add the redirect switch to the OS Load Options string.
				lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
				lstrcat(szOsLoadOptions,REDIRECT_SWITCH); 
			}
			
			//check if the user has entered OFF  option
			if( lstrcmpi(szEms,VALUE_OFF)== 0) 
			{
				// If the user enters either com port or  baud rate then display error message and exit.
				if (_tcsstr(szOsLoadOptions,REDIRECT_SWITCH) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_REDIRECT_ABSENT));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				//remove the debug switch from the OSLoad Options
				removeSubString(szOsLoadOptions,REDIRECT_SWITCH);
						
			}


			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szOsLoadOptions) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

			// modify the Boot Entry with the modified OsLoad Options. 	
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

	return (dwExitCode);

} 


// ***************************************************************************
//
//  Name			   : ProcessAddSwSwitch_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************

DWORD ProcessAddSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bAddSw = FALSE ;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;

	BOOL bBaseVideo = FALSE ;
	BOOL bNoGui = FALSE ;
	BOOL bSos = FALSE ;
	DWORD dwMaxmem = 0 ; 

	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szMaxmem[MAX_RES_STRING] = NULL_STRING ; 


	// Building the TCMDPARSER structure
	 
	  TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_ADDSW,     CP_MAIN_OPTION, 1, 0,&bAddSw, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY|CP_MANDATORY , 1, 0, &dwBootID,    NULL_STRING, NULL, NULL },
		{ SWITCH_MAXMEM,		 CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY,1,0,&dwMaxmem,NULL_STRING,NULL,NULL},
		{ SWITCH_BASEVIDEO,		 0,1,0,&bBaseVideo,NULL_STRING,NULL,NULL},
		{ SWITCH_NOGUIBOOT,		 0,1,0,&bNoGui,NULL_STRING,NULL,NULL},
		{ SWITCH_SOS,		 0,1,0,&bSos,NULL_STRING,NULL,NULL},
	 }; 


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (dwExitCode);
	}

	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
		displayAddSwUsage_IA64();
		return (EXIT_SUCCESS);
	}

	if((dwMaxmem==0)&&(cmdOptions[3].dwActuals!=0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
		return EXIT_FAILURE ;
	}

	//display an error mesage if none of the options are specified.
	if((!bSos)&&(!bBaseVideo)&&(!bNoGui)&&(dwMaxmem==0))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
		return EXIT_FAILURE ;
	}


	
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;
			
			
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			}


			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

			// copy the existing OS Loadoptions into a string.
			lstrcpy(szOsLoadOptions,pWindowsOptions->OsLoadOptions);

			//check if the user has entered -basevideo option 
			if(bBaseVideo) 
			{
				if (_tcsstr(szOsLoadOptions,BASEVIDEO_VALUE) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_BASEVIDEO_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// add the redirect switch to the OS Load Options string.
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,BASEVIDEO_VALUE); 
				}
				
			}
			
			if(bSos) 
			{
				if (_tcsstr(szOsLoadOptions,SOS_VALUE) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_SOS_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// add the redirect switch to the OS Load Options string.
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,SOS_VALUE); 
				}
				
			}

			if(bNoGui) 
			{
				if (_tcsstr(szOsLoadOptions,NOGUI_VALUE) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_NOGUI_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// add the redirect switch to the OS Load Options string.
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,NOGUI_VALUE); 
				}
				
			}

			if(dwMaxmem!=0)
			{
				// check if the maxmem value is in the valid range.
				if( (dwMaxmem < 32) )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
					dwExitCode = EXIT_FAILURE;
					break;

				}
				
				if (_tcsstr(szOsLoadOptions,MAXMEM_VALUE1) != 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPL_MAXMEM_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// add the redirect switch to the OS Load Options string.
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,MAXMEM_VALUE1); 
					lstrcat(szOsLoadOptions,TOKEN_EQUAL); 
					_ltow(dwMaxmem,szMaxmem,10);
					lstrcat(szOsLoadOptions,szMaxmem); 
				}


			}


			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szOsLoadOptions) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

			//Change the OS load options. Pass NULL to friendly name as we are not changing the same
			//szRawString is the Os load options specified by the user
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

		
	//Remember to free memory allocated for the linked lists

	return (dwExitCode);

}


// ***************************************************************************
//
//  Name			   : ProcessRmSwSwitch_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************

DWORD ProcessRmSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] )
{

	BOOL bUsage = FALSE ;
	BOOL bRmSw = FALSE ;
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;

	BOOL bBaseVideo = FALSE ;
	BOOL bNoGui = FALSE ;
	BOOL bSos = FALSE ;
	
	BOOL bMaxmem = FALSE ; 

	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szMaxmem[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ; 


	// Building the TCMDPARSER structure
 
	TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_RMSW,     CP_MAIN_OPTION, 1, 0,&bRmSw, NULL_STRING, NULL, NULL },
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY|CP_MANDATORY, 1, 0, &dwBootID,    NULL_STRING, NULL, NULL },
		{ SWITCH_MAXMEM,	0,1,0,&bMaxmem,NULL_STRING,NULL,NULL},
		{ SWITCH_BASEVIDEO,	0,1,0,&bBaseVideo,NULL_STRING,NULL,NULL},
		{ SWITCH_NOGUIBOOT,	0,1,0,&bNoGui,NULL_STRING,NULL,NULL},
		{ SWITCH_SOS,		0,1,0,&bSos,NULL_STRING,NULL,NULL},
	 }; 


	// Parsing the copy option switches
	if ( ! DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) )
	{
		dwExitCode = EXIT_FAILURE;
		DISPLAY_MESSAGE(stderr,ERROR_TAG);
		ShowMessage(stderr,GetReason());
		return (dwExitCode);
	}

	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{

		displayRmSwUsage_IA64();
		return (EXIT_SUCCESS);
	}


	//display an error mesage if none of the options are specified.
	if((!bSos)&&(!bBaseVideo)&&(!bNoGui)&&(!bMaxmem))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_RMSW));
		return EXIT_FAILURE;
	}

	
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;
			
			
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			}


			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

			// copy the existing OS Loadoptions into a string.
			lstrcpy(szOsLoadOptions,pWindowsOptions->OsLoadOptions);

			//check if the user has entered -basevideo option 
			if(bBaseVideo) 
			{
				if (_tcsstr(szOsLoadOptions,BASEVIDEO_VALUE) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_BV_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// remove the basevideo switch from the OS Load Options string.
					removeSubString(szOsLoadOptions,BASEVIDEO_VALUE);
				}
				
			}
			
			if(bSos) 
			{
				if (_tcsstr(szOsLoadOptions,SOS_VALUE) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_SOS_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// remove the /sos switch from the  Load Options string.
					removeSubString(szOsLoadOptions,SOS_VALUE);
				}
				
			}

			if(bNoGui) 
			{
				if (_tcsstr(szOsLoadOptions,NOGUI_VALUE) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_NOGUI_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// remove the noguiboot switch to the OS Load Options string.
					removeSubString(szOsLoadOptions,NOGUI_VALUE);
				}
				
			}

			if(bMaxmem)
			{

				if (_tcsstr(szOsLoadOptions,MAXMEM_VALUE1) == 0 )
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_MAXMEM_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}
				else
				{
					// add the redirect switch to the OS Load Options string.
	
					//for, a temporary string of form /maxmem=xx so that it 
					//can be checked in the Os load options,
					
					
					if ( GetSubString(szOsLoadOptions,MAXMEM_VALUE1,szTemp) == EXIT_FAILURE)
					{
						return EXIT_FAILURE ;
					}

					removeSubString(szOsLoadOptions,szTemp);
					if(_tcsstr(szOsLoadOptions,MAXMEM_VALUE1)!=0)
					{
						DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_MAXMEM) );
						return EXIT_FAILURE ;
					}
				}


			}

			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szOsLoadOptions) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

			//Change the OS load options. Pass NULL to friendly name as we are not changing the same
			//szRawString is the Os load options specified by the user
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

	return (dwExitCode);

}


// ***************************************************************************
//
//  Name			   : ProcessDbg1394Switch_IA64
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 at the cmdline to the boot 	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
DWORD ProcessDbg1394Switch_IA64(  DWORD argc, LPCTSTR argv[] )
{
	
	BOOL bUsage = FALSE ;
	BOOL bDbg1394 = FALSE ;
	
	DWORD dwBootID = 0;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	
	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;

	BOOL bBaseVideo = FALSE ;
	BOOL bNoGui = FALSE ;
	BOOL bSos = FALSE ;
	
	BOOL bMaxmem = FALSE ; 

	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szMaxmem[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szChannel[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szDefault[MAX_RES_STRING] = NULL_STRING ; 
	
	DWORD dwChannel = 0 ;
	DWORD dwCode = 0 ;
	

	// Building the TCMDPARSER structure

	TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_DBG1394, CP_MAIN_OPTION, 1, 0,&bDbg1394,NULL_STRING , NULL, NULL }, 
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY , 1, 0, &dwBootID,    NULL_STRING, NULL, NULL }, 
		{ CMDOPTION_CHANNEL, CP_TYPE_NUMERIC | CP_VALUE_MANDATORY,1,0,&dwChannel,NULL_STRING,NULL,NULL},
		{ CMDOPTION_DEFAULT, CP_DEFAULT|CP_TYPE_TEXT , 1, 0, &szDefault,NULL_STRING, NULL, NULL }  
	 
	};  


	// Parsing the copy option switches
	 if ( !(DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) ) )
	{ 
		DISPLAY_MESSAGE(stderr,ERROR_TAG) ;
		ShowMessage(stderr,GetReason()) ;
		return (EXIT_FAILURE);
	} 

	 
	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
	
		displayDbg1394Usage_IA64() ;
		return (EXIT_SUCCESS);
	}


	if((cmdOptions[2].dwActuals == 0) &&(dwBootID == 0 ))
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ID_MISSING));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_1394_HELP));
		return (EXIT_FAILURE);
	}


	//
	//display error message if user enters a value
	// other than on or off
	//
	if( ( lstrcmpi(szDefault,OFF_STRING)!=0 ) && (lstrcmpi(szDefault,ON_STRING)!=0 ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_DEFAULT_MISSING));
		DISPLAY_MESSAGE(stderr,GetResString(IDS_1394_HELP));
		return (EXIT_FAILURE);
	}


	if(( lstrcmpi(szDefault,OFF_STRING)==0 ) &&(dwChannel != 0) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
		return (EXIT_FAILURE);
	}

	if(( lstrcmpi(szDefault,ON_STRING)==0 ) && (cmdOptions[3].dwActuals != 0) &&( (dwChannel < 1) || (dwChannel > 64 ) ) )
	{
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_CH_RANGE));
		return (EXIT_FAILURE);
	}
	
	
	//Query the boot entries till u get the BootID specified by the user
	for (listEntry = BootEntries.Flink;
	listEntry != &BootEntries;
	listEntry = listEntry->Flink) 
	{
		//Get the boot entry
		mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
		
		if(mybootEntry->myId == dwBootID)
		{
			bBootIdFound = TRUE;
			bootEntry = &mybootEntry->NtBootEntry;
			
			
			//Check whether the bootEntry is a Windows one or not.
			//The OS load options can be added only to a Windows boot entry.
			if(!IsBootEntryWindows(bootEntry))
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				DISPLAY_MESSAGE(stderr, GetResString(IDS_INFO_NOTWINDOWS));
				dwExitCode = EXIT_FAILURE;
				break;
			}


			pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

			// copy the existing OS Loadoptions into a string.
			lstrcpy(szOsLoadOptions,pWindowsOptions->OsLoadOptions);

			//check if the user has entered on option
			if(lstrcmpi(szDefault,ON_STRING)==0 )
			{

				if(_tcsstr(szOsLoadOptions,DEBUGPORT) != 0)
				{
					
					DISPLAY_MESSAGE(stderr,GetResString(IDS_DUPLICATE_ENTRY)); 
					dwExitCode = EXIT_FAILURE;
					break;
				}


				if( _tcsstr(szOsLoadOptions,DEBUG_SWITCH)== 0)
				{
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,DEBUG_SWITCH);
				}

				lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
				lstrcat(szOsLoadOptions,DEBUGPORT_1394) ;
		
				if(dwChannel!=0)
				{

					//frame the string and concatenate to the Os Load options.
					lstrcat(szOsLoadOptions,TOKEN_EMPTYSPACE);
					lstrcat(szOsLoadOptions,TOKEN_CHANNEL);
					lstrcat(szOsLoadOptions,TOKEN_EQUAL);
					_ltow(dwChannel,szChannel,10);
					lstrcat(szOsLoadOptions,szChannel);
				}


			}

			if(lstrcmpi(szDefault,OFF_STRING)==0 )
			{
				if(_tcsstr(szOsLoadOptions,DEBUGPORT_1394) == 0)
				{
					DISPLAY_MESSAGE(stderr,GetResString(IDS_NO_1394_SWITCH));
					dwExitCode = EXIT_FAILURE;
					break;
				}

				//
				//remove the port from the Os Load options string.
				//
				removeSubString(szOsLoadOptions,DEBUGPORT_1394);

				// check if the string contains the channel token
				// and if present remove that also.
				//
				if(_tcsstr(szOsLoadOptions,TOKEN_CHANNEL)!=0)
				 {
					lstrcpy(szTemp,NULL_STRING);
					dwCode = GetSubString(szOsLoadOptions,TOKEN_CHANNEL,szTemp);				
					
					if(dwCode == EXIT_SUCCESS)
					{
						//
						//Remove the channel token if present.
						//
						if(lstrlen(szTemp)!= 0)
						{
							removeSubString(szOsLoadOptions,szTemp);
							removeSubString(szOsLoadOptions,DEBUG_SWITCH);
						}
					}
				}
				
				removeSubString(szOsLoadOptions,DEBUG_SWITCH);

			}

			//display error message if Os Load options is more than 254
			// characters.
			if(lstrlen(szOsLoadOptions) >= MAX_RES_STRING)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
				DISPLAY_MESSAGE(stderr,szMsgBuffer);
				break ;

			}

	
			//Change the OS load options. Pass NULL to friendly name as we are not changing the same
			//szRawString is the Os load options specified by the user
			dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
			if(dwExitCode == ERROR_SUCCESS)
			{
				_stprintf(szMsgBuffer, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stdout,szMsgBuffer);
			}
			else
			{
				_stprintf(szMsgBuffer, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
				DISPLAY_MESSAGE(stderr, szMsgBuffer);
			}
			
			break;
		}
	}
	
	if(bBootIdFound == FALSE)
	{
		//Could not find the BootID specified by the user so output the message and return failure
		DISPLAY_MESSAGE(stderr,GetResString(IDS_INVALID_BOOTID));
		dwExitCode = EXIT_FAILURE;
	}

	return (dwExitCode);

}



// ***************************************************************************
//
//  Synopsis		   : Allows the user to add the OS load options specifed 
//						 based on the mirror plex	 
//				     				 
//  Parameters		   : DWORD argc (in) - Number of command line arguments
//				         LPCTSTR argv (in) - Array containing command line arguments
//
//  Return Type	       : DWORD
//
//  Global Variables: Global Linked lists for storing the boot entries
//						LIST_ENTRY BootEntries;
//  
// ***************************************************************************
 DWORD ProcessMirrorSwitch_IA64(  DWORD argc, LPCTSTR argv[] )
{
	
	BOOL bUsage = FALSE ;
	BOOL bDbg1394 = FALSE ;
	
	DWORD dwBootID = 1;
	BOOL bBootIdFound = FALSE;
	DWORD dwExitCode = ERROR_SUCCESS;

	PMY_BOOT_ENTRY mybootEntry;
	PLIST_ENTRY listEntry;
	PBOOT_ENTRY bootEntry;
	PBOOT_ENTRY ModbootEntry;

	TCHAR szMsgBuffer[MAX_RES_STRING] = NULL_STRING;

	BOOL bBaseVideo = FALSE ;
	BOOL bNoGui = FALSE ;
	BOOL bSos = FALSE ;
	
	BOOL bMaxmem = FALSE ; 

	PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
	TCHAR szOsLoadOptions[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szMaxmem[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szTemp[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szChannel[MAX_RES_STRING] = NULL_STRING ; 

	TCHAR szAdd[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szDefault[MAX_RES_STRING] = NULL_STRING ; 
	TCHAR szUpdate[MAX_RES_STRING] = NULL_STRING ; 
	
	DWORD dwChannel = 0 ;
	DWORD dwCode = 0 ;
	BOOL bMirror = FALSE ;
	DWORD dwList = 0 ;
	
	DWORD dwCnt = 0 ;
	TCHAR szArcPath[MAX_RES_STRING] = NULL_STRING ; 
	
	TCHAR szBootPath[MAX_RES_STRING] = NULL_STRING ; 
	
	TCHAR szLdrString[MAX_RES_STRING] = NULL_STRING ; 

	ULONG length = 0 ;
	DWORD Id = 0 ;
	NTSTATUS status ;
	DWORD error = 0 ;
	LONG lRetVal = 0 ;

	

	
	WCHAR pwszLoaderPath[] = L"signature({09de56a0-a122-01c0-507b-9e5f8078f531})\\EFI\\Microsoft\\WINNT50.1\\ia64ldr.efi" ;
	
	WCHAR pwszArcString[] = L"signature(fd0611c0a12101c0a1f404622fd5ec6d)\\WINDOWS=";

	WCHAR pwszArcString1[] =		L"\"Boot Mirror x: - secondary plex\"";

	WCHAR pwszFinalArcString[1024] 	;

	// Building the TCMDPARSER structure

	TCMDPARSER cmdOptions[] = 
	 {
		{ CMDOPTION_MIRROR, CP_MAIN_OPTION, 1, 0,&bMirror,NULL_STRING , NULL, NULL }, 
		{ CMDOPTION_USAGE,   CP_USAGE,                    1, 0, &bUsage,        NULL_STRING, NULL, NULL },
		{ CMDOPTION_LIST, CP_VALUE_OPTIONAL|CP_TYPE_UNUMERIC,1,0,&dwList,NULL_STRING,NULL,NULL},
		{ CMDOPTION_ADD, CP_TYPE_TEXT|CP_VALUE_MANDATORY , 1, 0, &szAdd,NULL_STRING, NULL, NULL }  ,
		{ CMDOPTION_UPDATE, CP_TYPE_TEXT|CP_VALUE_MANDATORY, 1, 0, &szUpdate,NULL_STRING, NULL, NULL },  
		{ SWITCH_ID,		 CP_TYPE_NUMERIC | CP_VALUE_MANDATORY , 1, 0, &dwBootID,    NULL_STRING, NULL, NULL }
	};  


	// Parsing the copy option switches
	 if ( !(DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) ) )
	{ 
		DISPLAY_MESSAGE(stderr,ERROR_TAG) ;
		ShowMessage(stderr,GetReason()) ;
		return (EXIT_FAILURE);
	} 


	
	// Displaying query usage if user specified -? with -query option
	if( bUsage )
	{
	
		displayMirrorUsage_IA64() ;
		return (EXIT_SUCCESS);
	}

	if((cmdOptions[2].dwActuals ==0)&&(cmdOptions[3].dwActuals ==0)&&(cmdOptions[4].dwActuals ==0) )
	{
		DISPLAY_MESSAGE(stdout,GetResString(IDS_MIRROR_SYNTAX));
		return (EXIT_FAILURE);

	}

	if((cmdOptions[2].dwActuals !=0))
	{
		if(dwList > 0)
		{
			//ScanGPT(dwList) ;
            _tprintf(_T("To be implemented.\n"));
			return (EXIT_SUCCESS);
		}
		else
		{
			dwList = 0 ;
			//ScanGPT(dwList) ;
            _tprintf(_T("To be implemented.\n"));
			return (EXIT_SUCCESS);
		}
	}

	if(lstrlen(szAdd) !=0)
	{
		_tprintf(_T("To be implemented.\n"));

	}

	if(lstrlen(szUpdate) !=0)
	{
		_tprintf(_T("To be implemented.\n"));

	}

	return EXIT_SUCCESS ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\bootini\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by script.rc
//
#define IDS_MAIN_USAGE                  1
#define IDS_QUERY_USAGE                 2
#define IDS_CHANGE_USAGE                3
#define IDS_COPY_USAGE                  4
#define IDS_DELETE_USAGE                5

#define IDS_DELETE_HELP_BEGIN           6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16
#define IDS_STRING17                    17
#define IDS_STRING18                    18
#define IDS_STRING19                    19
#define IDS_STRING20                    20
#define IDS_STRING21                    21
#define IDS_STRING22                    22
#define IDS_DELETE_HELP_END             23

#define IDS_QUERY_HELP_BEGIN            73
#define IDS_STRING74                    74
#define IDS_STRING75                    75
#define IDS_STRING76                    76
#define IDS_STRING77                    77
#define IDS_STRING78                    78
#define IDS_STRING79                    79
#define IDS_STRING80                    80
#define IDS_STRING81                    81
#define IDS_STRING82                    82
#define IDS_STRING83                    83
#define IDS_STRING84                    84
#define IDS_STRING85					85
#define IDS_QUERY_HELP_END              86

#define IDS_COPY_HELP_BEGIN             87
#define IDS_STRING88                    88
#define IDS_STRING89                    89
#define IDS_STRING90                    90
#define IDS_STRING91                    91
#define IDS_STRING92                    92
#define IDS_STRING93                    93
#define IDS_STRING94                    94
#define IDS_STRING95                    95
#define IDS_STRING96                    96
#define IDS_STRING97                    97
#define IDS_STRING98                    98
#define IDS_STRING99                    99
#define IDS_STRING100                   100
#define IDS_STRING101                   101
#define IDS_STRING102                   102
#define IDS_STRING103                   103
#define IDS_STRING104                   104
#define IDS_COPY_HELP_END               105

#define IDS_ERROR_TAG                   124

#define IDS_INVALID_BOOTID    		125	
#define IDS_TIMEOUT_CHANGE  		126
#define IDS_TIMEOUT_NO_CHANGE   	127	
#define IDS_REDIRECT_CHANGE     	128
#define IDS_REDIRECT_NO_CHANGE  	129
#define IDS_OS_CHANGE 	    		130
#define IDS_OS_NO_CHANGE 	    	131
#define IDS_NO_ADD_SWITCHES	    	132
#define IDS_NO_REMOVE_SWITCHES  	133
#define IDS_COPY_OS             	134
#define IDS_ONLY_ONE_OS	    		135
#define IDS_DELETE_OS          		136
#define IDS_CONNECT_SYSTEM 	   	    137
#define IDS_BOOTINI            		138
#define IDS_READWRITE_BOOTINI  		139
#define IDS_READING_BOOTINI    		140
#define IDS_RESET_ERROR			    141	
#define IDS_QUERY_HELP64_BEGIN  	142	
#define IDS_QUERY_HELP64A        	143
#define IDS_QUERY_HELP64B	    	144
#define IDS_QUERY_HELP64C	    	145
#define IDS_QUERY_HELP64D	    	146
#define IDS_QUERY_HELP64_END  		147
#define IDS_ERROR_LOAD			148
#define IDS_ERROR_NO_NVRAM		149
#define IDS_UNEXPECTED_ERROR		150
#define IDS_NO_PRIVILAGE		151
#define IDS_DELETE_SUCCESS		152
#define IDS_DELETE_FAILURE		153
#define IDS_ERROR_TIMEOUT		154
#define IDS_ERROR_REDIRECT		155
#define IDS_DEF_CHANGE			156
#define IDS_ADD_FAILURE			157
#define IDS_ADD_SUCCESS			158
#define IDS_COL_BOOTID	    		159
#define IDS_COL_FRIENDLYNAME     	160
#define IDS_COL_COL_BOOTOPTION   	161
#define IDS_COL_FRIENDLYNAME_SIZE 	162
#define IDS_COL_BOOTID_SIZE       	163
#define IDS_COL_BOOTOPTION_SIZE   	164
#define IDS_FORMAT_TABLE	     	165	
#define IDS_FORMAT_LIST	     		166
#define IDS_FORMAT_CSV	     		167
#define IDS_COL_ARCPATH			168
#define IDS_COL_ARCPATH_SIZE	169
#define IDS_OS_HEADER	     	170
#define IDS_DASHES_OS	     	171		
#define IDS_BOOT_HEADER         172
#define IDS_DASHES_BOOTOS	    173
#define IDS_DEFAULT_ARC			174
#define IDS_TIMEOUT		     	175
#define IDS_DEFAULT_OS	     	176		
#define IDS_DEFAULT_ARC_SIZE	177
#define IDS_TIMEOUT_SIZE        178
#define IDS_RAW_USAGE			179

#define IDS_RAW_HELP_BEGIN		180
#define IDS_RAW_HELP1           181
#define IDS_RAW_HELP2			182
#define IDS_RAW_HELP3			183
#define IDS_RAW_HELP4			184
#define IDS_RAW_HELP5			185
#define IDS_RAW_HELP6			186
#define IDS_RAW_HELP7			187
#define IDS_RAW_HELP8			188
#define IDS_RAW_HELP9			189
#define IDS_RAW_HELP10			190
#define IDS_RAW_HELP11			191
#define IDS_RAW_HELP12			192
#define IDS_RAW_HELP13			193
#define IDS_RAW_HELP14			194
#define IDS_RAW_HELP15			195
#define IDS_RAW_HELP16			196
#define IDS_RAW_HELP17			197
#define IDS_RAW_HELP18			198
#define IDS_RAW_HELP19			199
#define IDS_RAW_HELP20			200
#define IDS_RAW_HELP21			201
#define IDS_RAW_HELP_END		202

#define IDS_SWITCH_ADD			203
#define IDS_SWITCH_SKIP			204
#define IDS_SWITCH_REMOVE		205
#define IDS_COPY_SUCCESS		206
#define IDS_DEL_SUCCESS			207

#define IDS_RAW_HELP_IA64_BEGIN	300
#define IDS_RAW_HELP1_IA64      301
#define IDS_RAW_HELP2_IA64		302
#define IDS_RAW_HELP3_IA64		303
#define IDS_RAW_HELP4_IA64		304
#define IDS_RAW_HELP5_IA64		305
#define IDS_RAW_HELP6_IA64		306
#define IDS_RAW_HELP7_IA64		307
#define IDS_RAW_HELP8_IA64		308
#define IDS_RAW_HELP9_IA64		309
#define IDS_RAW_HELP10_IA64		310
#define IDS_RAW_HELP11_IA64		311
#define IDS_RAW_HELP12_IA64		312
#define IDS_RAW_HELP13_IA64		313
#define IDS_RAW_HELP14_IA64		314
#define IDS_RAW_HELP_IA64_END	315

#define IDS_DELETE_HELP_IA64_BEGIN	325
#define IDS_DELETE_HELP1_IA64       326
#define IDS_DELETE_HELP2_IA64		327
#define IDS_DELETE_HELP3_IA64		328
#define IDS_DELETE_HELP4_IA64		329
#define IDS_DELETE_HELP5_IA64		330
#define IDS_DELETE_HELP6_IA64		331
#define IDS_DELETE_HELP7_IA64		332
#define IDS_DELETE_HELP8_IA64		333
#define IDS_DELETE_HELP_IA64_END	334

#define IDS_COPY_ERROR			349

#define IDS_COPY_HELP_IA64_BEGIN	350
#define IDS_COPY_HELP1_IA64         351
#define IDS_COPY_HELP2_IA64		    352
#define IDS_COPY_HELP3_IA64		    353
#define IDS_COPY_HELP4_IA64		    354
#define IDS_COPY_HELP5_IA64		    355
#define IDS_COPY_HELP6_IA64		    356
#define IDS_COPY_HELP7_IA64		    357
#define IDS_COPY_HELP8_IA64		    358
#define IDS_COPY_HELP9_IA64		    359
#define IDS_COPY_HELP10_IA64		360
#define IDS_COPY_HELP_IA64_END   	361

#define IDS_ERROR_MODIFY_TIMEOUT      370
#define IDS_SUCCESS_MODIFY_TIMEOUT    371
#define IDS_ERROR_MODIFY_NEXTBOOTID   372
#define IDS_SUCCESS_MODIFY_NEXTBOOTID 373
#define IDS_ERROR_MODIFY_HEADLESS     374
#define IDS_SUCCESS_MODIFY_HEADLESS   375
#define IDS_SUCCESS_DEFAULT_ENTRY	  376
#define IDS_ERROR_DEFAULT_ENTRY		  377


#define IDS_SUCCESS_OSOPTIONS 400
#define IDS_ERROR_OSOPTIONS   401
#define IDS_INFO_NOTWINDOWS	  402



#define IDS_TIMOUTHELP_BEGIN     	403
#define IDS_TIMOUTHELP1	     		404
#define IDS_TIMOUTHELP2	     		405
#define IDS_TIMOUTHELP3	     		406
#define IDS_TIMOUTHELP4          	407	
#define IDS_TIMOUTHELP5          	408
#define IDS_TIMOUTHELP6          	409
#define IDS_TIMOUTHELP7          	410
#define IDS_TIMOUTHELP8         	411
#define IDS_TIMOUTHELP9         	412
#define IDS_TIMOUTHELP10        	413
#define IDS_TIMOUTHELP11        	414
#define IDS_TIMOUTHELP12        	415
#define IDS_TIMOUTHELP13        	416
#define IDS_TIMOUTHELP14        	417
#define IDS_TIMOUTHELP_END 	   	    418

#define IDS_DEFAULT_BEGIN        	420
#define IDS_DEFAULT1	     		421
#define IDS_DEFAULT2	     		422
#define IDS_DEFAULT3	     		423
#define IDS_DEFAULT4	     		424
#define IDS_DEFAULT5 	     		425
#define IDS_DEFAULT6 	    		426
#define IDS_DEFAULT7            	427
#define IDS_DEFAULT8            	428
#define IDS_DEFAULT9	    		429
#define IDS_DEFAULT10	    		430
#define IDS_DEFAULT11	    		431
#define IDS_DEFAULT12	    		432
#define IDS_DEFAULT13	    		433
#define IDS_DEFAULT14	    		434
#define IDS_DEFAULT_END	    		435

#define IDS_TIMEOUT_USAGE          	437
#define IDS_DEFAULTOS_USAGE       	438
#define IDS_ERR_CHANGE			    439
#define IDS_INVALID_OSID		    440
#define IDS_TIMEOUT_RANGE		    441


#define IDS_TIMOUTHELP_IA64_BEGIN   450
#define IDS_TIMOUTHELP1_IA64     	451
#define IDS_TIMOUTHELP2_IA64     	452
#define IDS_TIMOUTHELP3_IA64     	453
#define IDS_TIMOUTHELP4_IA64     	454
#define IDS_TIMOUTHELP5_IA64     	455
#define IDS_TIMOUTHELP6_IA64     	456
#define IDS_TIMOUTHELP7_IA64     	457
#define IDS_TIMOUTHELP8_IA64		458
#define IDS_TIMOUTHELP_IA64_END	   	459

#define IDS_MAIN_HELP_BEGIN			500      
#define IDS_MAIN_HELP1				501
#define IDS_MAIN_HELP2				502
#define IDS_MAIN_HELP3				503
#define IDS_MAIN_HELP4				504
#define IDS_MAIN_HELP5				505
#define IDS_MAIN_HELP6				506
#define IDS_MAIN_HELP7				507
#define IDS_MAIN_HELP8				508
#define IDS_MAIN_HELP9				509
#define IDS_MAIN_HELP10				510
#define IDS_MAIN_HELP11				511
#define IDS_MAIN_HELP12				512
#define IDS_MAIN_HELP13				513
#define IDS_MAIN_HELP14				514
#define IDS_MAIN_HELP15				515
#define IDS_MAIN_HELP16				516
#define IDS_MAIN_HELP17				517
#define IDS_MAIN_HELP18				518
#define IDS_MAIN_HELP19				519
#define IDS_MAIN_HELP_END			520

#define IDS_MAIN_HELP_IA64_BEGIN    850
#define IDS_MAIN_HELP1_IA64         851 
#define IDS_MAIN_HELP2_IA64         852 
#define IDS_MAIN_HELP3_IA64         853
#define IDS_MAIN_HELP4_IA64         854
#define IDS_MAIN_HELP5_IA64         855
#define IDS_MAIN_HELP6_IA64         856
#define IDS_MAIN_HELP7_IA64         857
#define IDS_MAIN_HELP8_IA64         858
#define IDS_MAIN_HELP9_IA64         859 
#define IDS_MAIN_HELP10_IA64        860 
#define IDS_MAIN_HELP11_IA64        861 
#define IDS_MAIN_HELP12_IA64        862 
#define IDS_MAIN_HELP13_IA64		863
#define IDS_MAIN_HELP14_IA64		864
#define IDS_MAIN_HELP15_IA64		865
#define IDS_MAIN_HELP16_IA64		866
#define IDS_MAIN_HELP17_IA64		867
#define IDS_MAIN_HELP18_IA64		868
#define IDS_MAIN_HELP19_IA64		869
#define IDS_MAIN_HELP20_IA64		870
#define IDS_MAIN_HELP21_IA64		871
#define IDS_MAIN_HELP22_IA64		872
#define IDS_MAIN_HELP23_IA64		873
#define IDS_MAIN_HELP24_IA64		874
#define IDS_MAIN_HELP25_IA64		875
#define IDS_MAIN_HELP26_IA64		876
#define IDS_MAIN_HELP27_IA64		877
#define IDS_MAIN_HELP28_IA64		878
#define IDS_MAIN_HELP29_IA64		879
#define IDS_MAIN_HELP30_IA64		880
#define IDS_MAIN_HELP31_IA64		881
#define IDS_MAIN_HELP32_IA64		882
#define IDS_MAIN_HELP33_IA64		883
#define IDS_MAIN_HELP34_IA64		884
#define IDS_MAIN_HELP35_IA64		885
#define IDS_MAIN_HELP36_IA64		886
#define IDS_MAIN_HELP37_IA64		887
#define IDS_MAIN_HELP38_IA64		888
#define IDS_MAIN_HELP_IA64_END		889

#define IDS_DEFAULT_IA64_BEGIN   580
#define IDS_DEFAULT1_IA64	     581
#define IDS_DEFAULT2_IA64	     582
#define IDS_DEFAULT3_IA64	     583
#define IDS_DEFAULT4_IA64	     584
#define IDS_DEFAULT5_IA64	     585
#define IDS_DEFAULT6_IA64	     586
#define IDS_DEFAULT7_IA64	     587
#define IDS_DEFAULT_IA64_END     588


#define IDS_MAIN_HELP_BEGIN1      590
#define IDS_MAIN_HELP1A           591
#define IDS_MAIN_HELP2A           592
#define IDS_MAIN_HELP3A           593
#define IDS_MAIN_HELP4A           594
#define IDS_MAIN_HELP5A			  595	
#define IDS_MAIN_HELP6A			  596	
#define IDS_MAIN_HELP7A			  597
#define IDS_MAIN_HELP8A			  598
#define IDS_MAIN_HELP9A			  599
#define IDS_MAIN_HELP10A		  600
#define IDS_MAIN_HELP11A		  601
#define IDS_MAIN_HELP12A		  602
#define IDS_MAIN_HELP13A	      603
#define IDS_MAIN_HELP14A		  604
#define IDS_MAIN_HELP15A		  605
#define IDS_MAIN_HELP16A		  606
#define IDS_MAIN_HELP17A		  607
#define IDS_MAIN_HELP18A		  608
#define IDS_MAIN_HELP19A		  609
#define IDS_MAIN_HELP20A		  610
#define IDS_MAIN_HELP21A		  611
#define IDS_MAIN_HELP22A		  612	
#define IDS_MAIN_HELP23A		  613
#define IDS_MAIN_HELP24A		  614	
#define IDS_MAIN_HELP25A		  615
#define IDS_MAIN_HELP26A		  616
#define IDS_MAIN_HELP27A		  617
#define IDS_MAIN_HELP28A		  618
#define IDS_MAIN_HELP29A		  619
#define IDS_MAIN_HELP30A		  620
#define IDS_MAIN_HELP31A		  621
#define IDS_MAIN_HELP32A		  622
#define IDS_MAIN_HELP33A		  623
#define IDS_MAIN_HELP34A		  624
#define IDS_MAIN_HELP35A		  625
#define IDS_MAIN_HELP36A		  626
#define IDS_MAIN_HELP37A		  627
#define IDS_MAIN_HELP_END1		  628	


#define IDS_SWITCH_CHANGE		     630
#define IDS_ERROR_NO_COM_PORT	     631
#define IDS_ERROR_NO_BAUD_VAL	     632
#define IDS_ERROR_NO_DBG_SWITCH	     633
#define IDS_ERROR_DUPLICATE_COM_PORT 634
#define IDS_ERROR_DUPLICATE_BAUD_VAL 635
#define IDS_EMS_CHANGE_BOOTLOADER	 636 
#define IDS_EMS_CHANGE_ERROR_BLOADER 637
#define IDS_NO_REDIRECT_SWITCH		 638
#define IDS_INVALID_SYNTAX_OFF		 639
#define IDS_DUPL_REDIRECT_SWITCH	 640
#define IDS_EMS_CHANGE_BAUDRATE		 641
#define IDS_EMS_CHANGE_ERROR_BAUDRATE 642

#define IDS_EMS_BEGIN_X86    645
#define	IDS_EMS1		     646
#define IDS_EMS2		     647
#define IDS_EMS3			 648
#define IDS_EMS4			 649
#define IDS_EMS5 		 	 650
#define IDS_EMS6 			 651
#define IDS_EMS7			 652
#define IDS_EMS8			 653
#define	IDS_EMS9			 654
#define	IDS_EMS10			 655
#define IDS_EMS11			 656
#define	IDS_EMS12			 657
#define	IDS_EMS13            658
#define IDS_EMS14 			 659
#define IDS_EMS15		     660
#define IDS_EMS16		     661
#define IDS_EMS17		     662
#define IDS_EMS18		     663
#define IDS_EMS19		     664
#define IDS_EMS20		     665
#define IDS_EMS21		     666
#define IDS_EMS22		     667
#define IDS_EMS23			 668
#define IDS_EMS24			 669
#define IDS_EMS25			 670
#define IDS_EMS26			 671
#define IDS_EMS27			 672
#define IDS_EMS28			 673
#define IDS_EMS29			 674
#define IDS_EMS_END_X86		 675

#define IDS_DEBUG_BEGIN_X86  680
#define	IDS_DEBUG1		     681
#define IDS_DEBUG2		     682
#define IDS_DEBUG3			 683
#define IDS_DEBUG4			 684
#define IDS_DEBUG5 		 	 685
#define IDS_DEBUG6 			 686
#define IDS_DEBUG7			 687
#define IDS_DEBUG8			 688
#define	IDS_DEBUG9			 689
#define	IDS_DEBUG10			 690
#define IDS_DEBUG11			 691
#define	IDS_DEBUG12			 692
#define	IDS_DEBUG13          693
#define IDS_DEBUG14 		 694
#define IDS_DEBUG15		     695
#define IDS_DEBUG16		     696
#define IDS_DEBUG17		     697
#define IDS_DEBUG18		     698
#define IDS_DEBUG19		     699
#define IDS_DEBUG20		     700
#define IDS_DEBUG21		     701
#define IDS_DEBUG22		     702
#define IDS_DEBUG23		     703
#define IDS_DEBUG24		     704
#define IDS_DEBUG25			 705	
#define IDS_DEBUG26			 706
#define IDS_DEBUG27			 707
#define IDS_DEBUG_END_X86	 708


#define IDS_WARN_REDIRECT	  712
#define IDS_WARN_REDIRECTBAUD 713
#define IDS_DUPL_DEBUG		  714


#define IDS_EMS_BEGIN_IA64   715
#define	IDS_EMS1A		     716
#define IDS_EMS2A		     717
#define IDS_EMS3A			 718
#define IDS_EMS4A			 719
#define IDS_EMS5A 		 	 720
#define IDS_EMS6A 			 721
#define IDS_EMS7A			 722
#define IDS_EMS8A			 723
#define	IDS_EMS9A			 724
#define	IDS_EMS10A			 725
#define	IDS_EMS11A			 726
#define IDS_EMS_END_IA64	 727


#define IDS_DEBUG_BEGIN_IA64  740
#define	IDS_DEBUG1A		     741
#define IDS_DEBUG2A		     742
#define IDS_DEBUG3A			 743
#define IDS_DEBUG4A			 744
#define IDS_DEBUG5A 		 745
#define IDS_DEBUG6A 		 746
#define IDS_DEBUG7A			 747
#define IDS_DEBUG8A			 748
#define	IDS_DEBUG9A			 749
#define	IDS_DEBUG10A		 750
#define IDS_DEBUG11A		 751
#define	IDS_DEBUG12A		 752
#define	IDS_DEBUG13A         753
#define IDS_DEBUG14A 		 754
#define IDS_DEBUG15A		 755
#define IDS_DEBUG16A		 756
#define IDS_DEBUG17A		 757
#define IDS_DEBUG18A		 758
#define IDS_DEBUG19A		 759
#define IDS_DEBUG_END_IA64	 760

#define IDS_DEBUG_ABSENT      770
#define IDS_DEBUG_PORT_ABSENT 771
#define IDS_INVALID_SYNTAX	  772 
#define IDS_SUCCESS_CHANGE_OSOPTIONS 773
#define IDS_ERROR_CHANGE_OSOPTIONS 774
#define IDS_DUPL_REDIRECT		775

#define IDS_ERROR_BOOT_OPTIONS 776
#define IDS_REDIRECT_ABSENT	777	
#define IDS_INVALID_EDIT_SYNTAX 778
#define IDS_USER_BUT_NOMACHINE 779
#define IDS_PASSWD_BUT_NOUSER  780
#define IDS_ERROR_NO_PORT      781
#define IDS_ERROR_NULL_SERVER  782
#define IDS_ERROR_NULL_USER    783
#define IDS_DUPLICATE_ENTRY    784
#define IDS_DUPLICATE_BAUD_RATE 785

#define WARN_LOCALCREDENTIALS	787
#define IDS_MAX_BOOTID			788
#define IDS_INVALID_OPERATION	789	
#define IDS_DUPL_NOGUI_SWITCH  790	
#define IDS_DUPL_SOS_SWITCH   791
#define IDS_DUPL_BASEVIDEO_SWITCH  792
#define IDS_DUPL_MAXMEM_SWITCH    793
#define IDS_ERROR_MAXMEM_VALUES	  794
#define IDS_NO_MAXMEM_SWITCH    795
#define IDS_NO_SOS_SWITCH		796
#define	IDS_NO_BV_SWITCH  797  
#define IDS_NO_NOGUI_SWITCH   798
#define IDS_SWITCH_DELETE		799
#define IDS_NO_SWITCH_DELETE  800
#define IDS_NO_MAXMEM				801

#define IDS_ADDSW_BEGIN_X86		900
#define IDS_ADDSW1		901
#define IDS_ADDSW2		902
#define IDS_ADDSW3		903
#define IDS_ADDSW4		904
#define IDS_ADDSW5		905
#define IDS_ADDSW6		906
#define IDS_ADDSW7		907
#define IDS_ADDSW8		908
#define IDS_ADDSW9		909
#define IDS_ADDSW10		911
#define IDS_ADDSW11		912
#define IDS_ADDSW12		913
#define IDS_ADDSW13		914
#define IDS_ADDSW14		915
#define IDS_ADDSW15		916
#define IDS_ADDSW16		917
#define IDS_ADDSW17		918
#define IDS_ADDSW18		919
#define IDS_ADDSW19		920
#define IDS_ADDSW20		921
#define IDS_ADDSW21		922
#define IDS_ADDSW22		923
#define IDS_ADDSW23		924
#define IDS_ADDSW24		925
#define IDS_ADDSW25		926
#define IDS_ADDSW26		927
#define IDS_ADDSW27		928
#define IDS_ADDSW28		929
#define IDS_ADDSW29		930
#define IDS_ADDSW30		931
#define IDS_ADDSW_END_X86 		932

#define IDS_ADDSW_BEGIN_IA64	940
#define IDS_ADDSW1A		941
#define IDS_ADDSW2A		942
#define IDS_ADDSW3A		943
#define IDS_ADDSW4A		944
#define IDS_ADDSW5A		945
#define IDS_ADDSW6A		946
#define IDS_ADDSW7A		947
#define IDS_ADDSW8A		948
#define IDS_ADDSW9A		949
#define IDS_ADDSW10A		951
#define IDS_ADDSW11A	952
#define IDS_ADDSW12A	953
#define IDS_ADDSW13A		954
#define IDS_ADDSW14A		955
#define IDS_ADDSW15A		956
#define IDS_ADDSW16A		957
#define IDS_ADDSW17A		958
#define IDS_ADDSW18A		959
#define IDS_ADDSW19A		960
#define IDS_ADDSW20A		961
#define IDS_ADDSW21A		962
#define IDS_ADDSW22A		963
#define IDS_ADDSW_END_IA64	964



#define IDS_RMSW_BEGIN_X86  970      
#define IDS_RMSW1		    971 
#define IDS_RMSW2		    972 
#define IDS_RMSW3			973 
#define IDS_RMSW4			974 
#define IDS_RMSW5 		 	975 
#define IDS_RMSW6 		    976 
#define IDS_RMSW7			977 
#define IDS_RMSW8			978 
#define IDS_RMSW9			979 
#define IDS_RMSW10			980 
#define IDS_RMSW11			981 
#define IDS_RMSW12			982 
#define IDS_RMSW13          983 
#define IDS_RMSW14			984 
#define IDS_RMSW15          985 
#define IDS_RMSW16          986 
#define IDS_RMSW17          987 
#define IDS_RMSW18 		    988 
#define IDS_RMSW19		    989 
#define IDS_RMSW20		    990 
#define IDS_RMSW21		    991 
#define IDS_RMSW22		    992 
#define IDS_RMSW23		    993 
#define IDS_RMSW24		    994 
#define IDS_RMSW25		    995 
#define IDS_RMSW26		    996 
#define IDS_RMSW27		    997 
#define IDS_RMSW28		    998
#define IDS_RMSW29		    999
#define IDS_RMSW_END_X86	1000

#define IDS_RMSW_BEGIN_IA64  1010      
#define IDS_RMSW1A		    1011 
#define IDS_RMSW2A		    1012 
#define IDS_RMSW3A			1013
#define IDS_RMSW4A			1014
#define IDS_RMSW5A		 	1015
#define IDS_RMSW6A 		    1016
#define IDS_RMSW7A			1017
#define IDS_RMSW8A			1018
#define IDS_RMSW9A			1019
#define IDS_RMSW10A			1020
#define IDS_RMSW11A			1021
#define IDS_RMSW12A			1022
#define IDS_RMSW13A         1023
#define IDS_RMSW14A			1024
#define IDS_RMSW15A         1025
#define IDS_RMSW16A         1026
#define IDS_RMSW17A         1027
#define IDS_RMSW18A 		1028
#define IDS_RMSW19A		    1029
#define IDS_RMSW20A		    1030
#define IDS_RMSW21A		    1031
#define IDS_RMSW_END_IA64	1032


#define IDS_NO_COM_PORT  1050
#define IDS_OPTION_SNTAX_ERROR 1051
#define IDS_OPTION_SYNTAX	1052

#define IDS_INVALID_SYNTAX_ADDSW  1070
#define IDS_INVALID_SYNTAX_RMSW  1071
#define IDS_INVALID_SYNTAX_DEBUG  1072
#define IDS_INVALID_SYNTAX_EMS	1073

#define IDS_NO_1394_SWITCH   1080
#define IDS_DUPL_1394_SWITCH 1081
#define IDS_ERROR_LOAD_OSOPTIONS 1082
#define IDS_INVALID_SYNTAX_DBG1394 1083
#define IDS_INVALID_CH_RANGE	1084


#define  IDS_DBG1394_BEGIN_IA64   2000
#define  IDS_DBG1394_IA64A		2001
#define  IDS_DBG1394_IA64B		2002
#define  IDS_DBG1394_IA64C		2003
#define  IDS_DBG1394_IA64D		2004
#define  IDS_DBG1394_IA64E      2005 
#define  IDS_DBG1394_IA64F		2006
#define  IDS_DBG1394_IA64G		2007
#define  IDS_DBG1394_IA64H		2008
#define  IDS_DBG1394_IA64I		2009
#define  IDS_DBG1394_IA64J 		2010
#define  IDS_DBG1394_IA64K 		2011
#define  IDS_DBG1394_IA64L	    2012
#define	 IDS_DBG1394_IA64M	    2013
#define  IDS_DBG1394_IA64N	    2014	
#define  IDS_DBG1394_IA64O      2015  
#define  IDS_DBG1394_IA64P	    2016 
#define  IDS_DBG1394_IA64Q	    2017 
#define  IDS_DBG1394_IA64R	    2018
#define  IDS_DBG1394_END_IA64	2019



#define IDS_DBG1394_BEGIN_X86   2025
#define IDS_DBG1394A		    2026
#define IDS_DBG1394B		    2027 
#define IDS_DBG1394C			2028 
#define IDS_DBG1394D			2029
#define IDS_DBG1394E            2030
#define IDS_DBG1394F            2031
#define IDS_DBG1394G            2032
#define IDS_DBG1394H            2033
#define IDS_DBG1394I            2034
#define IDS_DBG1394J            2035
#define IDS_DBG1394K 		    2036
#define IDS_DBG1394L 		    2037
#define IDS_DBG1394M	        2038
#define IDS_DBG1394N	        2039
#define IDS_DBG1394O		    2040
#define IDS_DBG1394P            2041
#define IDS_DBG1394Q	        2042
#define IDS_DBG1394R	        2043
#define IDS_DBG1394S	        2044
#define  IDS_DBG1394T			2045
#define  IDS_DBG1394U	        2046 


#define IDS_DBG1394_END_X86	   2055
#define IDS_ERROR_1394_REMOVE  2056
#define IDS_ERROR_VERSION_MISMATCH 2057
#define IDS_ERROR_SYSTEM_INFO  2058
#define IDS_ERROR_ID_MISSING   2060
#define IDS_EMS_HELP		2061
#define IDS_ERROR_EDIT_1394_SWITCH    2062
#define IDS_1394_HELP 2063
#define IDS_ERROR_BAUDRATE_HELP  2064
#define IDS_ERROR_DEFAULT_MISSING 2065
#define IDS_REMOTE_NOT_SUPPORTED  2066 		

#define WARNING_STRING	2067
#define IDS_CANNOT_ADD_BAUDRATE 2068
#define IDS_1394_ALREADY_PRESENT 2069

#define IDS_ERROR_QUERY_BOOTENTRY   2080    
#define IDS_ERROR_ENUM_BOOTENTRY    2081    
#define IDS_ERROR_QUERY_BOOTOPTIONS 2082    
#define IDS_ERROR_MODIFY_BOOTENTRY  2083    
#define IDS_ERROR_UNEXPECTED        2084    
#define IDS_ERROR_SET_BOOTENTRY     2085    

#define IDS_INSUFF_PRIV		2086
#define IDS_NO_EFINVRAM		2087
#define IDS_NO_DEBUGPORT	2088
#define IDS_NO_TOKENS		2089

#define IDS_MIRROR_BEGIN_IA64   3000
#define IDS_MIRROR_IA64A		3001
#define IDS_MIRROR_IA64B		3002
#define IDS_MIRROR_IA64C		3003
#define IDS_MIRROR_IA64D		3004
#define IDS_MIRROR_IA64E		3005
#define	IDS_MIRROR_IA64F		3006
#define IDS_MIRROR_IA64G		3007
#define	IDS_MIRROR_IA64H		3008
#define	IDS_MIRROR_IA64I		3009
#define	IDS_MIRROR_IA64J 		3010
#define IDS_MIRROR_IA64K 		3011
#define IDS_MIRROR_IA64L		3012
#define IDS_MIRROR_IA64M		3013
#define IDS_MIRROR_IA64N		3014
#define IDS_MIRROR_IA64O		3015
#define IDS_MIRROR_IA64P		3016
#define IDS_MIRROR_IA64Q		3017
#define IDS_MIRROR_IA64R		3018
#define IDS_MIRROR_IA64S		3019

#define IDS_MIRROR_END_IA64		3020
#define IDS_NO_FWDSLASH			3021
#define IDS_NO_FILE				3022

#define IDS_OUTPUT_IA64A		3040
#define IDS_OUTPUT_IA64B		3041
#define IDS_OUTPUT_IA64C		3042
#define IDS_OUTPUT_IA64D		3043
#define IDS_OUTPUT_IA64E		3044
#define IDS_OUTPUT_IA64F		3045
#define IDS_OUTPUT_IA64G		3046
#define IDS_OUTPUT_IA64H        3047 
#define IDS_OUTPUT_IA64I		3048
#define IDS_OUTPUT_IA64J		3049
#define IDS_OUTPUT_IA64K        3050 
#define IDS_OUTPUT_IA64L        3051 
#define IDS_OUTPUT_IA64M		3052
#define IDS_OUTPUT_IA64N		3053
#define IDS_OUTPUT_IA64O        3054 
#define IDS_MIRROR_SYNTAX		3055

#define IDS_ERROR_DRIVE			3065
#define IDS_HEADER1				3066
#define IDS_HEADER2				3067

#define IDS_ERROR_DISPLAY		3068
#define IDS_ERROR_READ			3069
#define IDS_ERROR_GPT			3070
#define IDS_ERROR_GPT_HEADER	3071
#define IDS_ERROR_MEM_GPT		3072
#define IDS_ERROR_READ_GPT_ENTRIES 3073
#define IDS_ERROR_DUMP_GPT_ENTRIES 3074	
#define IDS_INFO_DUMP_GPT_ENTRIES  3075
#define IDS_PARTITION1			   3076	
#define IDS_PARTITION2			   3077	

#define IDS_PARTITION3				3078
#define IDS_START_LBA			   3079
#define IDS_PARTITION4				3080
#define IDS_PARTITION5				3081
#define IDS_ERROR_READ_GEOMETRY		3082
#define IDS_HEADER2_DASH			3083
#define IDS_HEADER_DASH1			3084

#define IDS_ERROR_STRING_LENGTH		3090
#define IDS_ERROR_STRING_LENGTH1	3091
#define IDS_ERROR_DEBUG_PORT		3092
#define IDS_ERROR_REDIRECT_PORT		3093
#define IDS_ERROR_FRIENDLY_NAME		3094

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\pch.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		PCH.H
//  
//  Abstract:
//		Include file for standard system include files,
//		or project specific include files that are used frequently, but
//      are changed infrequently.
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include <objbase.h>
#include <initguid.h>
#include <comdef.h>
#include "wbemidl.h"

#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>
#include <chstring.h>
#include <shlwapi.h>
#include <mstask.h>

#include "cmdline.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\resource.h ===
#define IDS_TRIGGERID				1
#define IDS_TRIGGERNAME				2
#define IDS_CREATED					3
#define IDS_CREATE_FAILED			4
#define IDS_DELETED					5
#define IDS_DELETE_FAILED			6
#define IDS_TRIGGER_FAILED			7
#define IDS_TRIGGERED				8
#define IDS_TRIGGER_NOT_FOUND		9
#define IDS_ERROR_CODE				10
#define IDS_REASON					11
#define IDS_ALREADY_TRIGGERED		12
#define IDS_INFO_INVALID_USER 				13
#define IDS_INFO_SERVICE_STOPPED	14
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\eventconsumerprovider.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		EVENTCONSUMERPROVIDER.H
//  
//  Abstract:
//		Contains global variables to be used in other files.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __EVENT_CONSUMER_PROVIDER_H
#define __EVENT_CONSUMER_PROVIDER_H

// 
// constants / defines / enumerations
//
#define LENGTH_UUID				128
#define NULL_CHAR				_T( '\0' )
#define NULL_STRING				_T( "\0" )

// *** no need of localizing the below defined strings ***
#define PROVIDER_CLASSNAME						L"CmdTriggerConsumer"
#define METHOD_RETURNVALUE						_T( "ReturnValue" )
#define TEC_PROPERTY_TRIGGERID					_T( "TriggerID" )
#define TEC_PROPERTY_TRIGGERNAME				_T( "TriggerName" )
#define TEC_PROPERTY_DESCRIPTION				_T( "Description" )
#define TEC_PROPERTY_COMMAND					_T( "Command" )

#define TEC_ADDTRIGGER							L"AddTrigger"
#define TEC_ADDTRIGGER_TRIGGERNAME				_T( "strTriggerName" )
#define TEC_ADDTRIGGER_DESCRIPTION				_T( "strDescription" )
#define TEC_ADDTRIGGER_COMMAND					_T( "strCommand" )
#define TEC_ADDTRIGGER_QUERY					_T( "strQuery" )

//
// extern(ing) variables ... global usage
//
extern DWORD				g_dwLocks;			// holds the active locks count
extern DWORD				g_dwInstances;		// holds the active instances of the component
extern CRITICAL_SECTION		g_critical_sec;		// critical section variable
extern HMODULE					g_hModule;	// holds the current module handle

#endif	// __EVENT_CONSUMER_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\general.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		GENERAL.H
//  
//  Abstract:
//		Contains General functions prototypes.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __GENERAL_H
#define __GENERAL_H

// constants
#define LOG_FILE_PATH				_T( "\\system32\\wbem\\logs\\" )
#define NEW_LINE					_T( "\n" )
#define LOG_FILE					_T( "CmdTriggerConsumer.log" )
#define JOB							_T( ".job" )
#define CHAR_SPACE					_T( ' ' )
#define STRING_SPACE				_T( " " )
#define SINGLE_QUOTE_CHAR			_T( '\"' )
#define	SINGLE_QUOTE_STRING			_T( "\"" )
#define NULL_CHAR					_T( '\0' )
#define DATE_FORMAT					L"ddd',' MMM dd yyyy"
#define TIME_FORMAT					L"hh':'mm':'ss tt"

#define TRIM_SPACES					TEXT(" \0")
#define MAX_RES_STRING1				500

// macros
#define SAFERELEASE( pIObj ) \
	if ( pIObj != NULL ) \
	{ \
		pIObj->Release();	\
		pIObj = NULL;	\
	}

#define FREESTRING( pStr ) \
        if ( pStr ) \
		{ \
           free( pStr ); \
		   pStr = NULL; \
		}

#define ONFAILTHROWERROR(hResult) \
	if (FAILED(hResult)) \
	{	\
		_com_issue_error(hResult); \
	}

#define SAFEBSTRFREE(bstrVal) \
	if (bstrVal != NULL) \
	{	\
		SysFreeString(bstrVal); \
	}

// public function prototypes
LPCTSTR ErrorString( HRESULT hRes );

HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCTSTR szProperty, 
					 DWORD dwType, LPVOID pValue, DWORD dwSize );

HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCTSTR szProperty, LPCTSTR szValue );

HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCTSTR szProperty, DWORD dwValue );

VOID ErrorLog( LPCTSTR lpErrString, LPWSTR lpTrigName, DWORD dwID );

VOID	GetFormattedTime( LPTSTR lpDate );

ITaskScheduler* GetTaskScheduler();

BOOL ProcessFilePath( LPTSTR szInput, LPTSTR szFirstString,
					  LPTSTR szSecondString );

#endif		// __GENERAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\eventconsumerprovider.cpp ===
//***************************************************************************
// Copyright (c) Microsoft Corporation
//
// Module Name:
//		EventConsumerProvider.CPP
//
// Abstract:
//		Contains DLL entry points.  code that controls
//	    when the DLL can be unloaded by tracking the number of
//		objects and locks as well as routines that support
//      self registration.
//
// Author:
//		Vasundhara .G
//
// Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#include "pch.h"
#include "EventConsumerProvider.h"
#include "TriggerFactory.h"

// 
// constants / defines / enumerations
//
#define THREAD_MODEL_BOTH			_T( "Both" )
#define THREAD_MODEL_APARTMENT		_T( "Apartment" )
#define RUNAS_INTERACTIVEUSER		_T( "Interactive User" )
#define FMT_CLS_ID					_T( "CLSID\\%s" )
#define FMT_APP_ID					_T( "APPID\\%s" )
#define PROVIDER_TITLE				_T( "Command line Trigger Consumer" )

#define KEY_INPROCSERVER32			_T( "InprocServer32" )
#define KEY_THREADINGMODEL			_T( "ThreadingModel" )
#define KEY_CLSID					_T( "CLSID" )
#define KEY_APPID					_T( "APPID" )
#define KEY_RUNAS					_T( "RunAs" )
#define KAY_DLLSURROGATE			_T( "DllSurrogate" )


// 
// global variables
//
DWORD				g_dwLocks = 0;				// holds the active locks count
DWORD				g_dwInstances = 0;			// holds the active instances of the component
HMODULE				g_hModule = NULL;			// holds the current module handle
CRITICAL_SECTION    g_critical_sec;				// critical section variable
DWORD				g_criticalsec_count = 0;	// to keep tab on when to release critical section

// {797EF3B3-127B-4283-8096-1E8084BF67A6}
DEFINE_GUID( CLSID_EventTriggersConsumerProvider, 
0x797ef3b3, 0x127b, 0x4283, 0x80, 0x96, 0x1e, 0x80, 0x84, 0xbf, 0x67, 0xa6 );

//
// dll entry point
//

// *************************************************************************
// Routine Description:
//		Entry point for dll.
//                         
// Arguments:
//		hModule [in] : Instance of the caller.
//		ul_reason_for_call  [in] : Reason being called like process attach
//								   or process detach.
//		lpReserved [in] : reserved.
// 
// Return Value:
//		TRUE if loading is successful.
//		FALSE if loading fails.
// *************************************************************************
BOOL WINAPI DllMain( HINSTANCE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved )
{
	// check the reason for this function call
	// if this going to be attached to a process, save the module handle
	if ( ul_reason_for_call == DLL_PROCESS_ATTACH )
	{
		g_hModule = hModule;
		InitializeCriticalSection( &g_critical_sec );
		InterlockedIncrement( ( LPLONG ) &g_criticalsec_count );
	}
	else if ( ul_reason_for_call == DLL_PROCESS_DETACH )
	{
		if ( InterlockedDecrement( ( LPLONG ) &g_criticalsec_count ) == 0 )
		{
			DeleteCriticalSection( &g_critical_sec );
		}
	}
	// dll loaded successfully ... inform the same
	return TRUE;
}

//
// exported functions
//

// *************************************************************************
// Routine Description:
//		Called periodically by OLE in order to determine if the DLL can be freed.
//                         
// Arguments:
//		none.
//
// Return Value:
//		S_OK if there are no objects in use and the class factory  isn't locked.
//		S_FALSE if server locks or components still exsists.
// *************************************************************************
STDAPI DllCanUnloadNow()
{
	// the dll cannot be unloaded if there are any server locks or active instances
	if ( g_dwLocks == 0 && g_dwInstances == 0 )
	{
		return S_OK;
	}
	// dll cannot be unloaded ... server locks (or) components still alive
	return S_FALSE;
}

// *************************************************************************
// Routine Description:
//		Called by OLE when some client wants a class factory.
//		Return one only if it is the sort of class this DLL supports.
//                         
// Arguments:
//		rclsid [in] : CLSID for the class object.
//		riid   [in] : Reference to the identifier of the interface 
//                    that communicates with the class object.
//		ppv [out]   : Address of output variable that receives the 
//                    interface pointer requested in riid.
//
// Return Value:
//		returns status.
// *************************************************************************

STDAPI DllGetClassObject( REFCLSID rclsid, REFIID riid, LPVOID* ppv )
{
	// local variables
    HRESULT hr = NULL;
    CTriggerFactory* pFactory = NULL;

	// check whether this module supports the requested class id
	if ( rclsid != CLSID_EventTriggersConsumerProvider )
	{
		return E_FAIL;			// not supported by this module
	}
	// create the factory
    pFactory = new CTriggerFactory();
    if ( pFactory == NULL )
	{
		return E_OUTOFMEMORY;			// insufficient memory
	}
	// get the requested interface
    hr = pFactory->QueryInterface( riid, ppv );
    if ( FAILED( hr ) )
	{
        delete pFactory;		// error getting interface ... deallocate memory
	}
	// return the result (appropriate result)
    return hr;
}

// *************************************************************************
// Routine Description:
//		Called during setup or by regsvr32.
//                         
// Arguments:
//		none.
//
// Return Value:
//		NOERROR.
// *************************************************************************

STDAPI DllRegisterServer()
{
	// local variables
	HKEY hkMain = NULL;
	HKEY hkDetails = NULL;
    TCHAR szID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szCLSID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szAppID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szModule[ MAX_PATH ] = NULL_STRING;
    TCHAR szTitle[ MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR szThreadingModel[ MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR szRunAs[ MAX_STRING_LENGTH ] = NULL_STRING;
    DWORD dwResult = 0;

	// kick off
    // Note:- 
	//		Normally we want to use "Both" as the threading model since
    //		the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    //		the model is "Aparment"
	lstrcpy( szTitle, PROVIDER_TITLE );					// provider title
	GetModuleFileName( g_hModule, szModule, MAX_PATH );	// get the current module name
	lstrcpy( szThreadingModel,  THREAD_MODEL_BOTH );
	lstrcpy( szRunAs, RUNAS_INTERACTIVEUSER );

	//
    // create the class id path

#ifdef UNICODE

	// get the GUID in the string format
    StringFromGUID2( CLSID_EventTriggersConsumerProvider, szID, LENGTH_UUID );
#else
	
	// StrignFromGUID2 will return the value in UNICODE version
	// but, as the current version is of non UNICODE we need to convert the
	// value into multi-byte character set and then use it
	WCHAR wszID[ LENGTH_UUID ] = L"\0";
	StringFromGUID2( CLSID_EventTriggersConsumerProvider, wszID, LENGTH_UUID );
	wcstombs( szID, wszID, LENGTH_UUID );		// unicode -> mbcs conversion
#endif	// UNICODE

	// finally form the class id path
	wsprintf( szCLSID, FMT_CLS_ID, szID );
	wsprintf( szAppID, FMT_APP_ID, szID );

    // 
	// now, create the entries in registry under CLSID branch

    // create / save / put class id information
	dwResult = RegCreateKey( HKEY_CLASSES_ROOT, szCLSID, &hkMain );
	if( dwResult  != ERROR_SUCCESS )
	{
		return dwResult;			// failed in opening the key.
	}
	dwResult = RegSetValueEx( hkMain, NULL, 0, REG_SZ, 
		( LPBYTE ) szTitle, ( lstrlen( szTitle ) + 1 ) * sizeof( TCHAR ) );
   	if( dwResult  != ERROR_SUCCESS )
	{
		RegCloseKey( hkMain );
		return dwResult;			// failed to set key value.
	}

	// now create the server information
	dwResult = RegCreateKey( hkMain, KEY_INPROCSERVER32, &hkDetails );
	if( dwResult  != ERROR_SUCCESS )
	{	RegCloseKey( hkMain );
		return dwResult;			// failed in opening the key.
	}

    dwResult = RegSetValueEx( hkDetails, NULL, 0, REG_SZ, 
		( LPBYTE ) szModule, ( lstrlen( szModule ) + 1 ) * sizeof( TCHAR ) );
   	if( dwResult  != ERROR_SUCCESS )
	{	RegCloseKey( hkMain );
		RegCloseKey( hkDetails );
		return dwResult;			// failed to set key value.
	}

	// set the threading model we support
	dwResult = RegSetValueEx( hkDetails, KEY_THREADINGMODEL, 0, REG_SZ, 
		( LPBYTE ) szThreadingModel, ( lstrlen( szThreadingModel ) + 1 ) * sizeof( TCHAR ) );
   	if( dwResult  != ERROR_SUCCESS )
	{	RegCloseKey( hkMain );
		RegCloseKey( hkDetails );
		return dwResult;			// failed to set key value.
	}

	// close the open register keys
	RegCloseKey( hkMain );
    RegCloseKey( hkDetails );

    // 
	// now, create the entries in registry under AppID branch
    // create / save / put class id information
	dwResult = RegCreateKey( HKEY_CLASSES_ROOT, szAppID, &hkMain );
	if(dwResult != ERROR_SUCCESS )
	{
		return dwResult;
	}
	dwResult = RegSetValueEx( hkMain, NULL, 0, REG_SZ, 
		( LPBYTE ) szTitle, ( lstrlen( szTitle ) + 1 ) * sizeof( TCHAR ) );
	if( dwResult != ERROR_SUCCESS )
	{
		RegCloseKey( hkMain );
		return dwResult;
	}

	// now set run as information
	dwResult = RegSetValueEx( hkMain, KEY_RUNAS, 0, REG_SZ, 
		( LPBYTE ) szRunAs, ( lstrlen( szRunAs ) + 1 ) * sizeof( TCHAR ) );
	if( dwResult != ERROR_SUCCESS )
	{
		RegCloseKey( hkMain );
		return dwResult;
	}
	// close the open register keys
	RegCloseKey( hkMain );

	// registration is successfull ... inform the same
    return NOERROR;
}

// *************************************************************************
// Routine Description:
//		Called when it is time to remove the registry entries.
//                         
// Arguments:
//		none.
//
// Return Value:
//		NOERROR if unregistration successful.
//		Otherwise error.
// *************************************************************************

STDAPI DllUnregisterServer()
{
	// local variables
    HKEY hKey;
    DWORD dwResult = 0;
	TCHAR szID[ LENGTH_UUID ];
    TCHAR szCLSID[ LENGTH_UUID ];
    TCHAR szAppID[ LENGTH_UUID ] = NULL_STRING;

	//
    // create the class id path

#ifdef UNICODE

    StringFromGUID2( CLSID_EventTriggersConsumerProvider, szID, LENGTH_UUID );
#else
	
	// StrignFromGUID2 will return the value in UNICODE version
	// but, as the current version is of non UNICODE we need to convert the
	// value into multi-byte character set and then use it
	WCHAR wszID[ LENGTH_UUID ] = L"\0";
	StringFromGUID2( CLSID_EventTriggersConsumerProvider, wszID, LENGTH_UUID );
	wcstombs( szID, wszID, LENGTH_UUID );		// unicode -> mbcs conversion
#endif	// UNICODE

	// finally form the class id path
	wsprintf( szCLSID, FMT_CLS_ID, szID );
	wsprintf( szAppID, FMT_APP_ID, szID );

	// open the clsid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, szCLSID, &hKey );
	if ( dwResult != NO_ERROR )
	{
		return dwResult;			// failed in opening the key ... inform the same
	}
	// clsid opened ... first delete the InProcServer32
    RegDeleteKey( hKey, KEY_INPROCSERVER32 );

    // now delete the clsid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, KEY_CLSID, &hKey );
	if ( dwResult != NO_ERROR )
	{
		return dwResult;			// failed in opening the key ... inform the same
	}

	// delete the clsid also from the registry
	RegDeleteKey( hKey, szID );

    // now delete the appid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, KEY_APPID, &hKey );
	if ( dwResult != NO_ERROR )
	{
		return dwResult;			// failed in opening the key ... inform the same
	}

	// delete the cls id also from the registry
	RegDeleteKey( hKey, szID );

	// unregistration is successfull ... inform the same
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerconsumer.cpp ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERCONSUMER.CPP
//  
//  Abstract:
//		Contains CEventConsumer implementation.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#include "pch.h"
#include "EventConsumerProvider.h"
#include "General.h"
#include "TriggerConsumer.h"
#include "resource.h"

extern HMODULE g_hModule;

#define PROPERTY_COMMAND		_T( "Action" )
#define PROPERTY_TRIGID			_T( "TriggerID" )
#define PROPERTY_NAME			_T( "TriggerName" )
#define PROPERTY_SHEDULE		_T( "ScheduledTaskName" )
#define SPACE					_T( " " )
#define SLASH					_T( "\\" )
#define NEWLINE					_T( "\0" )


//***************************************************************************
// Routine Description:
//		Constructor for CTriggerConsumer class for initialization.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerConsumer::CTriggerConsumer()
{
	// initialize the reference count variable
    m_dwCount = 0;
}

//***************************************************************************
// Routine Description:
//		Desstructor for CTriggerConsumer class.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerConsumer::~CTriggerConsumer()
{
	// there is nothing much to do at this place ...
}

//***************************************************************************
// Routine Description:
//		Returns a pointer to a specified interface on an object
//		to which a client currently holds an interface pointer. 
//                         
// Arguments:
//		riid [in] : Identifier of the interface being requested. 
//		ppv  [out] :Address of pointer variable that receives the
//			  interface pointer requested in riid. Upon successful
//			  return, *ppvObject contains the requested interface
//			  pointer to the object.
//
// Return Value:
//		NOERROR if the interface is supported.
//		E_NOINTERFACE if not.
//***************************************************************************
STDMETHODIMP CTriggerConsumer::QueryInterface( REFIID riid, LPVOID* ppv )
{
	// initialy set to NULL 
    *ppv = NULL;

	// check whether interface requested is one we have
	if ( riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink )
	{
		//
		// yes ... requested interface exists
        *ppv = this;		// set the out parameter for the returning the requested interface
        this->AddRef();		// update the reference count
        return NOERROR;		// inform success
	}

	// interface is not available
    return E_NOINTERFACE;
}

//***************************************************************************
// Routine Description:
//		The AddRef method increments the reference count for
//		an interface on an object. It should be called for every
//		new copy of a pointer to an interface on a given object. 
//                         
// Arguments:
//		none.
//
// Return Value:
//		Returns the value of the new reference count.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerConsumer::AddRef( void )
{
	// increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

//***************************************************************************
// Routine Description:
//		The Release method decreases the reference count of the object by 1.
//                         
// Arguments:
//		none.
//
// Return Value:
//		Returns the new reference count.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerConsumer::Release( void )
{
	// decrement the reference count ( thread safe ) and check whether
	// there are some more references or not ... based on the result value
	DWORD dwCount = 0;
	dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
	if ( dwCount == 0 )
	{
		// free the current factory instance
		delete this;
	}
    
	// return the no. of instances references left
    return dwCount;
}

//***************************************************************************
// Routine Description:
//		IndicateToConsumer method is called by Windows Management
//		to actually deliver events to a consumer.
//                         
// Arguments:
//		pLogicalCosumer [in] :Pointer to the logical consumer object
//							  for which this set of objects is delivered. 
//		lNumObjects [in]     :Number of objects delivered in the array that follows. 
//		ppObjects [in]       : Pointer to an array of IWbemClassObject
//							   instances which represent the events  delivered. 
//
// Return Value:
//		Returns WBEM_S_NO_ERROR if successful.
//		Otherwise error.
//***************************************************************************
STDMETHODIMP CTriggerConsumer::IndicateToConsumer( IWbemClassObject* pLogicalConsumer,
												   LONG lNumObjects, 
												   IWbemClassObject **ppObjects )
{
	STARTUPINFO				info;
	PROCESS_INFORMATION		procinfo;
	TCHAR					szCommand[ MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR					szName[ MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR					szTask[ MAX_STRING_LENGTH ] = NULL_STRING;
	TCHAR				    szPath[ MAX_STRING_LENGTH ] = NULL_STRING;
	DWORD					dwID = 0;

	PTCHAR					szParams = NULL;
	PTCHAR					szExe = NULL;
	HRESULT					hRes = 0;
	BOOL					bResult = FALSE;

	VARIANT					varValue;
	VARIANT					varScheduler;

	memset( szCommand, 0, sizeof( szCommand ) );
	memset( szName, 0, sizeof( szName ) );
	memset( szPath, 0, sizeof( szPath ) );
	memset( szTask, 0, sizeof( szTask ) );


	// get the 'Item' property values out of the embedded object.
	hRes = PropertyGet( pLogicalConsumer, PROPERTY_COMMAND, 0, szCommand, MAX_STRING_LENGTH );
	if ( FAILED( hRes ) )
	{
		return hRes;
	}
	// get the trigger name.
	hRes = PropertyGet( pLogicalConsumer, PROPERTY_NAME, 0, szName, MAX_STRING_LENGTH );
	if( FAILED( hRes ) )
		return hRes;

	VariantInit( &varScheduler );
	hRes = pLogicalConsumer->Get( PROPERTY_SHEDULE, 0, &varScheduler, NULL, NULL );
	if( FAILED( hRes ) )
		return hRes;

	try
	{
		lstrcpyW( szTask, ( LPCWSTR ) _bstr_t( varScheduler ) );
	}
	catch( ... )
	{
		// memory exhausted -- return
		return E_OUTOFMEMORY;
	}

	VariantInit( &varValue );
	hRes = pLogicalConsumer->Get( PROPERTY_TRIGID, 0, &varValue, NULL, NULL );
	if( FAILED( hRes ) )
		return hRes;

	if( varValue.vt == VT_NULL || varValue.vt == VT_EMPTY )
		return WBEM_E_INVALID_PARAMETER;

	dwID = varValue.lVal;
	VariantClear( &varValue );

	if( lstrlen( szTask ) > 0 )
	{
		try
		{
			ITaskScheduler *pITaskScheduler = NULL;
			IEnumWorkItems *pIEnum = NULL;
			IPersistFile *pIPF = NULL;
			ITask *pITask = NULL;

			LPWSTR *lpwszNames = NULL;
			DWORD dwFetchedTasks = 0;
			TCHAR szActualTask[MAX_STRING_LENGTH] = NULL_STRING;

			pITaskScheduler = GetTaskScheduler();
			if ( pITaskScheduler == NULL )
			{	
				hRes = E_FAIL;
				ONFAILTHROWERROR( hRes );
			}

			hRes = pITaskScheduler->Enum( &pIEnum );
			ONFAILTHROWERROR( hRes );
			while ( SUCCEEDED( pIEnum->Next( 1,
										   &lpwszNames,
										   &dwFetchedTasks ) )
							  && (dwFetchedTasks != 0))
			{
				while (dwFetchedTasks)
				{
					
					// Check whether the TaskName is present, if present 
					// then return arrJobs.

					// Convert the Wide Charater to Multi Byte value.
					GetCompatibleStringFromUnicode( lpwszNames[ --dwFetchedTasks ], szActualTask, SIZE_OF_ARRAY( szActualTask ) );

					// Parse the TaskName to remove the .job extension.
					szActualTask[lstrlen(szActualTask ) - lstrlen(JOB) ] = NULL_CHAR;

					StrTrim( szActualTask, TRIM_SPACES );
					CHString strTemp;
					strTemp = varScheduler.bstrVal;
					if( lstrcmpi( szActualTask, strTemp )  == 0 )
					{
						hRes = pITaskScheduler->Activate( szActualTask, IID_ITask, (IUnknown**) &pITask );
						ONFAILTHROWERROR( hRes );
						hRes = pITask->Run();	
						ONFAILTHROWERROR( hRes );
						bResult = TRUE;
					}
				    CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
			
				}//end while
			    CoTaskMemFree( lpwszNames );
			}
			
			pIEnum->Release();
  
			if( bResult == TRUE )
			{
				HRESULT phrStatus;
				Sleep( 10000 );
				hRes = pITask->GetStatus( &phrStatus );
				ONFAILTHROWERROR( hRes );
				switch(phrStatus)
				{
				  case SCHED_S_TASK_READY:
			  			LoadStringW( g_hModule, IDS_TRIGGERED, szTask, MAX_STRING_LENGTH );
						break;
				  case SCHED_S_TASK_RUNNING:
			  			LoadStringW( g_hModule, IDS_TRIGGERED, szTask, MAX_STRING_LENGTH );
					   break;
				  case SCHED_S_TASK_NOT_SCHEDULED:
			  			LoadStringW( g_hModule, IDS_TRIGGER_FAILED, szTask, MAX_STRING_LENGTH );
					   break;
				  default:
			  			LoadStringW( g_hModule, IDS_TRIGGER_NOT_FOUND, szTask, MAX_STRING_LENGTH );
				}
				ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
			}
			else
			{
			  	LoadStringW( g_hModule, IDS_TRIGGER_NOT_FOUND, szTask, MAX_STRING_LENGTH );
				ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
			}
		} //try
		catch(_com_error& e)
		{
			IWbemStatusCodeText *pIStatus	= NULL;
			BSTR				bstrErr		= NULL;
			LPTSTR lpResStr = NULL; 
		
			lpResStr = ( LPTSTR ) __calloc( MAX_RES_STRING + 1, sizeof( TCHAR ) );

			if ( lpResStr != NULL )
			{
				if (SUCCEEDED(CoCreateInstance(CLSID_WbemStatusCodeText, 0, 
											CLSCTX_INPROC_SERVER,
											IID_IWbemStatusCodeText,
											(LPVOID*) &pIStatus)))
				{
					if (SUCCEEDED(pIStatus->GetErrorCodeText(e.Error(), 0, 0, &bstrErr)))
					{
						GetCompatibleStringFromUnicode(bstrErr,lpResStr,wcslen(bstrErr));
					}
					SAFEBSTRFREE(bstrErr);
			  		LoadStringW( g_hModule, IDS_TRIGGER_FAILED, szTask, MAX_STRING_LENGTH );
		  			LoadStringW( g_hModule, IDS_ERROR_CODE, szCommand, MAX_STRING_LENGTH );
					wsprintf( szPath, szCommand, e.Error() );
					lstrcat( szTask, szPath );
					LoadStringW( g_hModule, IDS_REASON, szCommand, MAX_STRING_LENGTH );
					wsprintf( szPath, szCommand, lpResStr );
					lstrcat( szTask, szPath );
					ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
				}
				SAFERELEASE(pIStatus);
				free( lpResStr );
				return( hRes );
			}
		}//catch
		catch( CHeap_Exception  )
		{
			return E_OUTOFMEMORY;
		}

	} //if
	else
	{
		TCHAR szApplName[ MAX_STRING_LENGTH ] = NULL_STRING;
		TCHAR szParams[ MAX_STRING_LENGTH ] = NULL_STRING;

		//
		// prepare the process start up info
		info.cb = sizeof( info );
		info.cbReserved2 = 0;
		info.dwFillAttribute = 0;
		info.dwX = 0;
		info.dwXCountChars = 0;
		info.dwXSize = 0;
		info.dwY = 0;
		info.dwYCountChars = 0;
		info.dwYSize = 0;
		info.hStdError = NULL;
		info.hStdInput = NULL;
		info.hStdOutput = NULL;
		info.lpDesktop = NULL;//( "winsta0\\default" );
		info.lpReserved = NULL;
		info.lpReserved2 = NULL;
		info.lpTitle = NULL;
		

		// init process info structure with 0's
		ZeroMemory( &procinfo, sizeof( PROCESS_INFORMATION ) );
		
		bResult = ProcessFilePath( szCommand, szApplName, szParams );
		
		if( bResult == TRUE )
		{
				if( lstrlen( szParams ) == 0 )
				{
					bResult = CreateProcess( NULL, szApplName, NULL, NULL,
								FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &info,
								&procinfo );
				}
				else
				{
					bResult = CreateProcess( szApplName, szParams, NULL, NULL,
								FALSE, CREATE_NEW_CONSOLE, NULL, NULL, &info,
								&procinfo );
				}
		}
		else
		{
			SetLastError( E_OUTOFMEMORY );
		}

	   	if(bResult == 0)
		{
			LPVOID lpMsgBuf = NULL;		// pointer to handle error message

			// load the system error message from the windows itself
			FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
				FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf, 0, NULL );

			LoadStringW( g_hModule, IDS_TRIGGER_FAILED, szTask, MAX_STRING_LENGTH );
  			LoadStringW( g_hModule, IDS_ERROR_CODE, szCommand, MAX_STRING_LENGTH );
			wsprintf( szPath, szCommand, GetLastError() );
			lstrcat( szTask, szPath );
			LoadStringW( g_hModule, IDS_REASON, szCommand, MAX_STRING_LENGTH );
			wsprintf( szPath, szCommand, lpMsgBuf );
			lstrcat( szTask, szPath );
			ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
			if ( lpMsgBuf != NULL )
			{
				LocalFree( lpMsgBuf );
			}
			return GetLastError();
		}
		else
		{
			LoadStringW( g_hModule, IDS_TRIGGERED, szTask, MAX_STRING_LENGTH );
			ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
			return WBEM_S_NO_ERROR;
		}
	}
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
// Routine Description:
//		This routine gets task scheduler interface.
//
// Arguments:
//		none.
//
// Return Value:
//		Returns ITaskScheduler interface.
//***************************************************************************
ITaskScheduler* CTriggerConsumer::GetTaskScheduler()
{
	HRESULT hRes = S_OK;
	ITaskScheduler *pITaskScheduler = NULL;

    hRes = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL, 
						   IID_ITaskScheduler,(LPVOID*) &pITaskScheduler );
	if( FAILED(hRes))
	{
		return NULL;
	}
	hRes = pITaskScheduler->SetTargetComputer( NULL );
	return pITaskScheduler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\general.cpp ===
//***************************************************************************
// Copyright (c) Microsoft Corporation
//
// Module Name:
//		GENERAL.CPP
//
// Abstract:
//		Source file that that contains general functions implementation.
//
// Author:
//		Vasundhara .G
//
// Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#include "pch.h"
#include "EventConsumerProvider.h"
#include "General.h"
#include "resource.h"
extern HMODULE g_hModule;

//
// internal functions ... private
//

//***************************************************************************
// Routine Description:
//		Returns the variant string for a variable of type LPCTSTR .
//                         
// Arguments:
//		pszValue [in] - A LPCTSTR value to convert into varaint type.
//		pVariant [in/out] - A VARAINT type variable which hold the variant
//		type for the given LPCTSTR string.
//
// Return Value:
//		A Variant type string.
//***************************************************************************
inline VARIANT* AsVariant( LPCTSTR pszValue, VARIANT* pVariant )
{
	// local variables
	WCHAR wszValue[ MAX_STRING_LENGTH + 1 ] = L"\0";

	// set the variant structure
	VariantInit( pVariant );
	pVariant->vt = VT_BSTR;
	pVariant->bstrVal = GetAsUnicodeString( pszValue, wszValue, MAX_STRING_LENGTH );

	// return the out parameter itself as the return value
	return pVariant;
}

//***************************************************************************
// Routine Description:
//		Returns the variant value for a variable of type DWORD .
//                         
// Arguments:
//		dwValue [in] - A DWORD value to convert into varaint type.
//		pVariant [in/out] - A VARAINT type variable which hold the variant
//		type for the given DWORD.
//
// Return Value:
//		A Variant type string.
//***************************************************************************
inline VARIANT* AsVariant( DWORD dwValue, VARIANT* pVariant )
{
	// set the variant structure
	VariantInit( pVariant );
	pVariant->vt = VT_UI1;
	pVariant->ulVal = dwValue;

	// return the out parameter itself as the return value
	return pVariant;
}

//***************************************************************************
// Routine Description:
//		Get the value of a property for the given instance .
//                         
// Arguments:
//		pWmiObject[in] - A pointer to wmi class.
//		szProperty [in] - property name whose value to be returned.
//		dwType [in] - Data Type of the property.
//		pValue [in/out] - Variable to hold the data.
//		dwSize [in] - size of the variable.
//
// Return Value:
//		HRESULT value.
//***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCTSTR szProperty, 
					 DWORD dwType, LPVOID pValue, DWORD dwSize )
{
	// local variables
	HRESULT hr = S_OK;
	VARIANT varValue;
	LPWSTR pwszValue = NULL;
	WCHAR wszProperty[ MAX_STRING_LENGTH ] = L"\0";

	// value should not be NULL
	if ( pValue == NULL )
	{
		return S_FALSE;
	}
	// initialize the values with zeros ... to be on safe side
	memset( pValue, 0, dwSize );
	memset( wszProperty, 0, MAX_STRING_LENGTH );

	// get the property name in UNICODE version
	GetAsUnicodeString( szProperty, wszProperty, MAX_STRING_LENGTH );

	// initialize the variant and then get the value of the specified property
	VariantInit( &varValue );
	hr = pWmiObject->Get( wszProperty, 0, &varValue, NULL, NULL );
	if ( FAILED( hr ) )
	{
		// clear the variant variable
		VariantClear( &varValue );

		// failed to get the value for the property
		return hr;
	}

	// get and put the value 
	switch( varValue.vt )
	{
	case VT_EMPTY:
	case VT_NULL:
		break;
	
	case VT_I2:
		*( ( short* ) pValue ) = V_I2( &varValue );
		break;
	
	case VT_I4:
		*( ( long* ) pValue ) = V_I4( &varValue );
		break;
	
	case VT_R4:
		*( ( float* ) pValue ) = V_R4( &varValue );
		break;

	case VT_R8:
		*( ( double* ) pValue ) = V_R8( &varValue );
		break;


	case VT_UI1:
		*( ( UINT* ) pValue ) = V_UI1( &varValue );
		break;

	case VT_BSTR:
		{
			// get the unicode value
			pwszValue = V_BSTR( &varValue );

			// get the comptable string
			GetCompatibleStringFromUnicode( pwszValue, ( LPTSTR ) pValue, dwSize );

			break;
		}
	}

	// clear the variant variable
	VariantClear( &varValue );

	// inform success
	return S_OK;
}

//***************************************************************************
// Routine Description:
//		putt the value of a property for the given instance .
//                         
// Arguments:
//		pWmiObject[in] - A pointer to wmi class.
//		szProperty [in] - property name whose value to be set.
//		SZValue [in/out] - Variable that hold the data.
//
// Return Value:
//		HRESULT value.
//***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCTSTR szProperty, LPCTSTR szValue )
{
	// local variables
	HRESULT hr;
	VARIANT var;
	WCHAR wszProperty[ MAX_STRING_LENGTH + 1 ] = L"\0";

	// put the value
	hr = pWmiObject->Put( GetAsUnicodeString( szProperty, wszProperty, MAX_STRING_LENGTH ), 
		0, AsVariant( szValue, &var ), VT_BSTR );
	
	// clear the variant
	VariantClear( &var );

	// now check the result of 'put' operation
	if ( FAILED( hr ) )
	{
		return hr;			// put has failed
	}
	// put is success ... inform the same
	return S_OK;
}

//***************************************************************************
// Routine Description:
//		put the value of a property for the given instance .
//                         
// Arguments:
//		pWmiObject[in] - A pointer to wmi class.
//		szProperty [in] - property name whose value to be set.
//		dwValue [in] - Variable that hold the data.
//
// Return Value:
//		HRESULT value.
//***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCTSTR szProperty, DWORD dwValue )
{
	// local variables
	HRESULT hr = S_OK;
	VARIANT var;
	WCHAR wszProperty[ MAX_STRING_LENGTH + 1 ] = L"\0";

	// put the value
	hr = pWmiObject->Put( GetAsUnicodeString( szProperty, wszProperty, MAX_STRING_LENGTH ), 
		0, AsVariant( dwValue, &var ), VT_UI1 );
	
	// clear the variant
	VariantClear( &var );

	// now check the result of 'put' operation
	if ( FAILED( hr ) )
	{
		return hr;			// put has failed
	}

	// put is success ... inform the same
	return S_OK;
}

//***************************************************************************
// Routine Description:
//		To write the log into log file.
//                         
// Arguments:
//		lpErrString [in] - text that hold the status of creating a trigger.
//		lpTrigName  [in] - trigger name.
//
// Return Value:
//		none.
//***************************************************************************
VOID ErrorLog( LPCTSTR lpErrString, LPWSTR lpTrigName, DWORD dwID )
{
	LPTSTR         lpTemp = NULL;
	LPSTR		   lpFilePath = NULL;
	FILE		   *fLogFile = NULL;
	DWORD		   dwResult = 0;
	LPTSTR		   lpResStr = NULL; 


	if( ( lpErrString == NULL ) || ( lpTrigName == NULL ) )
		return;

	lpResStr = ( LPTSTR ) __calloc( MAX_RES_STRING1 + 1, sizeof( TCHAR ) );
	lpTemp =  ( LPTSTR )calloc( MAX_RES_STRING1, sizeof( TCHAR ) );
	if( ( lpTemp == NULL ) || ( lpResStr == NULL ) )
	{
		FREESTRING( lpTemp );
		FREESTRING( lpResStr );
		return;
	}

    dwResult =  GetWindowsDirectory( lpTemp, MAX_RES_STRING1 );
	if( dwResult == 0 )
	{
		FREESTRING( lpTemp );
		FREESTRING( lpResStr );
		return;
	}

	lstrcat( lpTemp, LOG_FILE_PATH );
	CreateDirectory( lpTemp, NULL );
	lstrcat( lpTemp, LOG_FILE );

	lpFilePath =  ( LPSTR )calloc( MAX_RES_STRING1, sizeof( TCHAR ) );
	if( lpFilePath == NULL )
	{
		FREESTRING( lpTemp );
		FREESTRING( lpResStr );
		return;
	}
	GetAsMultiByteString( lpTemp, lpFilePath, MAX_RES_STRING1 );
	
	memset( lpTemp, 0, MAX_RES_STRING * sizeof( TCHAR ) );

	if ( (fLogFile  = fopen( lpFilePath, "a" )) != NULL )
	{
		LPSTR  lpReason =  NULL;
		lpReason =  ( LPSTR )calloc( MAX_RES_STRING1, sizeof( TCHAR ) );
		if( lpReason == NULL )
		{
			FREESTRING( lpTemp );
			FREESTRING( lpResStr );
			FREESTRING( lpFilePath );
			fclose( fLogFile );
			return;
		}

		GetFormattedTime( lpTemp );	
		if( lpTemp == NULL )
		{
			FREESTRING( lpResStr );
			FREESTRING( lpFilePath );
			return;
		}
		GetAsMultiByteString( NEW_LINE, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		GetAsMultiByteString( lpTemp, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );

		memset( lpTemp, 0, MAX_RES_STRING1 * sizeof( TCHAR ) );

		LoadStringW( g_hModule, IDS_TRIGGERNAME, lpResStr, MAX_RES_STRING1 );
		lstrcpy( lpTemp, lpResStr );
		lstrcat( lpTemp, lpTrigName );
		GetAsMultiByteString( NEW_LINE, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		GetAsMultiByteString( lpTemp, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );

		memset( lpTemp, 0, MAX_RES_STRING1 * sizeof( TCHAR ) );
		LoadStringW( g_hModule, IDS_TRIGGERID, lpResStr, MAX_RES_STRING1 );
		wsprintf( lpTemp, lpResStr, dwID );
		GetAsMultiByteString( NEW_LINE, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		GetAsMultiByteString( lpTemp, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );

		memset( lpTemp, 0, MAX_RES_STRING1 * sizeof( TCHAR ) );
		lstrcat( lpTemp, lpErrString );
		GetAsMultiByteString( NEW_LINE, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		GetAsMultiByteString( lpTemp, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		GetAsMultiByteString( NEW_LINE, lpReason, MAX_RES_STRING1 );
		fprintf( fLogFile, lpReason );
		free( lpReason );
		fclose( fLogFile );
	}

	FREESTRING( lpTemp );
	FREESTRING( lpResStr );
	FREESTRING( lpFilePath );
}

//***************************************************************************
// Routine Description:
//		Get the system date and time in specified format .
//                         
// Arguments:
//		lpDate [in/out] - string that holds the current date.
//
// Return Value:
//		None.
//***************************************************************************
VOID GetFormattedTime( LPTSTR lpDate )
{
    TCHAR szTime[MAX_STRING_LENGTH];
    INT   cch = 0;

	if( lpDate == NULL )
		return;
	cch =  GetDateFormat( LOCALE_USER_DEFAULT, 0, NULL, DATE_FORMAT, szTime, SIZE_OF_ARRAY( szTime ) );
     // cch includes null terminator, change it to a space to separate from time.
    szTime[ cch - 1 ] = ' ';

    // Get time and format to characters

    GetTimeFormat( LOCALE_USER_DEFAULT, NULL, NULL, TIME_FORMAT, szTime + cch, SIZE_OF_ARRAY( szTime ) - cch );

    lstrcpy( lpDate, ( LPTSTR )szTime );
	return;
}

/******************************************************************************
//	Routine Description:
//		This routine splits the input parameters into 2 substrings and returns it. 
//
//	Arguments:	
//		szInput [in]           : Input string.
//		szFirstString [in/out] : First Output string containing the path of the 
//						      	 file.	
//		szSecondString [in/out]: The second  output containing the paramters.
//	
//	Return Value :
//		A BOOL value indicating TRUE on success else FALSE
//		on failure
******************************************************************************/ 
BOOL ProcessFilePath( LPTSTR szInput, LPTSTR szFirstString, LPTSTR szSecondString )
{
	
	_TCHAR *pszTok = NULL ;
	_TCHAR *pszSep = NULL ;

	_TCHAR szTmpString[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpInStr[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpOutStr[MAX_RES_STRING] = NULL_STRING; 
	_TCHAR szTmpString1[MAX_RES_STRING] = NULL_STRING; 
	DWORD dwCnt = 0 ;
	DWORD dwLen = 0 ;

#ifdef _WIN64
	INT64 dwPos ;
#else
	DWORD dwPos ;
#endif

	//checking if the input parameters are NULL and if so 
	// return FAILURE. This condition will not come
	// but checking for safety sake.

	if( ( szInput == NULL ) || ( _tcslen( szInput ) == 0 ) )
	{
		return FALSE;
	}

	_tcscpy( szTmpString, szInput );
	_tcscpy( szTmpString1, szInput );
	_tcscpy( szTmpInStr, szInput );

	// check for first double quote (")
	if ( szTmpInStr[0] == SINGLE_QUOTE_CHAR )
	{
		// trim the first double quote
		StrTrim( szTmpInStr, SINGLE_QUOTE_STRING );
		
		// check for end double quote
		pszSep  = _tcschr( szTmpInStr, SINGLE_QUOTE_CHAR ) ;
		
		// get the position
		dwPos = pszSep - szTmpInStr + 1;
	}
	else
	{
		// check for the space 
		pszSep  = _tcschr( szTmpInStr, CHAR_SPACE ) ;
		
		// get the position
		dwPos = pszSep - szTmpInStr;

	}

	if ( pszSep != NULL )
	{
		szTmpInStr[dwPos] =  NULL_CHAR; 
	}
	else
	{
		_tcscpy( szFirstString, szTmpString );
		_tcscpy( szSecondString, NULL_STRING );
		return TRUE;
	}

	// intialize the variable
	dwCnt = 0 ;
	
	// get the length of the string
	dwLen = _tcslen ( szTmpString );

	// check for end of string
	while ( ( dwPos <= dwLen )  && szTmpString[dwPos++] != NULL_CHAR )
	{
		szTmpOutStr[dwCnt++] = szTmpString[dwPos];
	}

	// trim the executable and arguments
	StrTrim( szTmpInStr, SINGLE_QUOTE_STRING );
	StrTrim( szTmpInStr, STRING_SPACE );

	_tcscpy( szFirstString, szTmpInStr );
	_tcscpy( szSecondString, szTmpOutStr );
	
	// return success
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerfactory.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERFACTORY.H
//  
//  Abstract:
//		Contains CTriggerFactory definition.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __TRIGGER_FACTORY
#define __TRIGGER_FACTORY

// class factory for the provider
class CTriggerFactory : public IClassFactory   
{
public:
    CTriggerFactory();
    ~CTriggerFactory();

    // IUnknown interface members
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );
    STDMETHODIMP         QueryInterface( REFIID riid, LPVOID* ppv );

    // IClassFactory interface members
    STDMETHODIMP CreateInstance( LPUNKNOWN pUnknownOutter, REFIID riid, LPVOID* ppvObject );
    STDMETHODIMP LockServer( BOOL bLock );

protected:
    DWORD m_dwCount;			// holds the object reference count
};

#endif		// __TRIGGER_FACTORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerfactory.cpp ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERFACTORY.CPP
//  
//  Abstract:
//		Contains the class factory. This creates objects when connections are requested.
//
//  Author:
//		Vasundhara .G
//
//	Revision History :
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************
#include "pch.h"
#include "EventConsumerProvider.h"
#include "TriggerFactory.h"
#include "TriggerProvider.h"

//***************************************************************************
// Routine Description:
//		Constructor for CTriggerFactory class   for initialization.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerFactory::CTriggerFactory()
{
	// initialize the reference count variable
    m_dwCount = 0;
}

//***************************************************************************
// Routine Description:
//		Destructor for CTriggerFactory class for releasing resources.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerFactory::~CTriggerFactory()
{
	// there is nothing much to do at this place ... can be inlined, but
}

//***************************************************************************
// Routine Description:
//		QueryInterface required to be overridden for a class derived from IUnknown
//		interface.
//                         
// Arguments:
//		riid [in] : which has the ID value of the interface being called.
//      ppv [out] : pointer to the interface requested.
//
// Return Value:
//		NOERROR if successful.
//		E_NOINTERFACE if unsuccessful
//***************************************************************************
STDMETHODIMP CTriggerFactory::QueryInterface( REFIID riid, LPVOID* ppv )
{
	// initialy set to NULL 
    *ppv = NULL;

	// check whether interface requested is one we have
	if ( riid == IID_IUnknown || riid == IID_IClassFactory )
	{
		//
		// yes ... we have the requested interface 
        *ppv=this;			// set the out parameter for the returning the requested interface
        this->AddRef();		// update the reference count
        return NOERROR;		// inform success
	}

	// interface is not available
    return E_NOINTERFACE;
}

//***************************************************************************
// Routine Description:
//		Addref required to be overridden for a class derived from IUnknown interface.
//                         
// Arguments:
//		none.
//
// Return Value:
//		returns value of reference member.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerFactory::AddRef( void )
{
	// increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

//***************************************************************************
// Routine Description:
//		Release required to be overridden for a class derived from IUnknown interface.
//                         
// Arguments:
//		none.
//
// Return Value:
//		returns value of reference member, g_lCObj.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerFactory::Release( void )
{
	DWORD dwCount;
	
	// decrement the reference count ( thread safe ) and check whether
	// there are some more references or not ... based on the result value
	dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
	if ( 0 == dwCount )
	{
		// free the current factory instance
		delete this;
	}
	
	// return the no. of instances references left
	return dwCount;
}

//***************************************************************************
// Routine Description:
//		Creates an object of the specified CLSID and retrieves
//		an interface pointer to this object.
//                         
// Arguments:
//		pUnknownOutter [in] :If the object is being created as part of an
//		 					 aggregate, then pIUnkOuter must be the outer
//							 unknown. Otherwise, pIUnkOuter must be NULL.
//		riid  [in] : The IID of the requested interface.
//		ppvObject [out]  : A pointer to the interface pointer identified by riid.
//
// Return Value:
//		NOERROR if successful.
//		Otherwise  error value.
//***************************************************************************
STDMETHODIMP CTriggerFactory::CreateInstance( LPUNKNOWN pUnknownOutter, 
											  REFIID riid, LPVOID* ppvObject )
{
	// local variables
    HRESULT hr;
    CTriggerProvider* pProvider = NULL;

	// kick off
    *ppvObject = NULL;
    hr = E_OUTOFMEMORY;
    if ( pUnknownOutter != NULL )
	{
        return CLASS_E_NOAGGREGATION;		// object doesn't support aggregation.
	}
    // create the Initialize object.
    pProvider = new CTriggerProvider();
    if ( pProvider == NULL )
	{
        return E_OUTOFMEMORY;		// ran out of memory
	}
	// get the pointer to the requested interface
    hr = pProvider->QueryInterface( riid, ppvObject );
    if ( FAILED( hr ) )
	{
        delete pProvider;			// interface not available ... de-allocate memory
	}
	// return the appropriate result
    return hr;
}

//***************************************************************************
//
// Routine Description:
//		Increments or decrements the lock count of the DLL.
//		If the lock count goes to zero and there are no objects,
//		the DLL  is allowed to unload.
//
// arguments:
//		bLock [in] : specifying whether to increment or decrement the lock count.
//
// Returns Value:
//		NOERROR always.
//
//***************************************************************************
STDMETHODIMP CTriggerFactory::LockServer( BOOL bLock )
{
	// based on the request update the locks count
    if ( bLock )
	{
        InterlockedIncrement( ( LPLONG ) &g_dwLocks );
	}
    else
	{
        InterlockedDecrement( ( LPLONG ) &g_dwLocks );
	}
	// inform success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerconsumer.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERCONSUMER.H
//  
//  Abstract:
//		Contains CTriggerConsumer definition.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __TRIGGER_CONSUMER_H
#define __TRIGGER_CONSUMER_H

// event consumer class
class CTriggerConsumer : public IWbemUnboundObjectSink
{
private:
	DWORD m_dwCount;			// holds the object reference count

	ITaskScheduler* GetTaskScheduler();

public:
	CTriggerConsumer();
	~CTriggerConsumer();

    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );
    STDMETHODIMP         QueryInterface( REFIID riid, LPVOID* ppv );

	// This routine ultimately receives the event.
    STDMETHOD(IndicateToConsumer)( IWbemClassObject* pLogicalConsumer,
								   LONG lNumObjects, IWbemClassObject** ppObjects );

};

#endif			// __TRIGGER_CONSUMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventcreate\eventcreate.c ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  
//  Module Name:
//  
// 	  EventCreate.c
//  
//  Abstract:
//  
// 	  This modules implements creation of event in the user specified log / application
// 	
// 	  Syntax:
// 	  ------
// 	  EventCreate [-s server [-u username [-p password]]]
// 		[-log name] [-source name] -id eventid -description description -type eventtype
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "EvcrtMsg.h"
#include "EventCreate.h"

//
// local type definitions
//
typedef TCHAR  __OPTION_VALUE[ 256 ];

//
// constants / defines / enumerators
//
#define FULL_SUCCESS			0
#define PARTIALLY_SUCCESS		128
#define COMPLETELY_FAILED		255

#define MAX_KEY_LENGTH		256
#define EVENT_LOG_NAMES_LOCATION	_T( "SYSTEM\\CurrentControlSet\\Services\\EventLog" )

// constants
const TCHAR g_szDefaultLog[] = _T( "Application" );
const TCHAR g_szDefaultSource[] = _T( "EventCreate" );

//
// function prototypes
//
VOID Usage();
BOOL AddEventSource( HKEY hLogsKey, LPCTSTR pszSource );
BOOL CheckExistence( LPCTSTR szServer, 
					 LPCTSTR szLog, LPCTSTR szSource, PBOOL pbCustom );
BOOL CreateLogEvent( LPCTSTR szServer, 
					 LPCTSTR szLog, LPCTSTR szSource, 
					 WORD wType, DWORD dwEventID, LPCTSTR szDescription );
BOOL ProcessOptions( LONG argc, 
					 LPCTSTR argv[], 
					 PBOOL pbShowUsage,
					 PTARRAY parrServer, LPTSTR ppszUserName, LPTSTR ppszPassword, 
					 LPTSTR ppszLogName, LPTSTR ppszLogSource, LPTSTR ppszLogType,
					 PDWORD pdwEventID, LPTSTR ppszDescription, PBOOL pbNeedPwd );

// ***************************************************************************
// Routine Description:
//		This the entry point to this utility.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//  
// Return Value:
//		The below are actually not return values but are the exit values 
//		returned to the OS by this application
//			0		: utility successfully created the events
//			255		: utility completely failed in creating events
//			128		: utility has partially successfull in creating events
// ***************************************************************************
DWORD _cdecl _tmain( LONG argc, LPCTSTR argv[] )
{
	// local variables
	DWORD dw = 0;
	WORD wEventType = 0;
	BOOL bResult = FALSE;
	LPCTSTR pszServer = NULL;
	BOOL bNeedPassword = FALSE;
	BOOL bCloseConnection = FALSE;
	DWORD dwServers = 0, dwSuccess = 0;
	__STRING_512 szBuffer = NULL_STRING;
	
	// variables to hold the command line inputs
	BOOL bUsage = FALSE;							// usage 
	DWORD dwEventID = 0;							// event id
	TARRAY arrServers = NULL;						// holds the list of server names
	__OPTION_VALUE szLogName = NULL_STRING;			// log file name
	__OPTION_VALUE szSource = NULL_STRING;			// source name
	__OPTION_VALUE szType = NULL_STRING;			// event type
	__OPTION_VALUE szUserName = NULL_STRING;		// user name
	__OPTION_VALUE szPassword = NULL_STRING;		// password
	__OPTION_VALUE szDescription = NULL_STRING;		// description of the event

	// create a dynamic array
	arrServers = CreateDynamicArray();
	if ( arrServers == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		EXIT_PROCESS( 1 );
	}

	// process the command-line options
	bResult = ProcessOptions( argc, argv, &bUsage, 
		&arrServers, szUserName, szPassword, szLogName, 
		szSource, szType, &dwEventID, szDescription, &bNeedPassword );

	// check the result of the parsing
	if ( bResult == FALSE )
	{
		// invalid syntax
		DISPLAY_MESSAGE2( stderr, szBuffer, _T( "%s %s" ), TAG_ERROR, GetReason() );

		// release memory
		DestroyDynamicArray( &arrServers );

		// exit from program
		EXIT_PROCESS( 1 );
	}

	// check whether usage has to be displayed or not
	if ( bUsage == TRUE )
	{
		// show the usage of the utility
		Usage();

		// release memory
		DestroyDynamicArray( &arrServers );

		// finally exit from the program
		EXIT_PROCESS( 0 );
	}

	// determine the actual event type
	if ( StringCompare( szType, LOGTYPE_ERROR, TRUE, 0 ) == 0 )
		wEventType = EVENTLOG_ERROR_TYPE;
	else if ( StringCompare( szType, LOGTYPE_WARNING, TRUE, 0 ) == 0 )
		wEventType = EVENTLOG_WARNING_TYPE;
	else if ( StringCompare( szType, LOGTYPE_INFORMATION, TRUE, 0 ) == 0 )
		wEventType = EVENTLOG_INFORMATION_TYPE;

	// ******
	// actual creation of events in respective log files will start from here

	// get the no. of servers specified
	dwServers = DynArrayGetCount( arrServers );

	// now traverse thru the list of servers, and do the needed operations
	dwSuccess = 0;
	for( dw = 0; dw < dwServers; dw++ )
	{
		// get the system name
		pszServer = DynArrayItemAsString( arrServers, dw );
		if ( pszServer == NULL )
			continue;

		// try establishing connection to the required terminal
		bCloseConnection = TRUE;
		bResult = EstablishConnection( 
			pszServer, szUserName, SIZE_OF_ARRAY( szUserName ), 
			szPassword, SIZE_OF_ARRAY( szPassword ), bNeedPassword );
		bNeedPassword = FALSE;		// from next time onwards, we shouldn't prompt for passwd
		if ( bResult == FALSE )
		{
			//
			// failed in establishing n/w connection
			SHOW_RESULT_MESSAGE( NULL, TAG_ERROR, GetReason() );

			// try with next server
			continue;
		}
		else
		{
			// though the connection is successfull, some conflict might have occured
			switch( GetLastError() )
			{
			case I_NO_CLOSE_CONNECTION:
				bCloseConnection = FALSE;
				break;

			case E_LOCAL_CREDENTIALS:
			case ERROR_SESSION_CREDENTIAL_CONFLICT:
				{
					bCloseConnection = FALSE;
					SHOW_RESULT_MESSAGE( NULL, TAG_WARNING, GetReason() );
					break;
				}
			}
		}

		// report the log message
		bResult = CreateLogEvent( pszServer, szLogName, 
			szSource, wEventType, dwEventID, szDescription );
		if ( bResult == TRUE )
		{
			// display the message depending on the mode of conncetivity
			if ( lstrlen( szSource ) != 0 )
			{
				DISPLAY_MESSAGE( stdout, _T( "\n" ) );
				DISPLAY_MESSAGE2(stdout, szBuffer, EVENTCREATE_SUCCESS, szType, szSource);
			}
			else
			{
				DISPLAY_MESSAGE( stdout, _T( "\n" ) );
				DISPLAY_MESSAGE2(stdout, szBuffer, EVENTCREATE_SUCCESS,	szType, szLogName);
			}

			// update the success count
			dwSuccess++;
		}
		else
		{
			// display the message depending on the mode of conncetivity
			// SHOW_RESULT_MESSAGE( pszServer, TAG_ERROR, GetReason() );
			// ( we are temporarily displaying only the error message )
			SHOW_RESULT_MESSAGE( NULL, TAG_ERROR, GetReason() );
		}

		// close the connection that was established by the utility
		if ( bCloseConnection == TRUE )
			CloseConnection( pszServer );
	}

	// destroy the dynamic array
	DestroyDynamicArray( &arrServers );

	// depending the success count, determine whether the exit value
	//		FULL SUCCESS / PARTIAL SUCCESS / COMPLETELY FAILED
	return (dwSuccess == dwServers) ? FULL_SUCCESS :
				  ((dwSuccess == 0) ? COMPLETELY_FAILED : PARTIALLY_SUCCESS);
}

// ***************************************************************************
// Routine Description:
//		This function connects to the specified server's event log (or) source
//		and appropriately creates the needed event in it.
//		  
// Arguments:
//		[ in ] szServer			: server name on which event has to be created.
//								  null string has to be passed in order to create
//								  event on a local system.
//		[ in ] szLog			: Log name in which event has to be created.
//		[ in ] szSource			: Source name in which event has to be created.
//								  if log name is also specified, log name will be
//								  given priority and value in this variable is ignored.
//		[ in ] wType			: specifies type of the event that has to be created
//		[ in ] dwEventID		: event id for the event is being created
//		[ in ] szDescription	: description to the event
//  
// Return Value:
//		TRUE	: if the event creation is successful
//		FALSE	: if failed in creating the event
// ***************************************************************************
BOOL CreateLogEvent( LPCTSTR szServer, LPCTSTR szLog, LPCTSTR szSource, 
					 WORD wType, DWORD dwEventID, LPCTSTR szDescription )
{
	// local variables
	BOOL bReturn = 0;							// return value
	BOOL bCustom = FALSE;
	DWORD dwSeverity = 0;
	HANDLE hEventLog = NULL;					// points to the event log
	LPCTSTR lpszDescriptions[ 1 ] = { NULL };	// building descriptions
	__MAX_SIZE_STRING szBuffer = NULL_STRING;

	//
	// start the process

	// check whether the log / source exists in the registry or not
	bCustom = FALSE;
	if ( CheckExistence( szServer, szLog, szSource, &bCustom ) == FALSE )
		return FALSE;		// return failure

	// check whether the source is custom create or pre-existing source
	if ( bCustom == FALSE )
	{
		// we wont create events in a non-custom source
		SetReason( ERROR_NONCUSTOM_SOURCE );
		return FALSE;
	}

	// open the appropriate event log using the specified 'source' or 'log file'
	// and check the result of the operation
	// Note: At one time, we will make use of log name (or) source but not both
	if ( lstrlen( szSource ) != 0 )
		hEventLog = RegisterEventSource( szServer, szSource );	// open log using source name
	else
		hEventLog = OpenEventLog( szServer, szLog );			// open log

	// check the log open/register result
	if ( hEventLog == NULL )
	{
		// opening/registering  is failed
		SaveLastError();
		return FALSE;
	}

	// determine the severity code
	dwSeverity = 0;
	if ( wType == EVENTLOG_ERROR_TYPE )
		dwSeverity = 3;
	else if ( wType == EVENTLOG_WARNING_TYPE )
		dwSeverity = 2;
	else if ( wType == EVENTLOG_INFORMATION_TYPE )
		dwSeverity = 1;

	// report event
	lpszDescriptions[ 0 ] = szDescription;
	if ( bCustom == TRUE )
	{
		// validate the range of the event id specified
		if ( dwEventID >= MSG_EVENTID_START && dwEventID <= MSG_EVENTID_END )
		{
			// valid event id
			bReturn = ReportEvent( hEventLog, wType, 0, dwEventID, NULL, 1, 0, lpszDescriptions, NULL);

			// check the result
			if ( bReturn == FALSE )
				SaveLastError();						// save the error info
		}
		else
		{
			// format the error message
			bReturn = FALSE;
			_stprintf( szBuffer, ERROR_ID_OUTOFRANGE, MSG_EVENTID_START, MSG_EVENTID_END - 1 );
			SetReason( szBuffer );
		}
	}
	else
	{
		//
		// we are stopping from creating the events in a non-custom source
		// ********************************************************************
		// bReturn = ReportEvent( hEventLog, wType, 0, 
		//	(((unsigned long)(dwSeverity)<<30) | ((unsigned long)(dwEventID))), NULL, 1, 0, lpszDescriptions, NULL);

		// check the result
		// if ( bReturn == FALSE )
		//	SaveLastError();						// save the error info
	}

	// close the event source
	if ( lstrlen( szSource ) != 0 )
		DeregisterEventSource( hEventLog );
	else
		CloseEventLog( hEventLog );
	
	// return the result
	return bReturn;
}

// ***************************************************************************
// Routine Description:
//		This function checks wether the log name or source name specified
//		actually exists in the registry
//		  
// Arguments:
//		[ in ] szServer			- server name
//		[ in ] szLog			- log name 
//		[ in ] szSource			- source name
//  
// Return Value:
//		TRUE	: If log / source exists in the registry
//		FALSE	: if failed find the match
// ***************************************************************************
BOOL CheckExistence( LPCTSTR szServer, LPCTSTR szLog, LPCTSTR szSource, PBOOL pbCustom )
{
	// local variables
	DWORD dwSize = 0;
	DWORD dwLogsIndex = 0;
	DWORD dwDisposition = 0;
	DWORD dwSourcesIndex = 0;
	LONG lResult = 0L;
	HKEY hKey = NULL;
	HKEY hLogsKey = NULL;
	HKEY hSourcesKey = NULL;
	BOOL bFoundMatch = FALSE;
	BOOL bDuplicating = FALSE;
	FILETIME ftLastWriteTime;		// variable that will hold the last write info
	BOOL bErrorOccurred = FALSE;
	BOOL bLog = FALSE, bLogMatched = FALSE;
	BOOL bSource = FALSE, bSourceMatched = FALSE;
	__MAX_SIZE_STRING szBuffer = NULL_STRING;
	TCHAR szRLog[ MAX_KEY_LENGTH ] = NULL_STRING;
	TCHAR szRSource[ MAX_KEY_LENGTH ] = NULL_STRING;

	// prepare the server name into UNC format
	lstrcpy( szBuffer, szServer );
	if ( lstrlen( szServer ) != 0 && IsUNCFormat( szServer ) == FALSE )
	{
		// format the server name in UNC format
		FORMAT_STRING( szBuffer, _T( "\\\\%s" ), szServer );
	}

	// Connect to the registry
	lResult = RegConnectRegistry( szBuffer, HKEY_LOCAL_MACHINE, &hKey );
	if ( lResult != ERROR_SUCCESS)
	{
		// save the error information and return FAILURE
		SetLastError( lResult );
		SaveLastError();
		return FALSE;
	}

	// open the "EventLogs" registry key for enumerating its sub-keys (which are log names)
	lResult = RegOpenKeyEx( hKey, EVENT_LOG_NAMES_LOCATION, 0, KEY_READ, &hLogsKey );
	if ( lResult != ERROR_SUCCESS )
	{
		switch( lResult )
		{
		case ERROR_FILE_NOT_FOUND:
			SetLastError( ERROR_REGISTRY_CORRUPT );
			break;

		default:
			// save the error information and return FAILURE
			SetLastError( lResult );
			break;
		}

		// close the key and return
		SaveLastError();
		RegCloseKey( hKey );
		return FALSE;
	}

	// start enumerating the logs present
	dwLogsIndex = 0;			// initialize the logs index 
	bFoundMatch = FALSE;		// assume neither log (or) source doesn't match
	bErrorOccurred = FALSE;		// assume error is not occured
	dwSize = MAX_KEY_LENGTH;	// max. size of the key buffer
	bLogMatched = FALSE;
	bSourceMatched = FALSE;
	bDuplicating = FALSE;

	////////////////////////////////////////////////////////////////////////
	// Logic:-
	//		1. determine whether user has supplied the log name or not 
	//		2. determine whether user has supplied the source name or not
	//		3. Start enumerating all the logs present in the system
	//		4. check whether log is supplied or not, if yes, check whether
	//		   the current log matches with user supplied one.
	//		5. check whether source is supplied or not, if yes, enumerate the
	//		   sources available under the current log 

	// determine whether searching has to be done of LOG (or) SOURCE
	bLog = ( szLog != NULL && lstrlen( szLog ) != 0 ) ? TRUE : FALSE;			// #1
	bSource = ( szSource != NULL && lstrlen( szSource ) != 0 ) ? TRUE : FALSE;	// #2

	// initiate the enumeration of log present in the system					-- #3
	ZeroMemory( szRLog, MAX_KEY_LENGTH * sizeof( TCHAR ) );	// init to 0's - safe check
	lResult = RegEnumKeyEx( hLogsKey, 0, szRLog, &dwSize, NULL, NULL, NULL, &ftLastWriteTime );

	// traverse thru the sub-keys until there are no more items					-- #3
	do
	{
		// check the result
		if ( lResult != ERROR_SUCCESS )
		{
			// save the error and break from the loop
			bErrorOccurred = TRUE;
			SetLastError( lResult );
			SaveLastError();
			break;
		}

		// if log name is passed, compare the current key value
		// compare the log name with the current key							-- #4
		if ( bLog == TRUE && StringCompare( szLog, szRLog, TRUE, 0 ) == 0 )
			bLogMatched = TRUE;

		// if source name is passed ...											-- #5
		if ( bSource == TRUE && bSourceMatched == FALSE )
		{
			// open the current log name to enumerate the sources under this log
			lResult = RegOpenKeyEx( hLogsKey, szRLog, 0, KEY_READ, &hSourcesKey );
			if ( lResult != ERROR_SUCCESS )
			{
				// save the error and break from the loop
				bErrorOccurred = TRUE;
				SetLastError( lResult );
				SaveLastError();
				break;
			}

			// start enumerating the sources present
			dwSourcesIndex = 0;			// initialize the sources index 
			dwSize = MAX_KEY_LENGTH;	// max. size of the key buffer
			ZeroMemory( szRSource, MAX_KEY_LENGTH * sizeof( TCHAR ) );	
			lResult = RegEnumKeyEx( hSourcesKey, 0, 
				szRSource, &dwSize, NULL, NULL, NULL, &ftLastWriteTime );

			// traverse thru the sub-keys until there are no more items
			do
			{
				if ( lResult != ERROR_SUCCESS )
				{
					// save the error and break from the loop
					bErrorOccurred = TRUE;
					SetLastError( lResult );
					SaveLastError();
					break;
				}

				// check whether this key matches with the required source or not
				if ( StringCompare( szSource, szRSource, TRUE, 0 ) == 0 )
				{
					// source matched
					bSourceMatched = TRUE;
					break;		// break from the loop
				}

				// update the sources index and fetch the next source key
				dwSourcesIndex += 1;
				dwSize = MAX_KEY_LENGTH;	// max. size of the key buffer
				ZeroMemory( szRSource, MAX_KEY_LENGTH * sizeof( TCHAR ) );	
				lResult = RegEnumKeyEx( hSourcesKey, dwSourcesIndex, szRSource, &dwSize, NULL, 
					NULL, NULL, &ftLastWriteTime );
			} while( lResult != ERROR_NO_MORE_ITEMS );

			// close the sources registry key
			RegCloseKey( hSourcesKey );
			hSourcesKey = NULL;		// clear the key value

			// check how the loop ended
			//		1. Source might have found
			//		   Action:- we found required key .. exit from the main loop
			//		2. Error might have occured
			//		   Action:- ignore the error and continue fetching other log's sources
			//		3. End of sources reached in this log
			//		   Action:- check if log name is supplied or not.
			//		            if log specified, then source if not found, break
			//	for cases 2 & 3, clear the contents of lResult for smooth processing

			// Case #2 & #3
			lResult = 0;				// we are not much bothered abt the errors
			bErrorOccurred = FALSE;		// occured while traversing thru the source under logs
			
			// Case #1
			if ( bSourceMatched == TRUE )
			{
				// check whether log is specified or not
				// if log is specified, it should have matched .. otherwise
				// error ... because duplicate source should not be created
				if ( bLog == FALSE || ( bLog && bLogMatched && lstrcmpi( szLog, szRLog ) == 0 ) )
				{
					// no problem ...
					bFoundMatch = TRUE;

					//
					// determine whether this is custom created source or not
					
					// mark this as custom source 
					if ( pbCustom != NULL )
						*pbCustom = FALSE;

					// open the source registry key
					_stprintf( szBuffer, _T( "%s\\%s\\%s" ), EVENT_LOG_NAMES_LOCATION, szRLog, szRSource );
					lResult = RegOpenKeyEx( hKey, szBuffer, 0, KEY_QUERY_VALUE, &hSourcesKey );
					if ( lResult != ERROR_SUCCESS )
					{
						SetLastError( lResult );
						SaveLastError();
						bErrorOccurred = TRUE;
						break;
					}

					// now query for the value
					lResult = RegQueryValueEx( hSourcesKey, _T( "CustomSource" ), NULL, NULL, NULL, NULL );
					if ( lResult != ERROR_SUCCESS && lResult != ERROR_FILE_NOT_FOUND )
					{
						RegCloseKey( hSourcesKey );
						SetLastError( lResult );
						SaveLastError();
						bErrorOccurred = TRUE;
						break;
					}

					// close the souces key
					RegCloseKey( hSourcesKey );

					// mark this as custom source 
					if ( pbCustom != NULL && lResult == ERROR_SUCCESS )
						*pbCustom = TRUE;

					// break from the loop
					break;
				}
				else
				{
					// this should not be the case .. sources should not be duplicated
					FORMAT_STRING( szBuffer, ERROR_SOURCE_DUPLICATING, szRLog );
					SetReason( szBuffer );
					bDuplicating = TRUE;
				}
			}
		}
		else if ( bLogMatched == TRUE && bSource == FALSE )
		{
			// mark this as a custom event source
			if ( pbCustom != NULL  )
				*pbCustom = TRUE;
			
			// ...
			bFoundMatch = TRUE;
			break;
		}
		else if ( bLogMatched == TRUE && bDuplicating == TRUE )
		{
			bErrorOccurred = TRUE;
			break;
		}

		// update the sources index and fetch the next log key
		dwLogsIndex += 1;
		dwSize = MAX_KEY_LENGTH;	// max. size of the key buffer
		ZeroMemory( szRLog, MAX_KEY_LENGTH * sizeof( TCHAR ) );	
		lResult = RegEnumKeyEx( hLogsKey, dwLogsIndex, szRLog, &dwSize, NULL, 
			NULL, NULL, &ftLastWriteTime );
	} while( lResult != ERROR_NO_MORE_ITEMS );

	// close the logs registry key
	RegCloseKey( hLogsKey );
	hLogsKey = NULL;

	// check whether any error has occured or not in doing above tasks
	if ( bErrorOccurred )
	{
		// close the still opened registry keys
		RegCloseKey( hKey );

		// return failure
		return FALSE;
	}

	// now check whether location for creating the event is found or not
	// if not, check for the possibilities to create the source at appropriate location
	// NOTE:-
	//		  we won't create the logs. also to create the source, user needs to specify
	//		  the log name in which this source needs to be created.
	if ( bFoundMatch == FALSE )
	{
		if ( bLog == TRUE && bLogMatched == FALSE )
		{
			// log itself was not found ... error message
			FORMAT_STRING( szBuffer, ERROR_LOG_NOTEXISTS, szLog );
			SetReason( szBuffer );
		}
		else if ( bLog && bSource && bLogMatched && bSourceMatched == FALSE )
		{
			//
			// log name and source both were supplied but only log was found
			// so create the source in it

			// open the "EventLogs\{logname}" registry key for creating new source
			FORMAT_STRING2( szBuffer, _T( "%s\\%s" ), EVENT_LOG_NAMES_LOCATION, szLog );
			lResult = RegOpenKeyEx( hKey, szBuffer, 0, KEY_WRITE, &hLogsKey );
			if ( lResult != ERROR_SUCCESS )
			{
				switch( lResult )
				{
				case ERROR_FILE_NOT_FOUND:
					SetLastError( ERROR_REGISTRY_CORRUPT );
					break;

				default:
					// save the error information and return FAILURE
					SetLastError( lResult );
					break;
				}

				// close the key and return
				SaveLastError();
				RegCloseKey( hKey );
				return FALSE;
			}

			// now create the subkey with the source name given
			if ( AddEventSource( hLogsKey, szSource ) == FALSE )
			{
				RegCloseKey( hKey );
				RegCloseKey( hLogsKey );
				return FALSE;
			}

			// creation of new source is successfull
			bFoundMatch = TRUE;
			RegCloseKey( hSourcesKey );
			RegCloseKey( hLogsKey );

			// mark this as a custom event source
			if ( pbCustom != NULL  )
				*pbCustom = TRUE;
		}
		else if ( bLog == FALSE && bSource == TRUE && bSourceMatched == FALSE )
		{
			// else we need both log name and source in order to create the source
			SetReason( ERROR_NEED_LOG_ALSO );
		}
	}

	// close the currently open registry keys
	RegCloseKey( hKey );

	// return the result
	return bFoundMatch;
}

// ***************************************************************************
// Routine Description:
//		This function adds a new source to under the specifie log
//		  
// Arguments:
//  
// Return Value:
//		TRUE	: on success
//		FALSE	: on failure
// ***************************************************************************
BOOL AddEventSource( HKEY hLogsKey, LPCTSTR pszSource )
{
	// local variables
    HKEY hSourcesKey; 
	LONG lResult = 0;
	DWORD dwData = 0;
	DWORD dwLength = 0;
	DWORD dwDisposition = 0;
    LPTSTR pszBuffer = NULL; 

	// validate the inputs
	if ( hLogsKey == NULL || pszSource == NULL )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		SaveLastError();
		return FALSE;
	}
 
	// create the custom source
	lResult = RegCreateKeyEx( hLogsKey, pszSource, 0, _T( "" ), 
		REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hSourcesKey, &dwDisposition );
	if ( lResult != ERROR_SUCCESS )
	{
		SetLastError( lResult );
		SaveLastError();
		return FALSE;
	}

	// set the name of the message file.
	dwLength = lstrlen( _T( "%SystemRoot%\\System32\\EventCreate.exe" ) );
	pszBuffer = calloc( dwLength + 1, sizeof( TCHAR ) );
	if ( pszBuffer == NULL )
	{
		// set the error
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();

		// close the created registry key
		RegCloseKey( hSourcesKey );
		hSourcesKey = NULL;

		// return
		return FALSE;
	}

	// copy the required value into buffer
    lstrcpy( pszBuffer, _T( "%SystemRoot%\\System32\\EventCreate.exe" ) );
 
    // add the name to the EventMessageFile subkey. 
	lResult = RegSetValueEx( hSourcesKey, 
		_T( "EventMessageFile" ), 0, REG_EXPAND_SZ, (LPBYTE) pszBuffer, (dwLength + 1) * sizeof( TCHAR ) );
	if ( lResult != ERROR_SUCCESS )
	{
		// save the error
		SetLastError( lResult );
		SaveLastError();

		// release the memories allocated till this point
		RegCloseKey( hSourcesKey );
		hSourcesKey = NULL;

		// free the allocated memory
		if ( pszBuffer != NULL )
		{
			free( pszBuffer );
			pszBuffer = NULL;
		}

		// return
		return FALSE;
	}
 
    // set the supported event types in the TypesSupported subkey. 
	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE; 
    lResult = RegSetValueEx( hSourcesKey, _T( "TypesSupported" ), 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );
	if ( lResult != ERROR_SUCCESS )
	{
		// save the error
		SetLastError( lResult );
		SaveLastError();

		// release the memories allocated till this point
		RegCloseKey( hSourcesKey );
		hSourcesKey = NULL;

		// free the allocated memory
		if ( pszBuffer != NULL )
		{
			free( pszBuffer );
			pszBuffer = NULL;
		}

		// return
		return FALSE;
	}
 
    // mark this source as custom created source
	dwData = 1;
    lResult = RegSetValueEx( hSourcesKey, _T( "CustomSource" ), 0, REG_DWORD, (LPBYTE) &dwData, sizeof( DWORD ) );
	if ( lResult != ERROR_SUCCESS )
	{
		// save the error
		SetLastError( lResult );
		SaveLastError();

		// release the memories allocated till this point
		RegCloseKey( hSourcesKey );
		hSourcesKey = NULL;

		// free the allocated memory
		if ( pszBuffer != NULL )
		{
			free( pszBuffer );
			pszBuffer = NULL;
		}

		// return
		return FALSE;
	}
 
	// close the key
    RegCloseKey( hSourcesKey );

	// free the allocated memory
	if ( pszBuffer != NULL )
	{
		free( pszBuffer );
		pszBuffer = NULL;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		This function parses the options specified at the command prompt
//		  
// Arguments:
//		[ in ]  argc			: count of elements in argv
//		[ in ]  argv			: command-line parameterd specified by the user
//		[ out ] pbShowUsage		: sets to TRUE if -? exists in 'argv'
//		[ out ] parrServers		: value(s) specified with -s ( server ) option in 'argv'
//		[ out ] pszUserName		: value of -u ( username ) option in 'argv'
//		[ out ] pszPassword		: value of -p ( password ) option in 'argv'
//		[ out ] pszLogName		: value of -log ( log name ) option in 'argv'
//		[ out ] pszLogSource	: value of -source ( source name ) option in 'argv'
//		[ out ] pszLogType		: value of -type ( log type ) option in 'argv'
//		[ out ] pdwEventID		: value of -id ( event id ) option in 'argv'
//		[ out ] pszDescription	: value of -description ( description ) option in 'argv'
//		[ out ] pbNeedPwd		: sets to TRUE if -s exists without -p in 'argv'
//  
// Return Value:
//		TRUE	: the parsing is successful
//		FALSE	: errors occured in parsing
// ***************************************************************************
BOOL ProcessOptions( LONG argc, 
					 LPCTSTR argv[], 
					 PBOOL pbShowUsage,
					 PTARRAY parrServers, LPTSTR pszUserName, LPTSTR pszPassword, 
					 LPTSTR pszLogName, LPTSTR pszLogSource, LPTSTR pszLogType,
					 PDWORD pdwEventID, LPTSTR pszDescription, PBOOL pbNeedPwd )
{
	// local variables
	LPTSTR pszDup = NULL;
	LPCTSTR pszServer = NULL;
	PTCMDPARSER pcmdOption = NULL;
	TCMDPARSER cmdOptions[ MAX_OPTIONS ];

	//
	// prepare the command options
	ZeroMemory( cmdOptions, sizeof( TCMDPARSER ) * MAX_OPTIONS );

	// init the password with "*"
	if ( pszPassword != NULL )
	{
		lstrcpy( pszPassword, _T( "*" ) );
	}

	// -?
	pcmdOption = &cmdOptions[ OI_HELP ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_USAGE;
	pcmdOption->pValue = pbShowUsage;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_HELP );

	// -s
	pcmdOption = &cmdOptions[ OI_SERVER ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = 
		CP_TYPE_TEXT | CP_VALUE_NODUPLICATES | CP_MODE_ARRAY | CP_VALUE_MANDATORY;
	pcmdOption->pValue = parrServers;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_SERVER );

	// -u
	pcmdOption = &cmdOptions[ OI_USERNAME ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pcmdOption->pValue = pszUserName;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_USERNAME );

	// -p
	pcmdOption = &cmdOptions[ OI_PASSWORD ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	pcmdOption->pValue = pszPassword;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_PASSWORD );

	// -log
	pcmdOption = &cmdOptions[ OI_LOG ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pcmdOption->pValue = pszLogName;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_LOG );

	// -type
	pcmdOption = &cmdOptions[ OI_TYPE ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_VALUES | CP_MANDATORY;
	pcmdOption->pValue = pszLogType;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, OVALUES_TYPE );
	lstrcpy( pcmdOption->szOption, OPTION_TYPE );

	// -source
	pcmdOption = &cmdOptions[ OI_SOURCE ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	pcmdOption->pValue = pszLogSource;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_SOURCE );

	// -id
	pcmdOption = &cmdOptions[ OI_ID ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY | CP_MANDATORY;
	pcmdOption->pValue = pdwEventID;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_ID );

	// -description
	pcmdOption = &cmdOptions[ OI_DESCRIPTION ];
	pcmdOption->dwCount = 1;
	pcmdOption->dwActuals = 0;
	pcmdOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MANDATORY;
	pcmdOption->pValue = pszDescription;
	pcmdOption->pFunction = NULL;
	pcmdOption->pFunctionData = NULL;
	lstrcpy( pcmdOption->szValues, NULL_STRING );
	lstrcpy( pcmdOption->szOption, OPTION_DESCRIPTION );

	//
	// do the parsing
	if ( DoParseParam( argc, argv, MAX_OPTIONS, cmdOptions ) == FALSE )
		return FALSE;			// invalid syntax

	//
	// now, check the mutually exclusive options

	// check the usage option
	if ( *pbShowUsage == TRUE  )
	{
		if ( argc > 2 )
		{
			// no other options are accepted along with -? option
			SetLastError( MK_E_SYNTAX );
			SetReason( ERROR_INVALID_USAGE_REQUEST );
			return FALSE;
		}
		else
		{
			// no need of furthur checking of the values
			return TRUE;
		}
	}

	// empty system is not valid
	if ( cmdOptions[ OI_SERVER ].dwActuals != 0 )
	{
		// get the server name
		pszServer = DynArrayItemAsString( *parrServers, 0 );
		if ( pszServer != NULL )
		{
			// get the duplicate of this server name
			// we need to trim the value and then check
			pszDup = _tcsdup( pszServer );
			if ( pszDup == NULL )
			{
				SetLastError( E_OUTOFMEMORY );
				SaveLastError();
				return FALSE;
			}

			// trim the string value
			TrimString( pszDup, TRIM_ALL );

			// check the length now
			if ( lstrlen( pszDup ) == 0 )
			{
				// release the memory and return error
				free( pszDup );
				pszDup = NULL;
				SetLastError( MK_E_SYNTAX );
				SetReason( ERROR_SYSTEM_EMPTY );
				return FALSE;
			}

			// release memory
			free( pszDup );
			pszDup = NULL;
		}
	}

	// "-u" should not be specified without "-s"
	if ( cmdOptions[ OI_SERVER ].dwActuals == 0 && 
					cmdOptions[ OI_USERNAME ].dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_USERNAME_BUT_NOMACHINE );
		return FALSE;			// indicate failure
	}

	// empty user is not valid
	TrimString( pszUserName, TRIM_ALL );				// trim the string
	if ( cmdOptions[ OI_USERNAME ].dwActuals != 0 && lstrlen( pszUserName ) == 0 )
	{
		// invalid syntax
		SetReason( ERROR_USERNAME_EMPTY );
		return FALSE;
	}

	// "-p" should not be specified without "-u"
	if ( cmdOptions[ OI_USERNAME ].dwActuals == 0 && 
					cmdOptions[ OI_PASSWORD ].dwActuals != 0 )
	{
		// invalid syntax
		SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
		return FALSE;			// indicate failure
	}

	// check whether caller should accept the password or not
	// if -s ( server ) or -u ( username ) is specified 
	// but no "-p", then utility should accept password
	// provided if establish connection is failed without the credentials information
	if ( cmdOptions[ OI_PASSWORD ].dwActuals != 0 && 
		 pszPassword != NULL && lstrcmp( pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		*pbNeedPwd = TRUE;
	}
	else if ( cmdOptions[ OI_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ OI_SERVER ].dwActuals != 0 || cmdOptions[ OI_USERNAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		*pbNeedPwd = TRUE;
		if ( pszPassword != NULL )
		{
			lstrcpy( pszPassword, _T( "" ) );
		}
	}

	// event id should be greater than 0 ( zero ) and less than 65536
	if ( *pdwEventID <= 0 || *pdwEventID >= 65536 )
	{
		// invalid numeric value
		SetReason( ERROR_INVALID_EVENT_ID );
		return FALSE;
	}

	// description should not be empty
	TrimString( pszDescription, TRIM_ALL );				// trim the string
	if ( lstrlen( pszDescription ) == 0 )
	{
		// description is null
		SetReason( ERROR_DESCRIPTION_IS_EMPTY );
		return FALSE;
	}

	// either -source (or) -log must be specified ( both can also be specified )
	if ( cmdOptions[ OI_SOURCE ].dwActuals == 0 && cmdOptions[ OI_LOG ].dwActuals == 0 )
	{
		// if log name and application were not specified, we will set to defaults
		lstrcpy( pszLogName, g_szDefaultLog );
		lstrcpy( pszLogSource, g_szDefaultSource );
	}

	// -source option value should not be empty ( if specified )
	TrimString( pszLogSource, TRIM_ALL );				// trim the string
	if ( cmdOptions[ OI_SOURCE ].dwActuals != 0 && lstrlen( pszLogSource ) == 0 )
	{
		// description is null
		SetReason( ERROR_LOGSOURCE_IS_EMPTY );
		return FALSE;
	}

	// -log option value should not be empty ( if specified )
	TrimString( pszLogName, TRIM_ALL );				// trim the string
	if ( cmdOptions[ OI_LOG ].dwActuals != 0 && lstrlen( pszLogName ) == 0 )
	{
		// description is null
		SetReason( ERROR_LOGSOURCE_IS_EMPTY );
		return FALSE;
	}

	// check whether atleast one -s is specified or not ... if not, add 'null string' to
	// the servers array so that default it will work for local system
	if ( cmdOptions[ OI_SERVER ].dwActuals == 0 )
		DynArrayAppendString( *parrServers, NULL_STRING, 0 );

	// command-line parsing is successfull
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		This function fetches usage information from resource file and shows it
//		  
// Arguments:
//		None
//  
// Return Value:
//		None
// ***************************************************************************
VOID Usage()
{
	// local variables
	DWORD dw = 0;

	// start displaying the usage
	for( dw = ID_USAGE_START; dw <= ID_USAGE_END; dw++ )
		ShowMessage( stdout, GetResString( dw ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerprovider.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERPROVIDER.H
//  
//  Abstract:
//		Contains CTriggerProvider definition.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#ifndef __TRIGGER_PROVIDER_H
#define __TRIGGER_PROVIDER_H

// typedefs
typedef TCHAR STRINGVALUE[ MAX_STRING_LENGTH + 1 ];

#define ERROR_TRIGNAME_ALREADY_EXIST	1
#define	ERROR_TRIGGER_NOT_DELETED		2
#define ERROR_TRIGGER_NOT_FOUND			3
#define WARNING_INVALID_USER			2
#define ERROR_SCHDEULE_TASK_INVALID_USER   0x80041310
#define ERROR_TASK_SCHDEULE_SERVICE_STOP   0x80041315
#define EXE_STRING					_T( ".exe" )
#define CREATE_METHOD_NAME			L"CreateETrigger"
#define DELETE_METHOD_NAME			L"DeleteETrigger"
#define QUERY_METHOD_NAME			L"QueryETrigger"
#define IN_TRIGGER_ID				L"TriggerID"
#define IN_TRIGGER_NAME				L"TriggerName"
#define IN_TRIGGER_DESC				L"TriggerDesc"
#define IN_TRIGGER_ACTION			L"TriggerAction"
#define IN_TRIGGER_QUERY			L"TriggerQuery"
#define IN_TRIGGER_USER				L"RunAsUser"
#define IN_TRIGGER_PWD				L"RunAsPwd"
#define IN_TRIGGER_TSCHDULER		L"ScheduledTaskName"
#define RETURN_VALUE				L"ReturnValue"
#define OUT_RUNAS_USER				L"RunAsUser"
#define UNIQUE_TASK_NAME			_T( "%s%d%d" )

#define NAMESPACE					L"root\\cimv2"
#define CONSUMER_CLASS				L"CmdTriggerConsumer"
#define TRIGGER_ID					L"TriggerID"
#define TRIGGER_NAME				L"TriggerName"
#define TRIGGER_DESC				L"TriggerDesc"
#define TRIGGER_ACTION              L"Action"
#define TASK_SHEDULER				L"ScheduledTaskName"

#define FILTER_CLASS				L"__EventFilter"
#define FILTER_NAME                 L"Name"
#define FILTER_QUERY_LANGUAGE       L"QueryLanguage"
#define QUERY_LANGUAGE				L"WQL"
#define FILTER_QUERY				L"Query"

#define BINDINGCLASS				L"__FilterToConsumerBinding"
#define CONSUMER_BIND				L"Consumer"
#define FILTER_BIND					L"Filter"

#define REL_PATH					L"__RELPATH"
#define	BIND_CONSUMER_PATH			_T( "CmdTriggerConsumer.TriggerID=%d" )
#define TRIGGER_INSTANCE_NAME		_T( "SELECT * FROM CmdTriggerConsumer WHERE TriggerName = \"%s\"" )
#define BIND_FILTER_PATH			_T( "__EventFilter.Name=\"" )
#define BACK_SLASH					L"\""
#define DOUBLE_SLASH				L"\\\"\""
#define EQUAL						_T( '=' )
#define DOUBLE_QUOTE				_T( '"' )
#define END_OF_STRING				_T( '\0' )
#define FILTER_PROP					_T( "__FilterToConsumerBinding.Consumer=\"%s\",Filter=\"__EventFilter.Name=\\\"" )
#define FILTER_UNIQUE_NAME			_T( "CmdTriggerConsumer.%d%d:%d:%d%d/%d/%d" )
#define CONSUMER_QUERY				_T("SELECT * FROM CmdTriggerConsumer WHERE TriggerName = \"%s\"")
#define VALID_QUERY					_T("__instancecreationevent where targetinstance isa \"win32_ntlogevent\"")
#define EVENT_LOG					_T("win32_ntlogevent")
#define INSTANCE_EXISTS_QUERY		L"select * from CmdTriggerConsumer"

// provider class
class CTriggerProvider : public IDispatch,
						 public IWbemEventConsumerProvider, 
						 public IWbemServices, public IWbemProviderInit
{
private:
	DWORD m_dwCount;			// holds the object reference count
	DWORD m_dwNextTriggerID;	// holds the value of the next trigger id

	// WMI related stuff
	LPWSTR m_pwszLocale;
	IWbemContext* m_pContext;
	IWbemServices*  m_pServices;

// construction / destruction
public:
	CTriggerProvider();
	~CTriggerProvider();

// methods
private:

	HRESULT CreateTrigger( VARIANT varTName,
						   VARIANT varTDesc,
						   VARIANT varTAction,
						   VARIANT varTQuery,
						   VARIANT varRUser,
						   VARIANT varRPwd,
						   HRESULT *phRes = NULL );

	HRESULT DeleteTrigger( VARIANT varTName,
						   DWORD *dwTrigId );
						   
	HRESULT QueryTrigger( VARIANT  varScheduledTaskName,
						  CHString &szRunAsUser  );

	HRESULT ValidateParams( VARIANT varTrigName,
							VARIANT varTrigAction,
							VARIANT	varTrigQuery );

	HRESULT SetUserContext( 	VARIANT varRUser,
								VARIANT varRPwd,
								VARIANT varTAction,
								CHString &szscheduler );

	HRESULT DeleteTaskScheduler( CHString strTScheduler );

	ITaskScheduler* GetTaskScheduler();

	VOID CTriggerProvider::GetUniqueTScheduler( CHString& szScheduler,
												DWORD dwTrigID,
												VARIANT varTrigName );

// [ implementation of ] interfaces members
public:
	// ****
    // IUnknown members
    STDMETHODIMP_(ULONG) AddRef( void );
    STDMETHODIMP_(ULONG) Release( void );
    STDMETHODIMP         QueryInterface( REFIID riid, LPVOID* ppv );

	// ****
	// IDispatch interface
    STDMETHOD( GetTypeInfoCount )( THIS_ UINT FAR* pctinfo )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};

    STDMETHOD( GetTypeInfo )( 
		THIS_ UINT itinfo, 
		LCID lcid, 
		ITypeInfo FAR* FAR* pptinfo )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};

    STDMETHOD( GetIDsOfNames )( 
		THIS_ REFIID riid, 
		OLECHAR FAR* FAR* rgszNames, 
		UINT cNames, 
		LCID lcid, 
		DISPID FAR* rgdispid )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};

    STDMETHOD( Invoke )( 
		THIS_ DISPID dispidMember, 
		REFIID riid, 
		LCID lcid, 
		WORD wFlags,
		DISPPARAMS FAR* pdispparams, 
		VARIANT FAR* pvarResult, 
		EXCEPINFO FAR* pexcepinfo, 
		UINT FAR* puArgErr )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};

	// ****
    // IWbemProviderInit members

	HRESULT STDMETHODCALLTYPE Initialize(
		LPWSTR pszUser,
		LONG lFlags,
		LPWSTR pszNamespace,
		LPWSTR pszLocale,
		IWbemServices *pNamespace,
		IWbemContext *pCtx,
		IWbemProviderInitSink *pInitSink );

	// ****
	// IWbemServices members
	HRESULT STDMETHODCALLTYPE OpenNamespace( 
		const BSTR Namespace,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE CancelAsyncCall( IWbemObjectSink __RPC_FAR *pSink ) 
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE QueryObjectSink( 
		long lFlags,
		IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler ) 
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE GetObject( 
		const BSTR ObjectPath,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult ) 
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE GetObjectAsync( 
		const BSTR ObjectPath,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	}
    
	HRESULT STDMETHODCALLTYPE PutClass( 
		IWbemClassObject __RPC_FAR *pObject,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE PutClassAsync( 
		IWbemClassObject __RPC_FAR *pObject,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE DeleteClass( 
		const BSTR Class,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
		const BSTR Class,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler) 
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE CreateClassEnum( 
		const BSTR Superclass,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
		const BSTR Superclass,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE PutInstance( 
		IWbemClassObject __RPC_FAR *pInst,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
		IWbemClassObject __RPC_FAR *pInst,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE DeleteInstance( 
		const BSTR ObjectPath,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
		const BSTR ObjectPath,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
		const BSTR Class,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
		const BSTR Class,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	}
    
	HRESULT STDMETHODCALLTYPE ExecQuery( 
		const BSTR QueryLanguage,
		const BSTR Query,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
		const BSTR QueryLanguage,
		const BSTR Query,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
		const BSTR QueryLanguage,
		const BSTR Query,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};
    
	HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
		const BSTR QueryLanguage,
		const BSTR Query,
		long lFlags,
		IWbemContext __RPC_FAR *pCtx,
		IWbemObjectSink __RPC_FAR *pResponseHandler )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	};

	HRESULT STDMETHODCALLTYPE ExecMethod( 
		const BSTR strObjectPath, 
		const BSTR strMethodName, 
		long lFlags, 
		IWbemContext* pCtx,
		IWbemClassObject* pInParams, 
		IWbemClassObject** ppOutParams, 
		IWbemCallResult** ppCallResult )
	{
		// not implemented at this class level ... handled by base class ( WMI base class )
		return WBEM_E_NOT_SUPPORTED;
	}

	// *** one of method implemented by this provider under IWbemServices interface ***
	HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
		const BSTR strObjectPath, 
		const BSTR strMethodName, 
		long lFlags, 
		IWbemContext* pCtx, 
		IWbemClassObject* pInParams, 
		IWbemObjectSink* pResponseHandler );

	// ****
	// IWbemEventConsumerProvider members
	// ( this routine allows you to map the one physical consumer to potentially
	//	 multiple logical consumers. )
    STDMETHOD( FindConsumer )( IWbemClassObject* pLogicalConsumer, 
		IWbemUnboundObjectSink** ppConsumer);
};

#endif		// __TRIGGER_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventcreate\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  
//  Module Name:
// 
//		pch.h 
//  
//  Abstract:
//  
// 		pre-compiled header declaration
//		files that has to be pre-compiled into .pch file
//  
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************
#ifndef __PCH_H
#define __PCH_H

#ifdef __cplusplus
extern "C" {
#endif

#pragma once		// include header file only once

//
// public Windows header files
//
#include <windows.h>
#include "winerror.h"

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#ifdef __cplusplus
}
#endif

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\cmdevtgprov\triggerprovider.cpp ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		TRIGGERPROVIDER.CPP
//  
//  Abstract:
//		Contains CTriggerProvider implementation.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 9-oct-2k : Created It.
//***************************************************************************

#include "pch.h"
#include "General.h"
#include "EventConsumerProvider.h"
#include "TriggerConsumer.h"
#include "TriggerProvider.h"
#include "resource.h"

extern HMODULE g_hModule;

//
// general purpose macros
// ( some macros in this section might end abruptly ... this was done purposefully
//   do not alter that part ... will result compiler errors
//
#define VALUE_GET( object, property, type, valueaddr, size )		\
		hr = PropertyGet( object, property, type, valueaddr, size );	\
		if ( FAILED( hr ) )	\
			return hr;

//***************************************************************************
// Routine Description:
//		Constructor for CTriggerProvider class for  initialization.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerProvider::CTriggerProvider()
{
	// update the no. of provider instances count
    InterlockedIncrement( ( LPLONG ) &g_dwInstances );

	// initialize the reference count variable
    m_dwCount = 0;

	// initializations
	m_pContext = NULL;
	m_pServices = NULL;
	m_pwszLocale = NULL;
	m_dwNextTriggerID = 0;
}

//***************************************************************************
// Routine Description:
//		Destructor for CTriggerProvider class.
//                         
// Arguments:
//		None.
//
// Return Value:
//		None.
//***************************************************************************
CTriggerProvider::~CTriggerProvider()
{
	// release the services / namespace interface ( if exist )
	SAFERELEASE( m_pServices );

	// release the context interface ( if exist )
	SAFERELEASE( m_pContext );

	// if memory is allocated for storing locale information, free it
	if ( m_pwszLocale != NULL )
	{
		delete [] m_pwszLocale;
	}
	// update the no. of provider instances count
    InterlockedDecrement( ( LPLONG ) &g_dwInstances );
	
}

//***************************************************************************
// Routine Description:
//		Returns a pointer to a specified interface on an object
//		to which a client currently holds an interface pointer. 
//                         
// Arguments:
//		riid [in] : Identifier of the interface being requested. 
//		ppv [out] : Address of pointer variable that receives the
//					interface pointer requested in riid. Upon
//					successful return, *ppvObject contains the
//					requested interface  pointer to the object.
//
// Return Value:
//		NOERROR if the interface is supported.
//		E_NOINTERFACE if not.
//***************************************************************************
STDMETHODIMP CTriggerProvider::QueryInterface( REFIID riid, LPVOID* ppv )
{
	// initialy set to NULL 
    *ppv = NULL;

	// check whether interface requested is one we have
	if ( riid == IID_IUnknown )
	{
		// need IUnknown interface
		*ppv = this;
	}
	else if ( riid == IID_IWbemEventConsumerProvider )
	{
		// need IEventConsumerProvider interface
		*ppv = static_cast<IWbemEventConsumerProvider*>( this );
	}
	else if ( riid == IID_IWbemServices )
	{
		// need IWbemServices interface
		*ppv = static_cast<IWbemServices*>( this );
	}
	else if ( riid == IID_IWbemProviderInit )
	{
		// need IWbemProviderInit
		*ppv = static_cast<IWbemProviderInit*>( this );
	}
	else
	{
		// request interface is not available
		return E_NOINTERFACE;
	}

	// update the reference count
	reinterpret_cast<IUnknown*>( *ppv )->AddRef();
	return NOERROR;		// inform success
}

//***************************************************************************
// Routine Description:
//		The AddRef method increments the reference count for
//		an interface on an object. It should be called for every
//		new copy of a pointer to an interface on a given object. 
//                         
// Arguments:
//		none.
//
// Return Value:
//		Returns the value of the new reference count.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerProvider::AddRef( void )
{
	// increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

//***************************************************************************
// Routine Description:
//		The Release method decreases the reference count of  the object by 1.
//                         
// Arguments:
//		none.
//
// Return Value:
//		Returns the new reference count.
//***************************************************************************
STDMETHODIMP_(ULONG) CTriggerProvider::Release( void )
{
	// decrement the reference count ( thread safe ) and check whether
	// there are some more references or not ... based on the result value
	DWORD dwCount = 0;
	dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
	if ( dwCount == 0 )
	{
		// free the current factory instance
		delete this;
	}
    
	// return the no. of instances references left
    return dwCount;
}

//***************************************************************************
// Routine Description:
//		This is the implemention of IWbemProviderInit. The 
//		method is need to initialize with CIMOM.
//                         
// Arguments:
//		wszUser	[in] : pointer to user name.
//		lFlags	[in] : Reserved.
//		wszNamespace [in] : contains the namespace of WMI.
//		wszLocale [in] : Locale Name.
//		pNamespace [in] : pointer to IWbemServices.
//		pCtx [in] : IwbemContext pointer associated for  initialization.
//		pInitSink [out]	: a pointer to IWbemProviderInitSink for
//						  reporting the initialization status.
//
// Return Value:
//		returns HRESULT value.
//***************************************************************************
STDMETHODIMP CTriggerProvider::Initialize( LPWSTR wszUser, LONG lFlags,
										   LPWSTR wszNamespace, LPWSTR wszLocale,
										   IWbemServices* pNamespace, IWbemContext* pCtx,
										   IWbemProviderInitSink* pInitSink )
{
	HRESULT					  hRes = 0;
	IEnumWbemClassObject 	  *pINTEConsumer = NULL;
	DWORD					  dwReturned = 0;
	DWORD					  dwTrigId = 0;
	VARIANT					  varTrigId;
	DWORD					  i = 0;

	try
	{
		// save the namespace interface ... will be useful at later stages
		m_pServices = pNamespace;
		m_pServices->AddRef();		// update the reference

		// also save the context interface ... will be userful at later stages ( if available )
		if ( pCtx != NULL )
		{
			m_pContext = pCtx;
			m_pContext->AddRef();
		}

		// save the locale information ( if exist )
		if ( wszLocale != NULL )
		{
			m_pwszLocale = new WCHAR [ wcslen( wszLocale ) + 1 ];
			if ( m_pwszLocale == NULL )
			{
				// update the sink accordingly
				pInitSink->SetStatus( WBEM_E_FAILED, 0 );

				// return failure
				return WBEM_E_OUT_OF_MEMORY;
			}
		}

		// Enumerate TriggerEventConsumer to get the Maximum trigger Id which can be later
		// used to generate unique trigger id value.

		hRes = m_pServices ->CreateInstanceEnum(
							_bstr_t(CONSUMER_CLASS),
							WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
							m_pContext, &pINTEConsumer);
			
		if (SUCCEEDED( hRes ) )
		{
			dwReturned = 1;

			// Final Next will return with ulReturned = 0
			while ( dwReturned != 0 )
			{
				IWbemClassObject *pINTCons[5];

				// Enumerate through the resultset.
				hRes = pINTEConsumer->Next( WBEM_INFINITE,
										5,				// return just one Logfile
										pINTCons,		// pointer to Logfile
										&dwReturned );	// number obtained: one or zero

				if ( SUCCEEDED( hRes ) )
				{
					// Get the trigger id value
					for( i = 0; i < dwReturned; i++ )
					{
						VariantInit( &varTrigId );
						hRes = pINTCons[i]->Get( TRIGGER_ID, 0, &varTrigId, 0, NULL );
						SAFERELEASE( pINTCons[i] );
						
						if ( SUCCEEDED( hRes ) )
						{
							dwTrigId = ( DWORD )varTrigId.lVal;
							if( dwTrigId > m_dwNextTriggerID )
							{
								m_dwNextTriggerID = dwTrigId;
							}
						}
						else
						{
							VariantClear( &varTrigId );
							break;
						}
						VariantClear( &varTrigId );
					}
				}
				else
				{
					break;
				}
			}  //while
			// got triggerId so set it
			SAFERELEASE( pINTEConsumer );
		}
		//Let CIMOM know your initialized
		//===============================
		if ( SUCCEEDED( hRes ) )
		{
			// update the m_dwTrigId value
			m_dwNextTriggerID = m_dwNextTriggerID + 1;
			hRes = pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
		}
		else
		{
			hRes = pInitSink->SetStatus( WBEM_E_FAILED, 0);
		}
	}
	catch(_com_error& e)
	{
		hRes = pInitSink->SetStatus( WBEM_E_FAILED, 0);
		return hRes;
	}
	return hRes;
}

//***************************************************************************
// Routine Description:
//		This is the Async function implementation.           
//		The methods supported is named CreateETrigger and  DeleteETrigger.
//
// Arguments:
//		bstrObjectPath [in] : path of the object for which the method is executed.
//		bstrMethodName [in] : Name of the method for the object.
//		lFlags  [in]        : WBEM_FLAG_SEND_STATUS.
//		pICtx  [in]   : a pointer to IWbemContext. 
//		pIInParams [in]  : this points to an IWbemClassObject object
//						   that contains the properties acting as 
//						   inbound parameters for method execution.
//		pIResultSink [out] : The object sink receives the result of  the method call. 
//
// Return Value:
//		returns HRESULT.
//***************************************************************************
STDMETHODIMP CTriggerProvider::ExecMethodAsync( const BSTR bstrObjectPath,
											    const BSTR bstrMethodName, 
												long lFlags, 
												IWbemContext* pICtx, 
												IWbemClassObject* pIInParams, 
												IWbemObjectSink* pIResultSink )
{
	HRESULT					hRes = 0;
	HRESULT					hRes1 = NO_ERROR;
    IWbemClassObject 		*pIClass = NULL;
    IWbemClassObject 		*pIOutClass = NULL;    
    IWbemClassObject		*pIOutParams = NULL;
	VARIANT					varTriggerName, varTriggerAction, varTriggerQuery,
							varTriggerDesc, varTemp, varRUser, varRPwd, varScheduledTaskName;
	DWORD					dwTrigId = 0;
	try
	{
		//set out parameters
		hRes = m_pServices->GetObject( CONSUMER_CLASS, 0, pICtx, &pIClass, NULL );
		if( FAILED( hRes ) )
		{
			pIResultSink->SetStatus( 0, hRes, NULL, NULL );
			return hRes;
		}
	 
		// This method returns values, and so create an instance of the
		// output argument class.

		hRes = pIClass->GetMethod( bstrMethodName, 0, NULL , &pIOutClass );
		SAFERELEASE( pIClass );    
		if( FAILED( hRes ) )
		{
			 pIResultSink->SetStatus( 0, hRes, NULL, NULL );
			 return hRes;
		}

		hRes  = pIOutClass->SpawnInstance( 0, &pIOutParams );
		SAFERELEASE( pIOutClass );    
		if( FAILED( hRes ) )
		{
			 pIResultSink->SetStatus( 0, hRes, NULL, NULL );
			 return hRes;
		}
		
		VariantInit( &varTriggerName );
		//Check the method name
		if( _wcsicmp( bstrMethodName, CREATE_METHOD_NAME ) == 0 )
		{
			//  if client has called CreateETrigger then 
			//  parse input params to get trigger name, trigger desc, trigger action
			//  and trigger query for creating new instances of TriggerEventConsumer,
			//  __EventFilter and __FilterToConsumerBinding classes

			//initialize variables
			VariantInit( &varTriggerAction );
			VariantInit( &varTriggerQuery );
			VariantInit( &varTriggerDesc );
			VariantInit( &varRUser );
			VariantInit( &varRPwd );

			//Retrieve Trigger Name parameter from input params
			hRes = pIInParams->Get( IN_TRIGGER_NAME, 0, &varTriggerName, NULL, NULL );   
			if( SUCCEEDED( hRes ) )
			{
				//Retrieve Trigger Action parameter from input params
				hRes = pIInParams->Get( IN_TRIGGER_ACTION, 0, &varTriggerAction, NULL, NULL );   
				if( SUCCEEDED( hRes ) )
				{
					//Retrieve Trigger Query parameter from input params
					hRes = pIInParams->Get( IN_TRIGGER_QUERY, 0, &varTriggerQuery, NULL, NULL );   
					if( SUCCEEDED( hRes ) )
					{
						//Retrieve Trigger Description parameter from input params
						hRes = pIInParams->Get( IN_TRIGGER_DESC, 0, &varTriggerDesc, NULL, NULL );   
						if( SUCCEEDED( hRes ) )
						{
							EnterCriticalSection( &g_critical_sec );
							hRes = ValidateParams( varTriggerName, varTriggerAction,
												   varTriggerQuery );
							if( hRes == WBEM_S_NO_ERROR )
							{
								hRes = pIInParams->Get( IN_TRIGGER_USER, 0, &varRUser, NULL, NULL );   
								if( SUCCEEDED( hRes ) )
								{
									hRes = pIInParams->Get( IN_TRIGGER_PWD, 0, &varRPwd, NULL, NULL );   
									if( SUCCEEDED( hRes ) )
									{
										//call create trigger function to create the instances
										hRes = CreateTrigger( varTriggerName, varTriggerDesc,
															  varTriggerAction, varTriggerQuery,
															  varRUser, varRPwd, &hRes1 );
										if( ( hRes == WBEM_S_NO_ERROR ) || ( hRes == WARNING_INVALID_USER ) )
										{
											// increment the class member variable by one to get the new unique trigger id
											//for the next instance
											m_dwNextTriggerID = m_dwNextTriggerID + 1;
										}
									}
								}
							}
							LeaveCriticalSection( &g_critical_sec );
						}
					}
				}		
			}
			VariantClear( &varTriggerAction );	
			VariantClear( &varRUser );	
			VariantClear( &varRPwd );	
			VariantClear( &varTriggerDesc );	
			VariantClear( &varTriggerQuery );	
		}
		else if( _wcsicmp( bstrMethodName, DELETE_METHOD_NAME ) == 0 )
		{
			//Retrieve Trigger ID parameter from input params
			hRes = pIInParams->Get( IN_TRIGGER_NAME, 0, &varTriggerName, NULL, NULL );

			if( SUCCEEDED( hRes ) )
			{
				EnterCriticalSection( &g_critical_sec );
				//call Delete trigger function to delete the instances
				hRes = DeleteTrigger( varTriggerName, &dwTrigId );
				LeaveCriticalSection( &g_critical_sec );
			}
		}
		else if( _wcsicmp( bstrMethodName, QUERY_METHOD_NAME ) == 0 )
		{
			VariantInit( &varScheduledTaskName );
			VariantInit( &varRUser );
			//Retrieve schedule task name parameter from input params
			hRes = pIInParams->Get( IN_TRIGGER_TSCHDULER, 0, &varScheduledTaskName, NULL, NULL );
			if( SUCCEEDED( hRes ) )
			{
				EnterCriticalSection( &g_critical_sec );
				//call query trigger function to query the runasuser
				CHString szRunAsUser = NULL_STRING;
				hRes = QueryTrigger( varScheduledTaskName, szRunAsUser );
				varRUser.vt  = VT_BSTR;
				varRUser.bstrVal = SysAllocString( szRunAsUser );
				hRes = pIOutParams->Put( OUT_RUNAS_USER , 0, &varRUser, 0 ); 
				LeaveCriticalSection( &g_critical_sec );
			}
			VariantClear( &varScheduledTaskName );	
			VariantClear( &varRUser );	
		}
		else
		{
			 hRes = WBEM_E_INVALID_PARAMETER;
		}

		if( _wcsicmp( bstrMethodName, CREATE_METHOD_NAME ) == 0 )
		{
			LPTSTR lpResStr = NULL; 
			lpResStr = ( LPTSTR ) __calloc( MAX_RES_STRING1 + 1, sizeof( TCHAR ) );

			if ( lpResStr != NULL )
			{
				if( ( hRes == WBEM_S_NO_ERROR ) || ( hRes == WARNING_INVALID_USER ) )
				{
					LoadStringW( g_hModule, IDS_CREATED, lpResStr, MAX_RES_STRING1 );
					if( hRes1 != NO_ERROR )// write invalid user into log file
					{
						LPTSTR lpResStr1 = NULL; 
						BOOL   bFlag = FALSE;
						lpResStr1 = ( LPTSTR ) __calloc( MAX_RES_STRING1 + 1, sizeof( TCHAR ) );
						if ( lpResStr1 != NULL )
						{
							if( hRes1 == ERROR_TASK_SCHDEULE_SERVICE_STOP )
							{
								hRes = WBEM_S_NO_ERROR;
								LoadStringW( g_hModule,IDS_INFO_SERVICE_STOPPED, lpResStr1, MAX_RES_STRING1 );
								lstrcat( lpResStr, lpResStr1 );
							}
							else if( hRes1 == ERROR_SCHDEULE_TASK_INVALID_USER )
							{
								hRes = WARNING_INVALID_USER;
								LoadStringW( g_hModule, IDS_INFO_INVALID_USER, lpResStr1, MAX_RES_STRING1 );
								lstrcat( lpResStr, lpResStr1 );
							}
							free( lpResStr1 );
						}
					}
					ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), ( m_dwNextTriggerID - 1 ) );
				}
				else
				{
					LoadStringW( g_hModule, IDS_CREATE_FAILED, lpResStr, MAX_RES_STRING1 );
					ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), ( m_dwNextTriggerID - 1 ) );
				}
				free( lpResStr );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
			}
		}
		else if( _wcsicmp( bstrMethodName, DELETE_METHOD_NAME ) == 0 )
		{
			LPTSTR lpResStr = NULL; 
			lpResStr = ( LPTSTR ) __calloc( MAX_RES_STRING1 + 1, sizeof( TCHAR ) );

			if ( lpResStr != NULL )
			{
				if( hRes == WBEM_S_NO_ERROR )
				{
					LoadStringW( g_hModule, IDS_DELETED, lpResStr, MAX_RES_STRING1 );
					ErrorLog( lpResStr, ( LPWSTR )_bstr_t( varTriggerName ), dwTrigId );
				}
				else
				{
					LoadStringW( g_hModule, IDS_DELETE_FAILED, lpResStr, MAX_RES_STRING1 );
					ErrorLog( lpResStr,( LPWSTR )_bstr_t( varTriggerName ), dwTrigId );
				}
				free( lpResStr );
			}
			else
			{
				hRes = E_OUTOFMEMORY;
			}

		}
		
		VariantInit( &varTemp );
		V_VT( &varTemp ) = VT_I4;
		V_I4( &varTemp ) = hRes;

		// set out params
		hRes = pIOutParams->Put( RETURN_VALUE , 0, &varTemp, 0 ); 
		VariantClear( &varTemp );
		if( SUCCEEDED( hRes ) )
		{
			// Send the output object back to the client via the sink. Then 
			hRes = pIResultSink->Indicate( 1, &pIOutParams );   
		}
			//release all the resources
		SAFERELEASE( pIOutParams );
		
		hRes = pIResultSink->SetStatus( 0, WBEM_S_NO_ERROR, NULL, NULL );
	}
	catch(_com_error& e)
	{
		pIResultSink->SetStatus( 0, hRes, NULL, NULL );
		return hRes;
	}
	catch( CHeap_Exception  )
	{
		hRes = E_OUTOFMEMORY;
		pIResultSink->SetStatus( 0, hRes, NULL, NULL );
		return hRes;
	}

	return hRes;
}


//***************************************************************************
// Routine Description:
//		This routine creates the instance of TriggerEventConsumer,
//		__EventFilter and __FilterToConsumerBinding classes.
//
// Arguments:
//		varTName [in] :  Trigger Name.
//		varTDesc [in] :  Trigger Description.
//		varTAction [in] :  Trigger Action.
//		varTQuery [in]  :  Trigger Query.
//
// Return Value:
//		S_OK if successful.
//		Otherwise failure  error code.
//***************************************************************************
HRESULT CTriggerProvider::CreateTrigger( VARIANT varTName, VARIANT varTDesc,
										 VARIANT varTAction, VARIANT varTQuery,
										 VARIANT varRUser,  VARIANT varRPwd,
										 HRESULT *phRes )
{
    IWbemClassObject 			*pINtLogEventClass = 0;
	IWbemClassObject			*pIFilterClass = 0;
	IWbemClassObject			*pIBindClass = 0;
	IWbemClassObject 			*pINewInstance = 0;
	IEnumWbemClassObject		*pIEnumClassObject = 0;
	HRESULT						hRes = 0;
	DWORD						dwTId = 0;
	VARIANT						varTemp;
	TCHAR						szTemp[MAX_RES_STRING1];
	TCHAR						szTemp1[MAX_RES_STRING1];
	TCHAR						szFName[MAX_RES_STRING1];
	SYSTEMTIME					SysTime;
	BOOL						bInvalidUser = FALSE;

	try
	{
		_bstr_t						bstrcurInst;
		_bstr_t						bstrcurInst1;
		//initialize memory for temporary variables
		memset( szTemp, 0, sizeof( szTemp ) );
		memset( szTemp1, 0, sizeof(szTemp1 ) );
		memset( szFName, 0, sizeof( szFName ) );
		VariantInit( &varTemp );
		if ( phRes != NULL )
		{
			*phRes = NO_ERROR;
		}

		/**************************************************************************

							   CREATING __EventFilter INSTANCE

		***************************************************************************/
		// get EventFilter class object
		hRes = m_pServices->GetObject( FILTER_CLASS, 0, 0, &pIFilterClass, NULL );
		
		if( FAILED( hRes ) )
		{
		   return hRes;
		}

		// Create a new instance.
		hRes = pIFilterClass->SpawnInstance( 0, &pINewInstance );
		SAFERELEASE( pIFilterClass );  // Don't need the class any more

		//return error if unable to spawn a new instance of EventFilter class
		if( FAILED( hRes ) )
		{
			return hRes;
		}

		// set query property for the new instance
		hRes = pINewInstance->Put( FILTER_QUERY, 0, &varTQuery, 0 );
			
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		VariantInit( &varTemp ); 
		varTemp.vt = VT_BSTR;
		varTemp.bstrVal = SysAllocString( QUERY_LANGUAGE );
		
		//  set query language property for the new instance .
		hRes = pINewInstance->Put( FILTER_QUERY_LANGUAGE, 0, &varTemp, 0 );
		VariantClear( &varTemp ); 
			
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		//generate unique name for name key property of EventFilter class by concatinating
		// current system date and time

		GetSystemTime( &SysTime );
		wsprintf ( szTemp, FILTER_UNIQUE_NAME, m_dwNextTriggerID, SysTime.wHour, SysTime.wMinute,
				   SysTime.wSecond, SysTime.wMonth, SysTime.wDay, SysTime.wYear );
		//set Filter name property
		VariantInit( &varTemp ); 
		varTemp.vt  = VT_BSTR;
		varTemp.bstrVal = SysAllocString( szTemp );
		
		hRes = pINewInstance->Put( FILTER_NAME, 0, &varTemp, 0 );
		VariantClear( &varTemp );
		
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		// Write the instance to WMI. 
		hRes = m_pServices->PutInstance( pINewInstance, 0, NULL, NULL );
		SAFERELEASE( pINewInstance );

		//if putinstance failed return error
		if( FAILED( hRes ) )
		{
			return hRes;
		}

		//get the current Eventfilter instance for binding filter to consumer
		wsprintf( szTemp1, BIND_FILTER_PATH );
		bstrcurInst = _bstr_t(szTemp1) + _bstr_t(szTemp) + _bstr_t(BACK_SLASH);
		pIFilterClass = NULL;
		hRes = m_pServices->GetObject( bstrcurInst, 0L, NULL, &pIFilterClass, NULL );

		//unable to get the current instance object return error
		if( FAILED( hRes ) )
		{
			return hRes;
		}

		/**************************************************************************

							   CREATING TriggerEventConsumer INSTANCE

		***************************************************************************/

		//get NTEventConsumer class object
		hRes =m_pServices->GetObject( CONSUMER_CLASS, 0, 0, &pINtLogEventClass, NULL );

		//if unable to get the object of TriggerEventConsumer return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pINtLogEventClass );// safer side
			SAFERELEASE( pIFilterClass );
			return hRes;
		}

		// Create a new instance.
		pINewInstance = NULL;
		hRes = pINtLogEventClass->SpawnInstance( 0, &pINewInstance );
		SAFERELEASE( pINtLogEventClass );  // Don't need the class any more

		// if unable to spawn a instance return back to caller
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			return hRes;
		}

		//get the unique trigger id from CMethodPro memeber variable

		hRes =  m_pServices->ExecQuery( QUERY_LANGUAGE, INSTANCE_EXISTS_QUERY,
										  WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pIEnumClassObject );
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		DWORD dwReturned = 0;
		IWbemClassObject *pINTCons = NULL;
		// Enumerate through the resultset.
		hRes = pIEnumClassObject->Next( WBEM_INFINITE,
								1,				// return just one service
								&pINTCons,			// pointer to service
								&dwReturned );	// number obtained: one or zero

		if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
		{
			SAFERELEASE( pINTCons );
		} // If Service Succeeded
		else
		{
			 m_dwNextTriggerID = 1;
		}

		SAFERELEASE( pIEnumClassObject );

		dwTId = m_dwNextTriggerID;

		VariantInit(&varTemp);
		varTemp.vt = VT_I4;
		varTemp.lVal = dwTId;

		// set the trigger id property of NTEventConsumer
		hRes = pINewInstance->Put( TRIGGER_ID, 0, &varTemp, 0 );
		VariantClear( &varTemp );

		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		// set Triggername  property.
		hRes = pINewInstance->Put( TRIGGER_NAME, 0, &varTName, 0 );
		
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		// set action property
		hRes = pINewInstance->Put( TRIGGER_ACTION, 0, &varTAction, 0 );
		
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		//set desc property
		hRes = pINewInstance->Put( TRIGGER_DESC, 0, &varTDesc, 0 );
				 
		//if failed to set the property return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		CHString szScheduler = NULL_STRING;
		CHString szRUser = (LPCWSTR)_bstr_t(varRUser.bstrVal);
		if( ( varRUser.vt != VT_NULL ) && ( varRUser.vt != VT_EMPTY ) && ( szRUser.GetLength() > 0 ) ) 
		{
			GetUniqueTScheduler( szScheduler, m_dwNextTriggerID, varTName );
			hRes = SetUserContext( varRUser, varRPwd, varTAction, szScheduler );
			*phRes = hRes;
			if( hRes ==  ERROR_SCHDEULE_TASK_INVALID_USER ||
					( hRes == ERROR_TASK_SCHDEULE_SERVICE_STOP ) ) //to send a warning msg to client
			{
				bInvalidUser = TRUE;
			}
			if( FAILED( hRes ) )
			{
				//if user is not existing or service is stopped skip
				 if( ( hRes !=  ERROR_SCHDEULE_TASK_INVALID_USER ) && ( hRes != ERROR_TASK_SCHDEULE_SERVICE_STOP ) )
				{
					SAFERELEASE( pIFilterClass );
					SAFERELEASE( pINewInstance );
					return hRes;
				}
			}
		}

		VariantInit(&varTemp);
		varTemp.vt  = VT_BSTR;
		varTemp.bstrVal = SysAllocString( szScheduler );
		hRes = pINewInstance->Put( TASK_SHEDULER, 0, &varTemp, 0 );
		VariantClear( &varTemp );
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			SAFERELEASE( pINewInstance );
			return hRes;
		}

		// Write the instance to WMI. 
		hRes = m_pServices->PutInstance( pINewInstance, 0, 0, NULL );
		SAFERELEASE( pINewInstance );

		//if putinstance failed return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			return hRes;
		}

		//get the current instance for binding it with __FilterToConsumerBinding class
		wsprintf( szTemp, BIND_CONSUMER_PATH, dwTId);

		bstrcurInst1 = _bstr_t( szTemp );
		pINtLogEventClass = NULL;
		hRes = m_pServices->GetObject( bstrcurInst1, 0L, NULL, &pINtLogEventClass, NULL );

		//if unable to get the current instance return error
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIFilterClass );
			return hRes;
		}

		/**************************************************************************

							   BINDING FILTER TO CONSUMER

		***************************************************************************/

		// if association class exists...
		if( ( hRes = m_pServices->GetObject( BINDINGCLASS, 0L, NULL, &pIBindClass, NULL ) ) == S_OK )
		{
			// spawn a new instance.
			pINewInstance = NULL;
			if( ( hRes = pIBindClass->SpawnInstance( 0, &pINewInstance ) ) == WBEM_S_NO_ERROR )
			{
				// set consumer instance name
				if ( ( hRes = pINtLogEventClass->Get( REL_PATH, 0L, 
											&varTemp, NULL, NULL ) ) == WBEM_S_NO_ERROR ) 
				{
					hRes = pINewInstance->Put( CONSUMER_BIND, 0, &varTemp, 0 );
					VariantClear( &varTemp );
				
					// set Filter ref
					if ( ( hRes = pIFilterClass->Get( REL_PATH, 0L, 
												&varTemp, NULL, NULL ) ) == WBEM_S_NO_ERROR ) 
					{
						hRes = pINewInstance->Put( FILTER_BIND, 0, &varTemp, 0 );
						VariantClear( &varTemp );
								
						// putInstance
						hRes = m_pServices->PutInstance( pINewInstance,
														WBEM_FLAG_CREATE_OR_UPDATE, NULL, NULL );
					}
				}
				SAFERELEASE( pINewInstance );
				SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
				SAFERELEASE( pIFilterClass );  // Don't need the class any more
				SAFERELEASE( pIBindClass );
			}
			else
			{
				SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
				SAFERELEASE( pIFilterClass );  // Don't need the class any more
				SAFERELEASE( pIBindClass );
			}

		}
		else
		{
				SAFERELEASE( pINtLogEventClass );  // Don't need the class any more
				SAFERELEASE( pIFilterClass );  // Don't need the class any more
		}
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	catch( CHeap_Exception  )
	{
		return E_OUTOFMEMORY;
	}
	if( ( hRes == WBEM_S_NO_ERROR ) && ( bInvalidUser == TRUE ) )
	{
		return WARNING_INVALID_USER;
	}

	return hRes;
}

//***************************************************************************
// Routine Description:
//		This routine deletes the instance of TriggerEventConsumer,
//		__EventFilter and __FilterToConsumerBinding classes.
//
// Arguments:
//		varTName [in]       :  Trigger Name.
//		dwTrigId [in\out]	:  Trigger id.
//
// Return Value:
//		WBEM_S_NO_ERROR if successful.
//		Otherwise failure  error code.
//***************************************************************************

HRESULT CTriggerProvider::DeleteTrigger( VARIANT varTName, DWORD *dwTrigId )
{
	HRESULT							hRes = 0;
	IEnumWbemClassObject 			*pIEventBinder   = NULL;
	IWbemClassObject				*pINTCons = NULL;
	DWORD							dwReturned = 1;
	DWORD							i =0;
	DWORD							j = 0;
	TCHAR							szTemp[MAX_RES_STRING1];
	TCHAR							szTemp1[MAX_RES_STRING1];
	VARIANT							varTemp;
	BSTR							bstrFilInst = NULL;
	DWORD							dwFlag = 0;
	wchar_t							*szwTemp2 = NULL;
	wchar_t							szwFilName[100];
	try
	{
		_bstr_t							bstrBinInst;
		CHString						strTScheduler = NULL_STRING;

		memset( szTemp, 0, sizeof( szTemp ) );
		memset( szTemp1, 0, sizeof( szTemp1 ) );
		memset( szwFilName, 0, sizeof( szwFilName ) );

		wsprintf( szTemp, TRIGGER_INSTANCE_NAME, varTName.bstrVal );
		hRes =  m_pServices->ExecQuery( QUERY_LANGUAGE, _bstr_t( szTemp ),
						WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY, NULL,
						&pIEventBinder );

		memset( szTemp, 0, sizeof( szTemp ) );
		if( FAILED( hRes ) )
		{
			return hRes;
		}
		while ( ( dwReturned == 1 ) &&  ( dwFlag == 0 ) )
		{
			// Enumerate through the resultset.
			hRes = pIEventBinder->Next( WBEM_INFINITE,
									1,				// return just one service
									&pINTCons,			// pointer to service
									&dwReturned );	// number obtained: one or zero

			if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
			{
				dwFlag = 1;
		
			} // If Service Succeeded

		}
		SAFERELEASE( pIEventBinder );

		if( dwFlag == 0 )
		{
			SAFERELEASE( pINTCons );
			return ERROR_TRIGGER_NOT_FOUND;
		}

		VariantInit( &varTemp );
		hRes = pINTCons->Get( TRIGGER_ID, 0, &varTemp, 0, NULL );
		if (FAILED( hRes ) )
		{
			SAFERELEASE( pIEventBinder );
			SAFERELEASE( pINTCons );
			return hRes;
		}
		*dwTrigId = ( DWORD )varTemp.lVal;
		VariantClear( &varTemp );

		hRes = pINTCons->Get( TASK_SHEDULER, 0, &varTemp, 0, NULL );
		if (FAILED( hRes ) )
		{
			SAFERELEASE( pIEventBinder );
			SAFERELEASE( pINTCons );
			return hRes;
		}
		SAFERELEASE( pINTCons );
		strTScheduler = (LPCWSTR) _bstr_t(varTemp.bstrVal);
		VariantClear( &varTemp );
		if( strTScheduler.GetLength() > 0 )
		{
			hRes =  DeleteTaskScheduler( strTScheduler );
			if ( hRes != WBEM_S_NO_ERROR )
			{
				return hRes;
			}
		}

		wsprintf( szTemp, BIND_CONSUMER_PATH, *dwTrigId );

		//enumerate the binding class
		hRes = m_pServices->CreateInstanceEnum(
							_bstr_t(BINDINGCLASS),
							WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
							NULL, &pIEventBinder );

		if ( SUCCEEDED( hRes ) )
		{
			dwReturned = 1;
			dwFlag = 0;
			//loop through all the instances of binding class to find that trigger
			//id specified. If found loop out and proceed else return error
			// Final Next will return with ulReturned = 0
			while ( ( dwReturned == 1 ) && ( dwFlag == 0 ) )
			{
				IWbemClassObject *pIBind = NULL;

				// Enumerate through the resultset.
				hRes = pIEventBinder->Next( WBEM_INFINITE,
										1,				// return just one Logfile
										&pIBind,		// pointer to Logfile
										&dwReturned );	// number obtained: one or zero

				if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
				{
					VariantInit(&varTemp);
					//get consumer property of binding class
					hRes = pIBind->Get( CONSUMER_BIND, 0, &varTemp, 0, NULL );
					if ( SUCCEEDED( hRes ) )
					{
						if (varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY)
						{
							CHString strTemp;
							strTemp = varTemp.bstrVal;

							//compare with the inputed value
							if( wcscmp( szTemp, strTemp ) == 0 ) 
							{
								VariantClear( &varTemp );
								//get the filter property
								hRes = pIBind->Get( FILTER_BIND, 0, &varTemp, 0, NULL );
								if ( hRes != WBEM_S_NO_ERROR )
								{
									SAFERELEASE( pIBind );
									break;
								}
								bstrFilInst = SysAllocString( varTemp.bstrVal );
								dwFlag = 1;
							}
						}
						else
						{
							SAFERELEASE( pIBind );
							break;
						}
					}
					else
					{
						SAFERELEASE( pIBind );
						break;
					}
					SAFERELEASE( pIBind );
					VariantClear( &varTemp );
				}
				else
				{
					break;
				}
			} //end of while
			SAFERELEASE( pIEventBinder );
		}
		else
		{
			return( hRes );
		}

		//if instance has been found delete the instances from consumer,filter
		// and binding class
		if( dwFlag == 1 )
		{
			//get the key properties for binding class
			wsprintf( szTemp1, FILTER_PROP, szTemp );
			szwTemp2 =  (wchar_t *) bstrFilInst;
				
			//manpulate the filter property value to insert the filter name property
			// value in quotes
			i =0;
			while( szwTemp2[i] != EQUAL )
			{
				i++;
			}
			i += 2;
			j = 0;
			while( szwTemp2[i] != DOUBLE_QUOTE )
			{
				szwFilName[j] = ( wchar_t )szwTemp2[i];
				i++;
				j++;
			}
			szwFilName[j] = END_OF_STRING;
			bstrBinInst = _bstr_t( szTemp1 ) + _bstr_t( szwFilName ) + _bstr_t(DOUBLE_SLASH);

			//got it so delete the instance
			hRes = m_pServices->DeleteInstance( bstrBinInst, 0, 0, NULL );
			
			if( FAILED( hRes ) )
			{	
				SysFreeString( bstrFilInst );
				return hRes;	
			}
			//deleting instance from EventFilter class
			hRes = m_pServices->DeleteInstance( bstrFilInst, 0, 0, NULL );
			if( FAILED( hRes ) )
			{
				SysFreeString( bstrFilInst );
				return hRes;
			}

			//deleting instance from TriggerEventConsumer Class
			hRes = m_pServices->DeleteInstance( _bstr_t(szTemp), 0, 0, NULL );
			if( FAILED( hRes ) )
			{
				SysFreeString( bstrFilInst );
				return hRes;
			}
			SysFreeString( bstrFilInst );
		}
		else
			return( ERROR_TRIGGER_NOT_DELETED );
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	catch( CHeap_Exception  )
	{
	    return E_OUTOFMEMORY;
	}
	return WBEM_S_NO_ERROR;
}

//***************************************************************************
// Routine Description:
//		This routine queries task scheduler for account information
//
// Arguments:
//		varScheduledTaskName [in]  : Task scheduler name.
//		szRunAsUser          [out] : stores account information.
//
// Return Value:
//		WBEM_S_NO_ERROR if successful.
//		Otherwise failure  error code.
//***************************************************************************
HRESULT CTriggerProvider::QueryTrigger( VARIANT varScheduledTaskName,  CHString &szRunAsUser )
{

	HRESULT        hRes = 0;
	ITaskScheduler *pITaskScheduler = NULL;
	IEnumWorkItems *pIEnum = NULL;
	ITask          *pITask = NULL;

	LPWSTR *lpwszNames = NULL;
	DWORD dwFetchedTasks = 0;
	TCHAR szActualTask[MAX_STRING_LENGTH] = NULL_STRING;
	try
	{
		pITaskScheduler = GetTaskScheduler();
		if ( pITaskScheduler == NULL )
		{	
			hRes = E_FAIL;
			return hRes;
		}

		hRes = pITaskScheduler->Enum( &pIEnum );
		if( FAILED( hRes ) )
		{
			return hRes;
		}
		while ( SUCCEEDED( pIEnum->Next( 1,
									   &lpwszNames,
									   &dwFetchedTasks ) )
						  && (dwFetchedTasks != 0))
		{
			while (dwFetchedTasks)
			{
				// Check whether the TaskName is present, if present 
				// then return arrJobs.
				// Convert the Wide Charater to Multi Byte value.
				GetCompatibleStringFromUnicode( lpwszNames[ --dwFetchedTasks ], szActualTask, SIZE_OF_ARRAY( szActualTask ) );

				// Parse the TaskName to remove the .job extension.
				szActualTask[lstrlen(szActualTask ) - lstrlen(JOB) ] = NULL_CHAR;
				StrTrim( szActualTask, TRIM_SPACES );
				CHString strTemp;
				strTemp = varScheduledTaskName.bstrVal;
				if( lstrcmpi( szActualTask, strTemp )  == 0 )
				{
					hRes = pITaskScheduler->Activate( szActualTask, IID_ITask, (IUnknown**) &pITask );
					if( SUCCEEDED( hRes ) )
					{
						LPWSTR lpwszUser = NULL;
						hRes = pITask->GetAccountInformation( &lpwszUser ); 
						if( SUCCEEDED( hRes ) )
						{
							szRunAsUser = ( LPWSTR ) lpwszUser;
						}
					}
				}
				CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
			}//end while
			CoTaskMemFree( lpwszNames );
		}
		pIEnum->Release();
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	catch( CHeap_Exception  )
	{
		return E_OUTOFMEMORY;
	}
	return hRes;
}

//***************************************************************************
// Routine Description:
//		This routine validates input parameters trigger name,
//		Trigger Query, Trigger Desc, Trigger Action.
//
// Arguments:
//		varTrigName [in]:  Trigger Name.
//		varTrigAction  [in] :  Trigger Action.
//		varTrigQuery [in] :  Trigger Query.
//
// Return Value:
//		WBEM_S_NO_ERROR if successful.
//		WBEM_E_INVALID_PARAMETER if invalid inputs.
//***************************************************************************
HRESULT CTriggerProvider::ValidateParams( VARIANT varTrigName,
										  VARIANT varTrigAction,
										  VARIANT varTrigQuery )
{
	//local variables
	HRESULT					  hRes = 0;
	IEnumWbemClassObject 	 *pINTEConsumer = NULL;
	DWORD					  dwReturned = 0;
	DWORD					  dwFlag = 0;
	TCHAR					  szTemp[MAX_RES_STRING1];
	TCHAR					  szTemp1[MAX_RES_STRING1];
	LPTSTR					  lpSubStr = NULL;
	try
	{
		CHString				  strTemp = NULL_STRING;

		//check if input values are null
		if ( varTrigName.vt == VT_NULL )
		{
			return ( WBEM_E_INVALID_PARAMETER );
		}
		if ( varTrigAction.vt == VT_NULL )
		{
			return ( WBEM_E_INVALID_PARAMETER );
		}
		if( varTrigQuery.vt == VT_NULL )
		{
			return ( WBEM_E_INVALID_PARAMETER );
		}

		//validate trigger name
		strTemp = (LPCWSTR) _bstr_t(varTrigName.bstrVal);
		dwReturned = strTemp.FindOneOf( L"[]:|<>+=;,?$#{}~^'@`!()*%\\/" ); 
		if( dwReturned != -1 )
		{
			return ( WBEM_E_INVALID_PARAMETER );
		}

		//validate trigger query
		memset( szTemp, 0, sizeof( szTemp ) );
		memset( szTemp1, 0, sizeof( szTemp1 ) );

		strTemp = (LPCWSTR) _bstr_t(varTrigQuery.bstrVal);
		GetCompatibleStringFromUnicode( ( LPCWSTR )strTemp, szTemp, MAX_RES_STRING1 );
		lpSubStr = _tcsstr( szTemp, _T( "__instancecreationevent where targetinstance isa \"win32_ntlogevent\"" ) );

		if( lpSubStr == NULL )
		{
			return ( WBEM_E_INVALID_PARAMETER );
		}

		//make the SQL staements to query trigger event consumer class to check whether
		//an instance with the inputted trigger is already exists
		strTemp = (LPCWSTR) _bstr_t(varTrigName.bstrVal);
		memset( szTemp, 0, sizeof( szTemp ) );
		GetCompatibleStringFromUnicode( (LPCWSTR)strTemp, szTemp, MAX_RES_STRING1 );
		
		wsprintf(szTemp1, CONSUMER_QUERY, szTemp );
		//query triggereventconsumer class
		hRes = m_pServices->ExecQuery( QUERY_LANGUAGE, _bstr_t( szTemp1 ),
						WBEM_FLAG_RETURN_IMMEDIATELY| WBEM_FLAG_FORWARD_ONLY, NULL,
						&pINTEConsumer );

		//enumerate the result set of execquery for trigger name
		dwReturned = 1;
		if ( hRes == WBEM_S_NO_ERROR )
		{
			while ( ( dwReturned == 1 ) &&  ( dwFlag == 0 ) )
			{
				IWbemClassObject *pINTCons = NULL;

				// Enumerate through the resultset.
				hRes = pINTEConsumer->Next( WBEM_INFINITE,
									1,				// return just one service
									&pINTCons,			// pointer to service
									&dwReturned );	// number obtained: one or zero

				if ( SUCCEEDED( hRes ) && ( dwReturned == 1 ) )
				{
					SAFERELEASE( pINTCons );
					dwFlag = 1;
				} // If Service Succeeded

			}
			SAFERELEASE( pINTEConsumer );
		}

		if( dwFlag == 1 )
		{
			return ERROR_TRIGNAME_ALREADY_EXIST;
		}
		else
		{
			return WBEM_S_NO_ERROR;
		}
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	catch( CHeap_Exception  )
	{
		return E_OUTOFMEMORY;
	}
	//return WBEM_S_NO_ERROR;
}

//***************************************************************************
// Routine Description:
//		This routine creates task scheduler.
//
// Arguments:
//		varTName [in]    : Trigger Name.
//		varRUser  [in]   : User name.
//		varRPwd [in]     : Password.
//		varTAction [in]  : TriggerAction.
//		szscheduler [in] : Task scheduler name.
//
// Return Value:
//		Returns HRESULT value.
//***************************************************************************
HRESULT CTriggerProvider::SetUserContext( VARIANT varRUser, VARIANT varRPwd,
										  VARIANT varTAction, CHString &szscheduler )
{
	HRESULT hRes = 0;
	ITaskScheduler *pITaskScheduler = NULL;
    ITaskTrigger *pITaskTrig = NULL;
    ITask *pITask = NULL;
	IPersistFile *pIPF = NULL;
	try
	{
		CHString     strTemp = NULL_STRING;
		CHString     strTemp1 = NULL_STRING;

		SYSTEMTIME systime = {0,0,0,0,0,0,0,0};
		WORD  wTrigNumber = 0;
		WCHAR wszCommand[ MAX_STRING_LENGTH ] = NULL_STRING;
		WCHAR wszApplName[ MAX_STRING_LENGTH ] = NULL_STRING;
		WCHAR wszParams[ MAX_STRING_LENGTH ] = L"";
		WORD  wStartDay		= 0;
		WORD  wStartMonth	= 0;
		WORD  wStartYear	= 0;
		WORD  wStartHour	= 0; 
		WORD  wStartMin		= 0;

		TASK_TRIGGER TaskTrig;
		ZeroMemory(&TaskTrig, sizeof (TASK_TRIGGER));
		TaskTrig.cbTriggerSize = sizeof (TASK_TRIGGER); 
		TaskTrig.Reserved1 = 0; // reserved field and must be set to 0.
		TaskTrig.Reserved2 = 0; // reserved field and must be set to 0.

		strTemp = (LPCWSTR) _bstr_t(varTAction.bstrVal);
		if( GetAsUnicodeString( (LPCWSTR) strTemp, wszCommand, SIZE_OF_ARRAY( wszCommand ) ) == NULL )
		{
			return E_FAIL;
		}

		pITaskScheduler = GetTaskScheduler( );
		if ( pITaskScheduler == NULL )
		{
			return E_FAIL;
		}
		hRes = pITaskScheduler->NewWorkItem( szscheduler, CLSID_CTask, IID_ITask,
										  ( IUnknown** )&pITask );
		if( FAILED( hRes ) )
		{
			return hRes;
		}
		hRes = pITask->QueryInterface( IID_IPersistFile, ( void ** ) &pIPF );
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}
		
		BOOL bRet = ProcessFilePath( wszCommand, wszApplName, wszParams );

		if( bRet == FALSE )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return WBEM_E_INVALID_PARAMETER;
		}

		hRes = pITask->SetApplicationName( wszApplName );
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}

		wchar_t* wcszStartIn = wcsrchr( wszApplName, _T('\\') );
		
		if( wcszStartIn != NULL )
		*( wcszStartIn ) = _T( '\0' );
	
		hRes = pITask->SetWorkingDirectory( wszApplName ); 
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}

		hRes = pITask->SetParameters( wszParams );
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}

		DWORD dwMaxRunTimeMS = INFINITE;
		hRes = pITask->SetMaxRunTime(dwMaxRunTimeMS);
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}
		if( varRUser.vt != VT_NULL && varRUser.vt != VT_EMPTY ) 
		{
			strTemp = (LPCWSTR)_bstr_t(varRUser.bstrVal);
			strTemp1 = (LPCWSTR)_bstr_t(varRPwd.bstrVal);
			hRes = pITask->SetAccountInformation( ( LPCWSTR ) strTemp, ( LPCWSTR )strTemp1 );
		}
		else
		{
			strTemp = (LPCWSTR)_bstr_t(varRUser.bstrVal);
			hRes = pITask->SetAccountInformation( ( LPCWSTR )strTemp, NULL_STRING );
		}
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			return hRes;
		}
		GetLocalTime(&systime);
		wStartDay = systime.wDay;
		wStartMonth = systime.wMonth;
		wStartYear = systime.wYear - 1;
		GetLocalTime(&systime);
		wStartHour = systime.wHour;
		wStartMin = systime.wMinute;
			
		hRes = pITask->CreateTrigger( &wTrigNumber, &pITaskTrig );
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			SAFERELEASE( pITaskTrig );
			return hRes;
		}
		TaskTrig.TriggerType = TASK_TIME_TRIGGER_ONCE;
		TaskTrig.wStartHour = wStartHour;
		TaskTrig.wStartMinute = wStartMin;
		TaskTrig.wBeginDay = wStartDay;
		TaskTrig.wBeginMonth = wStartMonth;
		TaskTrig.wBeginYear = wStartYear;

		hRes = pITaskTrig->SetTrigger( &TaskTrig );	
		if ( FAILED( hRes ) )
		{
			SAFERELEASE( pIPF );
			SAFERELEASE( pITask );
			SAFERELEASE( pITaskTrig );
			return hRes;
		}
		hRes  = pIPF->Save( NULL,TRUE );
		SAFERELEASE( pIPF );
		SAFERELEASE( pITask );
		SAFERELEASE( pITaskTrig );
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	catch( CHeap_Exception  )
	{
		return E_OUTOFMEMORY;
	}
	return hRes;
}

//***************************************************************************
// Routine Description:
//		This routine deletes task scheduler.
//
// Arguments:
//		szTScheduler [in]  : Task Scheduler name.
//
// Return Value:
//		Returns HRESULT value.
//***************************************************************************
HRESULT CTriggerProvider::DeleteTaskScheduler( CHString strTScheduler )
{
	HRESULT hRes = 0;
	ITaskScheduler *pITaskScheduler = NULL;
	IEnumWorkItems *pIEnum = NULL;
	LPWSTR *lpwszNames = NULL;
	DWORD dwFetchedTasks = 0;
	TCHAR szActualTask[MAX_RES_STRING1] = NULL_STRING;

	try
	{
		pITaskScheduler = GetTaskScheduler();
		if ( pITaskScheduler == NULL )
		{	
			return E_FAIL;
		}
		// Enumerate the Work Items
		hRes = pITaskScheduler->Enum( &pIEnum );
		if( FAILED( hRes ) )
		{
			SAFERELEASE( pIEnum );
			return hRes;
		}

		while ( SUCCEEDED( pIEnum->Next( 1,
									   &lpwszNames,
									   &dwFetchedTasks ) )
						  && (dwFetchedTasks != 0))
		{
			while (dwFetchedTasks)
			{
				
				// Check whether the TaskName is present, if present 
				// then return arrJobs.

				// Convert the Wide Charater to Multi Byte value.
				if ( GetCompatibleStringFromUnicode( lpwszNames[ --dwFetchedTasks ],
												   szActualTask,
												   SIZE_OF_ARRAY( szActualTask ) ) == NULL )
				{
					CoTaskMemFree( lpwszNames[ dwFetchedTasks] );
					SAFERELEASE( pIEnum );
					return hRes;
				}

				// Parse the TaskName to remove the .job extension.
				szActualTask[lstrlen(szActualTask ) - lstrlen(JOB) ] = NULL_CHAR;

				StrTrim( szActualTask, TRIM_SPACES );
				
				if( lstrcmpi( szActualTask, strTScheduler ) == 0 )
				{
					
					hRes = pITaskScheduler->Delete( szActualTask );
					CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );
					SAFERELEASE( pIEnum );
					return hRes;
				}
			
			}//end while
		}
	}
	catch(_com_error& e)
	{
		return hRes;
	}
	return ERROR_TRIGGER_NOT_DELETED;

}


//***************************************************************************
// Routine Description:
//		This routine gets task scheduler interface.
//
// Arguments:
//		none.
//
// Return Value:
//		Returns ITaskScheduler interface.
//***************************************************************************
ITaskScheduler* CTriggerProvider::GetTaskScheduler()
{
	HRESULT hRes = S_OK;
	ITaskScheduler *pITaskScheduler = NULL;

    hRes = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL, 
						   IID_ITaskScheduler,(LPVOID*) &pITaskScheduler );
	if( FAILED(hRes))
	{
		return NULL;
	}
	hRes = pITaskScheduler->SetTargetComputer( NULL );
	return pITaskScheduler;
}

//***************************************************************************
// Routine Description:
//		This routine generates unique task scheduler name.
//
// Arguments:
//		szScheduler [in\out] : Unique task scheduler name.
//		dwTrigID [in]		 : Trigger id.
//		varTrigName [in]     : Trigger name.
//
// Return Value:
//		none.
//***************************************************************************
VOID CTriggerProvider::GetUniqueTScheduler( CHString& szScheduler, DWORD dwTrigID, VARIANT varTrigName )
{
	DWORD dwTickCount = 0;
	TCHAR szTaskName[ MAX_RES_STRING1 ] =  NULL_STRING;
	CHString strTemp = NULL_STRING;

	strTemp = (LPCWSTR)_bstr_t(varTrigName.bstrVal);
	dwTickCount = GetTickCount();
	wsprintf( szTaskName, UNIQUE_TASK_NAME, ( LPCWSTR )strTemp, dwTrigID, dwTickCount );
	
	szScheduler = szTaskName;
}

//***************************************************************************
// Routine Description:
//		When Windows Management needs to deliver events to a
//		particular logical consumer, it will call the
//		IWbemEventConsumerProvider::FindConsumer method so that
//		the consumer provider can locate the associated consumer event sink.
//                         
// Arguments:
//		pLogicalConsumer [in] : Pointer to the logical consumer object
//						        to which the event objects are to be  delivered. 
//		  ppConsumer [out]:	    Returns an event object sink to Windows 
//								Management. Windows Management calls
//								AddRef for this pointer and deliver the
//								events associated with the logical
//								consumer to this sink. 
//
// Return Value:
//		returns an HRESULT object that indicates the status of the method call.
//***************************************************************************
STDMETHODIMP CTriggerProvider::FindConsumer( IWbemClassObject* pLogicalConsumer,
											 IWbemUnboundObjectSink** ppConsumer )
{
	// create the logical consumer.
	CTriggerConsumer* pSink = new CTriggerConsumer();
    
	// return it's "sink" interface.
	return pSink->QueryInterface( IID_IWbemUnboundObjectSink, ( LPVOID* ) ppConsumer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventcreate\eventcreate.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation. All rights reserved.
//  
//  Module Name:
//  
// 	  EventCreate.h
//  
//  Abstract:
//  
// 	  macros and prototypes of eventcreate.c
// 	
//  Author:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000
//  
//  Revision History:
//  
// 	  Sunil G.V.N. Murali (murali.sunil@wipro.com) 24-Sep-2000 : Created It.
//  
// *********************************************************************************
#ifndef __EVENTCREATE_H
#define __EVENTCREATE_H

// include resource header
#include "resource.h"

//
// type definitions
//

//
// constants / defines / enumerators
//

// general purpose macros
#define EXIT_PROCESS( exitcode )	\
	ReleaseGlobals();	\
	return exitcode;	\
	1

//
// command line options and their indexes in the array
#define MAX_OPTIONS			9

// supported options ( do not localize )
#define OPTION_HELP			_T( "?|h" )						// 1
#define OPTION_SERVER		_T( "s"	)						// 2
#define OPTION_USERNAME		_T( "u"	)						// 3
#define OPTION_PASSWORD		_T( "p"	)						// 4
#define OPTION_LOG			_T( "l" )						// 5
#define OPTION_TYPE			_T( "t" )						// 6
#define OPTION_SOURCE		_T( "so" )						// 7
#define OPTION_ID			_T( "id" )						// 8
#define OPTION_DESCRIPTION	_T( "d" )						// 9

// indexes
#define OI_HELP				0
#define OI_SERVER			1
#define OI_USERNAME			2
#define OI_PASSWORD			3
#define OI_LOG				4
#define OI_TYPE				5
#define OI_SOURCE			6
#define OI_ID				7
#define OI_DESCRIPTION		8

// values supported by 'type' option
#define OVALUES_TYPE		GetResString( IDS_OVALUES_LOGTYPE )

// 
// others
#define	LOGTYPE_ERROR			GetResString( IDS_LOGTYPE_ERROR )
#define	LOGTYPE_WARNING			GetResString( IDS_LOGTYPE_WARNING )
#define	LOGTYPE_INFORMATION		GetResString( IDS_LOGTYPE_INFORMATION )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE	GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME	GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define	ERROR_INVALID_EVENT_ID			GetResString( IDS_ERROR_INVALID_EVENT_ID )
#define ERROR_DESCRIPTION_IS_EMPTY		GetResString( IDS_ERROR_DESCRIPTION_IS_EMPTY )
#define ERROR_LOGSOURCE_IS_EMPTY		GetResString( IDS_ERROR_LOGSOURCE_IS_EMPTY )
#define ERROR_LOG_SOURCE_BOTH_MISSING	GetResString( IDS_ERROR_LOG_SOURCE_BOTH_MISSING )
#define ERROR_LOG_NOTEXISTS				GetResString( IDS_ERROR_LOG_NOTEXISTS )
#define ERROR_NEED_LOG_ALSO				GetResString( IDS_ERROR_NEED_LOG_ALSO )
#define ERROR_SOURCE_DUPLICATING		GetResString( IDS_ERROR_SOURCE_DUPLICATING )
#define ERROR_USERNAME_EMPTY			GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_INVALID_USAGE_REQUEST		GetResString( IDS_ERROR_INVALID_USAGE_REQUEST )
#define ERROR_SYSTEM_EMPTY				GetResString( IDS_ERROR_SYSTEM_EMPTY )
#define ERROR_ID_OUTOFRANGE				GetResString( IDS_ERROR_ID_OUTOFRANGE )
#define ERROR_NONCUSTOM_SOURCE			GetResString( IDS_ERROR_NONCUSTOM_SOURCE )

#define EVENTCREATE_SUCCESS				GetResString( IDS_EVENTCREATE_SUCCESS )

#endif // __EVENTCREATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventcreate\resource.h ===
// 
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
#define IDS_LOGTYPE_ERROR						101
#define IDS_LOGTYPE_WARNING						102
#define IDS_LOGTYPE_INFORMATION					103
#define IDS_OVALUES_LOGTYPE						106

#define IDS_EVENTCREATE_SUCCESS					151
#define IDS_ERROR_LOG_NOTEXISTS					153
#define IDS_ERROR_USERNAME_BUT_NOMACHINE		154
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME		155
#define IDS_ERROR_INVALID_EVENT_ID				156
#define IDS_ERROR_DESCRIPTION_IS_EMPTY			157
#define IDS_ERROR_LOGSOURCE_IS_EMPTY			158
#define IDS_ERROR_LOG_SOURCE_BOTH_MISSING		159
#define IDS_ERROR_NEED_LOG_ALSO					160
#define IDS_ERROR_SOURCE_DUPLICATING			161
#define IDS_ERROR_USERNAME_EMPTY				162
#define IDS_ERROR_INVALID_USAGE_REQUEST			163
#define IDS_ERROR_SYSTEM_EMPTY					164
#define IDS_ERROR_ID_OUTOFRANGE					165
#define IDS_ERROR_NONCUSTOM_SOURCE				166

#define IDS_USAGE_SYNTAX1               1001
#define IDS_USAGE_SYNTAX2               1002
#define IDS_USAGE_NEWLINE1              1003
#define IDS_USAGE_DESC1                 1004
#define IDS_USAGE_DESC2                 1005
#define IDS_USAGE_DESC3                 1006
#define IDS_USAGE_NEWLINE2              1007
#define IDS_USAGE_PARAMLIST             1008
#define IDS_USAGE_PARAMLIST1            1009
#define IDS_USAGE_PARAMLIST2            1010
#define IDS_USAGE_PARAMLIST3            1011
#define IDS_USAGE_PARAMLIST4            1012
#define IDS_USAGE_PARAMLIST5            1013
#define IDS_USAGE_PARAMLIST6            1014
#define IDS_USAGE_PARAMLIST7            1015
#define IDS_USAGE_PARAMLIST8            1016
#define IDS_USAGE_PARAMLIST9            1017
#define IDS_USAGE_PARAMLIST10           1018
#define IDS_USAGE_PARAMLIST11           1019
#define IDS_USAGE_PARAMLIST12           1020
#define IDS_USAGE_PARAMLIST13           1021
#define IDS_USAGE_PARAMLIST14           1022
#define IDS_USAGE_PARAMLIST15           1023
#define IDS_USAGE_PARAMLIST16           1024
#define IDS_USAGE_PARAMLIST17           1025
#define IDS_USAGE_PARAMLIST18           1026
#define IDS_USAGE_PARAMLIST19           1027
#define IDS_USAGE_PARAMLIST20           1028
#define IDS_USAGE_NEWLINE3              1029
#define IDS_USAGE_EXAMPLES              1030
#define IDS_USAGE_EXAMPLE11             1031
#define IDS_USAGE_EXAMPLE12             1032
#define IDS_USAGE_EXAMPLE21             1033
#define IDS_USAGE_EXAMPLE22             1034
#define IDS_USAGE_EXAMPLE31             1035
#define IDS_USAGE_EXAMPLE32             1036
#define IDS_USAGE_EXAMPLE41             1037
#define IDS_USAGE_EXAMPLE42             1038
#define IDS_USAGE_EXAMPLE51             1039
#define IDS_USAGE_EXAMPLE52             1040
#define IDS_USAGE_EXAMPLE61             1041
#define IDS_USAGE_EXAMPLE62             1042
#define IDS_USAGE_EXAMPLE71             1043
#define IDS_USAGE_EXAMPLE72             1044

// NOTE: Be careful when defining this information
//       The help should be given in consecutive lines
#define ID_USAGE_START	IDS_USAGE_SYNTAX1
#define ID_USAGE_END	IDS_USAGE_EXAMPLE72
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etcreate.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name: 
 
    ETCreate.CPP 

Abstract:

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -create parameter.
  
  This will Create Event Triggers in local / remote system.
  
Author:
     Akhil Gokhale 03-Oct.-2000  (Created it)

Revision History:

******************************************************************************/ 
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETCreate.h"
#include "WMI.h"
#define NTAUTHORITY_USER L"NT AUTHORITY\\SYSTEM"
#define SYSTEM_USER      L"SYSTEM"

//***************************************************************************
// Routine Description:
//		Class constructor
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************
CETCreate::CETCreate()
{
    m_pszServerName         = NULL;
	m_pszUserName           = NULL;
	m_pszPassword           = NULL;
    m_pszTriggerName        = NULL;
	m_arrLogNames           = NULL;
    m_pszType               = NULL;
    m_pszSource             = NULL;
    m_pszDescription        = NULL;
    m_pszTaskName           = NULL;
    m_pszRunAsUserName      = NULL;
    m_pszRunAsUserPassword  = NULL;

	m_bNeedPassword     = FALSE;
    m_bCreate           = FALSE;

    m_bIsCOMInitialize  = FALSE;
    
    m_lMinMemoryReq     = 0;

	m_pWbemLocator      = NULL;
	m_pWbemServices     = NULL;
	m_pEnumObjects      = NULL;
	m_pAuthIdentity     = NULL;
    m_pClass            = NULL;
    m_pOutInst          = NULL;
    m_pInClass          = NULL;
    m_pInInst           = NULL;
    m_pszWMIQueryString = NULL;
    bstrTemp            = NULL;
    m_hStdHandle          = NULL;

    m_pEnumWin32_NTEventLogFile = NULL;
}
//***************************************************************************
// Routine Description:
//		Class constructor
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

CETCreate::CETCreate(LONG lMinMemoryReq,BOOL bNeedPassword)
{
    m_pszServerName     = NULL;
	m_pszUserName       = NULL;
	m_pszPassword       = NULL;
    m_pszTriggerName    = NULL;
	m_arrLogNames       = NULL;
    m_pszType           = NULL;
    m_pszSource         = NULL;
    m_pszDescription    = NULL;
    m_pszTaskName       = NULL;
	m_bNeedPassword     = bNeedPassword;
    m_bCreate           = FALSE;
    m_dwID              = 0;
    m_pszRunAsUserName      = NULL;
    m_pszRunAsUserPassword  = NULL;

    m_bIsCOMInitialize  = FALSE;

	m_pWbemLocator      = NULL;
	m_pWbemServices     = NULL;
	m_pEnumObjects      = NULL;
	m_pAuthIdentity     = NULL;

    m_pClass            = NULL;
    m_pOutInst          = NULL;
    m_pInClass          = NULL;
    m_pInInst           = NULL;

    bstrTemp            = NULL;
    m_hStdHandle          = NULL;
    m_pszWMIQueryString = NULL;

    m_lMinMemoryReq     = lMinMemoryReq;
    m_pEnumWin32_NTEventLogFile = NULL;
}
//***************************************************************************
// Routine Description:
//		Class destructor		
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

CETCreate::~CETCreate()
{
   // Release all memory which is allocated.
    RELEASE_MEMORY_EX(m_pszServerName);
    RELEASE_MEMORY_EX(m_pszUserName);
    RELEASE_MEMORY_EX(m_pszPassword);
    RELEASE_MEMORY_EX(m_pszTriggerName);
    DESTROY_ARRAY(m_arrLogNames);
    RELEASE_MEMORY_EX(m_pszType);
    RELEASE_MEMORY_EX(m_pszSource);
    RELEASE_MEMORY_EX(m_pszDescription);
    RELEASE_MEMORY_EX(m_pszTaskName);
    RELEASE_MEMORY_EX(m_pszWMIQueryString);
    RELEASE_MEMORY_EX(m_pszRunAsUserName);
    RELEASE_MEMORY_EX(m_pszRunAsUserPassword);

    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pEnumObjects);
    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pOutInst);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pEnumWin32_NTEventLogFile);

    // Uninitialize COM only if it is initialized.
    if(m_bIsCOMInitialize == TRUE)
    {
        CoUninitialize();
    }

}
// ***************************************************************************
// Routine Description:
//		Allocates and initialize variables.
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
//***************************************************************************
void 
CETCreate::Initialize()
{
    // local variable
    LONG lTemp = 0;
    // if at all any occurs, we know that is 'coz of the 
	// failure in memory allocation ... so set the error
	SetLastError( E_OUTOFMEMORY );
	SaveLastError();

    // allocate memory at least MAX_COMPUTER_NAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_COMPUTERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_COMPUTERNAME_LENGTH+1;
    m_pszServerName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszServerName,lTemp);

    // allocate memory at least MAX_USERNAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_USERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_USERNAME_LENGTH+1;
    m_pszUserName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszUserName,lTemp);
  
    m_pszRunAsUserName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszRunAsUserName,lTemp);

        
    // allocate memory at least MAX_PASSWORD_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_PASSWORD_LENGTH)?
             m_lMinMemoryReq:MAX_PASSWORD_LENGTH+1;
    m_pszPassword = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszPassword,lTemp);

    m_pszRunAsUserPassword = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszRunAsUserPassword,lTemp);

    m_pszTriggerName = new TCHAR[m_lMinMemoryReq+1]; 
    CheckAndSetMemoryAllocation (m_pszTriggerName,m_lMinMemoryReq);

    m_pszType = new TCHAR[m_lMinMemoryReq+1]; 
    CheckAndSetMemoryAllocation (m_pszType,m_lMinMemoryReq);
    
    m_pszSource = new TCHAR[m_lMinMemoryReq+1]; 
    CheckAndSetMemoryAllocation (m_pszSource,m_lMinMemoryReq);
    
    m_pszDescription = new TCHAR[m_lMinMemoryReq+1]; 
    CheckAndSetMemoryAllocation (m_pszDescription,m_lMinMemoryReq);
    
    m_pszTaskName = new TCHAR[m_lMinMemoryReq+1]; 
    CheckAndSetMemoryAllocation (m_pszTaskName,m_lMinMemoryReq);
    
    m_pszWMIQueryString = new TCHAR[(MAX_RES_STRING*2)+1]; 
    CheckAndSetMemoryAllocation (m_pszWMIQueryString,(MAX_RES_STRING*2));

    
    m_arrLogNames = CreateDynamicArray();
    if(m_arrLogNames == NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // initialization is successful
	SetLastError( NOERROR );			// clear the error
    SetReason( NULL_STRING );			// clear the reason
    return;
}
// ***************************************************************************
// Routine Description:
//		Function will allocate memory to a string
//		  
// Arguments:
//		[in][out] pszStr   : String variable to which memory to be  allocated
//      [in]               : Number of bytes to be allocated.
// Return Value:
//		NONE
// 
//***************************************************************************

void
CETCreate::CheckAndSetMemoryAllocation(LPTSTR pszStr,LONG lSize)
{
    if(pszStr == NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // init to ZERO's
    ZeroMemory( pszStr, lSize * sizeof( TCHAR ) );
}
// ***************************************************************************
// Routine Description:
//		This function will process/parce the command line options.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//  
// Return Value:
//       none
// ***************************************************************************

void 
CETCreate::ProcessOption(DWORD argc, LPCTSTR argv[])
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;

    PrepareCMDStruct();

	// initialize the password variable with '*' 
	if ( m_pszPassword != NULL )
		lstrcpy( m_pszPassword, _T( "*" ) );

    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam( argc, argv, MAX_COMMANDLINE_C_OPTION, cmdOptions);

    if(bReturn == FALSE)
        throw CShowError(MK_E_SYNTAX);
    // empty Server is not valid

    // At least any of -so , -t OR -i should be given .
    if((cmdOptions[ ID_C_SOURCE].dwActuals == 0) &&
       (cmdOptions[ ID_C_TYPE].dwActuals   == 0) &&
       (cmdOptions[ ID_C_ID ].dwActuals    == 0))
    {
           throw CShowError(IDS_ID_TYPE_SOURCE);
    }

	if ( (cmdOptions[ID_C_SERVER].dwActuals != 0) && 
        (lstrlen( m_pszServerName) == 0 ))
	{
		szTempString = m_pszServerName;
		szTempString.TrimRight();
		szTempString.TrimLeft();
		lstrcpy(m_pszServerName,(LPCWSTR)szTempString);
        throw CShowError(IDS_ERROR_SERVERNAME_EMPTY);
	}
    // "-u" should not be specified without "-s"
    if ( cmdOptions[ ID_C_SERVER ].dwActuals == 0 &&
         cmdOptions[ ID_C_USERNAME ].dwActuals != 0 )
    {
        throw CShowError(IDS_ERROR_USERNAME_BUT_NOMACHINE);
    }
	if ( (cmdOptions[ID_C_USERNAME].dwActuals != 0) && 
        (lstrlen( m_pszUserName) == 0 ))
	{
		// empty user is not valid
		szTempString = m_pszUserName;
		szTempString.TrimRight();
		szTempString.TrimLeft();
		lstrcpy(m_pszUserName,(LPCWSTR)szTempString);
        throw CShowError(IDS_ERROR_USERNAME_EMPTY);
	}
    // "-p" should not be specified without -u 
    if ( (cmdOptions[ID_C_USERNAME].dwActuals  == 0) && 
          (cmdOptions[ID_C_PASSWORD].dwActuals != 0 ))
	{
		// invalid syntax
        throw CShowError(IDS_USERNAME_REQUIRED);
	}

	
    if(cmdOptions[ ID_C_RU].dwActuals==1)
    {
       // Trim all blank spaces before and after  
		szTempString = m_pszRunAsUserName;
        szTempString.TrimRight();
        szTempString.TrimLeft();
       lstrcpy(m_pszRunAsUserName,(LPCWSTR)szTempString);
    }

    // "-rp" should not be specified without -ru 
    if ( (cmdOptions[ID_C_RU].dwActuals  == 0) && 
          (cmdOptions[ID_C_RP].dwActuals != 0 ))
	{
		// invalid syntax
        throw CShowError(IDS_RUN_AS_USERNAME_REQUIRED);
	}

    // check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept
    // password the user will be prompter for the password only if establish 
    // connection  is failed without the credentials information
	if ( cmdOptions[ ID_C_PASSWORD ].dwActuals != 0 && 
		 m_pszPassword != NULL && lstrcmp( m_pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( cmdOptions[ ID_C_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ ID_C_SERVER ].dwActuals != 0 || cmdOptions[ ID_C_USERNAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		if ( m_pszPassword != NULL )
		{
			lstrcpy( m_pszPassword, _T( "" ) );
		}
	}

    // Check if -d (Description) is given and if given it cannot be empty
    if(cmdOptions[ ID_C_DESCRIPTION].dwActuals==1)
    {
        szTempString = m_pszDescription;
        szTempString.TrimRight();
        szTempString.TrimLeft();
        lstrcpy(m_pszDescription,(LPCWSTR)szTempString);
        if(lstrlen(m_pszDescription)==0)
            throw CShowError(IDS_ID_DESC_EMPTY);
    }

    // Check if -so (source) is given and if given it cannot be empty
    if(cmdOptions[ ID_C_SOURCE].dwActuals==1)
    {
        szTempString = m_pszSource;
        szTempString.TrimRight();
        szTempString.TrimLeft();
        lstrcpy(m_pszSource,(LPCWSTR)szTempString);
        if(lstrlen(m_pszSource)==0)
            throw CShowError(IDS_ID_SOURCE_EMPTY);
    }
    // Check if -l (log) is given and if given it cannot be empty
    if(cmdOptions[ ID_C_LOGNAME].dwActuals!=0)
    {
        DWORD dwIndx = 0;
        DWORD dNoOfLogNames = DynArrayGetCount( m_arrLogNames );
        for(;dwIndx<dNoOfLogNames;dwIndx++)
        {
            szTempString = DynArrayItemAsString(m_arrLogNames,dwIndx);
            szTempString.TrimRight();
            szTempString.TrimLeft();
            if(szTempString.GetLength()==0)
                throw CShowError(IDS_ID_LOG_EMPTY);
        }
    }
    // checks for -tk (taskname) It must be there and should not be empty
        szTempString = m_pszTaskName;
    szTempString.TrimRight();
    szTempString.TrimLeft();
    lstrcpy(m_pszTaskName,(LPCWSTR)szTempString);
    if((cmdOptions[ ID_C_TASK ].dwActuals == 0) ||
	   (lstrlen(m_pszTaskName) == 0))  
    {
        throw CShowError(IDS_ID_TK_NAME_MISSING);
    }


    // checks for -tr (Triggername). It must be there and should not be empty
    szTempString = m_pszTriggerName;
    szTempString.TrimRight();
    szTempString.TrimLeft();
    lstrcpy(m_pszTriggerName,(LPCWSTR)szTempString);
    if((cmdOptions[ ID_C_TRIGGERNAME ].dwActuals == 0) ||
	   (lstrlen(m_pszTriggerName) == 0))  
    {
        throw CShowError(IDS_ID_TRIG_NAME_MISSING);
    }

    // Check for invalid trigger name
     szTempString =  m_pszTriggerName;
     szTempString.TrimRight();
     szTempString.TrimLeft();
     if(szTempString.FindOneOf(L"[]:|<>+=;,?$#{}~^'@`!()*%\\/")!=-1)
     {
         throw CShowError(IDS_ID_INVALID_TRIG_NAME);
     }
    
    // with -i option only positive integers
    
    if( (cmdOptions[ ID_C_ID ].dwActuals == 1) &&
         ((m_dwID ==0)||(m_dwID>USHRT_MAX))) 
    {
           throw CShowError(IDS_INVALID_ID);
    }
}
// ***************************************************************************
// Routine Description:
//		This function will prepare column structure for DoParseParam Function.
//		  
// Arguments:
//       none
// Return Value:
//       none
// ***************************************************************************
void 
CETCreate::PrepareCMDStruct()
{
    // Filling cmdOptions structure 
   // -create
    lstrcpy(cmdOptions[ ID_C_CREATE ].szOption,OPTION_CREATE);
    cmdOptions[ ID_C_CREATE ].dwFlags = CP_MAIN_OPTION;
    cmdOptions[ ID_C_CREATE ].dwCount = 1;
    cmdOptions[ ID_C_CREATE ].dwActuals = 0;
    cmdOptions[ ID_C_CREATE ].pValue    = &m_bCreate;
    lstrcpy(cmdOptions[ ID_C_CREATE ].szValues,NULL_STRING);
    cmdOptions[ ID_C_CREATE ].pFunction = NULL;
    cmdOptions[ ID_C_CREATE ].pFunctionData = NULL;
    cmdOptions[ ID_C_CREATE ].pFunctionData = NULL;

    // -s (servername)
    lstrcpy(cmdOptions[ ID_C_SERVER ].szOption,OPTION_SERVER);
    cmdOptions[ ID_C_SERVER ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_SERVER ].dwCount = 1;
    cmdOptions[ ID_C_SERVER ].dwActuals = 0;
    cmdOptions[ ID_C_SERVER ].pValue    = m_pszServerName;
    lstrcpy(cmdOptions[ ID_C_SERVER ].szValues,NULL_STRING);
    cmdOptions[ ID_C_SERVER ].pFunction = NULL;
    cmdOptions[ ID_C_SERVER ].pFunctionData = NULL;
    
    // -u (username)
    lstrcpy(cmdOptions[ ID_C_USERNAME ].szOption,OPTION_USERNAME);
    cmdOptions[ ID_C_USERNAME ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_USERNAME ].dwCount = 1;
    cmdOptions[ ID_C_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_C_USERNAME ].pValue    = m_pszUserName;
    lstrcpy(cmdOptions[ ID_C_USERNAME ].szValues,NULL_STRING);
    cmdOptions[ ID_C_USERNAME ].pFunction = NULL;
    cmdOptions[ ID_C_USERNAME ].pFunctionData = NULL;

	// -p (password)
    lstrcpy(cmdOptions[ ID_C_PASSWORD ].szOption,OPTION_PASSWORD);
    cmdOptions[ ID_C_PASSWORD ].dwFlags = CP_TYPE_TEXT|CP_VALUE_OPTIONAL;
    cmdOptions[ ID_C_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_C_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_C_PASSWORD ].pValue    = m_pszPassword;
    lstrcpy(cmdOptions[ ID_C_PASSWORD ].szValues,NULL_STRING);
    cmdOptions[ ID_C_PASSWORD ].pFunction = NULL;
    cmdOptions[ ID_C_PASSWORD ].pFunctionData = NULL;

	// -tr
    lstrcpy(cmdOptions[ ID_C_TRIGGERNAME ].szOption,OPTION_TRIGGERNAME);
    cmdOptions[ ID_C_TRIGGERNAME ].dwFlags = CP_MANDATORY|CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_TRIGGERNAME ].dwCount = 1;
    cmdOptions[ ID_C_TRIGGERNAME ].dwActuals = 0;
    cmdOptions[ ID_C_TRIGGERNAME ].pValue    = m_pszTriggerName;
    lstrcpy(cmdOptions[ ID_C_TRIGGERNAME ].szValues,NULL_STRING);
    cmdOptions[ ID_C_TRIGGERNAME ].pFunction = NULL;
    cmdOptions[ ID_C_TRIGGERNAME ].pFunctionData = NULL;
	
    //-l
    lstrcpy(cmdOptions[ ID_C_LOGNAME ].szOption,OPTION_LOGNAME);
    cmdOptions[ ID_C_LOGNAME ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY|
                                       CP_MODE_ARRAY|CP_VALUE_NODUPLICATES;

    cmdOptions[ ID_C_LOGNAME ].dwCount = 0;
    cmdOptions[ ID_C_LOGNAME ].dwActuals = 0;
    cmdOptions[ ID_C_LOGNAME ].pValue    = &m_arrLogNames ;
    lstrcpy(cmdOptions[ ID_C_LOGNAME ].szValues,NULL_STRING);
    cmdOptions[ ID_C_LOGNAME ].pFunction = NULL;
    cmdOptions[ ID_C_LOGNAME ].pFunctionData = NULL;

    //  -eid
    lstrcpy(cmdOptions[ ID_C_ID ].szOption,OPTION_EID);
    cmdOptions[ ID_C_ID ].dwFlags = CP_TYPE_UNUMERIC|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_ID ].dwCount = 1;
    cmdOptions[ ID_C_ID ].dwActuals = 0;
    cmdOptions[ ID_C_ID ].pValue    = &m_dwID;
    lstrcpy(cmdOptions[ ID_C_ID ].szValues,NULL_STRING);
    cmdOptions[ ID_C_ID ].pFunction = NULL;
    cmdOptions[ ID_C_ID ].pFunctionData = NULL;

    // -t (type)
    lstrcpy(cmdOptions[ ID_C_TYPE ].szOption,OPTION_TYPE);
    cmdOptions[ ID_C_TYPE ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY|
                                    CP_MODE_VALUES;
    cmdOptions[ ID_C_TYPE].dwCount = 1;
    cmdOptions[ ID_C_TYPE].dwActuals = 0;
    cmdOptions[ ID_C_TYPE].pValue    = m_pszType ;
    lstrcpy(cmdOptions[ ID_C_TYPE].szValues,GetResString(IDS_TYPE_OPTIONS));
    cmdOptions[ ID_C_TYPE].pFunction = NULL;
    cmdOptions[ ID_C_TYPE].pFunctionData = NULL;

	// -so (source)
    lstrcpy(cmdOptions[ ID_C_SOURCE].szOption,OPTION_SOURCE);
    cmdOptions[ ID_C_SOURCE].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_SOURCE ].dwCount = 1;
    cmdOptions[ ID_C_SOURCE].dwActuals = 0;
    cmdOptions[ ID_C_SOURCE].pValue    = m_pszSource ;
    lstrcpy(cmdOptions[ ID_C_SOURCE].szValues,NULL_STRING);
    cmdOptions[ ID_C_SOURCE].pFunction = NULL;
    cmdOptions[ ID_C_SOURCE].pFunctionData = NULL;

	// -d (description)
    lstrcpy(cmdOptions[ ID_C_DESCRIPTION].szOption,OPTION_DESCRIPTION);
    cmdOptions[ ID_C_DESCRIPTION].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_DESCRIPTION].dwCount = 1;
    cmdOptions[ ID_C_DESCRIPTION].dwActuals = 0;
    cmdOptions[ ID_C_DESCRIPTION].pValue    = m_pszDescription ;
    lstrcpy(cmdOptions[ ID_C_DESCRIPTION].szValues,NULL_STRING);
    cmdOptions[ ID_C_DESCRIPTION].pFunction = NULL;
    cmdOptions[ ID_C_DESCRIPTION].pFunctionData = NULL;


	// -tk (task)
    lstrcpy(cmdOptions[ ID_C_TASK].szOption,OPTION_TASK);
    cmdOptions[ ID_C_TASK].dwFlags = CP_MANDATORY|CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_TASK].dwCount = 1;
    cmdOptions[ ID_C_TASK].dwActuals = 0;
    cmdOptions[ ID_C_TASK].pValue    = m_pszTaskName; 
    lstrcpy(cmdOptions[ ID_C_TASK].szValues,NULL_STRING);
    cmdOptions[ ID_C_TASK].pFunction = NULL;
    cmdOptions[ ID_C_TASK].pFunctionData = NULL;

    // -ru (RunAsUserName)
    lstrcpy(cmdOptions[ ID_C_RU].szOption,OPTION_RU);
    cmdOptions[ ID_C_RU ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_C_RU ].dwCount = 1;
    cmdOptions[ ID_C_RU ].dwActuals = 0;
    cmdOptions[ ID_C_RU ].pValue    = m_pszRunAsUserName;
    lstrcpy(cmdOptions[ ID_C_RU ].szValues,NULL_STRING);
    cmdOptions[ ID_C_RU ].pFunction = NULL;
    cmdOptions[ ID_C_RU ].pFunctionData = NULL;

    lstrcpy(m_pszRunAsUserPassword,_T("*")); 
	// -pp (Run As User password)
    lstrcpy(cmdOptions[ ID_C_RP ].szOption,OPTION_RP);
    cmdOptions[ ID_C_RP ].dwFlags = CP_TYPE_TEXT|CP_VALUE_OPTIONAL;
    cmdOptions[ ID_C_RP ].dwCount = 1;
    cmdOptions[ ID_C_RP ].dwActuals = 0;
    cmdOptions[ ID_C_RP ].pValue    = m_pszRunAsUserPassword;
    lstrcpy(cmdOptions[ ID_C_RP ].szValues,NULL_STRING);
    cmdOptions[ ID_C_RP ].pFunction = NULL;
    cmdOptions[ ID_C_RP ].pFunctionData = NULL;

}
//***************************************************************************
// Routine Description:
//		This routine will actualy creates eventtrigers in WMI.
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

BOOL 
CETCreate::ExecuteCreate()
{
    // local variables...
    BOOL bResult = FALSE;// Stores return status of function
    HRESULT hr = 0; // Stores return code.
    BOOL bReturn = FALSE; // return value for function
    TCHAR szErrorMsg[MAX_RES_STRING+1];
 
    try 
    {
        // Initialize COM
        InitializeCom(&m_pWbemLocator);
        // make m_bIsCOMInitialize to true which will be useful when
        // uninitialize COM.
        m_bIsCOMInitialize = TRUE;
        {  // brackets used to restrict scope of following declered variables.
            CHString szTempUser = m_pszUserName; // Temp. variabe to store user
                                                // name.
            CHString szTempPassword = m_pszPassword;// Temp. variable to store
                                                    // password.
            m_bLocalSystem = TRUE;
           // Connect remote / local WMI.
            bResult = ConnectWmiEx( m_pWbemLocator, 
                                    &m_pWbemServices, 
                                    m_pszServerName,
                                    szTempUser, 
                                    szTempPassword,
                                    &m_pAuthIdentity, 
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2, 
                                    &m_bLocalSystem);
            if(bResult == FALSE) 
            {
                // ConnectWmiEx will set for reason for failure. 
                TCHAR szErrorMsg[MAX_RES_STRING+1];
                DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR,
                                  GetReason());
                return FALSE;
            }
	        // check the remote system version and its compatiblity
	        if ( m_bLocalSystem == FALSE )
	        {
                DWORD dwVersion = 0;
                dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
                if ( dwVersion <= 5000 )// to block win2k versions
                {
                    SetReason( ERROR_OS_INCOMPATIBLE );
                    DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                                      GetReason());
                    return FALSE;
                }
	        }
	        // check the local credentials and if need display warning
	        if ( m_bLocalSystem && (lstrlen(m_pszUserName)!=0) )
	        {
		        CHString str;
		        WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
		        str.Format( L"%s %s", TAG_WARNING, GetReason() );
		        ShowMessage( stdout, str );
	        }
            // Copy username and password returned from ConnectWmiEx
            lstrcpy(m_pszUserName,szTempUser);
            lstrcpy(m_pszPassword,szTempPassword);
        }
        if(cmdOptions[ ID_C_RU ].dwActuals ==1) 
        {
            CheckRpRu();
        }
        // Show wait message...............
        m_hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
        if(m_hStdHandle!=NULL)
        {
            GetConsoleScreenBufferInfo(m_hStdHandle,&m_ScreenBufferInfo);
        }
        PrintProgressMsg(m_hStdHandle,GetResString(IDS_MSG_EVTRIG_C),m_ScreenBufferInfo);
        // retrieves  TriggerEventCosumer class 

        bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
        hr =  m_pWbemServices->GetObject(bstrTemp,
                                   0, NULL, &m_pClass, NULL);
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);
        
        // Gets  information about the "CreateETrigger" method of
        // "TriggerEventCosumer" class
        bstrTemp = SysAllocString(FN_CREATE_ETRIGGER);
        hr = m_pClass->GetMethod(bstrTemp, 0, &m_pInClass, NULL); 
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);

        // create a new instance of a class "TriggerEventCosumer". 
        hr = m_pInClass->SpawnInstance(0, &m_pInInst);
        ON_ERROR_THROW_EXCEPTION(hr);
    
        // Set the sTriggerName property .
        // sets a "TriggerName" property for Newly created Instance
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_NAME,m_pszTriggerName);
        ON_ERROR_THROW_EXCEPTION(hr);
     
        // Set the sTriggerAction property to Variant.
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_ACTION,m_pszTaskName);
        ON_ERROR_THROW_EXCEPTION(hr);
    
        // Set the sTriggerDesc property to Variant .
        hr = PropertyPut(m_pInInst,FPR_TRIGGER_DESC,m_pszDescription);
        ON_ERROR_THROW_EXCEPTION(hr);
        

       // Set the RunAsUserName property .
       hr = PropertyPut(m_pInInst,FPR_RUN_AS_USER,_bstr_t(m_pszRunAsUserName));
        
        ON_ERROR_THROW_EXCEPTION(hr);

       // Set the RunAsUserNamePAssword property .
        hr = PropertyPut(m_pInInst,FPR_RUN_AS_USER_PASSWORD,_bstr_t(m_pszRunAsUserPassword));
        ON_ERROR_THROW_EXCEPTION(hr);

        lstrcpy(m_pszWMIQueryString ,QUERY_STRING);

	    if(ConstructWMIQueryString() ==TRUE)
        {
            // Set the sTriggerQuery property to Variant
            LONG lTemp = 0;
            TCHAR szMsgString[MAX_RES_STRING];
            TCHAR szMsgFormat[MAX_RES_STRING];

            hr = PropertyPut(m_pInInst,FPR_TRIGGER_QUERY,m_pszWMIQueryString);
            ON_ERROR_THROW_EXCEPTION(hr);

            // All The required properties sets, so 
            // executes CreateETrigger method to create eventtrigger
		    hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER), 
                                        _bstr_t(FN_CREATE_ETRIGGER), 
                                        0, NULL, m_pInInst, &m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION( hr );
            DWORD dwTemp;
            if(PropertyGet(m_pOutInst,FPR_RETURN_VALUE,dwTemp)==FALSE)
            {
                return FALSE;
            }
            lTemp = (LONG)dwTemp;
            PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
            if(lTemp==0)
            {
                 // SUCCESS: message on screen
                 lstrcpy(szMsgFormat,GetResString(IDS_CREATE_SUCCESS));
                 FORMAT_STRING(szMsgString,szMsgFormat,_X(m_pszTriggerName));
                 // Message shown on screen will be...
                 // SUCCESS: The Event Trigger "EventTrigger Name" has 
                 // successfully been created.
                 ShowMessage(stdout,szMsgString);
            }
            else if(lTemp==1) // Means duplicate id found.
            {
			    // Show Error Message
             lstrcpy(szMsgFormat,GetResString(IDS_DUPLICATE_TRG_NAME));
             FORMAT_STRING(szMsgString,szMsgFormat,_X(m_pszTriggerName));
             // Message shown on screen will be...
             // ERROR:Event  Trigger Name "EventTrigger Name"  
             // already exits.
             ShowMessage(stderr,szMsgString);
             return FALSE;
            }
            else if(lTemp==2) // Means ru is invalid so show warning....
                              // along with success message.
            {
                // Show Warning message..
                 ShowMessage(stdout,GetResString(IDS_INVALID_R_U));
                // SUCCESS: message on screen
                lstrcpy(szMsgFormat,GetResString(IDS_CREATE_SUCCESS));
                FORMAT_STRING(szMsgString,szMsgFormat,_X(m_pszTriggerName));
                // Message shown on screen will be...
                // SUCCESS: The Event Trigger "EventTrigger Name" has 
                // successfully been created.
                ShowMessage(stdout,szMsgString);
                return FALSE;
            }
            else
		    {
                 // Prectically this error will never occur
			     lstrcpy(szMsgFormat,GetResString(IDS_INVALID_PARAMETER));
			     FORMAT_STRING(szMsgString,szMsgFormat,_X(m_pszTriggerName));
			     // Message shown on screen will be...
			     // ERROR:Invalid parameter passed.  
			     ShowMessage(stderr,szMsgString);
                 return FALSE;
		    }

        }
        else
        {
           return FALSE; 
        }
        }
        catch(_com_error)
        {
            TCHAR szErrorMsg[MAX_RES_STRING+1];
            PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
            if(hr == 0x80041002)// WMI returns string for this hr value is 
                                // "Not Found." which is not user friendly. So
                                // changing the message text. 
            {
                ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
            }
            else
            {
                DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s" , TAG_ERROR,
                                 GetReason() );
            }
            return FALSE;
        }
    return TRUE;
}
/*****************************************************************************

Routine Description:
     This function Will create a WMI Query String  depending on other 
     parameters supplied with -create parameter  

Arguments:
     none

Return Value:
      TRUE - if Successfully creates Query string
      FALSE - if ERROR
   
******************************************************************************/

BOOL 
CETCreate::ConstructWMIQueryString()
{
    // Local variable
    TCHAR szLogName[MAX_RES_STRING+1];
    DWORD dNoOfLogNames = DynArrayGetCount( m_arrLogNames );
    DWORD dwIndx = 0;
    BOOL bBracket = FALSE;//user to check if brecket is used in WQL
    BOOL bAddLogToSQL = FALSE; // check whether to add log names to WQL
    BOOL bRequiredToCheckLogName = TRUE;// check whether to check log names
    TCHAR szMsgString[MAX_RES_STRING]; // To Show Error msg
    TCHAR szMsgFormat[MAX_RES_STRING]; // To Show Error msg

  
    // Check whether "*"  is given for -log
    // if it is there skip adding log to SQL
    for (dwIndx=0;dwIndx<dNoOfLogNames;dwIndx++)
    {
        if(m_arrLogNames!=NULL)
        {
            lstrcpy(szLogName,DynArrayItemAsString(m_arrLogNames,dwIndx));
        }
        else
        {
            PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
            ShowMessage(stderr,GetResString(IDS_OUTOF_MEMORY));
            return FALSE;
        }
        bAddLogToSQL = TRUE;
        if(lstrcmp(szLogName,ASTERIX)==0)
        {
            DWORD dwNewIndx = 0;
            try 
            {
			    SAFE_RELEASE_BSTR(bstrTemp);
                bstrTemp = SysAllocString(CLS_WIN32_NT_EVENT_LOGFILE);
                HRESULT hr = m_pWbemServices->CreateInstanceEnum(bstrTemp,
                                                   WBEM_FLAG_SHALLOW,
                                                   NULL,
                                                   &m_pEnumWin32_NTEventLogFile);
                SAFE_RELEASE_BSTR(bstrTemp);
                ON_ERROR_THROW_EXCEPTION( hr );
                // set the security at the interface level also
	            hr = SetInterfaceSecurity( m_pEnumWin32_NTEventLogFile, 
                                           m_pAuthIdentity );
                ON_ERROR_THROW_EXCEPTION(hr);

                // remove all from parrLogName which is initialy filled by 
                //DoParceParam()
                DynArrayRemoveAll(m_arrLogNames);
                while(GetLogName(szLogName,m_pEnumWin32_NTEventLogFile)==TRUE)
                {
                   if(DynArrayInsertString(m_arrLogNames,dwNewIndx++,szLogName,
                                           lstrlen(szLogName))==-1)
                   {
                       PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
                       ShowMessage(stderr,GetResString(IDS_OUTOF_MEMORY));
                       return FALSE;
                   }
                }
                bAddLogToSQL = TRUE;
                bRequiredToCheckLogName = FALSE; // as log names are taken
                                                 // from target system so 
                                                 // no need to check log names.
                dNoOfLogNames = DynArrayGetCount( m_arrLogNames );
                break;
            }
            catch(_com_error & error)
            {
               PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
                if(error.ErrorMessage ()!=NULL)
                    ShowMessage(stderr,error.ErrorMessage ());
                else
                    ShowMessage(stderr,GetResString(IDS_COM_ERROR));
                return FALSE;
            }

        }
    }

    if(bAddLogToSQL==TRUE)
    {
        for (dwIndx=0;dwIndx<dNoOfLogNames;dwIndx++)
        {
            if(m_arrLogNames!=NULL)
            {
                lstrcpy(szLogName,DynArrayItemAsString(m_arrLogNames,dwIndx));
            }
            else
            {
                PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
                ShowMessage(stderr,GetResString(IDS_OUTOF_MEMORY));
                return FALSE;
            }
           if(bRequiredToCheckLogName?CheckLogName(szLogName,m_pWbemServices):1)
            {
              if((dwIndx==0))
              {
                if(dNoOfLogNames!=1)
                {
                  lstrcat((m_pszWMIQueryString),
                           L" AND (targetinstance.LogFile =\"");
                  bBracket = TRUE; 
                }
                else
                {
                   lstrcat((m_pszWMIQueryString),
                            L" AND targetinstance.LogFile =\"");
                }
              }
              else
              {
                lstrcat((m_pszWMIQueryString),
                        L" OR targetinstance.LogFile =\"");
              }
             lstrcat((m_pszWMIQueryString),szLogName);
             lstrcat((m_pszWMIQueryString),L"\"");
             if(dwIndx==(dNoOfLogNames-1)&&(bBracket==TRUE))
             {
                lstrcat((m_pszWMIQueryString),L")");
             }
            }
            else 
            {
                // Show Log name doesn't exit.
                 lstrcpy(szMsgFormat,GetResString(IDS_LOG_NOT_EXISTS));
                 FORMAT_STRING(szMsgString,szMsgFormat,szLogName);
                 // Message shown on screen will be...
                 // FAILURE: "Log Name" Log not exists on system 
                 PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
                 ShowMessage(stderr,szMsgString);
                 return FALSE;
            }
        }
    }

    if(lstrlen(m_pszType)>0)// Updates Query string only if Event Type given
    {
        // In help -t can except "SUCCESSAUDIT" and "FAILUREAUDIT"
        // but this string directly cannot be appended to WQL as valid wmi
        // string for these two are "audit success" and "audit failure"
        // respectively
        if(lstrcmpi(m_pszType,GetResString(IDS_FAILURE_AUDIT))==0)
        {
            lstrcpy(m_pszType,GetResString(IDS_AUDIT_FAILURE));
        }
        else if(lstrcmpi(m_pszType,GetResString(IDS_SUCCESS_AUDIT))==0)
        {
               lstrcpy(m_pszType,GetResString(IDS_AUDIT_SUCCESS));
        }

        lstrcat((m_pszWMIQueryString),L" AND targetinstance.Type =\"");
        lstrcat((m_pszWMIQueryString),(m_pszType));
        lstrcat((m_pszWMIQueryString),L"\"");
    }
    if(lstrlen(m_pszSource)>0)// Updates Query string only if Event Source  
                              // given
    {
       lstrcat((m_pszWMIQueryString),L" AND targetinstance.SourceName =\"");
       lstrcat((m_pszWMIQueryString),(m_pszSource));
       lstrcat((m_pszWMIQueryString),L"\"");
    }
   
    if(m_dwID>0)
    {    
        TCHAR szID[15];
        _itot(m_dwID,szID,10);
        lstrcat(m_pszWMIQueryString,L" AND targetinstance.EventCode = ");
        lstrcat(m_pszWMIQueryString,szID);
    }
    return TRUE;
}
/*****************************************************************************

Routine Description:
     This function Will return all available log available in system
     
Arguments:
	[out] pszLogName      : Will have the NT Event Log names .
Return Value:

      TRUE - if Log name returned
      FALSE - if no log name
   
*****************************************************************************/

BOOL
CETCreate::GetLogName(PTCHAR pszLogName,
                      IEnumWbemClassObject *pEnumWin32_NTEventLogFile)
{
    HRESULT hr = 0;
    BOOL bReturn = FALSE;
    try
    {
        IWbemClassObject *pObj = NULL;     
        VARIANT vVariant;// variable used to get/set values from/to 
                        // COM functions
        ULONG uReturned = 0;
        TCHAR szTempLogName[MAX_RES_STRING];
        hr = pEnumWin32_NTEventLogFile->Next(0,1,&pObj,&uReturned);
        ON_ERROR_THROW_EXCEPTION(hr);
        if(uReturned == 0)
        {
            SAFE_RELEASE_INTERFACE(pObj);
            return FALSE;
        }
        VariantInit(&vVariant);
        SAFE_RELEASE_BSTR(bstrTemp);
        bstrTemp = SysAllocString(L"LogfileName");
        hr = pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
        SAFE_RELEASE_BSTR(bstrTemp);
        ON_ERROR_THROW_EXCEPTION(hr);
        if(GetCompatibleStringFromUnicode(V_BSTR(&vVariant),
                               szTempLogName,
                               MAX_RES_STRING)==NULL)
        {
            SAFE_RELEASE_INTERFACE(pObj);
            return FALSE;
        }
        hr = VariantClear(&vVariant);
        ON_ERROR_THROW_EXCEPTION(hr);
        lstrcpy(pszLogName,szTempLogName);
        bReturn = TRUE;

    }
    catch(_com_error & error)
    {
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        if(error.ErrorMessage ()!=NULL)
            ShowMessage(stderr,error.ErrorMessage ());
        else
            ShowMessage(stderr,GetResString(IDS_COM_ERROR));

        bReturn = FALSE;
    }
    SAFE_RELEASE_BSTR(bstrTemp);
    return bReturn;
}
/******************************************************************************

Routine Description:
     This function Will return whether log name given at commandline is a valid 
     log name or not. It chekcs the log name with WMI
Arguments:
     None

Return Value:

      TRUE - if Successfully Log name founds in WMI
      FALSE - if ERROR
   
******************************************************************************/

BOOL
CETCreate::CheckLogName(PTCHAR pszLogName,IWbemServices *pNamespace)
{
   // Local Variables
    IEnumWbemClassObject* pEnumWin32_NTEventLogFile = NULL;   
    HRESULT hr = 0;
    BOOL bReturn = FALSE;
    BSTR bstrTemp = NULL;
    try
    {
        SAFE_RELEASE_BSTR(bstrTemp);
        bstrTemp = SysAllocString(CLS_WIN32_NT_EVENT_LOGFILE);
        hr = pNamespace->CreateInstanceEnum(bstrTemp,
                                            WBEM_FLAG_SHALLOW,
                                            NULL,
                                            &pEnumWin32_NTEventLogFile);

        // set the security at the interface level also
         hr = SetInterfaceSecurity(pEnumWin32_NTEventLogFile, m_pAuthIdentity);

        ON_ERROR_THROW_EXCEPTION(hr);
        pEnumWin32_NTEventLogFile->Reset();
        
        while(1)
        {
            IWbemClassObject *pObj = NULL;     
            VARIANT vVariant;// variable used to get/set values from/to 
                            // COM functions
            ULONG uReturned = 0;
            TCHAR szTempLogName[MAX_RES_STRING];
            hr = pEnumWin32_NTEventLogFile->Next(0,1,&pObj,&uReturned);
            ON_ERROR_THROW_EXCEPTION(hr);
            if(uReturned == 0)
            {
                SAFE_RELEASE_INTERFACE(pObj);
                bReturn = FALSE;
                break;
            }
            VariantInit(&vVariant);// clear variant, containts not used now
            SAFE_RELEASE_BSTR(bstrTemp);// string will be no loger be used
            bstrTemp = SysAllocString(L"LogfileName");
            hr = pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
            SAFE_RELEASE_BSTR(bstrTemp);
            if(GetCompatibleStringFromUnicode(V_BSTR(&vVariant),
                                   szTempLogName,
                                   MAX_RES_STRING)==NULL)
            {
                SAFE_RELEASE_INTERFACE(pObj);
                bReturn = FALSE;
                break;
            }
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
            if(lstrcmpi(szTempLogName,pszLogName)==0) // Means log name 
                                                      //  found in WMI
            {
                SAFE_RELEASE_INTERFACE(pObj);
                bReturn = TRUE;
                break;
            }
         }
    }
    catch(_com_error & error)
    {
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        if(error.ErrorMessage ()!=NULL)
            ShowMessage(stderr,error.ErrorMessage ());
        else
            ShowMessage(stderr,GetResString(IDS_COM_ERROR));
        bReturn = FALSE;
    }
    SAFE_RELEASE_BSTR(bstrTemp);
    SAFE_RELEASE_INTERFACE(pEnumWin32_NTEventLogFile);
    return bReturn;
}
/******************************************************************************

Routine Description:
     This function will check/set values for rp and ru. 
Arguments:
     None

Return Value:
    none
    
******************************************************************************/

void CETCreate::CheckRpRu(void)
{
   TCHAR szTemp[MAX_RES_STRING]; // To Show Messages
   TCHAR szTemp1[MAX_RES_STRING];// To Show Messages
   TCHAR szWarnPassWord[MAX_RES_STRING];
   wsprintf(szWarnPassWord,GetResString(IDS_WARNING_PASSWORD),NTAUTHORITY_USER);
   // Check if run as username is "NT AUTHORITY\SYSTEM" OR "SYSTEM" Then
   // make this as BLANK (NULL_STRING) and do not ask for password, any how
   if((lstrcmpi(m_pszRunAsUserName,NTAUTHORITY_USER) == 0) ||
      (lstrcmpi(m_pszRunAsUserName,SYSTEM_USER) == 0 ))
    {
      
      lstrcpy(m_pszRunAsUserName,NULL_STRING); // make string blank
      lstrcpy(m_pszRunAsUserPassword,NULL_STRING); // make string blank
	  if(cmdOptions[ ID_C_RP ].dwActuals ==1)
	     DISPLAY_MESSAGE(stderr,szWarnPassWord);
      return;
    }
   if((cmdOptions[ ID_C_RP ].dwActuals ==1) &&
      (lstrcmpi(m_pszRunAsUserPassword,_T("*"))==0)&&(lstrlen(m_pszRunAsUserName)!=0))
    {
           lstrcpy(szTemp,GetResString(IDS_ASK_PASSWORD));
           wsprintf(szTemp1,szTemp,m_pszRunAsUserName);
    	   DISPLAY_MESSAGE(stderr,szTemp1);
           GetPassword(m_pszRunAsUserPassword,MAX_PASSWORD_LENGTH);
			if(lstrlen(m_pszRunAsUserPassword) == 0)
				DISPLAY_MESSAGE(stderr,GetResString(IDS_WARN_NULL_PASSWORD));

           return;
    }
   else
   {
		if((lstrlen(m_pszRunAsUserPassword) == 0) && (lstrlen(m_pszRunAsUserName)!=0))
			DISPLAY_MESSAGE(stderr,GetResString(IDS_WARN_NULL_PASSWORD));

   }

   if(m_bLocalSystem==TRUE)
    {
       
	   if((lstrlen(m_pszRunAsUserName)==0) && (cmdOptions[ ID_C_RP ].dwActuals == 1))
        {
           DISPLAY_MESSAGE(stderr,szWarnPassWord);
           return;
        }
       else if((lstrlen(m_pszRunAsUserName)!=0) && ((cmdOptions[ ID_C_RP ].dwActuals ==0)))
        {
           lstrcpy(szTemp,GetResString(IDS_ASK_PASSWORD));
           wsprintf(szTemp1,szTemp,m_pszRunAsUserName);
    	   DISPLAY_MESSAGE(stderr,szTemp1);
           GetPassword(m_pszRunAsUserPassword,MAX_PASSWORD_LENGTH);
			if(lstrlen(m_pszRunAsUserPassword) == 0)
				DISPLAY_MESSAGE(stderr,GetResString(IDS_WARN_NULL_PASSWORD));

           return;
        }
    }
    else // remote system
    {
		if((lstrlen(m_pszRunAsUserName)==0)&&((cmdOptions[ ID_C_RP ].dwActuals ==1)))
        {
            DISPLAY_MESSAGE(stderr,szWarnPassWord);
            return;
        }
        if(lstrlen(m_pszRunAsUserName)==0)
			return;

		if (lstrlen(m_pszUserName)!=0)
       {
           if((lstrcmpi(m_pszUserName,m_pszRunAsUserName)==0))
              
           {
              if(cmdOptions[ ID_C_RP ].dwActuals ==0)
               {
                  // Username and runasusername are same so password are same
                lstrcpy(m_pszRunAsUserPassword,m_pszPassword);
               }
           }
           else // Username and runasusername are not same
           {
              if(cmdOptions[ ID_C_RP ].dwActuals ==0)
               {
                   lstrcpy(szTemp,GetResString(IDS_ASK_PASSWORD));
                   wsprintf(szTemp1,szTemp,m_pszRunAsUserName);
                   DISPLAY_MESSAGE(stderr,szTemp1);
                   GetPassword(m_pszRunAsUserPassword,MAX_PASSWORD_LENGTH);
					if(lstrlen(m_pszRunAsUserPassword) == 0)
    					DISPLAY_MESSAGE(stderr,GetResString(IDS_WARN_NULL_PASSWORD));
                   return;
               }
           }
       }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etcreate.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name:

    ETCreate.h

Abstract:

  This module  contanins function definations required by ETCreate.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


*****************************************************************************/ 

#ifndef _ETCREATE_H
#define _ETCREATE_H



#define ID_C_CREATE        0
#define ID_C_SERVER        1
#define ID_C_USERNAME      2
#define ID_C_PASSWORD      3
#define ID_C_TRIGGERNAME   4
#define ID_C_LOGNAME       5
#define ID_C_ID            6
#define ID_C_TYPE          7
#define ID_C_SOURCE        8
#define ID_C_DESCRIPTION   9
#define ID_C_TASK          10
#define ID_C_RU            11 
#define ID_C_RP            12  

#define MAX_COMMANDLINE_C_OPTION 13  // Maximum Command Line  List

class CETCreate  
{
public:
	CETCreate();
    CETCreate(LONG lMinMemoryReq,BOOL bNeedPassword);
	virtual ~CETCreate();
public:
	BOOL ExecuteCreate();
	void ProcessOption(DWORD argc, LPCTSTR argv[]);
	void Initialize();

private:
	LPTSTR m_pszWMIQueryString;
	BOOL CheckLogName(PTCHAR pszLogName,IWbemServices *pNamespace);
	BOOL GetLogName(PTCHAR pszLogName,
                    IEnumWbemClassObject *pEnumWin32_NTEventLogFile);
	BOOL ConstructWMIQueryString();
    void CheckRpRu(void);
    CONSOLE_SCREEN_BUFFER_INFO m_ScreenBufferInfo; 
    HANDLE  m_hStdHandle;
    LPTSTR  m_pszServerName;
	LPTSTR  m_pszUserName;
	LPTSTR  m_pszPassword;
    LPTSTR  m_pszTriggerName;
    LPTSTR  m_pszRunAsUserName;
    LPTSTR  m_pszRunAsUserPassword;
	TARRAY  m_arrLogNames;
    DWORD   m_dwID;
    LPTSTR  m_pszType;
    LPTSTR  m_pszSource;
    LPTSTR  m_pszDescription;
    LPTSTR  m_pszTaskName;
	BOOL    m_bNeedPassword;
    BOOL    m_bCreate;
    BOOL    m_bLocalSystem;
    BOOL    m_bIsCOMInitialize;
    BSTR    bstrTemp;
    // WMI / COM interfaces
	IWbemLocator*           m_pWbemLocator;
	IWbemServices*          m_pWbemServices;
	IEnumWbemClassObject*   m_pEnumObjects;
    IWbemClassObject*       m_pClass; 
    IWbemClassObject*       m_pOutInst;
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst; 
    IEnumWbemClassObject*   m_pEnumWin32_NTEventLogFile;


    // WMI connectivity
	COAUTHIDENTITY* m_pAuthIdentity;
	
	void InitCOM();
	void CheckAndSetMemoryAllocation(LPTSTR pszStr,LONG lSize);
    void PrepareCMDStruct();
	LONG m_lMinMemoryReq;
    // Array to store command line options
    TCMDPARSER cmdOptions[MAX_COMMANDLINE_C_OPTION]; 
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etcommon.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name:

    ETCommon.h 

Abstract:
    This module contains all necessary header files required by 
    this project.


Author:
     Akhil Gokhale 03-Oct.-2000 

Revision History:


******************************************************************************/ 

#ifndef _ETCOMMON_H
#define _ETCOMMON_H
//
// general purpose macros
//
#define    ERROR_EXIT           2500

#define    OPTION_HELP         _T("?")
#define    OPTION_CREATE       _T("CREATE")
#define    OPTION_DELETE       _T("DELETE")
#define    OPTION_QUERY        _T("QUERY")
#define    OPTION_SERVER       _T("s")
#define    OPTION_USERNAME     _T("u")
#define    OPTION_PASSWORD     _T("p")
#define    OPTION_TRIGGERNAME  _T("tr")
#define    OPTION_LOGNAME      _T("l")
#define    OPTION_EID           _T("eid")
#define    OPTION_TYPE         _T("t")
#define    OPTION_SOURCE       _T("so")
#define    OPTION_DESCRIPTION  _T("d")
#define    OPTION_FORMAT       _T("fo")
#define    OPTION_NOHEADER     _T("nh")
#define    OPTION_VERBOSE      _T("v")
#define    OPTION_TASK         _T("tk")
#define    OPTION_TID          _T("tid")
#define    OPTION_RU           _T("ru")
#define    OPTION_RP           _T("rp")

HRESULT PropertyGet1( IWbemClassObject* pWmiObject, 
                      LPCTSTR szProperty, 
                      DWORD dwType, LPVOID pValue, DWORD dwSize );

void PrintProgressMsg(HANDLE hOutput,LPCWSTR pwszMsg,const CONSOLE_SCREEN_BUFFER_INFO& csbi);


extern DWORD  g_dwOptionFlag;
// CLS stands for class
#define CLS_TRIGGER_EVENT_CONSUMER    L"CmdTriggerConsumer"
#define CLS_FILTER_TO_CONSUMERBINDING L"__FilterToConsumerBinding"
#define CLS_WIN32_NT_EVENT_LOGFILE    L"Win32_NTEventLogFile"
#define CLS_EVENT_FILTER              L"__EventFilter"
// FN stands for Function name
#define FN_CREATE_ETRIGGER L"CreateETrigger"
#define FN_DELETE_ETRIGGER L"DeleteETrigger"
#define FN_QUERY_ETRIGGER  L"QueryETrigger"


// FPR stands for function-parameter
#define FPR_TRIGGER_NAME         L"TriggerName" 
#define FPR_TRIGGER_DESC         L"TriggerDesc"
#define FPR_TRIGGER_QUERY        L"TriggerQuery"
#define FPR_TRIGGER_ACTION       L"TriggerAction"
#define FPR_TRIGGER_ID           L"TriggerID"
#define FPR_RETURN_VALUE         L"ReturnValue"
#define FPR_RUN_AS_USER          L"RunAsUser"
#define FPR_RUN_AS_USER_PASSWORD L"RunAsPwd"
#define FPR_TASK_SCHEDULER       L"ScheduledTaskName"


#define QUERY_STRING   L"select * from __instancecreationevent where targetinstance isa \"win32_ntlogevent\""

#define ERROR_INVALID_SYNTAX 1
#define RELEASE_BSTR(bstrVal) \
	if (bstrVal!=NULL) \
	{	\
		SysFreeString(bstrVal); \
		bstrVal = NULL; \
	}\
    1

#define RELEASE_MEMORY( block )	\
	if ( (block) != NULL )	\
	{	\
		delete (block);	\
		(block) = NULL;	\
	}	\
	1

#define RELEASE_MEMORY_EX( block )	\
	if ( (block) != NULL )	\
	{	\
		delete [] (block);	\
		(block) = NULL;	\
	}	\
	1

#define DESTROY_ARRAY( array )	\
	if ( (array) != NULL )	\
	{	\
		DestroyDynamicArray( &(array) );	\
		(array) = NULL;	\
	}	\
	1
#define SAFE_RELEASE_BSTR(bstr)\
    if(bstr != NULL)\
    {\
        SysFreeString(bstr);\
		bstr = NULL;\
    }

#define ON_ERROR_THROW_EXCEPTION( hr )\
    if(FAILED(hr))\
    {\
      WMISaveError(hr);\
     _com_issue_error(hr);\
    }   

#define SAFE_RELEASE_INTERFACE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etdelete.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ETDelete.CPP 
 
Abstract:

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -delete parameter.
  This will delete an Event Trigger From local / remote System
  


Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:


******************************************************************************/ 
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETDelete.h"
#include "WMI.h"
//***************************************************************************
// Routine Description:
//     Class constructor    
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETDelete::CETDelete()
{
    m_bDelete           = FALSE;
    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_arrID             = NULL;
    m_bIsCOMInitialize  = FALSE;
    m_lMinMemoryReq     = 0;
    m_bNeedPassword     = FALSE;
    m_pszTemp           = NULL;

    m_pWbemLocator    = NULL;
    m_pWbemServices   = NULL;
    m_pEnumObjects    = NULL;
    m_pAuthIdentity   = NULL;

    m_pClass = NULL;
    m_pInClass = NULL;
    m_pInInst = NULL;
    m_pOutInst = NULL;
    m_hStdHandle          = NULL;


}
//***************************************************************************
// Routine Description:
//        Class constructor
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETDelete::CETDelete(LONG lMinMemoryReq,BOOL bNeedPassword)
{
    m_pszServerName     = NULL;
    m_pszUserName       = NULL;
    m_pszPassword       = NULL;
    m_arrID             = NULL;
    m_bIsCOMInitialize  = FALSE;
    m_lMinMemoryReq     = lMinMemoryReq;
    m_bNeedPassword     = bNeedPassword;
    m_pszTemp           = NULL;

    m_pWbemLocator    = NULL;
    m_pWbemServices   = NULL;
    m_pEnumObjects    = NULL;
    m_pAuthIdentity   = NULL;

    m_pClass = NULL;
    m_pInClass = NULL;
    m_pInInst = NULL;
    m_pOutInst = NULL;
    m_hStdHandle          = NULL;
}
//***************************************************************************
// Routine Description:
//        Class destructor
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETDelete::~CETDelete()
{
    RELEASE_MEMORY_EX(m_pszServerName);
    RELEASE_MEMORY_EX(m_pszUserName);
    RELEASE_MEMORY_EX(m_pszPassword);
    RELEASE_MEMORY_EX(m_pszTemp);
    DESTROY_ARRAY(m_arrID);

    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pEnumObjects);

    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pOutInst);

    // Uninitialize COM only when it is initialized.
    if(m_bIsCOMInitialize == TRUE)
    {
        CoUninitialize();
    }

}
//***************************************************************************
// Routine Description:
//        This function allocates and initializes variables.
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

void
CETDelete::Initialize()
{
    // local variable
    LONG lTemp = 0;
    // if at all any occurs, we know that is 'coz of the 
    // failure in memory allocation ... so set the error
    SetLastError( E_OUTOFMEMORY );
    SaveLastError();

    // allocate memory at least MAX_COMPUTER_NAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_COMPUTERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_COMPUTERNAME_LENGTH+1;
    m_pszServerName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszServerName,lTemp);

    // allocate memory at least MAX_USERNAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_USERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_USERNAME_LENGTH+1;
    m_pszUserName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszUserName,lTemp);

        
    // allocate memory at least MAX_PASSWORD_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_PASSWORD_LENGTH)?
             m_lMinMemoryReq:MAX_PASSWORD_LENGTH+1;
    m_pszPassword = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszPassword,lTemp);
    
    m_pszTemp = new TCHAR[MAX_RES_STRING+1]; 
    CheckAndSetMemoryAllocation (m_pszTemp,MAX_RES_STRING);

    m_arrID = CreateDynamicArray();
    if(m_arrID == NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( NULL_STRING );            // clear the reason
    return;

}
// ***************************************************************************
// Routine Description:
//        Function will allocate memory to a string
//          
// Arguments:
//        [in][out] pszStr   : String variable to which memory to be  allocated
//      [in]               : Number of bytes to be allocated.
// Return Value:
//        NONE
// 
//***************************************************************************
void 
CETDelete::CheckAndSetMemoryAllocation(LPTSTR pszStr, LONG lSize)
{
    if(pszStr == NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // init to ZERO's
    ZeroMemory( pszStr, lSize * sizeof( TCHAR ) );
    return;
}
// ***************************************************************************
// Routine Description:
//        This function will prepare column structure for DoParseParam Function.
//          
// Arguments:
//       none
// Return Value:
//       none
// ***************************************************************************

void
CETDelete::PrepareCMDStruct()
{
    // Filling cmdOptions structure 

   // -delete
    lstrcpy(cmdOptions[ ID_D_DELETE ].szOption,OPTION_DELETE);
    cmdOptions[ ID_D_DELETE ].dwFlags = CP_MAIN_OPTION;
    cmdOptions[ ID_D_DELETE ].dwCount = 1;
    cmdOptions[ ID_D_DELETE ].dwActuals = 0;
    cmdOptions[ ID_D_DELETE ].pValue    = &m_bDelete;
    lstrcpy(cmdOptions[ ID_D_DELETE ].szValues,NULL_STRING);
    cmdOptions[ ID_D_DELETE ].pFunction = NULL;
    cmdOptions[ ID_D_DELETE ].pFunctionData = NULL;
    cmdOptions[ ID_D_DELETE ].pFunctionData = NULL;

    // -s (servername)
    lstrcpy(cmdOptions[ ID_D_SERVER ].szOption,OPTION_SERVER);
    cmdOptions[ ID_D_SERVER ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_D_SERVER ].dwCount = 1;
    cmdOptions[ ID_D_SERVER ].dwActuals = 0;
    cmdOptions[ ID_D_SERVER ].pValue    = m_pszServerName;
    lstrcpy(cmdOptions[ ID_D_SERVER ].szValues,NULL_STRING);
    cmdOptions[ ID_D_SERVER ].pFunction = NULL;
    cmdOptions[ ID_D_SERVER ].pFunctionData = NULL;
    
    // -u (username)
    lstrcpy(cmdOptions[ ID_D_USERNAME ].szOption,OPTION_USERNAME);
    cmdOptions[ ID_D_USERNAME ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_D_USERNAME ].dwCount = 1;
    cmdOptions[ ID_D_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_D_USERNAME ].pValue    = m_pszUserName;
    lstrcpy(cmdOptions[ ID_D_USERNAME ].szValues,NULL_STRING);
    cmdOptions[ ID_D_USERNAME ].pFunction = NULL;
    cmdOptions[ ID_D_USERNAME ].pFunctionData = NULL;

    // -p (password)
    lstrcpy(cmdOptions[ ID_D_PASSWORD ].szOption,OPTION_PASSWORD);
    cmdOptions[ ID_D_PASSWORD ].dwFlags = CP_TYPE_TEXT|CP_VALUE_OPTIONAL;
    cmdOptions[ ID_D_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_D_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_D_PASSWORD ].pValue    = m_pszPassword;
    lstrcpy(cmdOptions[ ID_D_PASSWORD ].szValues,NULL_STRING);
    cmdOptions[ ID_D_PASSWORD ].pFunction = NULL;
    cmdOptions[ ID_D_PASSWORD ].pFunctionData = NULL;

    //  -tid
    lstrcpy(cmdOptions[ ID_D_ID ].szOption,OPTION_TID);
    cmdOptions[ ID_D_ID ].dwFlags = CP_TYPE_TEXT|CP_MODE_ARRAY|
                                    CP_VALUE_NODUPLICATES|
                                    CP_VALUE_MANDATORY|CP_MANDATORY;
    cmdOptions[ ID_D_ID ].dwCount = 0;
    cmdOptions[ ID_D_ID ].dwActuals = 0;
    cmdOptions[ ID_D_ID ].pValue    = &m_arrID;
    lstrcpy(cmdOptions[ ID_D_ID ].szValues,NULL_STRING);
    cmdOptions[ ID_D_ID ].pFunction = NULL;
    cmdOptions[ ID_D_ID ].pFunctionData = NULL;
}

// ***************************************************************************
// Routine Description:
//        This function will process/parce the command line options.
//          
// Arguments:
//        [ in ] argc        : argument(s) count specified at the command prompt
//        [ in ] argv        : argument(s) specified at the command prompt
//  
// Return Value:
//       none
// ***************************************************************************
void 
CETDelete::ProcessOption(DWORD argc, LPCTSTR argv[])
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;

    PrepareCMDStruct();

	// init the password variable with '*'
	if ( m_pszPassword != NULL )
		lstrcpy( m_pszPassword, _T( "*" ) );

    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam( argc, argv, MAX_COMMANDLINE_D_OPTION, cmdOptions);

    if(bReturn==FALSE)
        throw CShowError(MK_E_SYNTAX);
    // empty Server is not valid
    szTempString = m_pszServerName;
    szTempString.TrimRight();
    lstrcpy(m_pszServerName,(LPCWSTR)szTempString);
	if ( (cmdOptions[ID_D_SERVER].dwActuals != 0) && 
        (lstrlen( m_pszServerName) == 0 ))
	{
        throw CShowError(IDS_ERROR_SERVERNAME_EMPTY);
	}

    // "-u" should not be specified without "-s"
    if ( cmdOptions[ ID_D_SERVER ].dwActuals == 0 &&
         cmdOptions[ ID_D_USERNAME ].dwActuals != 0 )
    {
        throw CShowError(IDS_ERROR_USERNAME_BUT_NOMACHINE);
    }
    // empty user is not valid
    szTempString = m_pszUserName;
    szTempString.TrimRight();
    lstrcpy(m_pszUserName,(LPCWSTR)szTempString);
	if ( (cmdOptions[ID_D_USERNAME].dwActuals != 0) && 
        (lstrlen( m_pszUserName) == 0 ))
	{
        throw CShowError(IDS_ERROR_USERNAME_EMPTY);
	}
    // "-p" should not be specified without -u 
    if ( (cmdOptions[ID_D_USERNAME].dwActuals  == 0) && 
          (cmdOptions[ID_D_PASSWORD].dwActuals != 0 ))
	{
		// invalid syntax
        throw CShowError(IDS_USERNAME_REQUIRED);
	}

    // check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept
    // password the user will be prompter for the password only if establish 
    // connection  is failed without the credentials information
	if ( cmdOptions[ ID_D_PASSWORD ].dwActuals != 0 && 
		 m_pszPassword != NULL && lstrcmp( m_pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( cmdOptions[ ID_D_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ ID_D_SERVER ].dwActuals != 0 || cmdOptions[ ID_D_USERNAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		if ( m_pszPassword != NULL )
		{
			lstrcpy( m_pszPassword, _T( "" ) );
		}
	}

    if(cmdOptions[ ID_D_ID ].dwActuals==0)
    {
        throw CShowError(IDS_ID_REQUIRED);
    }
}
// ***************************************************************************
// Routine Description:
//        This routine will delete EventTriggers from WMI.
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

BOOL 
CETDelete::ExecuteDelete()
{
    BOOL bResult = FALSE; // Stores functins return status.
    LPTSTR lpTemp = NULL;
    LONG lTriggerID = 0;
    DWORD dNoOfIds=0; // Total Number of Event Trigger Ids...
    DWORD dwIndx = 0;
    BOOL bIsValidCommandLine = TRUE;
    BOOL bIsWildcard = FALSE;
    BOOL bRet = TRUE;
    HRESULT hr = S_OK; // used to reecive result form COM functions
    VARIANT vVariant;// variable used to get/set values from/to COM functions
    BSTR bstrTemp = NULL;
    TCHAR szEventTriggerName[MAX_RES_STRING];
    TCHAR szTaskSheduler[MAX_RES_STRING];
    TCHAR szMsgString[MAX_RES_STRING]; // Stores Message String
    TCHAR szMsgFormat[MAX_RES_STRING]; // Stores Message String
    DWORD lTemp    = 0;
    BOOL bIsAtLeastOne = FALSE;  
    try
    {
        // Analyze the default argument for ID 

        dNoOfIds = DynArrayGetCount( m_arrID  );
        for(dwIndx = 0;dwIndx<dNoOfIds;dwIndx++)
        {
             lstrcpy(m_pszTemp,
                     DynArrayItemAsString(m_arrID,dwIndx));
             if(lstrcmp(m_pszTemp,ASTERIX)==0)
             {
                // Wildcard "*" cannot be clubed with other ids
                 bIsWildcard = TRUE;
                 if(dNoOfIds > 1)
                 {
                     bIsValidCommandLine = FALSE;
                     break;
                 }
             }
             else if(IsNumeric(m_pszTemp,10,FALSE)==FALSE)
             {
                // Other than "*" are not excepted 
                 throw CShowError(IDS_ID_NON_NUMERIC);
             }
             else if((AsLong(m_pszTemp,10)==0)||
                     (AsLong(m_pszTemp,10)>ID_MAX_RANGE))
             {
                  throw CShowError(IDS_INVALID_ID);
             }
        }
        m_hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
        if(m_hStdHandle!=NULL)
        {
            GetConsoleScreenBufferInfo(m_hStdHandle,&m_ScreenBufferInfo);
        }
        InitializeCom(&m_pWbemLocator);
        m_bIsCOMInitialize = TRUE;

        ////////////////////////////////////////////////////
        // Connect Server.....
        {
            CHString szTempUser = m_pszUserName;
            CHString szTempPassword = m_pszPassword;
            BOOL bLocalSystem = TRUE;
            bResult = ConnectWmiEx( m_pWbemLocator, 
                                    &m_pWbemServices, 
                                    m_pszServerName,
                                    szTempUser, 
                                    szTempPassword,
                                    &m_pAuthIdentity, 
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2, 
                                    &bLocalSystem);
                                    
            if(bResult == FALSE)
            {
                TCHAR szErrorMsg[MAX_RES_STRING+1];
                DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR,
                                  GetReason());
                return FALSE;
            }
            // check the remote system version and its compatiblity
            if ( bLocalSystem == FALSE )
            {
                DWORD dwVersion = 0;
                dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
                if ( dwVersion <= 5000 )// to block win2k versions
                {
                    TCHAR szErrorMsg[MAX_RES_STRING+1];
                    SetReason( ERROR_OS_INCOMPATIBLE );
                    DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                                      GetReason());
                    return FALSE;
                }
            }

            // check the local credentials and if need display warning
            if ( bLocalSystem && (lstrlen(m_pszUserName)!=0) )
            {
                CHString str;
                WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
                str.Format( L"%s %s", TAG_WARNING, GetReason() );
                ShowMessage( stdout, str );
            }

        }
        ///////////////////////////////////////////////////
        // Show wait message
    m_hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
    if(m_hStdHandle!=NULL)
    {
        GetConsoleScreenBufferInfo(m_hStdHandle,&m_ScreenBufferInfo);
    }
    PrintProgressMsg(m_hStdHandle,GetResString(IDS_MSG_EVTRIG_D),m_ScreenBufferInfo);
    // retrieves  TriggerEventConsumer class 
    bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
    hr = m_pWbemServices->GetObject(bstrTemp,
                               0, NULL, &m_pClass, NULL);
    RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);
    
    // Gets  information about the "DeleteETrigger" method of
    // "TriggerEventConsumer" class
    bstrTemp = SysAllocString(FN_DELETE_ETRIGGER);
    hr = m_pClass->GetMethod(bstrTemp,
                            0, &m_pInClass, NULL); 
    RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);

   // create a new instance of a class "TriggerEventConsumer ". 
    hr = m_pInClass->SpawnInstance(0, &m_pInInst);
    ON_ERROR_THROW_EXCEPTION(hr);

    //Following method will creates an enumerator that returns the instances of 
    // a specified TriggerEventConsumer class 
    bstrTemp = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
    hr = m_pWbemServices->CreateInstanceEnum(bstrTemp,
                                        WBEM_FLAG_SHALLOW,
                                        NULL,
                                        &m_pEnumObjects);
    RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);

    // set the security at the interface level also
        hr = SetInterfaceSecurity( m_pEnumObjects, m_pAuthIdentity );
     ON_ERROR_THROW_EXCEPTION(hr);

     if(bIsWildcard == TRUE) // means * is choosen 
      {
          // instance of NTEventLogConsumer is cretated and now check 
        // for available TriggerID
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        while(GiveTriggerID(&lTriggerID,szEventTriggerName)==TRUE)
        {

            LONG  lTemp = -1;
            VariantInit(&vVariant);
            // Set the TriggerName property .
            hr = PropertyPut(m_pInInst,FPR_TRIGGER_NAME,_bstr_t(szEventTriggerName));
            ON_ERROR_THROW_EXCEPTION(hr);


            // All The required properties sets, so 
            // executes DeleteETrigger method to delete eventtrigger
            hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                             _bstr_t(FN_DELETE_ETRIGGER), 
                                             0, NULL, m_pInInst,&m_pOutInst,NULL);
            ON_ERROR_THROW_EXCEPTION(hr);
            // Get Return Value from DeleteETrigger function
            DWORD dwTemp;
            if(PropertyGet(m_pOutInst,FPR_RETURN_VALUE,dwTemp)==FALSE)
            {

                return FALSE;
            }

            lTemp = (LONG)dwTemp;
            if(lTemp==0) // Means deletion is successful......
            {
                lstrcpy(szMsgFormat,GetResString(IDS_DELETE_SUCCESS));
                FORMAT_STRING2(szMsgString,szMsgFormat,_X(szEventTriggerName),
                               lTriggerID);
                ShowMessage(stdout,szMsgString);
                bIsAtLeastOne = TRUE;
            }
            else if ((lTemp == 1))// Provider sends this if if failed to 
                                      // delete eventrigger of given ID
                                      // as id no longer exits....
            {
                 lstrcpy(szMsgFormat,GetResString(IDS_DELETE_ERROR));
                  FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                 // Message shown on screen will be...
                 // Info: "EventID" is not a Valid Event ID
                 ShowMessage(stderr,szMsgString);
             }
             else if (lTemp==2) // Means unable to delete trigger due to 
                                // some problem like someone renamed 
                                // Schedule task name etc. 
             {
                 lstrcpy(szMsgFormat,GetResString(IDS_UNABLE_DELETE));
                  FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                 // Message shown on screen will be...
                 // Info: Unable to delete event trigger id "EventID". 
                 ShowMessage(stderr,szMsgString);
                 bIsAtLeastOne = TRUE;
             }
             else if (lTemp == 3)// This error will come only if multiple 
                                // instances are running. This is due to 
                                // sending a non existance Trigger Name
             {
                 continue; // Just ignore this error.
             }
             else
             {
                  ON_ERROR_THROW_EXCEPTION(lTemp);
             }
        } // End of while loop
        if(bIsAtLeastOne==FALSE)
        {
            ShowMessage(stdout,GetResString(IDS_NO_EVENTID));
        }
      } // end of if
      else
      {
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        for(dwIndx=0;dwIndx<dNoOfIds;dwIndx++)
        {
            lTriggerID = AsLong(DynArrayItemAsString(m_arrID,dwIndx),10);
            if(GiveTriggerName(lTriggerID,szEventTriggerName)==TRUE)
            {
                hr = VariantClear(&vVariant);
                ON_ERROR_THROW_EXCEPTION(hr);

                // Set the TriggerName property .
                hr = PropertyPut(m_pInInst,FPR_TRIGGER_NAME,_bstr_t(szEventTriggerName));
                ON_ERROR_THROW_EXCEPTION(hr);

                // All The required properties sets, so 
                // executes DeleteETrigger method to delete eventtrigger

                hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER), 
                                                 _bstr_t(FN_DELETE_ETRIGGER),
                                                 0, NULL, m_pInInst, &m_pOutInst,
                                                 NULL);
                ON_ERROR_THROW_EXCEPTION(hr);
                // Get Return Value from DeleteETrigger function
                DWORD dwTemp;
                if(PropertyGet(m_pOutInst,FPR_RETURN_VALUE,dwTemp)==FALSE)
                {
                    return FALSE;
                }
                lTemp = (LONG)dwTemp;
                 if(lTemp==0) // Means deletion is successful......
                {
                    lstrcpy(szMsgFormat,GetResString(IDS_DELETE_SUCCESS));
                    FORMAT_STRING2(szMsgString,szMsgFormat,_X(szEventTriggerName),
                                   lTriggerID);
                    ShowMessage(stdout,szMsgString);
                }
                else if ((lTemp == 1))// Provider sends this if if failed to 
                                      // delete eventrigger of given ID
                {
                     lstrcpy(szMsgFormat,GetResString(IDS_DELETE_ERROR));
                      FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                     // Message shown on screen will be...
                     // FAILURE: "EventID" is not a Valid Event ID
                     ShowMessage(stderr,szMsgString);
                }
                 else if (lTemp==2) // Means unable to delete trigger due to 
                                    // some problem like someone renamed 
                                    // Schedule task name etc. 
                 {
                     lstrcpy(szMsgFormat,GetResString(IDS_UNABLE_DELETE));
                      FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                     // Message shown on screen will be...
                     // Info: Unable to delete event trigger id "EventID". 
                     ShowMessage(stderr,szMsgString);
                 }
                 else if (lTemp == 3)// This error will come only if multiple 
                                    // instances are running. This is due to 
                                    // sending a non existance Trigger Name
                                    // So for user we are showing invalid id
                 {
                  lstrcpy(szMsgFormat,GetResString(IDS_DELETE_ERROR));
                  FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                 // Message shown on screen will be...
                 // FAILURE: "EventID" is not a Valid Event ID
                  ShowMessage(stderr,szMsgString);
                  continue; // Just ignore this error.
                 }

                else
                {
                   ON_ERROR_THROW_EXCEPTION(lTemp);
                }
  
            } // End if
            else
            {
                  lstrcpy(szMsgFormat,GetResString(IDS_DELETE_ERROR));
                  FORMAT_STRING(szMsgString,szMsgFormat,lTriggerID);
                 // Message shown on screen will be...
                 // FAILURE: "EventID" is not a Valid Event ID
                 ShowMessage(stderr,szMsgString);
            }

        }// End for 
      
      } // End else
    }
    catch(_com_error)
    {
        TCHAR szErrorMsg[MAX_RES_STRING+1];
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        if(hr == 0x80041002)// WMI returns string for this hr value is 
                            // "Not Found." which is not user friendly. So
                            // changing the message text. 
        {
               ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR,
                              GetReason() );
        }
        return FALSE;

    }
    return TRUE;
}
/******************************************************************************

Routine Descripton:

     This function Will return Event Trigger Name for lTriggerID 

Arguments:
        
    [in]  lTriggerID              : Will Have Event Trigger ID
    [out] pszTriggerName         : Will return Event Trigger Name
    [out] pszTaskSheduler         : Will return TaskScheduler
    [in]  m_pEnumObjects: Will have valid pointer value for 
                                   NTEventLogConsumer class

Return Value:

  TRUE - if Successfully Gets  EventTrigger ID and Event Trigger Name
  FALSE - if ERROR
******************************************************************************/

BOOL 
CETDelete::GiveTriggerName(LONG lTriggerID, LPTSTR pszTriggerName)
{
    BOOL bReturn = TRUE; // holds status of return value of this function
    LONG lTriggerID1; // Holds trigger id
    IWbemClassObject *pObj1 = NULL;     
    ULONG uReturned1 = 0;
    HRESULT hRes = S_OK; // used to reecive result form COM functions
    // Resets it as It may be previouly pointing to other than first instance
    m_pEnumObjects->Reset();
    while(1)
    {
        hRes = m_pEnumObjects->Next(0,1,&pObj1,&uReturned1);
   
        if(FAILED(hRes))
        {
            ON_ERROR_THROW_EXCEPTION( hRes );
            break;
        }
        if(uReturned1 == 0)
        {
            SAFE_RELEASE_INTERFACE(pObj1);        
            bReturn = FALSE;
            return bReturn;
    
        }

        // Get Trigger ID
        hRes = PropertyGet1(pObj1,FPR_TRIGGER_ID,0,&lTriggerID1,sizeof(LONG));
        if(FAILED(hRes))
        {
            SAFE_RELEASE_INTERFACE(pObj1);        
            ON_ERROR_THROW_EXCEPTION( hRes );
            bReturn = FALSE;
            return bReturn;
        }

        if(lTriggerID==lTriggerID1)
        {
            
            // Get Trigger Name
            hRes = PropertyGet1(pObj1,FPR_TRIGGER_NAME,0,pszTriggerName,MAX_RES_STRING);
            if(FAILED(hRes))
            {
                SAFE_RELEASE_INTERFACE(pObj1);        
                ON_ERROR_THROW_EXCEPTION( hRes );
                bReturn = FALSE;
                return bReturn;
            }
                bReturn = TRUE;
                break;  
        }
    }
    SAFE_RELEASE_INTERFACE(pObj1);        
    return bReturn;
}
/******************************************************************************

Routine Description:

  This function Will return Trigger Id and Trigger Name of class pointed 
  by IEnumWbemClassObject pointer   

Arguments:

    [out] pTriggerID              : Will return Event Trigger ID
    [out] pszTriggerName          : Will return Event Trigger Name
    [out] pszTaskSheduler         : Will return TaskScheduler
    [in]  m_pEnumObjects: Will have valid pointer value for 
                                   NTEventLogConsumer class


Return Value:
  
     TRUE - if Successfully Gets  EventTrigger ID and Event Trigger Name
     FALSE - if ERROR
******************************************************************************/

BOOL 
CETDelete::GiveTriggerID(LONG *pTriggerID,LPTSTR pszTriggerName)
{
    BOOL bReturn = TRUE; // status of return value of this function
    IWbemClassObject *pObj1 = NULL;     
    TCHAR strTemp[MAX_RES_STRING];
    ULONG uReturned1 = 0;
    DWORD dwTemp = 0;
    HRESULT hRes = m_pEnumObjects->Next(0,1,&pObj1,&uReturned1);
    if(FAILED(hRes))
    {
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }
    if(uReturned1 == 0)
    {
        SAFE_RELEASE_INTERFACE(pObj1);        
        bReturn = FALSE;
        return bReturn;
   
    }
    // Get Trigger ID
    hRes = PropertyGet1(pObj1,FPR_TRIGGER_ID,0,pTriggerID,sizeof(LONG));
    if(FAILED(hRes))
    {
        SAFE_RELEASE_INTERFACE(pObj1);        
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }

    // Get Trigger Name
    hRes = PropertyGet1(pObj1,FPR_TRIGGER_NAME,0,pszTriggerName,MAX_RES_STRING);
    if(FAILED(hRes))
    {
        SAFE_RELEASE_INTERFACE(pObj1);        
        ON_ERROR_THROW_EXCEPTION( hRes );
        bReturn = FALSE;
        return bReturn;
    }
    SAFE_RELEASE_INTERFACE(pObj1);        
    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etquery.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ETQuery.CPP 

Abstract: 

  This module  is intended to have the functionality for EVENTTRIGGERS.EXE
  with -query parameter.
  
  This will Query WMI and shows presently available Event Triggers.

Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:

******************************************************************************/ 
#include "pch.h"
#include "ETCommon.h"
#include "resource.h"
#include "ShowError.h"
#include "ETQuery.h"
#include "WMI.h"
#define   DEFAULT_USER L"NT AUTHORITY\\SYSTEM"
#define   DBL_SLASH L"\\\\";
// Defines local to this file

#define SHOW_WQL_QUERY L"select * from __instancecreationevent where"
#define QUERY_STRING_AND L"select * from __instancecreationevent where \
targetinstance isa \"win32_ntlogevent\" AND"
#define BLANK_LINE L"\n"
// ***************************************************************************
// Routine Description:
//    Class default constructor.    
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETQuery::CETQuery()
{
    // init to defaults
    m_bNeedDisconnect     = FALSE;

    m_pszServerName   = NULL;
    m_pszUserName     = NULL;
    m_pszPassword     = NULL;
    m_pszFormat       = NULL;
    m_bVerbose        = FALSE;
    m_bNoHeader       = FALSE;
    m_pszEventDesc    = NULL;
    m_pszTask         = NULL;


    m_bNeedPassword   = FALSE;
    m_bUsage          = FALSE;
    m_bQuery          = FALSE;

    m_pWbemLocator          = NULL;
    m_pWbemServices         = NULL;
    m_pAuthIdentity         = NULL;
    m_pObj                  = NULL; 
    m_pTriggerEventConsumer = NULL;            
    m_pEventFilter          = NULL;            
    m_arrColData      = NULL;
    m_pszBuffer       = NULL;
    m_pszEventQuery   = NULL;
    m_pszTaskUserName = NULL;
    m_bIsCOMInitialize = FALSE;

    m_hStdHandle        = NULL;

    m_pClass = NULL;
    m_pInClass = NULL;
    m_pInInst = NULL;
    m_pOutInst = NULL;

    m_lHostNameColWidth    = WIDTH_HOSTNAME; 
    m_lTriggerIDColWidth   = WIDTH_TRIGGER_ID; 
    m_lETNameColWidth      = WIDTH_TRIGGER_NAME; 
    m_lTaskColWidth        = WIDTH_TASK;
    m_lQueryColWidth       = WIDTH_EVENT_QUERY;
    m_lDescriptionColWidth = WIDTH_DESCRIPTION;
    m_lWQLColWidth         = 0;
    m_lTaskUserName        = WIDTH_TASK_USERNAME; 
}
// ***************************************************************************
// Routine Description:
//     Class constructor.    
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETQuery::CETQuery(LONG lMinMemoryReq,BOOL bNeedPassword)
{
    // init to defaults
    m_bNeedDisconnect     = FALSE;

    m_pszServerName   = NULL;
    m_pszUserName     = NULL;
    m_pszPassword     = NULL;
    m_pszFormat       = NULL;
    m_bVerbose        = FALSE;
    m_bNoHeader       = FALSE;
    m_pszEventDesc    = NULL;
    m_pszTask         = NULL;
    m_bIsCOMInitialize = FALSE;

    m_hStdHandle        = NULL;

    m_bNeedPassword   = bNeedPassword;
    m_bUsage          = FALSE;
    m_bQuery          = FALSE;
    m_lMinMemoryReq   = lMinMemoryReq;

    m_pClass = NULL;
    m_pInClass = NULL;
    m_pInInst = NULL;
    m_pOutInst = NULL;

    m_pWbemLocator    = NULL;
    m_pWbemServices   = NULL;
    m_pAuthIdentity   = NULL;
    m_arrColData      = NULL; 
    m_pszBuffer       = NULL;
    m_pObj                  = NULL; 
    m_pTriggerEventConsumer = NULL;            
    m_pEventFilter          = NULL;  
    m_pszTaskUserName       = NULL;

    m_pszEventQuery   = NULL;
    m_lHostNameColWidth    = WIDTH_HOSTNAME; 
    m_lTriggerIDColWidth   = WIDTH_TRIGGER_ID; 
    m_lETNameColWidth      = WIDTH_TRIGGER_NAME; 
    m_lTaskColWidth        = WIDTH_TASK;
    m_lQueryColWidth       = WIDTH_EVENT_QUERY;
    m_lDescriptionColWidth = WIDTH_DESCRIPTION;
    m_lWQLColWidth         = 0;
    m_lTaskUserName        = WIDTH_TASK_USERNAME; 
}
// ***************************************************************************
// Routine Description:
//     Class desctructor. It frees memory which is allocated during instance 
//   creation.
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

CETQuery::~CETQuery()
{
    RELEASE_MEMORY_EX(m_pszServerName);
    RELEASE_MEMORY_EX(m_pszUserName);
    RELEASE_MEMORY_EX(m_pszPassword);
    RELEASE_MEMORY_EX(m_pszFormat);
    RELEASE_MEMORY_EX(m_pszBuffer);
    RELEASE_MEMORY_EX(m_pszEventDesc);
    RELEASE_MEMORY_EX(m_pszTask);
    RELEASE_MEMORY_EX(m_pszTaskUserName);
    DESTROY_ARRAY(m_arrColData);
    

    SAFE_RELEASE_INTERFACE(m_pWbemLocator);
    SAFE_RELEASE_INTERFACE(m_pWbemServices);
    SAFE_RELEASE_INTERFACE(m_pObj);
    SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
    SAFE_RELEASE_INTERFACE(m_pEventFilter);

    SAFE_RELEASE_INTERFACE(m_pClass);
    SAFE_RELEASE_INTERFACE(m_pInClass);
    SAFE_RELEASE_INTERFACE(m_pInInst);
    SAFE_RELEASE_INTERFACE(m_pOutInst);

    RELEASE_MEMORY_EX(m_pszEventQuery);

    // Uninitialize COM only when it is initialized.
    if(m_bIsCOMInitialize == TRUE)
    {
        CoUninitialize();
    }

}

// ***************************************************************************
// Routine Description:
//        This function will prepare column structure for DoParseParam Function.
//          
// Arguments:
//       none
// Return Value:
//       none
// ***************************************************************************

void CETQuery::PrepareCMDStruct()
{
   // -delete
    lstrcpy(cmdOptions[ ID_Q_QUERY ].szOption,OPTION_QUERY);
    cmdOptions[ ID_Q_QUERY ].dwFlags = CP_MAIN_OPTION;
    cmdOptions[ ID_Q_QUERY ].dwCount = 1;
    cmdOptions[ ID_Q_QUERY ].dwActuals = 0;
    cmdOptions[ ID_Q_QUERY ].pValue    = &m_bQuery;
    lstrcpy(cmdOptions[ ID_Q_QUERY ].szValues,NULL_STRING);
    cmdOptions[ ID_Q_QUERY ].pFunction = NULL;
    cmdOptions[ ID_Q_QUERY ].pFunctionData = NULL;
    cmdOptions[ ID_Q_QUERY ].pFunctionData = NULL;

    // -s (servername)
    lstrcpy(cmdOptions[ ID_Q_SERVER ].szOption,OPTION_SERVER);
    cmdOptions[ ID_Q_SERVER ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_Q_SERVER ].dwCount = 1;
    cmdOptions[ ID_Q_SERVER ].dwActuals = 0;
    cmdOptions[ ID_Q_SERVER ].pValue    = m_pszServerName;
    lstrcpy(cmdOptions[ ID_Q_SERVER ].szValues,NULL_STRING);
    cmdOptions[ ID_Q_SERVER ].pFunction = NULL;
    cmdOptions[ ID_Q_SERVER ].pFunctionData = NULL;
    
    // -u (username)
    lstrcpy(cmdOptions[ ID_Q_USERNAME ].szOption,OPTION_USERNAME);
    cmdOptions[ ID_Q_USERNAME ].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY;
    cmdOptions[ ID_Q_USERNAME ].dwCount = 1;
    cmdOptions[ ID_Q_USERNAME ].dwActuals = 0;
    cmdOptions[ ID_Q_USERNAME ].pValue    = m_pszUserName;
    lstrcpy(cmdOptions[ ID_Q_USERNAME ].szValues,NULL_STRING);
    cmdOptions[ ID_Q_USERNAME ].pFunction = NULL;
    cmdOptions[ ID_Q_USERNAME ].pFunctionData = NULL;

    // -p (password)
    lstrcpy(cmdOptions[ ID_Q_PASSWORD ].szOption,OPTION_PASSWORD);
    cmdOptions[ ID_Q_PASSWORD ].dwFlags = CP_TYPE_TEXT|CP_VALUE_OPTIONAL;
    cmdOptions[ ID_Q_PASSWORD ].dwCount = 1;
    cmdOptions[ ID_Q_PASSWORD ].dwActuals = 0;
    cmdOptions[ ID_Q_PASSWORD ].pValue    = m_pszPassword;
    lstrcpy(cmdOptions[ ID_Q_PASSWORD ].szValues,NULL_STRING);
    cmdOptions[ ID_Q_PASSWORD ].pFunction = NULL;
    cmdOptions[ ID_Q_PASSWORD ].pFunctionData = NULL;
    
    // -fo
    lstrcpy(cmdOptions[ ID_Q_FORMAT].szOption,OPTION_FORMAT);
    cmdOptions[ ID_Q_FORMAT].dwFlags = CP_TYPE_TEXT|CP_VALUE_MANDATORY|
                                       CP_MODE_VALUES;
    cmdOptions[ ID_Q_FORMAT].dwCount = 1;
    cmdOptions[ ID_Q_FORMAT].dwActuals = 0;
    cmdOptions[ ID_Q_FORMAT].pValue    = m_pszFormat;
    lstrcpy(cmdOptions[ID_Q_FORMAT].szValues,GetResString(IDS_FORMAT_OPTIONS));
    cmdOptions[ ID_Q_FORMAT].pFunction = NULL;
    cmdOptions[ ID_Q_FORMAT].pFunctionData = NULL;

    // -nh
    lstrcpy(cmdOptions[ ID_Q_NOHEADER].szOption,OPTION_NOHEADER);
    cmdOptions[ ID_Q_NOHEADER].dwFlags = 0;
    cmdOptions[ ID_Q_NOHEADER].dwCount = 1;
    cmdOptions[ ID_Q_NOHEADER].dwActuals = 0;
    cmdOptions[ ID_Q_NOHEADER].pValue    = &m_bNoHeader;
    lstrcpy(cmdOptions[ ID_Q_NOHEADER].szValues,NULL_STRING);
    cmdOptions[ ID_Q_NOHEADER].pFunction = NULL;
    cmdOptions[ ID_Q_NOHEADER].pFunctionData = NULL;

    // verbose
    lstrcpy(cmdOptions[ ID_Q_VERBOSE].szOption,OPTION_VERBOSE);
    cmdOptions[ ID_Q_VERBOSE ].dwFlags = 0;
    cmdOptions[ ID_Q_VERBOSE ].dwCount = 1;
    cmdOptions[ ID_Q_VERBOSE ].dwActuals = 0;
    cmdOptions[ ID_Q_VERBOSE ].pValue    = &m_bVerbose;
    cmdOptions[ ID_Q_VERBOSE ].pFunction = NULL;
    cmdOptions[ ID_Q_VERBOSE ].pFunctionData = NULL;
}
// ***************************************************************************
// Routine Description:
//        This function will process/parce the command line options.
//          
// Arguments:
//        [ in ] argc        : argument(s) count specified at the command prompt
//        [ in ] argv        : argument(s) specified at the command prompt
//  
// Return Value:
//        TRUE  : On Successful
//      FALSE : On Error
// 
// ***************************************************************************

void
CETQuery::ProcessOption(DWORD argc, LPCTSTR argv[])
{
    // local variable
    BOOL bReturn = TRUE;
    CHString szTempString;
   
    PrepareCMDStruct ();

	// init the password variable with '*'
	if ( m_pszPassword != NULL )
		lstrcpy( m_pszPassword, _T( "*" ) );
    
    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam( argc, argv, MAX_COMMANDLINE_Q_OPTION, cmdOptions );

    if(bReturn==FALSE)
        throw CShowError(MK_E_SYNTAX);
    // empty Server is not valid
    szTempString = m_pszServerName;
    szTempString.TrimRight();
    lstrcpy(m_pszServerName,(LPCWSTR)szTempString);
	if ( (cmdOptions[ID_Q_SERVER].dwActuals != 0) && 
        (lstrlen( m_pszServerName) == 0 ))
	{
        throw CShowError(IDS_ERROR_SERVERNAME_EMPTY);
	}

    // "-u" should not be specified without "-s"
    if ( cmdOptions[ ID_Q_SERVER ].dwActuals == 0 &&
         cmdOptions[ ID_Q_USERNAME ].dwActuals != 0 )
    {
        throw CShowError(IDS_ERROR_USERNAME_BUT_NOMACHINE);
    }
    // empty user is not valid
    szTempString = m_pszUserName;
    szTempString.TrimRight();
    lstrcpy(m_pszUserName,(LPCWSTR)szTempString);
	if ( (cmdOptions[ID_Q_USERNAME].dwActuals != 0) && 
        (lstrlen( m_pszUserName) == 0 ))
	{
        throw CShowError(IDS_ERROR_USERNAME_EMPTY);
	}
    // "-p" should not be specified without -u 
    if ( (cmdOptions[ID_Q_USERNAME].dwActuals  == 0) && 
          (cmdOptions[ID_Q_PASSWORD].dwActuals != 0 ))
	{
		// invalid syntax
        throw CShowError(IDS_USERNAME_REQUIRED);
	}

    // check whether caller should accept the password or not
	// if user has specified -s (or) -u and no "-p", then utility should accept
    // password the user will be prompter for the password only if establish 
    // connection  is failed without the credentials information
	if ( cmdOptions[ ID_Q_PASSWORD ].dwActuals != 0 && 
		 m_pszPassword != NULL && lstrcmp( m_pszPassword, _T( "*" ) ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		m_bNeedPassword = TRUE;
	}
	else if ( cmdOptions[ ID_Q_PASSWORD ].dwActuals == 0 && 
	        ( cmdOptions[ ID_Q_SERVER ].dwActuals != 0 || cmdOptions[ ID_Q_USERNAME ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		m_bNeedPassword = TRUE;
		if ( m_pszPassword != NULL )
		{
			lstrcpy( m_pszPassword, _T( "" ) );
		}
	}

    if((m_bNoHeader == TRUE) &&
         ((lstrcmpi(m_pszFormat,GetResString(IDS_STRING_LIST))==0)))
     {
        throw CShowError(IDS_HEADER_NOT_ALLOWED);
     }
}
// ***************************************************************************
// Routine Description:
//    This function will allocate memory to variables and also checks it and 
//  fills variable with value ZERO. 
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************

void 
CETQuery::Initialize()
{
    // local variable
    LONG lTemp = 0;
    // if at all any occurs, we know that is 'coz of the 
    // failure in memory allocation ... so set the error
    SetLastError( E_OUTOFMEMORY );
    SaveLastError();

    // allocate memory at least MAX_COMPUTER_NAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_COMPUTERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_COMPUTERNAME_LENGTH+1;
    m_pszServerName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszServerName,lTemp);

    // allocate memory at least MAX_USERNAME_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_USERNAME_LENGTH)?
             m_lMinMemoryReq:MAX_USERNAME_LENGTH+1;
    m_pszUserName = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszUserName,lTemp);

    // Allocate memory for Run As Username 
    m_pszTaskUserName = new TCHAR[MAX_RES_STRING+1];
    CheckAndSetMemoryAllocation(m_pszTaskUserName,MAX_RES_STRING);

        
    // allocate memory at least MAX_PASSWORD_LENGTH+1 (its windows )
    // constant
    lTemp = (m_lMinMemoryReq>MAX_PASSWORD_LENGTH)?
             m_lMinMemoryReq:MAX_PASSWORD_LENGTH+1;
    m_pszPassword = new TCHAR[lTemp+1]; 
    CheckAndSetMemoryAllocation (m_pszPassword,lTemp);
    
    m_pszFormat = new TCHAR[MAX_RES_STRING+1]; 
    CheckAndSetMemoryAllocation (m_pszFormat,MAX_RES_STRING);
    
    m_pszBuffer = new TCHAR[(MAX_RES_STRING*4)+1]; 
    CheckAndSetMemoryAllocation (m_pszBuffer,(MAX_RES_STRING*4));

    m_pszEventDesc = new TCHAR[(m_lDescriptionColWidth)+1]; 
    CheckAndSetMemoryAllocation (m_pszEventDesc,(m_lDescriptionColWidth));

    m_pszEventQuery = new TCHAR[(m_lQueryColWidth)+1]; 
    CheckAndSetMemoryAllocation (m_pszEventQuery,(m_lQueryColWidth));

    m_pszTask = new TCHAR[(m_lTaskColWidth)+1]; 
    CheckAndSetMemoryAllocation (m_pszTask,(m_lTaskColWidth));
    
    
    m_arrColData = CreateDynamicArray();
    if(m_arrColData==NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // initialization is successful
    SetLastError( NOERROR );            // clear the error
    SetReason( NULL_STRING );            // clear the reason

}
// ***************************************************************************
// Routine Description:
//        Function will allocate memory to a string
//          
// Arguments:
//        [in][out] pszStr   : String variable to which memory to be  allocated
//      [in]               : Number of bytes to be allocated.
// Return Value:
//        NONE
// 
//***************************************************************************

void CETQuery::CheckAndSetMemoryAllocation(LPTSTR pszStr, LONG lSize)
{
    if(pszStr == NULL)
    {
        throw CShowError(E_OUTOFMEMORY);
    }
    // init to ZERO's
    ZeroMemory( pszStr, lSize * sizeof( TCHAR ) );
    return; 

}
// ***************************************************************************
// Routine Description:
//    This function will execute query. This will enumerate classes from WMI
//  to get required data.
//          
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************
BOOL 
CETQuery::ExecuteQuery()
{
    // Local variables
    HRESULT hr =  S_OK;  // Holds  values returned by COM functions
    BOOL    bReturn = TRUE;      // status of Return value of this function.
    BOOL bSearchNTEventLogConsumer = FALSE;//status whether searching in all 
                                           //instances of NTEventLogConsumer is 
                                           //successful or not
    BOOL bSearchEventFilter = FALSE;// status whether searching in all 
                                    // instances of EventFilter is successful 
                                    //or not
    DWORD dwFormatType; // stores  FORMAT status values to show results
    // COM related pointer variable. their usage is well understood by their 
    //names.
    IEnumWbemClassObject *pEnumFilterToConsumerBinding = NULL;
    IWbemServices *pLocatorTriggerEventConsumer = NULL;
    VARIANT vVariant;      // variable used to get values from COM functions
    // Variables to store query results....
    TCHAR szHostName[MAX_RES_STRING+1];
    TCHAR szEventTriggerName[MAX_RES_STRING+1];
    DWORD  dwEventId = 0;
    DWORD dwRowCount = 0; // store Row number.
    BOOL bAtLeastOneEvent = FALSE;
    LPTSTR pstrTemp1 = NULL;
   
    BSTR bstrConsumer   = NULL;
    BSTR bstrFilter     = NULL;
    BSTR bstrCmdTrigger = NULL;

    LONG lTemp        = 0;
    
    

    try
    {
        m_hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
        if(m_hStdHandle!=NULL)
        {
            GetConsoleScreenBufferInfo(m_hStdHandle,&m_ScreenBufferInfo);
        }
       
        InitializeCom(&m_pWbemLocator);
        m_bIsCOMInitialize = TRUE;
        {
            CHString szTempUser = m_pszUserName; // Temp. variabe to store user
                                                // name.
            CHString szTempPassword = m_pszPassword;// Temp. variable to store
                                                    // password.
            m_bLocalSystem = TRUE;
           // Connect remote / local WMI.
            BOOL bResult = ConnectWmiEx( m_pWbemLocator, 
                                    &m_pWbemServices, 
                                    m_pszServerName,
                                    szTempUser, 
                                    szTempPassword,
                                    &m_pAuthIdentity, 
                                    m_bNeedPassword,
                                    WMI_NAMESPACE_CIMV2, 
                                    &m_bLocalSystem);
            if(bResult == FALSE)
            {
                TCHAR szErrorMsg[MAX_RES_STRING+1];
                DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                                  GetReason());
                return FALSE;
            }
            // check the remote system version and its compatiblity
            if ( m_bLocalSystem == FALSE )
            {
                DWORD dwVersion = 0;
                dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
                if ( dwVersion <= 5000 ) // to block win2k versions
                {
                    TCHAR szErrorMsg[MAX_RES_STRING+1];
                    SetReason( ERROR_OS_INCOMPATIBLE );
                    DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                                      GetReason());
                    return FALSE;
                }
            }

            // check the local credentials and if need display warning
            if ( m_bLocalSystem && (lstrlen(m_pszUserName)!=0) )
            {
                CHString str;
                WMISaveError( WBEM_E_LOCAL_CREDENTIALS );
                str.Format( L"%s %s", TAG_WARNING, GetReason() );
                ShowMessage( stdout, str );
            }


         }
        // Show wait message...............
        m_hStdHandle = GetStdHandle(STD_ERROR_HANDLE);
        if(m_hStdHandle!=NULL)
        {
            GetConsoleScreenBufferInfo(m_hStdHandle,&m_ScreenBufferInfo);
        }
        PrintProgressMsg(m_hStdHandle,GetResString(IDS_MSG_EVTRIG_Q),m_ScreenBufferInfo);
       
        //Following method will creates an enumerator that returns the  
        // instances of a specified __FilterToConsumerBinding class 
        bstrConsumer = SysAllocString(CLS_FILTER_TO_CONSUMERBINDING);
        hr = m_pWbemServices->
                CreateInstanceEnum(bstrConsumer,
                                   WBEM_FLAG_SHALLOW,
                                   NULL,
                                   &pEnumFilterToConsumerBinding);
        SAFE_RELEASE_BSTR(bstrConsumer);         
        ON_ERROR_THROW_EXCEPTION(hr);

       hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding, 
                               m_pAuthIdentity );
       ON_ERROR_THROW_EXCEPTION(hr);


        // retrieves  CmdTriggerConsumer class 
        bstrCmdTrigger = SysAllocString(CLS_TRIGGER_EVENT_CONSUMER);
        hr = m_pWbemServices->GetObject(bstrCmdTrigger,
                                   0, NULL, &m_pClass, NULL);
        RELEASE_BSTR(bstrCmdTrigger);
        ON_ERROR_THROW_EXCEPTION(hr);

        // Gets  information about the "QueryETrigger( " method of
        // "cmdTriggerConsumer" class
        bstrCmdTrigger = SysAllocString(FN_QUERY_ETRIGGER);
        hr = m_pClass->GetMethod(bstrCmdTrigger,
                                0, &m_pInClass, NULL); 
        RELEASE_BSTR(bstrCmdTrigger);
        ON_ERROR_THROW_EXCEPTION(hr);

       // create a new instance of a class "TriggerEventConsumer ". 
        hr = m_pInClass->SpawnInstance(0, &m_pInInst);
        ON_ERROR_THROW_EXCEPTION(hr);

        while(1)
        {
            ULONG uReturned = 0; // holds no. of object returns from Next 
                                //mathod
            
            BSTR bstrTemp = NULL;
            CHString strTemp;
          // set the security at the interface level also

           hr = SetInterfaceSecurity( pEnumFilterToConsumerBinding, 
                                   m_pAuthIdentity );
           
            ON_ERROR_THROW_EXCEPTION(hr);
            // Get one  object starting at the current position in an 
            //enumeration
            hr = pEnumFilterToConsumerBinding->Next(WBEM_INFINITE,
                                                1,&m_pObj,&uReturned);
            ON_ERROR_THROW_EXCEPTION(hr);
            if(uReturned == 0)
            {
                SAFE_RELEASE_INTERFACE(m_pObj);
                break;
            }
            VariantInit(&vVariant);
            SAFE_RELEASE_BSTR(bstrTemp); 
            bstrTemp = SysAllocString(L"Consumer");
            hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
            SAFE_RELEASE_BSTR(bstrTemp); 
            ON_ERROR_THROW_EXCEPTION(hr);            

            bstrConsumer =SysAllocString( vVariant.bstrVal);
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
            // Search for trggereventconsumer string as we are interested to
            // get object from this class only 
            strTemp = bstrConsumer;
            if(strTemp.Find(CLS_TRIGGER_EVENT_CONSUMER)==-1)
                continue;
            hr = SetInterfaceSecurity( m_pWbemServices, 
                                       m_pAuthIdentity );
               
                ON_ERROR_THROW_EXCEPTION(hr);

            hr = m_pWbemServices->GetObject(bstrConsumer,
                                            0,
                                            NULL,
                                            &m_pTriggerEventConsumer,
                                            NULL);
            SAFE_RELEASE_BSTR(bstrConsumer);
            if(FAILED(hr))
            {
                if(hr==WBEM_E_NOT_FOUND)
                    continue;
                ON_ERROR_THROW_EXCEPTION(hr);
            }
            bstrTemp = SysAllocString(L"Filter");
            hr = m_pObj->Get(bstrTemp, 0, &vVariant, 0, 0);
            SAFE_RELEASE_BSTR(bstrTemp); 
            ON_ERROR_THROW_EXCEPTION(hr);            
            bstrFilter = SysAllocString(vVariant.bstrVal);
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
            hr = m_pWbemServices->GetObject(
                                                bstrFilter,
                                                0,
                                                NULL,
                                                &m_pEventFilter,
                                                NULL);
            SAFE_RELEASE_BSTR(bstrFilter);
            if(FAILED(hr))
            {
                if(hr==WBEM_E_NOT_FOUND)
                    continue;
                ON_ERROR_THROW_EXCEPTION(hr);
            }

            //retrieves the 'TriggerID' value if exits
            bstrTemp = SysAllocString(FPR_TRIGGER_ID);
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 
                            0, &vVariant, 0, 0);
            if(FAILED(hr))
            {
                if(hr==WBEM_E_NOT_FOUND)
                    continue;
                ON_ERROR_THROW_EXCEPTION(hr);
            }
            SAFE_RELEASE_BSTR(bstrTemp);
            dwEventId = vVariant.lVal ;
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);

            //retrieves the 'Action' value if exits
            bstrTemp = SysAllocString(L"Action");
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
            ON_ERROR_THROW_EXCEPTION(hr);
            SAFE_RELEASE_BSTR(bstrTemp);

            lstrcpy(m_pszBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal));  
            lTemp = lstrlen(m_pszBuffer);
            lTemp += 4; // for the safer size for allocation of memory.
            
            // allocates memory only if new task length is greate than previous one.
            if(lTemp > m_lTaskColWidth)
            {
                // first free it (if previously allocated)
                RELEASE_MEMORY_EX(m_pszTask);
                m_pszTask = new TCHAR[lTemp+1];
                CheckAndSetMemoryAllocation(m_pszTask,lTemp);
            }
            lstrcpy(m_pszTask,m_pszBuffer);
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr); 
            //retrieves the  'TriggerDesc' value if exits
            bstrTemp = SysAllocString(FPR_TRIGGER_DESC);
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
            ON_ERROR_THROW_EXCEPTION(hr);

            SAFE_RELEASE_BSTR(bstrTemp);
            
            lstrcpy(m_pszBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal));  
            lTemp = lstrlen(m_pszBuffer);
            if(lTemp == 0)// Means description is not available make it N/A.
            {
                lstrcpy(m_pszBuffer,GetResString(IDS_ID_NA));
                lTemp = lstrlen(m_pszBuffer);
            }
            lTemp += 4; // for the safer size for allocation of memory.
            
            // allocates memory only if new Description length is greate than 
            // previous one.
            if(lTemp > m_lDescriptionColWidth)
            {
                // first free it (if previously allocated)
                RELEASE_MEMORY_EX(m_pszEventDesc);
                m_pszEventDesc = new TCHAR[lTemp+1];
                CheckAndSetMemoryAllocation(m_pszEventDesc,lTemp);
            }
            lstrcpy(m_pszEventDesc,m_pszBuffer);
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
            // TriggerName
            //retrieves the  'TriggerName' value if exits
            bstrTemp = SysAllocString(FPR_TRIGGER_NAME);
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
            ON_ERROR_THROW_EXCEPTION(hr);
            SAFE_RELEASE_BSTR(bstrTemp);
            wsprintf(szEventTriggerName,_T("%s"),vVariant.bstrVal);
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr); 
            // Host Name
            //retrieves the  '__SERVER' value if exits
            bstrTemp = SysAllocString(L"__SERVER");
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
            ON_ERROR_THROW_EXCEPTION(hr);
            SAFE_RELEASE_BSTR(bstrTemp);
            wsprintf(szHostName,_T("%s"),vVariant.bstrVal);

            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
            bstrTemp = SysAllocString(L"Query");
            hr = m_pEventFilter->Get(bstrTemp, 0, &vVariant, 0, 0);
            SAFE_RELEASE_BSTR(bstrTemp);
            ON_ERROR_THROW_EXCEPTION(hr);
            lstrcpy(m_pszBuffer,(_TCHAR*)_bstr_t(vVariant.bstrVal));  
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);
              
            FindAndReplace(&m_pszBuffer,QUERY_STRING_AND,SHOW_WQL_QUERY);
            FindAndReplace(&m_pszBuffer,L"targetinstance.LogFile",L"Log");
            FindAndReplace(&m_pszBuffer,L"targetinstance.Type",L"Type");
            FindAndReplace(&m_pszBuffer,L"targetinstance.EventCode",L"Id");
            FindAndReplace(&m_pszBuffer,
                           L"targetinstance.SourceName",L"Source");
            FindAndReplace(&m_pszBuffer,L"  ",L" ");//to remove extra spaces
            FindAndReplace(&m_pszBuffer,L"  ",L" ");//to remove extra spaces

            lTemp = lstrlen(m_pszBuffer);
            lTemp += 4; // for the safer size for allocation of memory.
            // allocates memory only if new WQL is greate than previous one.
           if(lTemp > m_lWQLColWidth)
            {
                // first free it (if previously allocated)
                RELEASE_MEMORY_EX(m_pszEventQuery);
                m_pszEventQuery = new TCHAR[lTemp+1];
                CheckAndSetMemoryAllocation(m_pszEventQuery,lTemp);
            }
            lTemp = m_lWQLColWidth;
            CalcColWidth(lTemp,&m_lWQLColWidth,m_pszBuffer);
            // Now manipulate the WQL string to get EventQuery....
            FindAndReplace(&m_pszBuffer,SHOW_WQL_QUERY,
                            GetResString(IDS_EVENTS_WITH));
            FindAndReplace(&m_pszBuffer,L"  ",L" ");//to remove extra spaces
            FindAndReplace(&m_pszBuffer,L"  ",L" ");//to remove extra spaces
            lstrcpy(m_pszEventQuery,m_pszBuffer);

            // Retrieves the "TaskScheduler"  information
            bstrTemp = SysAllocString(L"ScheduledTaskName");
            hr = m_pTriggerEventConsumer->Get(bstrTemp, 0, &vVariant, 0, 0);
            ON_ERROR_THROW_EXCEPTION(hr);
            SAFE_RELEASE_BSTR(bstrTemp);
            GetRunAsUserName((LPCWSTR)_bstr_t(vVariant.bstrVal)); 
            hr = VariantClear(&vVariant);
            ON_ERROR_THROW_EXCEPTION(hr);

            //////////////////////////////////////////

           // Now Shows the results on screen
           // Appends for in m_arrColData array
            dwRowCount = DynArrayAppendRow( m_arrColData, NO_OF_COLUMNS ); 
           // Fills Results in m_arrColData data structure
           DynArraySetString2(m_arrColData,dwRowCount,HOST_NAME,szHostName,0); 
           DynArraySetDWORD2(m_arrColData ,dwRowCount,TRIGGER_ID,dwEventId);
           DynArraySetString2(m_arrColData,dwRowCount,TRIGGER_NAME,szEventTriggerName,0); 
           DynArraySetString2(m_arrColData,dwRowCount,TASK,m_pszTask,0); 
           DynArraySetString2(m_arrColData,dwRowCount,EVENT_QUERY,m_pszEventQuery,0); 
           DynArraySetString2(m_arrColData,dwRowCount,EVENT_DESCRIPTION,m_pszEventDesc,0); 
           DynArraySetString2(m_arrColData,dwRowCount,TASK_USERNAME,m_pszTaskUserName,0); 
           bAtLeastOneEvent = TRUE;
 
          // Calculatate new column width for each column
          lTemp = m_lHostNameColWidth;
          CalcColWidth(lTemp,&m_lHostNameColWidth,szHostName);

          lTemp = m_lETNameColWidth;
          CalcColWidth(lTemp,&m_lETNameColWidth,szEventTriggerName);

          lTemp = m_lTaskColWidth;
          CalcColWidth(lTemp,&m_lTaskColWidth,m_pszTask);

          lTemp = m_lQueryColWidth;
          CalcColWidth(lTemp,&m_lQueryColWidth,m_pszEventQuery);

          lTemp = m_lDescriptionColWidth;
          CalcColWidth(lTemp,&m_lDescriptionColWidth,m_pszEventDesc);
           // Resets current containts..if any
           lstrcpy((szHostName),NULL_STRING);
           dwEventId = 0;
           lstrcpy((szEventTriggerName),NULL_STRING);
           lstrcpy((m_pszTask),NULL_STRING);
           lstrcpy((m_pszEventQuery),NULL_STRING);
           lstrcpy((m_pszEventDesc),NULL_STRING);
           SAFE_RELEASE_INTERFACE(m_pObj);
           SAFE_RELEASE_INTERFACE(m_pTriggerEventConsumer);
           SAFE_RELEASE_INTERFACE(m_pEventFilter);
        } // End of while
        if(StringCompare(m_pszFormat,GetResString(IDS_STRING_TABLE),TRUE,5)==0)
        {
            dwFormatType = SR_FORMAT_TABLE;
        }
        else if (StringCompare(m_pszFormat,GetResString(IDS_STRING_LIST),
                               TRUE,4)==0)
        {
            dwFormatType = SR_FORMAT_LIST;
        }
        else if (StringCompare(m_pszFormat,GetResString(IDS_STRING_CSV),
                               TRUE,3)==0)
        {
            dwFormatType = SR_FORMAT_CSV;
        }
        else // Default
        {
           dwFormatType = SR_FORMAT_TABLE;
        }
        if(m_bNoHeader == TRUE)
        {
           dwFormatType |=SR_NOHEADER;
        }
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        if(bAtLeastOneEvent==TRUE)
        {
            // Show Final Query Results on screen
            PrepareColumns (); 

            ShowMessage(stdout,BLANK_LINE);
            ShowResults(NO_OF_COLUMNS,mainCols,dwFormatType,m_arrColData);
        }
        else
        {
            // Show Message 
            ShowMessage(stdout,GetResString(IDS_NO_EVENT_FOUNT));
        }
    }
    catch(_com_error &e)
    {
        TCHAR szErrorMsg[MAX_RES_STRING+1];
        PrintProgressMsg(m_hStdHandle,NULL_STRING,m_ScreenBufferInfo);
        if(hr == 0x80041002)// WMI returns string for this hr value is 
                            // "Not Found." which is not user friendly. So
                            // changing the message text. 
        {
            ShowMessage( stderr,GetResString(IDS_CLASS_NOT_REG));
        }
        else
        {
            DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s" , TAG_ERROR,
                             GetReason() );
        }
        return FALSE;
    }
    return TRUE;
}
// ***************************************************************************
// Routine Description:
//    This function will prepare/fill structure which will be used to show
//  output data.
//
// Arguments:
//      None  
// Return Value:
//        None
// 
//***************************************************************************
void 
CETQuery::PrepareColumns()
{
    
    // local variable

    // If non verbose output, some column should be hide.
     DWORD  dwMask = m_bVerbose?0:SR_HIDECOLUMN;

    // For non verbose mode output, column width is predefined else
    // use dynamically calculated column width.
    m_lETNameColWidth = m_bVerbose?m_lETNameColWidth:V_WIDTH_TRIG_NAME;
    m_lTaskColWidth   = m_bVerbose?m_lTaskColWidth:V_WIDTH_TASK;
    m_lTriggerIDColWidth = m_bVerbose?m_lTriggerIDColWidth:V_WIDTH_TRIG_ID;

  
    lstrcpy(mainCols[HOST_NAME].szColumn,COL_HOSTNAME);
    mainCols[HOST_NAME].dwWidth = m_lHostNameColWidth;
    if(m_bVerbose==TRUE)
        mainCols[HOST_NAME].dwFlags = SR_TYPE_STRING;
    else
        mainCols[HOST_NAME].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;

    lstrcpy(mainCols[HOST_NAME].szFormat,L"%s");
    mainCols[HOST_NAME].pFunction = NULL;
    mainCols[HOST_NAME].pFunctionData = NULL;

    lstrcpy(mainCols[TRIGGER_ID].szColumn,COL_TRIGGER_ID);
    mainCols[TRIGGER_ID].dwWidth = m_lTriggerIDColWidth;
    mainCols[TRIGGER_ID].dwFlags = SR_TYPE_NUMERIC;
    lstrcpy(mainCols[TRIGGER_ID].szFormat,L"%d");
    mainCols[TRIGGER_ID].pFunction = NULL;
    mainCols[TRIGGER_ID].pFunctionData = NULL;

    lstrcpy(mainCols[TRIGGER_NAME].szColumn,COL_TRIGGER_NAME);
    mainCols[TRIGGER_NAME].dwWidth = m_lETNameColWidth;
    mainCols[TRIGGER_NAME].dwFlags = SR_TYPE_STRING;
    lstrcpy(mainCols[TRIGGER_NAME].szFormat,L"%s");
    mainCols[TRIGGER_NAME].pFunction = NULL;
    mainCols[TRIGGER_NAME].pFunctionData = NULL;

    lstrcpy(mainCols[TASK].szColumn,COL_TASK);
    mainCols[TASK].dwWidth = m_lTaskColWidth;

    mainCols[TASK].dwFlags = SR_TYPE_STRING;
    lstrcpy(mainCols[TASK].szFormat,L"%s");
    mainCols[TASK].pFunction = NULL;
    mainCols[TASK].pFunctionData = NULL;

    lstrcpy(mainCols[EVENT_QUERY].szColumn,COL_EVENT_QUERY);
    mainCols[EVENT_QUERY].dwWidth = m_lQueryColWidth;
    if(m_bVerbose==TRUE)
        mainCols[EVENT_QUERY].dwFlags = SR_TYPE_STRING;
    else
        mainCols[EVENT_QUERY].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;

    lstrcpy(mainCols[EVENT_QUERY].szFormat,L"%s");
    mainCols[EVENT_QUERY].pFunction = NULL;
    mainCols[EVENT_QUERY].pFunctionData = NULL;
  
    lstrcpy(mainCols[EVENT_DESCRIPTION].szColumn,COL_DESCRIPTION);
    mainCols[EVENT_DESCRIPTION].dwWidth = m_lDescriptionColWidth;
    if(m_bVerbose == TRUE)
        mainCols[EVENT_DESCRIPTION].dwFlags = SR_TYPE_STRING;
    else
        mainCols[EVENT_DESCRIPTION].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;
 
    // Task Username
    lstrcpy(mainCols[TASK_USERNAME].szFormat,L"%s");
    mainCols[TASK_USERNAME].pFunction = NULL;
    mainCols[TASK_USERNAME].pFunctionData = NULL;

    lstrcpy(mainCols[TASK_USERNAME].szColumn,COL_TASK_USERNAME);
    mainCols[TASK_USERNAME].dwWidth = m_lTaskUserName;
    if(m_bVerbose == TRUE)
        mainCols[TASK_USERNAME].dwFlags = SR_TYPE_STRING;
    else
        mainCols[TASK_USERNAME].dwFlags = SR_HIDECOLUMN|SR_TYPE_STRING;

    lstrcpy(mainCols[TASK_USERNAME].szFormat,L"%s");
    mainCols[TASK_USERNAME].pFunction = NULL;
    mainCols[TASK_USERNAME].pFunctionData = NULL;


}
/******************************************************************************
Routine Description:
 
    This function Will Find a string (lpszFind) in source string (lpszSource) 
    and replace it with replace string (lpszReplace) for all occurences.
  
Arguments: 
              
    [in/out] lpszSource : String on which Find-Replace operation to be 
                          performed
    [in] lpszFind       : String to be find
    [in] lpszReplace    : String to be replaced.
Return Value:
     0 - if Unsucessful
     else returns length of lpszSource.
                          
******************************************************************************/
LONG 
CETQuery::FindAndReplace(LPTSTR *lpszSource, LPCTSTR lpszFind, 
                         LPCTSTR lpszReplace)
{
    LONG lSourceLen = lstrlen(lpszFind);
    LONG lReplacementLen = lstrlen(lpszReplace);
    LONG lMainLength = lstrlen(*lpszSource);
    LPTSTR pszMainSafe= new TCHAR[lstrlen(*lpszSource)+1];
    // loop once to figure out the size of the result string
    LONG nCount = 0;
    LPTSTR lpszStart = NULL;
    lpszStart = *lpszSource;
    LPTSTR lpszEnd = NULL;
    lpszEnd = lpszStart + lMainLength;
    LPTSTR lpszTarget=NULL;
    if ((lSourceLen == 0)||(pszMainSafe==NULL))
    {
        RELEASE_MEMORY_EX(pszMainSafe);
        return 0;
    }
    while (lpszStart < lpszEnd)
    {
        while ((lpszTarget = _tcsstr(lpszStart, lpszFind)) != NULL)
        {
            nCount++;
            lpszStart = lpszTarget + lSourceLen;
        }
        lpszStart += lstrlen(lpszStart) + 1;
    }

    // if any changes were made, make them
    if (nCount > 0)
    {
        lstrcpy(pszMainSafe,*lpszSource);
        LONG lOldLength = lMainLength;
        // if the buffer is too small, just
        //   allocate a new buffer (slow but sure)
        int nNewLength =  lMainLength + (lReplacementLen-lSourceLen)*nCount;
        if(lMainLength < nNewLength)
        {
            
            if(*lpszSource!=NULL)
            {
                delete *lpszSource;
            }
            *lpszSource = new TCHAR[ (nNewLength*sizeof(TCHAR))+sizeof(TCHAR)];
            if( *lpszSource ==  NULL )
            { 
                RELEASE_MEMORY_EX(pszMainSafe);
                return 0;
            }
            memcpy((LPTSTR)*lpszSource,pszMainSafe, lMainLength*sizeof(TCHAR));
        }
                  
        // else, we just do it in-place
            lpszStart= *lpszSource;
            lpszEnd = lpszStart +lstrlen(*lpszSource);
        // loop again to actually do the work
        while (lpszStart < lpszEnd)
        {
            while ( (lpszTarget = _tcsstr(lpszStart, lpszFind)) != NULL)
            {
                #ifdef _WIN64
                    __int64 lBalance ;
                #else
                    LONG lBalance;
                #endif
                lBalance = lOldLength - (lpszTarget - lpszStart + lSourceLen);
                memmove(lpszTarget + lReplacementLen, lpszTarget + lSourceLen,
                (size_t)    lBalance * sizeof(TCHAR));
                memcpy(lpszTarget, lpszReplace, lReplacementLen*sizeof(TCHAR));
                lpszStart = lpszTarget + lReplacementLen;
                lpszStart[lBalance] = NULL_CHAR;
                lOldLength += (lReplacementLen - lSourceLen);
               
            }
            lpszStart += lstrlen(lpszStart) + 1;
        }
    }
    RELEASE_MEMORY_EX(pszMainSafe);
    return lstrlen(*lpszSource);
}
/******************************************************************************
Routine Description:
    Calculates the width required for column
Arguments: 
              
    [in]  lOldLength   : Previous length 
    [out] plNewLength  : New Length
    [in]  pszString    : String .

Return Value:
     none
                          
******************************************************************************/

void 
CETQuery::CalcColWidth(LONG lOldLength,LONG *plNewLength,LPTSTR pszString)
{
    LONG lStrLength = lstrlen(pszString)+2;
    //Any way column width should not be greater than MAX_COL_LENGTH 
   // Stores the maximum of WQL length.
    if(lStrLength > lOldLength)
        *plNewLength = lStrLength;
    else
        *plNewLength = lOldLength;

}
/******************************************************************************
Routine Description:
   Get User Name from Task Scheduler
Arguments: 
              
    [in]  pszTaskName   : Task Name

Return Value:
     HRESULT
                          
******************************************************************************/

HRESULT  
CETQuery::GetRunAsUserName(LPCWSTR pszScheduleTaskName)
{

    // if pszSheduleTaskName is null or 0 length just return N/A.
    HRESULT hr = S_OK;
    BSTR bstrTemp = NULL;
    VARIANT vVariant;
     

    if(lstrlen(pszScheduleTaskName)==0)
    {
        lstrcpy(m_pszTaskUserName,DEFAULT_USER);
        return S_OK;
    }
   lstrcpy(m_pszTaskUserName,GetResString(IDS_ID_NA));
    // Put input parameter for QueryETrigger method
    hr = PropertyPut(m_pInInst,FPR_TASK_SCHEDULER,_bstr_t(pszScheduleTaskName));
    ON_ERROR_THROW_EXCEPTION(hr);
    // All The required properties sets, so 
    // executes DeleteETrigger method to delete eventtrigger
    hr = m_pWbemServices->ExecMethod(_bstr_t(CLS_TRIGGER_EVENT_CONSUMER),
                                     _bstr_t(FN_QUERY_ETRIGGER), 
                                     0, NULL, m_pInInst,&m_pOutInst,NULL);
    ON_ERROR_THROW_EXCEPTION(hr);

    bstrTemp = SysAllocString(FPR_RUN_AS_USER);
    VariantInit(&vVariant);
    hr = m_pOutInst->Get(bstrTemp, 0, &vVariant, 0, 0);
    SAFE_RELEASE_BSTR(bstrTemp);
    ON_ERROR_THROW_EXCEPTION(hr);

    wsprintf(m_pszTaskUserName,_T("%s"),vVariant.bstrVal);
    hr = VariantClear(&vVariant);
    ON_ERROR_THROW_EXCEPTION(hr);
    if(lstrlen(m_pszTaskUserName)==0)
    {
         lstrcpy(m_pszTaskUserName,GetResString(IDS_ID_NA));
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etdelete.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name:

    ETDelete.h

Abstract:

  This module  contanins function definations required by ETDelete.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


*******************************************************************************/ 

#ifndef _ETDELETE
#define _ETDELETE

#define MAX_COMMANDLINE_D_OPTION  5

#define ID_D_DELETE        0
#define ID_D_SERVER        1
#define ID_D_USERNAME      2
#define ID_D_PASSWORD      3
#define ID_D_ID            4

#define ID_MAX_RANGE        UINT_MAX


class CETDelete  
{
public:
	BOOL ExecuteDelete();
	void Initialize();
	CETDelete();
    CETDelete(LONG lMinMemoryReq,BOOL bNeedPassword);
    void ProcessOption(DWORD argc, LPCTSTR argv[]);
	virtual ~CETDelete();
private:
	BOOL GiveTriggerID(LONG *pTriggerID,LPTSTR pszTriggerName);
	BOOL GiveTriggerName(LONG lTriggerID,LPTSTR pszTriggerName);
	
	void PrepareCMDStruct();
	void CheckAndSetMemoryAllocation(LPTSTR pszStr,LONG lSize);
    CONSOLE_SCREEN_BUFFER_INFO m_ScreenBufferInfo; 
    HANDLE  m_hStdHandle;
    BOOL    m_bDelete;
    LPTSTR  m_pszServerName;
	LPTSTR  m_pszUserName;
	LPTSTR  m_pszPassword;
    TARRAY  m_arrID;
    BOOL    m_bNeedPassword;
    LPTSTR  m_pszTemp;

    // COM function related local variables..
    BOOL m_bIsCOMInitialize;
	IWbemLocator*           m_pWbemLocator;
	IWbemServices*          m_pWbemServices;
	IEnumWbemClassObject*   m_pEnumObjects;
    IWbemClassObject*       m_pClass; 
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst; 
    IWbemClassObject*       m_pOutInst;



    COAUTHIDENTITY* m_pAuthIdentity;

    LONG m_lMinMemoryReq;

    // Array to store command line options
    TCMDPARSER cmdOptions[MAX_COMMANDLINE_D_OPTION]; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\etquery.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name:

    ETQuery.h

Abstract:

  This module  contanins function definations required by ETQuery.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


******************************************************************************/ 


#ifndef  _ETQUERY
#define _ETQUERY

#define COL_HOSTNAME        GetResString(IDS_HOSTNAME)
#define COL_TRIGGER_ID      GetResString(IDS_TRIGGER_ID)   
#define COL_TRIGGER_NAME    GetResString(IDS_TRIGGER_NAME)
#define COL_TASK            GetResString(IDS_TASK)
#define COL_EVENT_QUERY     GetResString(IDS_EVENT_QUERY)
#define COL_DESCRIPTION     GetResString(IDS_DESCRIPTION)
#define COL_WQL             GetResString(IDS_QUERY_LAGUAGE)
#define COL_TASK_USERNAME   GetResString(IDS_TASK_USERNAME)

#define    MAX_COL_LENGTH        MAX_RES_STRING - 1
#define    V_WIDTH_TRIG_ID   10
#define    V_WIDTH_TRIG_NAME 25
#define    V_WIDTH_TASK      40

#define    WIDTH_HOSTNAME      lstrlen(COL_HOSTNAME)+2
#define    WIDTH_TRIGGER_ID    lstrlen(COL_TRIGGER_ID)+2
#define    WIDTH_TRIGGER_NAME  lstrlen(COL_TRIGGER_NAME)
#define    WIDTH_TASK          lstrlen(COL_TASK) + 2
#define    WIDTH_EVENT_QUERY   lstrlen(COL_EVENT_QUERY)+2
#define    WIDTH_DESCRIPTION   lstrlen(COL_DESCRIPTION)+2
#define    WIDTH_TASK_USERNAME 64 //lstrlen(COL_TASK_USERNAME)+20

#define HOST_NAME          0
#define TRIGGER_ID         1
#define TRIGGER_NAME       2
#define TASK               3
#define EVENT_QUERY        4
#define EVENT_DESCRIPTION  5
#define TASK_USERNAME      6 

#define MAX_COMMANDLINE_Q_OPTION 7  // Maximum Command Line  List
#define NO_OF_COLUMNS            7

#define ID_Q_QUERY         0
#define ID_Q_SERVER        1
#define ID_Q_USERNAME      2
#define ID_Q_PASSWORD      3
#define ID_Q_FORMAT        4
#define ID_Q_NOHEADER      5
#define ID_Q_VERBOSE       6


class CETQuery  
{
public:
    BOOL ExecuteQuery();
    void Initialize();
    void ProcessOption(DWORD argc, LPCTSTR argv[]);
    CETQuery();
    virtual ~CETQuery();
    CETQuery::CETQuery(LONG lMinMemoryReq,BOOL bNeedPassword);
private:
    LONG FindAndReplace(LPTSTR* lpszSource,LPCTSTR lpszFind,
                        LPCTSTR lpszReplace);
    LPTSTR m_pszBuffer;
    TARRAY m_arrColData;
    void PrepareColumns();
    void CheckAndSetMemoryAllocation(LPTSTR pszStr,LONG lSize);
    void CalcColWidth(LONG lOldLength,LONG *plNewLength,LPTSTR pszString);
    HRESULT GetRunAsUserName(LPCWSTR pszScheduleTaskName);
    void PrepareCMDStruct();
    void CheckRpRu(void);
    CONSOLE_SCREEN_BUFFER_INFO m_ScreenBufferInfo; 
    HANDLE  m_hStdHandle;
    LPTSTR  m_pszServerName;
    LPTSTR  m_pszUserName;
    LPTSTR  m_pszPassword;
    LPTSTR  m_pszFormat;
    BOOL    m_bVerbose;
    BOOL    m_bNoHeader;
    BOOL    m_bNeedPassword;
    BOOL    m_bUsage;
    BOOL    m_bQuery;
    BOOL    m_bLocalSystem;
    BOOL    m_bNeedDisconnect;
    BOOL    m_bIsCOMInitialize;
    LONG    m_lMinMemoryReq;
    LPTSTR  m_pszEventDesc;
    LPTSTR  m_pszTask;
    LPTSTR  m_pszTaskUserName;

    LONG    m_lHostNameColWidth; 
    LONG    m_lTriggerIDColWidth; 
    LONG    m_lETNameColWidth;
    LONG    m_lTaskColWidth;
    LONG    m_lQueryColWidth;
    LONG    m_lDescriptionColWidth;
    LONG    m_lTaskUserName;

    // variables required to show results..
    LPTSTR m_pszEventQuery;
    LONG   m_lWQLColWidth;

    // WMI / COM interfaces
    IWbemLocator*           m_pWbemLocator;
    IWbemServices*          m_pWbemServices;
    IWbemClassObject*       m_pObj; // Temp. pointers which holds
                                   //next instance
    IWbemClassObject*       m_pTriggerEventConsumer;            
    IWbemClassObject*       m_pEventFilter;            
    IWbemClassObject*       m_pClass; 
    IWbemClassObject*       m_pInClass;
    IWbemClassObject*       m_pInInst; 
    IWbemClassObject*       m_pOutInst;

    // WMI connectivity
    COAUTHIDENTITY* m_pAuthIdentity;

    // Array to store command line options
    TCMDPARSER cmdOptions[MAX_COMMANDLINE_Q_OPTION]; 
    TCOLUMNS   mainCols[NO_OF_COLUMNS];


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\pch.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
// 
//		pch.h 
//  
//  Abstract:
//  
// 		pre-compiled header declaration
//		files that has to be pre-compiled into .pch file
//  
//  Author:
//  
// 	  Akhil Gokhale (akhil.gokhale@wipro.com)
//  
//  Revision History:
//  
// 	  Akhil Gokhale (akhil.gokhale@wipro.com)
//  
// *********************************************************************************

#ifndef __PCH_H
#define __PCH_H

#pragma once		// include header file only once

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

//
// Private nt headers.
//
extern "C"
{
   #include <nt.h>
   #include <ntrtl.h>
   #include <nturtl.h>
   #include <ntexapi.h>
   #include <security.h>
   #include <secExt.h>
}

//
// public Windows header files
//Wbemidl.h
#include <windows.h>
#include <objbase.h>
#include <initguid.h>
#include <ole2.h>
#include <mstask.h>
#include <msterr.h>
#include <mbctype.h>
#include <winperf.h>
#include <wbemidl.h>
#include <CHString.h>
#include <comdef.h>
#include <wbemtime.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <conio.h>
#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

#endif	// __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\eventtriggers.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		EventTriggers.h  
//  
//  Abstract:
//  
//		macros and function prototypes of EventTriggers.cpp
//  
//  Author:
//  
// 		Akhil V. Gokhale (akhil.gokhale@wipro.com)  
//
//  Revision History:
//  
// 		Akhil V. Gokhale (akhil.gokhale@wipro.com)
//  
// *********************************************************************************
#ifndef _EVENTTRIGGERS_H
#define _EVENTTRIGGERS_H
// resource header file
#include "resource.h"



#define CLEAN_EXIT 0
#define DIRTY_EXIT 1
#define SINGLE_SLASH L"\\"
#define DOUBLE_SLASH L"\\\\"
#define MIN_MEMORY_REQUIRED  255;

// CLS stands for class
#define CLS_FILTER_TO_CONSUMERBINDING L"__FilterToConsumerBinding"
#define CLS_WIN32_NT_EVENT_LOGFILE    L"Win32_NTEventLogFile"
#define CLS_EVENT_FILTER              L"__EventFilter"

// FN stands for Function name
#define FN_CREATE_ETRIGGER L"CreateETrigger"
#define FN_DELETE_ETRIGGER L"DeleteETrigger"

// FPR stands for function-parameter
#define FPR_TRIGGER_NAME    L"TriggerName" 
#define FPR_TRIGGER_DESC    L"TriggerDesc"
#define FPR_TRIGGER_QUERY   L"TriggerQuery"
#define FPR_TRIGGER_ACTION  L"TriggerAction"
#define FPR_TRIGGER_ID      L"TriggerID"
#define FPR_RETURN_VALUE    L"ReturnValue"

//
// formats ( used in show results )

// command line options and their indexes in the array

#define MAX_COMMANDLINE_OPTION  5//18  // Maximum Command Line  List

//#define ET_RES_STRINGS MAX_RES_STRING
//#define ET_RES_BUF_SIZE MAX_RES_STRING


#define ID_HELP          0
#define ID_CREATE        1
#define ID_DELETE        2
#define ID_QUERY         3
#define ID_DEFAULT       4
class CEventTriggers
{
public: // constructure and destructure.
     CEventTriggers();
    ~CEventTriggers();
// data memebers
private:
    LPTSTR m_pszServerNameToShow;
	BOOL m_bNeedDisconnect;
    TCMDPARSER cmdOptions[MAX_COMMANDLINE_OPTION]; // Array to store command line options
    LONG m_lMinMemoryReq;
    TARRAY m_arrTemp;
public:

   // functions
private:
	void PrepareCMDStruct();

public:
	void ShowQueryUsage();
	void ShowDeleteUsage();
	void ShowCreateUsage();
	BOOL IsQuery();
	BOOL IsDelete();
	BOOL IsUsage();
	BOOL IsCreate();
	BOOL GetNeedPassword();
	LONG GetMinMemoryReq();
	void ShowMainUsage();
	BOOL ProcessOption(DWORD argc, LPCTSTR argv[]);
	void CalcMinMemoryReq(DWORD argc, LPCTSTR argv[]);
    void UsageMain();
    void Initialize();
private:
	BOOL    m_bNeedPassword;
	BOOL    m_bUsage;
    BOOL    m_bCreate;
    BOOL    m_bDelete;
    BOOL    m_bQuery;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\resource.h ===
#define IDS_OPTION_HELP                 1
#define IDS_OPTION_CREATE               2
#define IDS_OPTION_DELETE               3
#define IDS_OPTION_QUERY                4
#define IDS_OPTION_SERVER               5
#define IDS_OPTION_USERNAME             6
#define IDS_OPTION_PASSWARD             7
#define IDS_OPTION_TRIGGERNAME          8
#define IDS_OPTION_LOGNAME              9
#define IDS_OPTION_ID                   10
#define IDS_OPTION_TYPE                 11
#define IDS_OPTION_SOURCE               12
#define IDS_OPTION_DESCRIPTION          13
#define IDS_OPTION_FORMAT               14
#define IDS_OPTION_NOHEADER             15
#define IDS_QUERY_DEFAULT               16
#define IDS_OPTION_VERBOSE              17
#define IDS_LOCAL_MAND_OPTIONS          20
#define IDS_LOCAL_FORMAT_STRING         21
#define IDS_QUERY_TYPE                  27
#define IDS_QUERY_ID                    28
#define IDS_QUERY_TRIGGERNAME           29
#define IDS_QUERY_LOGNAME               30
#define IDS_QUERY_SOURCENAME            31
#define IDS_QUERY_AND                   32
#define IDS_QUERY_EQ                    34

#define IDS_HELP_M1                     40
#define IDS_HELP_M2                     41
#define IDS_HELP_M3                     42
#define IDS_HELP_M4                     43
#define IDS_HELP_M5                     44
#define IDS_HELP_M6                     45
#define IDS_HELP_M7                     46
#define IDS_HELP_M8                     47
#define IDS_HELP_M9                     48
#define IDS_HELP_M10                    49
#define IDS_HELP_M11                    50
#define IDS_HELP_M12                    51
#define IDS_HELP_M13                    52
#define IDS_HELP_M14                    53
#define IDS_HELP_END                    54

#define IDS_HELP_C1                     60
#define IDS_HELP_C2                     61
#define IDS_HELP_C3                     62
#define IDS_HELP_C4                     63
#define IDS_HELP_C5                     64
#define IDS_HELP_C6                     65
#define IDS_HELP_C7                     66
#define IDS_HELP_C8                     67
#define IDS_HELP_C9                     68
#define IDS_HELP_C10                    69
#define IDS_HELP_C11                    70
#define IDS_HELP_C12                    71
#define IDS_HELP_C13                    72
#define IDS_HELP_C14                    73
#define IDS_HELP_C15                    74
#define IDS_HELP_C16                    75
#define IDS_HELP_C17                    76
#define IDS_HELP_C18                    77
#define IDS_HELP_C19                    78
#define IDS_HELP_C20                    79
#define IDS_HELP_C21                    80
#define IDS_HELP_C22                    81
#define IDS_HELP_C23                    82
#define IDS_HELP_C24                    83
#define IDS_HELP_C25                    84
#define IDS_HELP_C26                    85
#define IDS_HELP_C27                    86
#define IDS_HELP_C28                    87
#define IDS_HELP_C29                    88
#define IDS_HELP_C30                    89
#define IDS_HELP_C31                    90
#define IDS_HELP_C32                    91
#define IDS_HELP_C33                    92
#define IDS_HELP_C34                    93
#define IDS_HELP_C35                    94
#define IDS_HELP_C36                    95
#define IDS_HELP_C37                    96
#define IDS_HELP_C38                    97
#define IDS_HELP_C39                    98
#define IDS_HELP_C40                    99
#define IDS_HELP_C41                    100
#define IDS_HELP_C42                    101
#define IDS_HELP_C43                    102
#define IDS_HELP_C44                    103
#define IDS_HELP_C45                    104
#define IDS_HELP_C46                    105
#define IDS_HELP_C47                    106
#define IDS_HELP_C48                    107
#define IDS_HELP_C49                    108
#define IDS_HELP_C50                    109
#define IDS_HELP_C51                    110
#define IDS_HELP_C52                    111
#define IDS_HELP_C53                    112
#define IDS_HELP_C54                    113
#define IDS_HELP_CREATE_END             114

#define IDS_HELP_D1                     120
#define IDS_HELP_D2                     121
#define IDS_HELP_D3                     122
#define IDS_HELP_D4                     123
#define IDS_HELP_D5                     124
#define IDS_HELP_D6                     125
#define IDS_HELP_D7                     126
#define IDS_HELP_D8                     127
#define IDS_HELP_D9                     128
#define IDS_HELP_D10                    129
#define IDS_HELP_D11                    130
#define IDS_HELP_D12                    131
#define IDS_HELP_D13                    132
#define IDS_HELP_D14                    133
#define IDS_HELP_D15                    134
#define IDS_HELP_D16                    135
#define IDS_HELP_D17                    136 
#define IDS_HELP_D18                    137 
#define IDS_HELP_DELETE_END             138

#define IDS_HELP_Q1                     140
#define IDS_HELP_Q2                     141
#define IDS_HELP_Q3                     142
#define IDS_HELP_Q4                     143
#define IDS_HELP_Q5                     144
#define IDS_HELP_Q6                     145
#define IDS_HELP_Q7                     146
#define IDS_HELP_Q8                     147
#define IDS_HELP_Q9                     148
#define IDS_HELP_Q10                    149
#define IDS_HELP_Q11                    150
#define IDS_HELP_Q12                    151
#define IDS_HELP_Q13                    152
#define IDS_HELP_Q14                    153
#define IDS_HELP_Q15                    154
#define IDS_HELP_Q16                    155
#define IDS_HELP_Q17                    156
#define IDS_HELP_Q18                    157
#define IDS_HELP_Q19                    158
#define IDS_HELP_Q20                    159
#define IDS_HELP_Q21                    160
#define IDS_HELP_Q22                    161
#define IDS_HELP_Q23                    162
#define IDS_HELP_QUERY_END              163

#define IDS_INCORRECT_SYNTAX            201
#define IDS_TYPE_PASSWARD               202
#define IDS_LAST_CHAR                   203
#define IDS_CREATE_SUCCESS              204
#define IDS_HOSTNAME                    205
#define IDS_TRIGGER_ID                  206
#define IDS_TRIGGER_NAME                207
#define IDS_TASK                        208
#define IDS_EVENT_QUERY                 209
#define IDS_DESCRIPTION                 210
#define IDS_WIDTH_HOSTNAME              212
#define IDS_WIDTH_TRIGGER_ID            213
#define IDS_WIDTH_TRIGGER_NAME          214
#define IDS_WIDTH_TASK                  215
#define IDS_WIDTH_EVENT_QUERY           216
#define IDS_WIDTH_DESCRIPTION           217
#define IDS_DELETE_SUCCESS              219
#define IDS_EVENTS_WITH                 220
#define IDS_DELETE_ERROR                221
#define IDS_USERNAME_REQUIRED           222
#define IDS_DUPLICATE_TRG_NAME          223
#define IDS_STRING_TABLE                225
#define IDS_STRING_CSV                  226
#define IDS_STRING_LIST                 227
#define IDS_TYPE_OPTIONS                228
#define IDS_FORMAT_OPTIONS              229
#define IDS_NO_EVENTID                  230
#define IDS_NO_EVENT_FOUNT              231
#define IDS_LOG_NOT_EXISTS              232
#define IDS_ID_VALUE_OUT_OF_RANGE       233
#define IDS_ID_TYPE_SOURCE              234
#define IDS_ID_SHOW_ERROR               235
#define IDS_ID_DEFAULT_MISSING          236
#define IDS_DEFAULT_VALUES_ONCE         237
#define IDS_CLASS_NOT_REG               238
#define IDS_FAILURE_AUDIT               239
#define IDS_SUCCESS_AUDIT               240
#define IDS_AUDIT_FAILURE               241
#define IDS_AUDIT_SUCCESS               242 
#define IDS_ID_TRIG_NAME_MISSING        243
#define IDS_ACCESS_DENIED               244
#define IDS_INVALID_PARAMETER           245 
#define IDS_OUTOF_MEMORY                246
#define IDS_ERROR_USERNAME_EMPTY        248
#define IDS_ERROR_SERVERNAME_EMPTY      249
#define IDS_INVALID_ID                  250 
#define IDS_ID_TK_NAME_MISSING          251
#define IDS_ID_REQUIRED                 252 
#define IDS_ID_NON_NUMERIC              253
#define IDS_HEADER_NOT_ALLOWED          254
#define IDS_ERROR_USERNAME_BUT_NOMACHINE 255
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME 256
#define IDS_COM_ERROR                    259
#define IDS_ERROR_COM_ERROR              260 
#define IDS_ID_SOURCE_EMPTY              262
#define IDS_ID_DESC_EMPTY                263
#define IDS_ID_LOG_EMPTY                 264
#define IDS_ID_NA                        265
#define IDS_TYPE_HELP                    266
#define IDS_UTILITY_NAME                 267
#define IDS_ID_INVALID_TRIG_NAME         268
#define IDS_RUN_AS_USERNAME_REQUIRED     269
#define IDS_TASK_USERNAME                270
#define IDS_UNABLE_DELETE                271
#define IDS_ASK_PASSWORD                 272
#define IDS_WARNING_PASSWORD             273
#define IDS_ERROR_R_U_EMPTY              275
#define IDS_MSG_EVTRIG_C                 276
#define IDS_MSG_CONNECTING               277
#define IDS_MSG_EVTRIG_D                 278
#define IDS_MSG_EVTRIG_Q                 279
#define IDS_INVALID_R_U                  280
#define IDS_WARN_NULL_PASSWORD           283
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\showerror.cpp ===
/*****************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

  ShowError.CPP 

Abstract:

  This module  is intended to prepare  error messages.

Author:
  Akhil Gokhale 03-Oct.-2000 (Created it)

Revision History:

******************************************************************************/ 
#include "pch.h"
#include "ETCommon.h"
#include "ShowError.h"
#include "resource.h"

// ***************************************************************************
// Routine Description:
//	Class default constructor.	
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

CShowError::CShowError()
{
    m_lErrorNumber = 0;
}
// ***************************************************************************
// Routine Description:
//	Class constructor.	
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

CShowError::CShowError(LONG lErrorNumber)
{
    m_lErrorNumber = lErrorNumber;
}
// ***************************************************************************
// Routine Description:
//	Class default desctructor.
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

CShowError::~CShowError()
{

}
// ***************************************************************************
// Routine Description:
//	This function will return Text reason for given error code.
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************
LPCTSTR CShowError::ShowReason()
{
 
    __STRING_64 szTempStr = NULL_STRING; 
    BOOL bShowExtraMsg = TRUE;
    switch(m_lErrorNumber )
    {
    case MK_E_SYNTAX:
    case E_OUTOFMEMORY:
        {
            LPWSTR pwszTemp = NULL;
            lstrcpy(m_szErrorMsg,GetReason());
            bShowExtraMsg = FALSE;
        }
        break;
    case IDS_USERNAME_REQUIRED:
        lstrcpy(m_szErrorMsg,GetResString(IDS_USERNAME_REQUIRED));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ERROR_USERNAME_EMPTY:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ERROR_USERNAME_EMPTY));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ERROR_SERVERNAME_EMPTY:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ERROR_SERVERNAME_EMPTY));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_TRIG_NAME_MISSING:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_TRIG_NAME_MISSING));
        break;
    case IDS_ID_TYPE_SOURCE:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_TYPE_SOURCE));
        break;
    case IDS_INVALID_ID:
        lstrcpy(m_szErrorMsg,GetResString(IDS_INVALID_ID));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_TK_NAME_MISSING:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_TK_NAME_MISSING));
        break;
    case IDS_ID_REQUIRED:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_REQUIRED));
        break;
    case IDS_ID_NON_NUMERIC:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_NON_NUMERIC));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_HEADER_NOT_ALLOWED:
        lstrcpy(m_szErrorMsg,GetResString(IDS_HEADER_NOT_ALLOWED));
        break;
    case IDS_ERROR_USERNAME_BUT_NOMACHINE:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ERROR_USERNAME_BUT_NOMACHINE));
        bShowExtraMsg = FALSE;
        break;
    case IDS_ID_SOURCE_EMPTY:
       lstrcpy(m_szErrorMsg,GetResString(IDS_ID_SOURCE_EMPTY));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_DESC_EMPTY:
       lstrcpy(m_szErrorMsg,GetResString(IDS_ID_DESC_EMPTY));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_LOG_EMPTY:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_LOG_EMPTY));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_ID_INVALID_TRIG_NAME:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ID_INVALID_TRIG_NAME));
        g_dwOptionFlag = FALSE;
        break;
    case IDS_RUN_AS_USERNAME_REQUIRED:
        lstrcpy(m_szErrorMsg,GetResString(IDS_RUN_AS_USERNAME_REQUIRED));
        g_dwOptionFlag = FALSE;
		break;
     case IDS_ERROR_R_U_EMPTY:
        lstrcpy(m_szErrorMsg,GetResString(IDS_ERROR_R_U_EMPTY));
        g_dwOptionFlag = FALSE;

     default:
        break;
    }
    if(bShowExtraMsg)
    {
       __STRING_64 szStr = NULL_STRING; ;
       lstrcpy(szStr,GetResString(IDS_UTILITY_NAME));

		switch(g_dwOptionFlag)
        {

		    case 0:
                lstrcpy(szTempStr,NULL_STRING);
                break;
            case 1:
                wsprintf(szTempStr,GetResString(IDS_TYPE_HELP),szStr,OPTION_CREATE);
                break;
            case 2:
                wsprintf(szTempStr,GetResString(IDS_TYPE_HELP),szStr,OPTION_DELETE);
                break;
            case 3:
               wsprintf(szTempStr,GetResString(IDS_TYPE_HELP),szStr,OPTION_QUERY);
                break;
            default:
                break;
        }
    }
    lstrcat(m_szErrorMsg,szTempStr);
    return m_szErrorMsg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\showerror.h ===
/*****************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name:

    ShowError.h

Abstract:

  This module  contanins function definations required by ShowError.cpp

Author:
     Akhil Gokhale 03-Oct.-2000

Revision History:


*******************************************************************************/ 

#ifndef SHOWERROR_H 
#define SHOWERROR_H 
class CShowError  
{

public:
	LPCTSTR ShowReason();
	CShowError();
    CShowError(LONG lErrorNumber);
	virtual ~CShowError();

private:
	LONG m_lErrorNumber;
public:
    TCHAR m_szErrorMsg[(MAX_RES_STRING*2)+1];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\eventtriggers.cpp ===
//*****************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		EventTriggers.cpp
//  
//  Abstract:
//  
// 		This module implements the command-line parsing to create/delete/query 
//		EventTriggers on  current running on local and remote systems.
//
//  
//  Author:
//  
// 		Akhil V. Gokhale (akhil.gokhale@wipro.com)
//  
//  Revision History:
//  
// 		Akhil V. Gokhale (akhil.gokhale@wipro.com)
//  
//*****************************************************************************
#include "pch.h"
#include "ETCommon.h"
#include "EventTriggers.h"
#include "ShowError.h"
#include "ETCreate.h"
#include "ETDelete.h"
#include "ETQuery.h"
DWORD      g_dwOptionFlag;

// ***************************************************************************
// Routine Description:
//		This module reads the input from commond line and calls appropriate
//      functions to achive to functionality of EventTrigger-Client.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//
// Return Value:
//		The below are actually not return values but are the exit values 
//		returned to the OS by this application
//			0		: utility is successfull
//			1		: utility failed
// ***************************************************************************
DWORD __cdecl 
_tmain( DWORD argc, LPCTSTR argv[] )
{
	// local variables
    CEventTriggers eventTriggers; 
	BOOL bResult = DIRTY_EXIT; // Programs return value status variable.
    g_dwOptionFlag = 0;
    TCHAR szErrorMsg[(MAX_RES_STRING*2)+1];
	try
    {
        if(argc == 1)
        {
            if(IsWin2KOrLater()==FALSE)
			{
                TCHAR szErrorMsg[(MAX_RES_STRING*2)+1];
                TCHAR szErrorMsg1[(MAX_RES_STRING*2)+1];
                lstrcpy(szErrorMsg1,ERROR_OS_INCOMPATIBLE);
                DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                                  szErrorMsg1);
			}
			else
			{
			
				// If no command line parameter is given then  -query option
				// will be taken as default.
                g_dwOptionFlag = 3;
				CETQuery etQuery(MAX_RES_STRING,
								 FALSE);
				etQuery.Initialize();// Initializes variables.
			   // execute query method to query EventTriggers in WMI.                                  
				if(etQuery.ExecuteQuery () == TRUE)
				{
					// as ExecuteQuery routine returns with TRUE, 
					// exit from program with error level CLEAN_EXIT
					bResult = CLEAN_EXIT;
				}
			}
        }
        else
        {
            // Calculates minimum memory required for allocating memory to 
            // various variables.
            eventTriggers.CalcMinMemoryReq (argc,argv);
            // As commandline parameter is specified so command parscing will 
            // required.
            // Initialize variables for eventTriggers object.
            eventTriggers.Initialize ();
            // Process command line parameters.
            eventTriggers.ProcessOption(argc,argv);
            if(eventTriggers.IsUsage () == TRUE) //if usage option is selected
            {
                if(eventTriggers.IsCreate () ==TRUE)
                {
                    eventTriggers.ShowCreateUsage ();//Display create usage
                }
                else if(eventTriggers.IsDelete () ==TRUE)
                {
                    eventTriggers.ShowDeleteUsage ();//Display delete usage
                }
                else if(eventTriggers.IsQuery () ==TRUE)
                {
                    eventTriggers.ShowQueryUsage ();//Display query usage
                }
                else
                {
                    eventTriggers.ShowMainUsage ();//Display main usage
                }
                bResult = CLEAN_EXIT;
            }
            else if(eventTriggers.IsCreate () == TRUE)//if user selected create
            {
                
                // creates a object of type CETCreate.
                g_dwOptionFlag = 1;//for create option
                CETCreate etCreate(eventTriggers.GetMinMemoryReq(),
                                   eventTriggers.GetNeedPassword());
                etCreate.Initialize ();// Initializes variables.
                // Process command line argument for -create option.     
                etCreate.ProcessOption (argc,argv);
                // execute create method to create EventTriggers in WMI.                                  
                if(etCreate.ExecuteCreate ()== TRUE)
                {
                    // as ExecuteCreate routine returns with TRUE, 
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
            else if(eventTriggers.IsDelete () == TRUE)//if user selected delete
            {
                // creates a object of type CETDelete. 
                g_dwOptionFlag = 2;//for create option
                CETDelete  etDelete(eventTriggers.GetMinMemoryReq (),
                                    eventTriggers.GetNeedPassword());
                etDelete.Initialize ();// Initializes variables.
                // Process command line argument for -delete option.     
                etDelete.ProcessOption (argc,argv);
                // execute delete method to delete EventTriggers in WMI.                                  
                if(etDelete.ExecuteDelete ()==TRUE)
                {
                    // as ExecuteDelete routine returns with TRUE, 
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            } 
            else if(eventTriggers.IsQuery () == TRUE)//if user selected -query.
            {
                // creates a object of type CETQuery. 
                g_dwOptionFlag = 3;//for create option
                CETQuery etQuery(eventTriggers.GetMinMemoryReq (),
                                 eventTriggers.GetNeedPassword ());
                etQuery.Initialize();// Initializes variables.
                // Process command line argument for -Query option.     
                etQuery.ProcessOption(argc,argv);
                // execute query method to query EventTriggers in WMI.                                  
                if(etQuery.ExecuteQuery ()== TRUE)
                {
                    // as ExecuteQuery routine returns with TRUE, 
                    // exit from program with error level CLEAN_EXIT
                    bResult = CLEAN_EXIT;
                }
            }
            else
            {
                // Although this condition will never occure, for safe side
                // show error message as "ERROR: Invalid Syntax. 
                TCHAR szTemp[(MAX_RES_STRING*2)+1]; 
                wsprintf(szTemp,GetResString(IDS_INCORRECT_SYNTAX),argv[0]);
                SetReason(szTemp);
                throw CShowError(MK_E_SYNTAX);
            }
        } // End else
    }// try block
    catch(CShowError se)
    {
        // Show Error message on screen depending on value passed through
        // through machanism.
        DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                          se.ShowReason());
    }
    catch(CHeap_Exception ch)
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        DISPLAY_MESSAGE2( stderr, szErrorMsg, L"%s %s", TAG_ERROR, 
                          GetReason());
    }
    // Returns from program with error level stored in bResult.
	ReleaseGlobals();
    return bResult;
}

// ***************************************************************************
// Routine Description:
//		CEventTriggers contructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CEventTriggers::CEventTriggers()
{
	// init to defaults
    m_pszServerNameToShow = NULL;
	m_bNeedDisconnect     = FALSE;

    m_bNeedPassword       = FALSE;
	m_bUsage              = FALSE;
    m_bCreate             = FALSE;
    m_bDelete             = FALSE;
    m_bQuery              = FALSE;
    
    m_arrTemp             = NULL;
    
    m_lMinMemoryReq       = MIN_MEMORY_REQUIRED;
}

// ***************************************************************************
// Routine Description:
//		CEventTriggers destructor
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
CEventTriggers::~CEventTriggers()
{
	//
	// de-allocate memory allocations
	//
    DESTROY_ARRAY(m_arrTemp);
}

// ***************************************************************************
// Routine Description:
//		initialize the EventTriggers utility
//		  
// Arguments:
//		NONE
//  
// Return Value:
//		NONE
// 
// ***************************************************************************
void 
CEventTriggers::Initialize()
  {
    // local variables
    LONG lTemp = 0;

    // if at all any occurs, we know that is because of the 
	// failure in memory allocation ... so set the error
	SetLastError( E_OUTOFMEMORY );
	SaveLastError();
 
    // Allocates memory
    m_arrTemp = CreateDynamicArray();
    if(m_arrTemp == NULL)
    {
        // error occures while allocating required memory, so throw
        // exception.
        throw CShowError(E_OUTOFMEMORY);
    }
    // initialization is successful
	SetLastError( NOERROR );			// clear the error
	SetReason( NULL_STRING );			// clear the reason

}
// ***************************************************************************
// Routine Description:
//		This function will calculate minimum memory requirement value needed 
//    to allocated for various string variables.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//  
// Return Value:
//		NONE
// 
// ***************************************************************************

void 
CEventTriggers::CalcMinMemoryReq(DWORD argc, LPCTSTR argv[])
{
    // local variables
    DWORD dwIndx = 0;   // Index variable;
    DWORD dwStrLen = 0; // String length
    
    // Calculate minimum memory required based on length maximum of maximum
    // command line parameter passed.
    for(dwIndx = 0 ; dwIndx <argc; dwIndx++)
    {
        dwStrLen = lstrlen(argv [dwIndx]);
        if(m_lMinMemoryReq <lstrlen(argv [dwIndx]))
            m_lMinMemoryReq = lstrlen(argv [dwIndx]);
    }
    
}
// ***************************************************************************
// Routine Description:
//		This function will process/parce the command line options.
//		  
// Arguments:
//		[ in ] argc		: argument(s) count specified at the command prompt
//		[ in ] argv		: argument(s) specified at the command prompt
//  
// Return Value:
//		TRUE  : On Successful
//      FALSE : On Error
// 
// ***************************************************************************

BOOL 
CEventTriggers::ProcessOption(DWORD argc, LPCTSTR argv[])
{
    // local variable
    BOOL bReturn = TRUE;// stores return value of function.
    TCHAR szTemp[MAX_RES_STRING]; 
    TCHAR szStr [MAX_RES_STRING];
    lstrcpy(szStr,GetResString(IDS_UTILITY_NAME));
    wsprintf(szTemp,GetResString(IDS_INCORRECT_SYNTAX),
                    szStr);
    PrepareCMDStruct();
    // do the actual parsing of the command line arguments and check the result
    bReturn = DoParseParam( argc, argv, MAX_COMMANDLINE_OPTION, cmdOptions );

    if(bReturn==FALSE)
    {
        // Command line contains invalid parameter(s) so throw exception for
        // invalid syntax.
        // Valid reason already set in DoParceParam,.
        throw CShowError(MK_E_SYNTAX);
    }

    if((m_bUsage==TRUE)&&argc>3)
    {
		// Only one  option can be accepted along with -? option
        // Example: EvTrig.exe -? -query -nh should be invalid.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    if((m_bCreate+m_bDelete+m_bQuery)>1)
    {
        // Only ONE OF  the -create -delete and -query can be given as 
        // valid command line parameter.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    else if((argc == 2)&&(m_bUsage == TRUE))
    {
       // if -? alone given its a valid conmmand line
        bReturn = TRUE;
    }
    else if((argc>=2)&& (m_bCreate==FALSE)&&(m_bDelete==FALSE)&&(m_bQuery==FALSE))
    {
        // If command line argument is equals or greater than 2 atleast one 
        // of -query OR -create OR -delete should be present in it.
        // (for "-?" previous condition already takes care)
        // This to prevent from following type of command line argument:
        // EvTrig.exe -nh ... Which is a invalid syntax.
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);

    }

   // Following checking done if user given command like
    // -? -nh OR -? -v , its an invalid syntax.
    else if((m_bUsage==TRUE)&&(m_bCreate == FALSE)&&
        (m_bDelete == FALSE)&&(m_bQuery  == FALSE)&&
        (argc == 3))
    {
        SetReason(szTemp);
        throw CShowError(MK_E_SYNTAX);
    }
    // Any how following variables do not required.
    DESTROY_ARRAY(m_arrTemp);
    return bReturn;

}
// ***************************************************************************
// Routine Description:
//		This function will prepare column structure for DoParseParam Function.
//		  
// Arguments:
//       none
// Return Value:
//       none
// ***************************************************************************

void 
CEventTriggers::PrepareCMDStruct()
{
  
    // Filling cmdOptions structure 
    // -? 
    lstrcpy(cmdOptions[ ID_HELP ].szOption,OPTION_HELP);
    cmdOptions[ ID_HELP ].dwFlags = CP_USAGE;
    cmdOptions[ ID_HELP ].dwCount = 1;
    cmdOptions[ ID_HELP ].dwActuals = 0;
    cmdOptions[ ID_HELP ].pValue    = &m_bUsage;
    lstrcpy(cmdOptions[ ID_HELP ].szValues,NULL_STRING);
    cmdOptions[ ID_HELP ].pFunction = NULL;
    cmdOptions[ ID_HELP ].pFunctionData = NULL;

   // -create
    lstrcpy(cmdOptions[ ID_CREATE ].szOption,OPTION_CREATE);
    cmdOptions[ ID_CREATE ].dwFlags = 0;
    cmdOptions[ ID_CREATE ].dwCount = 1;
    cmdOptions[ ID_CREATE ].dwActuals = 0;
    cmdOptions[ ID_CREATE ].pValue    = &m_bCreate;
    lstrcpy(cmdOptions[ ID_CREATE ].szValues,NULL_STRING);
    cmdOptions[ ID_CREATE ].pFunction = NULL;
    cmdOptions[ ID_CREATE ].pFunctionData = NULL;
    cmdOptions[ ID_CREATE ].pFunctionData = NULL;

    // -delete
    lstrcpy(cmdOptions[ ID_DELETE ].szOption,OPTION_DELETE);
    cmdOptions[ ID_DELETE ].dwFlags = 0;
    cmdOptions[ ID_DELETE ].dwCount = 1;
    cmdOptions[ ID_DELETE ].dwActuals = 0;
    cmdOptions[ ID_DELETE ].pValue    = &m_bDelete;
    lstrcpy(cmdOptions[ ID_DELETE ].szValues,NULL_STRING);
    cmdOptions[ ID_DELETE ].pFunction = NULL;
    cmdOptions[ ID_DELETE ].pFunctionData = NULL;

    // -query
    lstrcpy(cmdOptions[ ID_QUERY ].szOption,OPTION_QUERY);
    cmdOptions[ ID_QUERY ].dwFlags = 0;
    cmdOptions[ ID_QUERY ].dwCount = 1;
    cmdOptions[ ID_QUERY ].dwActuals = 0;
    cmdOptions[ ID_QUERY ].pValue    = &m_bQuery;
    lstrcpy(cmdOptions[ ID_QUERY ].szValues,NULL_STRING);
    cmdOptions[ ID_QUERY ].pFunction = NULL;
    cmdOptions[ ID_QUERY ].pFunctionData = NULL;

     
  //  default ..
  // Although there is no default option for this utility... 
  // At this moment all the switches other than specified above will be 
  // treated as default parameter for Main DoParceParam. 
  // Exact parcing depending on optins (-create -query or -delete) will be done 
  // at that respective places.
    lstrcpy(cmdOptions[ ID_DEFAULT ].szOption,NULL_STRING);
    cmdOptions[ ID_DEFAULT ].dwFlags = CP_TYPE_TEXT | CP_MODE_ARRAY|CP_DEFAULT;
    cmdOptions[ ID_DEFAULT ].dwCount = 0;
    cmdOptions[ ID_DEFAULT ].dwActuals = 0;
    cmdOptions[ ID_DEFAULT ].pValue    = &m_arrTemp;
    lstrcpy(cmdOptions[ ID_DEFAULT ].szValues,NULL_STRING);
    cmdOptions[ ID_DEFAULT ].pFunction = NULL;
    cmdOptions[ ID_DEFAULT ].pFunctionData = NULL;
}
//***************************************************************************
// Routine Description:
//		Displays Eventriggers main usage
//		  
// Arguments:
//      None  
// Return Value:
//		None
// 
//***************************************************************************

void 
CEventTriggers::ShowMainUsage()
{
	// Displaying main usage
    for(DWORD dwIndx=IDS_HELP_M1;dwIndx<=IDS_HELP_END;dwIndx++)
    {
      ShowMessage(stdout,GetResString(dwIndx));
    }
}
//***************************************************************************
// Routine Description:
//		Returns Minimum memory required.
//		  
// Arguments:
//      None  
// Return Value:
//		LONG
// 
//***************************************************************************

LONG 
CEventTriggers::GetMinMemoryReq()
{
    return m_lMinMemoryReq;
}
//***************************************************************************
// Routine Description:
//		Returns whether to ask for password or not.
//		  
// Arguments:
//      None  
// Return Value:
//		BOOL
// 
//***************************************************************************
BOOL 
CEventTriggers::GetNeedPassword()
{
    return m_bNeedPassword;
}
//***************************************************************************
// Routine Description:
//		Returns if create option is selected.
//		  
// Arguments:
//      None  
// Return Value:
//		BOOL
// 
//***************************************************************************

BOOL
CEventTriggers::IsCreate()
{
    return m_bCreate;
}
//***************************************************************************
// Routine Description:
//		Returns if usage option is selected.		
//		  
// Arguments:
//      None  
// Return Value:
//		BOOL
// 
//***************************************************************************

BOOL
CEventTriggers::IsUsage()
{
    return m_bUsage;
}
//***************************************************************************
// Routine Description:
//		Returns if delete option is selected.		
//		  
// Arguments:
//      None  
// Return Value:
//		BOOL
// 
//***************************************************************************

BOOL 
CEventTriggers::IsDelete()
{
    return m_bDelete;
}
//***************************************************************************
// Routine Description:
//		Returns if Query option is selected.		
//		  
// Arguments:
//      None  
// Return Value:
//		BOOL
// 
//***************************************************************************

BOOL 
CEventTriggers::IsQuery()
{
    return m_bQuery;
}
/*****************************************************************************

Routine Description

    This function shows help message for EventTriggers utility for 
    -create operation 

Arguments:
    NONE

Return Value 			 
    None    
*****************************************************************************/

void 
CEventTriggers::ShowCreateUsage()
{
	// Displaying Create usage
    for(int iIndx=IDS_HELP_C1;iIndx<=IDS_HELP_CREATE_END;iIndx++)
    {
       ShowMessage(stdout,GetResString(iIndx));
    }
}
/*****************************************************************************

Routine Description

    This function shows help message for EventTriggers utility for 
    -delete operation 

Arguments:
    NONE

Return Value 			 
    None    
******************************************************************************/

void 
CEventTriggers::ShowDeleteUsage()
{
    for(int iIndx=IDS_HELP_D1;iIndx<=IDS_HELP_DELETE_END;iIndx++)
    {
       ShowMessage(stdout,GetResString(iIndx));
    }

}
/*****************************************************************************
Routine Description

    This function shows help message for EventTriggers utility for 
    -query operation 

Arguments:
    NONE

Return Value 			 
    None    
******************************************************************************/

void 
CEventTriggers::ShowQueryUsage()
{
    for(int iIndx=IDS_HELP_Q1;iIndx<=IDS_HELP_QUERY_END;iIndx++)
    {
        ShowMessage(stdout,GetResString(iIndx));
    }
}

//***************************************************************************
// Routine Description:
//		Get the value of a property for the given instance .
//                         
// Arguments:
//		pWmiObject[in] - A pointer to wmi class.
//		szProperty [in] - property name whose value to be returned.
//		dwType [in] - Data Type of the property.
//		pValue [in/out] - Variable to hold the data.
//		dwSize [in] - size of the variable.
//
// Return Value:
//		HRESULT value.
//***************************************************************************
HRESULT PropertyGet1( IWbemClassObject* pWmiObject, 
					 LPCTSTR szProperty, 
					 DWORD dwType, LPVOID pValue, DWORD dwSize )
{
	// local variables
	HRESULT hr = S_OK;
	VARIANT varValue;
	LPWSTR pwszValue = NULL;
	WCHAR wszProperty[ MAX_STRING_LENGTH ] = L"\0";

	// value should not be NULL
	if ( pValue == NULL )
	{
		return S_FALSE;
	}
	// initialize the values with zeros ... to be on safe side
	memset( pValue, 0, dwSize );
	memset( wszProperty, 0, MAX_STRING_LENGTH );

	// get the property name in UNICODE version
	GetAsUnicodeString( szProperty, wszProperty, MAX_STRING_LENGTH );

	// initialize the variant and then get the value of the specified property
	VariantInit( &varValue );
	hr = pWmiObject->Get( wszProperty, 0, &varValue, NULL, NULL );
	if ( FAILED( hr ) )
	{
		// clear the variant variable
		VariantClear( &varValue );
		// failed to get the value for the property
		return hr;
	}

	// get and put the value 
	switch( varValue.vt )
	{
	case VT_EMPTY:
	case VT_NULL:
		break;
	
	case VT_I2:
		*( ( short* ) pValue ) = V_I2( &varValue );
		break;
	
	case VT_I4:
		*( ( long* ) pValue ) = V_I4( &varValue );
		break;
	
	case VT_R4:
		*( ( float* ) pValue ) = V_R4( &varValue );
		break;

	case VT_R8:
		*( ( double* ) pValue ) = V_R8( &varValue );
		break;


	case VT_UI1:
		*( ( UINT* ) pValue ) = V_UI1( &varValue );
		break;

	case VT_BSTR:
		{
			// get the unicode value
			pwszValue = V_BSTR( &varValue );

			// get the comptable string
			if(GetCompatibleStringFromUnicode( pwszValue, ( LPTSTR ) pValue, dwSize )==NULL)
            {
               return S_FALSE;
            }

			break;
		}
	}

	// clear the variant variable
	if(FAILED(VariantClear( &varValue )))
    {
        return S_FALSE;
    }

	// inform success
	return S_OK;
}
/*****************************************************************************
Routine Description:


Arguments:


  result.

Return Value: 
   
******************************************************************************/

void PrintProgressMsg(HANDLE hOutput,LPCWSTR pwszMsg,const CONSOLE_SCREEN_BUFFER_INFO& csbi)
{
    COORD coord;
    DWORD dwSize = 0;
    WCHAR wszSpaces[80] = L"";

    if(hOutput == NULL)
        return;

    coord.X = 0;
	coord.Y = csbi.dwCursorPosition.Y;

	ZeroMemory(wszSpaces,80);
	SetConsoleCursorPosition(hOutput,coord);
	WriteConsoleW(hOutput,Replicate(wszSpaces,L"",79),79,&dwSize,NULL);

	SetConsoleCursorPosition(hOutput,coord);

	if(pwszMsg!=NULL)
		WriteConsoleW(hOutput,pwszMsg,lstrlen(pwszMsg),&dwSize,NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\wmi.cpp ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//  
//		WMI.cpp
//  
//  Abstract:
//  
// 		Common functionlity for dealing with WMI
//  
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#include "pch.h"
#include "wmi.h"
#include "resource.h"

//
// messages
//
#define INPUT_PASSWORD		GetResString( IDS_STR_INPUT_PASSWORD )

// error constants
#define E_SERVER_NOTFOUND			0x800706ba

//
// private function prototype(s)
//
BOOL IsValidUserEx( LPCWSTR pwszUser );
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity );
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities );
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent );
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue );

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;
	LONG lPos = 0;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
			return FALSE;

		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
			return FALSE;

		// SPECIAL CHECK
		// check for multiple '\' characters in the user name
		lPos = strUser.Find( L'\\' );
		if ( lPos != -1 )
		{
			// '\' character exists in the user name
			// strip off the user info upto first '\' character
			// check for one more '\' in the remaining string
			// if it exists, invalid user
			strUser = strUser.Mid( lPos + 1 );
			lPos = strUser.Find( L'\\' );
			if ( lPos != -1 )
				return FALSE;
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem )
{
	// local variables
	CHString strTemp;

	// kick-off
	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
			return FALSE;
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
		return FALSE;

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
			return FALSE;

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// inform that server name is valid
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL InitializeCom( IWbemLocator** ppLocator )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;

	try
	{
		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// initialize the COM library
		SAFE_EXECUTE( CoInitializeEx( NULL, COINIT_APARTMENTTHREADED ) );

		// initialize the security
		SAFE_EXECUTE( CoInitializeSecurity( NULL, -1, NULL, NULL,
			RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, 0 ) );

		// create the locator and get the pointer to the interface of IWbemLocator
		SAFE_RELEASE( *ppLocator );			// safe side
		SAFE_EXECUTE( CoCreateInstance( CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, 
			IID_IWbemLocator, ( LPVOID* ) ppLocator ) );

		// initialization successful
		bResult = TRUE;
	}
	catch( _com_error& e )
	{
		// save the WMI error
		WMISaveError( e );
	}

	// return the result;
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, BOOL bCheckWithNullPwd, 
				 LPCWSTR pwszNamespace, HRESULT* phr, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser, bstrPassword;

	// kick-off
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = FALSE;

	// ...
	if ( phr != NULL )
		*phr = NO_ERROR;

	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not
		// if not exists, return
		if ( pLocator == NULL )
		{
			if ( phr != NULL )
				*phr = WBEM_E_INVALID_PARAMETER;

			// return failure
			return FALSE;
		}

		// validate the server name
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
			_com_issue_error( ERROR_BAD_NETPATH );

		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
			_com_issue_error( ERROR_NO_SUCH_USER );

		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			else
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
					bstrPassword = (LPWSTR) NULL;
			}
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hr = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hr ) )
		{
			//
			// special case ...

			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			if ( hr == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hr = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hr == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hr = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
			}

			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hr ) )
				_com_issue_error( hr );
			else
				bstrPassword = L"";
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;

		// save the hr value if needed by the caller
		if ( phr != NULL )
			*phr = WBEM_S_NO_ERROR;
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phr != NULL )
			*phr = e.Error();
	}

	// ...
	if ( pbLocalSystem != NULL )
		*pbLocalSystem = bLocalSystem;

	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, 
				   BOOL bNeedPassword, LPCWSTR pwszNamespace, BOOL* pbLocalSystem )
{
	// local variables
	HRESULT hr;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;
	CHString strBuffer = NULL_STRING;

	// clear the error .. if any
	SetLastError( WBEM_S_NO_ERROR );

	// sometime users want the utility to prompt for the password
	// check what user wants the utility to do
	if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password
		// so skip this part and let the flow directly jump the password acceptance part
	}
	else
	{
		// try to establish connection to the remote system with the credentials supplied
		if ( strUserName.GetLength() == 0 )
		{
			// user name is empty
			// so, it is obvious that password will also be empty
			// even if password is specified, we have to ignore that
			bResult = ConnectWmi( pLocator, ppServices, 
				pwszServer, NULL, NULL, ppAuthIdentity, FALSE, pwszNamespace, &hr, pbLocalSystem );
		}
		else
		{
			// credentials were supplied
			// but password might not be specified ... so check and act accordingly
			LPCWSTR pwszTemp = NULL;
			BOOL bCheckWithNull = TRUE;
			if ( bNeedPassword == FALSE )
			{
				pwszTemp = strPassword;
				bCheckWithNull = FALSE;
			}

			// ...
			bResult = ConnectWmi( pLocator, ppServices, pwszServer,
				strUserName, pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hr, pbLocalSystem );
		}

		// check the result ... if successful in establishing connection ... return
		if ( bResult == TRUE )
			return TRUE;

		// now check the kind of error occurred
		switch( hr )
		{
		case E_ACCESSDENIED:
			break;

		case WBEM_E_LOCAL_CREDENTIALS:
			// needs to do special processing
			break;

		case WBEM_E_ACCESS_DENIED:
		default:
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'
			WMISaveError( hr );
			return FALSE;		// no use of accepting the password .. return failure
			break;
		}

		// if failed in establishing connection to the remote terminal
		// even if the password is specifed, then there is nothing to do ... simply return failure
		if ( bNeedPassword == FALSE )
			return FALSE;
	}

	// check whether user name is specified or not
	// if not, get the local system's current user name under whose credentials, the process
	// is running
	if ( strUserName.GetLength() == 0 )
	{
		// sub-local variables
		LPWSTR pwszUserName = NULL;

		try
		{
			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
			return FALSE;
		}

		// get the user name
		DWORD dwUserLength = MAX_STRING_LENGTH;
		if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
		{
			// error occured while trying to get the current user info
			SaveLastError();
			return FALSE;
		}

		// release the extra buffer allocated
		strUserName.ReleaseBuffer();
	}

	try
	{
		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// accept the password from the user
	strBuffer.Format( INPUT_PASSWORD, strUserName );
	WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
		strBuffer, strBuffer.GetLength(), &dwSize, NULL );
	GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

	// release the buffer allocated for password
	strPassword.ReleaseBuffer();

	// now again try to establish the connection using the currently
	// supplied credentials
	bResult = ConnectWmi( pLocator, ppServices, pwszServer,
		strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, NULL, pbLocalSystem );

	// return the failure
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown* pInterface, 
							  DWORD& dwAuthorization, DWORD& dwAuthentication )
{
	// local variables
	HRESULT hr;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity* pClientSecurity = NULL;

	// try to get the client security services values if possible
	hr = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hr ) )
	{
		// got the client security interface
		// now try to get the security services values
		hr = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hr ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFE_RELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, 
							  LPCWSTR pwszServer, LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword, COAUTHIDENTITY** ppAuthIdentity )
{
	// local variables
	HRESULT hr;
	CHString strUser;
	CHString strDomain;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// check the authentity strcuture ... if authentity structure is already ready
	// simply invoke the 2nd version of SetInterfaceSecurity
	if ( *ppAuthIdentity != NULL )
		return SetInterfaceSecurity( pInterface, *ppAuthIdentity );

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

    // If we are doing trivial case, just pass in a null authenication structure 
    // for which the current logged in user's credentials will be considered
	if ( pwszUser == NULL && pwszPassword == NULL )
	{
		// set the security
		hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
			NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

		// return the result
		return hr;
	}

	// parse and find out if the user name contains the domain name
	// if contains, extract the domain value from it
	LONG lPos = -1;
	strDomain = L"";
	strUser = pwszUser;
	if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
	{
		// user name contains domain name ... domain\user format
		strDomain = strUser.Left( lPos );
		strUser = strUser.Mid( lPos + 1 );
	}
	else if ( ( lPos = strUser.Find( L'@' ) ) != -1 )
	{
		// NEED TO IMPLEMENT THIS ... IF NEEDED
	}
	else
	{
		// server itself is the domain
		// NOTE: NEED TO DO SOME R & D ON BELOW COMMENTED LINE
		// strDomain = pwszServer;
	}

	// get the domain info if it exists only
	if ( strDomain.GetLength() != 0 )
		pwszDomainArg = strDomain;

	// get the user info if it exists only
	if ( strUser.GetLength() != 0 )
		pwszUserArg = strUser;

	// check if authenication info is available or not ...
	// initialize the security authenication information ... UNICODE VERSION STRUCTURE
	if ( ppAuthIdentity == NULL )
        return WBEM_E_INVALID_PARAMETER;
	else if ( *ppAuthIdentity == NULL )
	{
		hr = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
		if ( hr != S_OK )
			return hr;
	}

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
		return WBEM_E_INVALID_PARAMETER;

	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hr = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown* pInterface,
							    DWORD dwAuthnSvc, DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal, DWORD dwAuthLevel, DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities )
{
	// local variables
	HRESULT hr;
    IUnknown * pUnknown = NULL;
    IClientSecurity * pClientSecurity = NULL;

	// get the IUnknown interface ... to check whether this is a valid interface or not
    hr = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hr != S_OK )
        return hr;

	// now get the client security interface
    hr = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hr != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hr;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
        pAuthInfo = NULL;

	// now set the security
    hr = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hr = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hr == S_OK )
        {
			// set security authentication
            hr = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hr == E_NOINTERFACE )
            hr = S_OK;		// ignore no interface errors
    }

	// release the IUnknown
	SAFE_RELEASE( pUnknown );

	// return the result
    return hr;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser, LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain, COAUTHIDENTITY** ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY* pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
        return WBEM_E_INVALID_PARAMETER;

    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
        return WBEM_E_OUT_OF_MEMORY;

	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->User );

		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Password );

		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
            CoTaskMemFree( (*ppAuthIdentity)->Domain );

        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
VOID WMISaveError( HRESULT hrError )
{
	// local variables
	HRESULT hr;
	CHString strBuffer = NULL_STRING;
	IWbemStatusCodeText* pWbemStatus = NULL;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hrError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hrError == E_ACCESSDENIED )
				hrError = ERROR_LOGON_FAILURE;

			// ...
			SetLastError( hrError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hr = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, (LPVOID*) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hr ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hr = pWbemStatus->GetErrorCodeText( hrError, 0, 0, &bstr );
			if ( SUCCEEDED( hr ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );
				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
					lstrcatW( pwszTemp, L"." );

				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hrError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hrError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
				strBuffer = e.ErrorMessage();
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}

	// set the reason
	strBuffer += L"\n";
	SetReason( strBuffer );
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, VARIANT* pvarValue )
{
	// local variables
	HRESULT hr;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( pvarValue );

			// failed to get the value for the property
			return hr;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		VariantInit( &vtValue );
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( &vtValue );

			// failed to get the value for the property
			return hr;
		}

		// set the value
		varValue = vtValue;

		// clear the variant variable
		VariantClear( &vtValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first copy the default value
	strValue = pwszDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	try
	{
		// get the value
		if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( var );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] pwszProperty		: property name
//		[ out ] pdwValue		: value of the property
//		[ in ] dwDefault		: default in case failed in getting property value
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first set the defaul value
	dwValue = dwDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	// get the process id from the variant
	if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
		dwValue = (LONG) var;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
	// local variables
	CHString str;

	// first set the default value
	ullValue = 1;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	// get the 64-bit value
	ullValue = _wtoi64( str );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
	// local variables
	CHString str;

	// Clear method sets the time in the WBEMTime object to an invalid time.
	wbemtime.Clear();

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
		return FALSE;

	try
	{
		// convert into the time value
		wbemtime = _bstr_t( str );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
	// local variables
	CHString strTime;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	// 16010101000000.000000+000 is the default time
	if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
		return FALSE;

	// prepare the systemtime structure
	// yyyymmddHHMMSS.mmmmmmsUUU
	systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
	systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
	systime.wDayOfWeek = 0;
	systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
	systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
	systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
	systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
	systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;
	LONG lIndex = 0;
	LONG lLBound = 0;
	LONG lUBound = 0;
	VARTYPE vartype;
	SAFEARRAY* pSafeArray = NULL;

	// check the inputs
	if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
		return FALSE;

	// initialize the variant
	VariantInit( &vtValue );

	// now get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
	if ( FAILED( hr ) )
		return FALSE;

	if ( V_VT( &vtValue ) == VT_NULL )
		return TRUE;

		// confirm that the propety value is of array type .. if not return
	if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
		return FALSE;

	// get the safearray value
	pSafeArray = V_ARRAY( &vtValue );

	// get the bounds of the array
    SafeArrayGetLBound( pSafeArray, 1, &lLBound );
    SafeArrayGetUBound( pSafeArray, 1, &lUBound );

	// get the type of the elements in the safe array
	vartype = V_VT( &vtValue ) & ~VT_ARRAY;

	try
	{
		// traverse thru the values in the safe array and update into dynamic array
		for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
		{
			// sub-local variables
			VARIANT var;
			CHString strValue;
			
			// get the value
			V_VT( &var ) = vartype;
			SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

			// add the information to the dynamic array
			switch( vartype )
			{
			case VT_BSTR:
				strValue = V_BSTR( &var );
				DynArrayAppendString( arr, strValue, 0 );
				break;
			}
		}
	}
	catch( ... )
	{
		// clear the variant
		VariantClear( &vtValue );
		return FALSE;	// failure
	}

	// clear the variant
	VariantClear( &vtValue );

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ in ] varValue	: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT var;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// put the value
		var = varValue;
		hr = pWmiObject->Put( _bstr_t( pwszProperty ), 0, &var, 0 );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}
	
	// return the result
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL || pwszValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = pwszValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		Sets the value of the property to the WMI class object
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	// check the input value
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		varValue = ( LONG ) dwValue;
		hr = PropertyPut( pWmiObject, pwszProperty, varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		hr = e.Error();
	}

	// return 
	return hr;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
HRESULT RegQueryValueWMI( IWbemServices* pWbemServices, 
						  LPCWSTR pwszMethod, DWORD dwHDefKey, 
						  LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	BOOL bResult = FALSE;
	DWORD dwReturnValue = 0;
	IWbemClassObject* pClass = NULL;
	IWbemClassObject* pMethod = NULL;
	IWbemClassObject* pInParams = NULL;
	IWbemClassObject* pInParamsInstance = NULL;
	IWbemClassObject* pOutParamsInstance = NULL;

	// check the input value
	if (pWbemServices == NULL || pwszMethod == NULL || pwszSubKeyName == NULL || pwszValueName == NULL)
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// get the registry class object
		SAFE_EXECUTE( pWbemServices->GetObject( 
			_bstr_t( WMI_REGISTRY ), WBEM_FLAG_RETURN_WBEM_COMPLETE, NULL, &pClass, NULL ) );
		if ( pClass == NULL )						// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// get the method reference required
		SAFE_EXECUTE( pClass->GetMethod( pwszMethod, 0, &pInParams, NULL ) );
		if ( pInParams == NULL )					// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// create the instance for the in parameters
		SAFE_EXECUTE( pInParams->SpawnInstance( 0, &pInParamsInstance ) );
		if ( pInParamsInstance == NULL )
			_com_issue_error( STG_E_UNKNOWN );

		// set the input values
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_HDEFKEY ), dwHDefKey );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_SUBKEY ), pwszSubKeyName );
		PropertyPut( pInParamsInstance, _bstr_t( WMI_REGISTRY_IN_VALUENAME ), pwszValueName );

		// now execute the method
		SAFE_EXECUTE( pWbemServices->ExecMethod( _bstr_t( WMI_REGISTRY ),
			_bstr_t( pwszMethod ), 0, NULL, pInParamsInstance, &pOutParamsInstance, NULL ) );
		if ( pOutParamsInstance == NULL )			// check the object .. safety sake
			_com_issue_error( STG_E_UNKNOWN );

		// now check the return value of the method from the output params object
		bResult = PropertyGet( pOutParamsInstance, 
			_bstr_t( WMI_REGISTRY_OUT_RETURNVALUE ), dwReturnValue );
		if ( bResult == FALSE || dwReturnValue != 0 )
			_com_issue_error( STG_E_UNKNOWN );

		// now everything is sucess .. get the required value
		PropertyGet( pOutParamsInstance, _bstr_t( WMI_REGISTRY_OUT_VALUE ), varValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// release the interfaces
	SAFE_RELEASE( pClass );
	SAFE_RELEASE( pMethod );
	SAFE_RELEASE( pInParams );
	SAFE_RELEASE( pInParamsInstance );
	SAFE_RELEASE( pOutParamsInstance );

	// return success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, 
					   DWORD dwHDefKey, LPCWSTR pwszSubKeyName, 
					   LPCWSTR pwszValueName, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t varValue;

	try
	{
		// set the default value
		if ( pwszDefault != NULL )
			strValue = pwszDefault;

		// check the input
		if ( pWbemServices == NULL || pwszSubKeyName == NULL || pwszValueName == NULL )
			return FALSE;

		// get the value
		hr = RegQueryValueWMI( pWbemServices, 
			WMI_REGISTRY_M_STRINGVALUE, dwHDefKey, pwszSubKeyName, pwszValueName, varValue );
		if ( FAILED( hr ) )
			return FALSE;

		// get the value from the variant
		// get the value
		if ( varValue.vt != VT_NULL && varValue.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( varValue );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return success
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hr;
	LONG lPos = 0;
	DWORD dwMajor = 0;
	DWORD dwMinor = 0;
	DWORD dwVersion = 0;
	ULONG ulReturned = 0;
	CHString strVersion;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );
	
		//
		// now determine the os version
		dwMajor = dwMinor = 0;

		// get the major version
		lPos = strVersion.Find( L'.' );
		if ( lPos == -1 )
		{
			// the version string itself is version ... THIS WILL NEVER HAPPEN
			dwMajor = AsLong( strVersion, 10 );
		}
		else
		{
			// major version
			dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

			// get the minor version
			strVersion = strVersion.Mid( lPos + 1 );
			lPos = strVersion.Find( L'.' );
			if ( lPos == -1 )
				dwMinor = AsLong( strVersion, 10 );
			else
				dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
		}

		// mix the version info
		dwVersion = dwMajor * 1000 + dwMinor;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}

	// return 
	return dwVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\getmac\pch.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		PCH.H
//  
//  Abstract:
//		Include file for standard system include files, or project specific
//		include files that are used frequently, but  are changed infrequently.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 26-sep-2k : Created It.
//		Vasundhara .G 31-oct-2k : Modified
//***************************************************************************


#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <winsvc.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <mbstring.h>
#include <tchar.h>

#include <winperf.h>
#include <shlwapi.h>
#include <lmcons.h>
#include <Lmapibuf.h>
#include <lmerr.h>
#include <winnetwk.h>
#include <common.ver>

#include <objbase.h>
#include <initguid.h>
#include <wbemidl.h>
#include <Wbemcli.h>
#include <wbemtime.h>

#include <wchar.h>
#include <lmwksta.h>
#include <comdef.h> 
#include <Lmwksta.h>
#include <Chstring.h>
#include <malloc.h>
  
#include "cmdline.h"
#include "cmdlineres.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\getmac\resource.h ===
#define RES_HOST                        2
#define RES_CONNECTION                  3
#define RES_ADAPTER                     4
#define RES_ADDRESS                     5
#define RES_TRANSNAME                   6
#define FR_LIST                         7
#define FR_CSV                          8
#define FR_TABLE                        9
#define IDS_HYPHEN_STRING		10
#define IDS_USAGE_BEGINING              11
#define IDS_USG_4                       12
#define IDS_USG_5                       13
#define IDS_USG_6                       14
#define IDS_USG_7                       15
#define IDS_USG_8                       16
#define IDS_USG_9                       17
#define IDS_USG_10                      18
#define IDS_USG_11                      19
#define IDS_USG_12                      20
#define IDS_USG_13                      21
#define IDS_USG_14                      22
#define IDS_USG_15                      23
#define IDS_USG_16                      24
#define IDS_USG_17                      25
#define IDS_USG_18                      26
#define IDS_USG_19                      27
#define IDS_USG_20                      28
#define IDS_USG_21                      29
#define IDS_USG_22                      30
#define IDS_USG_23                      31
#define IDS_USG_24                      32
#define IDS_USG_25                      33
#define IDS_USG_26                      34
#define IDS_USG_27                      35
#define IDS_USG_28                      36
#define IDS_USAGE_ENDING                37
#define IDS_HOST_NAME_WIDTH             38
#define IDS_CONN_NAME_WIDTH             39
#define IDS_ADAPT_TYPE_WIDTH            40
#define IDS_MAC_ADDR_WIDTH              41
#define IDS_TRANS_NAME_WIDTH            42
#define IDS_NOT_AVAILABLE               43
#define IDS_USER_NMACHINE               44
#define IDS_SERVER_NPASSWORD            45
#define IDS_ERROR_STRING                46
#define IDS_FORMAT_TYPES                47
#define IDS_NULL_USER                   48
#define IDS_INVALID_OPTIONS             49
#define IDS_DISCONNECTED                50
#define IDS_CONNECTING                  51
#define IDS_DISCONNECTING               52
#define IDS_HWNOTPRESENT                53
#define IDS_HWDISABLED                  54
#define IDS_HWMALFUNCTION               55
#define IDS_MEDIADISCONNECTED           56
#define IDS_AUTHENTICATION              57
#define IDS_AUTHENSUCCEEDED             58
#define IDS_AUTHENFAILED                59
#define IDS_ERROR_VERSION_MISMATCH      61
#define IDS_DISABLED			62
#define IDS_NO_NETWORK_ADAPTERS         63
#define IDS_IGNORE_LOCALCREDENTIALS     64
#define IDS_WARNING_STRING              65
#define IDS_NOT_RESPONDING		66
#define IDS_NO_MACHINE			67
#define IDS_INVALID_MACHINE             68
#define IDS_WKST_NOT_FOUND		69
#define IDS_NULL_SERVER			70
#define IDS_NEW_LINE			71
#define IDS_TYPE_REQUEST		72
#define IDS_COLON_STRING		73
#define	IDS_NO_NETWOK_PROTOCOLS		74
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\eventtriggers\wmi.h ===
// *********************************************************************************
// 
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//
//		WMI.h  
//  
//  Abstract:
//  
// 		Common functionality for WMI
//
//  Author:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000
//  
//  Revision History:
//  
// 	    Sunil G.V.N. Murali (murali.sunil@wipro.com) 22-Dec-2000 : Created It.
//  
// *********************************************************************************

#ifndef __WMI_H
#define __WMI_H

//
// macros
//
#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1

#define SAFE_EXECUTE( statement )				\
	hr = statement;		\
	if ( FAILED( hr ) )	\
	{	\
		_com_issue_error( hr );	\
	}	\
	1

//
// define(s) / enumerators / constants
//
#define WMI_NAMESPACE_CIMV2		L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT	L"root\\default"

#define WMI_CLAUSE_AND			L"AND"
#define WMI_CLAUSE_OR			L"OR"
#define WMI_CLAUSE_WHERE		L"WHERE"

#define CLASS_CIMV2_Win32_OperatingSystem	L"Win32_OperatingSystem"

#define WMI_REGISTRY					L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE		L"GetStringValue"

#define WMI_REGISTRY_IN_HDEFKEY			L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY			L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME		L"sValueName"
#define WMI_REGISTRY_OUT_VALUE			L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE	L"ReturnValue"

#define WMI_HKEY_CLASSES_ROOT				2147483648 
#define WMI_HKEY_CURRENT_USER				2147483649
#define WMI_HKEY_LOCAL_MACHINE				2147483650
#define WMI_HKEY_USERS						2147483651
#define WMI_HKEY_CURRENT_CONFIG				2147482652

// messages
// #define ERROR_COM_ERROR					GetResString( IDS_ERROR_COM_ERROR )

//
// function prototype(s)
//
BOOL InitializeCom( IWbemLocator** ppLocator );
BOOL ConnectWmi( IWbemLocator* pLocator, 
				 IWbemServices** ppServices, 
				 LPCWSTR pwszServer, LPCWSTR pwszUser, LPCWSTR pwszPassword, 
				 COAUTHIDENTITY** ppAuthIdentity, 
				 BOOL bCheckWithNullPwd = FALSE, 
				 LPCWSTR pwszNamespace = WMI_NAMESPACE_CIMV2, 
				 HRESULT* phr = NULL, BOOL* pbLocalSystem = NULL );
BOOL ConnectWmiEx( IWbemLocator* pLocator, 
				   IWbemServices** ppServices, 
				   LPCWSTR pwszServer, CHString& strUserName, CHString& strPassword, 
				   COAUTHIDENTITY** ppAuthIdentity, BOOL bNeedPassword = FALSE, 
				   LPCWSTR pszNamespace = WMI_NAMESPACE_CIMV2, BOOL* pbLocalSystem = NULL );
BOOL IsValidServerEx( LPCWSTR pwszServer, BOOL& bLocalSystem );
HRESULT SetInterfaceSecurity( IUnknown* pInterface, COAUTHIDENTITY* pAuthIdentity );
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity );
VOID WMISaveError( HRESULT hrError );
HRESULT PropertyGet( IWbemClassObject* pWmiObject, 
					 LPCWSTR pwszProperty, _variant_t& varValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, 
				  CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault = 0 );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime );
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, DWORD dwValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, LPCWSTR pwszValue );
HRESULT PropertyPut( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue );
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity );
BOOL RegQueryValueWMI( IWbemServices* pWbemServices, DWORD dwHDefKey, 
					   LPCWSTR pwszSubKeyName, LPCWSTR pwszValueName, 
					   CHString& strValue, LPCWSTR pwszDefault = V_NOT_AVAILABLE );

//
// inline functions
//

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
inline VOID WMISaveError( _com_error& e )
{
	WMISaveError( e.Error() );
}

#endif // __WMI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\gpresult.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation

Module Name:

    GpResult.cpp

Abstract: 
    
    This file contains the main entry point function for this tool and also the 
    function to parse the command line arguments. 
 
Author:

    Wipro Technologies

Revision History:

    20-Feb-2001 : Created It.

*********************************************************************************************/ 

#include "pch.h"
#include "GpResult.h"
#include "wmi.h"

/*********************************************************************************************
Routine Description:
  This is main entry point for this utility. Different function calls are made from here, 
  depending on the command line parameters passed to this utility.

Arguments:
    [in] argc  : Number of Command line arguments.
    [in] argv  : Pointer to Command line arguments.

Return Value:
    Zero on success
    Corresponding error code on failure.
*********************************************************************************************/ 
DWORD _cdecl _tmain( DWORD argc, LPCWSTR argv[] )
{
    // local variables
    
    CGpResult       GpResult;
    
    DWORD           dwi = 0;

    BOOL            bResult = FALSE;
    BOOL            bNeedUsageMsg = FALSE;
    
    try
    {
        // initialize the GpResult utility
        if( GpResult.Initialize() == FALSE )
        {
            CHString strBuffer;
            strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
            ShowMessage( stderr, strBuffer );
            EXIT_PROCESS( ERROR_EXIT );
        }

        bResult = GpResult.ProcessOptions( argc, argv, &bNeedUsageMsg );
        if( bResult == FALSE )
        {
            CHString strBuffer;
            strBuffer.Format( L"%s %s", TAG_ERROR, GetReason() );
            ShowMessage( stderr, strBuffer );

            if( bNeedUsageMsg == TRUE )
            {
                strBuffer.Format( GetResString( IDS_TYPE_USAGE ), argv[ 0 ] );
                ShowMessage( stderr, strBuffer );
            }

            EXIT_PROCESS( ERROR_EXIT );
        }
    }
    catch( ... )
    {
        // display the error message
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
    }

    // Check if help is specified in the commandline
    if( (argc == 2) && ( ( lstrcmp ( argv[1], HELP_OPTION ) == 0) 
                           || (lstrcmp ( argv[1], HELP_OPTION1 ) == 0) ) )
    {
        GpResult.DisplayUsage();
        EXIT_PROCESS( CLEAN_EXIT );
    }

    //   Call GetLoggingData to get the data for the Logging mode
    if( GpResult.GetLoggingData() == FALSE )
    {
        EXIT_PROCESS( ERROR_EXIT );
    }
    
    EXIT_PROCESS( CLEAN_EXIT );
}

/*********************************************************************************************
Routine Description
    This function displays the help for GpResult utility 

Arguments:  
    None.

Return Value             
    None
*********************************************************************************************/ 
VOID CGpResult::DisplayUsage( void )
{
    DWORD dwIndex = 0;

    // Displaying main usage
    for( dwIndex = ID_HELP_START; dwIndex <= ID_HELP_END; dwIndex++ )
    {
        ShowMessage( stdout, GetResString( dwIndex ) );
    }
}

/*********************************************************************************************
Routine Description
    This function processes the command line for the main options

Arguments:  
    [in] argc  : Number of Command line arguments.
    [in] argv  : Pointer to Command line arguments.

Return Value             
    TRUE on success
    FALSE on failure

*********************************************************************************************/
BOOL CGpResult::ProcessOptions( DWORD argc, LPCWSTR argv[], BOOL *pbNeedUsageMsg )
{
    // local variables
    PTCMDPARSER pcmdOptions = NULL;
    __STRING_64 szScope = NULL_STRING;

    // temporary local variables
    LPWSTR pwszUserName = NULL;
    LPWSTR pwszPassword = NULL;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszServerName = NULL;

    PTCMDPARSER pOption = NULL;
    PTCMDPARSER pOptionServer = NULL;
    PTCMDPARSER pOptionUserName = NULL;
    PTCMDPARSER pOptionPassword = NULL;
    PTCMDPARSER pOptionUser = NULL;
    PTCMDPARSER pOptionVerbose = NULL;
    PTCMDPARSER pOptionSuperVerbose = NULL;

    //
    // prepare the command options
    pcmdOptions = new TCMDPARSER[ MAX_CMDLINE_OPTIONS ];
    if ( pcmdOptions == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    try
    {
        // get the memory
        pwszServerName = m_strServerName.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszUserName = m_strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszPassword = m_strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
        pwszUser =  m_strUser.GetBufferSetLength( MAX_STRING_LENGTH );

        // init the password value
        lstrcpy( pwszPassword, _T( "*" ) );
    }
    catch( ... )
    {
        SetLastError( E_OUTOFMEMORY );
        SaveLastError();
        return FALSE;
    }

    // initialize to ZERO's
    ZeroMemory( pcmdOptions, MAX_CMDLINE_OPTIONS * sizeof( TCMDPARSER ) );

    // -?
    pOption = pcmdOptions + OI_USAGE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bUsage;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_USAGE );

    // -s
    pOption = pcmdOptions + OI_SERVER;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->pValue = pwszServerName;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    pOption->dwFlags = CP_TYPE_TEXT |  CP_VALUE_MANDATORY;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_SERVER );

    // -u
    pOption = pcmdOptions + OI_USERNAME;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    pOption->pValue = pwszUserName;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_USERNAME );

    // -p
    pOption = pcmdOptions + OI_PASSWORD;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
    pOption->pValue = pwszPassword;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_PASSWORD );

    // -v
    pOption = pcmdOptions + OI_VERBOSE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bVerbose;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_VERBOSE );

    // -z
    pOption = pcmdOptions + OI_SUPER_VERBOSE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = 0;
    pOption->pValue = &m_bSuperVerbose;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_SUPER_VERBOSE );

    // -User
    pOption = pcmdOptions + OI_USER;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
    pOption->pValue = pwszUser;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, NULL_STRING );
    lstrcpy( pOption->szOption, OPTION_USER );

    // -scope
    pOption = pcmdOptions + OI_SCOPE;
    pOption->dwCount = 1;
    pOption->dwActuals = 0;
    pOption->dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY | CP_MODE_VALUES;
    pOption->pValue = &szScope;
    pOption->pFunction = NULL;
    pOption->pFunctionData = NULL;
    lstrcpy( pOption->szValues, TEXT_SCOPE_VALUES );
    lstrcpy( pOption->szOption, OPTION_SCOPE);

    //
    // do the parsing
    if( DoParseParam( argc, argv, MAX_CMDLINE_OPTIONS, pcmdOptions ) == FALSE )
    {
        delete [] pcmdOptions;  // clear memory
        pcmdOptions = NULL;
        return FALSE;           // invalid syntax
    }

    // Do Parse Param succeded so set the flag to indicate that we have to 
    // show an additional line alongwith the error message
    *pbNeedUsageMsg = TRUE;

    // release the buffers
    m_strServerName.ReleaseBuffer();
    m_strUserName.ReleaseBuffer();
    m_strPassword.ReleaseBuffer();
    m_strUser.ReleaseBuffer();

    // check the usage option
    if( m_bUsage && ( argc > 2 ) )
    {
        // No options are accepted with -?
        SetReason( ERROR_USAGE );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;
    }
    else if( m_bUsage == TRUE )
    {
        // should not do the furthur validations
        delete [] pcmdOptions;      // clear the cmd parser config info
        return TRUE;
    }

    // Check what has been entered for the scope variable 
    //  and set the flag appropriately
    if( lstrcmpi( szScope, TEXT_SCOPE_USER ) == 0 )
    {
        m_dwScope = SCOPE_USER;
    }
    else if( lstrcmpi( szScope, TEXT_SCOPE_COMPUTER ) == 0 )
    {
        m_dwScope = SCOPE_COMPUTER;
    }
        
    //
    // now, check the mutually exclusive options
    pOptionServer = pcmdOptions + OI_SERVER;
    pOptionUserName = pcmdOptions + OI_USERNAME;
    pOptionPassword = pcmdOptions + OI_PASSWORD;
    pOptionUser = pcmdOptions + OI_USER;
    pOptionVerbose = pcmdOptions + OI_VERBOSE;
    pOptionSuperVerbose = pcmdOptions + OI_SUPER_VERBOSE;

    // "-z" and "-v" are mutually exclusive options
    if( pOptionVerbose->dwActuals != 0 && pOptionSuperVerbose->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_VERBOSE_SYNTAX );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;           // indicate failure
    }

    // "-u" should not be specified without machine names
    if( pOptionServer->dwActuals == 0 && pOptionUserName->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_USERNAME_BUT_NOMACHINE );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;           // indicate failure
    }

    // "-p" should not be specified without "-u"
    if( pOptionUserName->dwActuals == 0 && pOptionPassword->dwActuals != 0 )
    {
        // invalid syntax
        SetReason( ERROR_PASSWORD_BUT_NOUSERNAME );
        delete [] pcmdOptions;      // clear the cmd parser config info
        return FALSE;
    }

    // empty server name is not valid
    if( pOptionServer->dwActuals != 0 && m_strServerName.GetLength() == 0 )
    {
        SetReason( ERROR_SERVERNAME_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // empty user is not valid
    if( pOptionUserName->dwActuals != 0 && m_strUserName.GetLength() == 0 )
    {
        SetReason( ERROR_USERNAME_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // empty user is not valid, for the target user
    if( pOptionUser->dwActuals != 0 && m_strUser.GetLength() == 0 )
    {
        SetReason( ERROR_TARGET_EMPTY );
        delete [] pcmdOptions;
        return FALSE;
    }

    // if user has specified -s (or) -u and no "-p", then utility should accept password
    // the user will be prompted for the password only if establish connection 
    // fails without the credentials information
    m_bNeedPassword = FALSE;
    if ( pOptionPassword->dwActuals != 0 && m_strPassword.Compare( L"*" ) == 0 )
    {
        // user wants the utility to prompt for the password before trying to connect
        m_bNeedPassword = TRUE;
    }
    else if ( pOptionPassword->dwActuals == 0 && 
            ( pOptionServer->dwActuals != 0 || pOptionUserName->dwActuals != 0 ) )
    {
        // utility needs to try to connect first and if it fails then prompt for the password
        m_bNeedPassword = TRUE;
        m_strPassword.Empty();
    }
    
    // Check wether we are querying for the local system
    if( pOptionServer->dwActuals == 0 )
    {
        m_bLocalSystem = TRUE;
    }

    // command-line parsing is successfull
    // clear the cmd parser config info
    delete [] pcmdOptions;      

    return TRUE;
}

/*********************************************************************************************
Routine Description:
    
    CGpResult constructor

Arguments:

    NONE

Return Value:

    NONE

*********************************************************************************************/
CGpResult::CGpResult()
{
    // initialize the member variables to defaults
    m_pWbemLocator = NULL;
    m_pEnumObjects = NULL;
    m_pWbemServices = NULL;
    m_pAuthIdentity = NULL;
    
    m_strServerName = L"";
    m_strUserName = L"";
    m_strPassword = L"";
    m_strUser = L"";
    m_strADSIDomain = L"";
    m_strADSIServer = L"";

    m_pwszPassword = NULL;

    m_hOutput = NULL;

    m_bVerbose = FALSE;
    m_dwScope = SCOPE_ALL;
    m_bNeedPassword = FALSE;
    m_bLocalSystem = FALSE;
    m_bUsage = FALSE;

    m_hMutex = CreateMutex( NULL, FALSE, MUTEX_NAME );
}

/*********************************************************************************************
Routine Description:
    
    CGpResult destructor

Arguments:

    NONE

Return Value:

    NONE

*********************************************************************************************/
CGpResult::~CGpResult()
{
    //
    // release WMI / COM interfaces
    SAFE_RELEASE( m_pWbemLocator );
    SAFE_RELEASE( m_pWbemServices );
    SAFE_RELEASE( m_pEnumObjects );

    // free authentication identity structure
    // release the existing auth identity structure
    WbemFreeAuthIdentity( &m_pAuthIdentity );

    // un-initialize the COM library
    CoUninitialize();

    // Release the object
    if( m_hMutex != NULL )
    {
        CloseHandle( m_hMutex );
    }
}

/*********************************************************************************************
Routine Description:
    
    Initializes the GpResult utility

Arguments:

    NONE

Return Value:

    TRUE    : if filters are appropriately specified
    FALSE   : if filters are errorneously specified

*********************************************************************************************/
BOOL CGpResult::Initialize()
{
    // if at all an error occurs, we know that is because of the 
    // failure in memory allocation, so set the error initially
    SetLastError( E_OUTOFMEMORY );
    SaveLastError();

    // initialize the COM library
    if ( InitializeCom( &m_pWbemLocator ) == FALSE )
    {
        return FALSE;
    }
    
    //
    // Init the console scree buffer structure to zero's
    // and then get the console handle and screen buffer information
    //
    // prepare for status display.
    // for this get a handle to the screen output buffer
    // but this handle will be null if the output is being redirected. so do not check 
    // for the validity of the handle. instead try to get the console buffer information
    // only in case you have a valid handle to the output screen buffer
    ZeroMemory( &m_csbi, sizeof( CONSOLE_SCREEN_BUFFER_INFO ) );
    m_hOutput = GetStdHandle( STD_ERROR_HANDLE );
    if ( m_hOutput != NULL )
    {
        GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
    }
    
    // initialization is successful
    SetLastError( NOERROR );                // clear the error
    SetReason( NULL_STRING );           // clear the reason
    return TRUE;
}

/*********************************************************************************************
Routine Description:
    
    Initializes the GpResult utility

Arguments:

    [in] HANDLE                                  :  Handle to the output console
    [in] LPCWSTR                                 :  String to display
    [in] const CONSOLE_SCREEN_BUFFER_INFO&       :  pointer to the screen buffer

Return Value:

    NONE

*********************************************************************************************/
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, 
                        const CONSOLE_SCREEN_BUFFER_INFO& csbi )
{
    // local variables
    COORD       coord; 
    DWORD       dwSize = 0;
    WCHAR       wszSpaces[ 80 ] = L"";

    // check the handle. if it is null, it means that output is being redirected. so return
    if( hOutput == NULL )
    {
        return;
    }

    // set the cursor position
    coord.X = 0;
    coord.Y = csbi.dwCursorPosition.Y;

    // first erase contents on the current line
    ZeroMemory( wszSpaces, 80 );
    SetConsoleCursorPosition( hOutput, coord );
    WriteConsoleW( hOutput, Replicate( wszSpaces, L"", 79 ), 79, &dwSize, NULL );

    // now display the message ( if exists )
    SetConsoleCursorPosition( hOutput, coord );
    if( pwszMsg != NULL )
    {
        WriteConsoleW( hOutput, pwszMsg, lstrlen( pwszMsg ), &dwSize, NULL );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\getmac\connectwmi.cpp ===
// **********************************************************************************
//  Copyright (c) Microsoft Corporation
//  
//  Module Name:
//		CONNECTWMI.cpp
//  
//  Abstract:
// 		Contains functions to connect to wmi.
//  
//  Author:
//		Vasundhara .G
//  
//  Revision History:
//		Vasundhara .G 26-sep-2k : Created It.  
// *********************************************************************************

// Include files
#include "pch.h"
#include "getmac.h"
#include "resource.h"

// messages

#define INPUT_PASSWORD		GetResString( IDS_STR_INPUT_PASSWORD )

// error constants

#define E_SERVER_NOTFOUND			0x800706ba

// function prototypes

BOOL IsValidUserEx( LPCWSTR pwszUser );

HRESULT GetSecurityArguments( IUnknown *pInterface, 
							  DWORD&   dwAuthorization,
							  DWORD&   dwAuthentication );

HRESULT SetInterfaceSecurity( IUnknown       *pInterface, 
							  LPCWSTR		 pwszServer,
							  LPCWSTR		 pwszUser, 
							  LPCWSTR		 pwszPassword,
							  COAUTHIDENTITY **ppAuthIdentity );

HRESULT WINAPI SetProxyBlanket( IUnknown  *pInterface,
							    DWORD	  dwAuthnSvc,
								DWORD	  dwAuthzSvc,
								LPWSTR	  pwszPrincipal,
								DWORD	  dwAuthLevel,
								DWORD	  dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
								DWORD	  dwCapabilities );

HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser,
									  LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain,
									  COAUTHIDENTITY **ppAuthIdent );

HRESULT RegQueryValueWMI( IWbemServices	*pWbemServices, 
						  LPCWSTR		pwszMethod,
						  DWORD			dwHDefKey, 
						  LPCWSTR		pwszSubKeyName,
						  LPCWSTR		pwszValueName,
						  _variant_t	&varValue );

HRESULT PropertyGet( IWbemClassObject	*pWmiObject, 
					 LPCWSTR			pwszProperty,
					 _variant_t&		varValue );

BOOL PropertyGet( IWbemClassObject  *pWmiObject,
				  LPCWSTR			pwszProperty, 
				  CHString&			strValue,
				  LPCWSTR			pwszDefault = V_NOT_AVAILABLE );

BOOL PropertyGet( IWbemClassObject  *pWmiObject, 
				  LPCWSTR			pwszProperty,
				  DWORD&			dwValue,
				  DWORD				dwDefault = 0 );

BOOL PropertyGet( IWbemClassObject  *pWmiObject,
				  LPCWSTR			pwszProperty,
				  ULONGLONG&		ullValue );

BOOL PropertyGet( IWbemClassObject  *pWmiObject,
				  LPCWSTR			pwszProperty,
				  WBEMTime&			wbemtime );

BOOL PropertyGet( IWbemClassObject  *pWmiObject,
				  LPCWSTR			pwszProperty,
				  SYSTEMTIME&		systime );

BOOL PropertyGet( IWbemClassObject  *pWmiObject,
				  LPCWSTR			pwszProperty,
				  TARRAY			arr );


// ***************************************************************************
// Routine Description:
//		Validates the user name.
//
// Arguments:
//		pwszUser [in] - Holds the user name to be validated.	
//
// Return Value:
//		returns TRUE if user name is a valid user else FALSE.
// ***************************************************************************
BOOL IsValidUserEx( LPCWSTR pwszUser )
{
	// local variables
	CHString strUser;
	LONG lPos = 0;

	try
	{
		// get user into local memory
		strUser = pwszUser;

		// user name should not be just '\'
		if ( strUser.CompareNoCase( L"\\" ) == 0 )
		{
			return FALSE;
		}
		// user name should not contain invalid characters
		if ( strUser.FindOneOf( L"/[]:|<>+=;,?*" ) != -1 )
		{
			return FALSE;
		}
		lPos = strUser.Find( L'\\' );
		if ( lPos != -1 )
		{
			// '\' character exists in the user name
			// strip off the user info upto first '\' character
			// check for one more '\' in the remaining string
			// if it exists, invalid user
			strUser = strUser.Mid( lPos + 1 );
			lPos = strUser.Find( L'\\' );
			if ( lPos != -1 )
			{
				return FALSE;
			}
		}

	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		return FALSE;
	}

	// user name is valid
	return TRUE;
}


// ***************************************************************************
// Routine Description: 
//		Checks whether the server name is a valid server name or not.
//		  
// Arguments:
//		pwszServer [in]       - Server name to be validated.
//		bLocalSystem [in/out] - Set to TRUE if server specified is local system.
//
// Return Value: 
//		TRUE if server is valid else FALSE.
// ***************************************************************************
BOOL IsValidServerEx( LPCWSTR pwszServer,
					  BOOL &bLocalSystem )
{
	// local variables
	CHString strTemp;

	if( pwszServer == NULL )
	{
		return FALSE;
	}
	bLocalSystem = FALSE;

	// get a local copy
	strTemp = pwszServer;

	// remove the forward slashes (UNC) if exist in the begining of the server name
	if ( IsUNCFormat( strTemp ) == TRUE )
	{
		strTemp = strTemp.Mid( 2 );
		if ( strTemp.GetLength() == 0 )
		{
			return FALSE;
		}
	}

	// now check if any '\' character appears in the server name. If so error
	if ( strTemp.Find( L'\\' ) != -1 )
	{
		return FALSE;
	}

	// now check if server name is '.' only which represent local system in WMI
	// else determine whether this is a local system or not
	bLocalSystem = TRUE;
	if ( strTemp.CompareNoCase( L"." ) != 0 )
	{
		// validate the server
		if ( IsValidServer( strTemp ) == FALSE )
		{
			return FALSE;
		}

		// check whether this is a local system or not
		bLocalSystem = IsLocalSystem( strTemp );
	}

	// valid server name
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Connects to wmi.
//		  
// Arguments:
//		pLocator [in]           - Pointer to the IWbemLocator object.
//		ppServices [out]        - Pointer to IWbemServices object.
//		pwszServer [in]         - Holds the server name to connect to.
//		pwszUser [in/out]       - Holds the user name.
//		pwszPassword [in/out]   - Holds the password.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//		bCheckWithNullPwd [in]  - Specifies whether to connect through null password.
//		pwszNamespace [in]		- Specifies the namespace to connect to.
//		phRes [in/out]          - Holds the error value.
//		pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//								  name is local or not.
// Return Value:
//		TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmi( IWbemLocator    *pLocator,
				 IWbemServices   **ppServices, 
				 LPCWSTR         pwszServer,
				 LPCWSTR         pwszUser,
				 LPCWSTR         pwszPassword, 
				 COAUTHIDENTITY  **ppAuthIdentity, 
				 BOOL            bCheckWithNullPwd,
				 LPCWSTR         pwszNamespace,
				 HRESULT         *phRes,
				 BOOL            *pbLocalSystem )
{
	// local variables
	HRESULT hRes = 0;
	BOOL bResult = FALSE;
	BOOL bLocalSystem = FALSE;
	_bstr_t bstrServer;
	_bstr_t bstrNamespace;
	_bstr_t bstrUser;
	_bstr_t	bstrPassword;

	if ( pbLocalSystem != NULL )
	{
		*pbLocalSystem = FALSE;
	}
	if ( phRes != NULL )
	{
		*phRes = NO_ERROR;
	}
	try
	{
		// clear the error
		SetLastError( WBEM_S_NO_ERROR );

		// assume that connection to WMI namespace is failed
		bResult = FALSE;

		// check whether locator object exists or not if not return FALSE
		if ( pLocator == NULL )
		{
			if ( phRes != NULL )
			{
				*phRes = WBEM_E_INVALID_PARAMETER;
			}
			// return failure
			return FALSE;
		}

		// validate the server name
		// NOTE: The error being raised in custom define for '0x800706ba' value
		//       The message that will be displayed in "The RPC server is unavailable."
		if ( IsValidServerEx( pwszServer, bLocalSystem ) == FALSE )
		{
			_com_issue_error( ERROR_BAD_NETPATH );
		}
		// validate the user name
		if ( IsValidUserEx( pwszUser ) == FALSE )
		{
			_com_issue_error( ERROR_NO_SUCH_USER );
		}
		// prepare namespace
		bstrNamespace = pwszNamespace;				// name space
		if ( pwszServer != NULL && bLocalSystem == FALSE )
		{
			// get the server name
			bstrServer = pwszServer;

			// prepare the namespace
			// NOTE: check for the UNC naming format of the server and do
			if ( IsUNCFormat( pwszServer ) == TRUE )
			{
				bstrNamespace = bstrServer + L"\\" + pwszNamespace;
			}
			else
			{
				bstrNamespace = L"\\\\" + bstrServer + L"\\" + pwszNamespace;
			}

			// user credentials
			if ( pwszUser != NULL && lstrlen( pwszUser ) != 0 )
			{
				// copy the user name
				bstrUser = pwszUser;

				// if password is empty string and if we need to check with
				// null password, then do not set the password and try
				bstrPassword = pwszPassword;
				if ( bCheckWithNullPwd == TRUE && bstrPassword.length() == 0 )
				{
					bstrPassword = (LPWSTR) NULL;
				}
			}
		}

		// release the existing services object ( to be in safer side )
		SAFE_RELEASE( *ppServices );

		// connect to the remote system's WMI
		// there is a twist here ... 
		// do not trap the ConnectServer function failure into exception
		// instead handle that action manually
		// by default try the ConnectServer function as the information which we have
		// in our hands at this point. If the ConnectServer is failed, 
		// check whether password variable has any contents are not ... if no contents
		// check with "" (empty) password ... this might pass in this situation ..
		// if this call is also failed ... nothing is there that we can do ... throw the exception
		hRes = pLocator->ConnectServer( bstrNamespace, 
			bstrUser, bstrPassword, 0L, 0L, NULL, NULL, ppServices );
		if ( FAILED( hRes ) )
		{
			//
			// special case ...
	
			// check whether password exists or not
			// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
			//       this error code says that user with the current credentials is not
			//       having access permisions to the 'namespace'

			if ( hRes == E_ACCESSDENIED )
			{
				// check if we tried to connect to the system using null password
				// if so, then try connecting to the remote system with empty string
				if ( bCheckWithNullPwd == TRUE &&
					 bstrUser.length() != 0 && bstrPassword.length() == 0 )
				{
					// now invoke with ...
					hRes = pLocator->ConnectServer( bstrNamespace, 
						bstrUser, _bstr_t( L"" ), 0L, 0L, NULL, NULL, ppServices );
				}
			}
			else if ( hRes == WBEM_E_LOCAL_CREDENTIALS )
			{
				// credentials were passed to the local system. 
				// So ignore the credentials and try to reconnect
				bLocalSystem = TRUE;
				bstrUser = (LPWSTR) NULL;
				bstrPassword = (LPWSTR) NULL;
				bstrNamespace = pwszNamespace;				// name space
				hRes = pLocator->ConnectServer( bstrNamespace, 
					NULL, NULL, 0L, 0L, NULL, NULL, ppServices );
				
				// check the result
				if ( SUCCEEDED( hRes ) && phRes != NULL )
				{
					// set the last error
					*phRes = WBEM_E_LOCAL_CREDENTIALS;
				}
			}

			// now check the result again .. if failed .. ummmm..
			if ( FAILED( hRes ) )
			{
				_com_issue_error( hRes );
			}
			else
			{
				bstrPassword = L"";
			}
		}

		// set the security at the interface level also
		SAFE_EXECUTE( SetInterfaceSecurity( *ppServices, 
			pwszServer, bstrUser, bstrPassword, ppAuthIdentity ) );

		// connection to WMI is successful
		bResult = TRUE;

		// save the hr value if needed by the caller
		if ( phRes != NULL )
		{
			*phRes = WBEM_S_NO_ERROR;
		}
	}
	catch( _com_error& e )
	{
		// save the error
		WMISaveError( e );

		// save the hr value if needed by the caller
		if ( phRes != NULL )
		{
			*phRes = e.Error();
		}
	}

	if ( pbLocalSystem != NULL )
	{
		*pbLocalSystem = bLocalSystem;
	}
	// return the result
	return bResult;
}

// ***************************************************************************
// Routine Description:
//		Connects to wmi.
//		  
// Arguments:
//		pLocator [in]           - Pointer to the IWbemLocator object.
//		ppServices [out]        - Pointer to IWbemServices object.
//		strServer [in]          - Holds the server name to connect to.
//		strUserName [in/out]    - Holds the user name.
//		strPassword [in/out]    - Holds the password.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//		bNeedPassword [in]		- Specifies whether to prompt for password.
//		pwszNamespace [in]		- Specifies the namespace to connect to.
//		pbLocalSystem [in/out]  - Holds the boolean value to represent whether the server
//								  name is local or not.
// Return Value:
//		TRUE if successfully connected, FALSE if not.
// ***************************************************************************
BOOL ConnectWmiEx( IWbemLocator    *pLocator, 
				   IWbemServices   **ppServices,
				   LPCWSTR         strServer,
				   CHString        &strUserName,
				   CHString        &strPassword, 
				   COAUTHIDENTITY  **ppAuthIdentity,
				   BOOL            bNeedPassword,
				   LPCWSTR         pwszNamespace,
				   BOOL            *pbLocalSystem )
{
	// local variables
	HRESULT hRes = 0;
	DWORD dwSize = 0;
	BOOL bResult = FALSE;
	LPWSTR pwszPassword = NULL;

	try
	{

		CHString strBuffer = NULL_STRING;

		// clear the error .. if any
		SetLastError( WBEM_S_NO_ERROR );

		// sometime users want the utility to prompt for the password
		// check what user wants the utility to do
		if ( bNeedPassword == TRUE && strPassword.Compare( L"*" ) == 0 )
		{
			// user wants the utility to prompt for the password
			// so skip this part and let the flow directly jump the password acceptance part
		}
		else
		{
			// try to establish connection to the remote system with the credentials supplied
			if ( strUserName.GetLength() == 0 )
			{
				// user name is empty
				// so, it is obvious that password will also be empty
				// even if password is specified, we have to ignore that
				bResult = ConnectWmi( pLocator, ppServices, 
					strServer, NULL, NULL, ppAuthIdentity, 
					FALSE, pwszNamespace, &hRes, pbLocalSystem );
			}
			else
			{
				// credentials were supplied
				// but password might not be specified ... so check and act accordingly
				LPCWSTR pwszTemp = NULL;
				BOOL bCheckWithNull = TRUE;
				if ( bNeedPassword == FALSE )
				{
					pwszTemp = strPassword;
					bCheckWithNull = FALSE;
				}

				// ...
				bResult = ConnectWmi( pLocator, ppServices, strServer, strUserName,
					pwszTemp, ppAuthIdentity, bCheckWithNull, pwszNamespace, &hRes, pbLocalSystem );
			}

			// check the result ... if successful in establishing connection ... return
			if ( bResult == TRUE )
			{
				SetLastError( hRes );			// set the error code
				return TRUE;
			}
			// now check the kind of error occurred
			switch( hRes )
			{
				case E_ACCESSDENIED:
					 break;
				case WBEM_E_ACCESS_DENIED:
				default:
					// NOTE: do not check for 'WBEM_E_ACCESS_DENIED'
					//       this error code says that user with the current credentials is not
					//       having access permisions to the 'namespace'
					WMISaveError( hRes );
					return FALSE;		// no use of accepting the password .. return failure
					break;
			}

			// if failed in establishing connection to the remote terminal
			// even if the password is specifed, then there is nothing to do ... simply return failure
			if ( bNeedPassword == FALSE )
			{
					return( FALSE );
			}
		}
		
		// check whether user name is specified or not
		// if not, get the local system's current user name under whose credentials, the process
		// is running
		if ( strUserName.GetLength() == 0 )
		{
			// sub-local variables
			LPWSTR pwszUserName = NULL;

			// get the required buffer
			pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );

			// get the user name
			DWORD dwUserLength = MAX_STRING_LENGTH;
			if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwUserLength ) == FALSE )
			{
				// error occured while trying to get the current user info
				SaveLastError();
				return( FALSE );
			}

			// release the extra buffer allocated
			strUserName.ReleaseBuffer();
		}

		// get the required buffer
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );

		// accept the password from the user
		strBuffer.Format( INPUT_PASSWORD, strUserName );
		WriteConsoleW( GetStdHandle( STD_ERROR_HANDLE ), 
					   strBuffer, strBuffer.GetLength(), &dwSize, NULL );
		GetPassword( pwszPassword, MAX_PASSWORD_LENGTH );

		// release the buffer allocated for password
		strPassword.ReleaseBuffer();

		// now again try to establish the connection using the currently
		// supplied credentials
		bResult = ConnectWmi( pLocator, ppServices, strServer,
			strUserName, strPassword, ppAuthIdentity, FALSE, pwszNamespace, &hRes, pbLocalSystem );

	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	// return the success
	return bResult;

}

// ***************************************************************************
// Routine Description:
//		Gets the security arguments for an interface.
//
// Arguments:
//		pInterface [in]           - Pointer to interface stucture.
//		dwAuthorization [in/out]  - Holds Authorization value.
//		dwAuthentication [in/out] - Holds the Authentication value.
//  
// Return Value:
//		Returns HRESULT value. 
// ***************************************************************************
HRESULT GetSecurityArguments( IUnknown *pInterface, 
							  DWORD& dwAuthorization,
							  DWORD& dwAuthentication )
{
	// local variables
	HRESULT hRes = 0;
	DWORD dwAuthnSvc = 0, dwAuthzSvc = 0;
	IClientSecurity *pClientSecurity = NULL;

	if( pInterface == NULL )
	{
	   return WBEM_E_INVALID_PARAMETER;
	 }


	// try to get the client security services values if possible
	hRes = pInterface->QueryInterface( IID_IClientSecurity, (void**) &pClientSecurity );
	if ( SUCCEEDED( hRes ) )
	{
		// got the client security interface
		// now try to get the security services values
		hRes = pClientSecurity->QueryBlanket( pInterface, 
			&dwAuthnSvc, &dwAuthzSvc, NULL, NULL, NULL, NULL, NULL );
		if ( SUCCEEDED( hRes ) )
		{
			// we've got the values from the interface
			dwAuthentication = dwAuthnSvc;
			dwAuthorization = dwAuthzSvc;
		}

		// release the client security interface
		SAFE_RELEASE( pClientSecurity );
	}

	// return always success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Sets interface security.
//		  
// Arguments:
//		pInterface [in]         - Pointer to the interface to which security has to be set.
//		pwszServer [in]         - Holds the server name of the interface.
//		pwszUser [in]           - Holds the user name of the server.
//		pwszPassword [in]       - Hold the password of the user.
//		ppAuthIdentity [in/out] - Pointer to authentication structure.
//
// Return Value:
//		returns HRESULT value. 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown *pInterface, 
							  LPCWSTR pwszServer,
							  LPCWSTR pwszUser, 
							  LPCWSTR pwszPassword,
							  COAUTHIDENTITY **ppAuthIdentity )
{
	// local variables
	HRESULT hRes;
	LPCWSTR pwszUserArg = NULL;
	LPCWSTR pwszDomainArg = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	try
	{
		CHString strUser;
		CHString strDomain;

		// check the interface
		if ( pInterface == NULL )
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		// check the authentity strcuture ... if authentity structure is already ready
		// simply invoke the 2nd version of SetInterfaceSecurity
		if ( *ppAuthIdentity != NULL )
		{
			return SetInterfaceSecurity( pInterface, *ppAuthIdentity );
		}
		// get the current security argument value
		// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

		// If we are doing trivial case, just pass in a null authenication structure 
		// for which the current logged in user's credentials will be considered
		if ( pwszUser == NULL && pwszPassword == NULL )
		{
			// set the security
			hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, 
				NULL, RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE );

			// return the result
			return hRes;
		}

		// parse and find out if the user name contains the domain name
		// if contains, extract the domain value from it
		LONG lPos = -1;
		strDomain = L"";
		strUser = pwszUser;
		if ( ( lPos = strUser.Find( L'\\' ) ) != -1 )
		{
			// user name contains domain name ... domain\user format
			strDomain = strUser.Left( lPos );
			strUser = strUser.Mid( lPos + 1 );
		}

		// get the domain info if it exists only
		if ( strDomain.GetLength() != 0 )
		{
			pwszDomainArg = strDomain;
		}
		// get the user info if it exists only
		if ( strUser.GetLength() != 0 )
		{
			pwszUserArg = strUser;
		}
		// check if authenication info is available or not ...
		// initialize the security authenication information ... UNICODE VERSION STRUCTURE
		if ( ppAuthIdentity == NULL )
		{
			return WBEM_E_INVALID_PARAMETER;
		}
		else if ( *ppAuthIdentity == NULL )
		{
			hRes = WbemAllocAuthIdentity( pwszUserArg, pwszPassword, pwszDomainArg, ppAuthIdentity );
			if ( hRes != S_OK )
			{
				return hRes;
			}
		}

		// set the security information to the interface
		hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
			RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, *ppAuthIdentity, EOAC_NONE );

		// return the result
		return hRes;
	}
	catch(CHeap_Exception)
	{	
		return E_OUTOFMEMORY;
	}
}

// ***************************************************************************
// Routine Description:
//		Sets the interface security for the interface.	
//		  
// Arguments:
//		pInterface [in]  - pointer to the interface.
//		pAuthIdentity [in] - pointer to authentication structure.
//
// Return Value:
//		returns HRESULT value. 
// ***************************************************************************
HRESULT SetInterfaceSecurity( IUnknown *pInterface,
							  COAUTHIDENTITY *pAuthIdentity )
{
	// local variables
	HRESULT hRes;
	LPWSTR pwszDomain = NULL;
	DWORD dwAuthorization = RPC_C_AUTHZ_NONE;
	DWORD dwAuthentication = RPC_C_AUTHN_WINNT;

	// check the interface
	if ( pInterface == NULL )
	{
		return WBEM_E_INVALID_PARAMETER;
	}
	// get the current security argument value
	// GetSecurityArguments( pInterface, dwAuthorization, dwAuthentication );

	// set the security information to the interface
	hRes = SetProxyBlanket( pInterface, dwAuthentication, dwAuthorization, NULL,
		RPC_C_AUTHN_LEVEL_DEFAULT, RPC_C_IMP_LEVEL_IMPERSONATE, pAuthIdentity, EOAC_NONE );

	// return the result
	return hRes;
}

// ***************************************************************************
// Routine Description:
//		Sets proxy blanket for the interface.
//		  
// Arguments:
//		pInterface [in]     - pointer to the inteface.
//		dwAuthnsvc [in]     - Authentication service to use.
//		dwAuthzSvc [in]     - Authorization service to use.
//		pwszPricipal [in]   - Server principal name to use with the authentication service.
//		dwAuthLevel [in]    - Authentication level to use.
//		dwImpLevel [in]     - Impersonation level to use.
//		pAuthInfo	[in]    - Identity of the client.
//		dwCapabilities [in] - Capability flags.
//  
// Return Value:
//		Return HRESULT value.
// 
// ***************************************************************************
HRESULT WINAPI SetProxyBlanket( IUnknown *pInterface,
							    DWORD dwAuthnSvc,
								DWORD dwAuthzSvc,
								LPWSTR pwszPrincipal,
								DWORD dwAuthLevel,
								DWORD dwImpLevel,
								RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
								DWORD dwCapabilities )
{
	// local variables
	HRESULT hRes;
    IUnknown *pUnknown = NULL;
    IClientSecurity *pClientSecurity = NULL;

	if( pInterface == NULL )
	{
		return  WBEM_E_INVALID_PARAMETER;
	}
	// get the IUnknown interface ... to check whether this is a valid interface or not
    hRes = pInterface->QueryInterface( IID_IUnknown, (void **) &pUnknown );
    if ( hRes != S_OK )
	{
        return hRes;
	}
	// now get the client security interface
    hRes = pInterface->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
    if ( hRes != S_OK )
    {
        SAFE_RELEASE( pUnknown );
        return hRes;
    }

    //
    // Can't set pAuthInfo if cloaking requested, as cloaking implies
    // that the current proxy identity in the impersonated thread (rather
    // than the credentials supplied explicitly by the RPC_AUTH_IDENTITY_HANDLE)
    // is to be used.
    // See MSDN info on CoSetProxyBlanket for more details.
    //
    if ( dwCapabilities & (EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING) )
	{
        pAuthInfo = NULL;
	}
	// now set the security
    hRes = pClientSecurity->SetBlanket( pInterface, dwAuthnSvc, dwAuthzSvc, pwszPrincipal,
		dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

	// release the security interface
	SAFE_RELEASE( pClientSecurity );

    // we should check the auth identity structure. if exists .. set for IUnknown also
    if ( pAuthInfo != NULL )
    {
        hRes = pUnknown->QueryInterface( IID_IClientSecurity, (void **) &pClientSecurity );
        if ( hRes == S_OK )
        {
			// set security authentication
            hRes = pClientSecurity->SetBlanket( 
				pUnknown, dwAuthnSvc, dwAuthzSvc, pwszPrincipal, 
				dwAuthLevel, dwImpLevel, pAuthInfo, dwCapabilities );

			// release
            SAFE_RELEASE( pClientSecurity );
        }
        else if ( hRes == E_NOINTERFACE )
		{
            hRes = S_OK;		// ignore no interface errors
		}
    }

	// release the IUnknown
	SAFE_RELEASE( pUnknown );

	// return the result
    return hRes;
}

// ***************************************************************************
// Routine Description:
//		Allocate memory for authentication variables.
//		  
// Arguments:
//		pwszUser [in/out]     - User name.
//		pwszPassword [in/out] - Password.
//		pwszDomain [in/out]   - Domain name.
//		ppAuthIdent [in/out]  - Poointer to authentication structure.
//  
// Return Value:
//		Returns HRESULT value.
// ***************************************************************************
HRESULT WINAPI WbemAllocAuthIdentity( LPCWSTR pwszUser,
									  LPCWSTR pwszPassword, 
									  LPCWSTR pwszDomain,
									  COAUTHIDENTITY **ppAuthIdent )
{
	// local variables
    COAUTHIDENTITY *pAuthIdent = NULL;

	// validate the input parameter
    if ( ppAuthIdent == NULL )
	{
        return WBEM_E_INVALID_PARAMETER;
	}
    // allocation thru COM API
    pAuthIdent = ( COAUTHIDENTITY* ) CoTaskMemAlloc( sizeof( COAUTHIDENTITY ) );
    if ( NULL == pAuthIdent )
	{
        return WBEM_E_OUT_OF_MEMORY;
	}
	// init with 0's
    ZeroMemory( ( void* ) pAuthIdent, sizeof( COAUTHIDENTITY ) );

	//
	// Allocate needed memory and copy in data.  Cleanup if anything goes wrong

	// user
    if ( pwszUser != NULL )
    {
		// allocate memory for user
		LONG lLength = wcslen( pwszUser ); 
        pAuthIdent->User = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
		if ( pAuthIdent->User == NULL )
		{
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->UserLength = lLength;
        wcscpy( pAuthIdent->User, pwszUser );
    }

	// domain
    if ( pwszDomain != NULL )
    {
		// allocate memory for domain
		LONG lLength = wcslen( pwszDomain ); 
        pAuthIdent->Domain = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Domain == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->DomainLength = lLength;
        wcscpy( pAuthIdent->Domain, pwszDomain );
    }

	// passsord
    if ( pwszPassword != NULL )
    {
		// allocate memory for passsord
		LONG lLength = wcslen( pwszPassword ); 
        pAuthIdent->Password = ( LPWSTR ) CoTaskMemAlloc( (lLength + 1) * sizeof( WCHAR ) );
        if ( pAuthIdent->Password == NULL )
        {
            WbemFreeAuthIdentity( &pAuthIdent );
            return WBEM_E_OUT_OF_MEMORY;
        }

		// set the length and do copy contents
        pAuthIdent->PasswordLength = lLength;
        wcscpy( pAuthIdent->Password, pwszPassword );
    }

	// type of the structure
    pAuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // final set the address to out parameter
	*ppAuthIdent = pAuthIdent;

	// return result
    return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Frees the memory of authentication stucture	variable.
//
// Arguments:
//		ppAuthIdentity [in] - Pointer to authentication structure.
//
// Return Value:
//		none. 
// ***************************************************************************
VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY** ppAuthIdentity )
{
    // make sure we have a pointer, then walk the structure members and  cleanup.
    if ( *ppAuthIdentity != NULL )
    {
		// free the memory allocated for user
        if ( (*ppAuthIdentity)->User != NULL )
		{
            CoTaskMemFree( (*ppAuthIdentity)->User );
		}
		// free the memory allocated for password
        if ( (*ppAuthIdentity)->Password != NULL )
		{
            CoTaskMemFree( (*ppAuthIdentity)->Password );
		}
		// free the memory allocated for domain
        if ( (*ppAuthIdentity)->Domain != NULL )
		{
            CoTaskMemFree( (*ppAuthIdentity)->Domain );
		}
        // final the structure
		CoTaskMemFree( *ppAuthIdentity );
    }

	// set to NULL
	*ppAuthIdentity = NULL;
}

// ***************************************************************************
// Routine Description:
//		Gets WMI error description.
//
// Arguments:
//		hResError [in] - Contain error value.
//
// Return Value:
//		none.	
// ***************************************************************************
VOID WMISaveError( HRESULT hResError )
{
	// local variables
	HRESULT hRes;
	IWbemStatusCodeText *pWbemStatus = NULL;

	CHString strBuffer = NULL_STRING;

	// if the error is win32 based, choose FormatMessage to get the message
	switch( hResError )
	{
	case E_ACCESSDENIED:			// Message: "Access Denied"
	case ERROR_NO_SUCH_USER:		// Message: "The specified user does not exist."
		{
			// change the error message to "Logon failure: unknown user name or bad password." 
			if ( hResError == E_ACCESSDENIED )
			{
				hResError = ERROR_LOGON_FAILURE;
			}
			// ...
			SetLastError( hResError );
			SaveLastError();
			return;
		}
	}

	try
	{
		// get the pointer to buffer
		LPWSTR pwszBuffer = NULL;
		pwszBuffer = strBuffer.GetBufferSetLength( MAX_STRING_LENGTH );

		// get the wbem specific status code text
		hRes = CoCreateInstance( CLSID_WbemStatusCodeText, 
			NULL, CLSCTX_INPROC_SERVER, IID_IWbemStatusCodeText, ( LPVOID* ) &pWbemStatus );

		// check whether we got the interface or not
		if ( SUCCEEDED( hRes ) )
		{
			// get the error message
			BSTR bstr = NULL;
			hRes = pWbemStatus->GetErrorCodeText( hResError, 0, 0, &bstr );
			if ( SUCCEEDED( hRes ) )
			{
				// get the error message in proper format
				GetCompatibleStringFromUnicode( bstr, pwszBuffer, MAX_STRING_LENGTH );

				//
				// supress all the new-line characters and add '.' at the end ( if not exists )
				LPWSTR pwszTemp = NULL;
				pwszTemp = wcstok( pwszBuffer, L"\r\n" );

				if( pwszTemp == NULL )
				{
					_com_issue_error( WBEM_E_INVALID_PARAMETER );	
				}
				if ( *( pwszTemp + lstrlenW( pwszTemp ) - 1 ) != L'.' )
				{
					lstrcatW( pwszTemp, L"." );
				}
				// free the BSTR
				SysFreeString( bstr );
				bstr = NULL;

				// now release status code interface
				SAFE_RELEASE( pWbemStatus );
			}
			else
			{
				// failed to get the error message ... get the com specific error message
				_com_issue_error( hResError );
			}
		}
		else
		{
			// failed to get the error message ... get the com specific error message
			_com_issue_error( hResError );
		}

		// release the buffer
		strBuffer.ReleaseBuffer();
		// set the reason
		strBuffer += L"\n";
		SetReason( strBuffer );

	}
	catch( _com_error& e )
	{
		try
		{
			// get the error message
			strBuffer.ReleaseBuffer();
			if ( e.ErrorMessage() != NULL )
			{
				strBuffer = e.ErrorMessage();
			}
		}
		catch( ... )
		{
			SetLastError( E_OUTOFMEMORY );
			SaveLastError();
		}
	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return;
	}


}

// ***************************************************************************
// Routine Description:
//		  
// Arguments:
//  
// Return Value:
// 
// ***************************************************************************
DWORD GetTargetVersionEx( IWbemServices* pWbemServices, COAUTHIDENTITY* pAuthIdentity )
{
	// local variables
	HRESULT hRes;
	LONG lPos = 0;
	DWORD dwMajor = 0;
	DWORD dwMinor = 0;
	DWORD dwVersion = 0;
	ULONG ulReturned = 0;
	IWbemClassObject* pWbemObject = NULL;
	IEnumWbemClassObject* pWbemInstances = NULL;

	// check the input value
	if ( pWbemServices == NULL )
		return 0;

	try
	{
		CHString strVersion;
		// get the OS information
		SAFE_EXECUTE( pWbemServices->CreateInstanceEnum( 
			_bstr_t( CLASS_CIMV2_Win32_OperatingSystem ), 0, NULL, &pWbemInstances ) );

		// set the security on the enumerated object
		SAFE_EXECUTE( SetInterfaceSecurity( pWbemInstances, pAuthIdentity ) );

		// get the enumerated objects information
		// NOTE: This needs to be traversed only one time. 
		SAFE_EXECUTE( pWbemInstances->Next( WBEM_INFINITE, 1, &pWbemObject, &ulReturned ) );

		// to be on safer side ... check the count of objects returned
		if ( ulReturned == 0 )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// now get the os version value
		if ( PropertyGet( pWbemObject, L"Version", strVersion ) == FALSE )
		{
			// release the interfaces
			SAFE_RELEASE( pWbemObject );
			SAFE_RELEASE( pWbemInstances );
			return 0;
		}

		// release the interfaces .. we dont need them furthur
		SAFE_RELEASE( pWbemObject );
		SAFE_RELEASE( pWbemInstances );
	
		//
		// now determine the os version
		dwMajor = dwMinor = 0;

		// get the major version
		lPos = strVersion.Find( L'.' );
		if ( lPos == -1 )
		{
			// the version string itself is version ... THIS WILL NEVER HAPPEN
			dwMajor = AsLong( strVersion, 10 );
		}
		else
		{
			// major version
			dwMajor = AsLong( strVersion.Mid( 0, lPos ), 10 );

			// get the minor version
			strVersion = strVersion.Mid( lPos + 1 );
			lPos = strVersion.Find( L'.' );
			if ( lPos == -1 )
				dwMinor = AsLong( strVersion, 10 );
			else
				dwMinor = AsLong( strVersion.Mid( 0, lPos ), 10 );
		}

		// mix the version info
		dwVersion = dwMajor * 1000 + dwMinor;
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return 0;
	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return 0;
	}

	// return 
	return dwVersion;
}


// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, VARIANT* pvarValue )
{
	// local variables
	HRESULT hr;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL || pvarValue == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, pvarValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( pvarValue );

			// failed to get the value for the property
			return hr;
		}
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] szProperty		: property name
//		[ out ] varValue		: value of the property
//  
// Return Value:
//		HRESULT - result of the operation
// 
// ***************************************************************************
HRESULT PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, _variant_t& varValue )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return WBEM_E_INVALID_PARAMETER;

	try
	{
		// initialize the variant and then get the value of the specified property
		VariantInit( &vtValue );
		hr = pWmiObject->Get( _bstr_t( pwszProperty ), 0, &vtValue, NULL, NULL );
		if ( FAILED( hr ) )
		{
			// clear the variant variable
			VariantClear( &vtValue );

			// failed to get the value for the property
			return hr;
		}

		// set the value
		varValue = vtValue;

		// clear the variant variable
		VariantClear( &vtValue );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return e.Error();
	}

	// inform success
	return S_OK;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty, CHString& strValue, LPCWSTR pwszDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first copy the default value
	strValue = pwszDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	try
	{
		// get the value
		if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
			strValue = (LPCWSTR) _bstr_t( var );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//		[ in ] pWmiObject		: pointer to the WBEM class object
//		[ in ] pwszProperty		: property name
//		[ out ] pdwValue		: value of the property
//		[ in ] dwDefault		: default in case failed in getting property value
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, 
				  LPCWSTR pwszProperty,  DWORD& dwValue, DWORD dwDefault )
{
	// local variables
	HRESULT hr;
	_variant_t var;

	// first set the defaul value
	dwValue = dwDefault;

	// check with object and property passed to the function are valid or not
	// if not, return failure
	if ( pWmiObject == NULL || pwszProperty == NULL )
		return FALSE;

	// get the value of the property
	hr = PropertyGet( pWmiObject, pwszProperty, var );
	if ( FAILED( hr ) )
		return FALSE;

	// get the process id from the variant
	if ( var.vt != VT_NULL && var.vt != VT_EMPTY )
		dwValue = (LONG) var;

	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  ULONGLONG& ullValue )
{
	try
	{

		// local variables
		CHString str;

		// first set the default value
		ullValue = 1;

		// check with object and property passed to the function are valid or not
		// if not, return failure
		if ( pWmiObject == NULL || pwszProperty == NULL )
			return FALSE;

		// get the value of the property
		if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
			return FALSE;

		// get the 64-bit value
		ullValue = _wtoi64( str );
	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  WBEMTime& wbemtime )
{
	try
	{
		// local variables
		CHString str;

		// Clear method sets the time in the WBEMTime object to an invalid time.
		wbemtime.Clear();

		// check with object and property passed to the function are valid or not
		// if not, return failure
		if ( pWmiObject == NULL || pwszProperty == NULL )
			return FALSE;

		// get the value of the property
		if ( PropertyGet( pWmiObject, pwszProperty, str, _T( "0" ) ) == FALSE )
			return FALSE;

		// convert into the time value
		wbemtime = _bstr_t( str );
	}
	catch( _com_error& e )
	{
		WMISaveError( e );
		return FALSE;
	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty,  SYSTEMTIME& systime )
{
	try
	{
		// local variables
		CHString strTime;

		// check with object and property passed to the function are valid or not
		// if not, return failure
		if ( pWmiObject == NULL || pwszProperty == NULL )
			return FALSE;

		// get the value of the property
		// 16010101000000.000000+000 is the default time
		if ( PropertyGet( pWmiObject, pwszProperty, strTime, _T( "16010101000000.000000+000" ) ) == FALSE )
			return FALSE;

		// prepare the systemtime structure
		// yyyymmddHHMMSS.mmmmmmsUUU
		systime.wYear = (WORD) AsLong( strTime.Left( 4 ), 10 );
		systime.wMonth = (WORD) AsLong( strTime.Mid( 4, 2 ), 10 );
		systime.wDayOfWeek = 0;
		systime.wDay = (WORD) AsLong( strTime.Mid( 6, 2 ), 10 );
		systime.wHour = (WORD) AsLong( strTime.Mid( 8, 2 ), 10 );
		systime.wMinute = (WORD) AsLong( strTime.Mid( 10, 2 ), 10 );
		systime.wSecond = (WORD) AsLong( strTime.Mid( 12, 2 ), 10 );
		systime.wMilliseconds = (WORD) AsLong( strTime.Mid( 15, 6 ), 10 );
	}
	catch(CHeap_Exception)
	{	
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		return FALSE;
	}
	// return
	return TRUE;
}

// ***************************************************************************
// Routine Description:
//		Gets the value of the property from the WMI class object in string format
//		  
// Arguments:
//  
// Return Value:
//		TRUE - if operation is successfull, otherwise FALSE
// 
// ***************************************************************************
BOOL PropertyGet( IWbemClassObject* pWmiObject, LPCWSTR pwszProperty, TARRAY arr )
{
	// local variables
	HRESULT hr;
	VARIANT vtValue;
	LONG lIndex = 0;
	LONG lLBound = 0;
	LONG lUBound = 0;
	VARTYPE vartype;
	SAFEARRAY* pSafeArray = NULL;

	// check the inputs
	if ( pWmiObject == NULL || pwszProperty == NULL || arr == NULL )
		return FALSE;

	// initialize the variant
	VariantInit( &vtValue );

	// now get the property value
	hr = PropertyGet( pWmiObject, pwszProperty, &vtValue );
	if ( FAILED( hr ) )
		return FALSE;

	if ( V_VT( &vtValue ) == VT_NULL )
		return TRUE;

		// confirm that the propety value is of array type .. if not return
	if ( ( V_VT( &vtValue ) & VT_ARRAY ) == 0 )
		return FALSE;

	// get the safearray value
	pSafeArray = V_ARRAY( &vtValue );

	// get the bounds of the array
    hr = SafeArrayGetLBound( pSafeArray, 1, &lLBound );
	if ( FAILED( hr ) )
		return FALSE;

    hr = SafeArrayGetUBound( pSafeArray, 1, &lUBound );
	if ( FAILED( hr ) )
		return FALSE;

	// get the type of the elements in the safe array
	vartype = V_VT( &vtValue ) & ~VT_ARRAY;

	try
	{
		// traverse thru the values in the safe array and update into dynamic array
		for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
		{
			// sub-local variables
			VARIANT var;
			CHString strValue;
			
			// get the value
			V_VT( &var ) = vartype;
			SafeArrayGetElement( pSafeArray, &lIndex, &V_UI1( &var ) );

			// add the information to the dynamic array
			switch( vartype )
			{
			case VT_BSTR:
				strValue = V_BSTR( &var );
				DynArrayAppendString( arr, strValue, 0 );
				break;
			}
		}
	}
	catch( ... )
	{
		// clear the variant
		VariantClear( &vtValue );
		return FALSE;	// failure
	}

	// clear the variant
	VariantClear( &vtValue );

	// return
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\getmac\getmac.cpp ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		GETMAC.CPP
//  
//  Abstract:
//		Get MAC addresses and the related information of the network
//		adapters that exists either on a local system or on a remote system.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 26-sep-2k : Created It.
//		Vasundhara .G 31-oct-2k : Modified It. 
//								  Moved all hard coded string to header file.
//***************************************************************************

// Include files
#include "pch.h"
#include "getmac.h"
#include "resource.h"

// function prototypes
BOOL ParseCmdLine( DWORD     argc,
				   LPCTSTR   argv[],
				   CHString& strMachineName,
				   CHString& strUserName,
				   CHString& strPassword,
				   CHString& strFormat,
				   BOOL		 *pbVerbose,
				   BOOL      *pbHeader,
				   BOOL      *pbUsage,
				   BOOL	     *pbNeedPassword );

void DisplayUsage();

BOOL ComInitialize( IWbemLocator **ppIWbemLocator );

BOOL GetMacData( TARRAY					arrMacData,
				 LPCTSTR				lpMachineName,
				 IEnumWbemClassObject   *pAdapterConfig,
			 	 COAUTHIDENTITY			*pAuthIdentity,
			 	 IWbemServices		    *pIWbemServiceDef,
			     IWbemServices		    *pIWbemServices,
 	 			 TARRAY				    arrNetProtocol );

BOOL GetW2kMacData( TARRAY					arrMacData,
					LPCTSTR					lpMachineName, 
					IEnumWbemClassObject	*pAdapterConfig,
	 				IEnumWbemClassObject	*pAdapterSetting,
			 		IWbemServices			*pIWbemServiceDef,
				    IWbemServices		    *pIWbemServices,
					COAUTHIDENTITY			*pAuthIdentity,
 	 				TARRAY					arrNetProtocol );

BOOL GetTransName( IWbemServices		*pIWbemServiceDef,
				   IWbemServices		*pIWbemServices,
 	 			   TARRAY				arrNetProtocol,
				   TARRAY				arrTransName,
				   COAUTHIDENTITY		*pAuthIdentity,
				   LPCTSTR				lpMacAddr );

BOOL  GetConnectionName( TARRAY					arrMacData,
						 DWORD					dwIndex,
						 LPCTSTR				lpFormAddr,
						 IEnumWbemClassObject	*pAdapterSetting,
						 IWbemServices			*pIWbemServiceDef );

BOOL GetNwkProtocol( TARRAY					arrNetProtocol,
 	 				 IEnumWbemClassObject	*pNetProtocol );

BOOL FormatHWAddr( LPTSTR  lpRawAddr,
				   LPTSTR  lpFormattedAddr,
				   LPCTSTR lpFormatter );

BOOL DisplayResults( TARRAY   arrMacData,
					 LPCTSTR  lpFormat,
					 BOOL     bHeader,
					 BOOL	  bVerbose );

BOOL CallWin32Api( LPBYTE  *lpBufptr,
				   LPCTSTR lpMachineName,
				   DWORD   *pdwNumofEntriesRead );

BOOL CheckVersion( BOOL bLocalSystem,
				   COAUTHIDENTITY *pAuthIdentity,
				   IWbemServices *pIWbemServices );

/****************************************************************************
// Routine Description:
//		Main function which calls all the other functions depending on the
//		option specified by the user.
//                         
// Arguments:
//		argc [in] - Number of command line arguments.
//		argv [in] - Array containing command line arguments.
//
// Return Value:
//		EXIT_FAILURE if Getmac utility is not successful.
//		EXIT_SUCCESS if Getmac utility is successful.
*****************************************************************************/
DWORD _cdecl _tmain( DWORD argc,
					 LPCTSTR argv[] )
{
	//local variables
	HRESULT		hRes = WBEM_S_NO_ERROR;
	HRESULT		hResult = WBEM_S_NO_ERROR;
	DWORD		dwVersion = 0;
	
	TARRAY					arrMacData = NULL;
	TARRAY					arrNetProtocol = NULL;
	IWbemLocator			*pIWbemLocator = NULL;
    IWbemServices			*pIWbemServices = NULL;
	IWbemServices			*pIWbemServiceDef = NULL;
	IEnumWbemClassObject	*pAdapterConfig = NULL;
	IEnumWbemClassObject	*pNetProtocol = NULL;
	IEnumWbemClassObject	*pAdapterSetting = NULL;
	COAUTHIDENTITY			*pAuthIdentity = NULL;

    BOOL	bHeader = FALSE;
	BOOL	bUsage = FALSE;
	BOOL	bVerbose = FALSE;
	BOOL	bFlag = FALSE;
	BOOL	bNeedPassword = FALSE;
	BOOL	bCloseConnection = FALSE;
	BOOL	bLocalSystem = FALSE;

	try
	{
		CHString	strUserName = NULL_STRING;
		CHString	strPassword = NULL_STRING;
		CHString	strMachineName = NULL_STRING;
		CHString	strFormat = NULL_STRING; 

		//initialize dynamic array
		arrMacData  = CreateDynamicArray();
		if( arrMacData == NULL )
		{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			SetLastError( E_OUTOFMEMORY );
			ShowLastError( stderr );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}

		//parse the command line arguments
		bFlag = ParseCmdLine( argc, argv, strMachineName, strUserName,
				strPassword, strFormat, &bVerbose, &bHeader, &bUsage,
				&bNeedPassword );

		//if syntax of command line arguments is false display the error
		//and exit
		if( bFlag == FALSE )
		{
			DestroyDynamicArray( &arrMacData );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}

		//if usage is specified at command line, display usage
		if( bUsage == TRUE )
		{
				DisplayUsage();
				DestroyDynamicArray( &arrMacData );
				ReleaseGlobals();
				return( EXIT_SUCCESS );
		}

		//initialize com library
		bFlag = ComInitialize( &pIWbemLocator );
		//failed to initialize com or get IWbemLocator interface
		if( bFlag == FALSE ) 
		{
			SAFERELEASE( pIWbemLocator );
			CoUninitialize();
			DestroyDynamicArray( &arrMacData );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}

		// connect to CIMV2 name space
		bFlag = ConnectWmiEx( pIWbemLocator, &pIWbemServices, strMachineName,
					strUserName, strPassword, &pAuthIdentity, bNeedPassword,
					WMI_NAMESPACE_CIMV2, &bLocalSystem );

		//if unable to connect to wmi exit failure
		if( bFlag == FALSE )
		{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			DISPLAY_MESSAGE( stderr, GetReason() );
			SAFERELEASE( pIWbemLocator );
			SAFERELEASE( pIWbemServices );
			CoUninitialize();
			DestroyDynamicArray( &arrMacData );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}

		// set the security on the obtained interface
		hRes = SetInterfaceSecurity( pIWbemServices, pAuthIdentity );
		ONFAILTHROWERROR( hRes );		

		//connect to default namespace
		bFlag = ConnectWmi( pIWbemLocator, &pIWbemServiceDef, strMachineName,
					strUserName, strPassword, &pAuthIdentity, bNeedPassword,
					WMI_NAMESPACE_DEFAULT, &hResult, &bLocalSystem );
		if( bFlag == FALSE )
		{
			ONFAILTHROWERROR( hResult );		
		}

		// set the security on the obtained interface
		hRes = SetInterfaceSecurity( pIWbemServiceDef, pAuthIdentity );
		ONFAILTHROWERROR( hRes );		

		//get handle to win32_networkadapter class
		hRes = pIWbemServices->CreateInstanceEnum( NETWORK_ADAPTER_CLASS,
								WBEM_FLAG_RETURN_IMMEDIATELY,
								NULL, &pAdapterConfig );
		//if failed to enumerate win32_networkadapter class
		ONFAILTHROWERROR( hRes );		

		// set the security on the obtained interface
		hRes = SetInterfaceSecurity( pAdapterConfig, pAuthIdentity );
		//if failed to set security throw error
		ONFAILTHROWERROR( hRes );
		
		// get handle to win32_networkprotocol
		hRes = pIWbemServices->CreateInstanceEnum( NETWORK_PROTOCOL,
								WBEM_FLAG_RETURN_IMMEDIATELY,
								NULL, &pNetProtocol );
		//if failed to enumerate win32_networkprotocol class
		ONFAILTHROWERROR( hRes );		

		// set the security on the obtained interface
		hRes = SetInterfaceSecurity( pNetProtocol, pAuthIdentity );
		//if failed to set security throw error
		ONFAILTHROWERROR( hRes );

		//get handle to win32_networkadapterconfiguration class
		hRes = pIWbemServices->CreateInstanceEnum( NETWORK_ADAPTER_CONFIG_CLASS,
								WBEM_FLAG_RETURN_IMMEDIATELY,
								NULL, &pAdapterSetting );
		//if failed to enumerate win32_networkadapterconfiguration class
		ONFAILTHROWERROR( hRes );		

		// set the security on the obtained interface
		hRes = SetInterfaceSecurity( pAdapterSetting, pAuthIdentity );
		//if failed to set security throw error
		ONFAILTHROWERROR( hRes );

		arrNetProtocol  = CreateDynamicArray();
		if( arrNetProtocol == NULL )
		{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			SetLastError( E_OUTOFMEMORY );
			ShowLastError( stderr );
			SAFERELEASE( pIWbemLocator );
			SAFERELEASE( pIWbemServices );
			SAFERELEASE( pIWbemServiceDef );
			SAFERELEASE( pAdapterConfig );
			SAFERELEASE( pAdapterSetting );
			SAFERELEASE( pNetProtocol );
			CoUninitialize();
			DestroyDynamicArray( &arrMacData );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}

		//enumerate all the network protocols
		bFlag =  GetNwkProtocol( arrNetProtocol, pNetProtocol );
		if( bFlag == FALSE )
		{
			SAFERELEASE( pIWbemLocator );
			SAFERELEASE( pIWbemServices );
			SAFERELEASE( pIWbemServiceDef );
			SAFERELEASE( pAdapterConfig );
			SAFERELEASE( pAdapterSetting );
			SAFERELEASE( pNetProtocol );
			CoUninitialize();
			DestroyDynamicArray( &arrMacData );
			DestroyDynamicArray( &arrNetProtocol );
			ReleaseGlobals();
			return( EXIT_FAILURE );
		}
		else if( DynArrayGetCount( arrNetProtocol ) == 0 )
		{
			DISPLAY_MESSAGE( stdout, NO_NETWOK_PROTOCOLS );
		}
		else
		{
			//check whether the remote system under query is win2k or above
			if( CheckVersion( bLocalSystem, pAuthIdentity, pIWbemServices )
																	== TRUE )
			{
				// establish connection to remote system by using
				//win32api function
				if( bLocalSystem == FALSE )
				{
					LPCWSTR pwszUser = NULL;
					LPCWSTR pwszPassword = NULL;

					// identify the password to connect to the remote system
					if( pAuthIdentity != NULL )
					{
						pwszPassword = pAuthIdentity->Password;
						if( strUserName.GetLength() != 0 )
						{
							pwszUser = strUserName;
						}
					}

					// connect to the remote system
					DWORD dwConnect = 0;
					dwConnect = ConnectServer( strMachineName, pwszUser,
												pwszPassword );
					// check the result
					if( dwConnect != NO_ERROR )
					{
						//if session already exists display warning that
						//credentials conflict and proceed
						if( GetLastError() == ERROR_SESSION_CREDENTIAL_CONFLICT )
						{
							DISPLAY_MESSAGE( stdout, WARNING_STRING );
							SetLastError( ERROR_SESSION_CREDENTIAL_CONFLICT );
							ShowLastError( stdout );
						}
						else if( dwConnect == ERROR_EXTENDED_ERROR )
						{
							DISPLAY_MESSAGE( stderr, ERROR_STRING );
							DISPLAY_MESSAGE( stderr, GetReason() );
							SAFERELEASE( pIWbemLocator );
							SAFERELEASE( pIWbemServices );
							SAFERELEASE( pAdapterConfig );
							SAFERELEASE( pNetProtocol );
							SAFERELEASE( pAdapterSetting );
							SAFERELEASE( pIWbemServiceDef );
							CoUninitialize();
							DestroyDynamicArray( &arrMacData );
							DestroyDynamicArray( &arrNetProtocol );
							ReleaseGlobals();
							return( EXIT_SUCCESS );
						}
						else
						{
							SetLastError( dwConnect );
							DISPLAY_MESSAGE( stderr, ERROR_STRING );
							ShowLastError( stderr );
							SAFERELEASE( pIWbemLocator );
							SAFERELEASE( pIWbemServices );
							SAFERELEASE( pAdapterConfig );
							SAFERELEASE( pNetProtocol );
							SAFERELEASE( pAdapterSetting );
							SAFERELEASE( pIWbemServiceDef );
							CoUninitialize();
							DestroyDynamicArray( &arrMacData );
							DestroyDynamicArray( &arrNetProtocol );
							ReleaseGlobals();
							return( EXIT_SUCCESS );
						}
					}
					else
					{
						// connection needs to be closed
						bCloseConnection = TRUE;
					}
				}
				bFlag = GetW2kMacData( arrMacData, strMachineName, pAdapterConfig,
							   pAdapterSetting, pIWbemServiceDef, pIWbemServices,
							   pAuthIdentity, arrNetProtocol );

				//close the connection that is established by win32api
				if( bCloseConnection == TRUE )
				{
					CloseConnection( strMachineName );
				}
			}
			else
			{
				bFlag = GetMacData( arrMacData, strMachineName, pAdapterConfig,
								pAuthIdentity, pIWbemServiceDef, pIWbemServices,
								arrNetProtocol );
			}

			// if getmacdata() function fails exit with failure code
			if( bFlag == FALSE )
			{
				SAFERELEASE( pIWbemLocator );
				SAFERELEASE( pIWbemServices );
				SAFERELEASE( pAdapterConfig );
				SAFERELEASE( pNetProtocol );
				SAFERELEASE( pAdapterSetting );
				SAFERELEASE( pIWbemServiceDef );
				CoUninitialize();
				DestroyDynamicArray( &arrMacData );
				DestroyDynamicArray( &arrNetProtocol );
				ReleaseGlobals();
				return( EXIT_FAILURE );
			}

			//show the results if atleast one entry exists in dynamic array
			
			if( DynArrayGetCount( arrMacData ) != 0)
			{
				if( bLocalSystem == TRUE )
				{
					if( strUserName.GetLength() > 0 )
					{
						DISPLAY_MESSAGE( stdout, IGNORE_LOCALCREDENTIALS );
					}
				}
				DISPLAY_MESSAGE( stdout, NEW_LINE );
				bFlag = DisplayResults( arrMacData, strFormat, bHeader, bVerbose );
				if( bFlag == FALSE )
				{
					SAFERELEASE( pIWbemLocator );
					SAFERELEASE( pIWbemServices );
					SAFERELEASE( pAdapterConfig );
					SAFERELEASE( pNetProtocol );
					SAFERELEASE( pAdapterSetting );
					SAFERELEASE( pIWbemServiceDef );
					CoUninitialize();
					DestroyDynamicArray( &arrMacData );
					DestroyDynamicArray( &arrNetProtocol );
					ReleaseGlobals();
					return( EXIT_FAILURE );
				}
			}
			else
				DISPLAY_MESSAGE( stdout, NO_NETWORK_ADAPTERS );
		}
		//successfully retrieved the data then exit with EXIT_SUCCESS code
		SAFERELEASE( pIWbemLocator );
		SAFERELEASE( pIWbemServices );
		SAFERELEASE( pAdapterConfig );
		SAFERELEASE( pNetProtocol );
		SAFERELEASE( pAdapterSetting );
		SAFERELEASE( pIWbemServiceDef );
		CoUninitialize();
		DestroyDynamicArray( &arrMacData );
		DestroyDynamicArray( &arrNetProtocol );
		ReleaseGlobals();
		return( EXIT_SUCCESS );
	}
	catch(_com_error& e)
	{
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		SAFERELEASE( pIWbemLocator );
		SAFERELEASE( pIWbemServices );
		SAFERELEASE( pIWbemServiceDef );
		SAFERELEASE( pAdapterConfig );
		SAFERELEASE( pAdapterSetting );
		SAFERELEASE( pNetProtocol );
		CoUninitialize();
		DestroyDynamicArray( &arrMacData );
		ReleaseGlobals();
		return( EXIT_FAILURE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		SAFERELEASE( pIWbemLocator );
		SAFERELEASE( pIWbemServices );
		SAFERELEASE( pAdapterConfig );
		SAFERELEASE( pNetProtocol );
		SAFERELEASE( pAdapterSetting );
		SAFERELEASE( pIWbemServiceDef );
		CoUninitialize();
		DestroyDynamicArray( &arrMacData );
		DestroyDynamicArray( &arrNetProtocol );
		ReleaseGlobals();
		return( EXIT_FAILURE );
	}
}

/*****************************************************************************
// Routine Description:
//		This function parses the command line arguments which
//		are obtained as input parameters and gets the values
//		into the corresponding variables which are pass by address
//		parameters to this function.
//                         
// Arguments:
//		argc [in]                  - Number of command line arguments.
//		argv [in]                  - Array containing command line arguments.
//		strMachineName [in/out]    - To hold machine name.
//		strUserName [in/out]       - To hold User name.
//		strPassword [in/out]       - To hold Password.
//		strFormat [in/out]         - To hold the formatted string.
//		pbVerbose [in/out]         - tells whether verbose option is specified.
//		pbHeader [in/out]          - Header to required or not.
//		pbUsage  [in/out]          - usage is mentioned at command line.
//		pbNeedPassword  [in/out]   - Set to true if -p option is not specified
//									 at cmdline.
// Return Value:
//		TRUE  if command parser succeeds.
//		FALSE if command parser fails .
*****************************************************************************/
BOOL ParseCmdLine( DWORD     argc,
				   LPCTSTR   argv[],
				   CHString& strMachineName,
				   CHString& strUserName,
				   CHString& strPassword,
				   CHString& strFormat,
				   BOOL		 *pbVerbose,
				   BOOL      *pbHeader,
				   BOOL      *pbUsage,
				   BOOL      *pbNeedPassword )
{
	//local varibles
	BOOL		bFlag = FALSE;
	BOOL		bTempUsage = FALSE;
	BOOL		bTempHeader = FALSE;
	BOOL		bTempVerbose = FALSE;
	TCMDPARSER	tcmdOptions[MAX_OPTIONS];
	
	// temp variables
	LPWSTR pwszMachineName = NULL;
	LPWSTR pwszUserName = NULL;
	LPWSTR pwszPassword = NULL;
	LPWSTR pwszFormat = NULL;

	//validate input parameters
	if(  ( pbVerbose == NULL ) || ( pbHeader == NULL )
		|| ( pbUsage == NULL ) || (pbNeedPassword == NULL ) )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		ShowLastError( stderr );
		return FALSE;
	}

	try
	{
		pwszMachineName = strMachineName.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszUserName = strUserName.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszPassword = strPassword.GetBufferSetLength( MAX_STRING_LENGTH );
		pwszFormat = strFormat.GetBufferSetLength( MAX_STRING_LENGTH );

		// init the password with '*'
		lstrcpy( pwszPassword, L"*" );
	}
	catch( ... )
	{
		SetLastError( E_OUTOFMEMORY );
		SaveLastError();
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		ShowLastError( stderr );
		return FALSE;
	}

	//Initialize the valid command line arguments

	//machine option
	tcmdOptions[ CMD_PARSE_SERVER ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_SERVER ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_SERVER ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	tcmdOptions[ CMD_PARSE_SERVER ].pValue = pwszMachineName;
	tcmdOptions[ CMD_PARSE_SERVER ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_SERVER ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_SERVER ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_SERVER ].szOption, CMDOPTION_SERVER );
	
	// username option
	tcmdOptions[ CMD_PARSE_USER ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_USER ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_USER ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY;
	tcmdOptions[ CMD_PARSE_USER ].pValue = pwszUserName;
	tcmdOptions[ CMD_PARSE_USER ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_USER ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_USER ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_USER ].szOption, CMDOPTION_USER );
	
	// password option
	tcmdOptions[ CMD_PARSE_PWD ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_PWD ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_PWD ].dwFlags = CP_TYPE_TEXT | CP_VALUE_OPTIONAL;
	tcmdOptions[ CMD_PARSE_PWD ].pValue = pwszPassword;
	tcmdOptions[ CMD_PARSE_PWD ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_PWD ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_PWD ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_PWD ].szOption, CMDOPTION_PASSWORD );

	// format option
	tcmdOptions[ CMD_PARSE_FMT ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_FMT ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_FMT ].dwFlags = CP_TYPE_TEXT | CP_VALUE_MANDATORY |
										   CP_MODE_VALUES;
	tcmdOptions[ CMD_PARSE_FMT ].pValue = pwszFormat;
	tcmdOptions[ CMD_PARSE_FMT ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_FMT ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_FMT ].szValues, FORMAT_TYPES );
	lstrcpy( tcmdOptions[ CMD_PARSE_FMT ].szOption, CMDOPTION_FORMAT );

	//usage option
	tcmdOptions[ CMD_PARSE_USG ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_USG ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_USG ].dwFlags = CP_USAGE;
	tcmdOptions[ CMD_PARSE_USG ].pValue = &bTempUsage;
	tcmdOptions[ CMD_PARSE_USG ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_USG ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_USG ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_USG ].szOption, CMDOPTION_USAGE );

	//header option
	tcmdOptions[ CMD_PARSE_HRD ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_HRD ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_HRD ].dwFlags = CP_USAGE;
	tcmdOptions[ CMD_PARSE_HRD ].pValue = &bTempHeader;
	tcmdOptions[ CMD_PARSE_HRD ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_HRD ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_HRD ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_HRD ].szOption, CMDOPTION_HEADER );

	//verbose option
	tcmdOptions[ CMD_PARSE_VER ].dwCount = 1;
	tcmdOptions[ CMD_PARSE_VER ].dwActuals  = 0;
	tcmdOptions[ CMD_PARSE_VER ].dwFlags = CP_USAGE;
	tcmdOptions[ CMD_PARSE_VER ].pValue = &bTempVerbose;
	tcmdOptions[ CMD_PARSE_VER ].pFunction = NULL;
	tcmdOptions[ CMD_PARSE_VER ].pFunctionData = NULL;
	lstrcpy( tcmdOptions[ CMD_PARSE_VER ].szValues, NULL_STRING );
	lstrcpy( tcmdOptions[ CMD_PARSE_VER ].szOption, CMDOPTION_VERBOSE );

	//parse the command line arguments
	bFlag = DoParseParam( argc, argv, MAX_OPTIONS, tcmdOptions );

	// release buffers allocated for temp variables
	strMachineName.ReleaseBuffer();
	strUserName.ReleaseBuffer();
	strPassword.ReleaseBuffer();
	strFormat.ReleaseBuffer();

	//if syntax of command line arguments is false display the error and exit
	if( bFlag == FALSE )
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		return( FALSE );
	}

	//if usage is specified at command line, then check whether any other
	//arguments are entered at the command line and if so display syntax
	//error 
	if( ( bTempUsage ) && ( argc > 2 )  )
	{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			SetLastError( MK_E_SYNTAX );
			ShowLastError( stderr );
			DISPLAY_MESSAGE( stderr, ERROR_TYPE_REQUEST );
			return( FALSE );
	}

	// return false if username is entered without machine name
	if ( ( tcmdOptions[ CMD_PARSE_USER ].dwActuals != 0 ) &&
				( tcmdOptions[ CMD_PARSE_SERVER ].dwActuals == 0 ) )
	{
		DISPLAY_MESSAGE( stderr, ERROR_USER_WITH_NOSERVER );
		return( FALSE );
	}

	//if password entered without username then return false
    if( ( tcmdOptions[ CMD_PARSE_USER ].dwActuals == 0 ) &&
				( tcmdOptions[ CMD_PARSE_PWD ].dwActuals != 0 ) )
	{
		DISPLAY_MESSAGE( stderr, ERROR_SERVER_WITH_NOPASSWORD );
		return( FALSE );
	}

	//if no header is specified with list format return FALSE else return TRUE
	if( ( ( StringCompare( GetResString( FR_LIST ), strFormat, TRUE, 0 ) ) == 0 )
																&& bTempHeader ) 
	{
		DISPLAY_MESSAGE( stderr, ERROR_INVALID_HEADER_OPTION );
		return( FALSE );
	}

	//if -s is entered with empty string
	if( ( tcmdOptions[ CMD_PARSE_SERVER ].dwActuals != 0 ) && 
									( lstrlen( strMachineName ) == 0 ) )
	{
		DISPLAY_MESSAGE( stderr, ERROR_NULL_SERVER );
		return( FALSE );
	}

	//if -u is entered with empty string
	if( ( tcmdOptions[ CMD_PARSE_USER ].dwActuals != 0 ) &&
									( lstrlen( strUserName ) == 0 ) )
	{
		DISPLAY_MESSAGE( stderr, ERROR_NULL_USER );
		return( FALSE );
	}


	//assign the data obtained from parsing to the call by address parameters
	*pbUsage = bTempUsage;
	*pbHeader = bTempHeader;
	*pbVerbose = bTempVerbose;
	
	if ( tcmdOptions[ CMD_PARSE_PWD ].dwActuals != 0 && strPassword.Compare( L"*" ) == 0 )
	{
		// user wants the utility to prompt for the password before trying to connect
		*pbNeedPassword = TRUE;
	}
	else if ( tcmdOptions[ CMD_PARSE_PWD ].dwActuals == 0 && 
	        ( tcmdOptions[ CMD_PARSE_SERVER ].dwActuals != 0 || tcmdOptions[ CMD_PARSE_USER ].dwActuals != 0 ) )
	{
		// -s, -u is specified without password ...
		// utility needs to try to connect first and if it fails then prompt for the password
		*pbNeedPassword = TRUE;
		strPassword.Empty();
	}

	//return true
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function displays the usage of getmac.exe.
//                         
// Arguments:
//		None.
//
// Return Value:
//		void
*****************************************************************************/
void DisplayUsage()
{ 
	DWORD dwIndex = 0;

	//redirect the usage to the console
	for( dwIndex = IDS_USAGE_BEGINING; dwIndex <= USAGE_END; dwIndex++ )
	{
		DISPLAY_MESSAGE( stdout, GetResString( dwIndex ) );
	}
}

/*****************************************************************************
// Routine Description:
//		This function initializes the com and set security
//                         
// Arguments:
//		ppIWbemLocator[in/out] - pointer to IWbemLocator.
//
// Return Value:
//		TRUE if initialize is successful.
//		FALSE if initialization fails.
*****************************************************************************/
BOOL ComInitialize( IWbemLocator **ppIWbemLocator)
{
	HRESULT  hRes = S_OK;

	try
	{
		hRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
		// COM initialization failed
		ONFAILTHROWERROR( hRes );

		// Initialize COM security for DCOM services, Adjust security to 
		// allow client impersonation
		hRes = CoInitializeSecurity( NULL, -1, NULL, NULL,
									 RPC_C_AUTHN_LEVEL_NONE, 
									 RPC_C_IMP_LEVEL_IMPERSONATE, 
									 NULL, EOAC_NONE, 0 );
		// COM security failed
		ONFAILTHROWERROR( hRes );

		//get IWbemLocator
		hRes = CoCreateInstance( CLSID_WbemLocator, 0, 
						CLSCTX_INPROC_SERVER, IID_IWbemLocator,
						(LPVOID *) ppIWbemLocator ); 
		//unable to get IWbemLocator
		ONFAILTHROWERROR( hRes );

	}
	catch( _com_error& e )
	{
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		return( FALSE );
	}
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function gets the media access control address of
//		the network adapters which are there either in the local
//		or on the remote network system of OS whistler and above.
//                         
// Arguments:
//		arrMacData [in/out]   - contains the MAC and other data of the
//								network adapter.
//		lpMachineName [in]    - holds machine name.
//		pAdapterConfig [in]   - interface to win32_networkadapter class.
//		pAuthIdentity [in]    - pointer to authentication structure.
//		pIWbemServiceDef [in] - interface to default name space.
//		pIWbemServices [in]   - interface to cimv2 name space.
//		pNetProtocol [in]     - interface to win32_networkprotocol class.
//
// Return Value:
//		TRUE if getmacdata is successful.
//		FALSE if getmacdata failed.
*****************************************************************************/
BOOL GetMacData( TARRAY					arrMacData,
				 LPCTSTR				lpMachineName,
				 IEnumWbemClassObject   *pAdapterConfig,
			 	 COAUTHIDENTITY			*pAuthIdentity,
			 	 IWbemServices		    *pIWbemServiceDef,
			 	 IWbemServices		    *pIWbemServices,
 	 			 TARRAY				    arrNetProtocol )
{
	//local variables
	HRESULT				hRes = S_OK;
	IWbemClassObject	*pAdapConfig = NULL;
	DWORD				dwReturned  = 1;
	DWORD				i = 0;
	BSTR				bstrTemp = NULL;
	BOOL				bFlag = TRUE;
	BOOL				bFlag1 = TRUE;
	TARRAY				arrTransName = NULL;

	VARIANT				varTemp;
	VARIANT				varStatus;

	//get the mac ,network adapter type and other details
	VariantInit( &varTemp );
	VariantInit( &varStatus );
	try
	{
		CHString			strAType = NULL_STRING;

		//validate input parametrs
		if( ( arrMacData == NULL ) || ( lpMachineName == NULL ) ||
			( pAdapterConfig == NULL ) || ( pIWbemServiceDef == NULL ) ||
			( pIWbemServices == NULL ) || ( arrNetProtocol == NULL ) )
		{
			ONFAILTHROWERROR( WBEM_E_INVALID_PARAMETER );
		}

		while ( ( dwReturned == 1 ) )
		{
			// Enumerate through the resultset.
			hRes = pAdapterConfig->Next( WBEM_INFINITE,
								1,				
								&pAdapConfig,	
								&dwReturned );	
			ONFAILTHROWERROR( hRes );
			if( dwReturned == 0 )
			{
				break;
			}
			hRes = pAdapConfig->Get( NETCONNECTION_STATUS, 0 , &varStatus,
																0, NULL );
			ONFAILTHROWERROR( hRes );

			if ( varStatus.vt == VT_NULL )
			{
				continue;
			}
			DynArrayAppendRow( arrMacData, 0 );
			hRes = pAdapConfig->Get( HOST_NAME, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
			}
			else
			{
				strAType = NOT_AVAILABLE; 
			}
			VariantClear( &varTemp );
			DynArrayAppendString2( arrMacData, i, strAType, 0 );//machine name

			hRes = pAdapConfig->Get( NETCONNECTION_ID, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
			}
			else
			{
				strAType = NOT_AVAILABLE; 
			}
			VariantClear( &varTemp );
			DynArrayAppendString2( arrMacData, i, strAType, 0 );// connection name 
			
			hRes = pAdapConfig->Get( NAME, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
			}
			else
			{
				strAType = NOT_AVAILABLE; 
			}
			VariantClear( &varTemp );
			DynArrayAppendString2( arrMacData, i, strAType, 0 );//Network adapter

			hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
				for( int i = 2; i < strAType.GetLength();i += 3 )
				{
					strAType.SetAt( i, HYPHEN_CHAR );
				}
			}
			else if( varStatus.lVal == 0 )
			{
				strAType = DISABLED;
			}
			else
			{
				strAType = NOT_AVAILABLE; 
			}
			VariantClear( &varTemp );
			DynArrayAppendString2( arrMacData, i, strAType, 0 ); //MAC address

			arrTransName = CreateDynamicArray();
			if( arrTransName == NULL )
			{
				DISPLAY_MESSAGE( stderr, ERROR_STRING );
				SetLastError( E_OUTOFMEMORY );
				ShowLastError( stderr );
				VariantClear( &varTemp );
				VariantClear( &varStatus );
				SAFERELEASE( pAdapConfig );
				return( FALSE );
			}
			if( varStatus.lVal == 2)
			{
				hRes = pAdapConfig->Get( DEVICE_ID, 0 , &varTemp, 0, NULL );
				ONFAILTHROWERROR( hRes );
				if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
				{
					strAType = ( LPCWSTR ) _bstr_t( varTemp );
				}
				bFlag = GetTransName( pIWbemServiceDef, pIWbemServices,
						arrNetProtocol,	arrTransName,pAuthIdentity,	strAType );
				if( bFlag == FALSE )
				{
					VariantClear( &varTemp );
					VariantClear( &varStatus );
					SAFERELEASE( pAdapConfig );
					DestroyDynamicArray( &arrTransName );
					return( FALSE );
				}
			}
			else
			{ 
				switch(varStatus.lVal)
				{
				case 0 :
					strAType = GetResString( IDS_DISCONNECTED );
					break;
				case 1 :
					strAType = GetResString( IDS_CONNECTING );
					break;
				case 3 :
					strAType = GetResString( IDS_DISCONNECTING );
					break;
				case 4 :
					strAType = GetResString( IDS_HWNOTPRESENT );
					break;
				case 5 :
					strAType = GetResString( IDS_HWDISABLED );
					break;
				case 6 :
					strAType = GetResString( IDS_HWMALFUNCTION );
					break;
				case 7 :
					strAType = GetResString( IDS_MEDIADISCONNECTED );
					break;
				case 8 :
					strAType = GetResString( IDS_AUTHENTICATION );
					break;
				case 9 :
					strAType = GetResString( IDS_AUTHENSUCCEEDED );
					break;
				case 10 :
					strAType = GetResString( IDS_AUTHENFAILED );
					break;
				default : 
					strAType = NOT_AVAILABLE;
					break;
				}//switch
				if( strAType == NULL_STRING )
				{
					VariantClear( &varTemp );
					VariantClear( &varStatus );
					DISPLAY_MESSAGE( stderr, ERROR_STRING );
					DISPLAY_MESSAGE( stderr, GetReason() );
					SAFERELEASE( pAdapConfig );
					return( FALSE );
				}
				DynArrayAppendString( arrTransName, strAType, 0 );
			}//else
			//insert transport name array into results array
			DynArrayAppendEx2( arrMacData, i, arrTransName );
			i++;
			SAFERELEASE( pAdapConfig );
		}//while
		
	}//try

	catch( _com_error& e )
	{
		VariantClear( &varTemp );
		VariantClear( &varStatus );
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		SAFERELEASE( pAdapConfig );
		return( FALSE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		VariantClear( &varTemp );
		VariantClear( &varStatus );
		SAFERELEASE( pAdapConfig );
		return( FALSE );
	}
	//if arrmacdata and not arrtransname then set transname to N/A
	if( DynArrayGetCount( arrMacData ) > 0 &&
							DynArrayGetCount( arrTransName ) <= 0  )
	{
		DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
		DynArrayAppendEx2( arrMacData, i, arrTransName );
	}

	VariantClear( &varTemp );
	VariantClear( &varStatus );
	SAFERELEASE( pAdapConfig );
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function display the results in the specified format.
//                         
// Arguments:
//		arrMacData [in] - Data to be displayed on to the  console.
//	  	lpFormat [in]   - Holds the formatter string in which the results
//						  are to be displayed.
//		bHeader [in]    - Holds whether the header has to be dislpayed in the
//						  results or not.
//		bVerbose [in]   - Hold whether verbose option is specified or not.
//
// Return Value:
//		void.
*****************************************************************************/
BOOL DisplayResults( TARRAY   arrMacData,
					 LPCTSTR  lpFormat,
					 BOOL     bHeader,
					 BOOL     bVerbose )
{
	//local variables
	DWORD       dwFormat = 0;
	TCOLUMNS	tColumn[MAX_COLUMNS];

	//validate input parameters
	if( arrMacData == NULL )
	{
		SetLastError( E_OUTOFMEMORY );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		ShowLastError( stderr );
		return( FALSE );
	}

	for( DWORD i = 0; i < MAX_COLUMNS; i++ )
	{
		tColumn[i].pFunction = NULL;
		tColumn[i].pFunctionData = NULL;
		lstrcpy( tColumn[i].szFormat, NULL_STRING ); 
	}

	//host name
	tColumn[ SH_RES_HOST ].dwWidth = HOST_NAME_WIDTH;
	/*if( bVerbose == TRUE )
		tColumn[ SH_RES_HOST ].dwFlags = SR_TYPE_STRING;
	else*/
		tColumn[ SH_RES_HOST ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	lstrcpy( tColumn[ SH_RES_HOST ].szColumn, RES_HOST_NAME );

	//connection name
	tColumn[ SH_RES_CON ].dwWidth = CONN_NAME_WIDTH;
	if( bVerbose == TRUE )
	{
		tColumn[ SH_RES_CON ].dwFlags = SR_TYPE_STRING;
	}
	else
	{
		tColumn[ SH_RES_CON ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	}
	lstrcpy( tColumn[ SH_RES_CON ].szColumn, RES_CONNECTION_NAME );

	//Adpater type
	tColumn[ SH_RES_TYPE ].dwWidth = ADAPT_TYPE_WIDTH;
	if( bVerbose == TRUE )
	{
		tColumn[ SH_RES_TYPE ].dwFlags = SR_TYPE_STRING;
	}
	else
	{
		tColumn[ SH_RES_TYPE ].dwFlags = SR_TYPE_STRING | SR_HIDECOLUMN;
	}
	lstrcpy( tColumn[ SH_RES_TYPE ].szColumn, RES_ADAPTER_TYPE );

	//mac address
	tColumn[ SH_RES_MAC ].dwWidth = MAC_ADDR_WIDTH;
	tColumn[ SH_RES_MAC ].dwFlags = SR_TYPE_STRING;
	lstrcpy( tColumn[ SH_RES_MAC ].szColumn, RES_MAC_ADDRESS );

	//transport name
	tColumn[ SH_RES_TRAN ].dwWidth = TRANS_NAME_WIDTH;
	tColumn[ SH_RES_TRAN ].dwFlags = SR_ARRAY | SR_TYPE_STRING | SR_NO_TRUNCATION ;
	lstrcpy( tColumn[ SH_RES_TRAN ].szColumn, RES_TRANS_NAME );

	//get the display results formatter string
	if( lpFormat == NULL )
	{
		dwFormat = SR_FORMAT_TABLE;
	}
	else if( ( StringCompare( GetResString( FR_LIST ), lpFormat, TRUE, 0 ) ) == 0 )
	{
		dwFormat = SR_FORMAT_LIST;
	}
	else if ( ( StringCompare( GetResString( FR_CSV ), lpFormat, TRUE, 0 ) ) == 0 )
	{
		dwFormat = SR_FORMAT_CSV;
	}
	else if( ( StringCompare( GetResString( FR_TABLE ), lpFormat, TRUE, 0 ) ) == 0 )
	{
		dwFormat = SR_FORMAT_TABLE;
	}
	else
	{
		dwFormat = SR_FORMAT_TABLE;
	}
	//look for header and display accordingly
	if( bHeader == TRUE )
	{
		ShowResults( 5, tColumn, dwFormat | SR_NOHEADER, arrMacData );
	}
	else
	{
		ShowResults( 5, tColumn, dwFormat, arrMacData );
	}
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function gets transport name of the network adapter.
//                         
// Arguments:
//		pIWbemServiceDef [in]   - interface to default name space.
//		pIWbemServices [in]     - interface to CIMV2 name space.
//		pNetProtocol [in]		- interface to win32_networkprotocol.
//	  	arrTransName [in/out]   - Holds the transport name.
//	  	pAuthIdentity [in]      - pointer to authentication structure.
//	  	lpDeviceId [in]         - Holds the device id.
//
// Return Value:
//		TRUE if successful.
//		FALSE if failed to get transport name.
*****************************************************************************/
BOOL GetTransName( IWbemServices		*pIWbemServiceDef,
				   IWbemServices		*pIWbemServices,
 	 			   TARRAY				arrNetProtocol,
				   TARRAY				arrTransName,
   			 	   COAUTHIDENTITY		*pAuthIdentity,
				   LPCTSTR				lpDeviceId )
{
	BOOL				bFlag = FALSE;
	DWORD				dwCount = 0;
	DWORD				i = 0;
	DWORD				dwOnce = 0;
	HRESULT				hRes = 0;

	DWORD				dwReturned = 1;
	IWbemClassObject	*pSetting = NULL;
	IWbemClassObject	*pClass = NULL;
    IWbemClassObject	*pOutInst = NULL;
    IWbemClassObject	*pInClass = NULL;
    IWbemClassObject	*pInInst = NULL;
	IEnumWbemClassObject *pAdapterSetting = NULL;
	
	VARIANT				varTemp;
	LPTSTR				lpKeyPath = NULL;
	SAFEARRAY           *safeArray = NULL;
	LONG                lLBound = 0;
    LONG                lUBound = 0;
    LONG                lSubScript[1];
   	LONG				lIndex = 0;
	TCHAR				szTemp[ MAX_STRING_LENGTH ] = NULL_STRING;

	VariantInit( &varTemp );
	try
	{
		CHString			strAType = NULL_STRING;
		CHString			strSetId = NULL_STRING;

		//validate input parameters
		if( ( pIWbemServiceDef == NULL ) || ( pIWbemServices == NULL ) ||
		    ( arrNetProtocol == NULL ) || ( arrTransName == NULL ) || 
			( lpDeviceId == NULL ) )
		{
			ONFAILTHROWERROR( WBEM_E_INVALID_PARAMETER );			
		}

		wsprintf( szTemp, ASSOCIATOR_QUERY, lpDeviceId );
		hRes =  pIWbemServices->ExecQuery( QUERY_LANGUAGE, _bstr_t(szTemp),
					  WBEM_FLAG_RETURN_IMMEDIATELY, NULL, &pAdapterSetting );
		ONFAILTHROWERROR( hRes );

		hRes = SetInterfaceSecurity( pAdapterSetting, pAuthIdentity );
		//if failed to set security throw error
		ONFAILTHROWERROR( hRes );

		//get setting id
		while ( dwReturned == 1 )
		{
			// Enumerate through the resultset.
			hRes = pAdapterSetting->Next( WBEM_INFINITE,
								1,			
								&pSetting,	
								&dwReturned );	
			ONFAILTHROWERROR( hRes );
			if( dwReturned == 0 )
			{
				break;
			}
			hRes = pSetting->Get( SETTING_ID, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strSetId = ( LPCWSTR ) _bstr_t( varTemp );
				break;
			}						
		}//while
		dwCount = DynArrayGetCount( arrNetProtocol );
		lpKeyPath = ( LPTSTR )calloc( MAX_RES_STRING, sizeof( TCHAR ) );
		if( lpKeyPath == NULL )
		{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			SetLastError( E_OUTOFMEMORY );
			ShowLastError( stderr );
			SAFERELEASE( pSetting );
			FREESTRING( lpKeyPath );
			return( FALSE );
		}
		for( i = 0; i < dwCount; i++ )
		{
			if( StringCompare( ( DynArrayItemAsString( arrNetProtocol, i ) ),
													NETBIOS, TRUE, 0 )  == 0 )
			{
				continue;
			}
			hRes = pIWbemServiceDef->GetObject( WMI_REGISTRY, 0, NULL,
												&pClass, NULL );
			ONFAILTHROWERROR( hRes );
			hRes = pClass->GetMethod( WMI_REGISTRY_M_MSTRINGVALUE, 0,
													&pInClass, NULL ); 
			ONFAILTHROWERROR( hRes );
			hRes = pInClass->SpawnInstance(0, &pInInst);
			ONFAILTHROWERROR( hRes );
			varTemp.vt = VT_I4;
			varTemp.lVal = WMI_HKEY_LOCAL_MACHINE;
			hRes = pInInst->Put( WMI_REGISTRY_IN_HDEFKEY, 0, &varTemp, 0 );
			VariantClear( &varTemp );
			ONFAILTHROWERROR( hRes );

			lstrcpy( lpKeyPath, TRANSPORT_KEYPATH );
			lstrcat( lpKeyPath, DynArrayItemAsString( arrNetProtocol, i ) );
			lstrcat( lpKeyPath, LINKAGE );
			varTemp.vt = VT_BSTR;
			varTemp.bstrVal = SysAllocString( lpKeyPath );
			hRes = pInInst->Put( WMI_REGISTRY_IN_SUBKEY, 0, &varTemp, 0 );
			VariantClear( &varTemp );
			ONFAILTHROWERROR( hRes );

			varTemp.vt = VT_BSTR;
			varTemp.bstrVal = SysAllocString( ROUTE );
			hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0, &varTemp, 0 );
			VariantClear( &varTemp );
			ONFAILTHROWERROR( hRes );

			// Call the method.
			hRes = pIWbemServiceDef->ExecMethod( WMI_REGISTRY,
							WMI_REGISTRY_M_MSTRINGVALUE, 0, NULL, pInInst,
							&pOutInst, NULL );
			ONFAILTHROWERROR( hRes );

			varTemp.vt = VT_I4;
			hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0, &varTemp,
																	0, 0 );
			ONFAILTHROWERROR( hRes );

			if( varTemp.lVal == 0 )
			{
				VariantClear( &varTemp );
				varTemp.vt = VT_BSTR;
				hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0, &varTemp,
																	0, 0);
				ONFAILTHROWERROR( hRes );
				if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
				{
					safeArray = (SAFEARRAY *)varTemp.parray;
	                //get the number of elements (subkeys)
		            if( safeArray != NULL )
			        {
				        hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
						ONFAILTHROWERROR( hRes );
	                    hRes = SafeArrayGetUBound( safeArray, 1, &lUBound );
						ONFAILTHROWERROR( hRes );
						bFlag = FALSE;
						for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
						{
							hRes = SafeArrayGetElement( safeArray, &lIndex,
														&V_UI1( &varTemp ) );
							ONFAILTHROWERROR( hRes );
							strAType = V_BSTR( &varTemp );
							LPTSTR lpSubStr = _tcsstr( strAType, strSetId );
							if( lpSubStr != NULL )
							{
								bFlag = TRUE;
								break;
							}

						}
					}
				}
			}
			if( bFlag == TRUE )
			{
				varTemp.vt = VT_BSTR;
				varTemp.bstrVal = SysAllocString( EXPORT );
				hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0, &varTemp, 0 );
				VariantClear( &varTemp );
				ONFAILTHROWERROR( hRes );

				// Call the method.
				hRes = pIWbemServiceDef->ExecMethod( WMI_REGISTRY,
							WMI_REGISTRY_M_MSTRINGVALUE, 0, NULL, pInInst,
							&pOutInst, NULL );
				ONFAILTHROWERROR( hRes );

				varTemp.vt = VT_I4;
				hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0,
															&varTemp, 0, 0 );
				ONFAILTHROWERROR( hRes );

				if( varTemp.lVal == 0 )
				{
					VariantClear( &varTemp );
					varTemp.vt = VT_BSTR;
					hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0,
															&varTemp, 0, 0);
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						safeArray = varTemp.parray;
						//get the number of elements (subkeys)
						if( safeArray != NULL )
						{
							hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
							ONFAILTHROWERROR( hRes );
							hRes = SafeArrayGetUBound( safeArray, 1, &lUBound );
							ONFAILTHROWERROR( hRes );
							dwOnce = 0;
							for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
							{
								hRes = SafeArrayGetElement( safeArray, &lIndex,
															&V_UI1( &varTemp ) );
								ONFAILTHROWERROR( hRes );
								strAType = V_BSTR( &varTemp );
								LPTSTR lpSubStr = _tcsstr( strAType, strSetId );
								if( lpSubStr != NULL )
								{
									dwOnce = 1;
									DynArrayAppendString( arrTransName, strAType, 0 );
									break;
								}
							}
							if( dwOnce == 0 )
							{
								hRes = SafeArrayGetLBound( safeArray, 1, &lLBound );
								for( lIndex = lLBound; lIndex <= lUBound; lIndex++ )
								{
									hRes = SafeArrayGetElement( safeArray,
											&lIndex, &V_UI1( &varTemp ) );
									ONFAILTHROWERROR( hRes );
									strAType = V_BSTR( &varTemp );
									DynArrayAppendString( arrTransName, strAType, 0 );
								}
							}

						}
					}
				}
			}
		}//for
	}//try
	catch( _com_error& e )
	{
		VariantClear( &varTemp );
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		FREESTRING( lpKeyPath );
		SAFERELEASE( pSetting );
		SAFERELEASE( pClass );
		SAFERELEASE( pOutInst );
		SAFERELEASE( pInClass );
		SAFERELEASE( pInInst );
		return( FALSE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		VariantClear( &varTemp );
		FREESTRING( lpKeyPath );
		SAFERELEASE( pSetting );
		SAFERELEASE( pClass );
		SAFERELEASE( pOutInst );
		SAFERELEASE( pInClass );
		SAFERELEASE( pInInst );
		return( FALSE );
	}

	if( DynArrayGetCount( arrTransName ) <= 0 )
	{
		DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
	}
	FREESTRING( lpKeyPath );
	SAFERELEASE( pSetting );
	SAFERELEASE( pClass );
	SAFERELEASE( pOutInst );
	SAFERELEASE( pInClass );
	SAFERELEASE( pInInst );
	return( TRUE );

}

/*****************************************************************************
// Routine Description:
//		Format a 12 Byte Ethernet Address and return it as 6 2-byte
//		sets separated by hyphen.
//                         
// Arguments:
//		lpRawAddr [in]        - a pointer to a buffer containing the
//								unformatted hardware address.
//		lpFormattedAddr [out] - a pointer to a buffer in which to place
//								the formatted output.
//		lpFormatter [in]      - The Formatter string.
//
// Return Value:
//		void.
*****************************************************************************/
BOOL FormatHWAddr ( LPTSTR lpRawAddr,
				    LPTSTR lpFormattedAddr,
					LPCTSTR lpFormatter )
{
	//local variables
	DWORD dwLength =0;
	DWORD i=0;
	DWORD j=0;
	TCHAR szTemp[MAX_STRING] = NULL_STRING;

	if( ( lpRawAddr == NULL ) || ( lpFormattedAddr == NULL ) ||
								( lpFormatter == NULL ) )
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		return( FALSE );
	}
	

	//initialize memory
	ZeroMemory( szTemp, sizeof( szTemp ) );
	//get the length of the string to be formatted
	dwLength = lstrlen( lpRawAddr );
	
	//loop through the address string and insert formatter string
	//after every two characters

	while( i <= dwLength )
	{
		szTemp[j++] = lpRawAddr[i++];
		szTemp[j++] = lpRawAddr[i++];
		if( i >= dwLength )
		{
            break;
		}
		szTemp[j++] = lpFormatter[0];
	}
	//insert null character at the end
	szTemp[j] = NULL_CHAR;

	//copy the formatted string from temporary variable into the
	//output string
	lstrcpy( lpFormattedAddr, szTemp );

	return( TRUE );
}       

/*****************************************************************************
// Routine Description:
//		This function gets data into a predefined structure from win32 api.
//                         
// Arguments:
//		lpBufptr [in/out]        - To hold MAc and Transport names of all
//								   network adapters.
//	    lpMachineName [in]       - remote Machine name.
//	    pdwNumofEntriesRead [in] - Contains number of network adpaters api
//								   has enumerated.
//
// Return Value:
//		TRUE if Win32Api function is successful.
//		FALSE if win32api failed.
*****************************************************************************/
BOOL CallWin32Api( LPBYTE  *lpBufptr,
				   LPCTSTR lpMachineName,
				   DWORD   *pdwNumofEntriesRead )
{
		//local variables
	NET_API_STATUS  err = NERR_Success;
	DWORD           dwEntriesRead = 0;
	DWORD			dwConResult=0;      
	DWORD           dwNumofTotalEntries = 0;
	DWORD           dwResumehandle = 0;     
	LPWSTR          lpwMName  = NULL;

	//validate input parameters
	if( lpMachineName == NULL )
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		return( FALSE );
	}

	//allocate memory
	lpwMName = ( LPWSTR )calloc( MAX_STRING_LENGTH, sizeof( wchar_t ) );
	if( lpwMName == NULL )
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		return( FALSE );
	}

	if( lstrlen( lpMachineName ) != 0 )
	{
		//get the machine name as wide character string
		if( GetAsUnicodeString( lpMachineName, lpwMName, MAX_STRING_LENGTH )
																	== NULL )
		{
			DISPLAY_MESSAGE( stderr, ERROR_STRING );
			SetLastError( E_OUTOFMEMORY );
			ShowLastError( stderr );
			FREESTRING( lpwMName );
			return( FALSE );
		}
		//Call to an API function which enumerates the network adapters on the 
		//machine specified
		err = NetWkstaTransportEnum ( lpwMName,         
			0L,                      
			lpBufptr,               
			(DWORD) -1,              
			&dwEntriesRead,                                
			&dwNumofTotalEntries,                               
			&dwResumehandle );
	}
	else
	{
		//Call to an API function which enumerates the network adapters on the 
		//machine specified
		err = NetWkstaTransportEnum ( NULL,         
			0L,                      
			lpBufptr,               
			(DWORD) -1,              
			&dwEntriesRead,                                
			&dwNumofTotalEntries,                               
			&dwResumehandle );
	}

	FREESTRING( lpwMName );
	*pdwNumofEntriesRead = dwEntriesRead;
	//if error has been returned by the API then display the error message
	//just ignore the transport name and display the available data
    if ( err != NERR_Success ) 
	{    
		switch( GetLastError() )
		{
			case ERROR_IO_PENDING :
				DISPLAY_MESSAGE( stdout, NO_NETWORK_ADAPTERS );
				return( FALSE );
			case ERROR_ACCESS_DENIED :
				DISPLAY_MESSAGE( stderr, ERROR_STRING );
				ShowLastError( stderr );
				return( FALSE );
			case ERROR_NOT_SUPPORTED :
				DISPLAY_MESSAGE( stderr, ERROR_NOT_RESPONDING );
				return( FALSE );
			case ERROR_BAD_NETPATH :
				DISPLAY_MESSAGE( stderr, ERROR_NO_MACHINE );
				return( FALSE );
			case ERROR_INVALID_NAME :
				DISPLAY_MESSAGE( stderr, ERROR_INVALID_MACHINE );
				return( FALSE );
			case RPC_S_UNKNOWN_IF :
				DISPLAY_MESSAGE( stderr, ERROR_WKST_NOT_FOUND );
				return( FALSE );
			default : break;
		}
		return ( FALSE );
	} 

	return( TRUE );
}

/****************************************************************************
// Routine Description:
//		This function gets the media access control address of
//		the network adapters which are there on win2k or below.
//                         
// Arguments:
//		arrMacData [in/out]   - contains the MAC and other data of the network
//								adapter.
//		lpMachineName [in]    - holds machine name.
//		pAdapterConfig [in]   - interface to win32_networkadapter class.
//		pAdapterSetting [in]  - interface to win32_networkadapterconfiguration.
//		pIWbemServiceDef [in] - interface to default name space.
//		pIWbemServices [in]   - interface to cimv2 name space.
//		pAuthIdentity [in]    - pointer to authentication structure.
//		pNetProtocol [in]     - interface to win32_networkprotocol class
//
// Return Value:
//		TRUE if getmacdata is successful.
//		FALSE if getmacdata failed.
*****************************************************************************/
BOOL GetW2kMacData( TARRAY					arrMacData,
					LPCTSTR					lpMachineName, 
					IEnumWbemClassObject	*pAdapterConfig,
	 				IEnumWbemClassObject	*pAdapterSetting,
			 		IWbemServices			*pIWbemServiceDef,
			 	    IWbemServices		    *pIWbemServices,
			 		COAUTHIDENTITY			*pAuthIdentity,
		 			TARRAY				    arrNetProtocol )
{
	//local variables
	HRESULT				hRes = S_OK;
	IWbemClassObject	*pAdapConfig = NULL;
	VARIANT				varTemp;
	DWORD				dwReturned  = 1;

	DWORD           i = 0;
	DWORD           j = 0;
	DWORD			dwIndex = 0;
	BOOL			bFlag = FALSE;

	DWORD						dwNumofEntriesRead = 0;
	LPWKSTA_TRANSPORT_INFO_0	lpAdapterData=NULL;
	LPBYTE						lpBufptr = NULL;
	TARRAY						arrTransName = NULL;
	LPTSTR						lpRawAddr = NULL;
	LPTSTR						lpFormAddr = NULL;

	try
	{
		CHString			strAType = NULL_STRING;
		//validate input parametrs
		if( ( arrMacData == NULL ) || ( lpMachineName == NULL ) ||
			( pAdapterConfig == NULL ) || ( pIWbemServiceDef == NULL ) ||
			( pIWbemServices == NULL ) || ( arrNetProtocol == NULL ) || 
			( pAdapterSetting == NULL ) )
		{
			ONFAILTHROWERROR( WBEM_E_INVALID_PARAMETER );
		}
	
		//callwin32api to get the mac address
		bFlag = CallWin32Api( &lpBufptr, lpMachineName, &dwNumofEntriesRead );
		if( bFlag == FALSE )
		{
				return( FALSE );
		}
		else
		{
			lpAdapterData = ( LPWKSTA_TRANSPORT_INFO_0 ) lpBufptr;
			lpRawAddr = ( LPTSTR )calloc( MAX_STRING, sizeof( TCHAR ) );
			lpFormAddr = ( LPTSTR )calloc( MAX_STRING, sizeof( TCHAR ) );

			if( lpRawAddr == NULL || lpFormAddr == NULL )
			{
				FREESTRING( lpRawAddr );
				FREESTRING( lpFormAddr );
				NetApiBufferFree( lpBufptr );  
				DISPLAY_MESSAGE( stderr, ERROR_STRING );
				SetLastError( E_OUTOFMEMORY );
				ShowLastError( stderr );
				return( FALSE );
			}

			for ( i = 0; i < dwNumofEntriesRead; i++ )
			{      
				//get the mac address
				GetCompatibleStringFromUnicode( lpAdapterData[i].wkti0_transport_address,
													lpRawAddr, MAX_STRING );
				if( StringCompare( lpRawAddr, DEFAULT_ADDRESS, TRUE, 0 )  == 0 )
				{
					continue;
				}

				bFlag = FormatHWAddr ( lpRawAddr, lpFormAddr, COLON_STRING ); 
				if( bFlag == FALSE )
				{
					FREESTRING( lpRawAddr );
					FREESTRING( lpFormAddr );
					NetApiBufferFree( lpBufptr );  
					return( FALSE );
				}

				//get the network adapter type and other details
				VariantInit( &varTemp );
				bFlag = FALSE;
				hRes = pAdapterConfig->Reset();
				ONFAILTHROWERROR( hRes );
				while ( ( dwReturned == 1 ) && ( bFlag == FALSE ) )
				{
					// Enumerate through the resultset.
					hRes = pAdapterConfig->Next( WBEM_INFINITE,
										1,				
										&pAdapConfig,	
										&dwReturned );	
					ONFAILTHROWERROR( hRes );
					if( dwReturned == 0 )
					{
						break;
					}

					hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp,
																	0, NULL );
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						strAType = varTemp.bstrVal;
						VariantClear( &varTemp ); 
						if( StringCompare( lpFormAddr, strAType, TRUE, 0 )  == 0 )
						{
							bFlag = TRUE;
							break;
						}
						else
						{
							continue;
						}
					}
					else
					{
						continue;
					}
				}  //while
				if ( bFlag	== TRUE )
				{
					FormatHWAddr ( lpRawAddr, lpFormAddr, HYPHEN_STRING ); 		 
					LONG dwCount = DynArrayFindStringEx( arrMacData, 3,
														lpFormAddr, TRUE, 0 );
					if( dwCount == 0 )
					{
						hRes = pAdapterConfig->Reset();
						ONFAILTHROWERROR( hRes );
						continue;
					}
					DynArrayAppendRow( arrMacData, 0 );
					//get host name
					hRes = pAdapConfig->Get( HOST_NAME, 0 , &varTemp, 0, NULL );
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						strAType = varTemp.bstrVal;
					}
					else
					{
						strAType = NOT_AVAILABLE; 
					}
					VariantClear( &varTemp );
					DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

					FormatHWAddr ( lpRawAddr, lpFormAddr, COLON_STRING ); 		 
					//get connection name
					bFlag = GetConnectionName( arrMacData, dwIndex, lpFormAddr,
										   pAdapterSetting, pIWbemServiceDef );
					if( bFlag == FALSE )
					{
						FREESTRING( lpRawAddr );
						FREESTRING( lpFormAddr );
						SAFERELEASE( pAdapConfig );
						NetApiBufferFree( lpBufptr );  
						return( FALSE );
					}
					//get adapter type	
					hRes = pAdapConfig->Get( NAME, 0 , &varTemp, 0, NULL );
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						strAType = varTemp.bstrVal;
					}
					else
					{
						strAType = NOT_AVAILABLE; 
					}
					VariantClear( &varTemp );
					DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

					//get MAC address
					hRes = pAdapConfig->Get( ADAPTER_MACADDR, 0 , &varTemp,
																	0, NULL );
					ONFAILTHROWERROR( hRes );
					strAType = varTemp.bstrVal;
					for( int j = 2; j < strAType.GetLength();j += 3 )
					{
						strAType.SetAt( j, HYPHEN_CHAR );
					}
					VariantClear( &varTemp );
					DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );

					//get transport name
					arrTransName = CreateDynamicArray();
					if( arrTransName == NULL )
					{
						DISPLAY_MESSAGE( stderr, ERROR_STRING );
						SetLastError( E_OUTOFMEMORY );
						ShowLastError( stderr );
						FREESTRING( lpRawAddr );
						FREESTRING( lpFormAddr );
						SAFERELEASE( pAdapConfig );
						NetApiBufferFree( lpBufptr );  
						return( FALSE );
					}
					//get Device id	
					hRes = pAdapConfig->Get( DEVICE_ID, 0 , &varTemp, 0, NULL );
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						strAType = ( LPCWSTR ) _bstr_t( varTemp );
					}
					bFlag = GetTransName( pIWbemServiceDef, pIWbemServices,
								arrNetProtocol,	arrTransName, pAuthIdentity,
								strAType );
					if( bFlag == FALSE )
					{
						FREESTRING( lpRawAddr );
						FREESTRING( lpFormAddr );
						SAFERELEASE( pAdapConfig );
						NetApiBufferFree( lpBufptr );  
						DestroyDynamicArray( &arrTransName );
						return( FALSE );
					}
					//insert transport name array into results array
					DynArrayAppendEx2( arrMacData, dwIndex, arrTransName );
					dwIndex++;
				}  //wmi data found
			}//for each entry in api
		}//if call api succeeded
	}
	catch( _com_error& e )
	{
		FREESTRING( lpRawAddr );
		FREESTRING( lpFormAddr );
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		SAFERELEASE( pAdapConfig );
		NetApiBufferFree( lpBufptr );  
		return( FALSE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		FREESTRING( lpRawAddr );
		FREESTRING( lpFormAddr );
		SAFERELEASE( pAdapConfig );
		NetApiBufferFree( lpBufptr );  
		return( FALSE );
	}


	if( lpBufptr != NULL )
	{
		NetApiBufferFree( lpBufptr );  
	}
	//if arrmacdata and not arrtransname then set transname to N/A
	if( DynArrayGetCount( arrMacData ) > 0 &&
								DynArrayGetCount( arrTransName ) <= 0  )
	{
		DynArrayAppendString( arrTransName, NOT_AVAILABLE, 0 );
		DynArrayAppendEx2( arrMacData, dwIndex, arrTransName );
	}

	FREESTRING( lpRawAddr );
	FREESTRING( lpFormAddr );
	SAFERELEASE( pAdapConfig );
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function gets connection name of the network adapter.
//                         
// Arguments:
//		arrMacData [in/out]   - contains the MAC and other data of the network
//								adapter.
//		dwIndex [in]          - index for array.
//		lpFormAddr [in]		  - Mac address for network adapter.
//		pAdapterSetting [in]  - interface to win32_networkadapterconfiguration.
//		pIWbemServiceDef [in] - interface to default name space.
//
// Return Value:
//		TRUE if GetConnectionName  is successful.
//		FALSE if GetConnectionName failed.
*****************************************************************************/
BOOL  GetConnectionName( TARRAY					arrMacData,
						 DWORD					dwIndex,
						 LPCTSTR				lpFormAddr,
						 IEnumWbemClassObject	*pAdapterSetting,
						 IWbemServices			*pIWbemServiceDef )
{
	DWORD				dwReturned = 1;
	HRESULT				hRes = 0;
	IWbemClassObject	*pAdapSetting = NULL;
	VARIANT				varTemp;
	BOOL				bFlag = FALSE;

	IWbemClassObject	*pClass = NULL;
    IWbemClassObject	*pOutInst = NULL;
    IWbemClassObject	*pInClass = NULL;
    IWbemClassObject	*pInInst = NULL;
	LPTSTR				lpKeyPath = NULL;

	VariantInit( &varTemp );
	try
	{
		CHString			strAType = NULL_STRING;
		//validate input parameters
		if( ( arrMacData == NULL ) || ( lpFormAddr == NULL ) ||
		    ( pAdapterSetting == NULL ) || ( pIWbemServiceDef == NULL ) )
		{
			ONFAILTHROWERROR( WBEM_E_INVALID_PARAMETER );
		}

		while ( ( dwReturned == 1 ) && ( bFlag == FALSE ) )
		{
			// Enumerate through the resultset.
			hRes = pAdapterSetting->Next( WBEM_INFINITE,
								1,	
								&pAdapSetting,
								&dwReturned );
			ONFAILTHROWERROR( hRes );
			if( dwReturned == 0 )
			{
				break;
			}
			hRes = pAdapSetting->Get( ADAPTER_MACADDR, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
				VariantClear( &varTemp ); 
				if( StringCompare( lpFormAddr, strAType, TRUE, 0 )  == 0 )
				{
					bFlag = TRUE;
					break;
				}
			}
		}//while
		if( bFlag == TRUE )
		{
			hRes = pAdapSetting->Get( SETTING_ID, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
				VariantClear( &varTemp ); 
				lpKeyPath = ( LPTSTR )calloc( MAX_RES_STRING, sizeof( TCHAR ) );
				if( lpKeyPath == NULL )
				{
					DISPLAY_MESSAGE( stderr, ERROR_STRING );
					SetLastError( E_OUTOFMEMORY );
					ShowLastError( stderr );
					SAFERELEASE( pAdapSetting );
					return( FALSE );
				}
				hRes = pIWbemServiceDef->GetObject( WMI_REGISTRY, 0, NULL,
													&pClass, NULL );
				ONFAILTHROWERROR( hRes );
				hRes = pClass->GetMethod( WMI_REGISTRY_M_STRINGVALUE, 0,
											&pInClass, NULL ); 
				ONFAILTHROWERROR( hRes );
			    hRes = pInClass->SpawnInstance(0, &pInInst);
				ONFAILTHROWERROR( hRes );
				varTemp.vt = VT_I4;
				varTemp.lVal = WMI_HKEY_LOCAL_MACHINE;
				hRes = pInInst->Put( WMI_REGISTRY_IN_HDEFKEY, 0, &varTemp, 0 );
				VariantClear( &varTemp );
				ONFAILTHROWERROR( hRes );

				lstrcpy( lpKeyPath, CONNECTION_KEYPATH );
				lstrcat( lpKeyPath, strAType );
				lstrcat( lpKeyPath, CONNECTION_STRING );
				varTemp.vt = VT_BSTR;
				varTemp.bstrVal = SysAllocString( lpKeyPath );
				hRes = pInInst->Put( WMI_REGISTRY_IN_SUBKEY, 0, &varTemp, 0 );
				VariantClear( &varTemp );
				ONFAILTHROWERROR( hRes );

				varTemp.vt = VT_BSTR;
				varTemp.bstrVal = SysAllocString( REG_NAME );
				hRes = pInInst->Put( WMI_REGISTRY_IN_VALUENAME, 0,
										&varTemp, 0 );
				VariantClear( &varTemp );
				ONFAILTHROWERROR( hRes );

				// Call the method.
				hRes = pIWbemServiceDef->ExecMethod( WMI_REGISTRY,
								WMI_REGISTRY_M_STRINGVALUE,	0, NULL, pInInst,
								&pOutInst, NULL );
				ONFAILTHROWERROR( hRes );

				varTemp.vt = VT_I4;
				hRes = pOutInst->Get( WMI_REGISTRY_OUT_RETURNVALUE, 0,
														&varTemp, 0, 0 );
				ONFAILTHROWERROR( hRes );

				if( varTemp.lVal == 0 )
				{
					VariantClear( &varTemp );
					varTemp.vt = VT_BSTR;
					hRes = pOutInst->Get( WMI_REGISTRY_OUT_VALUE, 0,
															&varTemp, 0, 0);
					ONFAILTHROWERROR( hRes );
					if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
					{
						strAType = varTemp.bstrVal;
						DynArrayAppendString2( arrMacData, dwIndex, strAType, 0 );
					}
				}
				else
				{
					DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
				}
			}//setting id not null
			else
			{
				DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
			}
		}//got match
		else
		{
			DynArrayAppendString2( arrMacData, dwIndex, NOT_AVAILABLE, 0 );
		}

	}//try
	catch( _com_error& e )
	{
		VariantClear( &varTemp );
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		FREESTRING( lpKeyPath );
		SAFERELEASE( pAdapSetting );
		SAFERELEASE( pClass );
		SAFERELEASE( pOutInst );
		SAFERELEASE( pInClass );
		SAFERELEASE( pInInst );
		return( FALSE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		VariantClear( &varTemp );
		FREESTRING( lpKeyPath );
		SAFERELEASE( pAdapSetting );
		SAFERELEASE( pClass );
		SAFERELEASE( pOutInst );
		SAFERELEASE( pInClass );
		SAFERELEASE( pInInst );
		return( FALSE );
	}

	VariantClear( &varTemp );
	FREESTRING( lpKeyPath );
	SAFERELEASE( pAdapSetting );
	SAFERELEASE( pClass );
	SAFERELEASE( pOutInst );
	SAFERELEASE( pInClass );
	SAFERELEASE( pInInst );
	return( TRUE );
}

/*****************************************************************************
// Routine Description:
//		This function enumerates all the network protocols.
//                         
// Arguments:
//		arrNetProtocol [in/out] - contains all the network protocols.
//		pNetProtocol [in]       - interface to win32_networkprotocol.
//
// Return Value:
//		TRUE if GetNwkProtocol  is successful.
//		FALSE if GetNwkProtocol failed.
*****************************************************************************/
BOOL GetNwkProtocol( TARRAY					arrNetProtocol,
 	 				 IEnumWbemClassObject	*pNetProtocol )
{
	HRESULT				hRes = 0;
	DWORD				dwReturned = 1;
	IWbemClassObject	*pProto = NULL;
	VARIANT				varTemp;

	VariantInit( &varTemp );
	try
	{
		CHString			strAType = NULL_STRING;
		//get transport protocols
		while ( dwReturned == 1 )
		{
			// Enumerate through the resultset.
			hRes = pNetProtocol->Next( WBEM_INFINITE,
								1,	
								&pProto,
								&dwReturned );	
			ONFAILTHROWERROR( hRes );
			if( dwReturned == 0 )
			{
				break;
			}
			hRes = pProto->Get( CAPTION, 0 , &varTemp, 0, NULL );
			ONFAILTHROWERROR( hRes );
			if( varTemp.vt != VT_NULL && varTemp.vt != VT_EMPTY )
			{
				strAType = varTemp.bstrVal;
				VariantClear( &varTemp );
				if( DynArrayGetCount( arrNetProtocol ) == 0 )
				{
					DynArrayAppendString( arrNetProtocol, strAType, 0 );
				}
				else
				{
					LONG lFound =  DynArrayFindString( arrNetProtocol,
														strAType, TRUE, 0 );
					if( lFound == -1 )
					{
						DynArrayAppendString( arrNetProtocol, strAType, 0 );
					}
				}
			}
		}//while
	}
	catch( _com_error& e )
	{
		VariantClear( &varTemp );
		WMISaveError( e.Error() );
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		DISPLAY_MESSAGE( stderr, GetReason() );
		SAFERELEASE( pProto );
		return( FALSE );
	}
	catch( CHeap_Exception)
	{
		DISPLAY_MESSAGE( stderr, ERROR_STRING );
		SetLastError( E_OUTOFMEMORY );
		ShowLastError( stderr );
		VariantClear( &varTemp );
		SAFERELEASE( pProto );
		return( FALSE );
	}

	VariantClear( &varTemp );
	SAFERELEASE( pProto );
	return( TRUE );
}

/****************************************************************************
// Routine Description:
//		This function checks whether tha target system is win2k or above.
//                         
// Arguments:
//		bLocalSystem [in]  - Hold whether local system or not.
//		pAuthIdentity [in] - pointer to authentication structure.
//		pIWbemServices [in] - pointer to IWbemServices.
//
// Return Value:
//		TRUE if target system is win2k.
//		FALSE if target system is not win2k.
*****************************************************************************/
BOOL CheckVersion( BOOL           bLocalSystem,
				   COAUTHIDENTITY *pAuthIdentity,
				   IWbemServices  *pIWbemServices )
{
	if ( bLocalSystem == FALSE )
	{
		// check the version compatibility
		DWORD dwVersion = 0;
		dwVersion = GetTargetVersionEx( pIWbemServices, pAuthIdentity );
		if ( dwVersion <= 5000 )
		{
			return( TRUE );
		}
	}
	return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\getmac\getmac.h ===
//***************************************************************************
//  Copyright (c) Microsoft Corporation
//
//  Module Name:
//		GETMAC.H
//  
//  Abstract:
//		Contains function prototypes and macros.
//
//  Author:
//		Vasundhara .G
//
//	Revision History:
//		Vasundhara .G 26-sep-2k : Created It.
//		Vasundhara .G 31-oct-2k : Modified.
//								  Added macros and some #defines.
//***************************************************************************

#ifndef __GETMAC_H
#define __GETMAC_H

// constants / defines / enumerations

#define MAX_STRING                      256
#define MAX_OPTIONS                     7
#define MAX_COLUMNS						5
#define USAGE_END						37

//Command line parser index
#define CMD_PARSE_SERVER				0
#define CMD_PARSE_USER					1
#define CMD_PARSE_PWD					2
#define CMD_PARSE_FMT					3
#define CMD_PARSE_USG					4
#define CMD_PARSE_HRD					5
#define CMD_PARSE_VER					6

//show results index
#define SH_RES_HOST						0
#define SH_RES_CON						1
#define SH_RES_TYPE						2
#define SH_RES_MAC						3
#define SH_RES_TRAN						4

//wmi registry key value
#define WMI_HKEY_CLASSES_ROOT			2147483648 
#define WMI_HKEY_CURRENT_USER			2147483649
#define WMI_HKEY_LOCAL_MACHINE			2147483650
#define WMI_HKEY_USERS					2147483651
#define WMI_HKEY_CURRENT_CONFIG			2147482652

// Error constants
#define ERROR_USER_WITH_NOSERVER		GetResString( IDS_USER_NMACHINE )
#define ERROR_SERVER_WITH_NOPASSWORD	GetResString( IDS_SERVER_NPASSWORD )
#define ERROR_NULL_SERVER				GetResString( IDS_NULL_SERVER )
#define ERROR_NULL_USER					GetResString( IDS_NULL_USER )
#define ERROR_INVALID_HEADER_OPTION     GetResString( IDS_INVALID_OPTIONS )
#define ERROR_TYPE_REQUEST				GetResString( IDS_TYPE_REQUEST )
#define ERROR_STRING					GetResString( IDS_ERROR_STRING )
#define ERROR_VERSION_MISMATCH			GetResString( IDS_ERROR_VERSION_MISMATCH )
#define ERROR_NOT_RESPONDING			GetResString( IDS_NOT_RESPONDING ) 
#define ERROR_NO_MACHINE				GetResString( IDS_NO_MACHINE )
#define ERROR_INVALID_MACHINE			GetResString( IDS_INVALID_MACHINE )
#define ERROR_WKST_NOT_FOUND			GetResString( IDS_WKST_NOT_FOUND )

//warning message
#define IGNORE_LOCALCREDENTIALS			GetResString( IDS_IGNORE_LOCALCREDENTIALS )
#define WARNING_STRING					GetResString( IDS_WARNING_STRING )

//info message
#define NO_NETWORK_ADAPTERS				GetResString( IDS_NO_NETWORK_ADAPTERS )
#define NO_NETWOK_PROTOCOLS				GetResString( IDS_NO_NETWOK_PROTOCOLS )

//show results  column length
#define HOST_NAME_WIDTH					AsLong(GetResString( IDS_HOST_NAME_WIDTH ),10 )
#define CONN_NAME_WIDTH					AsLong(GetResString( IDS_CONN_NAME_WIDTH ),10 )
#define ADAPT_TYPE_WIDTH				AsLong(GetResString( IDS_ADAPT_TYPE_WIDTH ),10 )
#define MAC_ADDR_WIDTH					AsLong(GetResString( IDS_MAC_ADDR_WIDTH ),10 )
#define TRANS_NAME_WIDTH				AsLong(GetResString( IDS_TRANS_NAME_WIDTH ),10 )

//output headers strings
#define RES_HOST_NAME                   GetResString( RES_HOST )
#define RES_CONNECTION_NAME             GetResString( RES_CONNECTION )
#define RES_ADAPTER_TYPE                GetResString( RES_ADAPTER )
#define RES_MAC_ADDRESS                 GetResString( RES_ADDRESS )
#define RES_TRANS_NAME                  GetResString( RES_TRANSNAME )

//general
#define NOT_AVAILABLE					GetResString( IDS_NOT_AVAILABLE )
#define DISABLED						GetResString( IDS_DISABLED )
#define HYPHEN_STRING					GetResString( IDS_HYPHEN_STRING )
#define	COLON_STRING					GetResString( IDS_COLON_STRING )
#define NEW_LINE						GetResString( IDS_NEW_LINE )
#define FORMAT_TYPES					GetResString( IDS_FORMAT_TYPES )

//registry key names
#define DEFAULT_ADDRESS					_T( "000000000000" )
#define CONNECTION_KEYPATH				_T( "SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\" )
#define TRANSPORT_KEYPATH				_T( "SYSTEM\\CurrentControlSet\\Services\\" )
#define LINKAGE							_T( "\\Linkage" )
#define	ROUTE							_T( "route" )
#define	EXPORT							_T( "Export" )
#define CONNECTION_STRING				_T( "\\Connection" )
#define REG_NAME						_T( "name" )
#define NETBIOS							_T( "NetBIOS" )


//command line options
#define CMDOPTION_SERVER                _T( "s" )
#define CMDOPTION_USER					_T( "u" )
#define CMDOPTION_PASSWORD				_T( "p" )
#define CMDOPTION_FORMAT				_T( "fo" )
#define CMDOPTION_USAGE					_T( "?" )
#define CMDOPTION_HEADER				_T( "nh" )
#define CMDOPTION_VERBOSE				_T( "v" )
#define TOKEN_BACKSLASH2				_T( "\\\\" )
#define TOKEN_BACKSLASH3				_T( "\\\\\\" )

//wmi classes and property names
#define HYPHEN_CHAR						L'-'
#define	COLON_CHAR						L':'
#define BACK_SLASHS						L"\\\\"
#define BACK_SLASH						L"\\"
#define NETCONNECTION_STATUS			L"NetConnectionStatus"
#define ADAPTER_MACADDR					L"MACAddress"
#define NETCONNECTION_ID				L"NetConnectionID"
#define DEVICE_ID						L"DeviceID"
#define NAME							L"Name"
#define HOST_NAME						L"SystemName"
#define	SETTING_ID						L"SettingID"
#define NETWORK_ADAPTER_CLASS           L"Win32_NetworkAdapter"
#define NETWORK_ADAPTER_CONFIG_CLASS	L"Win32_NetworkAdapterConfiguration"
#define NETWORK_PROTOCOL				L"Win32_NetworkProtocol"
#define CLASS_CIMV2_Win32_OperatingSystem	L"Win32_OperatingSystem"
#define QUERY_LANGUAGE					L"WQL"
#define ASSOCIATOR_QUERY				_T( "ASSOCIATORS OF {Win32_NetworkAdapter.DeviceID=\"%s\"} WHERE ResultClass=Win32_NetworkAdapterConfiguration" )

#define SUCCESS 0
#define FAILURE 1

#define WMI_NAMESPACE_CIMV2				L"root\\cimv2"
#define WMI_NAMESPACE_DEFAULT			L"root\\default"
#define WMI_CLAUSE_AND					L"AND"
#define WMI_CLAUSE_OR					L"OR"
#define WMI_CLAUSE_WHERE				L"WHERE"
#define WMI_REGISTRY					L"StdRegProv"
#define WMI_REGISTRY_M_STRINGVALUE		L"GetStringValue"
#define WMI_REGISTRY_M_MSTRINGVALUE		L"GetMultiStringValue"
#define WMI_REGISTRY_IN_HDEFKEY			L"hDefKey"
#define WMI_REGISTRY_IN_SUBKEY			L"sSubKeyName"
#define WMI_REGISTRY_IN_VALUENAME		L"sValueName"
#define WMI_REGISTRY_OUT_VALUE			L"sValue"
#define WMI_REGISTRY_OUT_RETURNVALUE	L"ReturnValue"
#define CAPTION							L"Caption"


//macro for freeing, deleting, releasing memory which has been allocated using calloc

#define FREESTRING( pStr ) \
        if ( pStr ) \
		{ \
           free( pStr ); \
		   pStr = NULL; \
		}

#define DELETESTRING( pStr ) \
        if ( pStr ) \
		{ \
           delete[] pStr; \
		   pStr = NULL; \
		}

#define SAFERELEASE( pIObj ) \
	if ( pIObj != NULL ) \
	{ \
		pIObj->Release();	\
		pIObj = NULL;	\
	}

#define SAFEBSTRRELEASE( pIObj ) \
	if ( pIObj != NULL ) \
	{ \
		SysFreeString( pIObj );	\
		pIObj = NULL;	\
	}

#define ONFAILTHROWERROR(hResult) \
	if (FAILED(hResult)) \
	{	\
		_com_issue_error(hResult); \
	}

#define SAFE_RELEASE( interfacepointer )	\
	if ( (interfacepointer) != NULL )	\
	{	\
		(interfacepointer)->Release();	\
		(interfacepointer) = NULL;	\
	}	\
	1

#define SAFE_EXECUTE( statement )				\
	hRes = statement;		\
	if ( FAILED( hRes ) )	\
	{	\
		_com_issue_error( hRes );	\
	}	\
	1

//function prototype 

BOOL ConnectWmi( IWbemLocator      *pLocator,
				 IWbemServices     **ppServices, 
				 LPCWSTR           pwszServer,
				 LPCWSTR		   pwszUser,
				 LPCWSTR		   pwszPassword, 
				 COAUTHIDENTITY    **ppAuthIdentity, 
				 BOOL			   bCheckWithNullPwd = FALSE, 
				 LPCWSTR		   pwszNamespace = WMI_NAMESPACE_CIMV2, 
				 HRESULT		   *phRes = NULL,
				 BOOL			   *pbLocalSystem = NULL );

BOOL ConnectWmiEx( IWbemLocator		*pLocator, 
				   IWbemServices	**ppServices, 
				   LPCWSTR			pwszServer,
				   CHString			&strUserName,
				   CHString			&strPassword, 
				   COAUTHIDENTITY	**ppAuthIdentity,
				   BOOL				bNeedPassword = FALSE, 
				   LPCWSTR			pszNamespace = WMI_NAMESPACE_CIMV2,
				   BOOL				*pbLocalSystem = NULL );

BOOL IsValidServerEx( LPCWSTR		pwszServer,
					  BOOL			&bLocalSystem );

HRESULT SetInterfaceSecurity( IUnknown			*pInterface,
							  COAUTHIDENTITY	*pAuthIdentity );

VOID WINAPI WbemFreeAuthIdentity( COAUTHIDENTITY	**ppAuthIdentity );

VOID WMISaveError( HRESULT hResError );

DWORD GetTargetVersionEx( IWbemServices* pWbemServices,
						  COAUTHIDENTITY* pAuthIdentity );

// inline functions
inline VOID WMISaveError( _com_error  &e )
{
	WMISaveError( e.Error() );
}

#endif // __GETMAC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\gpresult.h ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name: 

    GpResult.h

Abstract:
  
    This module  contanins function definations required by GpResult.cpp,
    and all necessary Defines and header files used in this project. 

Author:
 
    Wipro Technologies.

Revision History:

    20-Feb-2001 : Created It.

*********************************************************************************************/ 
#ifndef _GPRESULT_H
#define _GPRESULT_H

#include "Resource.h"

//
// macro definitions

// Exit the program with appropriate error code after releasing the memory
#define EXIT_PROCESS( exitcode )    \
    ReleaseGlobals();   \
    return exitcode;    \
    1

// Macro to check for the returned hresult value
#define CHECK_HRESULT( hr )    \
    if( FAILED( hr ) ) \
    {   \
        _com_issue_error( hr ); \
    }\
    1

// Macro to check for the returned hresult value, this one cleans the status msg
#define CHECK_HRESULT_EX( hr )    \
    if( FAILED( hr ) ) \
    {   \
        PrintProgressMsg( m_hOutput, NULL, m_csbi );    \
        _com_issue_error( hr ); \
    }\
    1

// Macro to check for the returned hresult value
// It also sets the variant to VT_EMPTY
#define CHECK_HRESULT_VAR( hr, var )    \
    if( FAILED( hr ) ) \
    {   \
        V_VT( &var ) = VT_EMPTY; \
        _com_issue_error( hr ); \
    }\
    1

#define CHECK_BRESULT( bResult ) \
    if( bResult == FALSE )  \
    {   \
        _com_issue_error( STG_E_UNKNOWN ); \
    }   \
    1

//SAFEDELETE
#define SAFEDELETE( pObj ) \
    if (pObj) \
    {   \
        delete[] pObj; \
        pObj = NULL; \
    }\
    1

//SAFEIRELEASE
#define SAFEIRELEASE( pIObj )\
    if ( pIObj )\
    {\
        pIObj->Release();\
        pIObj = NULL;\
    }\
    1

// SAFEBSTRFREE
#define SAFEBSTRFREE( bstrVal ) \
    if ( bstrVal ) \
    {   \
        SysFreeString( bstrVal ); \
        bstrVal = NULL; \
    } \
    1

// CHECK_ALLOCATION
#define CHECK_ALLOCATION( allocation )\
    if( ( allocation ) == NULL )\
    {\
        _com_issue_error( E_OUTOFMEMORY ); \
    }\
    1

#define SAFE_DELETE( pointer )      \
    if ( (pointer) != NULL )    \
    {   \
        delete (pointer);   \
        (pointer) = NULL;   \
    }   \
    1

#define SAFE_DELETE_EX( pointer )       \
    if ( (pointer) != NULL )    \
    {   \
        delete [] (pointer);    \
        (pointer) = NULL;   \
    }   \
    1

#define DESTROY_ARRAY( array )  \
    if ( (array) != NULL )  \
    {   \
        DestroyDynamicArray( &(array) );    \
        (array) = NULL; \
    }   \
    1

#ifdef _DEBUG
#define TRACE_DEBUG( text )     _tprintf( _T("TRACE: ") ## text )
#else
#define TRACE_DEBUG( text )     1
#endif
    
// 
//      Constants and Definitions

// Maximum Command Line  List
#define MAX_CMDLINE_OPTIONS         10
#define MAX_DATA                    6

#define MAX_QUERY_STRING            512

#define TIME_OUT_NEXT               5000
#define VERSION_CHECK               5000

// Defining the domain role of a PDC for LDAP purposes
#define DOMAIN_ROLE_PDC             5

// Define a constant to check for the True value returned from WMI
#define VAR_TRUE    -1

// Option indices
#define OI_USAGE                0
#define OI_LOGGING              1
#define OI_PLANNING             2
#define OI_SERVER               3
#define OI_USERNAME             4
#define OI_PASSWORD             5
#define OI_USER                 6
#define OI_SCOPE                7
#define OI_VERBOSE              8
#define OI_SUPER_VERBOSE        9

// Option values
#define OPTION_USAGE            _T( "?" )
#define OPTION_LOGGING          _T( "Logging" )
#define OPTION_PLANNING         _T( "Planning" )
#define OPTION_SERVER           _T( "s" )
#define OPTION_USERNAME         _T( "u" )
#define OPTION_PASSWORD         _T( "p" )
#define OPTION_USER             _T( "User" )   
#define OPTION_SCOPE            _T( "Scope" )
#define OPTION_VERBOSE          _T( "v" )
#define OPTION_SUPER_VERBOSE    _T( "z" )

// Data Indices
#define DI_USER_SID             0
#define DI_USER_NAME            1
#define DI_LOCAL_PROFILE        2
#define DI_USER_SERVER          3
#define DI_USER_DOMAIN          4
#define DI_USER_SITE            5

// Exit values
#define CLEAN_EXIT              0
#define ERROR_EXIT              1

// Array column values
#define COL_DATA                0
#define COL_ORDER               1
#define COL_FILTER              1
#define COL_FILTER_ID           2
#define COL_MAX                 2               
#define COL_MAX_FILTER          3

// General defines
#define ARRAYSIZE( a ) ( sizeof(a)/sizeof( a[0] ) )

#define MUTEX_NAME              _T( "RsopCreateSessionMutex" )
#define START_NAMESPACE         _T( "\\root\\rsop" )

#define DEFAULT_LINK_SPEED      _T( "500 kbps" )

#define HELP_OPTION             _T( "-?" )
#define HELP_OPTION1            _T( "/?" )
#define NEW_LINE                _T( "\n" )
#define TAB_TWO                 _T( "        " )

#define SLASH                   _T( '\\' )
#define SEPARATOR_AT            _T( '@' )
#define SEPARATOR_DOT           _T( '.' )

// SID values
#define SID_NULL_SID            _T( "S-1-0-0" )
#define SID_EVERYONE            _T( "S-1-1-0" )
#define SID_LOCAL               _T( "S-1-2-0" )
#define SID_CREATOR_OWNER       _T( "S-1-3-0" )
#define SID_CREATOR_GROUP       _T( "S-1-3-1" )

// Scope (Computer/User/All)
#define SCOPE_ALL               0
#define SCOPE_USER              1
#define SCOPE_COMPUTER          2

#define TEXT_SCOPE_VALUES       _T( "USER|COMPUTER" )
#define TEXT_SCOPE_USER         _T( "USER" )
#define TEXT_SCOPE_COMPUTER     _T( "COMPUTER" )
#define TEXT_WILD_CARD          _T( "*" )
#define TEXT_BACKSLASH          _T( "\\" )
#define TEXT_COMMA_DC           _T( ", DC=" )
#define TEXT_DOLLAR             _T( "$" )

// Queries
#define QUERY_LOCAL             _T( "Select * from Win32_UserAccount where name = \"%s\"" )
#define QUERY_DOMAIN            _T( "Select * from Win32_UserAccount where name = \"%s\" and Domain = \"%s\" " )
#define QUERY_LANGUAGE          _T( "WQL" )
#define QUERY_WILD_CARD         _T( "Select * from Win32_UserAccount" )
#define QUERY_GPO_NAME          _T( "Select name from Rsop_Gpo WHERE id = \"%s\"" )
#define QUERY_DOMAIN_NAME       _T( "ASSOCIATORS OF {%s} WHERE ResultClass=Win32_Group" )
#define QUERY_USER_NAME         _T( "Select name, domain from Win32_UserAccount where SID = \"%s\"" )
#define QUERY_COMPUTER_FQDN     _T( "Select ds_distinguishedName from ds_computer" )
#define QUERY_USER_FQDN         _T( "Select ds_distinguishedName from ds_user where ds_SAMAccountName = \"%s\"" )

#define OBJECT_PATH             _T( "Win32_SID.SID=\"%s\"" )
#define GPO_REFERENCE           _T( "RSOP_GPO.id=" )

// error messages
#define ERROR_USERNAME_BUT_NOMACHINE    GetResString( IDS_ERROR_USERNAME_BUT_NOMACHINE )
#define ERROR_PASSWORD_BUT_NOUSERNAME   GetResString( IDS_ERROR_PASSWORD_BUT_NOUSERNAME )
#define ERROR_NODATA_AVAILABLE_REMOTE   GetResString( IDS_ERROR_NODATA_AVAILABLE_REMOTE )
#define ERROR_NODATA_AVAILABLE_LOCAL    GetResString( IDS_ERROR_NODATA_AVAILABLE_LOCAL )
#define ERROR_USERNAME_EMPTY            GetResString( IDS_ERROR_USERNAME_EMPTY )
#define ERROR_SERVERNAME_EMPTY          GetResString( IDS_ERROR_SERVERNAME_EMPTY )
#define ERROR_NO_OPTIONS                GetResString( IDS_ERROR_NO_OPTIONS )
#define ERROR_USAGE                     GetResString( IDS_ERROR_USAGE )
#define ERROR_TARGET_EMPTY              GetResString( IDS_ERROR_TARGET_EMPTY )
#define ERROR_VERBOSE_SYNTAX            GetResString( IDS_ERROR_VERBOSE_SYNTAX )

// 
// Mapping information of Win32_ComputerSystem's DomainRole property
// NOTE: Refer to the _DSROLE_MACHINE_ROLE enumeration values in DsRole.h header file
#define VALUE_STANDALONEWORKSTATION     GetResString( IDS_VALUE_STANDALONEWORKSTATION )
#define VALUE_MEMBERWORKSTATION         GetResString( IDS_VALUE_MEMBERWORKSTATION )
#define VALUE_STANDALONESERVER          GetResString( IDS_VALUE_STANDALONESERVER )
#define VALUE_MEMBERSERVER              GetResString( IDS_VALUE_MEMBERSERVER )
#define VALUE_BACKUPDOMAINCONTROLLER    GetResString( IDS_VALUE_BACKUPDOMAINCONTROLLER )
#define VALUE_PRIMARYDOMAINCONTROLLER   GetResString( IDS_VALUE_PRIMARYDOMAINCONTROLLER )

// Classes, providers and namespaces...
#define ROOT_NAME_SPACE             _T( "root\\cimv2" )
#define ROOT_RSOP                   _T( "root\\rsop" )
#define ROOT_DEFAULT                _T( "root\\default" )
#define ROOT_POLICY                 _T( "root\\policy" )
#define ROOT_LDAP                   _T( "root\\directory\\ldap" )

#define CLS_DIAGNOSTIC_PROVIDER     _T( "RsopLoggingModeProvider" )
#define CLS_STD_REGPROV             _T( "StdRegProv" )

#define CLS_WIN32_SITE              _T( "Win32_NTDomain" )
#define CLS_WIN32_OS                _T( "Win32_OperatingSystem" )
#define CLS_WIN32_CS                _T( "Win32_ComputerSystem" )
#define CLS_WIN32_UA                _T( "Win32_UserAccount" )
#define CLS_WIN32_C                 _T( "Win32_Computer" )
#define CLS_RSOP_GPO                _T( "Rsop_GPO" )
#define CLS_RSOP_GPOLINK            _T( "Rsop_GPLink" )
#define CLS_RSOP_SESSION            _T( "Rsop_Session" )

// Class Property Values
#define CPV_SID                     _T( "SID" )
#define CPV_NAME                    _T( "name" )
#define CPV_DOMAIN                  _T( "domain" )
#define CPV_SVALUE                  _T( "sValue" )
#define CPV_GPO_NAME                _T( "name" )
#define CPV_GPO_FILTER_STATUS       _T( "filterAllowed" )
#define CPV_GPO_FILTER_ID           _T( "filterId" )
#define CPV_GPO_SERVER              _T( "__SERVER" )
#define CPV_SITE_NAME               _T( "DcSiteName" )
#define CPV_DC_NAME                 _T( "DomainControllerName" )
#define CPV_USER_SID                _T( "userSid" )
#define CPV_DOMAIN_ROLE             _T( "DomainRole" )
#define CPV_OS_VERSION              _T( "Version" )
#define CPV_OS_CAPTION              _T( "Caption" )
#define CPV_SEC_GRPS                _T( "SecurityGroups" )
#define CPV_SLOW_LINK               _T( "slowLink" )
#define CPV_ACCOUNT_NAME            _T( "AccountName" )
#define CPV_USER_SIDS               _T( "userSids" )
#define CPV_APPLIED_ORDER           _T( "appliedOrder" )
#define CPV_GPO_REF                 _T( "GPO" )
#define CPV_ENABLED                 _T( "enabled" )
#define CPV_ACCESS_DENIED           _T( "accessDenied" )
#define CPV_VERSION                 _T( "version" )
#define CPV_FQDN                    _T( "ds_distinguishedName" )
#define CPV_LDAP_FQDN               _T( "distinguishedName" )
#define CPV_LDAP_SAM                _T( "sAMAccountName" )

// Function return
#define FPR_VALUE_NAME              _T( "sValueName" )
#define FPR_LOCAL_VALUE             _T( "ProfileImagePath" )
#define FPR_ROAMING_VALUE           _T( "CentralProfile" )
#define FPR_SUB_KEY_NAME            _T( "sSubKeyName" )
#define FPR_HDEFKEY                 _T( "hDefKey" )
#define FPR_RSOP_NAME_SPACE         _T( "nameSpace" )   
#define FPR_RETURN_VALUE            _T( "hResult" )
#define FPR_RSOP_NAMESPACE          _T( "nameSpace" )
#define FPR_SNAMES                  _T( "sNames" )
#define FPR_LINK_SPEED_VALUE        _T( "GroupPolicyMinTransferRate" )
#define FPR_APPLIED_FROM            _T( "DCName" )
#define CPV_FLAGS                   _T( "flags" )

// Paths in registry to retrieve info. from
#define PATH                        _T( "SOFTWARE\\MicroSoft\\Windows NT\\CurrentVersion\\ProfileList\\" )
#define GPRESULT_PATH               _T( "Software\\policies\\microsoft\\windows\\system" )
#define GROUPPOLICY_PATH            _T( "Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy" )
#define APPLIED_PATH                _T( "Software\\Microsoft\\Windows\\CurrentVersion\\Group Policy\\History" )

// Registry keys
#define HKEY_DEF                    2147483650
#define HKEY_CURRENT_USER_DEF       2147483649

// keys in registry whose info. is required
#define FN_GET_EXPAND_VAL           _T( "GetExpandedStringValue" )
#define FN_CREATE_RSOP              _T( "RsopCreateSession" )
#define FN_DELETE_RSOP              _T( "RsopDeleteSession" )
#define FN_ENUM_USERS               _T( "RsopEnumerateUsers" )
#define FN_ENUM_KEYS                _T( "EnumKey" )

// general defines
#define SEPARATOR                   _T("-") 
#define DOUBLESLASH                 _T("\\\\")
#define ZERO                        _T("00000000000000.000000+000")
#define EXTRA                       _T('e')
#define LAST_TIME_OP                _T( "%s at %s" )

// Structure to hold the User Information
typedef struct _USER_INFO
{
    CHString        strUserSid;             // Holds the SID value for the user.
    CHString        strUserName;            // Holds the Name of the user.
    CHString        strLocalProfile;        // Holds the local profile for the user.
    CHString        strRoamingProfile;      // Holds the roaming profile for the user.
    CHString        strUserServer;          // Holds the server name for the user.
    CHString        strUserDomain;          // Holds the domain name.
    CHString        strUserSite;            // Holds the site name.
    CHString        strOsType;              // Holds the OS type
    CHString        strOsVersion;           // Holds the OS Version
    CHString        strOsConfig;            // Holds the OS Configuration
    CHString        strUserFQDN;            // Holds the FQDN of the user
    CHString        strComputerFQDN;        // Holds the FQDN of the computer
    
}USERINFO, *PUSERINFO;


//
// CGpResult
//
class CGpResult
{
// constructor / destructor
public:
      CGpResult();
    ~CGpResult();

// data memebers
private:
    // WMI / COM interfaces
    IWbemLocator            *m_pWbemLocator;
    IWbemServices           *m_pWbemServices;
    IWbemServices           *m_pRsopNameSpace;
    IEnumWbemClassObject    *m_pEnumObjects;

    // WMI connectivity
    COAUTHIDENTITY          *m_pAuthIdentity;

    // command-line argument values
    CHString        m_strUserName;     // Stores the user name
    CHString        m_strPassword;     // Stores the password
    CHString        m_strUser;         // Stores the User for whom the data is to be retrieved
    CHString        m_strServerName;   // Stores the server name
    CHString        m_strDomainName;   // Stores the domain name, if specified with the user name

    LPWSTR          m_pwszPassword;    // Stores the password returned by the AUTHIDENTITY structure

    BOOL            m_bVerbose;        // is set to TRUE if the verbose information is to be displayed
    BOOL            m_bSuperVerbose;   // is set to TRUE if the super verbose information is to be displayed

    DWORD           m_dwScope;         // This gives the scope of information to be displayed
    
    // others
    BOOL            m_bNeedPassword;   // is set to TRUE if the password has to be prompted for
    BOOL            m_bLocalSystem;    // is set to TRUE if the local system has to be queried.

    HANDLE          m_hMutex;          // Handle to the mutex for the RsopCreateSession method

    CHString        m_strADSIDomain;   // Holds the domain name for the ADSI connection
    CHString        m_strADSIServer;   // Holds the server name for ADSI

//   data members that we need to access directly
public:
    // main command line arguments
    BOOL            m_bLogging;        // set to TRUE if the logging mode data is to be displayed
    BOOL            m_bPlanning;       // set to TRUE if the planning mode data is to be displayed
    BOOL            m_bUsage;          // set to TRUE if the usage is to be displayed

    // progress message related
    HANDLE                              m_hOutput;
    CONSOLE_SCREEN_BUFFER_INFO          m_csbi;

private:
    BOOL DisplayCommonData( PUSERINFO pUserInfo );
    VOID DisplaySecurityGroups( IWbemServices *pNameSpace, BOOL bComputer );
    BOOL DisplayData( PUSERINFO pUserInfo, IWbemServices *pRsopNameSpace );
    BOOL DisplayVerboseComputerData( IWbemServices *pNameSpace );
    BOOL DisplayVerboseUserData( IWbemServices *pNameSpace );
    BOOL GetUserData( BOOL bAllUsers );
    BOOL GetUserProfile( PUSERINFO pUserInfo );
    BOOL GetDomainInfo( PUSERINFO pUserInfo );
    BOOL GetOsInfo( PUSERINFO pUserInfo );
    BOOL GetUserNameFromWMI( TCHAR szSid[], TCHAR szName[], TCHAR szDomain[] );
    BOOL DisplayThresholdSpeedAndLastTimeInfo( BOOL bComputer );
    BOOL GpoDisplay( IWbemServices *pNameSpace, LPCTSTR pszScopeName );
    VOID GetFQDNFromADSI( TCHAR szFQDN[], BOOL bComputer, LPCTSTR pszUserName );
    BOOL CreateRsopMutex( LPWSTR szMutexName );

public:
    VOID DisplayUsage();
    BOOL Initialize();
    BOOL ProcessOptions( DWORD argc, LPCWSTR argv[], BOOL *pbNeedUsageMsg );
        
    // functionality related
    BOOL GetLoggingData();
    BOOL Connect( LPCWSTR pszServer );
    VOID Disconnect();
};

// Function prototypes
VOID GetWbemErrorText( HRESULT hResult );
VOID PrintProgressMsg( HANDLE hOutput, LPCWSTR pwszMsg, 
                                        const CONSOLE_SCREEN_BUFFER_INFO& csbi );
LCID GetSupportedUserLocale( BOOL& bLocaleChanged );
#endif //#ifndef _GPRESULT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\resource.h ===
// Help
#define IDS_HELP_1                                      1
#define IDS_HELP_2                                      2
#define IDS_HELP_3                                      3
#define IDS_HELP_4                                      4
#define IDS_HELP_5                                      5
#define IDS_HELP_6                                      6
#define IDS_HELP_7                                      7
#define IDS_HELP_8                                      8
#define IDS_HELP_9                                      9
#define IDS_HELP_10                                     10
#define IDS_HELP_11                                     11
#define IDS_HELP_12                                     12
#define IDS_HELP_13                                     13
#define IDS_HELP_14                                     14
#define IDS_HELP_15                                     15
#define IDS_HELP_16                                     16
#define IDS_HELP_17                                     17
#define IDS_HELP_18                                     18
#define IDS_HELP_19                                     19
#define IDS_HELP_20                                     20
#define IDS_HELP_21                                     21
#define IDS_HELP_22                                     22  
#define IDS_HELP_23                                     23
#define IDS_HELP_24                                     24
#define IDS_HELP_25                                     25
#define IDS_HELP_26                                     26
#define IDS_HELP_27                                     27
#define IDS_HELP_28                                     28
#define IDS_HELP_29                                     29
#define IDS_HELP_30                                     30
#define IDS_HELP_31                                     31
#define IDS_HELP_32                                     32
#define IDS_HELP_33                                     33
#define IDS_HELP_34                                     34
#define IDS_HELP_35                                     35
#define IDS_HELP_36                                     36
#define IDS_HELP_37                                     37
#define IDS_HELP_38                                     38
#define IDS_HELP_39                                     39
#define IDS_HELP_40                                     40

// General
#define IDS_INFO                                        51        
#define IDS_ERROR                                       52
#define IDS_WARNING                                     53
#define IDS_DASH                                        54
#define IDS_NEWLINE_TAB                                 55
#define IDS_LAST_CHAR                                   56
#define IDS_NEWLINE                                     57
#define IDS_NEWLINE1                                    58
#define IDS_NEWLINETAB                                  59
#define IDS_NEWLINE_TABTHREE                            60
#define IDS_NEWLINE2                                    61

// Warning
#define IDS_WARN_LOCAL                                  65

// Info
#define IDS_USER_NO_RSOP                                75

// Error
#define IDS_ERROR_USERNAME_BUT_NOMACHINE                81
#define IDS_ERROR_PASSWORD_BUT_NOUSERNAME               82
#define IDS_ERROR_COM_ERROR                             83
#define IDS_ERROR_USERNAME_EMPTY                        84
#define IDS_ERROR_SERVERNAME_EMPTY                      85
#define IDS_ERROR_NO_OPTIONS                            86
#define IDS_ERROR_USAGE                                 87
#define IDS_TYPE_USAGE                                  88
#define IDS_ERROR_TARGET_EMPTY                          89
#define IDS_USER_NOT_VALID                              90
#define IDS_NO_USER                                     91
#define IDS_METHOD_FAILED                               92
#define IDS_ERROR_VERBOSE_SYNTAX                        93

// Display
#define IDS_GPO_USER                                    101 
#define IDS_GPO_COMPUTER                                102
#define IDS_GPO_TITLE                                   103
#define IDS_COMPUTER_RESULT                             104
#define IDS_USER_RESULT                                 105
#define IDS_DOMAIN_NAME                                 106
#define IDS_DOMAIN_TYPE                                 107
#define IDS_SITE_NAME                                   108
#define IDS_OS_TYPE                                     109
#define IDS_OS_VERSION                                  110
#define IDS_OS_CONFIG                                   111
#define IDS_LOCAL_PROFILE                               112
#define IDS_GPO_DISPLAY                                 113
#define IDS_GPO_FILTERED                                114 
#define IDS_GPO_FILTER_ID                               115
#define IDS_SW_SETTINGS                                 116
#define IDS_WS_SS_AP_PP                                 117
#define IDS_WS_SS_AP_ALP                                118
#define IDS_WS_SS_LP_AP                                 119
#define IDS_WS_SS_LP_URA                                120
#define IDS_WS_SS_LP_SO                                 121
#define IDS_WS_SSU                                      122
#define IDS_WS_SSD                                      123
#define IDS_WS_SS_EL                                    124
#define IDS_WS_SS_RG                                    125
#define IDS_WS_SS_SS                                    126
#define IDS_WS_SS_REG                                   127
#define IDS_WS_SS_FS                                    128
#define IDS_WS_SS_PKP                                   129
#define IDS_ADTS_RAS                                    130
#define IDS_ADTS_ERS                                    131
#define IDS_USERFR                                      132
#define IDS_IEPOLICY                                    133
#define IDS_FAVLINKORITEM                               134
#define IDS_IE_SECURITY                                 135
#define IDS_IE_PROGRAMS                                 136
#define IDS_PROXY                                       137
#define IDS_POLICY                                      138
#define IDS_COMPUTER_SETTING                            139
#define IDS_GPO                                         140
#define IDS_NAME                                        141
#define IDS_PARAMETERS                                  142
#define IDS_LASTEXECUTED                                143
#define IDS_SETTING                                     144
#define IDS_FR_SETTING                                  145
#define IDS_STATE                                       146
#define IDS_AUTOINSTALL                                 147
#define IDS_ORIGIN                                      148
#define IDS_OBJECTNAME                                  149
#define IDS_GROUPNAME                                   150
#define IDS_MEMBERS                                     151
#define IDS_SERVICENAME                                 152
#define IDS_STARTUP                                     153
#define IDS_PERMISSION                                  154
#define IDS_MEMBEROF                                    155
#define IDS_INSTALLATIONTYPE                            156
#define IDS_GRANTTYPE                                   157
#define IDS_MOVETYPE                                    158
#define IDS_REDIRECTINGGROUP                            159
#define IDS_REDIRECTEDPATH                              160
#define IDS_POLICYREMOVAL                               161
#define IDS_HOMEPAGEURL                                 162
#define IDS_BITMAPNAME                                  163
#define IDS_LOGOBITMAPNAME                              164
#define IDS_TITLEBARTEXT                                165
#define IDS_USERAGENTTEXT                               166
#define IDS_URL                                         167
#define IDS_AVAILABLE                                   168
#define IDS_VIEWABLESITES                               169
#define IDS_PASSWORDOVERRIDE                            170
#define IDS_HTTP_PROXY                                  171
#define IDS_SECURE_PROXY                                172
#define IDS_FTP_PROXY                                   173
#define IDS_GOPHER_PROXY                                174
#define IDS_SOCKS_PROXY                                 175
#define IDS_AUTO_CONFIG_ENABLE                          176
#define IDS_ENABLE_PROXY                                177
#define IDS_USE_SAME_PROXY                              178
#define IDS_APP_NAME                                    179
#define IDS_APP_VERSION                                 180
#define IDS_DEPLOY_STATE                                181
#define IDS_APP_SRC                                     182
#define IDS_LOG_NAME                                    183
#define IDS_USER_SG                                     184
#define IDS_SYS_SG                                      185
#define IDS_LINK_SPEED                                  186
#define IDS_THRESHOLD_LINK_SPEED                        187
#define IDS_LAST_TIME                                   188
#define IDS_APPLIED_FROM                                189
#define IDS_ROAMING_PROFILE                             190
#define IDS_SEARCHBARURL                                191
#define IDS_HELPPAGEURL                                 192
#define IDS_ZONE_SETTING                                193
#define IDS_PROGRAM_SETTING                             194
#define IDS_CONTENT_SETTING                             195
#define IDS_AUTH_SETTING                                196
#define IDS_TRUST_PUB                                   197
#define IDS_TOOL_BUTTONS                                198
#define IDS_FILTERING                                   199

// Display data
#define IDS_NO_AUDITING                                 251
#define IDS_AUTOMATIC                                   252
#define IDS_MANUAL                                      253
#define IDS_DISABLED                                    254
#define IDS_PUBLISHED                                   255
#define IDS_ASSIGNED                                    256
#define IDS_TRUE                                        257
#define IDS_FALSE                                       258
#define IDS_ARP                                         259
#define IDS_APPLICATION                                 260
#define IDS_REMOVED                                     261
#define IDS_NOPOLICY                                    262         
#define IDS_BASIC                                       263         
#define IDS_ADVANCED                                    264         
#define IDS_MAXIMUM                                     265         
#define IDS_YES                                         266         
#define IDS_NO                                          267         
#define IDS_VALUE_STANDALONEWORKSTATION                 268         
#define IDS_VALUE_MEMBERWORKSTATION                     269         
#define IDS_VALUE_STANDALONESERVER                      270         
#define IDS_VALUE_MEMBERSERVER                          271
#define IDS_VALUE_BACKUPDOMAINCONTROLLER                272
#define IDS_VALUE_PRIMARYDOMAINCONTROLLER               273
#define IDS_STRING_COMPUTER                             274
#define IDS_STRING_USER                                 275
#define IDS_NULL_SID                                    276
#define IDS_EVERYONE                                    277
#define IDS_LOCAL                                       278
#define IDS_CREATOR_OWNER                               279
#define IDS_CREATOR_GROUP                               280
#define IDS_SYSTEM                                      281
#define IDS_SECURITY                                    282
#define IDS_APP_LOG                                     283
#define IDS_ENABLED                                     284
#define IDS_NOT_ENABLED                                 285
#define IDS_NOT_EXECUTED                                286
#define IDS_EXCLUSIVE                                   287
#define IDS_NOTEXCLUSIVE                                288
#define IDS_MOVED                                       289
#define IDS_NOTMOVED                                    290
#define IDS_LEAVEFOLDER                                 291
#define IDS_REDIRECT                                    292
#define IDS_W2K_DOMAIN                                  293
#define IDS_LOCAL_COMP                                  294
#define IDS_NT4_DOMAIN                                  295
#define IDS_MS_409                                      296
#define IDS_LEGAL_INFO1                                 297
#define IDS_LEGAL_INFO2                                 298
#define IDS_CREATED_ON                                  299
#define IDS_WMI_DENIED                                  300
#define IDS_LINK_DISABLED                               301
#define IDS_GPO_DISABLED                                302
#define IDS_ACCESS_DENIED                               303
#define IDS_VERSION_ZERO                                304
#define IDS_NOT_APPLIED                                 305

// Status messages
#define IDS_STARTED_RETRIEVAL                           351
#define IDS_CONNECT_CIMV2                               352
#define IDS_USER_DATA                                   353
#define IDS_CONNECT_RSOP                                354
#define IDS_GET_SID                                     355
#define IDS_GET_NAME                                    356
#define IDS_GET_PROFILE                                 357
#define IDS_GET_COMMON                                  358
#define IDS_GET_DOMAIN                                  359
#define IDS_GET_SITE                                    360
#define IDS_GET_PROVIDER                                361
#define IDS_GET_METHOD                                  362
#define IDS_PUT_SID                                     363
#define IDS_CREATE_SESSION                              364
#define IDS_DISPLAY_DATA                                365
#define IDS_WAIT                                        366
#define IDS_GET_OSINFO                                  367

#define ID_HELP_START                   IDS_HELP_1
#define ID_HELP_END                     IDS_HELP_40
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\cmdline\gpresult\loggingdata.cpp ===
/*********************************************************************************************

Copyright (c) Microsoft Corporation
 
Module Name: 
    
    LoggingData.cpp

Abstract:
    
    Collects and displays all the data related with the logging option.     
 
Author:
    
    Wipro Technologies.
    
Revision History:

    22-Feb-2001 : Created It.

*********************************************************************************************/ 

#include "pch.h"
#include "GpResult.h"
#include "WMI.h"

// Local function prototypes
BOOL GetDomainType( LPTSTR lpszDomainName, BOOL * pbW2K, BOOL *pbLocalAccount );
BOOL RsopDeleteMethod( IWbemClassObject *pClass, CHString strNameSpace, 
                                        IWbemServices *pNamespace );
VOID DisplayLinkSpeed( IWbemServices *pNameSpace, COAUTHIDENTITY *pAuthIdentity );
VOID SortAppliedData( TARRAY arrAppliedData );

/*********************************************************************************************
Routine Description:

    This function is the main entry point for collecting and displaying the data for logging mode
     
Arguments:
 
    None

Return Value:
 
    TRUE  on SUCCESS
    FALSE on ERROR
*********************************************************************************************/
BOOL  CGpResult::GetLoggingData()
{
    // Local declarations
    BOOL        bResult = FALSE;
    BOOL        bAllUsers = TRUE;

    DWORD       dwBufferSize = MAX_STRING_LENGTH;
    DWORD       dwPosition = -1;

    // Connect to wmi...connecting to 'cimv2' and saving the pointer in a member variable
    bResult = ConnectWmiEx( m_pWbemLocator, &m_pWbemServices, m_strServerName,
                            m_strUserName, m_strPassword, &m_pAuthIdentity, 
                            m_bNeedPassword, ROOT_NAME_SPACE, &m_bLocalSystem );
        
    if( bResult == FALSE )
    {
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );
        return FALSE;
    }

    // check the remote system version and its compatiblity
    if ( m_bLocalSystem == FALSE )
    {
        // check the version compatibility
        DWORD dwVersion = 0;
        dwVersion = GetTargetVersionEx( m_pWbemServices, m_pAuthIdentity );
        
        // Check for the version W2K = 5000 and WindowsXP = 5001
        if ( dwVersion <= VERSION_CHECK )
        {
            // Display the appropriate error message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, ERROR_OS_INCOMPATIBLE );
            return FALSE;
        }
    }

    // Set the password to the one got in the AUTHIDENTITY structure
    if( m_pAuthIdentity != NULL )
    {
        m_pwszPassword = m_pAuthIdentity->Password;
    }

    // check if it is the local system and the user credentials are specified....
    // if so display a warning message
    if( ( m_bLocalSystem == TRUE ) && ( m_strUserName.GetLength() != 0 ) )
    {
        ShowMessage( stdout, GetResString( IDS_WARNING ) );
        ShowMessage( stdout, GetResString( IDS_WARN_LOCAL ) );
        ShowMessage( stdout, NEW_LINE );

        // set the user name and password to NULL
        m_strUserName = L"";
        m_pwszPassword = NULL;

        // Get the new screen co-ordinates
        if ( m_hOutput != NULL )
        {
            GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
        }
    }
    
    // Connection part is over...check wether the user,for whom the RSOP data
    // has to be got has been specified.
    if( m_strUser.GetLength() == 0 )
    {
        // user is not specified....get the current logged on user
        LPWSTR pwszUserName = NULL;
        try
        {
            pwszUserName = m_strUser.GetBufferSetLength( dwBufferSize );
        }
        catch( ... )
        {
            // display the error message
            SetLastError( E_OUTOFMEMORY );
            SaveLastError();
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetReason() );
        }

        if ( GetUserNameEx( NameSamCompatible, pwszUserName, &dwBufferSize ) == FALSE )
        {
            // error occured while trying to get the current user info
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            return FALSE;
        }

        // Release the buffer
        m_strUser.ReleaseBuffer();
    }

    // Separating the domain name from the user name for whom the data has to be retrieved
    if( m_strUser.Compare( TEXT_WILD_CARD ) != 0 )
    {
        bAllUsers = FALSE;
        dwPosition = m_strUser.Find( SLASH );
        try
        {
            if( dwPosition != -1 )
            {
                m_strDomainName = m_strUser.Left( dwPosition );
                m_strUser = m_strUser.Mid( ( dwPosition + 1 ), m_strUser.GetLength() );
            }
            else
            {
                // Try for the name@domain format (UPN format)
                dwPosition = m_strUser.Find( SEPARATOR_AT );
                if( dwPosition != -1 )
                {
                    m_strDomainName = m_strUser.Mid( ( dwPosition + 1 ), m_strUser.GetLength() );
                    m_strUser = m_strUser.Left( dwPosition );
                }

                // Remove the unwanted things in the domain name
                dwPosition = m_strDomainName.Find( SEPARATOR_DOT );
                if( dwPosition != -1 )
                {
                    m_strDomainName = m_strDomainName.Left( dwPosition );
                }
            }
        }
        catch( ... )
        {
            // display the error message
            SetLastError( E_OUTOFMEMORY );
            SaveLastError();
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetReason() );
        }
    }

    PrintProgressMsg( m_hOutput, GetResString( IDS_USER_DATA ), m_csbi );

    //
    // Start the retrieval of information....
    // Get the user information
    if( GetUserData( bAllUsers ) == FALSE )
    {
        return FALSE;
    }

    return TRUE;
}

/*********************************************************************************************
Routine Description:

     This function displays the non verbose data
     
Arguments:
 
    [in] USERINFO           :   pointer to the user information structure
    [in] IWBEMSERVICES      :   pointer to the namespace
    
Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayData( PUSERINFO pUserInfo, IWbemServices *pRsopNameSpace )
{
    // local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bCreatedRsop = FALSE;

    ULONG                       ulReturn = 0;
    DWORD                       dwi = 0;
    DWORD                       dwj = 0;
    DWORD                       dwMutex = 0;

    CHString                    strTemp;
    CHString                    strNameSpace;
    BSTR                        bstrTemp = NULL;
    
    IWbemClassObject            *pClass = NULL;
    IWbemClassObject            *pInClass = NULL;
    IWbemClassObject            *pInInst = NULL;
    IWbemClassObject            *pOutInst = NULL;
    IWbemServices               *pNameSpace = NULL;
    IEnumWbemClassObject        *pRsopClass = NULL;

    WCHAR                       szMutexName[512] = MUTEX_NAME;

    try
    {
        if( pUserInfo == NULL || pRsopNameSpace == NULL )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            _com_issue_error( STG_E_UNKNOWN );
        }
    
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_PROVIDER ), m_csbi );

        // Get the object for the RSOP diagnostic mode provider
        hResult = pRsopNameSpace->GetObject( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                0, NULL, &pClass, NULL );
        CHECK_HRESULT_EX( hResult );
        
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_METHOD ), m_csbi );

        // get the reqd. method....create an rsop session
        hResult = pClass->GetMethod( _bstr_t( FN_CREATE_RSOP ), 0, &pInClass, NULL );
        CHECK_HRESULT_EX( hResult );

        // spawn the instances....get a new instance of the provider
        hResult = pInClass->SpawnInstance( 0, &pInInst );
        CHECK_HRESULT_EX( hResult );
        
        // Put the user SID...
        PrintProgressMsg( m_hOutput, GetResString( IDS_PUT_SID ), m_csbi );

        hResult = PropertyPut( pInInst, CPV_USER_SID, pUserInfo->strUserSid );
        CHECK_HRESULT_EX( hResult );

        hResult = PropertyPut( pInInst, CPV_FLAGS, FLAG_FORCE_CREATENAMESPACE );
        CHECK_HRESULT_EX( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_WAIT ), m_csbi );
        
        // We are ready to call the method to create a session
        // Check on the mutex to see if the call can be executed
        lstrcat( szMutexName, L"_");
        strTemp = pUserInfo->strUserName;
        LONG lPos = strTemp.Find(TEXT_BACKSLASH);
        if( lPos >= 0 && lPos <= strTemp.GetLength() )
        {
            strTemp.SetAt(lPos, L'_' );
        }

        lstrcat( szMutexName, strTemp );
        if( FALSE == CreateRsopMutex( szMutexName ) )
        {
            ShowMessage(stdout, GetResString(IDS_INFO) );
			SetLastError( ERROR_RETRY );
			ShowLastError( stdout );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );

            return TRUE;
        }
        dwMutex = WAIT_FAILED;
        if( NULL == m_hMutex )
        {
           PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage(stdout, GetResString(IDS_INFO) );
			SetLastError( ERROR_SINGLE_INSTANCE_APP );
			ShowLastError( stdout );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );

            return TRUE;
        }
        if( m_hMutex != NULL )
        {
            dwMutex = WaitForSingleObject( m_hMutex, INFINITE );
            if( dwMutex == WAIT_FAILED )
            {
                SaveLastError();
                ShowMessage( stderr, GetResString(IDS_ERROR) );
                ShowMessage( stderr, GetReason() );
            }
        }

        if( dwMutex != WAIT_FAILED )
        {
            // Print the progress message
            strTemp.Format( GetResString( IDS_CREATE_SESSION ), pUserInfo->strUserName );
            PrintProgressMsg( m_hOutput, strTemp, m_csbi );

            // All The required properties are set, so...execute method RSopCreateSession
            hResult = pRsopNameSpace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ), 
                                                    _bstr_t( FN_CREATE_RSOP ), 
                                                    0, NULL, pInInst, &pOutInst, NULL);
        }
        if( pOutInst == NULL )
        {
            hResult = E_FAIL;   
        }
        if( FAILED( hResult ) )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            // display the error message
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );

            //release the object
            ReleaseMutex( m_hMutex );
        
            return FALSE;
        }
        
        // Get the result value...
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0 );
        CHECK_BRESULT( bResult );

        if( ulReturn != 0 )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );

            ReleaseMutex( m_hMutex );

            return FALSE;
        }

        // set the flag to indicate that the namespace has been created.
        bCreatedRsop = TRUE;

        // Get the resultant RSOP name space
        bResult = PropertyGet( pOutInst, FPR_RSOP_NAME_SPACE, strTemp, V_NOT_AVAILABLE );
        CHECK_BRESULT( bResult );

        // Check if we have got the output
        if( lstrcmp( strTemp, V_NOT_AVAILABLE ) == 0 )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the allocated variables
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            
            ReleaseMutex( m_hMutex );

            return FALSE;
        }

        // Got the data so start displaying
        // Display the information common to both scopes
        DisplayCommonData( pUserInfo );

        // Get the string starting with 'R'...as that's where the RSOP namespace starts
        // This is done to remove the '\'s in the beginning of the string returned.
        lPos = 0;
        strTemp.MakeLower();
        lPos = strTemp.Find( START_NAMESPACE );
        if ( lPos != -1 )
        {
            strTemp = strTemp.Mid( lPos + 1 );
        }
        else
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // check if the computer information has to be displayed
        if( (m_dwScope == SCOPE_COMPUTER) || (m_dwScope == SCOPE_ALL) )
        {
            // connect to the resultant name space (computer)
            strNameSpace = strTemp + TEXT_BACKSLASH + TEXT_SCOPE_COMPUTER;

            ConnectWmi( m_pWbemLocator, &pNameSpace, m_strServerName, 
                        m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                        FALSE, strNameSpace, &hResult );
            CHECK_HRESULT( hResult );

            // get the link speed information
            DisplayLinkSpeed( pNameSpace, m_pAuthIdentity );

            // Display the heading for the scope Computer
            ShowMessage( stdout, GetResString( IDS_GPO_COMPUTER ) );
            ShowMessage( stdout, NEW_LINE );
            for( dwi = lstrlen( GetResString( IDS_GPO_COMPUTER ) ); dwi > 1; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the FQDN for the computer
            ShowMessage( stdout, pUserInfo->strComputerFQDN );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the link speed threshold value for the computer
            DisplayThresholdSpeedAndLastTimeInfo( TRUE );

            // Display the heading for the Computer GPO's
            ShowMessage( stdout, GetResString( IDS_GPO_DISPLAY ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = lstrlen( GetResString( IDS_GPO_DISPLAY ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            // Display the GPO data for computer
            GpoDisplay( pNameSpace, TEXT_SCOPE_COMPUTER );

            // Display the security groups for the system
            DisplaySecurityGroups( pNameSpace, TRUE );

            // check wether the verbose option is specified
            if( m_bVerbose == TRUE || m_bSuperVerbose == TRUE )
            {
                // display the verbose computer information
                DisplayVerboseComputerData( pNameSpace );
            }

            // release the interface pointer
            SAFEIRELEASE( pNameSpace );
        }

        // check for user...
        if( (m_dwScope == SCOPE_USER) || (m_dwScope == SCOPE_ALL) )
        {
            // connect to the resultant name space (user)
            strNameSpace = strTemp + TEXT_BACKSLASH + TEXT_SCOPE_USER;

            ConnectWmi( m_pWbemLocator, &pNameSpace, m_strServerName, 
                        m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                        FALSE, strNameSpace, &hResult );
            CHECK_HRESULT( hResult );

            // if only the user scope has been specified then the link speed 
            // information has not yet been displayed...display it
            if( m_dwScope == SCOPE_USER )
            {
                // Get the link speed information
                DisplayLinkSpeed( pNameSpace, m_pAuthIdentity );
            }

            // Display the heading for the scope User
            ShowMessage( stdout, GetResString( IDS_GPO_USER ) );
            ShowMessage( stdout, NEW_LINE );
            for( dwi = lstrlen( GetResString( IDS_GPO_USER ) ); dwi > 1; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the FQDN for the computer
            ShowMessage( stdout, pUserInfo->strUserFQDN );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );

            // Display the link speed threshold value for the user
            DisplayThresholdSpeedAndLastTimeInfo( FALSE );

            // Display the heading for the User GPO's
            ShowMessage( stdout, GetResString( IDS_GPO_DISPLAY ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = lstrlen( GetResString( IDS_GPO_DISPLAY ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );

            // Display the GPO data for user
            GpoDisplay( pNameSpace, TEXT_SCOPE_USER );

            // Display the security groups for the user
            DisplaySecurityGroups( pNameSpace, FALSE );

            // check wether the verbose option is specified
            if( m_bVerbose == TRUE || m_bSuperVerbose == TRUE )
            {
                // display the verbose computer information
                DisplayVerboseUserData( pNameSpace );
            }

            // release the interface pointer
            SAFEIRELEASE( pNameSpace );
        }
        
        // Delete the namespace created
        if( RsopDeleteMethod( pClass, strTemp, pRsopNameSpace ) == FALSE )
        {
            // release the allocated variables
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pRsopClass );
            SAFEIRELEASE( pClass );
            SAFEIRELEASE( pInClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            ReleaseMutex( m_hMutex );
            return FALSE;
        }
    }
    catch(  _com_error & error )
    {
        // display the error message
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // Delete the name space if it has been created.
        if( bCreatedRsop == TRUE )
        {
            RsopDeleteMethod( pClass, strNameSpace, pRsopNameSpace );
        }

        // release the interface pointers and exit
        SAFEIRELEASE( pRsopClass );
        SAFEIRELEASE( pClass );
        SAFEIRELEASE( pInClass );
        SAFEIRELEASE( pInInst );
        SAFEIRELEASE( pOutInst );
        
        ReleaseMutex( m_hMutex );
        return FALSE;
    }

    ReleaseMutex( m_hMutex );

    // release the interface pointers and exit
    SAFEIRELEASE( pRsopClass );
    SAFEIRELEASE( pClass );
    SAFEIRELEASE( pInClass );
    SAFEIRELEASE( pInInst );
    SAFEIRELEASE( pOutInst );
    
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the user data and fills the structure with the same
     
Arguments:
 
    [in] BOOL   bAllUsers       :   Specifies that the Rsop data has to be retrieved
                                    for all the users.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserData( BOOL bAllUsers )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bGotDomainInfo = FALSE;
    BOOL                        bConnFlag = TRUE;
    
    TCHAR                       szTemp[ MAX_STRING_LENGTH ];
    TCHAR                       szServer[ MAX_STRING_LENGTH ];
    TCHAR                       szName[ MAX_STRING_LENGTH ];
    TCHAR                       szDomain[ MAX_STRING_LENGTH ];
    TCHAR                       szFQDN[ MAX_STRING_LENGTH ];
    TCHAR                       szAdsiBuffer[ MAX_STRING_LENGTH ];
    
    CHString                    strTemp = NULL_STRING;
    CHString                    strDisplay = NULL_STRING;
    
    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemServices               *pRsopNameSpace = NULL;
    IWbemClassObject            *pUserClass =  NULL;
    IWbemClassObject            *pInInst = NULL;
    IWbemClassObject            *pOutInst = NULL;

    ULONG                       ulReturn = 0;
    LONG                        lCount = 0;
    LONG                        lLBound = 0;
    LONG                        lUBound = 0;

    DWORD                       dwName = MAX_STRING_LENGTH;
    DWORD                       dwDomain = MAX_STRING_LENGTH;
    DWORD                       dwBufSize = MAX_STRING_LENGTH;
        
    USERINFO                    *pUserInfo = new USERINFO;

    VARIANT                     vVarVerbose;
    VARTYPE                     vartype;

    SAFEARRAY                   *safeArray = NULL;

    PSID                        pSid = NULL;
    SID_NAME_USE                *pSidNameUse = new SID_NAME_USE;

    try
    {
        // set the strings to NULL
        ZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        ZeroMemory( szName, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        ZeroMemory( szServer, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        ZeroMemory( szDomain, MAX_STRING_LENGTH * sizeof( TCHAR ) );
        ZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );

        PrintProgressMsg( m_hOutput, GetResString( IDS_CONNECT_RSOP ), m_csbi );

        // connect to the RSOP namespace
        ConnectWmi( m_pWbemLocator, &pRsopNameSpace, m_strServerName, 
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_RSOP ), &hResult );
        CHECK_HRESULT( hResult );

        // Get the object for the RSOP diagnostic mode provider
        hResult = pRsopNameSpace->GetObject( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ),
                                                0, NULL, &pUserClass, NULL );
        CHECK_HRESULT( hResult );
        
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_METHOD ), m_csbi );

        // get the reqd. method....to enumerate the users
        hResult = pUserClass->GetMethod( _bstr_t( FN_ENUM_USERS ), 0, &pInInst, NULL );
        CHECK_HRESULT( hResult );

        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_SID ), m_csbi );

        // Execute method RSopEnumerateUsers
        hResult = pRsopNameSpace->ExecMethod( _bstr_t( CLS_DIAGNOSTIC_PROVIDER ), 
                                                _bstr_t( FN_ENUM_USERS ), 
                                                0, NULL, pInInst, &pOutInst, NULL);
        if( pOutInst == NULL )
        {
            hResult = E_FAIL;   
        }
        if( FAILED( hResult ) )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );
                    
            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pUserClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pEnumClass );
            
            SAFE_DELETE( pUserInfo );
            SAFE_DELETE( pSidNameUse );

            return FALSE;
        }

        // Get the result value...
        bResult = PropertyGet( pOutInst, FPR_RETURN_VALUE, ulReturn, 0 );
        CHECK_BRESULT( bResult );

        if( ulReturn != 0 )
        {
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            ShowMessage( stderr, GetResString( IDS_ERROR ) );
            ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

            // release the interface pointers and exit
            SAFEIRELEASE( pRsopNameSpace );
            SAFEIRELEASE( pUserClass );
            SAFEIRELEASE( pInInst );
            SAFEIRELEASE( pOutInst );
            SAFEIRELEASE( pEnumClass );
            
            SAFE_DELETE( pUserInfo );
            SAFE_DELETE( pSidNameUse );

            return FALSE;
        }

        VariantInit( &vVarVerbose );
        hResult = pOutInst->Get( _bstr_t( CPV_USER_SIDS ), 0, &vVarVerbose, 0, 0 );
        CHECK_HRESULT_VAR( hResult, vVarVerbose );

        if( vVarVerbose.vt != VT_NULL && vVarVerbose.vt != VT_EMPTY )
        {
            // get the type of the elements in the safe array
            vartype = V_VT( &vVarVerbose ) & ~VT_ARRAY;

            //get the array of strings in to the safe array from the variant
            safeArray = (SAFEARRAY *)vVarVerbose.parray;

            //get the number of elements (subkeys)
            if( safeArray != NULL )
            {
                hResult = SafeArrayGetLBound( safeArray, 1, &lLBound );
                CHECK_HRESULT( hResult );   

                hResult = SafeArrayGetUBound( safeArray, 1, &lUBound );
                CHECK_HRESULT( hResult );  
                if( lUBound == 0xffffffff )
                {
                                // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );

                    ShowMessage( stdout, GetResString( IDS_INFO) );
					SetLastError( ERROR_POLICY_OBJECT_NOT_FOUND );
					ShowLastError( stdout );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );
                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );
                    return TRUE;
                }
            }

            // If we have to get the information from a remote machine then...
            // connect to the remote machine.
            if ( m_bLocalSystem == FALSE )
            {
                lstrcpy( szServer, m_strServerName );
                lstrcpy( szName, m_strUserName );
                
                // erase the last status message
                PrintProgressMsg( m_hOutput, NULL, m_csbi );

                bResult = EstablishConnection( szServer, szName, MAX_STRING_LENGTH, 
                                                m_pwszPassword, MAX_STRING_LENGTH, FALSE );
                if( bResult != TRUE )
                {
                    // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );
                    
                    ShowMessage( stderr, GetResString( IDS_ERROR ) );
                    ShowMessage( stderr, GetReason() );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );
                    
                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );

                    return FALSE;
                }
                else
                {
                    switch( GetLastError() )
                    {
                        case I_NO_CLOSE_CONNECTION:
                            bConnFlag = FALSE;
                            break;
 
                        case E_LOCAL_CREDENTIALS:
                        case ERROR_SESSION_CREDENTIAL_CONFLICT:
                            bConnFlag = FALSE;
                            break;

                        default:
                            break;
                    }
                }

                // Get the new output co-ordinates
                if ( m_hOutput != NULL )
                {   
                    GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
                }
            }

            for( lCount = lLBound ; lLBound <= lUBound; lLBound++ )
            {
                bResult = GetPropertyFromSafeArray( safeArray, lLBound, strTemp, vartype );
                CHECK_BRESULT( bResult );
                         
                // Got the SID...save it in the structure
                pUserInfo->strUserSid = strTemp;

                PrintProgressMsg( m_hOutput, GetResString( IDS_GET_NAME ), m_csbi );

                // Get the User Name
                lstrcpy( szTemp, strTemp );
                ConvertStringSidToSid( szTemp, &pSid );
                                
                // Get the user name for the SID we have got
                bResult = LookupAccountSid( szServer, pSid, szName, &dwName, szDomain, 
                                            &dwDomain, pSidNameUse );
                if( bResult == 0 )
                {
                    // Could not get the name from the API try to retrieve it from WMI
                    bResult = GetUserNameFromWMI( szTemp, szName, szDomain );
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );
                    if( bResult == FALSE )
                    {
                        // Increment the count
                        lCount++;

                        // If the user was not found then display a message stating the same
                        if( lCount > lUBound )
                        {
                            strTemp = L"";
                            if( bAllUsers == FALSE )
                            {
                                // check if we need to append the domain name
                                if ( m_strDomainName.GetLength() != 0 )
                                {
                                    strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
                                }
                                else
                                {
                                    strTemp = m_strUser;
                                }
                            }
                            
                            // Form the display string
                            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), strTemp );

                            ShowMessage( stderr, GetResString( IDS_INFO ) );
                            ShowMessage( stderr, strDisplay );
                        }

                        // could not get a name for this SID, so continue with the next SID.
                        continue;
                    }
                }
                
                // Free the pSid
                if( pSid != NULL )
                {
                    LocalFree( pSid );
                    pSid = NULL;
                }

                // Check wether the Rsop data has to be retrieved for this user name.
                if( bAllUsers == FALSE )
                {
                    if( lstrcmpi( szName, m_strUser ) != 0 
                        || ( lstrcmpi( szDomain, m_strDomainName ) != 0 
                                && m_strDomainName.GetLength() != 0 ) )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // re-set the buffer sizes
                        dwName = MAX_STRING_LENGTH;
                        dwDomain = MAX_STRING_LENGTH;

                        // Increment the count
                        lCount++;

                        // If the user was not found then display a message stating the same
                        if( lCount > lUBound )
                        {
                            // check if we need to append the domain name
                            if ( m_strDomainName.GetLength() != 0 )
                            {
                                strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
                            }
                            else
                            {
                                strTemp = m_strUser;
                            }

                            // Form the display string
                            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), strTemp );

                            ShowMessage( stderr, GetResString( IDS_INFO ) );
                            ShowMessage( stderr, strDisplay );
                        }

                        // No need to get the data for this user
                        continue;
                    }
                }

                // Store the user name into the structure.
                pUserInfo->strUserName = szName;

                // Append the domain name to the user name.
                lstrcat( szDomain, TEXT_BACKSLASH );
                lstrcat( szDomain, pUserInfo->strUserName );
                pUserInfo->strUserName = szDomain;
  
                PrintProgressMsg( m_hOutput, GetResString( IDS_GET_PROFILE ), m_csbi );

                // Get the user profile information
                if( GetUserProfile( pUserInfo ) == FALSE )
                {
                    // erase the last status message
                    PrintProgressMsg( m_hOutput, NULL, m_csbi );

                    // Display the error message
                    ShowMessage( stderr, GetResString( IDS_ERROR ) );
                    ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

                    // release the interface pointers and exit
                    SAFEIRELEASE( pRsopNameSpace );
                    SAFEIRELEASE( pUserClass );
                    SAFEIRELEASE( pInInst );
                    SAFEIRELEASE( pOutInst );
                    SAFEIRELEASE( pEnumClass );
                    
                    SAFE_DELETE( pUserInfo );
                    SAFE_DELETE( pSidNameUse );

                    // if we have opened a connection then close the same.
                    if( m_bLocalSystem == FALSE  && bConnFlag == TRUE )
                    {
                        lstrcpy( szServer, m_strServerName );
                        CloseConnection( szServer );
                    }

                    return FALSE;
                }

                if( bGotDomainInfo == FALSE )
                {
                    PrintProgressMsg( m_hOutput, GetResString( IDS_GET_COMMON ), m_csbi );

                    // Get the domain name and other related information
                    if( GetDomainInfo( pUserInfo ) == FALSE )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // Display the error message
                        ShowMessage( stderr, GetResString( IDS_ERROR ) );
                        ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );

                        // release the interface pointers and exit
                        SAFEIRELEASE( pRsopNameSpace );
                        SAFEIRELEASE( pUserClass );
                        SAFEIRELEASE( pInInst );
                        SAFEIRELEASE( pOutInst );
                        SAFEIRELEASE( pEnumClass );
                        
                        SAFE_DELETE( pUserInfo );
                        SAFE_DELETE( pSidNameUse );

                        // if we have opened a connection then close the same.
                        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
                        {
                            lstrcpy( szServer, m_strServerName );
                            CloseConnection( szServer );
                        }

                        return FALSE;
                    }

                    // Get the OS information
                    if( GetOsInfo( pUserInfo ) == FALSE )
                    {
                        // erase the last status message
                        PrintProgressMsg( m_hOutput, NULL, m_csbi );

                        // Display the error message
                        ShowMessage( stderr, GetResString( IDS_ERROR ) );
                        ShowMessage( stderr, GetResString( IDS_METHOD_FAILED ) );
                        
                        // release the interface pointers and exit
                        SAFEIRELEASE( pRsopNameSpace );
                        SAFEIRELEASE( pUserClass );
                        SAFEIRELEASE( pInInst );
                        SAFEIRELEASE( pOutInst );
                        SAFEIRELEASE( pEnumClass );
                        
                        SAFE_DELETE( pUserInfo );
                        SAFE_DELETE( pSidNameUse );

                        // if we have opened a connection then close the same.
                        if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
                        {
                            lstrcpy( szServer, m_strServerName );
                            CloseConnection( szServer );
                        }

                        return FALSE;
                    }

                    // Get the FQDN of the computer
                    // PrintProgressMsg( m_hOutput, GetResString( IDS_GET_FQDN ), m_csbi );

                    if( m_bLocalSystem == TRUE )
                    {
                        // we have to get the FQDN for the local system 
                        // use the GetComputerObjectName API
                        ulReturn = MAX_STRING_LENGTH;
                        GetComputerObjectName( NameFullyQualifiedDN, szFQDN, &ulReturn);
                    }
                    else 
                    {
                        // Get the local computers domain name
                        GetComputerNameEx( ComputerNameDnsDomain, szAdsiBuffer, &dwBufSize );

                        lstrcpy( szServer, m_strADSIServer );
                        lstrcat( szServer, TEXT_DOLLAR );

                        // Check if the machine we are querying is in the same domain
                        if( m_strADSIDomain.CompareNoCase( szAdsiBuffer ) == 0 )
                        {
                            // get the FQDN from the Translate name call
                            dwBufSize = MAX_STRING_LENGTH;
                            TranslateName( szServer, NameDisplay, NameFullyQualifiedDN, 
                                            szFQDN, &dwBufSize );
                        }
                        else
                        {
                            // Get the FQDN from ADSI directory services
                            GetFQDNFromADSI( szFQDN, TRUE, szServer );
                        }
                    }
                        
                    // Store the FQDN into the structure.
                    pUserInfo->strComputerFQDN = szFQDN;
    
                    // Set the flag to TRUE so that this code is not executed again and again
                    bGotDomainInfo = TRUE;
                }

                // Get the FQDN of the user
                if( ( m_bLocalSystem == TRUE ) 
                        || ( m_strADSIDomain.CompareNoCase( szAdsiBuffer ) == 0 ) ) 
                {
                    ZeroMemory( szFQDN, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                    dwBufSize = MAX_STRING_LENGTH;
                    lstrcpy( szName, pUserInfo->strUserName );

                    // get the FQDN from the Translate name call
                    TranslateName( szName, NameSamCompatible, NameFullyQualifiedDN, 
                                    szFQDN, &dwBufSize );
                }
                else
                {
                    // Get the FQDN from ADSI directory services
                    lstrcpy( szName, pUserInfo->strUserName );
                    GetFQDNFromADSI( szFQDN, FALSE, szName );
                }
                
                // Store the FQDN into the structure.
                pUserInfo->strUserFQDN = szFQDN;

                // Now display the data
                PrintProgressMsg( m_hOutput, GetResString( IDS_STARTED_RETRIEVAL ), m_csbi );
                DisplayData( pUserInfo, pRsopNameSpace );

                // Get the new output co-ordinates
                if ( m_hOutput != NULL )
                {
                    GetConsoleScreenBufferInfo( m_hOutput, &m_csbi );
                }

                // re-set the buffers and their sizes
                ZeroMemory( szTemp, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                ZeroMemory( szName, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                ZeroMemory( szServer, MAX_STRING_LENGTH * sizeof( TCHAR ) );
                ZeroMemory( szDomain, MAX_STRING_LENGTH * sizeof( TCHAR ) );

                dwName = MAX_STRING_LENGTH;
                dwDomain = MAX_STRING_LENGTH;
            }// for

            // if we have opened a connection then close the same.
            if( m_bLocalSystem == FALSE && bConnFlag == TRUE )
            {
                lstrcpy( szServer, m_strServerName );
                CloseConnection( szServer );
            }
        }
        else
        {
            // No classes were retrieved....display msg
            // erase the last status message
            PrintProgressMsg( m_hOutput, NULL, m_csbi );

            // check if we need to append the domain name
            if ( m_strDomainName.GetLength() != 0 )
            {
                strTemp = m_strDomainName + _T( "\\" ) + m_strUser;
            }
            else
            {
                strTemp = m_strUser;
            }

            // Form the display string
            strDisplay.Format( GetResString( IDS_USER_NO_RSOP ), strTemp );

            ShowMessage( stderr, GetResString( IDS_INFO ) );
            ShowMessage( stderr, strDisplay );
        }

        VariantClear(&vVarVerbose);                 
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        // display the error msg
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the interface pointers and exit
        SAFEIRELEASE( pRsopNameSpace );
        SAFEIRELEASE( pUserClass );
        SAFEIRELEASE( pInInst );
        SAFEIRELEASE( pOutInst );
        SAFEIRELEASE( pEnumClass );
        
        SAFE_DELETE( pUserInfo );
        SAFE_DELETE( pSidNameUse );

        VariantClear(&vVarVerbose);

        return FALSE;
    }

    // release the interface pointers and exit
    SAFEIRELEASE( pRsopNameSpace );
    SAFEIRELEASE( pUserClass );
    SAFEIRELEASE( pInInst );
    SAFEIRELEASE( pOutInst );
    SAFEIRELEASE( pEnumClass );
    
    SAFE_DELETE( pUserInfo );
    SAFE_DELETE( pSidNameUse );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the user profile data and fills the array with the same
     
Arguments:
 
    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetUserProfile( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                 hResult = S_OK;

    IWbemServices           *pDefaultNameSpace = NULL;

    TCHAR                   szTemp[ MAX_STRING_LENGTH ];

    try
    {
        // connect to the default namespace
        ConnectWmi( m_pWbemLocator, &pDefaultNameSpace, m_strServerName, 
                    m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                    FALSE, _bstr_t( ROOT_DEFAULT ), &hResult );
        CHECK_HRESULT( hResult );

        // Set the sub key name
        lstrcpy( szTemp, PATH );
        lstrcat( szTemp, pUserInfo->strUserSid );
        
        // Get the local profile
        RegQueryValueWMI( pDefaultNameSpace, HKEY_DEF, szTemp, FPR_LOCAL_VALUE, 
                            pUserInfo->strLocalProfile, V_NOT_AVAILABLE );

        // Get the roaming profile
        RegQueryValueWMI( pDefaultNameSpace, HKEY_DEF, szTemp, FPR_ROAMING_VALUE, 
                            pUserInfo->strRoamingProfile, V_NOT_AVAILABLE );
    }
    catch(  _com_error & error )
    {
        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pDefaultNameSpace );
    
        return FALSE;
    }

    // release the interface pointer
    SAFEIRELEASE( pDefaultNameSpace );

    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function gets the domain information and fills the array with the same
     
Arguments:
 
    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::GetDomainInfo( PUSERINFO pUserInfo )
{
    // Local variables
    HRESULT                     hResult = S_OK;

    BOOL                        bResult = FALSE;
    BOOL                        bDone = FALSE;

    IEnumWbemClassObject        *pEnumClass = NULL;
    IWbemClassObject            *pClass = NULL;

    ULONG                       ulReturn = 0;

    CHString                    strTemp;

    try
    {
        // print the progress message
        PrintProgressMsg( m_hOutput, GetResString( IDS_GET_DOMAIN ), m_csbi );

        // Enumerate the instances to get the domain and site names of the Win32 NT domain
        hResult = m_pWbemServices->CreateInstanceEnum( _bstr_t( CLS_WIN32_SITE ),
                                                        WBEM_FLAG_FORWARD_ONLY | 
                                                        WBEM_FLAG_RETURN_IMMEDIATELY,
                                                        NULL, &pEnumClass );
        CHECK_HRESULT( hResult );
        
        // Set the interface security
        hResult = SetInterfaceSecurity( pEnumClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // get the data
        //   since there may be more than one instance and we are looking for the instance 
        //   with the domain controller and site name.....using a while loop and as soon as 
        //   we get the instance we need break out of it
        hResult = WBEM_S_NO_ERROR;
        while( hResult == WBEM_S_NO_ERROR )
        {
            hResult = pEnumClass->Next( WBEM_INFINITE, 1, &pClass, &ulReturn );
            CHECK_HRESULT( hResult );

            if( ulReturn == 0 )
            {
                // no more data so break out of the loop
                break;
            }

            // get the server name
            if( bDone == FALSE )
            {
                bDone = TRUE;
                bResult = PropertyGet( pClass, CPV_GPO_SERVER, pUserInfo->strUserServer, 
                                        V_NOT_AVAILABLE );
                CHECK_BRESULT( bResult );
            }

            // get the domain name
            bResult = PropertyGet( pClass, CPV_GPO_NAME, pUserInfo->strUserDomain, 
                                    V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            PrintProgressMsg( m_hOutput, GetResString( IDS_GET_SITE ), m_csbi );

            // get the site name
            bResult = PropertyGet( pClass, CPV_SITE_NAME, pUserInfo->strUserSite, 
                                    V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            // get the domain controller name
            bResult = PropertyGet( pClass, CPV_DC_NAME, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );

            if( lstrcmp( strTemp, V_NOT_AVAILABLE ) != 0 )
            {
                // this enumeration has the domain controller name...
                //   we have got the enumeration we need so get the other data
                break;
            }
        }// while
    }
    catch(  _com_error & error )
    {
        // erase the last status message
        PrintProgressMsg( m_hOutput, NULL, m_csbi );

        WMISaveError( error.Error() );
        ShowMessage( stderr, GetResString( IDS_ERROR ) );
        ShowMessage( stderr, GetReason() );

        // release the allocated variables
        SAFEIRELEASE( pEnumClass );
        SAFEIRELEASE( pClass );
        
        return FALSE;
    }

    // release the interface pointers
    SAFEIRELEASE( pEnumClass );
    SAFEIRELEASE( pClass );
        
    return TRUE;
}

/*********************************************************************************************
Routine Description:

    This function returns the domain type

Arguments:

    [in]  lpDomainName     : domain name intends to view Rsop data.
    [out] pbW2K            : contain whether the domain type in W2K.
    [out] pbLocalAccount   : contain whether the account is local.
        
Return Value:

    TRUE  - if DC found/domain name is computer name
    FALSE - if DC not found   
*********************************************************************************************/
BOOL GetDomainType( LPTSTR lpszDomainName, BOOL * pbW2K, BOOL *pbLocalAccount )
{
    PDOMAIN_CONTROLLER_INFO         pDCI;

    DWORD                           dwResult = 0;
    DWORD                           dwSize = 0;

    TCHAR                           szComputerName[ MAX_PATH ];
        
    // Check the incoming pointers
    if( lpszDomainName == NULL || pbW2K == NULL || pbLocalAccount == NULL )
    {
        return FALSE;
    }

    // Check this domain for a Domain Controller
    dwResult = DsGetDcName( NULL, lpszDomainName, NULL, NULL,
                            DS_DIRECTORY_SERVICE_PREFERRED, &pDCI );
    if ( dwResult == ERROR_SUCCESS )
    {
        // Found a DC, does it have a DS ?
        if ( pDCI->Flags & DS_DS_FLAG ) 
        {
            *pbW2K = TRUE;
        }
        
        NetApiBufferFree( pDCI );
        
        return TRUE;
    }
    
    // Check if the domain name is also the computer name (eg: local account)
    dwSize = ARRAYSIZE( szComputerName );
    if ( GetComputerName ( szComputerName, &dwSize )  != 0 )
    {
        if ( lstrcmpi( szComputerName, lpszDomainName ) == 0 )
        {
            *pbLocalAccount = TRUE;
            return TRUE;
        }
    }
    
    return FALSE;
}

/*********************************************************************************************
Routine Description:

    This function displays the data common to both scopes
     
Arguments:
 
    [in] PUSERINFO      pUserInfo       :   Structure containing the user information.

Return Value:
 
    TRUE  on SUCCESS
    FALSE on FAILURE
*********************************************************************************************/
BOOL CGpResult::DisplayCommonData( PUSERINFO pUserInfo )
{
    // Local variables
    TCHAR                   szMsgBuffer[ MAX_RES_STRING ];
    TCHAR                   szDate[ MAX_RES_STRING ];
    TCHAR                   szTime[ MAX_RES_STRING ];

    BOOL                    bW2KDomain = FALSE;
    BOOL                    bLocalAccount = FALSE;
    BOOL                    bLocaleChanged = FALSE;

    DWORD                   dwLength = 0;

    SYSTEMTIME              systime;

    LCID                    lcid;
    
    // erase the last status message
    PrintProgressMsg( m_hOutput, NULL, m_csbi );

    // Clear the Msg buffer
    ZeroMemory( szMsgBuffer, MAX_RES_STRING );

    // Start displaying the output
    ShowMessage( stdout, NEW_LINE );
    
    // Print the leagal information
    ShowMessage( stdout, GetResString( IDS_LEGAL_INFO1 ) );
    ShowMessage( stdout, GetResString( IDS_LEGAL_INFO2 ) );

    // Print the date and time this report is generated
    GetLocalTime( &systime );

    // verify whether console supports the current locale 100% or not
    lcid = GetSupportedUserLocale( bLocaleChanged );

    // get the formatted date
    GetDateFormat( lcid, 0, &systime, ((bLocaleChanged == TRUE) ? L"MM/dd/yyyy" : NULL), 
                    szDate, SIZE_OF_ARRAY( szDate ) );
    
    // now format the date
    GetTimeFormat( LOCALE_USER_DEFAULT, 0, &systime, ((bLocaleChanged == TRUE) ? L"HH:mm:ss" : NULL), 
                    szTime, SIZE_OF_ARRAY( szTime ) );

    wsprintf( szMsgBuffer, GetResString( IDS_CREATED_ON ), szDate, szTime );
    ShowMessage( stdout, szMsgBuffer );

    ShowMessage( stdout, NEW_LINE );

    // Display the common information....Domain Info
    wsprintf( szMsgBuffer, GetResString( IDS_GPO_TITLE ), pUserInfo->strUserName, 
                pUserInfo->strUserServer );
    ShowMessage( stdout, szMsgBuffer );
    dwLength = lstrlen( szMsgBuffer );
    
    ShowMessage( stdout, NEW_LINE );
    
    // Underline the above heading
    for( ; dwLength > 0; dwLength-- )
    {
        ShowMessage( stdout, GetResString( IDS_DASH ) );
    }
    ShowMessage( stdout, NEW_LINE );

    lstrcpy( szMsgBuffer, pUserInfo->strUserDomain );
    if( lstrlen( szMsgBuffer ) != 0 )
    {
        lstrcpy( szMsgBuffer, _tcstok( szMsgBuffer, GetResString( IDS_LAST_CHAR ) ) );
        lstrcpy( szMsgBuffer, _tcstok( NULL, GetResString( IDS_LAST_CHAR ) ) );
    }
    
    // Show the OS information
    ShowMessage( stdout, GetResString( IDS_OS_TYPE ) ); 
    ShowMessage( stdout, pUserInfo->strOsType );

    ShowMessage( stdout, GetResString( IDS_OS_CONFIG ) );   
    ShowMessage( stdout, pUserInfo->strOsConfig );

    ShowMessage( stdout, GetResString( IDS_OS_VERSION ) );  
    ShowMessage( stdout, pUserInfo->strOsVersion );
    ShowMessage( stdout, NEW_LINE );    

    // Get the domain type information
    GetDomainType (szMsgBuffer, &bW2KDomain, &bLocalAccount);

    ShowMessage( stdout, GetResString( IDS_DOMAIN_NAME ) ); 
    ShowMessage( stdout, szMsgBuffer );
    ShowMessage( stdout, NEW_LINE );    

    ShowMessage( stdout, GetResString( IDS_DOMAIN_TYPE ) ); 
    // if it is a  win2k domain type
    if ( bW2KDomain ) 
    {
        ShowMessage( stdout, GetResString( IDS_W2K_DOMAIN ) );  
    }
    else
    {
        if ( bLocalAccount ) // local account
        {
            ShowMessage( stdout, V_NOT_AVAILABLE ); 
            ShowMessage( stdout, GetResString( IDS_LOCAL_COMP ) );  
        }
        else    //win NT4
        {
            ShowMessage( stdout, GetResString( IDS_NT4_DOMAIN ) );
        }
    }

    // Display the Site name
    ShowMessage( stdout, NEW_LINE );    
    ShowMessage( stdout, GetResString( IDS_SITE_NAME ) );
    ShowMessage( stdout, pUserInfo->strUserSite );

    // Display the roaming profile
    ShowMessage( stdout, NEW_LINE );    
    ShowMessage( stdout, GetResString( IDS_ROAMING_PROFILE ) );
    ShowMessage( stdout, pUserInfo->strRoamingProfile );

    // Display the local profile
    ShowMessage( stdout, NEW_LINE ); 
    ShowMessage( stdout, GetResString( IDS_LOCAL_PROFILE ) );
    ShowMessage( stdout, pUserInfo->strLocalProfile );
    ShowMessage( stdout, NEW_LINE );    

    return TRUE;
}

/*********************************************************************************************
Routine Description:
    This function displays the GPO information from the rsop namespace created.

Arguments:

    [in] IEnumWbemClassObject   :   pointer to the Enumeration class object
    [in] LPCTSTR                :   string containing the scope( USER or COMPUTER )

Return Value:
    
    TRUE  - if SUCCESS
    FALSE - if ERROR
*********************************************************************************************/
BOOL CGpResult::GpoDisplay( IWbemServices *pNameSpace, LPCTSTR pszScopeName )
{
    HRESULT                 hResult = WBEM_S_NO_ERROR;

    BOOL                    bResult = FALSE;
    BOOL                    bFilterAllowed = FALSE;
    BOOL                    bLinkEnabled = FALSE;
    BOOL                    bGpoEnabled = FALSE;
    BOOL                    bAccessDenied = FALSE;
    BOOL                    bConnected = FALSE;
    
    ULONG                   ulReturn = 0;
    ULONG                   ulAppliedOrder = 0;
    ULONG                   ulVersion = 0;

    DWORD                   dwAppliedRow = 0;
    DWORD                   dwFilteredRow = 0;

    CHString                strTemp;
    
    IEnumWbemClassObject    *pRsopLinkClass = NULL;
    IWbemClassObject        *pRsopLinkObj = NULL;
    IWbemClassObject        *pRsopObj = NULL;
    IWbemClassObject        *pSomFilter = NULL;

    IWbemServices           *pPolicyNameSpace = NULL;

    TARRAY                  arrAppliedData = NULL;
    TARRAY                  arrFilteredData = NULL;

    try
    {
        if( pNameSpace == NULL || pszScopeName == NULL )
        {
            _com_issue_error( STG_E_UNKNOWN );
        }

        // Create the Dynamic Arrays
        arrAppliedData = CreateDynamicArray( );
        arrFilteredData = CreateDynamicArray( );

        // Check the memory allocations
        if( arrAppliedData == NULL || arrFilteredData == NULL )
        {
            _com_issue_error( E_OUTOFMEMORY );
        }

        // enumerate the instances of the RSOP GPLink class
        hResult = pNameSpace->CreateInstanceEnum( _bstr_t( CLS_RSOP_GPOLINK ), 
                                                    WBEM_FLAG_FORWARD_ONLY |
                                                    WBEM_FLAG_RETURN_IMMEDIATELY,
                                                    NULL, &pRsopLinkClass );
        CHECK_HRESULT( hResult );

        // set the interface security
        hResult = SetInterfaceSecurity( pRsopLinkClass, m_pAuthIdentity );
        CHECK_HRESULT( hResult );

        // Get the information from the enumerated classes
        while( TRUE )
        {           
            // Get the pointer to the next class
            hResult = pRsopLinkClass->Next( WBEM_INFINITE, 1, &pRsopLinkObj, &ulReturn );
            CHECK_HRESULT( hResult );
            if( ulReturn == 0 )
            {
                break;
            }
            
            // Get the applied order for the link
            bResult = PropertyGet( pRsopLinkObj, CPV_APPLIED_ORDER, ulAppliedOrder, 0 );
            CHECK_BRESULT( bResult );

            // Get the link enabled property
            bResult = PropertyGet( pRsopLinkObj, CPV_ENABLED, bLinkEnabled, FALSE );
            CHECK_BRESULT( bResult );
            
            // Get the reference to the GPO class
            bResult = PropertyGet( pRsopLinkObj, CPV_GPO_REF, strTemp, V_NOT_AVAILABLE );
            CHECK_BRESULT( bResult );
            
            // Check wether the link has a GPO class
            if( strTemp.Find( GPO_REFERENCE ) != VAR_TRUE )
            {
                // Get the object for the GPO reference got
                hResult = pNameSpace->GetObject( _bstr_t( strTemp ), 0, NULL, &pRsopObj, NULL );
                if( FAILED( hResult ) )
                {
                    if( hResult == WBEM_E_NOT_FOUND )
                    {
                        continue;
                    }
                    _com_issue_error( hResult );
                }
            
                // Get the GPO name
                bResult = PropertyGet( pRsopObj, CPV_GPO_NAME, strTemp, V_NOT_AVAILABLE );
                CHECK_BRESULT( bResult );

                // Get the WMI filter status
                bResult = PropertyGet( pRsopObj, CPV_GPO_FILTER_STATUS, bFilterAllowed, FALSE );
                CHECK_BRESULT( bResult );

                // Get the Gpo enabled information
                bResult = PropertyGet( pRsopObj, CPV_ENABLED, bGpoEnabled, FALSE );
                CHECK_BRESULT( bResult );

                // Get the access denied information
                bResult = PropertyGet( pRsopObj, CPV_ACCESS_DENIED, bAccessDenied, FALSE );
                CHECK_BRESULT( bResult );

                // Get the version
                bResult = PropertyGet( pRsopObj, CPV_VERSION, ulVersion, 0 );
                CHECK_BRESULT( bResult );

                // If the applied order id not zero then this GPO is applied
                if( ulAppliedOrder > 0 )
                {
                    // Populate the applied Gpo array
                    DynArrayAppendRow( arrAppliedData, COL_MAX );
                    DynArraySetString2( arrAppliedData, dwAppliedRow, COL_DATA, strTemp, 0 );
                    DynArraySetDWORD2( arrAppliedData, dwAppliedRow, COL_ORDER, ulAppliedOrder );
                    dwAppliedRow++;
                }
                else if( bLinkEnabled != VAR_TRUE )
                {
                    // if the link is disabled...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_LINK_DISABLED ), 0 );
                    dwFilteredRow++;
                }
                else if( bGpoEnabled != VAR_TRUE )
                {
                    // if the GPO is disabled...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_GPO_DISABLED ), 0 );
                    dwFilteredRow++;
                }
                else if( bAccessDenied == VAR_TRUE )
                {
                    // if the access is denied...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_ACCESS_DENIED ), 0 );
                    dwFilteredRow++;
                }
                else if( bFilterAllowed != VAR_TRUE )
                {
                    // if the filter status is false...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX_FILTER );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_WMI_DENIED ), 0 );

                    // Get the filter ID
                    bResult = PropertyGet( pRsopObj, CPV_GPO_FILTER_ID, strTemp, V_NOT_AVAILABLE );
                    CHECK_BRESULT( bResult );

                    // Store it in the array
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER_ID, strTemp, 0 );
                    
                    dwFilteredRow++;
                }
                else if( ulVersion == 0 )
                {
                    // if the version is zero...populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_VERSION_ZERO ), 0 );
                    dwFilteredRow++;
                }
                else
                {
                    // the Gpo is not applied due to an unknown reason...
                    // populate the Filtered Array
                    DynArrayAppendRow( arrFilteredData, COL_MAX );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_DATA, strTemp, 0 );
                    DynArraySetString2( arrFilteredData, dwFilteredRow, COL_FILTER, 
                                        GetResString( IDS_NOT_APPLIED ), 0 );
                    dwFilteredRow++;
                }
            }
            
        }// while

        // Got the data...sort it
        SortAppliedData( arrAppliedData );

        // Display the applied data first
        dwAppliedRow = DynArrayGetCount( arrAppliedData );
        for( DWORD dwi = 0; dwi < dwAppliedRow; dwi++ )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, DynArrayItemAsString2( arrAppliedData, dwi, COL_DATA ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }

        // Check if there was any data displayed
        if( dwAppliedRow <= 0 )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, V_NOT_AVAILABLE );
            ShowMessage( stdout, NEW_LINE );
        }

        // Display the filtered GPOs
        // Display the header...if there are any GPO's filtered out
        dwFilteredRow = DynArrayGetCount( arrFilteredData );
        if( dwFilteredRow > 0 )
        {
            ShowMessage( stdout, GetResString( IDS_GPO_FILTERED ) );
            ShowMessage( stdout, GetResString( IDS_NEWLINE_TAB ) );
            for( dwi = lstrlen( GetResString( IDS_GPO_FILTERED ) ); dwi > 4; dwi-- )
            {
                ShowMessage( stdout, GetResString( IDS_DASH ) );
            }
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }
        else
        {
            // There are no filtered GPO's hence put a new line and continue 
            // displaying the rest of the output
            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }

        // display the data
        for( DWORD dwi = 0; dwi < dwFilteredRow; dwi++ )
        {
            ShowMessage( stdout, TAB_TWO );
            ShowMessage( stdout, DynArrayItemAsString2( arrFilteredData, dwi, COL_DATA ) );
            ShowMessage( stdout, GetResString( IDS_FILTERING ) );
            ShowMessage( stdout, DynArrayItemAsString2( arrFilteredData, dwi, COL_FILTER ) );
            
            // Check if we have to display the filter id for the WMI filter that evaluated to false
            if( lstrcmp( DynArrayItemAsString2( arrFilteredData, dwi, COL_FILTER ), 
                            GetResString( IDS_WMI_DENIED ) ) == 0 )
            {
                if( bConnected == FALSE )
                {
                    // we need to connect to Root\Policy 
                    // connect to the default namespace
                    ConnectWmi( m_pWbemLocator, &pPolicyNameSpace, m_strServerName, 
                                m_strUserName, m_pwszPassword, &m_pAuthIdentity,
                                FALSE, _bstr_t( ROOT_POLICY ), &hResult );
                    CHECK_HRESULT( hResult );

                    bConnected = TRUE;
                }
                                    
                // Get the object
                hResult = pPolicyNameSpace->GetObject( _bstr_t( DynArrayItemAsString2( 
                                                        arrFilteredData, dwi, COL_FILTER_ID ) ), 
                                                        0, NULL, &pSomFilter, NULL );
                CHECK_HRESULT( hResult );

                // Get the name of the filter applied
                bResult = PropertyGet( pSomFilter, CPV_NAME, strTemp, V_NOT_AVAILABLE );

                // display the filter ID
                ShowMessage( stdout, GetResString( IDS_GPO_FILTER_ID ) );
                ShowMessage( stdout, strTemp );
                ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
            }

            ShowMessage( stdout, GetResString( IDS_NEWLINE ) );
        }
        
        // destroy the dynamic arrays
        DESTROY_ARRAY( arrAppliedData );
        DESTROY_ARRAY( arrFilteredData );
    }
    catch( _com_error & error )
    {
        // display the error message
