                 )
                                        );
                    WriteProfileString( APPNAME
                                        , "Recursive"
                                        , dialog_recursive ? "1" : "0"
                                      );
                    Recursive = dialog_recursive;
                    dialog_fastscan =  ( 1 == SendDlgItemMessage( hDlg
                                                                  , IDD_FASTSCAN
                                                                  , BM_GETCHECK
                                                                  , 0
                                                                  , 0
                                                                )
                                       );
                    WriteProfileString( APPNAME
                                        , "Fastscan"
                                        , dialog_fastscan ? "1" : "0"
                                      );
                    dialog_autocopy =  ( 1 == SendDlgItemMessage( hDlg
                                                                  , IDD_AUTOCOPY
                                                                  , BM_GETCHECK
                                                                  , 0
                                                                  , 0
                                                                )
                                       );
                    /* The autocopy function is DANGEROUS so we do NOT keep it */

                    dialog_bothremote = (SendDlgItemMessage( hDlg
                                                             , IDD_BOTHREMOTE
                                                             , BM_GETCHECK
                                                             , 0
                                                             , 0
                                                           ) == 1);

                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* complist_dodlg_remote */
#endif

/* complist_matchnames has become utils_CompPath in gutils\utils.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\compitem.h ===
/*
 * CompItem
 *
 * a CompItem is a comparison between two files. It keeps track
 * of the two files. It knows how to compare two files, and knows the
 * results of the comparison: the end result is a list of SECTIONs
 * in each of the files, and a composite list of sections.
 *
 * One or other of the files may not exist.
 *
 * a compitem has a state - this indicates whether the two
 * files are the same, or different, or if only one file of that
 * name exists. This state is set on creation of the CompItem
 * and may be queried later.
 *
 */

#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST

/* build a new compitem from two files. Either (but not both) of the files
 * may be NULL.
 *
 * This operation may cause the files to be read in and compared.
 * In any case, this will be done by the time a call to one of
 * the query*sections functions completes.
 *
 * If the LIST parameter is not NULL, the item will be
 * appended to the list during initialisation - that is, the
 * compitem will do a List_NewLast operation and then initialise the
 * resulting object. If LIST is NULL, the compitem will allocate the
 * structure using some other memory allocation scheme. in either
 * case, the compitem handle will be returned. This also affects
 * behaviour of compitem_delete- we only free the compitem itself if
 * we allocated it ourself and not through List_NewLast.
 */
COMPITEM compitem_new(DIRITEM left, DIRITEM right, LIST list, BOOL fExact);


/* delete a compitem and free all associated data - INCLUDING deleting
 * the two FILEDATAs and all associated list of lines and sections.
 *
 * If the compitem was allocated on a list, it will not be freed, only
 * the memory hanging off it.
 */
void compitem_delete(COMPITEM item);


/* return a handle to a LIST of SECTIONs representing the compared file.
 * this call will cause the list to be created if it hasn't already been.
 *
 * returned handle will be NULL if either of the files is NULL.
 *
 * the list of sections can be traversed using the standard list functions.
 * the list you have a handle to is still owned by the compitem. to delete
 * it, call compitem_delete to delete the whole thing, or
 * compitem_discardsections to throw away all of the results of the compare
 */
LIST compitem_getcomposite(COMPITEM item);


/*
 * discard all compare data - throw away the composite section list and
 * any associated data (including the left and right section lists).
 * retains the two files. This is used either to free up memory when a
 * compitem is no longer being viewed, or to cause a new compare when
 * the global compare options flags (such as ignore_blanks) have changed.
 */
void compitem_discardsections(COMPITEM item);



/* return the handle to the list of sections in the left, right file.
 * These calls will cause the lists to be created if they are not already.
 *
 * the compitem still owns the list. traverse it with the standard list
 * functions, but don't change it or delete it.
 */
LIST compitem_getleftsections(COMPITEM item);
LIST compitem_getrightsections(COMPITEM item);


/* return the handle of the left or right file */
FILEDATA compitem_getleftfile(COMPITEM item);
FILEDATA compitem_getrightfile(COMPITEM item);


/* query the compare state of this compitem */
int compitem_getstate(COMPITEM item);

/* get a pointer to a text string describing the item (normally the
 * file name or filenames if different. The text pointed to should not
 * be changed or freed.
 */
LPSTR compitem_gettext_tag(COMPITEM item);

/* return a pointer to a text string describing the compare result - this
 * will be a text form of the item's state.
 * The text pointed to should not be changed or freed.
 */
LPSTR compitem_gettext_result(COMPITEM item);

/*
 * options for compitem_getfilename, indicating which name is desired
 */
#define CI_LEFT         1       /* name of left file */
#define CI_RIGHT        2       /* name of right file */
#define CI_COMP         3       /* name of composite file */

/*
 * return the name of the file associated with this compitem. The option
 * argument (one of CI_LEFT, CI_RIGHT, CI_COMP) indicates which file
 * is required.
 *
 * The file may be a temporary file, if the file option specifies a remote
 * file, or the composite file.
 *
 * call compitem_freefilename once the file is finished with.
 */
LPSTR compitem_getfilename(VIEW view, COMPITEM item, int option);

/*
 * free memory created by a call to compitem_getfilename. if a temporary
 * file was created, this may cause it to be deleted. The option argument must
 * be the same as passed to the original compitem_getfilename call.
 */
void compitem_freefilename(COMPITEM item, int option, LPSTR filename);


/* save the composite file
 *
 * if savename is not null, write the item out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR compitem_savecomp(VIEW view, COMPITEM ci, LPSTR savename, int listopts);


/*
 * worker function to write the actual composite file
 *
 * if savename is not null, write the list out to savename using compopts.
 * otherwise, prompt by dialog for filename and options.
 */
LPSTR compitem_writefile(VIEW view, COMPITEM ci, LPSTR savename, int compopts);


/*
 * set the mark state of a file. The only use for this is to retrieve it
 * later using compitem_getmark. The state is a bool.
 */
void compitem_setmark(COMPITEM item, BOOL bMark);


/*
 * return the mark state set by compitem_setmark
 */
BOOL compitem_getmark(COMPITEM item);

/* Tell compitem the paths to be used for autocopy.  Copies left to right */
void compitem_SetCopyPaths(LPSTR LeftPath, LPSTR RightPath);

/* Rescan the file, get new checksums etc */
void compitem_rescan(COMPITEM ci);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\complist.h ===
/*
 *
 * complist -  a list of CompItems
 *
 * build a list of CompItems from various sources. That is to say, build
 * two corresponding lists of filenames (DIRLISTs) and then build a list
 * of CompItems, with one CompItem for each pair of files whose names
 * match, and one CompItem for each unmatched name.
 *
 * when building the complist, a view handle can be given. If this is non-null,
 * the CompList will register with the view (calling view_setcomplist), and
 * will inform the view of each compitem added, during the build
 * process (so that the user can be kept up to date during a lengthy scan).
 *
 * We can return a handle to this list of CompItems on demand.
 *
 * The CompList owns the DIRLISTs and the list of CompItems. If you delete
 * the CompList, you delete all of these.
 */


/* view.h includes the term COMPLIST: we need to use the term VIEW.
 * Alas MIPS doesn't allow duplicate definitions, even harmless ones,
 * so we need to play games.  Whoever declares it first does
 * the real declares and the second one gets no-ops.
 * We don't care what a VIEW  is. Whatever you give us, we will
 * pass to the view_setcomplist function and view_newitem, and that is all.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST


/*
 * build a complist by putting up two dialogs to allow the user to
 * select two files. This will build a Complist with one CompItem (even
 * if the names don't match).
 */
COMPLIST complist_filedialog(VIEW view);

/*
 * build a complist by putting up a dialog in which the user can specify
 * two directories. The directories will then be scanned and a CompItem
 * added to the list for each pair of names that match, and one for each
 * unmatched name
 */
COMPLIST complist_dirdialog(VIEW view);

/* build a complist by putting up a dialog in which the user can
 * specify a remote checksum server name as well as a local and remote
 * directory path.
 *
 * if server is not null, puts up dialog. otherwise uses args as
 * server, remote and local paths
 */
COMPLIST complist_remote(LPSTR server, LPSTR remote, LPSTR local, VIEW view,
                         BOOL fDeep);

/* build a complist from the two pathnames provided */
COMPLIST complist_args(LPSTR path1, LPSTR path2, VIEW view, BOOL fDeep);


/* build/append a complist from the two pathnames provided (either or both is
 * allowed to be null).
 */
void complist_append(COMPLIST *pcl, LPCSTR path1, LPCSTR path2, int *psequence);
BOOL complist_appendfinished(COMPLIST *pcl, LPCSTR pszLeft, LPCSTR pszRight, VIEW view);



/* delete a complist and all associated CompItems and DIRLISTs. Note this
 * does not delete any VIEW - the VIEW owns the COMPLIST and not the other
 * way around.
 */
void complist_delete(COMPLIST cl);

/*
 * get the handle to the list of COMPITEMs. The list continues to be
 * owned by the COMPLIST, so don't delete except by calling complist_delete.
 */
LIST complist_getitems(COMPLIST cl);


/* save the list of files as a series of lines to a file. query the user
 * for the name of the file to write, and the states of lines to be
 * included.
 *
 * if savename is not null, write the list out to savename using listopts.
 * otherwise, prompt by dialog for filename and options.
 */
void complist_savelist(COMPLIST cl, LPSTR savename, UINT listopts);


/*
 * get the description of this complist - a name in the form %s : %s with
 * the dir_getrootdescription() for each side.
 */
LPSTR complist_getdescription(COMPLIST cl);

/* free up memory allocated in a call to complist_getdescription() */
void complist_freedescription(COMPLIST cl, LPSTR path);


/*
 * copy files to a new directory newroot. if newroot is NULL, query the user
 * via a dialog to get the new dir name and options.
 *
 * options are either COPY_FROMLEFT or COPY_FROMRIGHT (indicating which
 * tree is to be the source of the files, plus any or all of
 * INCLUDE_SAME, INCLUDE_DIFFER and INCLUDE_LEFT (INCLUDE_LEFT
 * and INCLUDE_RIGHT are treated the same here since the COPY_FROM* option
 * indicates which side to copy from).
 */

/* option flags */
#define COPY_FROMLEFT       0x100           /* copy files from left tree */
#define COPY_FROMRIGHT      0x200           /* copy files from right tree */
#define COPY_HITREADONLY    0x400           /* overwrite read only files */

void complist_copyfiles(COMPLIST cl, LPSTR newroot, UINT options);


/* return time last operation took in milliseconds */
DWORD complist_querytime(void);


/*
 * complist_togglemark
 *
 * each compitem has a BOOL mark state. This function inverts the value of
 * this state for each compitem in the list.
 */
void complist_togglemark(COMPLIST cl);


/*
 * complist_itemcount
 *
 * return the number of items in the list
 */
UINT
complist_itemcount(COMPLIST cl);


/*
 * query the user for a pattern to match.
 * all compitems with this pattern in their tag string will be
 * marked (the mark state will be set to TRUE);
 *
 * returns TRUE if any states changed
 */
BOOL complist_markpattern(COMPLIST cl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\file.c ===
/*
 * file.c
 *
 * an object representing a file and the lines of text it contains.
 *
 * a FILEDATA object is initialised with a DIRITEM handle from which it
 * can get a filename. It knows how to supply a list of LINE handles for the
 * lines of text in the file.
 *
 * The file is read into memory optionally on creation of the FILEDATA object:
 * otherwise, at the first call to file_getlinelist. It can be discarded
 * by calling file_discardlines: in this case, it will be re-read next time
 * file_getlinelist is called.
 *
 * calling file_reset will cause line_reset to be called for all lines
 * in the list. This clears any links and forces a recalc of line checksums.
 *
 * we allocate all memory from a gmem* heap hHeap, assumed to be declared and
 * initialised elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include "windiff.h"
#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "wdiffrc.h"

extern HANDLE hHeap;

/*
 * we return FILEDATA handles: these are pointers to a
 * filedata struct defined here.
 */
struct filedata {

    DIRITEM diritem;        /* handle to file name information */
    LIST lines;             /* NULL if lines not read in */

    BOOL fUnicode;
};


void file_readlines(FILEDATA fd);

/*-- external functions ---------------------------------------------- */

/*
 * create a new filedata, given the DIRITEM handle which will give us
 * the file name. If bRead is TRUE, read the file into memory.
 */
FILEDATA
file_new(DIRITEM fiName, BOOL bRead)
{
    FILEDATA fd;

    fd = (FILEDATA) gmem_get(hHeap, sizeof(struct filedata));
    if (fd == NULL) {
        return(NULL);
    }

    fd->diritem = fiName;
    fd->lines = NULL;

    if (bRead) {
        file_readlines(fd);
    }

    return(fd);
}

/*
 * return a handle to the DIRITEM used to create this FILEDATA
 */
DIRITEM
file_getdiritem(FILEDATA fd)
{
    if (fd == NULL) {
        return(NULL);
    }

    return(fd->diritem);
}


/*
 * delete a filedata and its associated list of lines. note that the diritem
 * is not deleted (this is owned by the DIRLIST, and will be deleted
 * when the DIRLIST is deleted)
 */
void
file_delete(FILEDATA fd)
{
    if (fd == NULL) {
        return;
    }

    /* throw away the line list, if there is one */
    file_discardlines(fd);

    gmem_free(hHeap, (LPSTR) fd, sizeof(struct filedata));
}

/*
 * return a handle to a list of lines in this file. the items in the
 * list are LINE handles.
 *
 * the first call to this function will cause the file to be read into
 * memory if bRead was FALSE on the call to file_new, or if file_discardlines
 * has since been called.
 *
 * the list of lines returned should not be deleted except by calls to
 * file_delete or file_discardlines.
 */
LIST
file_getlinelist(FILEDATA fd)
{
    if (fd == NULL) {
        return NULL;
    }

    if (fd->lines == NULL) {
        file_readlines(fd);
    }
    return(fd->lines);
}


/*
 * discard the list of lines associated with a file. this will cause
 * the file to be re-read next time file_getlinelist is called.
 */
void
file_discardlines(FILEDATA fd)
{
    LINE line;

    if (fd == NULL) {
        return;
    }

    if (fd->lines != NULL) {

        /* clear each line to free any memory associated
         * with them, then discard the entire list
         */
        List_TRAVERSE(fd->lines, line) {
            line_delete(line);
        }
        List_Destroy(&fd->lines);
    }

    /* this is probably done in List_Destroy, but better do it anyway*/
    fd->lines = NULL;
}


/*
 * force a reset of each line in the list. line_reset discards any
 * links between lines, and any hashcode information. This would be used if
 * the compare options or hashcode options have changed.
 */
void
file_reset(FILEDATA fd)
{
    LINE line;

    if (fd == NULL) {
        return;
    }

    if (fd->lines != NULL) {

        List_TRAVERSE(fd->lines, line)  {
            line_reset(line);
        }
    }
}

/*
 * return a checksum identical to one obtained through dir_getchecksum
 * This will recalculate it for local files, but not for remote ones.
 * Remote ones would give checksum zero if we didn't have one.
 */
DWORD
file_checksum(FILEDATA fd)
{
    return(dir_getchecksum(fd->diritem));
}


/*
 * Retrieve the checksum that we have for this file, valid or not.
 * Indicate in bValid whether it is actually valid or not.
 * Do NOT recalculate it or make any new attempt to read the file!
 */
DWORD file_retrievechecksum(FILEDATA fd, BOOL * bValid)
{
    if (dir_validchecksum(fd->diritem)) {
        *bValid = TRUE;
        return dir_getchecksum(fd->diritem);
    } else {
        *bValid = FALSE;
        return 0;
    }
} /* file_retrievechecksum */


/* retrieve the filetime for the file */
FILETIME file_GetTime(FILEDATA fd)
{  return dir_GetFileTime(fd->diritem);
}

/* --- internal functions -------------------------------------------*/

/*
 * read the file into a list of lines.
 *
 * we use the buffered read functions to read a block at a time, and
 * return us a pointer to a line within the block. The line we are
 * pointed to is not null terminated. from this we do a line_new: this
 * will make a copy of the text (since we want to re-use the buffer), and
 * will null-terminate its copy.
 *
 * we also give each line a number, starting at one.
 */
void
file_readlines(FILEDATA fd)
{
    LPSTR textp;
    LPWSTR pwzText;
    int cwch;
    HANDLE fh;
    FILEBUFFER fbuf;
    int linelen;
    int linenr = 1;
    HCURSOR hcurs;

    hcurs = SetCursor(LoadCursor(NULL, IDC_WAIT));

    /* open the file */
    fh = dir_openfile(fd->diritem);

    if (fh == INVALID_HANDLE_VALUE) {
        TRACE_ERROR(LoadRcString(IDS_ERR_OPENING_FILE), FALSE);
        SetCursor(hcurs);
        return;
    }
    /* initialise the file buffering */
    fbuf = readfile_new(fh, &fd->fUnicode);

    if (fbuf)
    {
        /* make an empty list for the files */
        fd->lines = List_Create();

        while ( (textp = readfile_next(fbuf, &linelen, &pwzText, &cwch)) != NULL) {
            if (linelen>0) { /* readfile failure gives linelen==-1 */
                line_new(textp, linelen, pwzText, cwch, linenr++, fd->lines);
            } else {
                line_new("!! <unreadable> !!", 20, NULL, 0, linenr++,fd->lines);
                break;
            }


        }

        /* close filehandle and free buffer */
        readfile_delete(fbuf);
    }

    dir_closefile(fd->diritem, fh);

    SetCursor(hcurs);
}

BOOL
file_IsUnicode(FILEDATA fd)
{
    return fd->fUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\file.h ===
/*
 * FILEDATA - represents a file name and its contents.
 *
 * The file name is held in the form of a DIRITEM which is managed
 * by SCANDIR (see scandir.h).  A DIRITEM must be supplied to initialise
 * a FILEDATA.
 *
 * On demand, the FILEDATA will return a handle to a list of lines.
 * These are the lines in the file in the form of LINE handles (see line.h)
 * this list can be discarded by a call to file_discardlines, or file_delete.
 */

/* handle to filedata */
typedef struct filedata FAR * FILEDATA;

/*
 * make a new FILEDATA, based on a DIRITEM. the filedata will retain
 * the diritem handle for use in fetching filenames and handles.
 *
 * if the bRead is set, the file will be read into memory. If not, this
 * will be done during the first call to file_getlines
 */
FILEDATA file_new(DIRITEM fiName, BOOL bRead);

/*
 * return a handle to the DIRITEM used to create this FILEDATA
 */
DIRITEM file_getdiritem(FILEDATA fi);


/* delete a FILEDATA and its associated list of LINEs. note that the
 * DIRITEM is NOT deleted.
 */
void file_delete(FILEDATA fi);

/*
 * return a list of the lines in the file. This is a standard list that can
 * be traversed with the list functions. The list should only be deleted
 * by calls to file_delete or file_discardlines for the owning FILEDATA.
 * The items in the list are LINE handles.
 *
 * this call will cause the file to be read into memory if necessary (if
 * the lines had been discarded using file_discardlines, or if bRead were
 * false in the initial call to file_new
 */
LIST file_getlinelist(FILEDATA fi);

/*
 * free up the line list and any associated memory until it is needed again.
 */
void file_discardlines(FILEDATA fi);

/*
 * force all lines in the line list to reset their hashcodes and any line
 * links. Does not cause the file to be re-read.
 */
void file_reset(FILEDATA fi);

/*
 * give me a checksum for the file. whether or not actually calculated by
 * dir_getchecksum(), it will be the same checksum as if it were.
 */
DWORD file_checksum(FILEDATA fi);

/*
 * Retrieve the checksum that we have for this file, valid or not.
 * Indicate in bValid whether it is actually valid or not.
 * Do NOT recalculate it or make any new attempt to read the file!
 */
DWORD file_retrievechecksum(FILEDATA fi, BOOL * bValid);

/* returns TRUE if the file is unicode */
BOOL file_IsUnicode(FILEDATA fd);

/* for 16 bit there is a definition of FILETIME in scandir.h
   scandir.h is already needed for other things in this header.
*/

/* retrieve the filetime for the file */
FILETIME file_GetTime(FILEDATA fd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\findgoto.c ===
/*
 * findgoto.c
 *
 * Michael Arnquist, June 99
 */

#include <precomp.h>
#include <table.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"

#include "view.h"
#include "findgoto.h"

extern const CHAR szWinDiff[];
extern VIEW current_view;

static const char szFindSearchDown[]  = "FindSearchDown";
static const char szFindMatchCase[]   = "FindMatchCase";
static const char szFindWholeWord[]   = "FindWholeWord";
static const char szFindStringXX[]    = "FindString%02d";

/*
 * DlgProc for the Find dialog
 *
 */
INT_PTR CALLBACK
FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
    {
    case WM_INITDIALOG:
      {
      char rgchFindString[CCH_FINDSTRING];
      char rgchKey[32];
      int iString = 0;
      const BOOL fDown      = GetProfileInt(APPNAME, szFindSearchDown, 1);
      const BOOL fMatchCase = GetProfileInt(APPNAME, szFindMatchCase, 0);
      const BOOL fWholeWord = GetProfileInt(APPNAME, szFindWholeWord, 0);

      CheckDlgButton(hDlg, ((!fDown) ? IDC_OPT_UP : IDC_OPT_DOWN), BST_CHECKED);
      CheckDlgButton(hDlg, IDC_CHK_MATCHCASE, ((fMatchCase) ? BST_CHECKED : BST_UNCHECKED));
      CheckDlgButton(hDlg, IDC_CHK_WHOLEWORD, ((fWholeWord) ? BST_CHECKED : BST_UNCHECKED));
      SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_RESETCONTENT, 0, 0L);
      SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, EM_LIMITTEXT, CCH_FINDSTRING, 0L);

      for (iString = 0; iString < NUM_FINDSTRINGS; iString++)
        {
        wsprintf(rgchKey, szFindStringXX, iString);
        if ( !GetProfileString(APPNAME, rgchKey, "", rgchFindString, CCH_FINDSTRING)
          || !*rgchFindString)
          {
          break;
          }

        SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_INSERTSTRING, -1, (LPARAM) rgchFindString);
        }

      return TRUE;
      }

    case WM_COMMAND:
      switch (wParam)
        {
        case IDOK:
          {
          char rgchText[CCH_FINDSTRING];
          const BOOL fWholeWord = (IsDlgButtonChecked(hDlg, IDC_CHK_WHOLEWORD) == BST_CHECKED);

          WriteProfileInt(APPNAME, szFindSearchDown, (IsDlgButtonChecked(hDlg, IDC_OPT_DOWN) == BST_CHECKED));
          WriteProfileInt(APPNAME, szFindMatchCase,  (IsDlgButtonChecked(hDlg, IDC_CHK_MATCHCASE) == BST_CHECKED));
          WriteProfileInt(APPNAME, szFindWholeWord,  fWholeWord);

          SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, WM_GETTEXT, CCH_FINDSTRING, (LPARAM) rgchText);
          if (*rgchText)
            {
            const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
            char rgchBuf[CCH_FINDSTRING];
            char rgchKey[32];
            int iRet = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_FINDSTRINGEXACT, -1, (LPARAM) rgchText);
            int iString = 0;

            if (iRet != CB_ERR)
              {
              iString = iRet;

              do
                {
                SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_GETLBTEXT, iString, (LPARAM) rgchBuf);
                if (!My_mbsncmp((PUCHAR) rgchText, (PUCHAR) rgchBuf, CCH_FINDSTRING))
                  {
                  /* delete the string out of its old place */
                  SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_DELETESTRING, iString, 0L);
                  break;
                  }

                iString = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_FINDSTRINGEXACT, iString, (LPARAM) rgchText);
                } while (iString != CB_ERR && iString != iRet);
              }

            /* insert the new string at index zero */
            SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_INSERTSTRING, 0, (LPARAM) rgchText);

            for (iString = 0; iString < NUM_FINDSTRINGS; iString++)
              {
              *rgchBuf = 0;
              iRet = (int) SendDlgItemMessage(hDlg, IDC_DRD_FINDWHAT, CB_GETLBTEXT, iString, (LPARAM) rgchBuf);
              if (iRet <= 0 || iRet == CB_ERR || !*rgchBuf)
                break;

              wsprintf(rgchKey, szFindStringXX, iString);
              WriteProfileString(APPNAME, rgchKey, rgchBuf);
              }

            /* don't end the dlg if we didn't find a match */
            if (!FindString(hDlg, iCol, rgchText, 0, ((fWholeWord) ? 1 : -1)))
              return TRUE;
            }

          EndDialog(hDlg, wParam);
          return TRUE;
          }

        case IDCANCEL:
          EndDialog(hDlg, wParam);
          return TRUE;
        }
    }

  return FALSE;
}


/*
 * DlgProc for the Go To Line dialog
 *
 */
INT_PTR CALLBACK
GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  switch (message)
    {
    case WM_INITDIALOG:
      /* worth remembering last goto value? */
      SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, EM_LIMITTEXT, CCH_MAXDIGITS, 0L);
      SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, WM_SETTEXT, 0, (LPARAM) "1");
      return TRUE;

    case WM_COMMAND:
      switch (wParam)
        {
        case IDOK:
          {
          const LONG lMax = view_getrowcount(current_view);
          char *pchT = NULL;
          int cNumeric = 0;
          char rgchBuf[256];

          SendDlgItemMessage(hDlg, IDC_EDT_GOTOLINE, WM_GETTEXT, CCH_MAXDIGITS + 1, (LPARAM) rgchBuf);

          /* eat leading whitespace */
          for (pchT = rgchBuf; *pchT && isspace(*pchT); pchT = CharNext(pchT))
            NULL;

          for (NULL; *pchT; pchT = CharNext(pchT))
            {
            if (IsDBCSLeadByte(*pchT) || !isdigit(*pchT))
              break;
            
            cNumeric++;
            }

          /* if we didn't reach the end of the string, we have an invalid numeric string */
          if (!cNumeric)
            {
            MessageBox(hDlg, LoadRcString(IDS_GOTOLINE_INVALIDSTRING), szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
            return TRUE;
            }

          /* terminate the string after the numeric chars */
          *pchT = 0;

          /* go find the string */
          if (!FindString(hDlg, 0, rgchBuf, 1, 1))
            return TRUE;

          EndDialog(hDlg, wParam);
          return TRUE;
          }

        case IDCANCEL:
          EndDialog(hDlg, wParam);
          return TRUE;
        }
    }

  return FALSE;
}


/*
 * Cover function for string search
 *
 */
BOOL
FindString(HWND hwndParent, LONG iCol, const char *pszFind, int nSearchDirection, int nWholeWord)
{
  char rgchText[CCH_FINDSTRING];
  char rgchKey[32];
  BOOL fSearchDown = TRUE;    /* default is to search forward (down) */
  const BOOL fMatchCase = GetProfileInt(APPNAME, szFindMatchCase, 0);
  BOOL fWholeWord = FALSE;

  if (!nWholeWord)
    {
    fWholeWord = (BOOL) GetProfileInt(APPNAME, szFindWholeWord, 0);
    }
  else
    {
    fWholeWord = (nWholeWord == 1);
    }

  if (nSearchDirection < 0)   /* search backward (up) */
    {
    fSearchDown = FALSE;
    }
  else if (!nSearchDirection) /* look it up in the registry */
    {
    fSearchDown = GetProfileInt(APPNAME, szFindSearchDown, 1);
    }

  *rgchText = 0;
  if (pszFind)
    {
    /* use the arg string */
    My_mbsncpy((PUCHAR) rgchText, (PUCHAR) pszFind, CCH_FINDSTRING);
    }
  else
    {
    /* look up last find string in registry */
    wsprintf(rgchKey, szFindStringXX, 0);
    if (!GetProfileString(APPNAME, rgchKey, "", rgchText, CCH_FINDSTRING))
      *rgchText = 0;
    }

  if ( !*rgchText
    || !view_findstring(current_view, iCol, rgchText, fSearchDown, fMatchCase, fWholeWord))
    {
    char rgchMsg[CCH_FINDSTRING * 2];
    wsprintf(rgchMsg, LoadRcString(IDS_FIND_NOTFOUND), rgchText);
    MessageBox(hwndParent, rgchMsg, szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
    return FALSE;
    }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\line.h ===
/*
 * line.h
 *
 * interface definition for the LINE data type.
 *
 * a LINE is a data type representing a line of ansi text along with a
 * line number.
 * a LINE can establish and maintain a link to another line known to be
 * the same.
 *
 * The LINE maintains a copy of the text, a line number associated with it,
 * a handle to another linked line, and a hashcode representing the line.
 *
 * Comparisons between LINEs take note of the global BOOL option flag
 * ignore_blanks. If this is TRUE, all spaces and tabs will be ignored during
 * the process of comparing two LINEs. If this option changes, each line
 * will have to be told by calling line_reset.
 */

/* a handle to a line looks like this. neither you nor your compiler needs
 * to know what the structure itself looks like.
 */
typedef struct fileline FAR * LINE;


/*
 * create a new line. space is allocated somewhere in the line object
 * for a null-terminated copy of the text passed in.
 *
 * the line passed in need not be null-terminated (the length of the line
 * is one argument) The copy made will be null-terminated.
 *
 * returns NULL if failed to create the line.
 *
 * The line number can be any value you wish to associate with the line.
 *
 * If the list parameter is non-null, the LINE data will be allocated at
 * the end of the list (a List_NewLast operation will be done). if list is
 * null, the memory will be allocated from gmem_get(hHeap). This also affects
 * the behaviour of line_delete
 *
 * call line_delete to free up memory associated with this line.
 */
LINE line_new(LPSTR text, int linelength, LPWSTR pwzText, int cwchText, UINT linenr, LIST list);



/*
 * discard a line. free up all memory associated with it.
 *
 * if the line was allocated on a list (list argument to line_new was non-null),
 * the associated memory will be freed, but the LINE itself will not be.
 * Otherwise, the line will freed as well.
 */
void line_delete(LINE line);


/*
 * reset: discard existing hashcode and linked-line information, since
 * the ignore_blanks option has changed.
 */
void line_reset(LINE line);

/* test if two lines are alike (they have the same text). Takes note of
 * ignore_blanks in its comparison. Does not take any note of the line numbers
 * associated with each line. Returns TRUE if they are the same.
 */
BOOL line_compare(LINE line1, LINE line2);

/* try to link two lines together. Tests the lines to see if they are
 * alike, and if so, establishes a link between them and returns TRUE.
 * returns FALSE if they are not the same, or if either of them are already
 * linked (a LINE can only have one linked line, and it must be mutual).
 */
BOOL line_link(LINE line1, LINE line2);

/*
 * return a pointer to the text of this line. You get a pointer to the
 * LINE's own copy, so don't free it or extend it. If you modify it,
 * you will need to call line_reset before any line_compares or line_links.
 */
LPSTR line_gettext(LINE line);
LPWSTR line_gettextW(LINE line);

/*
 * return the length of the line in characters, expanding tabs. The tabstops
 * parameter determines the tabstop width to be used.
 *
 * This can be used to calculated
 * display space needed, but note that the line returned by
 * line_gettext() will still have any tabs unexpanded.
 */
int line_gettabbedlength(LINE line, int tabstops);

/*
 * each line has a hashcode associated with it. This is a 32-bit code
 * generated using the hashstring function. It is calculated only once
 * for each line (and thus calls to this function are efficient). To force
 * a recalculation, call line_reset.
 */
DWORD line_gethashcode(LINE line);

/* get the effective text length, ignoring blanks */
int line_gettextlen(LINE line);

/*
 * return the handle for the line that is linked to this line, or NULL if
 * there isn't one. Lines are either not linked at all, or are mutually
 * linked such that
 *              line_getlink( line_getlink(myline)) == myline;
 */
LINE line_getlink(LINE line);

/* return the line number associated with a line. This can be any 32-bit
 * number that was associated with the line when it was created
 */
UINT line_getlinenr(LINE line);

/* return TRUE iff line is blank.  NULL => return FALSE */
BOOL line_isblank(LINE line);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\findgoto.h ===
/*
 *
 * FINDGOTO
 *
 */


#ifndef __FINDGOTO_H__
#define __FINDGOTO_H__


/*
 * defines
 *
 */
#define CCH_MAXDIGITS     10
#define CCH_FINDSTRING    MAX_PATH
#define NUM_FINDSTRINGS   16      /* indexed from 0 to 15 */

/*
 * functions
 *
 */
INT_PTR CALLBACK FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL FindString(HWND hwndParent, LONG iCol, const char *pszFind, int nSearchDirection, int nWholeWord);


#endif //__FINDGOTO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\precomp.h ===
#include <windows.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <dos.h>
#include <direct.h>
#include <commdlg.h>
#include <gutils.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\line.c ===
/*
 * line.c
 *
 * data type representing a string of ascii text along with a line number.
 * a LINE can compare itself to another line, and maintain a link if the
 * lines are similar. A line can also generate a hashcode for the line.
 *
 * Comparisons between lines take note of the global option flag
 * ignore_blanks, defined elsewhere. If this is true, we ignore
 * differences in spaces and tabs when comparing lines, and when
 * generating hashcodes.
 *
 * Links and hashcodes are only generated once. to clear the link and
 * force re-generation of the hashcode (eg after changing ignore_blanks)
 * call line_reset.
 *
 * Lines can be allocated on a list. If a null list handle is passed, the
 * line will be allocated using gmem_get() from the hHeap defined and
 * initialised elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include "windiff.h"    /* defines hHeap and ignore_blanks */
#include "list.h"
#include "line.h"

#define IS_BLANK(c) \
    (((c) == ' ') || ((c) == '\t') || ((c) == '\r'))

/*
 * a LINE handle is a pointer to a struct fileline, defined here
 */
struct fileline {

    UINT flags;     /* see below */

    LPSTR text;     /* null-terminated copy of line text */
    DWORD hash;     /* hashcode for line */
    LINE link;      /* handle for linked line */
    UINT linenr;    /* line number (any arbitrary value) */

    LPWSTR pwzText; /* null-terminated original unicode text */
};

/* flag values (or-ed) */
#define LF_DISCARD      1       /* if true, alloced from gmem heap */
#define LF_HASHVALID    2       /* if true, hashcode need not be recalced */


/*
 * create a new line. make a copy of the text.
 *
 * if the list is non-null, allocate on the list. if null, alloc from
 * gmem_get.
 */
LINE
line_new(LPSTR text, int linelength, LPWSTR pwzText, int cwchText, UINT linenr, LIST list)
{
    LINE line;
    int cch = 0;

    /* alloc a line. from the list if there is a list */
    if (list) {
        line = List_NewLast(list, sizeof(struct fileline));
        if (line == NULL) {
            return(NULL);
        }
        line->flags = 0;
    } else {
        line = (LINE) gmem_get(hHeap, sizeof(struct fileline));
        if (line == NULL) {
            return(NULL);
        }
        line->flags = LF_DISCARD;
    }

    /* alloc space for the text. remember the null character */
    /* also add cr/nl pair if absent for composite file */
    cch = (text[linelength - 1] == '\n') ? 1 : 3;
    line->text = gmem_get(hHeap, linelength + cch);
    My_mbsncpy(line->text, text, linelength);
    if (cch == 3) {
        line->text[linelength++] = '\r';
        line->text[linelength++] = '\n';
    }
    line->text[linelength] = '\0';

    line->pwzText = 0;
    if (pwzText)
    {
        /* alloc space for the unicode text. remember the null character */
        /* also add cr/nl pair if absent for composite file */
        cch = (pwzText[cwchText - 1] == '\n') ? 1 : 3;
        line->pwzText = (WCHAR*)gmem_get(hHeap, (cwchText + cch) * sizeof(*pwzText));
        wcsncpy(line->pwzText, pwzText, cwchText);
        if (cch == 3) {
            line->pwzText[cwchText++] = '\r';
            line->pwzText[cwchText++] = '\n';
        }
        line->pwzText[cwchText] = '\0';
    }

    line->link = NULL;
    line->linenr = linenr;

    return(line);
}

/*
 * delete a line. free up all associated memory and if the line
 * was not alloc-ed from a list, free up the line struct itself
 */
void
line_delete(LINE line)
{
    if (line == NULL) {
        return;
    }

    /* free up text space */
    gmem_free(hHeap, line->text, lstrlen(line->text)+1);

    /* free up line itself only if not on list */
    if (line->flags & LF_DISCARD) {
        gmem_free(hHeap, (LPSTR) line, sizeof(struct fileline));
    }
}

/*
 * clear the link and force recalc of the hash code.
 */
void
line_reset(LINE line)
{
    if (line == NULL) {
        return;
    }

    line->link = NULL;

    line->flags &= ~LF_HASHVALID;
}


/* return a pointer to the line text */
LPSTR
line_gettext(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return (line->text);
}

/* return a pointer to the line text */
LPWSTR
line_gettextW(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return (line->pwzText);
}

/* get the effective text length, ignoring blanks */
int line_gettextlen(LINE line)
{
    int sum = 0;
    LPSTR string = line->text;

    while (*string != '\0') {

        if (ignore_blanks) {
            while (IS_BLANK(*string)) {
                string++;
            }
        }
        if(IsDBCSLeadByte((BYTE)*string)) {
            ++sum;
            ++string;
        }
        ++sum;
        ++string;
    }
    return(sum);
}


/*
 * line_gettabbedlength
 *
 * return length of line in characters, expanding tabs. useful
 * for display-space calculations.
 */
int
line_gettabbedlength(LINE line, int tabstops)
{
    int length;
    LPSTR chp;

    if (line == NULL) {
        return(0);
    }

    for (length = 0, chp = line->text; *chp != '\0'; chp++) {
        if (*chp == '\t') {
            length = (length + tabstops) / tabstops * tabstops;
        } else {
            if (IsDBCSLeadByte(*chp)) {
                chp++;
                length++;
            }
            length++;
        }
    }
    return(length);
}


/* return the hashcode for this line */
DWORD
line_gethashcode(LINE line)
{
    if (line == NULL) {
        return(0);
    }

    if (! (line->flags & LF_HASHVALID)) {


        /* hashcode needs to be recalced */
        line->hash = hash_string(line->text, ignore_blanks);
        line->flags |= LF_HASHVALID;
    }
    return (line->hash);
}

/* return the handle for the line that is linked to this line (the
 * result of a successful line_link() operation). This line is
 * identical in text to the linked line (allowing for ignore_blanks).
 */
LINE
line_getlink(LINE line)
{
    if (line == NULL) {
        return(NULL);
    }

    return(line->link);
}

/* return the line number associated with this line */
UINT
line_getlinenr(LINE line)
{
    if (line == NULL) {
        return(0);
    }

    return(line->linenr);
}

/* compare two lines. return TRUE if they are the same. uses
 * ignore_blanks to determine whether to ignore any
 * spaces/tabs in the comparison.
 */
BOOL
line_compare(LINE line1, LINE line2)
{
    LPSTR p1, p2;

    /* Assert: At least one of them is not null ??? */

    if ((line1 == NULL) || (line2 == NULL)) {
        /* null line handles do not compare */
        return(FALSE);
    }

    /* check that the hashcodes match */
    if (line_gethashcode(line1) != line_gethashcode(line2)) {
        return(FALSE);
    }

    /* hashcodes match - are the lines really the same ? */
    /* note that this is coupled to gutils\utils.c in definition of blank */
    p1 = line_gettext(line1);
    p2 = line_gettext(line2);
    do {
        if (ignore_blanks) {
            while (IS_BLANK(*p1)) {
                p1 = CharNext(p1);
            }
            while (IS_BLANK(*p2)) {
                p2 = CharNext(p2);
            }
        }
        if (IsDBCSLeadByte(*p1) && *(p1+1) != '\0'
        &&  IsDBCSLeadByte(*p2) && *(p2+1) != '\0') {
            if (*p1 != *p2 || *(p1+1) != *(p2+1)) {
                return(FALSE);
            }
            p1 += 2;
            p2 += 2;
        } else {
            if (*p1 != *p2) {
                return(FALSE);
            }
            p1++;
            p2++;
        }
    } while ( (*p1 != '\0') && (*p2 != '\0'));

    return(TRUE);
}

/*
 * attempt to link two lines. return TRUE if succesful.
 *
 * this will fail if either line is NULL, or already linked, or if
 * they differ.
 */
BOOL
line_link(LINE line1, LINE line2)
{
    if ( (line1 == NULL) || (line2 == NULL)) {
        return(FALSE);
    }

    if ( (line1->link != NULL) || (line2->link != NULL)) {
        return(FALSE);
    }

    if (line_compare(line1, line2)) {
        line1->link = line2;
        line2->link = line1;
        return(TRUE);
    } else {
        return(FALSE);
    }
}


/* return TRUE iff line is blank.  NULL => return FALSE */
BOOL line_isblank(LINE line)
{
    return line!=NULL && utils_isblank(line->text);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\profile.h ===
/*
 * utility functions to read and write values to the profile,
 * using win.ini for Win16 or HKEY_CURRENT_USER\software\microsoft\windiff\...
 * in the registry for Win32
 */

#ifndef _PROFILE_REG_H
#define _PROFILE_REG_H

#define MMPROFILECACHE 0  // Set to 1 to cache keys, 0 otherwise
#define USESTRINGSALSO 1

#ifndef _WIN32

#define mmGetProfileIntA(app, value, default) \
          GetProfileInt(app, value, default)

#define mmWriteProfileString(appname, valuename, pData) \
          WriteProfileString(appname, valuename, pData)

#define mmGetProfileString(appname, valuename, pDefault, pResult, cbResult) \
          GetProfileString(appname, valuename, pDefault, pResult, cbResult)

#define CloseKeys()

#else


/*
 * read a UINT from the profile, or return default if
 * not found.
 */
UINT mmGetProfileIntA(LPCSTR appname, LPCSTR valuename, INT uDefault);

/*
 * read a string from the profile into pResult.
 * result is number of characters written into pResult
 */
DWORD mmGetProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pDefault,
                    LPTSTR pResult, int cbResult
);

/*
 * write a string/integer to the profile
 */
BOOL mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData);

BOOL mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT value);

UINT mmGetProfileInt(LPCTSTR appname, LPCTSTR valuename, INT value);

#undef WriteProfileString
#undef GetProfileString
#undef GetProfileInt

#define WriteProfileString  mmWriteProfileString
#define WriteProfileInt     mmWriteProfileInt
#define GetProfileString    mmGetProfileString
#define GetProfileInt       mmGetProfileInt


#if MMPROFILECACHE
VOID CloseKeys(VOID);
#else
#define CloseKeys()
#endif

/*
 * convert an Ansi string to Wide characters
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,   // out: wide char buffer to convert into
   LPCSTR  lpsz,   // in: ansi string to convert from
   UINT   nChars); // in: count of characters in each buffer

/*
 * convert a Wide char string to Ansi
 */
LPSTR mmWideToAnsi (
   LPSTR  lpsz,    // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT   nChars); // in: count of characters (not bytes!)

#if !defined NUMELMS
 #define NUMELMS(aa) (sizeof(aa)/sizeof((aa)[0]))
#endif

#endif
#endif // _PROFILE_REG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\profile.c ===
/*
 * MSVFW32: (Compman, drawdib and video)
 *
 * profile.c
 *
 * win32/win16 utility functions to read and write profile items
 * for VFW
 *
 * JMK: added functions to convert from Ansi to Unicode & back
 *
 * WARNING:  This code caches open registry keys.  When a profile call
 * is made the code looks for an atom to correspond to the appname supplied.
 * If an atom is found, then the table of cached registry keys is searched
 * for the matching registry handle.  If the handle exists, it is used.
 * No handle would mean that someone else registered an atom using this
 * name, so we proceed to the next step.
 *
 * No atom found, or no matching registry handle, means that we have to
 * open a registry key.  If successful, and there is space in the cache,
 * we AddAtom the appname, and cache the registry key before returning to
 * the caller.
 */

#include <precomp.h>
//#include <windowsx.h>

#ifdef _WIN32
// This whole file is only used for 32 bit code.  It is the implementation
// that allows Win GetProfilexxx calls to use the registry.
#include "profile.key"

#include "mmsystem.h"

#include "profile.h"

#ifdef USESTRINGSALSO
#include <stdlib.h>/* for atoi */
#endif

#if MMPROFILECACHE

#ifdef DEBUG
#define KEYSCACHED 3 // Normally DrawDib, Debug and ??
#else
#define KEYSCACHED 2 // Normally DrawDib and ??
#endif

HKEY   ahkey[KEYSCACHED];
ATOM   akeyatoms[KEYSCACHED];
UINT   keyscached = 0;

#else
#define KEYSCACHED 0
#endif


static HKEY GetKeyA(LPCSTR appname, BOOL * closekey, BOOL fCreate)
{
    HKEY key = 0;
    char achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomA(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF2(("Found existing key for %s\n", appname));
                return ahkey[n];
            }
        }
    }
    DPF2(("No key found for %s", appname));
#endif

    lstrcpyA(achName, KEYNAMEA);
    // Use registry under "CURRENT_USER\Software\Microsoft\Windiff\"
    //lstrcatA(achName, appname);

    if ((!fCreate && RegOpenKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyA(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if ((keyscached < KEYSCACHED)
	  && (atm = AddAtomA(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF1(("Adding key %s to cache array in position %d\n", appname, keyscached));
            ++keyscached;
        } else {
            DPF2(("Not adding key %s to cache array\n", appname));
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}

#ifdef UNICODE
static HKEY GetKeyW(LPCWSTR appname, BOOL * closekey, BOOL fCreate) {

    HKEY key = 0;
    WCHAR achName[MAX_PATH];
#if !MMPROFILECACHE
    *closekey = TRUE;
#else
    UINT n;
    ATOM atm;

    *closekey = FALSE;
    //
    // See if we have already used this key
    //
    atm = FindAtomW(appname);

    if (atm != 0) {
	// Atom exists... search the table for it.
        for (n=0; n<keyscached; ++n) {
            if (akeyatoms[n] == atm) {
                DPF2(("(W)Found existing key for %ls\n", appname));
                return ahkey[n];
            }
        }
    }
    DPF2(("(W)No key found for %ls\n", appname));
#endif

    lstrcpyW(achName, KEYNAME );
    lstrcatW(achName, appname);

    if ((!fCreate && RegOpenKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)
        || (fCreate && RegCreateKeyW(ROOTKEY, achName, &key) == ERROR_SUCCESS)) {
#if MMPROFILECACHE
        if (keyscached < KEYSCACHED
	  && (atm = AddAtomW(appname))) {
            // Add this key to the cache array
            akeyatoms[keyscached] = atm;
            ahkey[keyscached] = key;
            DPF1(("Adding key %ls to cache array in position %d\n", appname, keyscached));
            ++keyscached;
        } else {
            DPF2(("Not adding key to cache array\n"));
            *closekey = TRUE;
        }
#endif
    }

    return(key);
}
#define GetKey GetKeyW
#else
#define GetKey GetKeyA
#endif // UNICODE

/*
 * read a UINT from the profile, or return default if
 * not found.
 */
#ifdef _WIN32
UINT
mmGetProfileInt(LPCSTR appname, LPCSTR valuename, INT uDefault)
{
    DWORD dwType;
    INT value = uDefault;
    DWORD dwData;
    int cbData;
    BOOL fCloseKey;

    HKEY key = GetKeyA(appname, &fCloseKey, FALSE);

    if (key) {

        cbData = sizeof(dwData);
        if (RegQueryValueExA(
            key,
            (LPSTR)valuename,
            NULL,
            &dwType,
            (PBYTE) &dwData,
            &cbData) == ERROR_SUCCESS) {
            if (dwType == REG_DWORD || dwType == REG_BINARY) {
                value = (INT)dwData;
#ifdef USESTRINGSALSO
            } else if (dwType == REG_SZ) {
		value = atoi((LPSTR) &dwData);
#endif
	    }
	}

        // close open key open if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    return((UINT)value);
}
#endif

/*
 * read a string from the profile into pResult.
 * result is number of bytes written into pResult
 */
#ifdef _WIN32
DWORD
mmGetProfileString(
    LPCTSTR appname,
    LPCTSTR valuename,
    LPCTSTR pDefault,
    LPTSTR pResult,
    int cbResult
)
{
    DWORD dwType;
    BOOL fCloseKey;

    HKEY key = GetKey(appname, &fCloseKey, FALSE);

    if (key) {

        cbResult = cbResult * sizeof(TCHAR);
        if (RegQueryValueEx(
            key,
            (LPTSTR)valuename,
            NULL,
            &dwType,
            (LPBYTE)pResult,
            &cbResult) == ERROR_SUCCESS) {

                if (dwType == REG_SZ) {
                    // cbResult is set to the size including null
                    // we return the number of characters

                    // close key if we did not cache it
                    if (fCloseKey) {
                        RegCloseKey(key);
                    }
                    return(cbResult/sizeof(TCHAR) - 1);
                }
        }

        // close open key if we did not cache it
        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    // if we got here, we didn't find it, or it was the wrong type - return
    // the default string
    lstrcpy(pResult, pDefault);
    return(lstrlen(pDefault));
}
#endif


/*
 * write a string to the profile
 */
#ifdef _WIN32
BOOL
mmWriteProfileString(LPCTSTR appname, LPCTSTR valuename, LPCTSTR pData)
{
    BOOL fCloseKey;
    HKEY key = GetKey(appname, &fCloseKey, TRUE);
    BOOL fResult = !(ERROR_SUCCESS);

    if (key) {
        if (pData) {
            fResult = RegSetValueEx(
                key,
                (LPTSTR)valuename,
                0,
                REG_SZ,
                (LPBYTE)pData,
                (lstrlen(pData) + 1) * sizeof(TCHAR)
            );
        } else {
            fResult = RegDeleteValue(
                key,
                (LPTSTR)valuename
            );
        }

        if (fCloseKey) {
            RegCloseKey(key);
        }
    }

    if (ERROR_SUCCESS == fResult) {
        return TRUE;
    } else {
        return FALSE;
    }
}

/*****************************************************************************

 functions to help convert wide characters to multibyte & vv. (using
 functions to control code size...)

 these functions are not needed if we are building 16 bit code

 ****************************************************************************/

/*
 * convert an Ansi string to Unicode
 */
LPWSTR mmAnsiToWide (
   LPWSTR lpwsz,  // out: wide char buffer to convert into
   LPCSTR lpsz,   // in: ansi string to convert from
   UINT   nChars) // in: count of characters in each buffer
{
   MultiByteToWideChar(GetACP(), 0, lpsz, nChars, lpwsz, nChars);
   return lpwsz;
}

/*
 * convert a unicode string to ansi
 */
LPSTR mmWideToAnsi (
   LPSTR   lpsz,   // out: ansi buffer to convert into
   LPCWSTR lpwsz,  // in: wide char buffer to convert from
   UINT    nChars) // in: count of characters (not bytes!)
{
   WideCharToMultiByte(GetACP(), 0, lpwsz, nChars, lpsz, nChars, NULL, NULL);
   return lpsz;
}


/*
 * Close all open registry keys
 */
#if MMPROFILECACHE
VOID CloseKeys()
{
    for (; keyscached--;) {

#ifdef DEBUG
        if (!ahkey[keyscached]) {           //Assertion!
            DPF0(("Closing a null key\n"));
            //DebugBreak();
        }
#endif
        RegCloseKey(ahkey[keyscached]);
        DeleteAtom(akeyatoms[keyscached]);
    }
}

#endif //MMPROFILECACHE


/*
 * write a UINT to the profile, if it is not the
 * same as the default or the value already there
 */
#ifdef _WIN32
BOOL
mmWriteProfileInt(LPCTSTR appname, LPCTSTR valuename, INT Value)
{
    // If we would write the same as already there... return.
    if (mmGetProfileInt(appname, valuename, !Value) == ((UINT)Value)) {
        return TRUE;
    }

    {
        TCHAR achName[MAX_PATH];
        HKEY hkey;

        lstrcpy(achName, KEYNAME);
        // KEYNAME already has the windiff on it. don't do this
        // for consistency with GetKeyA
        //lstrcat(achName, appname);
        if (RegCreateKey(ROOTKEY, achName, &hkey) == ERROR_SUCCESS) {
            RegSetValueEx(
                hkey,
                valuename,
                0,
                REG_DWORD,
                (PBYTE) &Value,
                sizeof(Value)
            );

            RegCloseKey(hkey);
        }
    }
    return TRUE;
}

#endif // _WIN32

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\regexp.c ===
/* $Header: /nw/tony/src/stevie/src/RCS/regexp.c,v 1.5 89/07/07 16:27:11 tony Exp $
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 *
 * regcomp and regexec -- regsub and regerror are elsewhere
 *
 *      Copyright (c) 1986 by University of Toronto.
 *      Written by Henry Spencer.  Not derived from licensed software.
 *
 *      Permission is granted to anyone to use this software for any
 *      purpose on any computer system, and to redistribute it freely,
 *      subject to the following restrictions:
 *
 *      1. The author is not responsible for the consequences of use of
 *              this software, no matter how awful, even if they arise
 *              from defects in it.
 *
 *      2. The origin of this software must not be misrepresented, either
 *              by explicit claim or by omission.
 *
 *      3. Altered versions must be plainly marked as such, and must not
 *              be misrepresented as being the original software.
 *
 * Beware that some of this code is subtly aware of the way operator
 * precedence is structured in regular expressions.  Serious changes in
 * regular-expression syntax might require a total rethink.
 *
 */

#include <precomp.h>
/* #include "env.h" */

#include "regexp.h"

int cstrncmp(char *,char *,int);
char *cstrchr(char *,char);
/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart     char that must begin a match; '\0' if none obvious
 * reganch      is the match anchored (at beginning-of-line only)?
 * regmust      string (pointer into program) that match must include, or NULL
 * regmlen      length of regmust string
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that regcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in regexec() needs it and regcomp() is computing
 * it anyway.
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are:
 */

/* definition   number  opnd?   meaning */
#define END     0       /* no   End of program. */
#define BOL     1       /* no   Match "" at beginning of line. */
#define EOL     2       /* no   Match "" at end of line. */
#define ANY     3       /* no   Match any one character. */
#define ANYOF   4       /* str  Match any character in this string. */
#define ANYBUT  5       /* str  Match any character not in this string. */
#define BRANCH  6       /* node Match this alternative, or the next... */
#define BACK    7       /* no   Match "", "next" ptr points backward. */
#define EXACTLY 8       /* str  Match this string. */
#define NOTHING 9       /* no   Match empty string. */
#define STAR    10      /* node Match this (simple) thing 0 or more times. */
#define PLUS    11      /* node Match this (simple) thing 1 or more times. */
#define OPEN    20      /* no   Mark this point in input as start of #n. */
/*      OPEN+1 is number 1, etc. */
#define CLOSE   30      /* no   Analogous to OPEN. */

/*
 * Opcode notes:
 *
 * BRANCH       The set of branches constituting a single choice are hooked
 *              together with their "next" pointers, since precedence prevents
 *              anything being concatenated to any individual branch.  The
 *              "next" pointer of the last BRANCH in a choice points to the
 *              thing following the whole choice.  This is also where the
 *              final "next" pointer of each individual branch points; each
 *              branch starts with the operand node of a BRANCH node.
 *
 * BACK         Normal "next" pointers all implicitly point forward; BACK
 *              exists to make loop structures possible.
 *
 * STAR,PLUS    '?', and complex '*' and '+', are implemented as circular
 *              BRANCH structures using BACK.  Simple cases (one character
 *              per match) are implemented with STAR and PLUS for speed
 *              and to minimize recursive plunges.
 *
 * OPEN,CLOSE   ...are numbered at compile time.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 */
#define OP(p)   (*(p))
#define NEXT(p) (((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
#define OPERAND(p)      ((p) + 3)

/*
 * See regmagic.h for one further detail of program structure.
 */


/*
 * Utility definitions.
 */
#ifndef CHARBITS
    #define UCHARAT(p)      ((int)*(unsigned char *)(p))
#else
    #define UCHARAT(p)      ((int)*(p)&CHARBITS)
#endif

#define FAIL(m) { regerror(m); return(NULL); }
#define ISMULT(c)       ((c) == '*' || (c) == '+' || (c) == '?')
#define META    "^$.[()|?+*\\"

/*
 * Flags to be passed up and down.
 */
#define HASWIDTH        01      /* Known never to match null string. */
#define SIMPLE          02      /* Simple enough to be STAR/PLUS operand. */
#define SPSTART         04      /* Starts with * or +. */
#define WORST           0       /* Worst case. */

#ifndef ORIGINAL
/*
 * The following supports the ability to ignore case in searches.
 */

    #include <ctype.h>

int reg_ic = 0;                 /* set by callers to ignore case */

/*
 * mkup - convert to upper case IF we're doing caseless compares
 */
    #define mkup(c)         ((reg_ic && islower(c)) ? toupper(c) : (c))

#endif

/*
 * Global work variables for regcomp().
 */
static char *regparse;          /* Input-scan pointer. */
static int regnpar;             /* () count. */
static char regdummy;
static char *regcode;           /* Code-emit pointer; &regdummy = don't. */
static long regsize;            /* Code size. */

/*
 * Forward declarations for regcomp()'s friends.
 */
#ifndef STATIC
    #define STATIC  static
#endif
STATIC char *reg();
STATIC char *regbranch();
STATIC char *regpiece();
STATIC char *regatom();
STATIC char *regnode();
STATIC char *regnext();
STATIC void regc();
STATIC void reginsert();
STATIC void regtail();
STATIC void regoptail();
#ifdef STRCSPN
STATIC int strcspn();
#endif

/*
 - regcomp - compile a regular expression into internal code
 *
 * We can't allocate space until we know how big the compiled form will be,
 * but we can't compile it (and thus know how big it is) until we've got a
 * place to put the code.  So we cheat:  we compile it twice, once with code
 * generation turned off and size counting turned on, and once "for real".
 * This also means that we don't allocate space until we are sure that the
 * thing really will compile successfully, and we never have to move the
 * code and thus invalidate pointers into it.  (Note that it has to be in
 * one piece because free() must be able to free it all.)
 *
 * Beware that the optimization-preparation code in here knows about some
 * of the structure of the compiled regexp.
 */
regexp *
regcomp(char * exp)
{
    register regexp *r;
    register char *scan;
    register char *longest;
    register int len;
    int flags;

    if (exp == NULL)
        FAIL("NULL argument");

    /* First pass: determine size, legality. */
    regparse = exp;
    regnpar = 1;
    regsize = 0L;
    regcode = &regdummy;
    regc(MAGIC);
    if (reg(0, &flags) == NULL)
        return(NULL);

    /* Small enough for pointer-storage convention? */
    if (regsize >= 32767L)          /* Probably could be 65535L. */
        FAIL("regexp too big");

    /* Allocate space. */
    r = (regexp *)malloc(sizeof(regexp) + (unsigned)regsize);
    if (r == NULL)
        FAIL("out of space");

    /* Second pass: emit code. */
    regparse = exp;
    regnpar = 1;
    regcode = r->program;
    regc(MAGIC);
    if (reg(0, &flags) == NULL)
        return(NULL);

    /* Dig out information for optimizations. */
    r->regstart = '\0';     /* Worst-case defaults. */
    r->reganch = 0;
    r->regmust = NULL;
    r->regmlen = 0;
    scan = r->program+1;                    /* First BRANCH. */
    if (OP(regnext(scan)) == END) {         /* Only one top-level choice. */
        scan = OPERAND(scan);

        /* Starting-point info. */
        if (OP(scan) == EXACTLY)
            r->regstart = *OPERAND(scan);
        else if (OP(scan) == BOL)
            r->reganch++;

        /*
         * If there's something expensive in the r.e., find the
         * longest literal string that must appear and make it the
         * regmust.  Resolve ties in favor of later strings, since
         * the regstart check works with the beginning of the r.e.
         * and avoiding duplication strengthens checking.  Not a
         * strong reason, but sufficient in the absence of others.
         */
        if (flags&SPSTART) {
            longest = NULL;
            len = 0;
            for (; scan != NULL; scan = regnext(scan))
                if (OP(scan) == EXACTLY && strlen(OPERAND(scan)) >= (size_t)len) {
                    longest = OPERAND(scan);
                    len = strlen(OPERAND(scan));
                }
            r->regmust = longest;
            r->regmlen = len;
        }
    }

    return(r);
}

/*
 - reg - regular expression, i.e. main body or parenthesized thing
 *
 * Caller must absorb opening parenthesis.
 *
 * Combining parenthesis handling with the base level of regular expression
 * is a trifle forced, but the need to tie the tails of the branches to what
 * follows makes it hard to avoid.
 */
static char *
reg(int paren /* Parenthesized? */, int * flagp)
{
    register char *ret;
    register char *br;
    register char *ender;
    register int parno = 0; /* spurious init to make compiler happy */
    int flags;

    *flagp = HASWIDTH;      /* Tentatively. */

    /* Make an OPEN node, if parenthesized. */
    if (paren) {
        if (regnpar >= NSUBEXP)
            FAIL("too many ()");
        parno = regnpar;
        regnpar++;
        ret = regnode(OPEN+parno);
    } else
        ret = NULL;

    /* Pick up the branches, linking them together. */
    br = regbranch(&flags);
    if (br == NULL)
        return(NULL);
    if (ret != NULL)
        regtail(ret, br);       /* OPEN -> first. */
    else
        ret = br;
    if (!(flags&HASWIDTH))
        *flagp &= ~HASWIDTH;
    *flagp |= flags&SPSTART;
    while (*regparse == '|') {
        regparse++;
        br = regbranch(&flags);
        if (br == NULL)
            return(NULL);
        regtail(ret, br);       /* BRANCH -> BRANCH. */
        if (!(flags&HASWIDTH))
            *flagp &= ~HASWIDTH;
        *flagp |= flags&SPSTART;
    }

    /* Make a closing node, and hook it on the end. */
    ender = regnode((paren) ? CLOSE+parno : END);
    regtail(ret, ender);

    /* Hook the tails of the branches to the closing node. */
    for (br = ret; br != NULL; br = regnext(br))
        regoptail(br, ender);

    /* Check for proper termination. */
    if (paren && *regparse++ != ')') {
        FAIL("unmatched ()");
    } else if (!paren && *regparse != '\0') {
        if (*regparse == ')') {
            FAIL("unmatched ()");
        } else
            FAIL("junk on end");    /* "Can't happen". */
        /* NOTREACHED */
    }

    return(ret);
}

/*
 - regbranch - one alternative of an | operator
 *
 * Implements the concatenation operator.
 */
static char *
regbranch(int * flagp)
{
    register char *ret;
    register char *chain;
    register char *latest;
    int flags;

    *flagp = WORST;         /* Tentatively. */

    ret = regnode(BRANCH);
    chain = NULL;
    while (*regparse != '\0' && *regparse != '|' && *regparse != ')') {
        latest = regpiece(&flags);
        if (latest == NULL)
            return(NULL);
        *flagp |= flags&HASWIDTH;
        if (chain == NULL)      /* First piece. */
            *flagp |= flags&SPSTART;
        else
            regtail(chain, latest);
        chain = latest;
    }
    if (chain == NULL)      /* Loop ran zero times. */
        (void) regnode(NOTHING);

    return(ret);
}

/*
 - regpiece - something followed by possible [*+?]
 *
 * Note that the branching code sequences used for ? and the general cases
 * of * and + are somewhat optimized:  they use the same NOTHING node as
 * both the endmarker for their branch list and the body of the last branch.
 * It might seem that this node could be dispensed with entirely, but the
 * endmarker role is not redundant.
 */
static char *
regpiece(int * flagp)
{
    register char *ret;
    register char op;
    register char *next;
    int flags;

    ret = regatom(&flags);
    if (ret == NULL)
        return(NULL);

    op = *regparse;
    if (!ISMULT(op)) {
        *flagp = flags;
        return(ret);
    }

    if (!(flags&HASWIDTH) && op != '?')
        FAIL("*+ operand could be empty");
    *flagp = (op != '+') ? (WORST|SPSTART) : (WORST|HASWIDTH);

    if (op == '*' && (flags&SIMPLE))
        reginsert(STAR, ret);
    else if (op == '*') {
        /* Emit x* as (x&|), where & means "self". */
        reginsert(BRANCH, ret);                 /* Either x */
        regoptail(ret, regnode(BACK));          /* and loop */
        regoptail(ret, ret);                    /* back */
        regtail(ret, regnode(BRANCH));          /* or */
        regtail(ret, regnode(NOTHING));         /* null. */
    } else if (op == '+' && (flags&SIMPLE))
        reginsert(PLUS, ret);
    else if (op == '+') {
        /* Emit x+ as x(&|), where & means "self". */
        next = regnode(BRANCH);                 /* Either */
        regtail(ret, next);
        regtail(regnode(BACK), ret);            /* loop back */
        regtail(next, regnode(BRANCH));         /* or */
        regtail(ret, regnode(NOTHING));         /* null. */
    } else if (op == '?') {
        /* Emit x? as (x|) */
        reginsert(BRANCH, ret);                 /* Either x */
        regtail(ret, regnode(BRANCH));          /* or */
        next = regnode(NOTHING);                /* null. */
        regtail(ret, next);
        regoptail(ret, next);
    }
    regparse++;
    if (ISMULT(*regparse))
        FAIL("nested *?+");

    return(ret);
}

/*
 - regatom - the lowest level
 *
 * Optimization:  gobbles an entire sequence of ordinary characters so that
 * it can turn them into a single node, which is smaller to store and
 * faster to run.  Backslashed characters are exceptions, each becoming a
 * separate node; the code is simpler that way and it's not worth fixing.
 */
static char *
regatom(int * flagp)
{
    register char *ret;
    int flags;

    *flagp = WORST;         /* Tentatively. */

    switch (*regparse++) {
        case '^':
            ret = regnode(BOL);
            break;
        case '$':
            ret = regnode(EOL);
            break;
        case '.':
            ret = regnode(ANY);
            *flagp |= HASWIDTH|SIMPLE;
            break;
        case '[': {
                register int class;
                register int classend;

                if (*regparse == '^') { /* Complement of range. */
                    ret = regnode(ANYBUT);
                    regparse++;
                } else
                    ret = regnode(ANYOF);
                if (*regparse == ']' || *regparse == '-')
                    regc(*regparse++);
                while (*regparse != '\0' && *regparse != ']') {
                    if (*regparse == '-') {
                        regparse++;
                        if (*regparse == ']' || *regparse == '\0')
                            regc('-');
                        else {
                            class = UCHARAT(regparse-2)+1;
                            classend = UCHARAT(regparse);
                            if (class > classend+1)
                                FAIL("invalid [] range");
                            for (; class <= classend; class++)
                                regc(class);
                            regparse++;
                        }
                    } else
                        regc(*regparse++);
                }
                regc('\0');
                if (*regparse != ']')
                    FAIL("unmatched []");
                regparse++;
                *flagp |= HASWIDTH|SIMPLE;
            }
            break;
        case '(':
            ret = reg(1, &flags);
            if (ret == NULL)
                return(NULL);
            *flagp |= flags&(HASWIDTH|SPSTART);
            break;
        case '\0':
        case '|':
        case ')':
            FAIL("internal urp");   /* Supposed to be caught earlier. */
            break;
        case '?':
        case '+':
        case '*':
            FAIL("?+* follows nothing");
            break;
        case '\\':
            if (*regparse == '\0')
                FAIL("trailing \\");
            ret = regnode(EXACTLY);
            regc(*regparse++);
            regc('\0');
            *flagp |= HASWIDTH|SIMPLE;
            break;
        default: {
                register int len;
                register char ender;

                regparse--;
                len = strcspn(regparse, META);
                if (len <= 0)
                    FAIL("internal disaster");
                ender = *(regparse+len);
                if (len > 1 && ISMULT(ender))
                    len--;          /* Back off clear of ?+* operand. */
                *flagp |= HASWIDTH;
                if (len == 1)
                    *flagp |= SIMPLE;
                ret = regnode(EXACTLY);
                while (len > 0) {
                    regc(*regparse++);
                    len--;
                }
                regc('\0');
            }
            break;
    }

    return(ret);
}

/*
 - regnode - emit a node
 */
static char *                   /* Location. */
regnode(char op)
{
    register char *ret;
    register char *ptr;

    ret = regcode;
    if (ret == &regdummy) {
        regsize += 3;
        return(ret);
    }

    ptr = ret;
    *ptr++ = op;
    *ptr++ = '\0';          /* Null "next" pointer. */
    *ptr++ = '\0';
    regcode = ptr;

    return(ret);
}

/*
 - regc - emit (if appropriate) a byte of code
 */
static void
regc(char b)
{
    if (regcode != &regdummy)
        *regcode++ = b;
    else
        regsize++;
}

/*
 - reginsert - insert an operator in front of already-emitted operand
 *
 * Means relocating the operand.
 */
static void
reginsert(char op, char * opnd)
{
    register char *src;
    register char *dst;
    register char *place;

    if (regcode == &regdummy) {
        regsize += 3;
        return;
    }

    src = regcode;
    regcode += 3;
    dst = regcode;
    while (src > opnd)
        *--dst = *--src;

    place = opnd;           /* Op node, where operand used to be. */
    *place++ = op;
    *place++ = '\0';
    *place++ = '\0';
}

/*
 - regtail - set the next-pointer at the end of a node chain
 */
static void
regtail(
        char * p,
        char * val
        )
{
    register char *scan;
    register char *temp;
    register int offset;

    if (p == &regdummy)
        return;

    /* Find last node. */
    scan = p;
    for (;;) {
        temp = regnext(scan);
        if (temp == NULL)
            break;
        scan = temp;
    }

    if (OP(scan) == BACK)
        offset = (int)(scan - val);
    else
        offset = (int)(val - scan);
    *(scan+1) = (char)((offset>>8)&0377);
    *(scan+2) = (char)(offset&0377);
}

/*
 - regoptail - regtail on operand of first argument; nop if operandless
 */
static void
regoptail(char * p, char * val)
{
    /* "Operandless" and "op != BRANCH" are synonymous in practice. */
    if (p == NULL || p == &regdummy || OP(p) != BRANCH)
        return;
    regtail(OPERAND(p), val);
}

/*
 * regexec and friends
 */

/*
 * Global work variables for regexec().
 */
static char *reginput;          /* String-input pointer. */
static char *regbol;            /* Beginning of input, for ^ check. */
static char **regstartp;        /* Pointer to startp array. */
static char **regendp;          /* Ditto for endp. */

/*
 * Forwards.
 */
STATIC int regtry();
STATIC int regmatch();
STATIC int regrepeat();

#ifdef REGEX_DEBUG
int regnarrate = 0;
void regdump();
STATIC char *regprop();
#endif

/*
 - regexec - match a regexp against a string
 */
int
regexec(regexp *prog, char *string, int at_bol)
{
    register char *s;

    /* Be paranoid... */
    if (prog == NULL || string == NULL) {
        regerror("NULL parameter");
        return(0);
    }

    /* Check validity of program. */
    if (UCHARAT(prog->program) != MAGIC) {
        regerror("corrupted program");
        return(0);
    }

    /* If there is a "must appear" string, look for it. */
    if (prog->regmust != NULL) {
        s = string;
        while ((s = cstrchr(s, prog->regmust[0])) != NULL) {
            if (cstrncmp(s, prog->regmust, prog->regmlen) == 0)
                break;  /* Found it. */
            s++;
        }
        if (s == NULL)  /* Not present. */
            return(0);
    }

    /* Mark beginning of line for ^ . */
    if (at_bol)
        regbol = string;        /* is possible to match bol */
    else
        regbol = NULL;          /* we aren't there, so don't match it */

    /* Simplest case:  anchored match need be tried only once. */
    if (prog->reganch)
        return(regtry(prog, string));

    /* Messy cases:  unanchored match. */
    s = string;
    if (prog->regstart != '\0')
        /* We know what char it must start with. */
        while ((s = cstrchr(s, prog->regstart)) != NULL) {
            if (regtry(prog, s))
                return(1);
            s++;
        } else
        /* We don't -- general case. */
        do {
            if (regtry(prog, s))
                return(1);
        } while (*s++ != '\0');

    /* Failure. */
    return(0);
}

/*
 - regtry - try match at specific point
 */
static int                      /* 0 failure, 1 success */
regtry(regexp * prog, char * string)
{
    register int i;
    register char **sp;
    register char **ep;

    reginput = string;
    regstartp = prog->startp;
    regendp = prog->endp;

    sp = prog->startp;
    ep = prog->endp;
    for (i = NSUBEXP; i > 0; i--) {
        *sp++ = NULL;
        *ep++ = NULL;
    }
    if (regmatch(prog->program + 1)) {
        prog->startp[0] = string;
        prog->endp[0] = reginput;
        return(1);
    } else
        return(0);
}

/*
 - regmatch - main matching routine
 *
 * Conceptually the strategy is simple:  check to see whether the current
 * node matches, call self recursively to see whether the rest matches,
 * and then act accordingly.  In practice we make some effort to avoid
 * recursion, in particular by going through "ordinary" nodes (that don't
 * need to know whether the rest of the match failed) by a loop instead of
 * by recursion.
 */
static int                      /* 0 failure, 1 success */
regmatch(char * prog)
{
    register char *scan;    /* Current node. */
    char *next;             /* Next node. */

    scan = prog;
#ifdef REGEX_DEBUG
    if (scan != NULL && regnarrate)
        fprintf(stderr, "%s(\n", regprop(scan));
#endif
    while (scan != NULL) {
#ifdef REGEX_DEBUG
        if (regnarrate)
            fprintf(stderr, "%s...\n", regprop(scan));
#endif
        next = regnext(scan);

        switch (OP(scan)) {
            case BOL:
                if (reginput != regbol)
                    return(0);
                break;
            case EOL:
                if (*reginput != '\0')
                    return(0);
                break;
            case ANY:
                if (*reginput == '\0')
                    return(0);
                reginput++;
                break;
            case EXACTLY: {
                    register int len;
                    register char *opnd;

                    opnd = OPERAND(scan);
                    /* Inline the first character, for speed. */
                    if (mkup(*opnd) != mkup(*reginput))
                        return(0);
                    len = strlen(opnd);
                    if (len > 1 && cstrncmp(opnd,reginput,len) != 0)
                        return(0);
                    reginput += len;
                }
                break;
            case ANYOF:
                if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) == NULL)
                    return(0);
                reginput++;
                break;
            case ANYBUT:
                if (*reginput == '\0' || strchr(OPERAND(scan), *reginput) != NULL)
                    return(0);
                reginput++;
                break;
            case NOTHING:
                break;
            case BACK:
                break;
            case OPEN+1:
            case OPEN+2:
            case OPEN+3:
            case OPEN+4:
            case OPEN+5:
            case OPEN+6:
            case OPEN+7:
            case OPEN+8:
            case OPEN+9: {
                    register int no;
                    register char *save;

                    no = OP(scan) - OPEN;
                    save = reginput;

                    if (regmatch(next)) {
                        /*
                         * Don't set startp if some later
                         * invocation of the same parentheses
                         * already has.
                         */
                        if (regstartp[no] == NULL)
                            regstartp[no] = save;
                        return(1);
                    } else
                        return(0);
                }
                break;
            case CLOSE+1:
            case CLOSE+2:
            case CLOSE+3:
            case CLOSE+4:
            case CLOSE+5:
            case CLOSE+6:
            case CLOSE+7:
            case CLOSE+8:
            case CLOSE+9: {
                    register int no;
                    register char *save;

                    no = OP(scan) - CLOSE;
                    save = reginput;

                    if (regmatch(next)) {
                        /*
                         * Don't set endp if some later
                         * invocation of the same parentheses
                         * already has.
                         */
                        if (regendp[no] == NULL)
                            regendp[no] = save;
                        return(1);
                    } else
                        return(0);
                }
                break;
            case BRANCH: {
                    register char *save;

                    if (OP(next) != BRANCH)         /* No choice. */
                        next = OPERAND(scan);   /* Avoid recursion. */
                    else {
                        do {
                            save = reginput;
                            if (regmatch(OPERAND(scan)))
                                return(1);
                            reginput = save;
                            scan = regnext(scan);
                        } while (scan != NULL && OP(scan) == BRANCH);
                        return(0);
                        /* NOTREACHED */
                    }
                }
                break;
            case STAR:
            case PLUS: {
                    register char nextch;
                    register int no;
                    register char *save;
                    register int min;

                    /*
                     * Lookahead to avoid useless match attempts
                     * when we know what character comes next.
                     */
                    nextch = '\0';
                    if (OP(next) == EXACTLY)
                        nextch = *OPERAND(next);
                    min = (OP(scan) == STAR) ? 0 : 1;
                    save = reginput;
                    no = regrepeat(OPERAND(scan));
                    while (no >= min) {
                        /* If it could work, try it. */
                        if (nextch == '\0' || *reginput == nextch)
                            if (regmatch(next))
                                return(1);
                            /* Couldn't or didn't -- back up. */
                        no--;
                        reginput = save + no;
                    }
                    return(0);
                }
                break;
            case END:
                return(1);      /* Success! */
                break;
            default:
                regerror("memory corruption");
                return(0);
                break;
        }

        scan = next;
    }

    /*
     * We get here only if there's trouble -- normally "case END" is
     * the terminating point.
     */
    regerror("corrupted pointers");
    return(0);
}

/*
 - regrepeat - repeatedly match something simple, report how many
 */
static int
regrepeat(char * p)
{
    register int count = 0;
    register char *scan;
    register char *opnd;

    scan = reginput;
    opnd = OPERAND(p);
    switch (OP(p)) {
        case ANY:
            count = strlen(scan);
            scan += count;
            break;
        case EXACTLY:
            while (mkup(*opnd) == mkup(*scan)) {
                count++;
                scan++;
            }
            break;
        case ANYOF:
            while (*scan != '\0' && strchr(opnd, *scan) != NULL) {
                count++;
                scan++;
            }
            break;
        case ANYBUT:
            while (*scan != '\0' && strchr(opnd, *scan) == NULL) {
                count++;
                scan++;
            }
            break;
        default:                /* Oh dear.  Called inappropriately. */
            regerror("internal foulup");
            count = 0;      /* Best compromise. */
            break;
    }
    reginput = scan;

    return(count);
}

/*
 - regnext - dig the "next" pointer out of a node
 */
static char *
regnext(register char * p)
{
    register int offset;

    if (p == &regdummy)
        return(NULL);

    offset = NEXT(p);
    if (offset == 0)
        return(NULL);

    if (OP(p) == BACK)
        return(p-offset);
    else
        return(p+offset);
}

#ifdef REGEX_DEBUG

STATIC char *regprop();

/*
 - regdump - dump a regexp onto stdout in vaguely comprehensible form
 */
void
regdump(regexp * r)
{
    register char *s;
    register char op = EXACTLY;     /* Arbitrary non-END op. */
    register char *next;

    s = r->program + 1;
    while (op != END) {     /* While that wasn't END last time... */
        op = OP(s);
        printf("%2d%s", s-r->program, regprop(s));      /* Where, what. */
        next = regnext(s);
        if (next == NULL)               /* Next ptr. */
            printf("(0)");
        else
            printf("(%d)", (s-r->program)+(next-s));
        s += 3;
        if (op == ANYOF || op == ANYBUT || op == EXACTLY) {
            /* Literal string, where present. */
            while (*s != '\0') {
                putchar(*s);
                s++;
            }
            s++;
        }
        putchar('\n');
    }

    /* Header fields of interest. */
    if (r->regstart != '\0')
        printf("start `%c' ", r->regstart);
    if (r->reganch)
        printf("anchored ");
    if (r->regmust != NULL)
        printf("must have \"%s\"", r->regmust);
    printf("\n");
}

/*
 - regprop - printable representation of opcode
 */
static char *
regprop(char * op)
{
    register char *p;
    static char buf[50];

    (void) strcpy(buf, ":");

    switch (OP(op)) {
        case BOL:
            p = "BOL";
            break;
        case EOL:
            p = "EOL";
            break;
        case ANY:
            p = "ANY";
            break;
        case ANYOF:
            p = "ANYOF";
            break;
        case ANYBUT:
            p = "ANYBUT";
            break;
        case BRANCH:
            p = "BRANCH";
            break;
        case EXACTLY:
            p = "EXACTLY";
            break;
        case NOTHING:
            p = "NOTHING";
            break;
        case BACK:
            p = "BACK";
            break;
        case END:
            p = "END";
            break;
        case OPEN+1:
        case OPEN+2:
        case OPEN+3:
        case OPEN+4:
        case OPEN+5:
        case OPEN+6:
        case OPEN+7:
        case OPEN+8:
        case OPEN+9:
            sprintf(buf+strlen(buf), "OPEN%d", OP(op)-OPEN);
            p = NULL;
            break;
        case CLOSE+1:
        case CLOSE+2:
        case CLOSE+3:
        case CLOSE+4:
        case CLOSE+5:
        case CLOSE+6:
        case CLOSE+7:
        case CLOSE+8:
        case CLOSE+9:
            sprintf(buf+strlen(buf), "CLOSE%d", OP(op)-CLOSE);
            p = NULL;
            break;
        case STAR:
            p = "STAR";
            break;
        case PLUS:
            p = "PLUS";
            break;
        default:
            regerror("corrupted opcode");
            break;
    }
    if (p != NULL)
        (void) strcat(buf, p);
    return(buf);
}
#endif

/*
 * The following is provided for those people who do not have strcspn() in
 * their C libraries.  They should get off their butts and do something
 * about it; at least one public-domain implementation of those (highly
 * useful) string routines has been published on Usenet.
 */
#ifdef STRCSPN
/*
 * strcspn - find length of initial segment of s1 consisting entirely
 * of characters not from s2
 */

static int
strcspn(char * s1, char * s2)
{
    register char *scan1;
    register char *scan2;
    register int count;

    count = 0;
    for (scan1 = s1; *scan1 != '\0'; scan1++) {
        for (scan2 = s2; *scan2 != '\0';)       /* ++ moved down. */
            if (*scan1 == *scan2++)
                return(count);
        count++;
    }
    return(count);
}
#endif

int
cstrncmp(char * s1, char * s2, int n)
{
    char    *p, *S1, *S2;
    int     rval;

    if (!reg_ic)
        return (strncmp(s1, s2, n));

    S1 = _strdup(s1);
    S2 = _strdup(s2);

    if (S1 && S2)
    {
        for (p = S1; *p ;p = CharNext(p))
            if (islower(*p))
                *p = (char)toupper(*p);

        for (p = S2; *p ;p = CharNext(p))
            if (islower(*p))
                *p = (char)toupper(*p);

        rval = strncmp(S1, S2, n);
    }
    else
    {
        // just call them equal.  if we get here, we've got bigger problems.
        rval = 0;
    }

    free(S1);
    free(S2);

    return rval;
}

char *
cstrchr(
       char  *s,
       char  c)
{
    char    *p;

    for (p = s; *p ;p = CharNext(p)) {
        if (mkup(*p) == mkup(c))
            return p;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\regexp.h ===
/*
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * This is NOT the original regular expression code as written by
 * Henry Spencer. This code has been modified specifically for use
 * with the STEVIE editor, and should not be used apart from compiling
 * STEVIE. If you want a good regular expression library, get the
 * original code. The copyright notice that follows is from the
 * original.
 *
 * NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE NOTICE
 *
 * Definitions etc. for regexp(3) routines.
 *
 * Caveat:  this is V8 regexp(3) [actually, a reimplementation thereof],
 * not the System V one.
 *
 * The first byte of the regexp internal "program" is actually this magic
 * number; the start node begins in the second byte.
 */
#define     MAGIC   0234

#define     NSUBEXP  10
typedef struct regexp {
        char *startp[NSUBEXP];
        char *endp[NSUBEXP];
        char regstart;          /* Internal use only. */
        char reganch;           /* Internal use only. */
        char *regmust;          /* Internal use only. */
        int regmlen;            /* Internal use only. */
        char program[1];        /* Unwarranted chumminess with compiler. */
} regexp;

extern regexp   *regcomp(char *exp);
extern int      regexec(regexp *prog, char *string, int at_bol);
extern void     regsub( regexp *prog, char *source, char *dest );
extern void     regerror(char *);

#ifndef ORIGINAL
extern int reg_ic;              /* set non-zero to ignore case in searches */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\scandir.c ===
/*
 * scandir.c
 *
 * build lists of filenames given a pathname.
 *
 * dir_buildlist takes a pathname and returns a handle. Subsequent
 * calls to dir_firstitem and dir_nextitem return handles to
 * items within the list, from which you can get the name of the
 * file (relative to the original pathname, or complete), and a checksum
 * and filesize.
 *
 * lists can also be built using dir_buildremote (WIN32 only) and
 * the same functions used to traverse the list and obtain checksums and
 * filenames.
 *
 * The list can be either built entirely during the build call, or
 * built one directory at a time as required by dir_nextitem calls. This
 * option affects only relative performance, and is taken as a
 * recommendation only (ie some of the time we will ignore the flag).
 *
 * the list is ordered alphabetically (case-insensitive using lstrcmpi).
 * within any one directory, we list filenames before going on
 * to subdirectory contents.
 *
 * All memory is allocated from a gmem_* heap hHeap declared
 * and initialised elsewhere.
 *
 * Geraint Davies, July 92
 * Laurie Griffiths
 */

#include <precomp.h>

#ifdef REMOTE_SERVER
#include "sumserve.h"
#include "ssclient.h"
#endif

#include "list.h"
#include "scandir.h"

#include "windiff.h"
#include "wdiffrc.h"

#include "slmmgr.h"

#ifdef trace
extern BOOL bTrace;  /* in windiff.c.  Read only here */
#endif //trace

/*
 * The caller gets handles to two things: a DIRLIST, representing the
 * entire list of filenames, and a DIRITEM: one item within the list.
 *
 * from the DIRITEM he can get the filename relative to tree root
 * passed to dir_build*) - and also he can get to the next
 * DIRITEM (and back to the DIRLIST).
 *
 * We permit lazy building of the tree (usually so the caller can keep
 * the user-interface uptodate as we go along). In this case,
 * we need to store information about how far we have scanned and
 * what is next to do. We need to scan an entire directory at a time and then
 * sort it so we can return files in the correct order.
 *
 *
 * We scan an entire directory and store it in a DIRECT struct. This contains
 * a list of DIRITEMs for the files in the current directory, and a list of
 * DIRECTs for the subdirectories (possible un-scanned).
 *
 * dir_nextitem will use the list functions to get the next DIRITEM on the list.
 * When the end of the list is reached, it will use the backpointer back to the
 * DIRECT struct to find the next directory to scan.
 *
 *
 * For REMOTE scans, we do not parse the names and store them by directory,
 * since they are already sorted. The DIRLIST will have only one DIRECT
 * (dot), and all files are on this one dot->diritems list, including the
 * relname of the directory in the name field (ie for remote files, we
 * don't need to prepend the directory relname when doing dir_getrelname -
 * we can pass a pointer to the diritem->name[] itself.
 *
 */

/*
 * hold name and information about a given file (one ITEM in a DIRectory)
 * caller's DIRITEM handle is a pointer to one of these structures
 */
struct diritem {
    LPSTR name;             /* ptr to filename (final element only) */
    LPSTR pSlmTag;          /* ptr to version string - for SLM "@v.-1", etc; or for SD "#head", etc; or NULL */
    long size;              /* filesize */
    DWORD checksum;         /* checksum of file */
    DWORD attr;             /* file attributes */
    FILETIME ft_lastwrite;  /* last write time, set whenever size is set */
    BOOL sumvalid;          /* TRUE if checksum calculated */
    BOOL fileerror;         // true if some file error occurred
    struct direct * direct; /* containing directory */
    LPSTR localname;        /* name of temp copy of file */
    BOOL bLocalIsTemp;      /* true if localname is tempfile. not
                             * defined if localname is NULL
                             */
    int sequence;           /* sequence number, for dir_compsequencenumber */
};


/* DIRECT: hold state about directory and current position in list of filenames.
 */
typedef struct direct {
    LPSTR relname;          /* name of dir relative to DIRLIST root */
    DIRLIST head;           /* back ptr (to get fullname and server) */
    struct direct * parent; /* parent directory (NULL if above tree root)*/

    BOOL bScanned;          /* TRUE if scanned -for Remote, T if completed*/
    LIST diritems;          /* list of DIRITEMs for files in cur. dir */
    LIST directs;           /* list of DIRECTs for child dirs */

    int pos;                /* where are we? begin, files, dirs */
    struct direct * curdir; /* subdir being scanned (ptr to list element)*/
} * DIRECT;

/* values for direct.pos */
#define DL_FILES        1       /* reading files from the diritems */
#define DL_DIRS         2       /* in the dirs: List_Next on curdir */


/*
 * the DIRLIST handle returned from a build function is in fact
 * a pointer to one of these. Although this is not built from a LIST object,
 * it behaves like a list to the caller.
 */
struct dirlist {

    char rootname[MAX_PATH];        /* name of root of tree */
    BOOL bFile;             /* TRUE if root of tree is file, not dir */
#ifdef REMOTE_SERVER
    BOOL bRemote;           /* TRUE if list built from remote server */
#endif
    BOOL bSum;              /* TRUE if checksums required */
    DIRECT dot;             /* dir  for '.' - for tree root dir */

    LPSTR pPattern;         /* wildcard pattern or NULL */
    LPSTR pSlmTag;          /* Slm version info "@v.-1" or NULL */
    LPSTR pDescription;     /* description */

    DIRLIST pOtherDirList;

#ifdef REMOTE_SERVER
    LPSTR server;           /* name of server if remote, NULL otherwise */
    HANDLE hpipe;           /* pipe to checksum server */
    LPSTR uncname;          /* name of server&share if password req'd */
    LPSTR password;         /* password for UNC connection if needed */
#endif
};

extern BOOL bAbort;             /* from windiff.c (read only here). */

/* file times are completely different under DOS and NT.
   On NT they are FILETIMEs with a 2 DWORD structure.
   Under DOS they are single long.  We emulate the NT
   thing under DOS by providing CompareFileTime and a
   definition of FILETIME
*/

/* ------ memory allocation ---------------------------------------------*/

/* all memory is allocated from a heap created by the application */
extern HANDLE hHeap;

/*-- forward declaration of internal functions ---------------------------*/

BOOL iswildpath(LPCSTR pszPath);
LPSTR dir_finalelem(LPSTR path);
void dir_cleardirect(DIRECT dir);
void dir_adddirect(DIRECT dir, LPSTR path);
BOOL dir_addfile(DIRECT dir, LPSTR path, LPSTR version, DWORD size, FILETIME ft, DWORD attr, int *psequence);
void dir_scan(DIRECT dir, BOOL bRecurse);
BOOL dir_isvalidfile(LPSTR path);
BOOL dir_fileinit(DIRITEM pfile, DIRECT dir, LPSTR path, LPSTR version, long size, FILETIME ft, DWORD attr, int *psequence);
void dir_dirinit(DIRECT dir, DIRLIST head, DIRECT parent, LPSTR name);
long dir_getpathsizeetc(LPSTR path, FILETIME FAR*ft, DWORD FAR*attr);
DIRITEM dir_findnextfile(DIRLIST dl, DIRECT curdir);
BOOL dir_remoteinit(DIRLIST dl, LPSTR server, LPSTR path, BOOL fDeep);
DIRITEM dir_remotenext(DIRLIST dl, DIRITEM cur);



/* --- external functions ------------------------------------------------*/


/* ----- list initialisation/cleanup --------------------------------------*/


/*
 * build a list of filenames
 *
 * optionally build the list on demand, in which case we scan the
 * entire directory but don't recurse into subdirs until needed
 *
 * if bSum is true, checksum each file as we build the list. checksums can
 * be obtained from the DIRITEM (dir_getchecksum(DIRITEM)). If bSum is FALSE,
 * checksums will be calculated on request (the first call to dir_getchecksum
 * for a given DIRITEM).
 */

DIRLIST
dir_buildlist(
              LPSTR path,
              BOOL bSum,
              BOOL bOnDemand
              )
{
    DIRLIST dlOut = 0;
    DIRLIST dl = 0;
    BOOL bFile;
    char tmppath[MAX_PATH] = {0};
    LPSTR pstr;
    LPSTR pPat = NULL;
    LPSTR pTag = NULL;

    /*
     * copy the path so we can modify it
     */
    strncat(tmppath, path, sizeof(tmppath)-1);

    /* look for SLM tags, strip them and return them in pTag
     * look for SLM tags beginning @ and separate if there.
     */
    pTag = SLM_ParseTag(tmppath, TRUE);

    /* look for wildcards and separate out pattern if there */
    if (My_mbschr(tmppath, '*') || My_mbschr(tmppath, '?'))
    {
        pstr = dir_finalelem(tmppath);
        pPat = gmem_get(hHeap, lstrlen(pstr) +1);
        lstrcpy(pPat, pstr);
        *pstr = '\0';
    }

    /* we may have reduced the path to nothing - replace with . if so */
    if (lstrlen(tmppath) == 0)
    {
        lstrcpy(tmppath, ".");
    }
    else
    {
        /*
         * remove the trailing slash if unnecessary (\, c:\ need it)
         */
        pstr = &tmppath[lstrlen(tmppath) -1];
        if ((*pstr == '\\') && (pstr > tmppath) && (pstr[-1] != ':')
            && !IsDBCSLeadByte((BYTE)*(pstr-1)))
        {
            *pstr = '\0';
        }
    }


    /* check if the path is valid */
    if ((pTag && !iswildpath(tmppath)) || (tmppath[0] == '/' && tmppath[1] == '/'))
    {
        bFile = TRUE;
    }
    else if (dir_isvaliddir(tmppath))
    {
        bFile = FALSE;
    }
    else if (dir_isvalidfile(tmppath))
    {
        bFile = TRUE;
    }
    else
    {
        /* not valid */
        goto LError;
    }


    /* alloc and init the DIRLIST head */

    dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));

    // done in gmem_get
    //memset(dl, 0, sizeof(struct dirlist));

    dl->pOtherDirList = NULL;

    /* convert the pathname to an absolute path */
    // (but don't mess with depot paths)
    if (!IsDepotPath(tmppath))
        _fullpath(dl->rootname, tmppath, sizeof(dl->rootname));

#ifdef REMOTE_SERVER
    dl->server = NULL;
    dl->bRemote = FALSE;
#endif

    dl->bSum = bSum;
    dl->bSum = FALSE;  // to speed things up. even if we do want checksums,
                       // let's get them on demand, not right now.
    dl->bFile = bFile;

    if (pTag)
    {
        dl->pSlmTag = pTag;
        pTag = 0;
    }
    if (pPat)
    {
        dl->pPattern = pPat;
        pPat = 0;
    }


    /* make a '.' directory for the tree root directory -
     * all files and subdirs will be listed from here
     */
    {    /* Do NOT chain on anything with garbage pointers in it */
        DIRECT temp;
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));

        //done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));

        dl->dot = temp;
    }

    dir_dirinit(dl->dot, dl, NULL, ".");

    /* were we given a file or a directory ? */
    if (bFile)
    {
        /* its a file. create a single file entry
         * and set the state accordingly
         */
        long fsize;
        FILETIME ft;
        DWORD attr;
        fsize = dir_getpathsizeetc(tmppath, &ft, &attr);

        dl->dot->bScanned = TRUE;

        /*
         * addfile will extract the slm version, if
         * required. It will recalc file size based on
         * the slm-extraction if necessary.
         */
        if (!dir_addfile(dl->dot, dir_finalelem(tmppath), dl->pSlmTag, fsize, ft, attr, 0))
            goto LError;
    }
    else
    {
        /* scan the root directory and return. if we are asked
         * to scan the whole thing, this will cause a recursive
         * scan all the way down the tree
         */
        dir_scan(dl->dot, (!bOnDemand) );
    }

    dlOut = dl;
    dl = 0;

LError:
    if (pTag)
        gmem_free(hHeap, pTag, lstrlen(pTag) + 1);
    if (pPat)
        gmem_free(hHeap, pPat, lstrlen(pPat) + 1);
    dir_delete(dl);
    return dlOut;
} /* dir_buildlist */

/*
 * build/append a list of filenames
 *
 * if bSum is true, checksum each file as we build the list. checksums can
 * be obtained from the DIRITEM (dir_getchecksum(DIRITEM)). If bSum is FALSE,
 * checksums will be calculated on request (the first call to dir_getchecksum
 * for a given DIRITEM).
 */

BOOL
dir_appendlist(
               DIRLIST *pdl,
               LPCSTR path,
               BOOL bSum,
               int *psequence
               )
{
    DIRLIST dl;
    BOOL bFile;
    char tmppath[MAX_PATH];
    LPSTR pstr;
    LPSTR pTag = NULL;
    BOOL fSuccess = FALSE;

    if (path)
    {
        // copy the path so we can modify it
        lstrcpy(tmppath, path);

        // look for SLM tags, strip them and return them in pTag
        pTag = SLM_ParseTag(tmppath, TRUE);

        // remove the trailing slash if unnecessary (\, c:\ need it)
        pstr = &tmppath[lstrlen(tmppath) -1];
        if ((*pstr == '\\') && (pstr > tmppath) && (pstr[-1] != ':')
            && !IsDBCSLeadByte((BYTE)*(pstr-1)))
        {
            *pstr = '\0';
        }


        /* check if the path is valid */
        if ((pTag && !iswildpath(tmppath))|| (tmppath[0] == '/' && tmppath[1] == '/'))
        {
            // assume valid if under source control
            bFile = TRUE;
        }
        else if (dir_isvaliddir(tmppath))
        {
            bFile = FALSE;
        }
        else if (dir_isvalidfile(tmppath))
        {
            bFile = TRUE;
        }
        else
        {
            /* not valid */
            goto LError;
        }
    }

    if (!*pdl)
    {
        DIRECT temp;

        /* alloc and init the DIRLIST head */
        *pdl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));
        // done in gmem_get
        //memset(dl, 0, sizeof(struct dirlist));

        (*pdl)->pOtherDirList = NULL;

        /* convert the pathname to an absolute path */

        //_fullpath((*pdl)->rootname, tmppath, sizeof((*pdl)->rootname));
#ifdef REMOTE_SERVER
        (*pdl)->server = NULL;
        (*pdl)->bRemote = FALSE;
#endif

        (*pdl)->bSum = bSum;
        (*pdl)->bSum = FALSE;   // to speed things up. even if we do want
                                // checksums, let's get them on demand, not
                                // right now.
        (*pdl)->bFile = FALSE;

        /* make a null directory for the tree root directory -
         * all files and subdirs will be listed from here
         */
        /* Do NOT chain on anything with garbage pointers in it */
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));
        //done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));
        (*pdl)->dot = temp;

        dir_dirinit((*pdl)->dot, (*pdl), NULL, "");
        (*pdl)->dot->relname[0] = 0;
        (*pdl)->dot->bScanned = TRUE;
    }
    dl = *pdl;

    if (pTag && !dl->pSlmTag)
    {
        dl->pSlmTag = gmem_get(hHeap, lstrlen(pTag) + 1);
        lstrcpy(dl->pSlmTag, pTag);
    }

    if (path)
    {
        /* were we given a file or a directory ? */
        if (bFile)
        {
            /* its a file. create a single file entry
             * and set the state accordingly
             */
            long fsize;
            FILETIME ft;
            DWORD attr;

            if (pTag || dl->pSlmTag)
            {
                fsize = 0;
                attr = 0;
                ZeroMemory(&ft, sizeof(ft));
            }
            else
                fsize = dir_getpathsizeetc(tmppath, &ft, &attr);

            /*
             * addfile will extract the slm version, if
             * required. It will recalc file size based on
             * the slm-extraction if necessary.
             */
            if (!dir_addfile(dl->dot, tmppath, pTag, fsize, ft, attr, psequence))
                goto LError;
        }
    }

    fSuccess = TRUE;

LError:
    if (pTag)
        gmem_free(hHeap, pTag, lstrlen(pTag) + 1);
    return fSuccess;
} /* dir_appendlist */

void
dir_setotherdirlist(
                    DIRLIST dl,
                    DIRLIST otherdl
                    )
{
    dl->pOtherDirList = otherdl;
}

/* free up the DIRLIST and all associated memory */
void
dir_delete(
           DIRLIST dl
           )
{
    if (dl == NULL) {
        return;
    }

#ifdef REMOTE_SERVER
    if (dl->bRemote) {
        gmem_free(hHeap, dl->server, lstrlen(dl->server)+1);

        /* if remote, and dl->dot is not scanned (ie scan is not
         * complete), then the pipe handle is still open
         */
        if (!dl->dot->bScanned) {
            CloseHandle(dl->hpipe);
        }

        if (dl->uncname) {
            gmem_free(hHeap, dl->uncname, strlen(dl->uncname)+1);
        }
        if (dl->password) {
            gmem_free(hHeap, dl->password, strlen(dl->password)+1);
        }

    }
#endif

    dir_cleardirect(dl->dot);
    gmem_free(hHeap, (LPSTR) dl->dot, sizeof(struct direct));

    if (dl->pPattern) {
        gmem_free(hHeap, dl->pPattern, lstrlen(dl->pPattern)+1);
    }
    if (dl->pSlmTag) {
        gmem_free(hHeap, dl->pSlmTag, lstrlen(dl->pSlmTag)+1);
    }

    gmem_free(hHeap, (LPSTR) dl, sizeof(struct dirlist));
}

#ifdef REMOTE_SERVER

/*
 * build a list by accessing a remote checksum server.
 */
DIRLIST
dir_buildremote(
                LPSTR server,
                LPSTR path,
                BOOL bSum,
                BOOL bOnDemand,
                BOOL fDeep
                )
{
    DIRLIST dl;

    /* alloc and init the DIRLIST head */

    dl = (DIRLIST) gmem_get(hHeap, sizeof(struct dirlist));
    //done in gmem_get
    //memset(dl, 0, sizeof(struct dirlist));

    /* alloc space for the pathname */
    lstrcpy(dl->rootname, path);

    /* and for the server name */
    dl->server = gmem_get(hHeap, lstrlen(server) + 1);
    lstrcpy(dl->server, server);

    dl->bSum = bSum;
    /* bFile is set to TRUE - meaning we have just one file.
     * if we ever see a DIR response from the remote end, we will
     * set this to false.
     */
    dl->bFile = TRUE;
    dl->bRemote = TRUE;

    /* make a '.' directory for the current directory -
     * all files and subdirs will be listed from here
     */
    {    /* Do NOT chain on anmything with garbage pointers in it */
        DIRECT temp;
        temp = (DIRECT) gmem_get(hHeap, sizeof(struct direct));
        // done in gmem_get
        //if (temp!=NULL) memset(temp, 0, sizeof(struct direct));
        dl->dot = temp;
    }
    dir_dirinit(dl->dot, dl, NULL, ".");

    if (dir_remoteinit(dl, server, path, fDeep) == FALSE) {
        /* didn't find any files, so remove the directory */
        dir_delete(dl);
        return(NULL);
    }
    return(dl);
} /* dir_buildremote */

#endif

/* ----- DIRLIST functions ------------------------------------------------*/

/* was the original build request a file or a directory ? */
BOOL
dir_isfile(
           DIRLIST dl
           )
{
    if (dl == NULL) {
        return(FALSE);
    }

    return(dl->bFile);
}


/* return the first file in the list, or NULL if no files found.
 * returns a DIRITEM. This can be used to get filename, size and chcksum.
 * if there are no files in the root, we recurse down until we find a file
 */
DIRITEM
dir_firstitem(
              DIRLIST dl
              )
{
    if (dl == NULL) {
        return(NULL);
    }

#ifdef REMOTE_SERVER
    /*
     * is this a remote list or a local scan ?
     */
    if (dl->bRemote) {
        return(dir_remotenext(dl, NULL));
    }
#endif
    /*
     * reset the state to indicate that no files have been read yet
     */
    dl->dot->pos = DL_FILES;
    dl->dot->curdir = NULL;

    /* now get the next filename */
    return(dir_findnextfile(dl, dl->dot));
} /* dir_firstitem */


/*
 * get the next filename after the one given.
 *
 * The List_Next function can give us the next element on the list of files.
 * If this is null, we need to go back to the DIRECT and find the
 * next list of files to traverse (in the next subdir).
 *
 * after scanning all the subdirs, return to the parent to scan further
 * dirs that are peers of this, if there are any. If we have reached the end of
 * the tree (no more dirs in dl->dot to scan), return NULL.
 *
 * Don't recurse to lower levels unless fDeep is TRUE
 */
DIRITEM
dir_nextitem(
             DIRLIST dl,
             DIRITEM cur,
             BOOL fDeep
             )
{
    DIRITEM next;

    if ((dl == NULL) || (cur == NULL)) {
        TRACE_ERROR("DIR: null arguments to dir_nextitem", FALSE);
        return(NULL);
    }
#ifdef REMOTE_SERVER
    /*
     * is this a remote list or a local scan ?
     */
    if (dl->bRemote) {
        return(dir_remotenext(dl, cur));
    }
#endif
    if (bAbort) return NULL;  /* user requested abort */

    /* local list */

    if ( (next = List_Next(cur)) != NULL) {
        /* there was another file on this list */
        return(next);
    }
    if (!fDeep) return NULL;

    /* get the head of the next list of filenames from the directory */
    cur->direct->pos = DL_DIRS;
    cur->direct->curdir = NULL;
    return(dir_findnextfile(dl, cur->direct));
} /* dir_nextitem */

DIRITEM
dir_findnextfile(
                 DIRLIST dl,
                 DIRECT curdir
                 )
{
    DIRITEM curfile;

    if (bAbort) return NULL;  /* user requested abort */

    if ((dl == NULL) || (curdir == NULL)) {
        return(NULL);
    }

    /* scan the subdir if necessary */
    if (!curdir->bScanned) {
        dir_scan(curdir, FALSE);
    }

    /* have we already read the files in this directory ? */
    if (curdir->pos == DL_FILES) {
        /* no - return head of file list */
        curfile = (DIRITEM) List_First(curdir->diritems);
        if (curfile != NULL) {
            return(curfile);
        }

        /* no more files - try the subdirs */
        curdir->pos = DL_DIRS;
    }

    /* try the next subdir on the list, if any */
    /* is this the first or the next */
    if (curdir->curdir == NULL) {
        curdir->curdir = (DIRECT) List_First(curdir->directs);
    } else {
        curdir->curdir = (DIRECT) List_Next(curdir->curdir);
    }
    /* did we find a subdir ? */
    if (curdir->curdir == NULL) {

        /* no more dirs - go back to parent if there is one */
        if (curdir->parent == NULL) {
            /* no parent - we have exhausted the tree */
            return(NULL);
        }

        /* reset parent state to indicate this is the current
         * directory - so that next gets the next after this.
         * this ensures that multiple callers of dir_nextitem()
         * to the same tree work.
         */
        curdir->parent->pos = DL_DIRS;
        curdir->parent->curdir = curdir;

        return(dir_findnextfile(dl, curdir->parent));
    }

    /* there is a next directory - set it to the
     * beginning and get the first file from it
     */
    curdir->curdir->pos = DL_FILES;
    curdir->curdir->curdir = NULL;
    return(dir_findnextfile(dl, curdir->curdir));

} /* dir_findnextfile */


/*
 * get a description of this DIRLIST - this is essentially the
 * rootname with any wildcard specifier at the end. For remote
 * lists, we prepend the checksum server name as \\server!path.
 *
 * NOTE that this is not a valid path to the tree root - for that you
 * need dir_getrootpath().
 */
LPSTR
dir_getrootdescription(
                       DIRLIST dl
                       )
{
    LPSTR pname;

    // allow enough space for \\servername! + MAX_PATH
    pname = gmem_get(hHeap, MAX_PATH + 15);
    if (pname == NULL) {
        return(NULL);
    }

    if (dl->pDescription) {
        lstrcpy(pname, dl->pDescription);
#ifdef REMOTE_SERVER
    } else if (dl->bRemote) {
        wsprintf(pname, "\\\\%s!%s", dl->server, dl->rootname);
#endif
    } else {
        lstrcpy(pname, dl->rootname);

        if (dl->pPattern) {
            lstrcat(pname, "\\");
            lstrcat(pname, dl->pPattern);
        }

        if (dl->pSlmTag) {
            lstrcat(pname, dl->pSlmTag);
        }
    }

    return(pname);
}

/*
 * free up a string returned from dir_getrootdescription
 */
VOID
dir_freerootdescription(
                        DIRLIST dl,
                        LPSTR string
                        )
{
    gmem_free(hHeap, string, MAX_PATH+15);
}


/*
 * dir_getrootpath
 *
 * return the path to the DIRLIST root. This will be a valid path, not
 * including the checksum server name or pPattern or pSlmTag etc
 */
LPSTR
dir_getrootpath(
                DIRLIST dl
                )
{
    return(dl->rootname);
}



/*
 * free up a path created by dir_getrootpath
 */
void
dir_freerootpath(
                 DIRLIST dl,
                 LPSTR path
                 )
{
    return;
}


/*
 * set custom description for dirlist
 */
void
dir_setdescription(DIRLIST dl, LPCSTR psz)
{
    dl->pDescription = gmem_get(hHeap, lstrlen(psz) + 1);
    if (dl->pDescription)
        lstrcpy(dl->pDescription, psz);
}




/*
 * returns TRUE if the DIRLIST parameter has a wildcard specified
 */
BOOL
dir_iswildcard(
               DIRLIST dl
               )
{
    return (dl->pPattern != NULL);
}




/* --- DIRITEM functions ----------------------------------------------- */


/*
 * Return a handle to the DIRLIST given a handle to the DIRITEM within it.
 *
 */
DIRLIST
dir_getlist(
            DIRITEM item
            )
{
    if (item == NULL) {
        return(NULL);
    } else {
        return(item->direct->head);
    }
}


/*
 * return the name of the current file relative to tree root
 * This allocates storage.  Call dir_freerelname to release it.
 */
LPSTR
dir_getrelname(
               DIRITEM cur
               )
{
    LPSTR name;

    /* check this is a valid item */
    if (cur == NULL) {
        return(NULL);
    }

#ifdef REMOTE_SERVER
    /* the entire relname is already in the name[] field for
     * remote lists
     */
    if (cur->direct->head->bRemote) {
        return(cur->name);
    }
#endif

    name = gmem_get(hHeap, MAX_PATH);
    if (!IsDepotPath(cur->name))
        lstrcpy(name, cur->direct->relname);
    lstrcat(name, cur->name);

//$ review: (chrisant) what is this here for?  seems totally broken
// even for SLM, and for SD it screws everything up.
#if 0
    if (cur->direct->head->pSlmTag) {
        lstrcat(name, cur->direct->head->pSlmTag);
    }
#endif

    return(name);
} /* dir_getrelname */


/* free up a relname that we allocated. This interface allows us
 * some flexibility in how we store relative and complete names
 *
 * remote lists already have the relname and name combined, so in these
 * cases we did not alloc memory - so don't free it.
 */
void
dir_freerelname(
                DIRITEM cur,
                LPSTR name
                )
{
    if ((cur != NULL) 
#ifdef REMOTE_SERVER
        && (!cur->direct->head->bRemote)
#endif
        ) {
        if (name != NULL) {
            gmem_free(hHeap, name, MAX_PATH);
        }
    }
} /* dir_freerelname */


/*
 * get an open-able name for the file. This is the complete pathname
 * of the item (DIRLIST rootpath + DIRITEM relname)
 * except for remote files and slm early-version files,
 * in which case a temporary local copy of the file
 * will be made. call dir_freeopenname when finished with this name.
 */
LPSTR
dir_getopenname(
                DIRITEM item
                )
{
    LPSTR fname;
    DIRLIST phead;

    if (item == NULL) {
        return(NULL);
    }

    phead = item->direct->head;

    if (item->localname != NULL) {
        return(item->localname);
    }

    if (phead->bFile) {
        return(phead->rootname);
    }

    // build up the file name from rootname+relname
    // start with the root portion - rest is different in remote case
    fname = gmem_get(hHeap, MAX_PATH);
    if (!fname)
        return NULL;
    lstrcpy(fname, phead->rootname);

#ifdef REMOTE_SERVER
    if (phead->bRemote) {

        // relname is empty for remote names - just add
        // the rootname and the name to make a complete
        // remote name, and then make a local copy of this.

        /* avoid the . or .\ at the start of the relname */
        if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
            lstrcat(fname, &item->name[2]);
        } else {
            lstrcat(fname, &item->name[1]);
        }

        item->localname = gmem_get(hHeap, MAX_PATH);
        if (item->localname)
        {
            GetTempPath(MAX_PATH, item->localname);
            GetTempFileName(item->localname, "wdf", 0, item->localname);
            item->bLocalIsTemp = TRUE;


            if (!ss_copy_reliable(
                                 item->direct->head->server,
                                 fname,
                                 item->localname,
                                 item->direct->head->uncname,
                                 item->direct->head->password)) {

                TRACE_ERROR("Could not copy remote file", FALSE);
                DeleteFile(item->localname);
                gmem_free(hHeap, item->localname, MAX_PATH);
                item->localname = NULL;
            }
        }

        // finished with the rootname+relname
        gmem_free(hHeap, fname, MAX_PATH);

        return(item->localname);
    }

#endif

    /*
     * it's a simple local name - add both relname and name to make
     * the complete filename
     */
    /* avoid the . or .\ at the end of the relname */
    if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
        lstrcat(fname, &item->direct->relname[2]);
    } else {
        lstrcat(fname, &item->direct->relname[1]);
    }
    lstrcat(fname, item->name);

    return(fname);
}



/*
 * free up memory created by a call to dir_getopenname(). This *may*
 * cause the file to be deleted if it was a temporary copy.
 */
void
dir_freeopenname(
                 DIRITEM item,
                 LPSTR openname
                 )
{
    if ((item == NULL) || (openname == NULL)) {
        return;
    }

    if (item->localname != NULL) {
        /* freed in dir_cleardirect */
        return;
    }
    if (item->direct->head->bFile) {
        /* we used the rootname */
        return;
    }

    gmem_free(hHeap, openname, MAX_PATH);

} /* dir_freeopenname */


/*
 * return an open file handle to the file. if it is local,
 * just open the file. if remote, copy the file to a
 * local temp. file and open that
 */
HANDLE
dir_openfile(
             DIRITEM item
             )
{
    LPSTR fname;
    HANDLE fh;


    fname = dir_getopenname(item);
    if (fname == NULL) {
        /* can not make remote copy */
        return INVALID_HANDLE_VALUE;
    }

    fh = CreateFile(fname, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE,
                    0, OPEN_EXISTING, 0, 0);

    dir_freeopenname(item, fname);

    return(fh);
} /* dir_openfile */




/*
 * close a file opened with dir_openfile.
 */
void
dir_closefile(
              DIRITEM item,
              HANDLE fh
              )
{
    CloseHandle(fh);

} /* dir_closefile */



/* Recreate all the checksums and status for di as though
   it had never been looked at before
*/
void
dir_rescanfile(
               DIRITEM di
               )
{
    LPSTR fullname;

    if (di==NULL) return;

    /* start with it invalid, erroneous and zero */
    di->sumvalid = FALSE;
    di->fileerror = TRUE;
    di->checksum = 0;

    fullname = dir_getopenname(di);
#ifdef REMOTE_SERVER
    if ( di->direct->head->bRemote) {
        LPSTR fname;

        fname = gmem_get(hHeap, MAX_PATH);
        lstrcpy(fname, di->direct->head->rootname);
        // relname is empty for remote names - just add
        // the rootname and the name to make a complete
        // remote name, and then make a local copy of this.

        /* avoid the . or .\ at the start of the relname */
        if (*CharPrev(fname, fname+lstrlen(fname)) == '\\') {
            lstrcat(fname, &di->name[2]);
        } else {
            lstrcat(fname, &di->name[1]);
        }
        di->direct->head->hpipe = ss_connect( di->direct->head->server);
        di->fileerror = !ss_checksum_remote( di->direct->head->hpipe, fname
                                             , &(di->checksum), &(di->ft_lastwrite), &(di->size),
                                             &(di->attr));
    } else 
#endif
    {
        di->size = dir_getpathsizeetc(fullname, &(di->ft_lastwrite), &(di->attr));
        di->checksum = dir_getchecksum(di);
    }

    dir_freeopenname(di, fullname);

    di->sumvalid = !(di->fileerror);

} /* dir_rescanfile */


/* return a TRUE iff item has a valid checksum */
BOOL
dir_validchecksum(
                  DIRITEM item
                  )
{
    return (item!=NULL) && (item->sumvalid);
}


BOOL
dir_fileerror(
              DIRITEM item
              )
{
    return (item == NULL) || (item->fileerror);
}


/* return the current file checksum. Open the file and
 * calculate the checksum if it has not already been done.
 */
DWORD
dir_getchecksum(
                DIRITEM cur
                )
{
    LPSTR fullname;

    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }

    if (!cur->sumvalid) {
        /*
         * need to calculate checksum
         */
#ifdef REMOTE_SERVER
        if (cur->direct->head->bRemote) {
            /* complex case - leave till later - for
             * now the protocol always passes checksums to
             * the client.
             */
            cur->checksum = 0; /* which it probably was anyway */
        } else 
#endif
            {

            LONG err;

            fullname = dir_getopenname(cur);
            cur->checksum = checksum_file(fullname, &err);
            if (err==0) {
                cur->sumvalid = TRUE;
                cur->fileerror = FALSE;
            } else {
                cur->fileerror = TRUE;
                return 0;
            }

            dir_freeopenname(cur, fullname);

        }
    }

    return(cur->checksum);
} /* dir_getchecksum */



/* return the file size (set during scanning) - returns 0 if invalid */
long
dir_getfilesize(
                DIRITEM cur
                )
{
    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }


    return(cur->size);
} /* dir_getfilesize */

/* return the file attributes (set during scanning) - returns 0 if invalid */
DWORD
dir_getattr(
            DIRITEM cur
            )
{
    /* check this is a valid item */
    if (cur == NULL) {
        return(0);
    }


    return(cur->attr);
} /* dir_getattr */

/* return the file time (last write time) (set during scanning), (0,0) if invalid */
FILETIME
dir_GetFileTime(
                DIRITEM cur
                )
{
    /* return time of (0,0) if this is an invalid item */
    if (cur == NULL) {
        FILETIME ft;
        ft.dwLowDateTime = 0;
        ft.dwHighDateTime = 0;
        return ft;
    }

    return(cur->ft_lastwrite);

} /* dir_GetFileTime */

/*
 * extract the portions of a name that match wildcards - for now,
 * we only support wildcards at start and end.
 * if pTag is non-null, then the source will have a tag matching it that
 * can also be ignored.
 */
void
dir_extractwildportions(
                       LPSTR pDest,
                       LPSTR pSource,
                       LPSTR pPattern,
                       LPSTR pTag
                       )
{
    int size;

    /*
     * for now, just support the easy cases where there is a * at beginning or
     * end
     */

    if (pPattern[0] == '*') {
        size = lstrlen(pSource) - (lstrlen(pPattern) -1);

    } else if (pPattern[lstrlen(pPattern) -1] == '*') {
        pSource += lstrlen(pPattern) -1;
        size = lstrlen(pSource);
    } else {
        size = lstrlen(pSource);
    }

    if (pTag != NULL) {
        size -= lstrlen(pTag);
    }

    My_mbsncpy(pDest, pSource, size);
    pDest[size] = '\0';
}

/*
 * compares two DIRITEM paths that are both based on wildcards. if the
 * directories match, then the filenames are compared after removing
 * the fixed portion of the name - thus comparing only the
 * wildcard portion.
 */
int
dir_compwildcard(
                DIRLIST dleft,
                DIRLIST dright,
                LPSTR lname,
                LPSTR rname
                )
{
    LPSTR pfinal1, pfinal2;
    char final1[MAX_PATH], final2[MAX_PATH];
    int res;

    /*
     * relnames always have at least one backslash
     */
    pfinal1 = My_mbsrchr(lname, '\\');
    pfinal2 = My_mbsrchr(rname, '\\');

    My_mbsncpy(final1, lname, (size_t)(pfinal1 - lname));
    final1[pfinal1 - lname] = '\0';
    My_mbsncpy(final2, rname, (size_t)(pfinal2 - rname));
    final2[pfinal2 - rname] = '\0';


    /*
     * compare all but the final component - if not the same, then
     * all done.
     */
    res = utils_CompPath(final1,final2);
    if (res != 0) {
        return(res);
    }

    // extract just the wildcard-matching portions of the final elements
    dir_extractwildportions(final1, &pfinal1[1], dleft->pPattern, 0);
    dir_extractwildportions(final2, &pfinal2[1], dright->pPattern, 0);

    return(utils_CompPath(final1, final2));
}

/*
 * compares two DIRLIST items, based on a sequence number rather than filenames.
 */
BOOL dir_compsequencenumber(DIRITEM dleft, DIRITEM dright, int *pcmpvalue)
{
    if (!dleft->sequence && !dright->sequence)
        return FALSE;

    if (!dleft->sequence)
        *pcmpvalue = -1;
    else if (!dright->sequence)
        *pcmpvalue = 1;
    else
        *pcmpvalue = dleft->sequence - dright->sequence;

    return TRUE;
}






/* --- file copying ---------------------------------------------------*/



/* copying files can be done several ways.  The interesting one is
   bulk copy from remote server.  In this case before calling
   dir_copy, call dir_startcopy and after calling dir_copy some
   number of times call dir_endcopy.

   Read client and server to see the shenanigans that then go on there.
   Over here, we just call call ss_startcopy with the server name
   and ss_endcopy.

   dir_startcopy will kick off a dialog with the sumserver, dir_copy
   will send the next filename and dir_endcopy will wait for all the
   files to come through before returning.

*/

/* ss_endcopy returns a number indicating the number of files copied,
   but we may have some local copies too.  We need to count these
   ourselves and add them in
*/

static int nLocalCopies;        /* cleared in startcopy, ++d in copy
                                ** inspected in endcopy
                                */

/* start a bulk copy */
BOOL
dir_startcopy(
              DIRLIST dl
              )
{
    nLocalCopies = 0;
#ifdef REMOTE_SERVER
    if (dl->bRemote) {
        return  ss_startcopy( dl->server,dl->uncname,dl->password);
    } else 
#endif
    {
        return(TRUE);
    }

} /* dir_startcopy */

int
dir_endcopy(
            DIRLIST dl
            )
{
#ifdef REMOTE_SERVER
    int nCopied;

    if (dl->bRemote) {
        nCopied =  ss_endcopy();
        if (nCopied<0) return nCopied;              /* failure count */
        else return  nCopied+nLocalCopies;  /* success count */
    } else 
#endif
    {
        return(nLocalCopies);
    }

} /* dir_endcopy */

/* Build the real path from item and newroot into newpath.
 * Create directories as needed so that it is valid.
 * If mkdir fails, return FALSE, but return the full path that we were
 * trying to make anyway.
 */
BOOL
dir_MakeValidPath(
                  LPSTR newpath,
                  DIRITEM item,
                  LPSTR newroot
                  )
{
    LPSTR relname;
    LPSTR pstart, pdest, pel;
    BOOL bOK = TRUE;

    /*
     * name of file relative to the tree root
     */
    relname = dir_getrelname(item);

    /*
     * build the new pathname by concatenating the new root and
     * the old relative name. add one path element at a time and
     * ensure that the directory exists, creating it if necessary.
     */
    lstrcpy(newpath, newroot);

    /* add separating slash if not already there */
    if (*CharPrev(newpath, newpath+lstrlen(newpath)) != '\\') {
        lstrcat(newpath, "\\");
    }

    pstart = relname;
    while ( (pel = My_mbschr(pstart, '\\')) != NULL) {

        /*
         * ignore .
         */
        if (My_mbsncmp(pstart, ".\\", 2) != 0) {

            pdest = &newpath[lstrlen(newpath)];

            // copy all but the backslash
            // on NT you can create a dir 'fred\'
            // on dos you have to pass 'fred' to _mkdir()
            My_mbsncpy(pdest, pstart, (size_t)(pel - pstart));
            pdest[pel - pstart] = '\0';

            /* create subdir if necessary */
            if (!dir_isvaliddir(newpath)) {
                if (_mkdir(newpath) != 0) {
                    /* note error, but keep going */
                    bOK = FALSE;
                }
            }

            // now insert the backslash
            lstrcat(pdest, "\\");
        }

        /* found another element ending in slash. incr past the \\ */
        pel++;

        pstart = pel;
    }

    /*
     * there are no more slashes, so pstart points at the final
     * element
     */
    lstrcat(newpath, pstart);
    dir_freerelname(item, relname);
    return bOK;
}



/*
 * create a copy of the file, in the new root directory. creates sub-dirs as
 * necessary. Works for local and remote files. For remote files, uses
 * ss_copy_reliable to ensure that the copy succeeds if possible.
 * (Actually does bulk_copy which retries with copy_reliable if need be).
 *
 * returns TRUE for success and FALSE for failure.
 */
BOOL
dir_copy(
         DIRITEM item,
         LPSTR newroot,
         BOOL HitReadOnly,
         BOOL CopyNoAttributes
         )
{
    /*
     * newpath must be static for Win 3.1 so that it is in the
     * data segment (near) and not on the stack (far).
     */
    static char newpath[MAX_PATH];
    BOOL bOK;

    char msg[MAX_PATH+40];
    BY_HANDLE_FILE_INFORMATION bhfi;
    HANDLE hfile;
    DWORD fa;

    /*
     * check that the newroot directory itself exists
     */
    if ((item == NULL) || !dir_isvaliddir(newroot)) {
        return(FALSE);
    }

    if (!dir_MakeValidPath(newpath, item, newroot)) return FALSE;

#ifdef REMOTE_SERVER
    if (item->direct->head->bRemote) {
        /* if the target file already exists and is readonly,
         * warn the user, and delete if ok (remembering to clear
         * the read-only flag
         */
        fa = GetFileAttributes(newpath);
        if ( (fa != -1) &&  (fa & FILE_ATTRIBUTE_READONLY)) {
            wsprintf(msg, LoadRcString(IDS_IS_READONLY),
                     (LPSTR) newpath);

            windiff_UI(TRUE);
            if ((HitReadOnly)
			    || (MessageBox(hwndClient, msg, LoadRcString(IDS_COPY_FILES),
                               MB_OKCANCEL|MB_ICONSTOP) == IDOK)) {
                windiff_UI(FALSE);
                SetFileAttributes(newpath, fa & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(newpath);
            } else {
                windiff_UI(FALSE);
                return FALSE; /* don't overwrite */
            }
        }

        /*
         * we make local copies of the file (item->localname)
         * when the user wants to expand a remotely-compared
         * file. If this has happened, then we can copy the
         * local temp copy rather than the remote.
         */
        bOK = FALSE;
        if (item->localname != NULL) {
            bOK = CopyFile(item->localname, newpath, FALSE);
        }
        if (bOK) {
            ++nLocalCopies;
            if (CopyNoAttributes) {
                // kill the attributes preserved by CopyFile
                SetFileAttributes(newpath, FILE_ATTRIBUTE_NORMAL);
            }
        } else {
            char fullname[MAX_PATH];

            /*
             * in this case we need the full name of the
             * file as it appears to the remote server
             */
            lstrcpy(fullname, item->direct->head->rootname);
            if (!item->direct->head->bFile) {
                /*
                 * append the desired filename only if the
                 * original root was a dir or pattern, not a
                 * file.
                 */
                if (*CharPrev(fullname, fullname+lstrlen(fullname)) == '\\') {
                    lstrcat(fullname, &item->name[2]);
                } else {
                    lstrcat(fullname, &item->name[1]);
                }
            }

            bOK = ss_bulkcopy(item->direct->head->server,
                              fullname, newpath,
                              item->direct->head->uncname,
                              item->direct->head->password);

            /*
             * remember the local copy name so that he can
             * now rapidly expand the file also.
             * It is more difficult to clear the remotely
             * copied attributes as we do not know here
             * when the file copy has completed.
             */
            item->localname = gmem_get(hHeap, MAX_PATH);
            lstrcpy(item->localname, newpath);
            item->bLocalIsTemp = FALSE;
        }
    } else 
#endif
    {
        /* local copy of file */
        LPSTR pOpenName;

        pOpenName = dir_getopenname(item);

        /* if the target file already exists and is readonly,
         * warn the user, and delete if ok (remembering to clear
         * the read-only flag
         */
        bOK = TRUE;
        fa = GetFileAttributes(newpath);
        if ( (fa != -1) &&  (fa & FILE_ATTRIBUTE_READONLY)) {
            wsprintf(msg, LoadRcString(IDS_IS_READONLY),
                     (LPSTR) newpath);

            windiff_UI(TRUE);
            if ((HitReadOnly)
			    || (MessageBox(hwndClient, msg, LoadRcString(IDS_COPY_FILES),
                               MB_OKCANCEL|MB_ICONSTOP) == IDOK)) {
                windiff_UI(FALSE);
                SetFileAttributes(newpath, fa & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(newpath);
                // This of course is an unsafe copy...
                // we have deleted the target file before
                // we copy the new one over the top.
                // Should we omit the DeleteFile ??
            } else {
                windiff_UI(FALSE);
                bOK = FALSE; /* don't overwrite */
                // abort the copy... go and release resources
            }
        }

        if (bOK) {
            bOK = CopyFile(pOpenName, newpath, FALSE);
        }
        // The attributes are copied by CopyFile
        if (bOK) {

            /* having copied the file, now copy the times */
            hfile = CreateFile(pOpenName, GENERIC_READ, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            /*
             * bug in GetFileInformationByHandle causes trap if
             * file is not on local machine (in build 297).
             * code around:
             */
            //NOT NEEDED
            //bhfi.dwFileAttributes = GetFileAttributes(pOpenName);

            GetFileTime(hfile, &bhfi.ftCreationTime,
                        &bhfi.ftLastAccessTime, &bhfi.ftLastWriteTime);
            CloseHandle(hfile);

            // Note: CopyFile does not preserve all the file times...
            hfile = CreateFile(newpath, GENERIC_WRITE, 0, NULL,
                               OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
            SetFileTime(hfile, &bhfi.ftCreationTime,
                        &bhfi.ftLastAccessTime,
                        &bhfi.ftLastWriteTime);
            CloseHandle(hfile);

            if (CopyNoAttributes) {
                // Prepare to kill the attributes...
                SetFileAttributes(newpath, FILE_ATTRIBUTE_NORMAL);
            } else {
                // Attributes were preserved by CopyFile
                //SetFileAttributes(newpath, bhfi.dwFileAttributes);
            }
        }
        if (bOK)
            ++nLocalCopies;

        dir_freeopenname(item, pOpenName);
    }

    return(bOK);
} /* dir_copy */



/*--- internal functions ---------------------------------------- */

/* fill out a new DIRECT for a subdirectory (pre-allocated).
 * init files and dirs lists to empty (List_Create). set the relname
 * of the directory by pre-pending the parent relname if there
 * is a parent, and appending a trailing slash (if there isn't one).
 */
void
dir_dirinit(
            DIRECT dir,
            DIRLIST head,
            DIRECT parent,
            LPSTR name
            )
{
    int size;

    dir->head = head;
    dir->parent = parent;

    /* add on one for the null and one for the trailing slash */
    size = lstrlen(name) + 2;
    if (parent != NULL) {
        size += lstrlen(parent->relname);
    }

    /* build the relname from the parent and the current name
     * with a terminating slash
     */
    dir->relname = gmem_get(hHeap, size);
    if (parent != NULL) {
        lstrcpy(dir->relname, parent->relname);
    } else {
        dir->relname[0] = '\0';
    }

    lstrcat(dir->relname, name);

    if (*CharPrev(dir->relname, dir->relname+lstrlen(dir->relname)) != '\\')
    {
        lstrcat(dir->relname, "\\");
    }

    /* force name to lowercase */
    AnsiLowerBuff(dir->relname, lstrlen(dir->relname));

    dir->diritems = List_Create();
    dir->directs = List_Create();
    dir->bScanned = FALSE;
    dir->pos = DL_FILES;

} /* dir_dirinit */

/* initialise the contents of an (allocated) DIRITEM struct. checksum
 * the file if dir->head->bSum is true
 *
 * if the pSlmTag field is set in the DIRLIST, then we need to extract
 * a particular version of this file. If this is the case, then we
 * need to re-do the size calc as well.
 *
 */
BOOL
dir_fileinit(
             DIRITEM pfile,
             DIRECT dir,
             LPSTR path,
             LPSTR version,
             long size,
             FILETIME ft,
             DWORD attr,
             int *psequence
             )
{
    BOOL bFileOk = TRUE;

    pfile->name = gmem_get(hHeap, lstrlen(path) + 1);
    lstrcpy(pfile->name, path);

    if (version)
    {
        pfile->pSlmTag = gmem_get(hHeap, lstrlen(version) + 1);
        lstrcpy(pfile->pSlmTag, version);
    }

    /* force name to lower case */
    AnsiLowerBuff(pfile->name, lstrlen(path));

    pfile->direct = dir;
    pfile->size = size;
    pfile->ft_lastwrite = ft;
    pfile->attr = attr;

    pfile->sequence = psequence ? *psequence : 0;

    pfile->localname = NULL;
    /*
     * if we requested slm versions of this file, create
     * a temp file containing the version required.
     */
    if (pfile->pSlmTag != NULL) {
        SLMOBJECT hslm;
        LPSTR pName;

        /*
         * get the complete filename and create a slm object for that directory
         */
        pName = dir_getopenname(pfile);


        hslm = SLM_New(pName, 0);
        if (hslm != NULL) {

            char chVersion[MAX_PATH];

            lstrcpy(chVersion, pfile->name);
            lstrcat(chVersion, pfile->pSlmTag);

            pfile->localname = gmem_get(hHeap, MAX_PATH);
            pfile->bLocalIsTemp  = TRUE;

            bFileOk = SLM_GetVersion(hslm, chVersion, pfile->localname);
            SLM_Free(hslm);

            if (!bFileOk)
                return bFileOk;

            if (IsSourceDepot(hslm))
                pfile->size = dir_getpathsizeetc(pfile->localname, NULL, NULL);
            else
                pfile->size = dir_getpathsizeetc(pfile->localname, &(pfile->ft_lastwrite), NULL);
        }
    }


    if (dir->head->bSum) {
        LONG err;
        LPSTR openname;

        openname = dir_getopenname(pfile);
        pfile->checksum = checksum_file(openname, &err);

        if (err!=0) {
            pfile->sumvalid = FALSE;
        } else {
            pfile->sumvalid = TRUE;
        }
        dir_freeopenname(pfile, openname);

    } else {
        pfile->sumvalid = FALSE;
    }

    return bFileOk;
} /* dir_fileinit */



/* is this a valid file or not */
BOOL
dir_isvalidfile(
                LPSTR path
                )
{
    DWORD dwAttrib;

    dwAttrib = GetFileAttributes(path);
    if (dwAttrib == -1) {
        return(FALSE);
    }
    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
        return(FALSE);
    }
    return(TRUE);
} /* dir_isvalidfile */


/* is this a valid directory ? */
BOOL
dir_isvaliddir(
               LPCSTR path
               )
{
    DWORD dwAttrib;

    dwAttrib = GetFileAttributes(path);
    if (dwAttrib == -1) {
        return(FALSE);
    }
    if (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) {
        return(TRUE);
    }
    return(FALSE);
} /* dir_isvaliddir */



/*
 * scan the directory given. add all files to the list
 * in alphabetic order, and add all directories in alphabetic
 * order to the list of child DIRITEMs. If bRecurse is true, go on to
 * recursive call dir_scan for each of the child DIRITEMs
 */
void
dir_scan(
         DIRECT dir,
         BOOL bRecurse
         )
{
    PSTR path, completepath;
    int size;
    DIRECT child;
    BOOL bMore;
    long filesize;
    FILETIME ft;
    BOOL bIsDir;
    LPSTR name;
    HANDLE hFind;
    WIN32_FIND_DATA finddata;

    /* make the complete search string including *.* */
    size = lstrlen(dir->head->rootname);
    size += lstrlen(dir->relname);

    /* add on one null and \*.* */
    // in fact, we need space for pPattern instead of *.* but add an
    // extra few in case pPattern is less than *.*
    if (dir->head->pPattern != NULL) {
        size += lstrlen(dir->head->pPattern);
    }
    size += 5;

    path = LocalLock(LocalAlloc(LHND, size));
    completepath = LocalLock(LocalAlloc(LHND, size));

    if (!path || !completepath)
        goto LSkip;

    /*
     * fill out path with all but the *.*
     */
    lstrcpy(path, dir->head->rootname);

    /* omit the . at the beginning of the relname, and the
     * .\ if there is a trailing \ on the rootname
     */
    if (*CharPrev(path, path+lstrlen(path)) == '\\') {
        lstrcat(path, &dir->relname[2]);
    } else {
        lstrcat(path, &dir->relname[1]);
    }


    if (dir->head->pSlmTag && !SLM_FServerPathExists(path))
    {
        // if server path for source control does not exist, then skip this
        // directory.
        bRecurse = FALSE;
        goto LSkip;
    }



    /*
     * do this scan twice, once for subdirectories
     * (using *.* as the final element)
     * and the other for files (using the pattern or *.* if none)
     */

    lstrcpy(completepath, path);
    lstrcat(completepath, "*.*");


    /*
     * scan for all subdirectories
     */

    hFind = FindFirstFile(completepath, &finddata);
    bMore = (hFind != INVALID_HANDLE_VALUE);

    while (bMore) {

        bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        name = (LPSTR) &finddata.cFileName;
        filesize = finddata.nFileSizeLow;     // dead code - ???
        if (bIsDir) {
            if ( (lstrcmp(name, ".") != 0) &&
                 (lstrcmp(name, "..") != 0) &&
                 (TrackSlmFiles || (_stricmp(name, "slm.dif") != 0)) ) {

                if (dir->head->pOtherDirList == NULL) {
                    dir_adddirect(dir, name);
                } else {
                    char otherName[MAX_PATH+1];
                    strcpy(otherName, dir_getrootpath(dir->head->pOtherDirList));
                    if (otherName[strlen(otherName)-1] == '\\') {
                        strcat(otherName, &dir->relname[2]);
                    } else {
                        strcat(otherName, &dir->relname[1]);
                    }
                    strcat(otherName, name);
                    if (dir_isvaliddir(otherName)) {
                        dir_adddirect(dir, name);
                    }
                }
            }
        }
        if (bAbort) break;  /* User requested abort */

        bMore = FindNextFile(hFind, &finddata);
    }

    FindClose(hFind);

    /*
     * now do it a second time looking for files
     */
    lstrcpy(completepath, path);
    lstrcat(completepath,
            dir->head->pPattern == NULL ? "*.*" : dir->head->pPattern);

    /* read all file entries in the directory */
    hFind = FindFirstFile(completepath, &finddata);
    bMore = (hFind != INVALID_HANDLE_VALUE);

    while (bMore) {
        if (bAbort) break;  /* user requested abort */

        bIsDir = (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
        name = (LPSTR) &finddata.cFileName;
        filesize = finddata.nFileSizeLow;
        ft = finddata.ftLastWriteTime;
        if (!bIsDir) {
            if ( TrackSlmFiles ||
                 ( (_stricmp(name,"slm.ini") != 0) &&
                   (_stricmp(name,"iedcache.slm") != 0) &&
                   (_stricmp(name,"iedcache.slm.v6") != 0) ) ) {
                dir_addfile(dir, name, dir->head->pSlmTag, filesize, ft, finddata.dwFileAttributes, 0);
            }
        }

        bMore = FindNextFile(hFind, &finddata);
    }

    FindClose(hFind);

LSkip:
    if (path)
        //$ review: (chrisant) is PREfix confused, or is LocalUnlock really
        // unable to deal with NULL?
        LocalUnlock(LocalHandle ( (PSTR) path));
    LocalFree(LocalHandle ( (PSTR) path));
    if (completepath)
        //$ review: (chrisant) is PREfix confused, or is LocalUnlock really
        // unable to deal with NULL?
        LocalUnlock(LocalHandle ( (PSTR) completepath));
    LocalFree(LocalHandle ( (PSTR) completepath));

    dir->bScanned = TRUE;
    dir->pos = DL_FILES;

    if (bRecurse) {
        List_TRAVERSE(dir->directs, child) {
            if (bAbort) break;  /* user requested abort */
            dir_scan(child, TRUE);
        }
    }

} /* dir_scan */


/*
 * add the file 'path' to the list of files in dir, in order.
 *
 * checksum the file if dir->head->bSum  is true
 *
 * (On NT I think the filenames are normally delivered to us in alphabetic order,
 * so it might be quicker to scan the list in reverse order.  Don't change unless
 * and until it's been measured and seen to be significant)
 */
BOOL
dir_addfile(
            DIRECT dir,
            LPSTR path,
            LPSTR version,
            DWORD size,
            FILETIME ft,
            DWORD attr,
            int *psequence
            )
{
    DIRITEM pfile;

    AnsiLowerBuff(path, lstrlen(path));  // needless?

    // when psequence is passed, do not sort the list
    if (!psequence)
    {
        /* The names are often (always?) handed to us in alphabetical order.
           It therefore is traversing the list from the start.  MikeTri
           noticed a marked slowing down after the first few thousand files
           of a large (remote) diff.  Did over 4000 in the first hour, but only
           1500 in the second hour.  Reverse scan seems to fix it.
        */
#define SCANREVERSEORDER
#if defined(SCANREVERSEORDER)
        List_REVERSETRAVERSE(dir->diritems, pfile) {
            if (utils_CompPath(pfile->name, path) <= 0) {
                break;     /* goes after this one */
            }
        }
        /* goes after pfile, NULL => goes at start */
        pfile = List_NewAfter(dir->diritems, pfile, sizeof(struct diritem));
#else
        List_TRAVERSE(dir->diritems, pfile) {
            if (utils_CompPath(pfile->name, path) > 0) {
                break;    /* goes before this one */
            }
        }
        /* goes before pfile, NULL => goes at end */
        pfile = List_NewBefore(dir->diritems, pfile, sizeof(struct diritem));
#endif
    }
    else
    {
        /* append to end -- psequence implies that we are being called in
         * sequence order and do not need to do any further sorting.
         */
        pfile = List_NewBefore(dir->diritems, NULL, sizeof(struct diritem));
    }


    if (!dir_fileinit(pfile, dir, path, version, size, ft, attr, psequence))
    {
        List_Delete(pfile);
        return FALSE;
    }

    return TRUE;
} /* dir_addfile */


/* add a new directory in alphabetic order on
 * the list dir->directs
 *
 */
void
dir_adddirect(
              DIRECT dir,
              LPSTR path
              )
{
    DIRECT child;
    LPSTR finalel;
    char achTempName[MAX_PATH];

    AnsiLowerBuff(path, lstrlen(path));
    List_TRAVERSE(dir->directs, child) {

        int cmpval;

        /* we need to compare the child name with the new name.
         * the child name is a relname with a trailing
         * slash - so compare only the name up to but
         * not including the final slash.
         */
        finalel = dir_finalelem(child->relname);

        /*
         * we cannot use strnicmp since this uses a different
         * collating sequence to lstrcmpi. So copy the portion
         * we are interested in to a null-term. buffer.
         */
        My_mbsncpy(achTempName, finalel, lstrlen(finalel)-1);
        achTempName[lstrlen(finalel)-1] = '\0';

        cmpval = utils_CompPath(achTempName, path);

#ifdef trace
        {       char msg[600];
            wsprintf( msg, "dir_adddirect: %s %s %s\n"
                      , achTempName
                      , ( cmpval<0 ? "<"
                          : (cmpval==0 ? "=" : ">")
                        )
                      , path
                    );
            if (bTrace) Trace_File(msg);
        }
#endif
        if (cmpval > 0) {

            /* goes before this one */
            child = List_NewBefore(dir->directs, child, sizeof(struct direct));
            dir_dirinit(child, dir->head, dir, path);
            return;
        }
    }
    /* goes at end */
    child = List_NewLast(dir->directs, sizeof(struct direct));
    dir_dirinit(child, dir->head, dir, path);
} /* dir_adddirect */


/* free all memory associated with a DIRECT (including freeing
 * child lists). Don't de-alloc the direct itself (allocated on a list)
 */
void
dir_cleardirect(
                DIRECT dir
                )
{
    DIRITEM pfile;
    DIRECT child;

    /* clear contents of files list */
    List_TRAVERSE(dir->diritems, pfile) {
        gmem_free(hHeap, pfile->name, lstrlen(pfile->name));

        if (pfile->localname) {
            if (pfile->bLocalIsTemp) {
                /*
                 * the copy will have copied the attributes,
                 * including read-only. We should unset this bit
                 * so we can delete the temp file.
                 */
                SetFileAttributes(pfile->localname,
                                  GetFileAttributes(pfile->localname)
                                  & ~FILE_ATTRIBUTE_READONLY);
                DeleteFile(pfile->localname);
            }

            gmem_free(hHeap, pfile->localname, MAX_PATH);
            pfile->localname = NULL;

            if (pfile->pSlmTag)
            {
                gmem_free(hHeap, pfile->pSlmTag, lstrlen(pfile->pSlmTag) + 1);
                pfile->pSlmTag = NULL;
            }
        }
    }
    List_Destroy(&dir->diritems);

    /* clear contents of dirs list (recursively) */
    List_TRAVERSE(dir->directs, child) {
        dir_cleardirect(child);
    }
    List_Destroy(&dir->directs);

    gmem_free(hHeap, dir->relname, lstrlen(dir->relname) + 1);

} /* dir_cleardirect */



/*
 * return a pointer to the final element in a path. note that
 * we may be passed relnames with a trailing final slash - ignore this
 * and return the element before that final slash.
 */
LPSTR
dir_finalelem(
              LPSTR path
              )
{
    LPSTR chp;
    int size;

    /* is the final character a slash ? */
    size = lstrlen(path) - 1;
    if (*(chp = CharPrev(path, path+lstrlen(path))) == '\\') {
            /* find the slash before this */
            while (chp > path) {
                    if (*(chp = CharPrev(path, chp)) == '\\') {
                            /* skip the slash itself */
                            chp++;
                            break;
                    }
            }
            return(chp);
    }
    /* look for final slash */
    chp = My_mbsrchr(path, '\\');
    if (chp != NULL) {
        return(chp+1);
    }

    /* no slash - is there a drive letter ? */
    chp = My_mbsrchr(path, ':');
    if (chp != NULL) {
        return(chp+1);
    }

    /* this is a final-element anyway */
    return(path);

} /* dir_finalelem */



/* find the size of a file given a pathname to it */
long
dir_getpathsizeetc(
                   LPSTR path,
                   FILETIME *pft,
                   DWORD *pattr
                   )
{
    HANDLE fh;
    long size;

    // Don't accidentally treat //depot paths as UNCs
    if (IsDepotPath(path)) return 0;

    fh = CreateFile(path, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
    if (fh == INVALID_HANDLE_VALUE)
    {
        HANDLE hFind;
        WIN32_FIND_DATA finddata;

        hFind = FindFirstFile(path, &finddata);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            return 0;                       // would -1 be better?
        }
        else
        {
            FindClose(hFind);
            if (pft)
                *pft = finddata.ftLastWriteTime;
            if (pattr != NULL)
                *pattr = finddata.dwFileAttributes;
            return finddata.nFileSizeLow;
        }
    }

    size = GetFileSize(fh, NULL);
    if (pft)
        GetFileTime(fh, NULL, NULL, pft);
    if (pattr != NULL)
        *pattr = GetFileAttributes(path);
    CloseHandle(fh);
    return(size);
} /* dir_getpathsize */

/*--- remote functions ---------------------------------------*/

/* separate out the \\server\share name from the beginning of
 * the source path and store in dest. return false if there was
 * no server\share name.
 */
BOOL
dir_parseunc(
             LPSTR source,
             LPSTR dest
             )
{
    LPSTR cp;

    if ((source[0] != '\\') || (source[1] != '\\')) {
        return(FALSE);
    }

    /* find the second slash (between server and share) */
    cp = My_mbschr(&source[2], '\\');
    if (cp == NULL) {
        /* no second slash -> no share name-> error */
        return(FALSE);
    }

    /* find the third slash or end of name */
    cp = My_mbschr(++cp,'\\');
    if (cp == NULL) {
        /* no third slash -> whole string is what we need */
        strcpy(dest, source);
    } else {
        /* copy only up to the slash */
        My_mbsncpy(dest, source, (size_t)(cp - source));
        dest[cp-source] = '\0';
    }
    return(TRUE);
} /* dir_parseunc */

/*
 * communication between remote dialog, password dialog and dir_buildremote
 *
 */
char dialog_server[256];
char dialog_password[256];


/*
 * DialogProc for the dialog that
 * gets the password for a network server.
 *
 * the server name is stored in the module-wide dialog_server,
 * and the password is to be put in dialog_password
 */
INT_PTR
dir_dodlg_passwd(
                 HWND hDlg,
                 UINT message,
                 WPARAM wParam,
                 LPARAM lParam
                 )
{
    static char msg[256];

    switch (message) {

        case WM_INITDIALOG:
            /* set the prompt to ask for the password for
             * the given server
             */
            wsprintf(msg, LoadRcString(IDS_ENTER_PASSWORD), dialog_server);
            SetDlgItemText(hDlg, IDD_LABEL, msg);

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    return(TRUE);

                case IDOK:
                    GetDlgItemText(hDlg, IDD_PASSWORD,
                                   dialog_password, sizeof(dialog_password));
                    EndDialog(hDlg, TRUE);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
} /* dir_dodlg_passwd */

#ifdef REMOTE_SERVER

/* we have had a 'bad password' error.
 * If the path was a UNC name, then ask the user for the password and
 * try a SSREQ_UNC to make the connection with this password first, then
 * retry the scan.
 *
 * return TRUE if we have re-done the scan and *resp contains a response
 * other than BADPASS.
 *
 * return FALSE if we had any errors, or the user cancelled the password
 * dialog, or it was not a UNC name.
 */
BOOL
dir_makeunc(
            DIRLIST dl,
            HANDLE hpipe,
            LPSTR path,
            LONG lCode,
            PSSNEWRESP resp,
            BOOL fDeep
            )
{
    int sz;

    /* separate out the \\server\share name into server */
    if (dir_parseunc(path, dialog_server) == FALSE) {
        /* was not a valid UNC name - sorry */
        return(FALSE);
    }

    windiff_UI(TRUE);
    if (!DialogBox(hInst, "UNC", hwndClient, dir_dodlg_passwd)) {
        windiff_UI(FALSE);
        /* user cancelled dialog box */
        return(FALSE);
    }
    windiff_UI(FALSE);

    /* send the password request */
    if (!ss_sendunc(hpipe, dialog_password, dialog_server)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    /* wait for password response */
    if (!ss_getresponse(hpipe, resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    if (resp->lCode != SSRESP_END) {
        TRACE_ERROR("Connection failed", FALSE);
        return(FALSE);
    }

    /*
     * save the UNC name and password for future queries to this
     * DIRLIST (eg dir_copy)
     */
    sz = strlen(dialog_server);
    dl->uncname = gmem_get(hHeap, sz+1);
    strcpy(dl->uncname, dialog_server);
    sz = strlen(dialog_password);
    dl->password = gmem_get(hHeap, sz+1);
    strcpy(dl->password, dialog_password);


    /* ok - UNC went ok. now re-do the scan request and get the
     * first response.
     */
    if (!ss_sendrequest(hpipe, lCode, path, strlen(path) +1,
                        (fDeep ? INCLUDESUBS:0) ) ) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    if (!ss_getresponse(hpipe, resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    if (resp->lCode == SSRESP_BADPASS) {
        TRACE_ERROR("Cannot access remote files", FALSE);
        return(FALSE);
    }
    return(TRUE);
} /* dir_makeunc */

/*
 * start a scan to a remote server, and put the first item on the list
 *
 * We establish a connection to a remote checksum server, and then
 * request a scan of the path given. If this path requires a password
 * (because it is a UNC path) we prompt for a password.
 *
 * We take the first response (mainly to check the return code to indicate
 * the scan is started ok). We place this as the first file in the list
 * dl->dot->diritems, and return. dl->dot->bScanned is only set to TRUE
 * when the list is completed.  Further responses are picked up in
 * calls to dir_remotenext.
 *
 * return TRUE if we successfully picked up the first file
 */
BOOL
dir_remoteinit(
               DIRLIST dl,
               LPSTR server,
               LPSTR path,
               BOOL fDeep
               )
{
    SSNEWRESP resp;
    int nFiles = 0;
    HANDLE hpipe;
    char msg[MAX_PATH+60];
    DIRITEM pfile;
    LONG lCode;

    /* connect to the server and make the request */
    hpipe = ss_connect(server);
    dl->hpipe = hpipe;

    if (hpipe == INVALID_HANDLE_VALUE) {
        wsprintf(msg, "Cannot connect to %s", server);
        TRACE_ERROR(msg, FALSE);
        return(FALSE);
    }
    lCode = (dl->bSum) ? SSREQ_SCAN : SSREQ_QUICKSCAN;

    if (!ss_sendrequest( hpipe, lCode, path, strlen(path)+1,
                         (fDeep ? INCLUDESUBS:0) ) ) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }

    /* get the first response to see if the request is ok */
    if (!ss_getresponse(hpipe, &resp)) {
        TRACE_ERROR("Server connection lost", FALSE);
        return(FALSE);
    }
    if (resp.lCode == SSRESP_BADPASS) {
        /* check for UNC name and make connection first
         * with user-supplied password
         */
        if (dir_makeunc(dl, hpipe, path, lCode, &resp, fDeep) == FALSE) {
            /* password failed or was not UNC anyway */
            ss_terminate(hpipe);
            return(FALSE);
        }
    }


    switch (resp.lCode) {

        case SSRESP_END:
            /* null list - ok ? */
            TRACE_ERROR("No remote files found", FALSE);
            ss_terminate(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);

        case SSRESP_ERROR:
            if (resp.ulSize!=0) {
                wsprintf( msg, "Checksum server could not read %s win32 code %d"
                          , resp.szFile, resp.ulSize
                        );
            } else
                wsprintf(msg, "Checksum server could not read %s", resp.szFile);
            TRACE_ERROR(msg, FALSE);

            /* error as first response means we are getting a null list -
             * close the pipe (without waiting for completion)
             * and abort this scan.
             */
            CloseHandle(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);


        case SSRESP_CANTOPEN:
            /* Can see a file, but it's unreadable */
            /* alloc a new item at end of list */
            pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

            /* make copy of lowercased filename */
            pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
            lstrcpy(pfile->name, resp.szFile);
            AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

            // mark the file as having an error
            pfile->fileerror = TRUE;

            pfile->direct = dl->dot;
            pfile->size = resp.ulSize;
            pfile->ft_lastwrite = resp.ft_lastwrite;
            pfile->checksum = resp.ulSum;
            pfile->sumvalid = FALSE;
            pfile->localname = NULL;

            break;

        case SSRESP_FILE:
            /* alloc a new item at end of list */
            pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

            /* make copy of lowercased filename */
            pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
            lstrcpy(pfile->name, resp.szFile);
            AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

            pfile->direct = dl->dot;
            pfile->size = resp.ulSize;
            pfile->ft_lastwrite = resp.ft_lastwrite;
            pfile->checksum = resp.ulSum;
            pfile->sumvalid = dl->bSum;

            // no errors yet
            pfile->fileerror = FALSE;
            pfile->localname = NULL;

            break;

        case SSRESP_DIR:
            dl->bFile = FALSE;
            break;
        default:
            wsprintf(msg, "Bad code from checksum server:%d", resp.lCode);
            TRACE_ERROR(msg, FALSE);

            /* error as first response means we are getting a null list -
             * close the pipe (without waiting for completion)
             * and abort this scan.
             */
            CloseHandle(dl->hpipe);
            dl->dot->bScanned = TRUE;
            return(FALSE);

    }
    return(TRUE);
} /* dir_remoteinit */

/*
 * return the next diritem on the list, for a remote list.
 *
 * if there are any on the list, pass the next after cur (or the first if
 * cur is NULL). If at end of list, and bScanned is not true, try to
 * get another response from the remote server.
 */
DIRITEM
dir_remotenext(
               DIRLIST dl,
               DIRITEM cur
               )
{
    DIRITEM pfile;
    SSNEWRESP resp;

    if (dl == NULL) {
        return(NULL);
    }

    /* are there any more on the list ? */
    if (cur == NULL) {
        pfile = List_First(dl->dot->diritems);
    } else {
        pfile = List_Next(cur);
    }
    if (pfile != NULL) {
        return(pfile);
    }

    if (dl->dot->bScanned) {
        /* we have completed the scan - no more to give */
        return(NULL);
    }

    for (;;) {
        /* repeat until  we get a file that is interesting or
         * hit the end of the list
         */
        if (bAbort) return NULL;  /* user requested abort */

        if (!ss_getresponse(dl->hpipe, &resp)) {
            TRACE_ERROR("checksum server connection lost", FALSE);
            dl->dot->bScanned = TRUE;
            return(NULL);
        }

        switch (resp.lCode) {

            case SSRESP_END:
                /* end of scan */
                ss_terminate(dl->hpipe);
                dl->dot->bScanned = TRUE;
                return(NULL);

            case SSRESP_ERROR:
            case SSRESP_CANTOPEN:
                /* alloc a new item at end of list */
                /* same as next case now except sumvalid is FALSE
                 * and fileerror is true
                 */
                pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

                /* make copy of lowercased filename */
                pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
                lstrcpy(pfile->name, resp.szFile);
                AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

                pfile->direct = dl->dot;
                pfile->size = resp.ulSize;
                pfile->ft_lastwrite = resp.ft_lastwrite;
                pfile->checksum = resp.ulSum;
                pfile->sumvalid = FALSE;
                pfile->fileerror = TRUE;
                pfile->localname = NULL;

                return(pfile);
            case SSRESP_FILE:
                /* alloc a new item at end of list */
                pfile = List_NewLast(dl->dot->diritems, sizeof(struct diritem));

                /* make copy of lowercased filename */
                pfile->name = gmem_get(hHeap, lstrlen(resp.szFile)+1);
                lstrcpy(pfile->name, resp.szFile);
                AnsiLowerBuff(pfile->name, lstrlen(pfile->name));

                pfile->direct = dl->dot;
                pfile->size = resp.ulSize;
                pfile->ft_lastwrite = resp.ft_lastwrite;
                pfile->checksum = resp.ulSum;
                pfile->sumvalid = dl->bSum;
                pfile->fileerror = FALSE;
                pfile->localname = NULL;

                return(pfile);

            case SSRESP_DIR:
                dl->bFile = FALSE;
                break;
        }
    }
    // return(NULL); - unreachable!
} /* dir_remotenext */

#endif

/* ---- helpers ----------------------------------------------------------- */

BOOL iswildpath(LPCSTR pszPath)
{
    if (strchr(pszPath, '*') || strchr(pszPath, '?'))
        return TRUE;

    if (!(pszPath[0] && pszPath[0] == '/' && pszPath[1] && pszPath[1] == '/'))
    {
        DWORD dw;

        dw = GetFileAttributes(pszPath);
        if (dw != (DWORD)-1 && (dw & FILE_ATTRIBUTE_DIRECTORY))
            return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\section.c ===
/*
 * section.c
 *
 * manage sections of lines, and lists of sections.
 *
 * a section is a data type that represents a contiguous block of lines
 * of the same state (all unmatched, or all matched to a contiguous block of
 * lines). A section can link up matching lines within the section.
 *
 * section list functions can make and match lists of sections from lists of
 * lines, and create a composite list by combining sections from two lists
 * to create a list that 'best represents' the similarities and differences
 * between the two lists of lines.
 *
 * Assumptions: the lines passed in are on a list (can be traversed with
 *   List_Next() etc. Line numbering using the section_get*basenr()
 *   functions work only if lines are numbered sequentially in ascending order.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>

#include <tree.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "section.h"

#ifdef trace
extern BOOL bTrace;  /* in windiff.c.  Read only here */
#endif //trace

/*
 * a section handle (SECTION) is a pointer to one of these structures
 */
struct section {
        LINE first;             /* first line in section */
        LINE last;              /* last line in section */

        BOOL bDiscard;          /* true if not alloc-ed on list */

        SECTION link;           /* we match this section */
        SECTION correspond;     /* we correspond to this section, but
                                 * don't match it
                                 */

        int state;              /* compare state for section */

        int leftbase;           /* nr in original left list of first line*/
        int rightbase;          /* nr in original right list of first line*/
};

/* --- function prototypes ------------------------------------------*/

TREE section_makectree(SECTION sec);
BOOL section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2);



/*-- external functions ------------------------------------------------- */

/*
 * make a new section, given handles to a first and last line.
 *
 * a section must be at least one line long. The lines passed in must be
 * on a list in order.
 *
 * if the list parameter is non-null, we will allocate the section struct
 * on the list. otherwise we will alloc it from gmem_get(hHeap). We remember
 * this in the bDiscard flag for section_delete, so that we only
 * hand back to gmem_free memory that we got.
 */
SECTION
section_new(LINE first, LINE last, LIST list)
{
        SECTION sec;

        /* alloc the sec and remember where we alloc-ed it */
        if (list)
        {
            sec = (SECTION) List_NewLast(list, sizeof(struct section));
            if (!sec)
                return NULL;
            sec->bDiscard = TRUE;
        }
        else
        {
            sec = (SECTION) gmem_get(hHeap, sizeof(struct section));
            if (!sec)
                return NULL;
            sec->bDiscard = FALSE;
        }

        sec->first = first;
        sec->last = last;
        sec->link = NULL;
        sec->correspond = NULL;
        sec->state = 0;
        sec->leftbase = 1;
        sec->rightbase = 1;

        return(sec);
}

/*
 * discard a section. free all associated memory (not the line list).
 * free up the section itself if it was not alloc-ed on a list.
 */
void
section_delete(SECTION section)
{
        if (section->bDiscard) {
                gmem_free(hHeap, (LPSTR) section, sizeof(struct section));
        }
}




/*
 * match up two sections: match all lines that
 * are unique and identical between the two sections.
 *
 * we use a tree of line handles, keyed by the line hash code. We use a
 * ctree, which keeps a count for multiple identical keys. This allows
 * us to rapidly find lines that are unique within this section.
 * We build two of these trees (one for each line list). For each line
 * that is unique in both trees, we attempt to link the lines.
 *
 * we also attempt to link the first and last line of the section.
 *
 * for each line we successfully link, we spread up and down from
 * this anchor point attempting to link lines.
 *
 * we return true if we linked any lines
 *
 * This routine may be called more than once on the same list of lines.
 * In matching lines we want to find unique, *unmatched* lines: so we only
 * insert lines into the ctree if they are currently unlinked.
 *
 * ReSynch means accept lines which occur AT LEAST once on each side rather than
 * EXACTLY once on each side.  In this case we associate the first occurrence
 * on one side with the first occurrence onthe other.
 *
 * We might ideally keep track of which sections match dubiously and use
 * this to resolve which sections we treat as matched and which as moved
 * when we are forced to make a choice.  Here we are only making links
 * between LINES, not sections, so it makes it a bit tricky.
 */
BOOL
section_match(SECTION sec1, SECTION sec2, BOOL ReSynch)
{
        TREE ctleft, ctright;
        LINE line, line2;
        BOOL bLinked = FALSE;


        if ((sec1 == NULL) || (sec2 == NULL)) {
                return(FALSE);
        }

        if ((sec1->first == NULL) || (sec2->first == NULL)) {
                return(FALSE);
        }
        /* ASSERT if first is non-null, so is last */

        /* attempt to link the first line of each file, and
         * if matched, expand as long as we keep matching
         */
        bLinked |= section_expandanchor(sec1, sec1->first, sec2, sec2->first);


        /* build a tree of lines, indexed by the line hashcode.
         * a ctree will hold only the first value of any given key, but
         * it will keep track of the number of items inserted on this key.
         * thus we can keep count of the number of times this line
         * (or at least this hashcode) appears.
         */
        ctleft = section_makectree(sec1);
        ctright = section_makectree(sec2);

        /* for each unlinked line in one list (doesn't matter which), find if
         * it appears once only in each list. if so, link, and expand
         * the link to link lines before and after the matching line
         * as long as they continue to match.
         *
         * If ReSynch is set then accept lines which occur more than once in
         * each file (this matches the first copy in each file of lines which
         * are the same, but are non unique.  Heuristic: if the lines are short
         * (8 chars or fewer) then don't accept them.  It can waste a lot
         * of time matching spurious {, } or blank lines.
         * Ideally we could do with at least 8 non-blank chars.
         * "       }" is still not a good candidate.  Later.  Maybe.
         */
        for (line = sec1->first; line != NULL; line = List_Next(line)) {

                if (  (line_getlink(line) == NULL)
                   && (  ReSynch
                      ?  (  (ctree_getcount(ctleft, line_gethashcode(line)) >= 1)
                         && (ctree_getcount(ctright, line_gethashcode(line)) >= 1)
                         && (line_gettextlen(line) > 8)
                         )
                      :  (  (ctree_getcount(ctleft, line_gethashcode(line)) == 1)
                         && (ctree_getcount(ctright, line_gethashcode(line)) == 1)
                         )
                      )
                   ){

                        /* lines match */
                        line2 = * ((LINE FAR *)ctree_find(ctright,
                                        line_gethashcode(line)));
                        bLinked |= section_expandanchor(sec1, line, sec2, line2);
                }

                if (line == sec1->last) {
                        break;
                }
        }

        /* delete the ctrees */
        ctree_delete(ctleft);
        ctree_delete(ctright);


        /* attempt to link the last lines of each file and
         * expand upwards
         */
        bLinked |= section_expandanchor(sec1, sec1->last, sec2, sec2->last);

        return(bLinked);
} /* section_match */

/* -- accessor functions --------------*/

/*
 * get a handle to the first line in this section
 */
LINE
section_getfirstline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->first);
}

/*
 * return a handle to the last line in a section
 */
LINE
section_getlastline(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->last);
}

/*
 * return a handle to the linked section, if any. A linked section
 * is a section whose lines all match the lines in this section
 */
SECTION
section_getlink(SECTION section)
{
        if (section == NULL) {
                return NULL;
        }
        return(section->link);
}

/*
 * return a handle to the corresponding section (a section which
 * corresponds in position to this one, but whose lines do not match).
 */
SECTION
section_getcorrespond(SECTION section)
{
        if (section == NULL) {
                return(NULL);
        }
        return(section->correspond);
}

/* get the state for this section */
int
section_getstate(SECTION section)
{
        if (section == NULL) {
                TRACE_ERROR("SECTION: null section in getstate call", FALSE);
                return(0);
        }
        return(section->state);
}

/* set the state for this section */
void
section_setstate(SECTION section, int state)
{
        section->state = state;
}

/* return the number of lines in the section. Here we assume that
 * lines in the section are number sequentially in ascending order, and we
 * simply look at the first and last line numbers.
 */
int
section_getlinecount(SECTION section)
{
        if (section->last==NULL && section->first==NULL)
                return 0;   /* the thing below would return 1! */
        if (section->first==NULL || section->last==NULL)
                TRACE_ERROR("SECTION: null first or last (but not both) in getlinecount call", FALSE);

        return(line_getlinenr(section->last) -
                        line_getlinenr(section->first)) + 1;
}

/*
 * -- base line numbers --
 *
 * these functions only apply to sections in the composite list. When creating
 * a composite section, we record the line number of the first line in each
 * of the two sections we built it from. Thus we can calculate the
 * line number of any line in the section in either file it appeared in,
 * by adding the index of the line within the section to the base line
 * number.
 */
int
section_getleftbasenr(SECTION section)
{
        return(section->leftbase);
}

void
section_setleftbasenr(SECTION section, int base)
{
        section->leftbase = base;
}

int
section_getrightbasenr(SECTION section)
{
        return(section->rightbase);
}

void
section_setrightbasenr(SECTION section, int base)
{
        section->rightbase = base;
}


/* --- section list functions -------------------------------------*/

/* Theory of handling blank lines:
|                                      ??? WHERE IS THE BEST PLACE FOR THIS COMMENT ???
|  If ignore_blanks is FALSE then a blank is just another character.
|  If it is TRUE then we will normally include unmatched blanks in whatever
|  section is surrounding them.  It would be nice if we could arrange to
|  never have a section that is only unmatched blanks, but (at least at
|  the start of the file) it can happen.  Tough.
|
|  Note that there are two DIFFERENT blank handling techniques:
|  In the first phase of the comparison when we are just trying to match up
|  lines, we skip over blank lines both forwards and backwards from an anchor.
|  When we are making real sections for display we only go forwards.
|  This results in a possible anomaly at the top of the whole file where
|  there could be some blanks which do not match and which can only possibly
|  be described as the start of a section.
|  For this reason, we label the sections with their state as early as possible
|  and go by that rather than by the presence or absence of link fields.
|  (It takes some scanning to find a link.  The first line in the section
|  could be a blank).
*/


/* return a LINE which is the last line in an unmatched section
   containing (probably starting with) Line.
   Note that it does not necessarily make progress.

   As noted above, even if blank lines are being ignored, we don't
   mind tagging them onto the end of an already unmatching section.
   This means we carry on until we find the first real link
*/
LINE FindEndOfUnmatched(LINE line)
{
        LINE next;

        for (; ; )
        {       next = List_Next(line);
                if (next==NULL) return line;
                if (line_getlink(next)!=NULL) return line;
                line = next;
        }
} /* FindEndOfUnmatched */


/* An ignorable line is a blank line with no link and ignore_blanks set

   Given that line is initially not NULL and not ignorable:
   If line is the last line in the list then return NULL
   Else If ignore_blanks is FALSE then return the next line after line
   else return next line which has a link or which is non-blank.
   If there is no such line then return the last line in the list.

   Note that this does always make progress (at the cost of
   sometimes returning NULL).
*/
LINE NextNonIgnorable(LINE line)
{       LINE next;
        if (  line_getlink(line)==NULL
           && ! (ignore_blanks && line_isblank(line))
           )
                TRACE_ERROR("!!Bad call to NextNonIgnorable!!", FALSE);

        next = List_Next(line);
        if (next==NULL) return NULL;
        for (; ; ) {
                line = next;
                if (  line_getlink(line)!=NULL) return line;
                if (! ignore_blanks)            return line;
                if (! line_isblank(line))       return line;
                next = List_Next(line);
                if (next==NULL) return line;
        }
} /* NextNonIgnorable */


/* Given that line is either linked or an ignorable blank:
   Return a LINE which is the last line in a matched section
   containing (probably starting with) line.
   This could mean returning the line we were given.

   If the lines linked to are not consecutive then the section ends.
   If blanks are being ignored, then any blank line is deemed
   to match (even if it doesn't match).  In this case we need the
   links of the lines before and after the blanks to be consecutive
   in order to carry on.  There could be blank lines on either or both
   ends of the links.
*/
LINE FindEndOfMatched(LINE line)
{
        LINE next;              /* next non-ignored or linked line */
        LINE nextlink;          /* next in other file */

        /* The basic algorithm is to set up next and nextlink to point to
           candidate lines.  Examine them.  If they are good then step
           on to them, else return the line one before.
           There are confusion factors associated with the beginning and
           end of the file.
        */


        if (line==NULL) TRACE_ERROR("FindEndOfMatched called with NULL", FALSE);

        /* ASSERT( line is either an ignorable blank or else is linked) */

        /* As a section (at least at the start of the file) might start
           with an ignored non-linked blank line, first step over any such
        */
        if( line_getlink(line)==NULL && line_isblank(line) ) {
                next = NextNonIgnorable(line);

                /* There are unfortunately 6 cases to deal with
                   * marks where next will be. * against eof means next==NULL
                   blank(s) refer to ignorable unlinked blanks.
                          A         B        C        D        E        F
                   line-> xxxxx     xxxxx    xxxxx    xxxxx    xxxxx    xxxxx
                         *unlinked  blanks  *linked   blanks  *eof     *blanks
                                   *unlinked         *linked            eof

                   next could be:

                      null - case E => return line
                      unlinked ignorable blank - case F => return that blank line
                      unlinked other - cases A,B return prev(that unlinked line)
                      linked - cases C,D continue from that linked line
                */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                /*TRACE_ERROR("FindEndOfMatched found an all blank section", FALSE);*/
                                return next;
                        }
                        return List_Prev(next);
                }

                line = next;
        }

        /* we have stepped over inital blanks and now do have a link */
        if (line_getlink(line)==NULL)
                TRACE_ERROR("!!FindEndOfMatched -- no link!!", FALSE);

        for ( ; ; ) {

                next = NextNonIgnorable(line);
                /* Same 6 cases - basically same again */
                if (next==NULL) return line;
                if (line_getlink(next)==NULL) {
                        if (ignore_blanks && line_isblank(next)) {
                                /*TRACE_ERROR("FindEndOfMatched found an all blank section.", FALSE);*/
                                return next;
                        }
                        return List_Prev(next);
                }

                nextlink = NextNonIgnorable(line_getlink(line));

                /* WEAK LOOP INVARIANT
                   line is linked.
                   next is the next non-ignorable line in this list after line.
                   nextlink is the next non-ignorable line after link(line)
                                        in the other list (could be NULL etc).
                */
                if (line_getlink(next) != nextlink) return List_Prev(next);

                line = next;
        }
} /* FindEndOfMatched */


/*
 * make a list of sections by traversing a list of lines. consecutive
 * linked lines that are linked to consecutive lines are put in a single
 * section. blocks of unlinked lines are placed in a section.
 * If ignore_blanks is set then we first try to link them as normal.
 * but if they won't link then we just skip over them and keep them
 * in the same section.
 *
 * left must be set TRUE iff the list of lines is a left hand section.
 * returns a handle to a list of sections
 */
LIST
section_makelist(LIST linelist, BOOL left)
{
        LINE line1, line2;
        LIST sections;
        BOOL matched;
        SECTION sect;

        /* make an empty list of sections */
        sections = List_Create();

        /* for each line in the list */

        List_TRAVERSE(linelist, line1) {

                /* is it linked ? */

                if( line_getlink(line1) != NULL
                  || ( ignore_blanks && line_isblank(line1))
                  ) {
                        line2 = FindEndOfMatched(line1);
                        matched = TRUE;
                } else {
                        line2 = FindEndOfUnmatched(line1);
                        matched = FALSE;
                }

                /* create the section and add to list */
                sect = section_new(line1, line2, sections);
                sect->state = (matched ? STATE_SAME
                                       : left ? STATE_LEFTONLY
                                              : STATE_RIGHTONLY
                              );

#ifdef trace
                {       char msg[80];
                        wsprintf( msg
                                , "Created section: lines %d..%d of %s %s\r\n"
                                , line_getlinenr(line1)
                                , line_getlinenr(line2)
                                , (left ? "left" : "right")
                                , (matched ? "matching" : "non-matched")
                                );
                        if (bTrace) Trace_File(msg);
                }
#endif

                /* advance to end of section (no-op if 1 line section) */
                line1 = line2;
        }

        return(sections);
} /* section_makelist */



/*
 * delete a list of sections
 *
 * sections have no dangling pointers, so all we do is delete the list
 */
void
section_deletelist(LIST sections)
{
        List_Destroy(&sections);
}

/* Return the first line in the range first..last
   which has a link.  Return last if none of them have a link.
   List_Next must lead from first to last eventually.
   It is legit for last to be NULL.
*/
LINE FindFirstWithLink(LINE first, LINE last)
{
        /* The strategy of including blanks on the ENDS of sections rather
           than the start of new sections will mean that this function
           usually strikes gold immediately.  A file with a leading
           blank section is its raison d'etre.
        */
#ifdef trace
        LINE hold = first;
#endif
        while (line_getlink(first)==NULL && first!=last)
                first = List_Next(first);

        if (line_getlink(first)==NULL) {
#ifdef trace
                char msg[80];
                wsprintf( msg
                        , "???FindFirstWithLink found an unlinked section: %d..%d\r\n"
                        , line_getlinenr(hold)
                        , line_getlinenr(first)
                        );
                if (bTrace) Trace_File(msg);
#endif
        }
        return first;
} /* FindFirstWithLink */


/*
 * match up two lists of sections. establish links between sections
 * that match, and establish 'correspondence' between sections that
 * are in the same place, but don't match.
 *
 * for each pair of corresponding sections, we also call section_match
 * to try and link up more lines.
 *
 * we return TRUE if we made any more links between lines, or false
 * otherwise.
 *
 */
BOOL
section_matchlists(LIST secsleft, LIST secsright, BOOL bDups)
{
        BOOL bLinked = FALSE;
        SECTION sec1, sec2;

        /* match up linked sections - We know whether a section is
           supposed to link from its state, but we don't know what section
           it links to.  Also we can have sections which are defined to
           be matching but actually contain nothing but ignorable
           blank lines
        */

        /*  for each linked section try to find the section  linked to it. */
        List_TRAVERSE(secsleft, sec1) {
                if (sec1->state==STATE_SAME) {
                        LINE FirstWithLink = FindFirstWithLink(sec1->first, sec1->last);
#ifdef trace
                        {       char msg[80];
                                wsprintf( msg
                                        , "matchlists left matching section %d..%d \r\n"
                                        , line_getlinenr(sec1->first)
                                        , line_getlinenr(sec1->last)
                                        );
                                if (bTrace) Trace_File(msg);
                        }
#endif
                        List_TRAVERSE(secsright, sec2) {
                                if ( sec2->state==STATE_SAME
                                   && line_getlink(FirstWithLink)
                                        == FindFirstWithLink(sec2->first, sec2->last)) {
                                            break;
                                }
                        }
                        /* sec2 could be NULL if sec1 is all allowable blanks */
                        if (sec2!=NULL) {
                                sec1->link = sec2;
                                sec2->link = sec1;
#ifdef trace
                                {       char msg[80];
                                        wsprintf( msg
                                                , "matchlists right matching section is %d..%d \r\n"
                                                , line_getlinenr(sec2->first)
                                                , line_getlinenr(sec2->last)
                                                );
                                        if (bTrace) Trace_File(msg);
                                }
#endif
                        }
                }
        }

        /* go through all unmatched sections. Note that we need to complete
         * the link-up of matching sections before this, since we need
         * all the links in place for this to work.
         */

        List_TRAVERSE(secsleft, sec1) {
                SECTION secTemp;

                if (sec1->state == STATE_SAME) {
                        /* skip the linked sections */
                        continue;
                }

                /* check that the previous and next sections, if
                 * they exist, are linked. this should not fail since
                 * two consecutive unlinked sections should be made into
                 * one section
                 */
                secTemp = List_Prev(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        TRACE_ERROR("consecutive unlinked sections", FALSE);
                        continue;
                }
                secTemp = List_Next(sec1);
                if (secTemp && secTemp->state!= STATE_SAME) {
                        TRACE_ERROR("consecutive unlinked sections.", FALSE);
                        continue;
                }

                /* find the section that corresponds to this - that is, the
                 * section following the section linked to our previous section.
                 * we could be at beginning or end of list.
                 */
                if (List_Prev(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Prev(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Next(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }

                        /* check that the section after these are linked
                         * to each other (or both are at end of list).
                         */
                        if (List_Next(sec1) != NULL) {

                                if (section_getlink(List_Next(sec1)) !=
                                    List_Next(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Next(sec2) != NULL) {
                                        continue;
                                }
                        }

                } else if (List_Next(sec1) != NULL) {
                        SECTION secOther;
                        secOther = section_getlink(List_Next(sec1));
                        if (secOther==NULL)
                                continue;

                        sec2 = List_Prev(secOther);

                        /* check this section is not linked */
                        if ((sec2 == NULL) || (section_getlink(sec2) != NULL)) {
                                continue;
                        }

                        /* check that the section before these are linked
                         * to each other (or both are at start of list).
                         */
                        if (List_Prev(sec1) != NULL) {

                                if (section_getlink(List_Prev(sec1)) !=
                                    List_Prev(sec2)) {
                                        continue;
                                }
                        } else {
                                if (List_Prev(sec2) != NULL) {
                                        continue;
                                }
                        }
                } else {
                        /* there must be at most one section in each
                         * file, and they are unmatched. make these correspond.
                         * (Though I don't think this would ever do anything except
                         * waste time by trying to link that which has already failed)
                         * ???
                         */
                        sec2 = List_First(secsright);
                }


                /* make the correspondence links
                 * we will want these for  zebra striping
                 */
                if ((sec1 != NULL) && (sec2 != NULL)) {
                        sec1->correspond = sec2;
                        sec2->correspond = sec1;
                }

#ifdef trace
                {       // This is commented out because it CAN trap (and will
                        // on the EMPTY test case in test.a and test.b
                        //char msg[80];
                        //wsprintf( msg
                        //      , "recursive section_match %d..%d <-> %d..%d\r\n"
                        //      , line_getlinenr(sec1->first)
                        //      , line_getlinenr(sec1->last)
                        //      , line_getlinenr(sec2->first)
                        //      , line_getlinenr(sec2->last)
                        //      );
                        //if (bTrace) Trace_File(msg);
                }
#endif

                /* attempt to link up lines */
                if (section_match(sec1, sec2, bDups)) {
                        bLinked = TRUE;
                }
        }

        return(bLinked);
} /* section_matchlists */

/*
 * add a section to the composite list. called from makecomposites
 * to copy a section, add it to the composite list and set the state,
 * leftbase and rightbase.   Note that the state could be STATE_SAME
 * with a NULL section on the left.  May NOT call with STATE_SAME and
 * a NULL right section!
 *
 */
void
section_takesection(LIST compo, SECTION left, SECTION right, int state)
{
        SECTION newsec;
        SECTION sec = NULL;

        /* select which section is being output, and change the state
         * to indicate it has been output
         */
        switch(state) {
        case STATE_SAME:
                /* both the same. we mark both as output, and
                 * take the right one.  It is possible that the
                 * left one could be NULL (an ignorable blank section)
                 */
                if (left!=NULL) left->state = STATE_MARKED;
                right->state = STATE_MARKED;
                sec = right;
                break;

        case STATE_LEFTONLY:
        case STATE_MOVEDLEFT:
                sec = left;
                left->state = STATE_MARKED;
                break;

        case STATE_RIGHTONLY:
        case STATE_MOVEDRIGHT:
                sec = right;
                right->state = STATE_MARKED;
                break;
        /* other cases e.g. SIMILARLEFT should not occur! */
        }


        /* create a new section on the list */
        newsec = section_new(sec->first, sec->last, compo);

        newsec->state = state;


        if (left != NULL) {
                newsec->leftbase = line_getlinenr(left->first);
        } else {
                newsec->leftbase = 0;
        }

        if (right != NULL) {
                newsec->rightbase = line_getlinenr(right->first);
        } else {
                newsec->rightbase = 0;
        }

} /* section_takesection */

/********************************************************************/
/* Zebra striping                                                   */
/********************************************************************/
#ifdef trace
static DWORD ZebraTicks = 0; /* total tick count spent hunting for zebras */
#endif

typedef BYTE bitmap[32];   /* 256 bits.  address the ith bit as m[i/8] & (1<<i%8) */

/* MakeMap
   Turn a string into a bitmap showing its character usage.  ANSI only!
   The bit in the map is set if the corresponding character occurs
   at least once anywhere in the string.
*/
void MakeMap(bitmap bm, LPSTR str)
{   int i;
    for (i=0; i<32; ++i)  bm[i] = 0;   /* clear it (yeah, could use memset) */
    for (i=0; str[i]!='\0'; ++i)       /* for each char */
    {   UINT v = ((UINT)str[i]) & 0x000000ff;   /* 0..256, No negatives! */
        bm[v/8] = bm[v/8] | (1<<v%8);
    }
} /* MakeMap */

/* AndMaps
   Set the bit in res whenever the corresponding bit is set
   in both a and b
*/
void AndMaps(bitmap res, bitmap a, bitmap b)
{   int i;
    for (i=0; i<32; ++i)
        res[i] = (char)(a[i] & b[i]);
}

/* OrMaps
   Set the bit in res whenever the corresponding bit is set
   in either a or b
*/
void OrMaps(bitmap res, bitmap a, bitmap b)
{   int i;
    for (i=0; i<32; ++i)
        res[i] = (char)(a[i] | b[i]);
}

/* BitsInMap
   return the number of bits set on in bm
*/
int BitsInMap(bitmap bm)
{   int i;
    int j;
    int cb = 0;                  /* bit count */

    for (i=0; i<32; ++i)         /* for each byte in bm */
    {  for( j=0; j<8; ++j)       /*    for each bit in byte */
       {  if (bm[i] & (1<<j))    /*    if the bit is set  */
              ++cb;
       }
    }
    return cb;
} /* BitsInMap */

/*------------------------------------------------------------------------------
|  Return TRUE iff left and right match fuzzily.
|  Fuzzy matching is implemented as follows.
|
|  Create a bitmap with one bit for each character in the ANSI set.
|  (This is 32 bytes long).  Clear it, and then OR in bits for each
|  character actually found in string one and then do the same again
|  for string two.
|  AND the two bit maps to get the characters which occur in both lines and
|  OR them to get the total number of different characters in either line.
|  Count the number of bits in each and work off the ratio common/total.
|  If this ratio exceeds a magic number of 3/4 then say they fuzzily match.
|
|  You've probably noticed that this is an application for
|           COUNTING THE BITS IN A BYTE!
 -------------------------------------------------------------------------------*/
BOOL LinesMatch(LINE Left, LINE Right)
{   LPSTR LText = line_gettext(Left);
    LPSTR RText = line_gettext(Right);
    bitmap bmLeft;
    bitmap bmRight;
    bitmap bmBoth;
    bitmap bmEither;
    int nBoth;
    int nEither;

    MakeMap(bmLeft, LText);
    MakeMap(bmRight, RText);
    AndMaps(bmBoth, bmLeft, bmRight);
    OrMaps(bmEither, bmLeft, bmRight);
    nBoth = BitsInMap(bmBoth);
    nEither = BitsInMap(bmEither);

    return  (nBoth*4 >= nEither*3);    /* magic ratio is 3/4 */
} /* LinesMatch */


/*
 * add left and right sections to the comnposite list.  These sections
 * do not contain any matching lines, but do correspond, so here is
 * where we can do a fuzzy comparison and decide whether to zebra
 * them or not.
 *
 * If we retain the current structure of the composite list being a
 * list of sections rather than lines, then we might get rather a lot
 * of sections.  Do we care?  We need to build a new section here
 * for every line that we zebra, unpicking the old sections as we do it.
 *
 * At the moment it zebra stripes the lines as long as they keep
 * (fuzzily) matching.  Once there is a mismatch it takes the rest
 * as a block with no attempt to resynch until the next exact match.
 * We could be craftier, but I think we are already getting most of the
 * value from zebra striping.
 */
void TakeTwoSections(LIST compo, SECTION left, SECTION right)
{
        /* Algorithm:
           While there is something on each side,
              if the next lines match
              then take one line from each and make them into sections.
              else take everything that's left
           Finally take everything that's left (occurs if all matched until
                                                one side ran out)
        */

        SECTION NewL;
        SECTION NewR;
        LINE LLine = left->first;      /* first line left to process in left */
        LINE RLine = right->first;     /*   "    "    "   "   "      " right */

#ifdef trace
        DWORD Ticks = GetTickCount();  /* profiling */
#endif

        left->state = STATE_MARKED;
        right->state = STATE_MARKED;

        while(left!=NULL && right !=NULL) {

            if (LinesMatch(LLine, RLine)) {
                    NewL = section_new(LLine, LLine, compo);
                    NewL->state = STATE_SIMILARLEFT;
                    NewL->leftbase = line_getlinenr(LLine);
                    NewL->rightbase = line_getlinenr(RLine);

                    NewR = section_new(RLine, RLine, compo);
                    NewR->state = STATE_SIMILARRIGHT;
                    NewR->leftbase = line_getlinenr(LLine);
                    NewR->rightbase = line_getlinenr(RLine);

                    if (LLine == left->last) left = NULL;  /* done */
                    else LLine = List_Next(LLine);
                    if (RLine == right->last) right = NULL;  /* done */
                    else RLine = List_Next(RLine);
            } else {
                   /* lost synch - take all the rest with no more zebra stuff */
                    NewL = section_new(LLine, left->last, compo);
                    NewL->state = STATE_LEFTONLY;
                    NewL->leftbase = line_getlinenr(LLine);
                    NewL->rightbase = 0;
                    left = NULL;  /* done */

                    NewR = section_new(RLine, right->last, compo);
                    NewR->state = STATE_RIGHTONLY;
                    NewR->rightbase = line_getlinenr(RLine);
                    NewR->leftbase = 0;
                    right = NULL;  /* done */
            }
        }

        if (left!=NULL) {
            NewL = section_new(LLine, left->last, compo);
            NewL->state = STATE_LEFTONLY;
            NewL->leftbase = line_getlinenr(LLine);
            NewL->rightbase = 0;
        }
        if (right!=NULL) {
            NewR = section_new(RLine, right->last, compo);
            NewR->state = STATE_RIGHTONLY;
            NewR->rightbase = line_getlinenr(RLine);
            NewR->leftbase = 0;
        }

#ifdef trace
        Ticks = GetTickCount()-Ticks;
        ZebraTicks += Ticks;
        {   char Msg[80];
            wsprintf(Msg, "Zebra time %d, total zebra time %d\n", Ticks, ZebraTicks);
            Trace_File(Msg);
        }
#endif

} /* TakeTwoSections */

/*
 * make a composite list of sections by traversing a list of sections.
 *
 * return a handle to a list of sections.
 *
 * during this, set state, leftbase and rightbase for sections.
 *
 * This function creates a list that corresponds to the 'best' view
 * of the differences between the two lists. We place sections from the
 * two lists into one composite list. sections that match each other are only
 * inserted once (from the right list). sections that match, but in different
 * positions in the two lists are inserted twice, once in each position, with
 * status to indicate this. unmatched sections are inserted in the correct
 * position.
 *
 * - take sections from the left list until the section is linked to one not
 *   already taken.
 * - then take sections from right until we find a section linked to one not
 *   already taken.
 * - if the two sections waiting are linked to each other, take them both
 *   (once- we take the right one and advance past both).
 *
 * - now we have to decide which to take in place and which to declare
 *   'moved'. consider the case where the only change is that the first line
 *   has been moved to the end. We should take the first line (as a move),
 *   then the bulk of the file (SAME) then the last line (as a move). Hence,
 *   in difficult cases, we take the smaller section first, to ensure that
 *   the larger section is taken as SAME.
 *
 *   to indicate which section has been output, we set the state field
 *   to STATE_MARKED once we have taken it.   States in left and right
 *   lists are of no further interest once we have built the composite.
 *
 *   Up to this point we have worked off the STATE of a section.  By now
 *   all the section links are in place, so we can use them too.
 */
LIST
section_makecomposite(LIST secsleft, LIST secsright)
{
        SECTION left, right;
        LIST compo;

        /* make an empty list for the composite */
        compo = List_Create();

        left = List_First(secsleft);
        right = List_First(secsright);

        while ( (left != NULL) || (right != NULL)) {

                if (left == NULL) {
                        /* no more in left list - take right section */
                        /* is it moved or just unmatched ? */
                        if (right->link == NULL) {
                                section_takesection(compo, NULL, right, STATE_RIGHTONLY);
                                right = List_Next(right);
                        } else {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        }
                } else if (right == NULL) {
                        /* right list empty - must be left next */

                        /* is it moved or just unmatched ? */
                        if (left->link == NULL) {
                                section_takesection(compo, left, NULL, STATE_LEFTONLY);
                                left = List_Next(left);
                        } else {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        }

                } else if (left->state == STATE_LEFTONLY) {
                        /* unlinked section on left */
                        if (left->correspond==right) {
                            TakeTwoSections( compo, left, left->correspond );
                            left = List_Next(left);
                            right = List_Next(right);
                        } else {
                            /* see picture below for when this might occur */
                            section_takesection(compo, left, NULL, STATE_LEFTONLY);
                            left = List_Next(left);
                        }

                } else if (left->link==NULL) {
                        /* This is an ignorable blank section on the left.
                         * We ignore it. (We will take any such from the right)
                         */
                        left = List_Next(left);

                } else if (left->link->state==STATE_MARKED) {
                        /* left is linked to section that is already taken*/
                        section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                        left = List_Next(left);

                } else  if (right->link == NULL) {
                        /* take unlinked section on right
                         * Either unmatched or ignorable blanks
                         */
                        section_takesection(compo, NULL, right, right->state);
                        right = List_Next(right);

                } else if (right->link->state==STATE_MARKED) {
                        /* right is linked to section that's already taken */
                        section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                        right = List_Next(right);

                } else if (left->link == right) {
                        /* sections match */
                        section_takesection(compo, left, right, STATE_SAME);
                        right = List_Next(right);
                        left = List_Next(left);
                } else {
                        /* both sections linked to forward sections
                         * Original idea was to go by section size and
                         * take smallest first as a move so that larger one is
                         * unchanged.  Counter example is test file blanks2
                         *
                         *   Files     Good version    Not so good
                         *  A     A       A---A          A---A
                         *  B-   -A         ->A RR    LL B->
                         *  C | | A         ->A RR    LL C
                         *  D  -+-B       B---B       LL D
                         *  E   | c       C   c       LL E->
                         *  A---  d       D   d          A---A
                         *  A     E       E---E          A---A
                         *  A     A       A->              ->B
                         *  A             A->                c
                         *                A---A              d
                         *                A                ->E
                         *                               A---A
                         *                               A
                         *
                         * A better scheme looks at the distances marked
                         * above as RR and LL and take as moved the block that results
                         * in the shortest such distance.
                         * Let LeftDist = linenr(right->link) - linenr(left)
                         *       i.e. 5 in the example above  (the LL lines)
                         * Let RightDist = linenr(left->link) - linenr(right)
                         *       i.e. 3 in the example above  (the RR lines)
                         *
                         * if LeftDist > RightDist then treat right as moved
                         * and take it first.
                         */
                        if ( line_getlinenr(right->link->first) - line_getlinenr(left->first)
                           > line_getlinenr(left->link->first)  - line_getlinenr(right->first)
                           )
                        {
                                section_takesection(compo, right->link, right, STATE_MOVEDRIGHT);
                                right = List_Next(right);
                        } else {
                                section_takesection(compo, left, left->link, STATE_MOVEDLEFT);
                                left = List_Next(left);
                        }

                }
        }

        return(compo);
} /* section_makecomposite */

typedef LINE (APIENTRY * MOVEPROC)(LINE);

/* Update PLINE by making it point to the first non-blank
   at-or-after from but not after limit.
   If they are all blank then make it point to limit
   If from is non-blank then leave it alone.
   Return TRUE iff PLINE was updated.
   It is legit for limit to be NULL (meaning end of file).
*/
BOOL AbsorbAnyBlanks(LINE * from, LINE limit, MOVEPROC Move)
{       BOOL progress = FALSE;

        while ( (from!=NULL)
              && (line_isblank(*from))
              && (*from!=limit)
              ) {
                *from = Move(*from);
                progress = TRUE;
        }
        return progress;
} /* AbsorbAnyBlanks */


/* given an anchor point (two lines that we think should match),
 * try to link them, and the lines above and below them for as long
 * as the lines can be linked (are the same, are unlinked).
 *
 * return TRUE if we make any links.
 *
 */
BOOL
section_expandanchor(SECTION sec1, LINE line1, SECTION sec2, LINE line2)
{
        /* when a line is matched we set bChanges.  If we notice some
         * blank lines, but do NOT link any new non-blank lines, we
         * do NOT set bChanges.  (If we did it would cause a closed
         * loop as they would get noticed again next time.  line_link
         * only returns TRUE if it is a NEW link).
         * At this stage we are only interested in making links, not in
         * the size of the section that results (that fun comes later).
         * therefore trailing blanks at the end of a section are not
         * interesting and we don't look for them.
         */
        BOOL bChanges = FALSE;
        LINE left, right;

        /* We handle the section limits by using a sentinel which is one
         * past the end of the section.  (If the section ends at the end
         * of the list then the sentinel is NULL).
         */
        LINE leftend, rightend;
        leftend = List_Next(sec1->last);
        rightend = List_Next(sec2->last);

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "expanding anchor at %d<->%d in sections %d..%d <-> %d..%d\r\n"
                        , line_getlinenr(line1)
                        , line_getlinenr(line2)
                        , line_getlinenr(sec1->first)
                        , line_getlinenr(sec1->last)
                        , line_getlinenr(sec2->first)
                        , line_getlinenr(sec2->last)
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        /* null lines shall not match */
        if ((line1 == NULL) || (line2 == NULL)) {
                return(FALSE);
        }

        /* check all lines forward until fail to link (because null,
         * not matching, or already linked).
         * include the passed in anchor point since this has not
         * yet been linked.
         * If blanks are ignorable then skip over any number of whole
         * blank lines.
         */
        left = line1;
        right = line2;
        for (; ; ) {
                if (line_link(left, right) ) {

                        bChanges = TRUE;
                        left = List_Next(left);
                        right = List_Next(right);
                        if (left==leftend || right==rightend) break;
                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Next);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Next);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;
                }
                else break;
        }

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "marched forwards to (the line before) %d<->%d\r\n"
                        , (left==NULL ? 9999 : line_getlinenr(left))
                        , (right==NULL ? 9999 : line_getlinenr(right))
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        /* check all matches going backwards from anchor point
           but only if it was a real anchor  (could have been
           end-of-section/end-of-file and non-matching).
        */
        if (line_getlink(line1)==NULL) return bChanges;

        left = List_Prev(line1);
        right = List_Prev(line2);
        if (left==NULL || right==NULL) return bChanges;

        leftend = List_Prev(sec1->first);
        rightend = List_Prev(sec2->first);

        for (; ; ) {
                if (line_link(left, right)) {

                        bChanges = TRUE;
                        left = List_Prev(left);
                        right = List_Prev(right);
                        if (left == leftend || right == rightend) break;

                }
                else if (ignore_blanks){
                        /* even though no match, maybe an ignorable blank? */

                        BOOL moved = FALSE;
                        moved |= AbsorbAnyBlanks(&left, leftend, (MOVEPROC)List_Prev);
                        moved |= AbsorbAnyBlanks(&right, rightend, (MOVEPROC)List_Prev);
                        if (!moved) break; /* it didn't match and we didn't move on */
                        if (left==leftend || right==rightend) break;

                }
                else break;
        }

#ifdef trace
        {       char msg[120];
                wsprintf( msg, "marched backwards to (the line after) %d<->%d\r\n"
                        , (left==NULL ? 0 : line_getlinenr(left))
                        , (right==NULL ? 0 : line_getlinenr(right))
                        );
                if (bTrace) Trace_File(msg);
        }
#endif

        return(bChanges);
}


/*
 * build a ctree from the lines in the section given
 *
 * remember that we are only interested in the lines that are
 * not already linked.
 *
 * the value we store in the tree is the handle of the line. the key
 * is the line hash code
 */
TREE
section_makectree(SECTION sec)
{
        TREE tree;
        LINE line;

        /* make an empty tree */
        tree = ctree_create(hHeap);

        for (line = sec->first; line != NULL; line = List_Next(line)) {
                if (line_getlink(line) == NULL) {
                        ctree_update(tree, line_gethashcode(line),
                                        &line, sizeof(LINE));
                }
                if (line == sec->last) {
                        break;
                }
        }
        return(tree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\sdapi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for sdapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sdapi_h__
#define __sdapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISDVar_FWD_DEFINED__
#define __ISDVar_FWD_DEFINED__
typedef interface ISDVar ISDVar;
#endif 	/* __ISDVar_FWD_DEFINED__ */


#ifndef __ISDVars_FWD_DEFINED__
#define __ISDVars_FWD_DEFINED__
typedef interface ISDVars ISDVars;
#endif 	/* __ISDVars_FWD_DEFINED__ */


#ifndef __ISDVars2_FWD_DEFINED__
#define __ISDVars2_FWD_DEFINED__
typedef interface ISDVars2 ISDVars2;
#endif 	/* __ISDVars2_FWD_DEFINED__ */


#ifndef __ISDSpecForm_FWD_DEFINED__
#define __ISDSpecForm_FWD_DEFINED__
typedef interface ISDSpecForm ISDSpecForm;
#endif 	/* __ISDSpecForm_FWD_DEFINED__ */


#ifndef __ISDActionUser_FWD_DEFINED__
#define __ISDActionUser_FWD_DEFINED__
typedef interface ISDActionUser ISDActionUser;
#endif 	/* __ISDActionUser_FWD_DEFINED__ */


#ifndef __ISDInputUser_FWD_DEFINED__
#define __ISDInputUser_FWD_DEFINED__
typedef interface ISDInputUser ISDInputUser;
#endif 	/* __ISDInputUser_FWD_DEFINED__ */


#ifndef __ISDResolveUser_FWD_DEFINED__
#define __ISDResolveUser_FWD_DEFINED__
typedef interface ISDResolveUser ISDResolveUser;
#endif 	/* __ISDResolveUser_FWD_DEFINED__ */


#ifndef __ISDClientUser_FWD_DEFINED__
#define __ISDClientUser_FWD_DEFINED__
typedef interface ISDClientUser ISDClientUser;
#endif 	/* __ISDClientUser_FWD_DEFINED__ */


#ifndef __ISDClientApi_FWD_DEFINED__
#define __ISDClientApi_FWD_DEFINED__
typedef interface ISDClientApi ISDClientApi;
#endif 	/* __ISDClientApi_FWD_DEFINED__ */


#ifndef __ISDClientUtilities_FWD_DEFINED__
#define __ISDClientUtilities_FWD_DEFINED__
typedef interface ISDClientUtilities ISDClientUtilities;
#endif 	/* __ISDClientUtilities_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sdapi_0000 */
/* [local] */ 

#ifndef DeclareInterfaceUtil
#define DeclareInterfaceUtil(iface)
#endif

#ifndef IMPL
#define IMPL
#endif

#undef SetPort // winspool.h defines this

#ifdef __cplusplus
    interface ISDVar;
    interface ISDVars;
    interface ISDVars2;
    interface ISDSpecForm;
    interface ISDActionUser;
    interface ISDInputUser;
    interface ISDResolveUser;
    interface ISDClientUser;
    interface ISDClientApi;
    interface ISDClientUtilities;
#else
    typedef interface ISDVar ISDVar;
    typedef interface ISDVars ISDVars;
    typedef interface ISDVars2 ISDVars2;
    typedef interface ISDSpecForm ISDSpecForm;
    typedef interface ISDActionUser ISDActionUser;
    typedef interface ISDInputUser ISDInputUser;
    typedef interface ISDResolveUser ISDResolveUser;
    typedef interface ISDClientUser ISDClientUser;
    typedef interface ISDClientApi ISDClientApi;
    typedef interface ISDClientUtilities ISDClientUtilities;
#endif

enum __MIDL___MIDL_itf_sdapi_0000_0001
    {	SDTT_NONTEXT	= 0,
	SDTT_TEXT	= SDTT_NONTEXT + 1,
	SDTT_UNICODE	= SDTT_TEXT + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0000_v0_0_s_ifspec;

#ifndef __ISDVar_INTERFACE_DEFINED__
#define __ISDVar_INTERFACE_DEFINED__

/* interface ISDVar */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("054D6A99-6FD1-4AE5-AF57-D44A7C62ECE7")
    ISDVar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][retval][out] */ const char **ppszVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteString( 
            /* [string][retval][out] */ const char **ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteCount( 
            /* [retval][out] */ ULONG *pcbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUnicode( 
            /* [retval][out] */ BOOL *pfUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnicodeString( 
            /* [string][retval][out] */ const WCHAR **ppwzValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariant( 
            /* [out] */ VARIANT *pvarValue,
            /* [in] */ DWORD dwCodepage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVar * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISDVar * This,
            /* [string][retval][out] */ const char **ppszVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteString )( 
            ISDVar * This,
            /* [string][retval][out] */ const char **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteCount )( 
            ISDVar * This,
            /* [retval][out] */ ULONG *pcbValue);
        
        HRESULT ( STDMETHODCALLTYPE *IsUnicode )( 
            ISDVar * This,
            /* [retval][out] */ BOOL *pfUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnicodeString )( 
            ISDVar * This,
            /* [string][retval][out] */ const WCHAR **ppwzValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariant )( 
            ISDVar * This,
            /* [out] */ VARIANT *pvarValue,
            /* [in] */ DWORD dwCodepage);
        
        END_INTERFACE
    } ISDVarVtbl;

    interface ISDVar
    {
        CONST_VTBL struct ISDVarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVar_GetName(This,ppszVar)	\
    (This)->lpVtbl -> GetName(This,ppszVar)

#define ISDVar_GetByteString(This,ppszValue)	\
    (This)->lpVtbl -> GetByteString(This,ppszValue)

#define ISDVar_GetByteCount(This,pcbValue)	\
    (This)->lpVtbl -> GetByteCount(This,pcbValue)

#define ISDVar_IsUnicode(This,pfUnicode)	\
    (This)->lpVtbl -> IsUnicode(This,pfUnicode)

#define ISDVar_GetUnicodeString(This,ppwzValue)	\
    (This)->lpVtbl -> GetUnicodeString(This,ppwzValue)

#define ISDVar_GetVariant(This,pvarValue,dwCodepage)	\
    (This)->lpVtbl -> GetVariant(This,pvarValue,dwCodepage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVar_GetName_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const char **ppszVar);


void __RPC_STUB ISDVar_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetByteString_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const char **ppszValue);


void __RPC_STUB ISDVar_GetByteString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetByteCount_Proxy( 
    ISDVar * This,
    /* [retval][out] */ ULONG *pcbValue);


void __RPC_STUB ISDVar_GetByteCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_IsUnicode_Proxy( 
    ISDVar * This,
    /* [retval][out] */ BOOL *pfUnicode);


void __RPC_STUB ISDVar_IsUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetUnicodeString_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const WCHAR **ppwzValue);


void __RPC_STUB ISDVar_GetUnicodeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetVariant_Proxy( 
    ISDVar * This,
    /* [out] */ VARIANT *pvarValue,
    /* [in] */ DWORD dwCodepage);


void __RPC_STUB ISDVar_GetVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0109 */
/* [local] */ 

#define DeclareISDVarMembers(IPURE) \
        STDMETHOD(GetName)(THIS_ const char** ppszVar) IPURE; \
        STDMETHOD(GetByteString)(THIS_ const char** ppszValue) IPURE; \
        STDMETHOD(GetByteCount)(THIS_ ULONG* pcbValue) IPURE; \
        STDMETHOD(IsUnicode)(THIS_ BOOL* pfUnicode) IPURE; \
        STDMETHOD(GetUnicodeString)(THIS_ const WCHAR** ppwzValue) IPURE; \
        STDMETHOD(GetVariant)(THIS_ VARIANT* pvarValue, DWORD dwCodepage) IPURE; \

DeclareInterfaceUtil(ISDVar)

#ifndef __building_SDAPI_DLL
// {054D6A99-6FD1-4AE5-AF57-D44A7C62ECE7}
DEFINE_GUID(IID_ISDVar, 0x54d6a99, 0x6fd1, 0x4ae5, 0xaf, 0x57, 0xd4, 0x4a, 0x7c, 0x62, 0xec, 0xe7);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0109_v0_0_s_ifspec;

#ifndef __ISDVars_INTERFACE_DEFINED__
#define __ISDVars_INTERFACE_DEFINED__

/* interface ISDVars */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVars;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44897D02-B326-43B9-803A-CE72B4FF7C26")
    ISDVars : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVar( 
            /* [string][in] */ const char *pszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarX( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarXY( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarByIndex( 
            /* [in] */ int i,
            /* [string][out] */ const char **ppszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVarsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVars * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVars * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVars * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVar )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarX )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarXY )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarByIndex )( 
            ISDVars * This,
            /* [in] */ int i,
            /* [string][out] */ const char **ppszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        END_INTERFACE
    } ISDVarsVtbl;

    interface ISDVars
    {
        CONST_VTBL struct ISDVarsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVars_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVars_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVars_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVars_GetVar(This,pszVar,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVar(This,pszVar,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarX(This,pszVar,x,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarX(This,pszVar,x,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarXY(This,pszVar,x,y,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarXY(This,pszVar,x,y,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarByIndex(This,i,ppszVar,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarByIndex(This,i,ppszVar,ppszValue,pcbValue,pfIsUnicode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVars_GetVar_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarX_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarXY_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarByIndex_Proxy( 
    ISDVars * This,
    /* [in] */ int i,
    /* [string][out] */ const char **ppszVar,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVars_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0112 */
/* [local] */ 

#define DeclareISDVarsMembers(IPURE) \
        STDMETHOD(GetVar)(THIS_ const char* pszVar, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarX)(THIS_ const char* pszVar, int x, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarXY)(THIS_ const char* pszVar, int x, int y, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarByIndex)(THIS_ int i, const char** ppszVar, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \

DeclareInterfaceUtil(ISDVars)

#ifndef __building_SDAPI_DLL
// {44897D02-B326-43B9-803A-CE72B4FF7C26}
DEFINE_GUID(IID_ISDVars, 0x44897d02, 0xb326, 0x43b9, 0x80, 0x3a, 0xce, 0x72, 0xb4, 0xff, 0x7c, 0x26);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0112_v0_0_s_ifspec;

#ifndef __ISDVars2_INTERFACE_DEFINED__
#define __ISDVars2_INTERFACE_DEFINED__

/* interface ISDVars2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVars2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E6B2697-EB34-4D23-8144-5844B0B5DBE3")
    ISDVars2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVar( 
            /* [string][in] */ const char *pszVar,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarX( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarXY( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarByIndex( 
            /* [in] */ int i,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVars2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVars2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVars2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVars2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVar )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarX )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarXY )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarByIndex )( 
            ISDVars2 * This,
            /* [in] */ int i,
            /* [retval][out] */ ISDVar **ppVar);
        
        END_INTERFACE
    } ISDVars2Vtbl;

    interface ISDVars2
    {
        CONST_VTBL struct ISDVars2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVars2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVars2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVars2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVars2_GetVar(This,pszVar,ppVar)	\
    (This)->lpVtbl -> GetVar(This,pszVar,ppVar)

#define ISDVars2_GetVarX(This,pszVar,x,ppVar)	\
    (This)->lpVtbl -> GetVarX(This,pszVar,x,ppVar)

#define ISDVars2_GetVarXY(This,pszVar,x,y,ppVar)	\
    (This)->lpVtbl -> GetVarXY(This,pszVar,x,y,ppVar)

#define ISDVars2_GetVarByIndex(This,i,ppVar)	\
    (This)->lpVtbl -> GetVarByIndex(This,i,ppVar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVars2_GetVar_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarX_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarXY_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarByIndex_Proxy( 
    ISDVars2 * This,
    /* [in] */ int i,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVars2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0115 */
/* [local] */ 

#define DeclareISDVars2Members(IPURE) \
        STDMETHOD(GetVar)(THIS_ const char* pszVar, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarX)(THIS_ const char* pszVar, int x, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarXY)(THIS_ const char* pszVar, int x, int y, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarByIndex)(THIS_ int i, ISDVar** ppVar) IPURE; \

DeclareInterfaceUtil(ISDVars2)

#ifndef __building_SDAPI_DLL
// {8E6B2697-EB34-4D23-8144-5844B0B5DBE3}
DEFINE_GUID(IID_ISDVars2, 0x8e6b2697, 0xeb34, 0x4d23, 0x81, 0x44, 0x58, 0x44, 0xb0, 0xb5, 0xdb, 0xe3);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0115_v0_0_s_ifspec;

#ifndef __ISDSpecForm_INTERFACE_DEFINED__
#define __ISDSpecForm_INTERFACE_DEFINED__

/* interface ISDSpecForm */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDSpecForm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F01E61AE-FB1B-461C-A020-EB50412F1CC2")
    ISDSpecForm : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSchema( 
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseSpec( 
            /* [in] */ VARIANT *pvarSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatSpec( 
            /* [out] */ VARIANT *pvarSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ const char *pszName,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ const char *pszName,
            /* [in] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDSpecFormVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDSpecForm * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDSpecForm * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDSpecForm * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchema )( 
            ISDSpecForm * This,
            /* [retval][out] */ ISDVars **ppVars);
        
        HRESULT ( STDMETHODCALLTYPE *ParseSpec )( 
            ISDSpecForm * This,
            /* [in] */ VARIANT *pvarSpec);
        
        HRESULT ( STDMETHODCALLTYPE *FormatSpec )( 
            ISDSpecForm * This,
            /* [out] */ VARIANT *pvarSpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ISDSpecForm * This,
            /* [string][in] */ const char *pszName,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ISDSpecForm * This,
            /* [string][in] */ const char *pszName,
            /* [in] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ISDSpecFormVtbl;

    interface ISDSpecForm
    {
        CONST_VTBL struct ISDSpecFormVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDSpecForm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDSpecForm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDSpecForm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDSpecForm_GetSchema(This,ppVars)	\
    (This)->lpVtbl -> GetSchema(This,ppVars)

#define ISDSpecForm_ParseSpec(This,pvarSpec)	\
    (This)->lpVtbl -> ParseSpec(This,pvarSpec)

#define ISDSpecForm_FormatSpec(This,pvarSpec)	\
    (This)->lpVtbl -> FormatSpec(This,pvarSpec)

#define ISDSpecForm_GetValue(This,pszName,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,pszName,pvarValue)

#define ISDSpecForm_SetValue(This,pszName,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,pszName,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDSpecForm_GetSchema_Proxy( 
    ISDSpecForm * This,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDSpecForm_GetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_ParseSpec_Proxy( 
    ISDSpecForm * This,
    /* [in] */ VARIANT *pvarSpec);


void __RPC_STUB ISDSpecForm_ParseSpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_FormatSpec_Proxy( 
    ISDSpecForm * This,
    /* [out] */ VARIANT *pvarSpec);


void __RPC_STUB ISDSpecForm_FormatSpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_GetValue_Proxy( 
    ISDSpecForm * This,
    /* [string][in] */ const char *pszName,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ISDSpecForm_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_SetValue_Proxy( 
    ISDSpecForm * This,
    /* [string][in] */ const char *pszName,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ISDSpecForm_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDSpecForm_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0118 */
/* [local] */ 

#define DeclareISDSpecFormMembers(IPURE) \
        STDMETHOD(GetSchema)(THIS_ ISDVars** ppVars) IPURE; \
        STDMETHOD(ParseSpec)(THIS_ VARIANT* pvarSpec) IPURE; \
        STDMETHOD(FormatSpec)(THIS_ VARIANT* pvarSpec) IPURE; \
        STDMETHOD(GetValue)(THIS_ const char* pszName, VARIANT* pvarValue) IPURE; \
        STDMETHOD(SetValue)(THIS_ const char* pszName, VARIANT* pvarValue) IPURE; \

DeclareInterfaceUtil(ISDSpecForm)

#ifndef __building_SDAPI_DLL
// {F01E61AE-FB1B-461C-A020-EB50412F1CC2}
DEFINE_GUID(IID_ISDSpecForm, 0xf01e61ae, 0xfb1b, 0x461c, 0xa0, 0x20, 0xeb, 0x50, 0x41, 0x2f, 0x1c, 0xc2);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0118_v0_0_s_ifspec;

#ifndef __ISDActionUser_INTERFACE_DEFINED__
#define __ISDActionUser_INTERFACE_DEFINED__

/* interface ISDActionUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDActionUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21D212A9-C2B9-4441-B9A3-DFBA59821BCC")
    ISDActionUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Diff( 
            /* [string][in] */ const char *pszDiffCmd,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [in] */ DWORD eTextual,
            /* [string][in] */ const char *pszFlags,
            /* [string][in] */ const char *pszPaginateCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditForm( 
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditFile( 
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile,
            /* [in] */ DWORD eTextual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            /* [string][in] */ const char *pszMergeCmd,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult,
            /* [in] */ DWORD eTextual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDActionUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDActionUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDActionUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDActionUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Diff )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszDiffCmd,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [in] */ DWORD eTextual,
            /* [string][in] */ const char *pszFlags,
            /* [string][in] */ const char *pszPaginateCmd);
        
        HRESULT ( STDMETHODCALLTYPE *EditForm )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile);
        
        HRESULT ( STDMETHODCALLTYPE *EditFile )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile,
            /* [in] */ DWORD eTextual);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszMergeCmd,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult,
            /* [in] */ DWORD eTextual);
        
        END_INTERFACE
    } ISDActionUserVtbl;

    interface ISDActionUser
    {
        CONST_VTBL struct ISDActionUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDActionUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDActionUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDActionUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDActionUser_Diff(This,pszDiffCmd,pszLeft,pszRight,eTextual,pszFlags,pszPaginateCmd)	\
    (This)->lpVtbl -> Diff(This,pszDiffCmd,pszLeft,pszRight,eTextual,pszFlags,pszPaginateCmd)

#define ISDActionUser_EditForm(This,pszEditCmd,pszFile)	\
    (This)->lpVtbl -> EditForm(This,pszEditCmd,pszFile)

#define ISDActionUser_EditFile(This,pszEditCmd,pszFile,eTextual)	\
    (This)->lpVtbl -> EditFile(This,pszEditCmd,pszFile,eTextual)

#define ISDActionUser_Merge(This,pszMergeCmd,pszBase,pszTheirs,pszYours,pszResult,eTextual)	\
    (This)->lpVtbl -> Merge(This,pszMergeCmd,pszBase,pszTheirs,pszYours,pszResult,eTextual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDActionUser_Diff_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszDiffCmd,
    /* [string][in] */ const char *pszLeft,
    /* [string][in] */ const char *pszRight,
    /* [in] */ DWORD eTextual,
    /* [string][in] */ const char *pszFlags,
    /* [string][in] */ const char *pszPaginateCmd);


void __RPC_STUB ISDActionUser_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_EditForm_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszEditCmd,
    /* [string][in] */ const char *pszFile);


void __RPC_STUB ISDActionUser_EditForm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_EditFile_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszEditCmd,
    /* [string][in] */ const char *pszFile,
    /* [in] */ DWORD eTextual);


void __RPC_STUB ISDActionUser_EditFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_Merge_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszMergeCmd,
    /* [string][in] */ const char *pszBase,
    /* [string][in] */ const char *pszTheirs,
    /* [string][in] */ const char *pszYours,
    /* [string][in] */ const char *pszResult,
    /* [in] */ DWORD eTextual);


void __RPC_STUB ISDActionUser_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDActionUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0121 */
/* [local] */ 

#define DeclareISDActionUserMembers(IPURE) \
        STDMETHOD(Diff)(THIS_ const char* pszDiffCmd, const char* pszLeft, const char* pszRight, DWORD eTextual, const char* pszFlags, const char* pszPaginateCmd) IPURE; \
        STDMETHOD(EditForm)(THIS_ const char* pszEditCmd, const char* pszFile) IPURE; \
        STDMETHOD(EditFile)(THIS_ const char* pszEditCmd, const char* pszFile, DWORD eTextual) IPURE; \
        STDMETHOD(Merge)(THIS_ const char* pszMergeCmd, const char* pszBase, const char* pszTheirs, const char* pszYours, const char* pszResult, DWORD eTextual) IPURE; \

DeclareInterfaceUtil(ISDActionUser)

#ifndef __building_SDAPI_DLL
// {21D212A9-C2B9-4441-B9A3-DFBA59821BCC}
DEFINE_GUID(IID_ISDActionUser, 0x21d212a9, 0xc2b9, 0x4441, 0xb9, 0xa3, 0xdf, 0xba, 0x59, 0x82, 0x1b, 0xcc);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0121_v0_0_s_ifspec;

#ifndef __ISDInputUser_INTERFACE_DEFINED__
#define __ISDInputUser_INTERFACE_DEFINED__

/* interface ISDInputUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDInputUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3696BCC4-FDEB-49F9-9CED-12F4338C2669")
    ISDInputUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InputData( 
            /* [out][in] */ VARIANT *pvarInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prompt( 
            /* [string][in] */ const char *pszPrompt,
            /* [out][in] */ VARIANT *pvarResponse,
            /* [in] */ BOOL fPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptYesNo( 
            /* [string][in] */ const char *pszPrompt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ErrorPause( 
            /* [string][in] */ const char *pszError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDInputUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDInputUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDInputUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDInputUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *InputData )( 
            ISDInputUser * This,
            /* [out][in] */ VARIANT *pvarInput);
        
        HRESULT ( STDMETHODCALLTYPE *Prompt )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszPrompt,
            /* [out][in] */ VARIANT *pvarResponse,
            /* [in] */ BOOL fPassword);
        
        HRESULT ( STDMETHODCALLTYPE *PromptYesNo )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszPrompt);
        
        HRESULT ( STDMETHODCALLTYPE *ErrorPause )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszError);
        
        END_INTERFACE
    } ISDInputUserVtbl;

    interface ISDInputUser
    {
        CONST_VTBL struct ISDInputUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDInputUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDInputUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDInputUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDInputUser_InputData(This,pvarInput)	\
    (This)->lpVtbl -> InputData(This,pvarInput)

#define ISDInputUser_Prompt(This,pszPrompt,pvarResponse,fPassword)	\
    (This)->lpVtbl -> Prompt(This,pszPrompt,pvarResponse,fPassword)

#define ISDInputUser_PromptYesNo(This,pszPrompt)	\
    (This)->lpVtbl -> PromptYesNo(This,pszPrompt)

#define ISDInputUser_ErrorPause(This,pszError)	\
    (This)->lpVtbl -> ErrorPause(This,pszError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDInputUser_InputData_Proxy( 
    ISDInputUser * This,
    /* [out][in] */ VARIANT *pvarInput);


void __RPC_STUB ISDInputUser_InputData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_Prompt_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszPrompt,
    /* [out][in] */ VARIANT *pvarResponse,
    /* [in] */ BOOL fPassword);


void __RPC_STUB ISDInputUser_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_PromptYesNo_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszPrompt);


void __RPC_STUB ISDInputUser_PromptYesNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_ErrorPause_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszError);


void __RPC_STUB ISDInputUser_ErrorPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDInputUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0124 */
/* [local] */ 

#define DeclareISDInputUserMembers(IPURE) \
        STDMETHOD(InputData)(THIS_ VARIANT* pvarInput) IPURE; \
        STDMETHOD(Prompt)(THIS_ const char* pszPrompt, VARIANT* pvarResponse, BOOL fPassword) IPURE; \
        STDMETHOD(PromptYesNo)(THIS_ const char* pszPrompt) IPURE; \
        STDMETHOD(ErrorPause)(THIS_ const char* pszError) IPURE; \

DeclareInterfaceUtil(ISDInputUser)

#ifndef __building_SDAPI_DLL
// {3696BCC4-FDEB-49F9-9CED-12F4338C2669}
DEFINE_GUID(IID_ISDInputUser, 0x3696bcc4, 0xfdeb, 0x49f9, 0x9c, 0xed, 0x12, 0xf4, 0x33, 0x8c, 0x26, 0x69);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0124_v0_0_s_ifspec;

#ifndef __ISDResolveUser_INTERFACE_DEFINED__
#define __ISDResolveUser_INTERFACE_DEFINED__

/* interface ISDResolveUser */
/* [local][unique][uuid][object] */ 


enum __MIDL_ISDResolveUser_0001
    {	MH_SKIP	= 0,
	MH_ACCEPTTHEIRFILE	= MH_SKIP + 1,
	MH_ACCEPTYOURFILE	= MH_ACCEPTTHEIRFILE + 1,
	MH_ACCEPTMERGEDFILE	= MH_ACCEPTYOURFILE + 1
    } ;

EXTERN_C const IID IID_ISDResolveUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0051E40-DB07-4D12-92B5-832C55947039")
    ISDResolveUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AutoResolve( 
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint,
            /* [string][in] */ const char *pszDiffFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDResolveUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDResolveUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDResolveUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDResolveUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *AutoResolve )( 
            ISDResolveUser * This,
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            ISDResolveUser * This,
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint,
            /* [string][in] */ const char *pszDiffFlags);
        
        END_INTERFACE
    } ISDResolveUserVtbl;

    interface ISDResolveUser
    {
        CONST_VTBL struct ISDResolveUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDResolveUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDResolveUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDResolveUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDResolveUser_AutoResolve(This,pVars,pdwMergeHint)	\
    (This)->lpVtbl -> AutoResolve(This,pVars,pdwMergeHint)

#define ISDResolveUser_Resolve(This,pVars,pdwMergeHint,pszDiffFlags)	\
    (This)->lpVtbl -> Resolve(This,pVars,pdwMergeHint,pszDiffFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDResolveUser_AutoResolve_Proxy( 
    ISDResolveUser * This,
    /* [in] */ ISDVars *pVars,
    /* [out][in] */ DWORD *pdwMergeHint);


void __RPC_STUB ISDResolveUser_AutoResolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDResolveUser_Resolve_Proxy( 
    ISDResolveUser * This,
    /* [in] */ ISDVars *pVars,
    /* [out][in] */ DWORD *pdwMergeHint,
    /* [string][in] */ const char *pszDiffFlags);


void __RPC_STUB ISDResolveUser_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDResolveUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0127 */
/* [local] */ 

#define DeclareISDResolveUserMembers(IPURE) \
        STDMETHOD(AutoResolve)(THIS_ ISDVars* pVars, DWORD* pdwMergeHint) IPURE; \
        STDMETHOD(Resolve)(THIS_ ISDVars* pVars, DWORD* pdwMergeHint, const char* pszDiffFlags) IPURE; \

DeclareInterfaceUtil(ISDResolveUser)

#ifndef __building_SDAPI_DLL
// {F0051E40-DB07-4D12-92B5-832C55947039}
DEFINE_GUID(IID_ISDResolveUser, 0xf0051e40, 0xdb07, 0x4d12, 0x92, 0xb5, 0x83, 0x2c, 0x55, 0x94, 0x70, 0x39);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0127_v0_0_s_ifspec;

#ifndef __ISDClientUser_INTERFACE_DEFINED__
#define __ISDClientUser_INTERFACE_DEFINED__

/* interface ISDClientUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D0087D5-C8EB-42A0-AFC8-DFA8B453A9B9")
    ISDClientUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OutputText( 
            /* [size_is][string][in] */ const char *pszText,
            /* [in] */ int cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputBinary( 
            /* [size_is][in] */ const unsigned char *pbData,
            /* [in] */ int cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputInfo( 
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputWarning( 
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszWarning,
            /* [in] */ BOOL fEmptyReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputError( 
            /* [string][in] */ const char *pszError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputStructured( 
            /* [in] */ ISDVars *pVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finished( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *OutputText )( 
            ISDClientUser * This,
            /* [size_is][string][in] */ const char *pszText,
            /* [in] */ int cchText);
        
        HRESULT ( STDMETHODCALLTYPE *OutputBinary )( 
            ISDClientUser * This,
            /* [size_is][in] */ const unsigned char *pbData,
            /* [in] */ int cbData);
        
        HRESULT ( STDMETHODCALLTYPE *OutputInfo )( 
            ISDClientUser * This,
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszInfo);
        
        HRESULT ( STDMETHODCALLTYPE *OutputWarning )( 
            ISDClientUser * This,
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszWarning,
            /* [in] */ BOOL fEmptyReason);
        
        HRESULT ( STDMETHODCALLTYPE *OutputError )( 
            ISDClientUser * This,
            /* [string][in] */ const char *pszError);
        
        HRESULT ( STDMETHODCALLTYPE *OutputStructured )( 
            ISDClientUser * This,
            /* [in] */ ISDVars *pVars);
        
        HRESULT ( STDMETHODCALLTYPE *Finished )( 
            ISDClientUser * This);
        
        END_INTERFACE
    } ISDClientUserVtbl;

    interface ISDClientUser
    {
        CONST_VTBL struct ISDClientUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientUser_OutputText(This,pszText,cchText)	\
    (This)->lpVtbl -> OutputText(This,pszText,cchText)

#define ISDClientUser_OutputBinary(This,pbData,cbData)	\
    (This)->lpVtbl -> OutputBinary(This,pbData,cbData)

#define ISDClientUser_OutputInfo(This,cIndent,pszInfo)	\
    (This)->lpVtbl -> OutputInfo(This,cIndent,pszInfo)

#define ISDClientUser_OutputWarning(This,cIndent,pszWarning,fEmptyReason)	\
    (This)->lpVtbl -> OutputWarning(This,cIndent,pszWarning,fEmptyReason)

#define ISDClientUser_OutputError(This,pszError)	\
    (This)->lpVtbl -> OutputError(This,pszError)

#define ISDClientUser_OutputStructured(This,pVars)	\
    (This)->lpVtbl -> OutputStructured(This,pVars)

#define ISDClientUser_Finished(This)	\
    (This)->lpVtbl -> Finished(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientUser_OutputText_Proxy( 
    ISDClientUser * This,
    /* [size_is][string][in] */ const char *pszText,
    /* [in] */ int cchText);


void __RPC_STUB ISDClientUser_OutputText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputBinary_Proxy( 
    ISDClientUser * This,
    /* [size_is][in] */ const unsigned char *pbData,
    /* [in] */ int cbData);


void __RPC_STUB ISDClientUser_OutputBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputInfo_Proxy( 
    ISDClientUser * This,
    /* [in] */ int cIndent,
    /* [string][in] */ const char *pszInfo);


void __RPC_STUB ISDClientUser_OutputInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputWarning_Proxy( 
    ISDClientUser * This,
    /* [in] */ int cIndent,
    /* [string][in] */ const char *pszWarning,
    /* [in] */ BOOL fEmptyReason);


void __RPC_STUB ISDClientUser_OutputWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputError_Proxy( 
    ISDClientUser * This,
    /* [string][in] */ const char *pszError);


void __RPC_STUB ISDClientUser_OutputError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputStructured_Proxy( 
    ISDClientUser * This,
    /* [in] */ ISDVars *pVars);


void __RPC_STUB ISDClientUser_OutputStructured_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_Finished_Proxy( 
    ISDClientUser * This);


void __RPC_STUB ISDClientUser_Finished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0130 */
/* [local] */ 

#define DeclareISDClientUserMembers(IPURE) \
        STDMETHOD(OutputText)(THIS_ const char* pszText, int cchText) IPURE; \
        STDMETHOD(OutputBinary)(THIS_ const unsigned char* pbData, int cbData) IPURE; \
        STDMETHOD(OutputInfo)(THIS_ int cIndent, const char* pszInfo) IPURE; \
        STDMETHOD(OutputWarning)(THIS_ int cIndent, const char* pszWarning, BOOL fEmptyReason) IPURE; \
        STDMETHOD(OutputError)(THIS_ const char* pszError) IPURE; \
        STDMETHOD(OutputStructured)(THIS_ ISDVars* pVars) IPURE; \
        STDMETHOD(Finished)(THIS) IPURE; \

DeclareInterfaceUtil(ISDClientUser)

#ifndef __building_SDAPI_DLL
// {1D0087D5-C8EB-42A0-AFC8-DFA8B453A9B9}
DEFINE_GUID(IID_ISDClientUser, 0x1D0087D5, 0xc8eb, 0x42a0, 0xaf, 0xc8, 0xdf, 0xa8, 0xb4, 0x53, 0xa9, 0xb9);
#endif
typedef struct _SDVERINFO
    {
    DWORD dwSize;
    DWORD nApiMajor;
    DWORD nApiMinor;
    DWORD nApiBuild;
    DWORD nApiDot;
    DWORD nSrvMajor;
    DWORD nSrvMinor;
    DWORD nSrvBuild;
    DWORD nSrvDot;
    } 	SDVERINFO;



extern RPC_IF_HANDLE __MIDL_itf_sdapi_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0130_v0_0_s_ifspec;

#ifndef __ISDClientApi_INTERFACE_DEFINED__
#define __ISDClientApi_INTERFACE_DEFINED__

/* interface ISDClientApi */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientApi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A81BB025-1174-4BC7-930E-C3158CF87237")
    ISDClientApi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ ISDClientUser *pUI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ SDVERINFO *pver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArg( 
            /* [string][in] */ const char *pszArg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArgv( 
            /* [in] */ int cArgs,
            /* [size_is][string][in] */ const char **ppArgv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [string][in] */ const char *pszFunc,
            /* [in] */ ISDClientUser *pUI,
            /* [in] */ BOOL fStructured) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Final( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDropped( 
            /* [retval][out] */ BOOL *pfDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorString( 
            /* [string][retval][out] */ const char **ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [string][in] */ const char *pszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUser( 
            /* [string][in] */ const char *pszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [string][in] */ const char *pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClient( 
            /* [string][in] */ const char *pszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHost( 
            /* [string][in] */ const char *pszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            /* [string][in] */ const char *pszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinePort( 
            /* [string][in] */ const char *pszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineUser( 
            /* [string][in] */ const char *pszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinePassword( 
            /* [string][in] */ const char *pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineClient( 
            /* [string][in] */ const char *pszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineHost( 
            /* [string][in] */ const char *pszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineAuth( 
            /* [string][in] */ const char *pszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [string][retval][out] */ const char **ppszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUser( 
            /* [string][retval][out] */ const char **ppszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [string][retval][out] */ const char **ppszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClient( 
            /* [string][retval][out] */ const char **ppszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHost( 
            /* [string][retval][out] */ const char **ppszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuth( 
            /* [string][retval][out] */ const char **ppszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiff( 
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszDiffCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileEditor( 
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszEditorCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormEditor( 
            /* [string][retval][out] */ const char **ppszEditorCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMerge( 
            /* [string][retval][out] */ const char **ppszMergeCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPager( 
            /* [string][retval][out] */ const char **ppszPagerCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadIniFile( 
            /* [string][in] */ const char *pszPath,
            /* [in] */ BOOL fReset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientApiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientApi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientApi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISDClientApi * This,
            /* [in] */ ISDClientUser *pUI);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ISDClientApi * This,
            /* [out] */ SDVERINFO *pver);
        
        HRESULT ( STDMETHODCALLTYPE *SetArg )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszArg);
        
        HRESULT ( STDMETHODCALLTYPE *SetArgv )( 
            ISDClientApi * This,
            /* [in] */ int cArgs,
            /* [size_is][string][in] */ const char **ppArgv);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszFunc,
            /* [in] */ ISDClientUser *pUI,
            /* [in] */ BOOL fStructured);
        
        HRESULT ( STDMETHODCALLTYPE *Final )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsDropped )( 
            ISDClientApi * This,
            /* [retval][out] */ BOOL *pfDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorString )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetUser )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszUser);
        
        HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszClient);
        
        HRESULT ( STDMETHODCALLTYPE *SetHost )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszHost);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuth )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *DefinePort )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPort);
        
        HRESULT ( STDMETHODCALLTYPE *DefineUser )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszUser);
        
        HRESULT ( STDMETHODCALLTYPE *DefinePassword )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *DefineClient )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszClient);
        
        HRESULT ( STDMETHODCALLTYPE *DefineHost )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszHost);
        
        HRESULT ( STDMETHODCALLTYPE *DefineAuth )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetUser )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszUser);
        
        HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszHost);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuth )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiff )( 
            ISDClientApi * This,
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszDiffCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileEditor )( 
            ISDClientApi * This,
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszEditorCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormEditor )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszEditorCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetMerge )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszMergeCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetPager )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPagerCmd);
        
        HRESULT ( STDMETHODCALLTYPE *LoadIniFile )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPath,
            /* [in] */ BOOL fReset);
        
        HRESULT ( STDMETHODCALLTYPE *Break )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISDClientApi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **ppvObject);
        
        END_INTERFACE
    } ISDClientApiVtbl;

    interface ISDClientApi
    {
        CONST_VTBL struct ISDClientApiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientApi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientApi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientApi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientApi_Init(This,pUI)	\
    (This)->lpVtbl -> Init(This,pUI)

#define ISDClientApi_GetVersion(This,pver)	\
    (This)->lpVtbl -> GetVersion(This,pver)

#define ISDClientApi_SetArg(This,pszArg)	\
    (This)->lpVtbl -> SetArg(This,pszArg)

#define ISDClientApi_SetArgv(This,cArgs,ppArgv)	\
    (This)->lpVtbl -> SetArgv(This,cArgs,ppArgv)

#define ISDClientApi_Run(This,pszFunc,pUI,fStructured)	\
    (This)->lpVtbl -> Run(This,pszFunc,pUI,fStructured)

#define ISDClientApi_Final(This)	\
    (This)->lpVtbl -> Final(This)

#define ISDClientApi_IsDropped(This,pfDropped)	\
    (This)->lpVtbl -> IsDropped(This,pfDropped)

#define ISDClientApi_GetErrorString(This,ppsz)	\
    (This)->lpVtbl -> GetErrorString(This,ppsz)

#define ISDClientApi_SetPort(This,pszPort)	\
    (This)->lpVtbl -> SetPort(This,pszPort)

#define ISDClientApi_SetUser(This,pszUser)	\
    (This)->lpVtbl -> SetUser(This,pszUser)

#define ISDClientApi_SetPassword(This,pszPassword)	\
    (This)->lpVtbl -> SetPassword(This,pszPassword)

#define ISDClientApi_SetClient(This,pszClient)	\
    (This)->lpVtbl -> SetClient(This,pszClient)

#define ISDClientApi_SetHost(This,pszHost)	\
    (This)->lpVtbl -> SetHost(This,pszHost)

#define ISDClientApi_SetAuth(This,pszAuth)	\
    (This)->lpVtbl -> SetAuth(This,pszAuth)

#define ISDClientApi_DefinePort(This,pszPort)	\
    (This)->lpVtbl -> DefinePort(This,pszPort)

#define ISDClientApi_DefineUser(This,pszUser)	\
    (This)->lpVtbl -> DefineUser(This,pszUser)

#define ISDClientApi_DefinePassword(This,pszPassword)	\
    (This)->lpVtbl -> DefinePassword(This,pszPassword)

#define ISDClientApi_DefineClient(This,pszClient)	\
    (This)->lpVtbl -> DefineClient(This,pszClient)

#define ISDClientApi_DefineHost(This,pszHost)	\
    (This)->lpVtbl -> DefineHost(This,pszHost)

#define ISDClientApi_DefineAuth(This,pszAuth)	\
    (This)->lpVtbl -> DefineAuth(This,pszAuth)

#define ISDClientApi_GetPort(This,ppszPort)	\
    (This)->lpVtbl -> GetPort(This,ppszPort)

#define ISDClientApi_GetUser(This,ppszUser)	\
    (This)->lpVtbl -> GetUser(This,ppszUser)

#define ISDClientApi_GetPassword(This,ppszPassword)	\
    (This)->lpVtbl -> GetPassword(This,ppszPassword)

#define ISDClientApi_GetClient(This,ppszClient)	\
    (This)->lpVtbl -> GetClient(This,ppszClient)

#define ISDClientApi_GetHost(This,ppszHost)	\
    (This)->lpVtbl -> GetHost(This,ppszHost)

#define ISDClientApi_GetAuth(This,ppszAuth)	\
    (This)->lpVtbl -> GetAuth(This,ppszAuth)

#define ISDClientApi_GetDiff(This,eTextual,ppszDiffCmd)	\
    (This)->lpVtbl -> GetDiff(This,eTextual,ppszDiffCmd)

#define ISDClientApi_GetFileEditor(This,eTextual,ppszEditorCmd)	\
    (This)->lpVtbl -> GetFileEditor(This,eTextual,ppszEditorCmd)

#define ISDClientApi_GetFormEditor(This,ppszEditorCmd)	\
    (This)->lpVtbl -> GetFormEditor(This,ppszEditorCmd)

#define ISDClientApi_GetMerge(This,ppszMergeCmd)	\
    (This)->lpVtbl -> GetMerge(This,ppszMergeCmd)

#define ISDClientApi_GetPager(This,ppszPagerCmd)	\
    (This)->lpVtbl -> GetPager(This,ppszPagerCmd)

#define ISDClientApi_LoadIniFile(This,pszPath,fReset)	\
    (This)->lpVtbl -> LoadIniFile(This,pszPath,fReset)

#define ISDClientApi_Break(This)	\
    (This)->lpVtbl -> Break(This)

#define ISDClientApi_Clone(This,riid,ppvObject)	\
    (This)->lpVtbl -> Clone(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientApi_Init_Proxy( 
    ISDClientApi * This,
    /* [in] */ ISDClientUser *pUI);


void __RPC_STUB ISDClientApi_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetVersion_Proxy( 
    ISDClientApi * This,
    /* [out] */ SDVERINFO *pver);


void __RPC_STUB ISDClientApi_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetArg_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszArg);


void __RPC_STUB ISDClientApi_SetArg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetArgv_Proxy( 
    ISDClientApi * This,
    /* [in] */ int cArgs,
    /* [size_is][string][in] */ const char **ppArgv);


void __RPC_STUB ISDClientApi_SetArgv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Run_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszFunc,
    /* [in] */ ISDClientUser *pUI,
    /* [in] */ BOOL fStructured);


void __RPC_STUB ISDClientApi_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Final_Proxy( 
    ISDClientApi * This);


void __RPC_STUB ISDClientApi_Final_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_IsDropped_Proxy( 
    ISDClientApi * This,
    /* [retval][out] */ BOOL *pfDropped);


void __RPC_STUB ISDClientApi_IsDropped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetErrorString_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppsz);


void __RPC_STUB ISDClientApi_GetErrorString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetPort_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPort);


void __RPC_STUB ISDClientApi_SetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetUser_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszUser);


void __RPC_STUB ISDClientApi_SetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetPassword_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPassword);


void __RPC_STUB ISDClientApi_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetClient_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszClient);


void __RPC_STUB ISDClientApi_SetClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetHost_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszHost);


void __RPC_STUB ISDClientApi_SetHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetAuth_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszAuth);


void __RPC_STUB ISDClientApi_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefinePort_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPort);


void __RPC_STUB ISDClientApi_DefinePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineUser_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszUser);


void __RPC_STUB ISDClientApi_DefineUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefinePassword_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPassword);


void __RPC_STUB ISDClientApi_DefinePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineClient_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszClient);


void __RPC_STUB ISDClientApi_DefineClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineHost_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszHost);


void __RPC_STUB ISDClientApi_DefineHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineAuth_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszAuth);


void __RPC_STUB ISDClientApi_DefineAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPort_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPort);


void __RPC_STUB ISDClientApi_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetUser_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszUser);


void __RPC_STUB ISDClientApi_GetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPassword_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPassword);


void __RPC_STUB ISDClientApi_GetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetClient_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszClient);


void __RPC_STUB ISDClientApi_GetClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetHost_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszHost);


void __RPC_STUB ISDClientApi_GetHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetAuth_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszAuth);


void __RPC_STUB ISDClientApi_GetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetDiff_Proxy( 
    ISDClientApi * This,
    /* [in] */ DWORD eTextual,
    /* [string][retval][out] */ const char **ppszDiffCmd);


void __RPC_STUB ISDClientApi_GetDiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetFileEditor_Proxy( 
    ISDClientApi * This,
    /* [in] */ DWORD eTextual,
    /* [string][retval][out] */ const char **ppszEditorCmd);


void __RPC_STUB ISDClientApi_GetFileEditor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetFormEditor_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszEditorCmd);


void __RPC_STUB ISDClientApi_GetFormEditor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetMerge_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszMergeCmd);


void __RPC_STUB ISDClientApi_GetMerge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPager_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPagerCmd);


void __RPC_STUB ISDClientApi_GetPager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_LoadIniFile_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPath,
    /* [in] */ BOOL fReset);


void __RPC_STUB ISDClientApi_LoadIniFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Break_Proxy( 
    ISDClientApi * This);


void __RPC_STUB ISDClientApi_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Clone_Proxy( 
    ISDClientApi * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void **ppvObject);


void __RPC_STUB ISDClientApi_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientApi_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0133 */
/* [local] */ 

#define DeclareISDClientApiMembers(IPURE) \
        STDMETHOD(Init)(THIS_ ISDClientUser* pUI) IPURE; \
        STDMETHOD(GetVersion)(THIS_ SDVERINFO* pver) IPURE; \
        STDMETHOD(SetArg)(THIS_ const char* pszArg) IPURE; \
        STDMETHOD(SetArgv)(THIS_ int cArgs, const char** ppArgv) IPURE; \
        STDMETHOD(Run)(THIS_ const char* pszFunc, ISDClientUser* pUI, BOOL fStructured) IPURE; \
        STDMETHOD(Final)(THIS) IPURE; \
        STDMETHOD(IsDropped)(THIS_ BOOL* pfDropped) IPURE; \
        STDMETHOD(GetErrorString)(THIS_ const char** ppsz) IPURE; \
        STDMETHOD(SetPort)(THIS_ const char* pszPort) IPURE; \
        STDMETHOD(SetUser)(THIS_ const char* pszUser) IPURE; \
        STDMETHOD(SetPassword)(THIS_ const char* pszPassword) IPURE; \
        STDMETHOD(SetClient)(THIS_ const char* pszClient) IPURE; \
        STDMETHOD(SetHost)(THIS_ const char* pszHost) IPURE; \
        STDMETHOD(SetAuth)(THIS_ const char* pszAuth) IPURE; \
        STDMETHOD(DefinePort)(THIS_ const char* pszPort) IPURE; \
        STDMETHOD(DefineUser)(THIS_ const char* pszUser) IPURE; \
        STDMETHOD(DefinePassword)(THIS_ const char* pszPassword) IPURE; \
        STDMETHOD(DefineClient)(THIS_ const char* pszClient) IPURE; \
        STDMETHOD(DefineHost)(THIS_ const char* pszHost) IPURE; \
        STDMETHOD(DefineAuth)(THIS_ const char* pszAuth) IPURE; \
        STDMETHOD(GetPort)(THIS_ const char** ppszPort) IPURE; \
        STDMETHOD(GetUser)(THIS_ const char** ppszUser) IPURE; \
        STDMETHOD(GetPassword)(THIS_ const char** ppszPassword) IPURE; \
        STDMETHOD(GetClient)(THIS_ const char** ppszClient) IPURE; \
        STDMETHOD(GetHost)(THIS_ const char** ppszHost) IPURE; \
        STDMETHOD(GetAuth)(THIS_ const char** ppszAuth) IPURE; \
        STDMETHOD(GetDiff)(THIS_ DWORD eTextual, const char** ppszDiffCmd) IPURE; \
        STDMETHOD(GetFileEditor)(THIS_ DWORD eTextual, const char** ppszEditorCmd) IPURE; \
        STDMETHOD(GetFormEditor)(THIS_ const char** ppszEditorCmd) IPURE; \
        STDMETHOD(GetMerge)(THIS_ const char** ppszMergeCmd) IPURE; \
        STDMETHOD(GetPager)(THIS_ const char** ppszPagerCmd) IPURE; \
        STDMETHOD(LoadIniFile)(THIS_ const char* pszPath, BOOL fReset) IPURE; \
        STDMETHOD(Break)(THIS) IPURE; \
        STDMETHOD(Clone)(THIS_ REFIID riid, void** ppvObject) IPURE; \

DeclareInterfaceUtil(ISDClientApi)

#ifndef __building_SDAPI_DLL
// {A81BB025-1174-4BC7-930E-C3158CF87237}
DEFINE_GUID(IID_ISDClientApi, 0xa81bb025, 0x1174, 0x4bc7, 0x93, 0x0e, 0xc3, 0x15, 0x8c, 0xf8, 0x72, 0x37);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0133_v0_0_s_ifspec;

#ifndef __ISDClientUtilities_INTERFACE_DEFINED__
#define __ISDClientUtilities_INTERFACE_DEFINED__

/* interface ISDClientUtilities */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EFC0F46D-C483-4A70-A7EE-A261D9592ED2")
    ISDClientUtilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CheckMarkers( 
            /* [in] */ ISDVars *pVars,
            /* [retval][out] */ BOOL *pfHasMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve3( 
            /* [in] */ ISDClientUser *pUI,
            /* [string][in] */ const char *aflags,
            /* [string][in] */ const char *dflags,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Diff( 
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [string][in] */ const char *pszFlags,
            /* [in] */ DWORD eForceTextual,
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectType( 
            /* [string][in] */ const char *pszFile,
            /* [out] */ DWORD *peTextual,
            /* [out] */ const char **ppszType,
            /* [in] */ BOOL fServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszValue,
            /* [in] */ BOOL fMachine,
            /* [in] */ const char *pszService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySettings( 
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszService,
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientUtilities * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientUtilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientUtilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *CheckMarkers )( 
            ISDClientUtilities * This,
            /* [in] */ ISDVars *pVars,
            /* [retval][out] */ BOOL *pfHasMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve3 )( 
            ISDClientUtilities * This,
            /* [in] */ ISDClientUser *pUI,
            /* [string][in] */ const char *aflags,
            /* [string][in] */ const char *dflags,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult);
        
        HRESULT ( STDMETHODCALLTYPE *Diff )( 
            ISDClientUtilities * This,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [string][in] */ const char *pszFlags,
            /* [in] */ DWORD eForceTextual,
            /* [retval][out] */ ISDVars **ppVars);
        
        HRESULT ( STDMETHODCALLTYPE *DetectType )( 
            ISDClientUtilities * This,
            /* [string][in] */ const char *pszFile,
            /* [out] */ DWORD *peTextual,
            /* [out] */ const char **ppszType,
            /* [in] */ BOOL fServer);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            ISDClientUtilities * This,
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszValue,
            /* [in] */ BOOL fMachine,
            /* [in] */ const char *pszService);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySettings )( 
            ISDClientUtilities * This,
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszService,
            /* [retval][out] */ ISDVars **ppVars);
        
        END_INTERFACE
    } ISDClientUtilitiesVtbl;

    interface ISDClientUtilities
    {
        CONST_VTBL struct ISDClientUtilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientUtilities_CheckMarkers(This,pVars,pfHasMarkers)	\
    (This)->lpVtbl -> CheckMarkers(This,pVars,pfHasMarkers)

#define ISDClientUtilities_Resolve3(This,pUI,aflags,dflags,pszBase,pszTheirs,pszYours,pszResult)	\
    (This)->lpVtbl -> Resolve3(This,pUI,aflags,dflags,pszBase,pszTheirs,pszYours,pszResult)

#define ISDClientUtilities_Diff(This,pszLeft,pszRight,pszFlags,eForceTextual,ppVars)	\
    (This)->lpVtbl -> Diff(This,pszLeft,pszRight,pszFlags,eForceTextual,ppVars)

#define ISDClientUtilities_DetectType(This,pszFile,peTextual,ppszType,fServer)	\
    (This)->lpVtbl -> DetectType(This,pszFile,peTextual,ppszType,fServer)

#define ISDClientUtilities_Set(This,pszVar,pszValue,fMachine,pszService)	\
    (This)->lpVtbl -> Set(This,pszVar,pszValue,fMachine,pszService)

#define ISDClientUtilities_QuerySettings(This,pszVar,pszService,ppVars)	\
    (This)->lpVtbl -> QuerySettings(This,pszVar,pszService,ppVars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientUtilities_CheckMarkers_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ ISDVars *pVars,
    /* [retval][out] */ BOOL *pfHasMarkers);


void __RPC_STUB ISDClientUtilities_CheckMarkers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Resolve3_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ ISDClientUser *pUI,
    /* [string][in] */ const char *aflags,
    /* [string][in] */ const char *dflags,
    /* [string][in] */ const char *pszBase,
    /* [string][in] */ const char *pszTheirs,
    /* [string][in] */ const char *pszYours,
    /* [string][in] */ const char *pszResult);


void __RPC_STUB ISDClientUtilities_Resolve3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Diff_Proxy( 
    ISDClientUtilities * This,
    /* [string][in] */ const char *pszLeft,
    /* [string][in] */ const char *pszRight,
    /* [string][in] */ const char *pszFlags,
    /* [in] */ DWORD eForceTextual,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDClientUtilities_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_DetectType_Proxy( 
    ISDClientUtilities * This,
    /* [string][in] */ const char *pszFile,
    /* [out] */ DWORD *peTextual,
    /* [out] */ const char **ppszType,
    /* [in] */ BOOL fServer);


void __RPC_STUB ISDClientUtilities_DetectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Set_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ const char *pszVar,
    /* [in] */ const char *pszValue,
    /* [in] */ BOOL fMachine,
    /* [in] */ const char *pszService);


void __RPC_STUB ISDClientUtilities_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_QuerySettings_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ const char *pszVar,
    /* [in] */ const char *pszService,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDClientUtilities_QuerySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientUtilities_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0136 */
/* [local] */ 

#define DeclareISDClientUtilitiesMembers(IPURE) \
        STDMETHOD(CheckMarkers)(THIS_ ISDVars* pVars, BOOL* pfHasMarkers) IPURE; \
        STDMETHOD(Resolve3)(THIS_ ISDClientUser* pUI, const char* aflags, const char* dflags, const char* pszBase, const char* pszTheirs, const char* pszYours, const char* pszResult) IPURE; \
        STDMETHOD(Diff)(THIS_ const char* pszLeft, const char* pszRight, const char* pszFlags, DWORD eForceTextual, ISDVars** ppVars) IPURE; \
        STDMETHOD(DetectType)(THIS_ const char* pszFile, DWORD* peTextual, const char** ppszType, BOOL fServer) IPURE; \
        STDMETHOD(Set)(THIS_ const char* pszVar, const char* pszValue, BOOL fMachine, const char* pszService) IPURE; \
        STDMETHOD(QuerySettings)(THIS_ const char* pszVar, const char* pszService, ISDVars** ppVars) IPURE; \

DeclareInterfaceUtil(ISDClientUtilities)

#ifndef __building_SDAPI_DLL
// {EFC0F46D-C483-4A70-A7EE-A261D9592ED2}
DEFINE_GUID(IID_ISDClientUtilities, 0xefc0f46d, 0xc483, 0x4a70, 0xa7, 0xee, 0xa2, 0x61, 0xd9, 0x59, 0x2e, 0xd2);
#endif


STDAPI CreateSDAPIObject(REFCLSID clsid, void** ppvObj);


// {27A2571D-DDA1-4F58-B960-DE1023344C1C}
DEFINE_GUID(CLSID_SDAPI, 0x27a2571d, 0xdda1, 0x4f58, 0xb9, 0x60, 0xde, 0x10, 0x23, 0x34, 0x4c, 0x1c);


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\section.h ===
/*
 *
 * section.h
 *
 *
 * manage sections of lines. These are contiguous blocks of lines that either
 * all match a contiguous block in another file, or are unmatched.
 *
 * a section can maintain a link to a corresponding section in another
 * file, and can establish links between matching lines in the two sections.
 *
 * a section also knows its compare state (defined in state.h). This says
 * whether it matches another section, or is matched but out of
 * sequence, or is unmatched. These are set during section_makecomposite.
 *
 * sections are held in LISTs. A list of sections can be built by functions
 * here that traverse a LIST of LINEs, or that traverse a list of
 * SECTIONs (to produce a composite list). In both cases, the lists used
 * are managed by the standard list package
 *
 *
 *
 * Geraint Davies, July 92
 */

/* handle to a section */
typedef struct section FAR * SECTION;


/* make a section, given a first and last line. We return a handle to
 * a section. If the LIST parameter is non-null, we create the section
 * at the end of the list. if list is null, we allocate the memory ourselves.
 * This affects behaviour of section_delete (we only free memory we alloc
 * ourselves).
 *
 * The first and last lines must be on a LIST, with first coming before last.
 */
SECTION section_new(LINE first, LINE last, LIST list);


/* delete a section. free up all associated memory. does NOT delete the
 * associated list of lines.
 *
 *
 * If the section was allocated on a list, it will not be deleted here,
 * only the memory hanging off it will be freed.
 */
void section_delete(SECTION section);


/* match two sections: try to match as many lines as possible between
 * the two sections
 *
 * returns TRUE if any new links between LINEs were made, or FALSE if not.
 */
BOOL section_match(SECTION section1, SECTION section2, BOOL ReSynch);

/* return the handle to the first or last line in the section. If the section
 * is one line long, these will be the same. they should never be NULL
 */
LINE section_getfirstline(SECTION section);
LINE section_getlastline(SECTION section);

/* return the handle to the linked section, if any, or NULL if not linked */
SECTION section_getlink(SECTION section);

/* return a handle to a section that corresponds to this section, but
 * does not match. corresponding sections are found in the same
 * relative position of the file, but are not identical. At least
 * one of section_getlink and section_getcorrespond will return NULL for any
 * given section
 */
SECTION section_getcorrespond(SECTION section);

/* set the compare state for this section */
void section_setstate(SECTION section, int state);


/* return the compare state for this section. This will be 0 unless
 * set by section_getstate, or if the section was built by a call
 * to section_makecomposite.
 */
int section_getstate(SECTION section);


/* return a count of the number of lines in this section */
int section_getlinecount(SECTION section);


/* return the base line number for this section in the left or
 * right files. Base line number is the line number of the
 * first line in this section. Return 0 if the line was not in
 * the left(or right) file.
 *
 * This will only be set for sections created in section_makecomposites.
 *
 * Assumes that lines are numbered incrementally in ascending order.
 */
int section_getleftbasenr(SECTION section);
int section_getrightbasenr(SECTION section);



/*--  section list functions -------------------------------------*/


/* make a list of sections by traversing a list of lines. Contiguous
 * lines that are all linked to contiguous lines are put in the same section.
 * contiguous blocks of lines that are unmatched are put in the same section.
 * sections are kept in order in the list such that the first line of
 * the first section is the first line of the list of lines.
 * left must be TRUE iff the linelist represents a left hand file
 */
LIST section_makelist(LIST linelist, BOOL left);

/* free up a list of sections and all data associated with it */
void section_deletelist(LIST sections);


/* make a composite list of sections by traversing two lists of sections.
 *
 * section are placed in the same order: thus if sec1 is before sec2 in
 * list1, it will be before sec2 in the composite list. Sections that
 * match and are in the same order in both lists, are inserted only once
 * - only one of the two sections will be in the composite list, and the
 * section state will be set to SAME.
 * sections that match but are different places in the two original
 * lists will be inserted twice and the section state will be set to MOVED
 * (MOVED_LEFT and MOVED_RIGHT). Sections that are unmatched will be
 * inserted in order (relative to sections from the same list) with the
 * state set to ONLY_LEFT or ONLY_RIGHT
 */

LIST section_makecomposite(LIST secsleft, LIST secsright);


/* match up sections in the two lists. link sections that are the same,
 * (whose lines are linked), and make correspondence links for sections
 * that are in the same relative position, but not identical.
 * when making correspondence links, we attempt to link lines that
 * match between the two correponding sections. We return TRUE if at any
 * point we increase the number of links - this means that the section
 * lists will have to be rebuilt and rematched. This is *not* done here -
 * it must be done by caller.
 * bDups means allow matching the first occurrence of lines which are not unique.
 */
BOOL section_matchlists(LIST secsleft, LIST secsright, BOOL bDups);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\state.h ===
/*
 * windiff - windows file and directory comparisons
 *
 * state.h
 *
 * definition of the results of comparisons for files and for lines
 * within files.
 *
 * These need to be globally declared so that the UI code in windiff.c can
 * map states to the colour scheme (to correctly highlight changed lines).
 *
 * They apply to files (compitem_getstate() ) and to sections in the
 * composite list (section_getstate). All lines within a section have the
 * same state. The UI code will use the view_getstate() function to find the
 * state for a given line on the screen.
 *
 */

/* applies to both lines or files: they are the same */
#define STATE_SAME		1

/* applies to files.  Same size, date, time */
#define STATE_COMPARABLE	2

/* applies to files.  Different, but only in blanks
 * This state only turns up after the file has been expanded.
 */
#define STATE_SIMILAR		3

/* applies only to files */

/* - files differ (and can be expanded) */
#define STATE_DIFFER		4

/* they are only in the left or right tree */
#define STATE_FILELEFTONLY	5
#define STATE_FILERIGHTONLY	6


/* applies to lines only */

/* the line only exists in one of the lists */
#define STATE_LEFTONLY		7	/* line only in left file */
#define STATE_RIGHTONLY 	8	/* line only in right file */


/* the line is the same in both files, but in
 * different places (thus the line will appear twice in the composite list,
 * once with each of these two states
 */
#define STATE_MOVEDLEFT		9	/* this is the left file version */
#define STATE_MOVEDRIGHT	10	/* this is the right file version*/


#define STATE_SIMILARLEFT	11      /* this is the left file zebra version */
#define STATE_SIMILARRIGHT      12	/* this is the right file zebra version*/

/* In processing the sections to build the composite list, we need to
 * track which sections have been processed.  After this the left and
 * right lists of sections are of no further interest
 */
#define STATE_MARKED		99
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\scandir.h ===
/*
 *
 * scandir
 *
 *
 * scan a directory tree and build a sorted list of filenames within that
 * tree.
 *
 * the dir_buildlist function will scan the directories and files
 * and return DIRLIST handle.
 *
 * calls to dir_firstitem and dir_nextitem will traverse the files in the
 * listing in alphabetic order, returning a DIRITEM handle. This handle
 * can be queried for the associated filename, filesize and checksum.
 *
 * calls to dir_firstitem and dir_nextitem will only show files, not
 * directories, and will traverse the list in alphabetic order
 * within a directory, and contents of subdirectories in
 * alphabetic order within a directory. Within one directory, we traverse the
 * files before listing the contents of the subdirectories.
 *
 * if the bSum argument is true, we checksum each readable file during the
 * initial scan. If this is false, we will checksum the file on demand (during
 * the first call to  dir_getchecksum). if the file is not readable, the
 * checksum will be 0.
 *
 */

 /* handle to the list of files scanned */
typedef struct dirlist FAR * DIRLIST;

/* handle to one item within the list of files */
typedef struct diritem FAR * DIRITEM;


/*
 * scan the given directory for files, and return NULL if unsuccessful,
 * or a DIRLIST handle to the items if successful. If bSums is true,
 * checksum each file found.
 *
 * if pathname is not a directory, we return NULL. if it is a directory, but
 * contains no files, we return a valid handle to an empty list.
 *
 * If bOnDemand is TRUE, the list will scanned as necessary to fulfil
 * dir_firstitem/dir_nextitem requests. If this is false, the
 * list will be fully built before the dir_buildlist function returns.
 */
DIRLIST dir_buildlist(LPSTR pathname, BOOL bSum, BOOL bOnDemand);

void dir_setotherdirlist(DIRLIST dl, DIRLIST otherdl);

/*
 * build/append a directory list.
 *
 * If bSums is true, checksum each file found.
 *
 * if pathname is not a directory, we add it to the list.
 * if it is a directory, it gets ignored.
 */
BOOL dir_appendlist(DIRLIST *pdl, LPCSTR pathname, BOOL bSum, int *psequence);

/*
 * build a list of files by calling a remote checksum server. The result is
 * a handle to a DIRLIST that behaves the same as one returned from
 * dir_buildlist. if bSums is true, we checksum the files
 * during scanning. if bOnDemand is true, we only build the list as necessary
 * during calls to dir_first/nextitem. if this is false, the
 * entire list will be build before the function completes.
 */
DIRLIST dir_buildremote(LPSTR server, LPSTR path, BOOL bSum, BOOL bOnDemand, BOOL fDeep);


/* call this to delete this list, all the items in it and all the
 * associated memory
 */
void dir_delete(DIRLIST list);


/* was this list built from a filename or a directory ? This function
 * will return TRUE if the initial argument to the dir_buildlist()
 * function or dir_buildremote() function specified an individual filename
 * rather than a directory.
 */
BOOL dir_isfile(DIRLIST list);


/* return the first file in the list in alphabetic order. will return
 * null if no files found
 */
DIRITEM dir_firstitem(DIRLIST list);

/* return the next file in the list in alphabetic order, or null if no
 * more files
 */
DIRITEM dir_nextitem(DIRLIST list, DIRITEM previtem, BOOL fDeep);

/*
 * Return a handle to the DIRLIST given a handle to the DIRITEM within it.
 *
 */
DIRLIST dir_getlist(DIRITEM item);


// get the name of this file, relative to the DIRLIST root.
LPSTR dir_getrelname(DIRITEM item);

// get the absolute path to the dirlist root directory
LPSTR dir_getrootpath(DIRLIST dl);

// get a description text for this dirlist
LPSTR dir_getrootdescription(DIRLIST dl);

// set custom description (instead of using calculated one)
void dir_setdescription(DIRLIST dl, LPCSTR psz);



/* free memory created by a previous call to dir_getrelname */
void dir_freerelname(DIRITEM item, LPSTR relname);

/* free memory possibly created by a call to dir_getroot_*  */
void dir_freerootpath(DIRLIST dl, LPSTR rootname);
void dir_freerootdescription(DIRLIST dl, LPSTR rootname);

/*
 * get an open-able name for the file. This will be the same as the fullname,
 * except for remote files, in which case a temporary local copy of the file
 * will be made. call dir_freeopenname when finished with this name.
 */
LPSTR dir_getopenname(DIRITEM item);

/*
 * free up memory created by a call to dir_getopenname(). This *may*
 * cause the file to be deleted if it was a temporary copy.
 */
void dir_freeopenname(DIRITEM item, LPSTR openname);


/*
 * open the file and return a read-only handle to it.
 * will work even for remote files (causes a copy to a temporary local
 * file). close file using dir_closefile
 */
HANDLE dir_openfile(DIRITEM item);

/*
 * close a file opened by dir_openfile. This *may* cause the file to be
 * deleted if it was a temporary local copy
 */
void dir_closefile(DIRITEM item, HANDLE fh);


/* return a checksum for this file. If one has not yet been calculated
 * for this file, open the file and calculate it.
 * if the file was unreadable, this returns 0.
 */
DWORD dir_getchecksum(DIRITEM item);

/* Redo everything to do with checksums, size, etc */
void dir_rescanfile(DIRITEM di);

/* return a TRUE iff item has a valid checksum */
BOOL dir_validchecksum(DIRITEM item);

// return false if there is some error accessing this file
BOOL dir_fileerror(DIRITEM item);

/* return the (lower 32 bits) of the file size, as scanned at the
 * call to dir_buildlist
 */
long dir_getfilesize(DIRITEM item);

/* return the file attributes, as scanned at the call to dir_buildlist
 */
DWORD dir_getattr(DIRITEM item);

/* MUST CALL dir_startcopy first and dir_endcopy after.
 * create a copy of the file, in the new root directory. creates sub-dirs as
 * necessary. Works for local and remote files. For remote files, uses
 * ss_copy_reliable to ensure that the copy succeeds if possible.
 *
 * returns TRUE for success and FALSE for failure.
 */
BOOL dir_copy(DIRITEM item, LPSTR newroot, BOOL HitReadOnly, BOOL IgnoreAttributes);

/* Call this before starting copying */
BOOL dir_startcopy(DIRLIST dl);


/* call this after copying.  Negative retcode = number of bad files
   else retcode = number of file copied (all good).
*/
int dir_endcopy(DIRLIST dl);

/* Build the real path from item and newroot into newpath.
 * Create directories as needed so that it is valid.
 */
BOOL dir_MakeValidPath(LPSTR newpath, DIRITEM item, LPSTR newroot);

/*
 * useful routine exported for other users
 * returns TRUE if path is a valid directory
 */
BOOL dir_isvaliddir(LPCSTR path);

/*
 * returns TRUE if the DIRLIST parameter has a wildcard specified
 */
BOOL dir_iswildcard(DIRLIST);

/*
 * compares two relnames that are both based on wildcard DIRLISTs. if the
 * directories match, then the filenames are compared after removing
 * the fixed portion of the name - thus comparing only the
 * wildcard portion.
 */
int dir_compwildcard(DIRLIST dleft, DIRLIST dright, LPSTR lname, LPSTR rname);

/*
 * compares two DIRITEMs, based on a sequence number rather than filenames.
 */
BOOL dir_compsequencenumber(DIRITEM dleft, DIRITEM dright, int *pcmpvalue);

#ifndef WIN32
    /* FILETIME structure from WIN32 */
    typedef struct _FILETIME { /* ft */
        DWORD dwLowDateTime;
        DWORD dwHighDateTime;
    } FILETIME;
#define CONST const

long CompareFileTime( CONST FILETIME * lpft1,  /* address of first file time */
                      CONST FILETIME * lpft2  /* address of second file time */
                    );
#endif

/* return the file time (last write time) (set during scanning), (0,0) if invalid */
FILETIME dir_GetFileTime(DIRITEM cur);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\slmmgr.cpp ===
/*
 * slmmgr.c
 *
 * interface to SLM
 *
 * provides an interface to SLM libraries that will return the
 * SLM master library for a given directory, or extract into temp files
 * earlier versions of a SLM-controlled file
 *
 * Geraint Davies, August 93
 */

extern "C" {

#include <windows.h>
#include <string.h>
#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include "scandir.h"
#include "slmmgr.h"
#include "gutils.h"

#include "windiff.h"
#include "wdiffrc.h"

#include "initguid.h"
#include "sdapi.h"



#undef _ASSERT
#ifdef DEBUG
#define _ASSERT(expr) \
        do \
        { \
            if (!(expr)) \
            { \
                char sz[512]; \
                wsprintf(sz, "[%s, li%d]\n\n%s", __FILE__, __LINE__, #expr); \
                switch (MessageBox(NULL, sz, "WINDIFF ASSERT", MB_ABORTRETRYIGNORE)) \
                { \
                case IDABORT: ExitProcess(1); break; \
                case IDRETRY: DebugBreak(); break; \
                } \
            } \
        } \
        while (0)
#else
#define _ASSERT(expr) ((void)0)
#endif

}; // extern "C" (from top of file)
// -- begin C++ -----------------------------------------------------------



// ideally these should allocate through the gmem_ heap, but gmem_free
// requires a size and operator delete can't know the size.

void* _cdecl operator new(size_t nSize)
{
    return calloc(1, nSize);            // zero initialize
}

void _cdecl operator delete(void* pv)
{
    free(pv);
}



///////////////////////////////////////////////////////////////////////////
// SDServer class declaration
//
// The SDServer class abstracts whether the command is run via SD.EXE or the
// SDAPI.  This is desirable because it does not require changing any of the
// existing code that already assumed commands were run via SD.EXE.

enum SDCommand { sdExists, sdPrint, sdOpened, sdDescribe, sdWhere, sdMAX };


class SDServer
{
public:
    static void Init();
    static SDServer *GetServer(const char *pszDir);
    static void FreeAll();

    BOOL Exists(const char *pszArgs, const char *pszCwd) { return Run(sdExists, pszArgs, NULL, NULL, pszCwd); }
    BOOL Print(const char *pszArgs, HANDLE hFile, const char *pszCwd) { return Run(sdPrint, pszArgs, hFile, NULL, pszCwd); }
    BOOL Opened(const char *pszArgs, HANDLE hFile, HANDLE hFileErr) { return Run(sdOpened, pszArgs, hFile, hFileErr, NULL); }
    BOOL Describe(const char *pszArgs, HANDLE hFile, HANDLE hFileErr) { return Run(sdDescribe, pszArgs, hFile, hFileErr, NULL); }
    BOOL Where(const char *pszLocalFile, char *pszClientFile, int cchMax);

    void SetClient(const char *pszClient);
    const char *GetClientRelative() const { return *m_szClientRelative ? m_szClientRelative : NULL; }

    void FixupRoot(const char *pszFile, int cch, char *pszLeft, int cchMaxLeft, char *pszRight, int cchMaxRight);

private:
    SDServer(ISDClientApi *papi, const char *pszDir);
    ~SDServer();

    BOOL Run(SDCommand cmd, const char *pszArgs, HANDLE hFile, HANDLE hFileErr, const char *pszCwd);

private:
    SDServer *m_pNext;
    ISDClientApi *m_papi;
    char m_szDir[MAX_PATH];
    char m_szClient[MAX_PATH];
    char m_szClientRelative[MAX_PATH];

    char *m_pszX;
    int m_cchX;

    static SDServer *s_pHead;
#ifdef DEBUG
    static int s_cApiCreated;
#endif
};



// -- end C++ -------------------------------------------------------------
extern "C" {

/*
 * The SLMOBJECT is a pointer to one of these structures
 */
struct _slmobject {

    // shared, SD and SLM
    char CurDir[MAX_PATH];
    char SlmRoot[MAX_PATH];

    // only SLM
    char MasterPath[MAX_PATH];
    char SubDir[MAX_PATH];
    char SlmProject[MAX_PATH];

    // only SD
    BOOL fSourceDepot;
    BOOL fUNC;
    BOOL fFixupRoot;
    SDServer *pSD;                      // do not delete the pointer!
};


/*
 * The LEFTRIGHTPAIR is a pointer to one of these structures
 */
struct _leftrightpair
{
    char m_szLeft[512];
    char m_szRight[512];
    struct _leftrightpair *m_pNext;
};



static BOOL SLM_ReadIni(SLMOBJECT pslm, HANDLE fh);

// all memory allocated from gmem_get, using a heap declared and
// initialised elsewhere
extern HANDLE hHeap;


// windiff -l! forces us to assume SD without looking for SLM.INI or SD.INI
static BOOL s_fForceSD = FALSE;
static BOOL s_fFixupRoot = FALSE;       //$ todo: this really shouldn't be a global variable
static BOOL s_fDescribe = FALSE;        // -ld was used
static BOOL s_fOpened = FALSE;          // -lo was used
static char s_szSDPort[MAX_PATH] = "";
static char s_szSDClient[MAX_PATH] = "";
static char s_szSDChangeNumber[32] = "";
static char s_szSDOpenedArgs[MAX_PATH] = "";
static char s_szSDOpenedCwd[MAX_PATH] = "";
static char s_szSDOpenedClientRoot[MAX_PATH] = "";
static char s_szInputFile[MAX_PATH] = "";


static LPSTR DirUpOneLevel(LPSTR pszDir)
{
    LPSTR psz;
    LPSTR pszSlash = 0;

    for (psz = pszDir; *psz; ++psz) {
        if (*psz == '\\') {
            if (*(psz + 1) && *(psz + 1) != '\\') {
                pszSlash = psz;
            }
        }
    }
    if (pszSlash) {
        *pszSlash = 0;
    }
    return pszSlash;
}


void
SLM_ForceSourceDepot(void)
{
    s_fForceSD = TRUE;
}


void
SLM_Describe(LPCSTR pszChangeNumber)
{
    s_fForceSD = TRUE;
    s_fDescribe = TRUE;
    *s_szSDChangeNumber = 0;
    if (pszChangeNumber && *pszChangeNumber)
        lstrcpyn(s_szSDChangeNumber, pszChangeNumber, NUMELMS(s_szSDChangeNumber));
}


/*
 * SplitFilenameFromPath - splits the filename part from the path part.
 *
 * This function has special understanding of wildcards (including SD
 * wildcards), and always includes them in the filename part.
 */
static LPCSTR SplitFilenameFromPath(char **ppszFile, BOOL *pfDirectory)
{
    LPSTR pszPath = *ppszFile;
    LPSTR pszBegin = pszPath;
    LPSTR psz = 0;
    DWORD dw;
    int cDots;

    *pfDirectory = FALSE;

    if (pszPath[0] == '/' && pszPath[1] == '/')
        return 0;                       // no path is return value

    // check if it's a directory
    dw = GetFileAttributes(pszPath);
    if (dw != 0xffffffff && (dw & FILE_ATTRIBUTE_DIRECTORY))
    {
        *pfDirectory = TRUE;
        *ppszFile = 0;                  // no filename is out param
        return pszPath;                 // full path is return value
    }

    // skip past drive specifier or UNC \\machine\share
    if (pszPath[0] && pszPath[1] == ':')
    {
        pszPath += 2;
    }
    else if (pszPath[0] == '\\' && pszPath[1] == '\\')
    {
        int c = 0;
        for ( ;; )
        {
            if (!*pszPath)
            {
                *ppszFile = 0;          // no filename is out param
                return pszBegin;        // path is return value
            }
            if (*pszPath == '\\')
            {
                c++;
                if (c >= 4)
                    break;
            }
            ++pszPath;
        }
    }

    // find last \ in *ppszFile
    cDots = 0;
    while (*pszPath)
    {
        if (*pszPath == '.')
            cDots++;
        else
            cDots = 0;

        if (*pszPath == '\\' || *pszPath == '/')
            psz = pszPath;
        else if (cDots > 2 || *pszPath == '*' || *pszPath == '?')
            break;                      // stop looking for filename

        ++pszPath;
    }

    // found \ in *ppszFile
    if (psz)
    {
        *psz = 0;
        psz++;
        *ppszFile = psz;                // filename is out param
        return pszBegin;                // path is return value
    }

    // not found
    *ppszFile = pszBegin;               // filename is out param (unchanged, actually)
    return 0;                           // no path is return value
}


void
SLM_Opened(LPCSTR __pszArg, UINT *pidsError)
{
    char szFull[1024];
    char sz[1024];
    char *psz;
    char *pszArg = 0;

    // init assuming no error
    *pidsError = 0;
    s_fForceSD = TRUE;
    s_fOpened = TRUE;
    s_szSDOpenedArgs[0] = 0;

    // copy args
    sz[0] = 0;
    if (__pszArg)
        lstrcpyn(sz, __pszArg, NUMELMS(sz));
    pszArg = sz;

    // special handling if a path argument is given
    if (pszArg && *pszArg)
    {
        LPCSTR pszPath;
        SLMOBJECT pslm;
        BOOL fDir;

        s_szSDOpenedCwd[0] = 0;

        // split path and filename
        pszPath = SplitFilenameFromPath(&pszArg, &fDir);
        if (pszPath)
        {
            LPSTR pszDummy;

            // get fully qualified path name
            *szFull = 0;
            GetFullPathName(pszPath, sizeof(szFull), szFull, &pszDummy);
            if (*szFull)
                pszPath = szFull;

            // store off the path
            lstrcpyn(s_szSDOpenedCwd, pszPath, NUMELMS(s_szSDOpenedCwd));

            // set current directory
            if (!SetCurrentDirectory(pszPath))
            {
                *pidsError = IDS_ERROR_LO_UNC;
                return;
            }
        }

#ifdef DEBUG
        if (pszPath)
        {
            OutputDebugString("WINDIFF -LO:  cwd='");
            OutputDebugString(pszPath);
            OutputDebugString("'\n");
        }
#endif

        char *pszAppend = s_szSDOpenedArgs;
        char *pszEnd = s_szSDOpenedArgs + NUMELMS(s_szSDOpenedArgs);

        // init the path fixup stuff

        s_fFixupRoot = TRUE;

        pslm = SLM_New(pszPath, pidsError);
        if (pslm && !*pidsError)
        {
            const char *pszUncRoot = *s_szSDOpenedClientRoot ? s_szSDOpenedClientRoot : pslm->SlmRoot;
            int cchRoot = lstrlen(pszUncRoot);
            int cch;

            // build the new file argument by taking the ClientRelative path
            // and appending the original file argument (after stripping the
            // directory where the SD.INI file was found).

            cch = lstrlen(pszPath);
            if (cch > cchRoot)
                cch = cchRoot;
            if (_strnicmp(pszUncRoot, pszPath, cch) == 0 &&
                (!*pszUncRoot || lstrcmp(pszUncRoot, "\\")) &&
                pslm->fFixupRoot && pslm->pSD->GetClientRelative())
            {
                s_fFixupRoot = TRUE;

                SLM_OverrideUncRoot(pszUncRoot);

                // the original file argument specifies more than just the
                // client root, so strip the root and append the rest to the
                // client namespace path.

                lstrcpyn(pszAppend, pslm->pSD->GetClientRelative(), int(pszEnd - pszAppend));
                pszAppend += lstrlen(pszAppend);

                lstrcpyn(pszAppend, pszPath + cch, int(pszEnd - pszAppend));
                pszAppend += lstrlen(pszAppend);
            }
            else
            {
                s_fFixupRoot = FALSE;

                lstrcpyn(pszAppend, pszPath, int(pszEnd - pszAppend));
                pszAppend += lstrlen(pszAppend);
            }
        }
        else
        {
            s_fFixupRoot = FALSE;

            // oh whatever, we'll just ignore these errors and assume the -LO
            // flag means the user believes the specified path really is under
            // SD source control.
            *pidsError = 0;

            lstrcpyn(pszAppend, pszPath, int(pszEnd - pszAppend));
            pszAppend += lstrlen(pszAppend);
        }
        SLM_Free(pslm);

        // tack on ... if the user specified a directory name, otherwise
        // whatever args were split off by SplitFilenameFromPath above.

        if (*s_szSDOpenedArgs && *(pszAppend - 1) != '/' &&
            *(pszAppend - 1) != '\\' && pszAppend < pszEnd)
        {
            *(pszAppend++) = '/';
        }

        if (fDir)
        {
            lstrcpyn(pszAppend, "...", int(pszEnd - pszAppend));
        }
        else
        {
            if (*pszArg == '/' || *pszArg == '\\')
                ++pszArg;
            lstrcpyn(pszAppend, pszArg, int(pszEnd - pszAppend));
        }

        // convert slashes

        char chFrom = '/';              // first, assume file system paths
        char chTo = '\\';

        if (s_fFixupRoot)
        {
            // nope, we're using client namespace paths, so use these instead:
            chFrom = '\\';
            chTo = '/';
        }

        for (psz = s_szSDOpenedArgs; *psz; psz++)
            if (*psz == chFrom)
                *psz = chTo;
    }
}


LPCSTR
SLM_SetInputFile(LPCSTR pszInputFile)
{
    *s_szInputFile = 0;
    if (pszInputFile)
        lstrcpyn(s_szInputFile, pszInputFile, NUMELMS(s_szInputFile));
    return s_szInputFile;
}


void
SLM_SetSDPort(LPCSTR pszPort)
{
    lstrcpy(s_szSDPort, pszPort);
}


void
SLM_SetSDClient(LPCSTR pszClient)
{
    lstrcpy(s_szSDClient, pszClient);
}


void
SLM_SetSDChangeNumber(LPCSTR pszChangeNumber)
{
    *s_szSDChangeNumber = 0;
    if (pszChangeNumber && *pszChangeNumber)
    {
        lstrcpy(s_szSDChangeNumber, " -c ");
        lstrcat(s_szSDChangeNumber, pszChangeNumber);
    }
}


void
SLM_OverrideUncRoot(LPCSTR pszUncRoot)
{
    if (!*s_szSDOpenedClientRoot && pszUncRoot && *pszUncRoot)
    {
        lstrcpyn(s_szSDOpenedClientRoot, pszUncRoot, NUMELMS(s_szSDOpenedClientRoot));

        int cch = lstrlen(s_szSDOpenedClientRoot);
        if (cch && cch + 1 < NUMELMS(s_szSDOpenedClientRoot) &&
            s_szSDOpenedClientRoot[cch - 1] != '\\' &&
            s_szSDOpenedClientRoot[cch - 1] != '/')
        {
            lstrcpy(s_szSDOpenedClientRoot + cch, "\\");
        }
    }
}


}; // extern "C" (from second one)
// -- begin C++ -----------------------------------------------------------



///////////////////////////////////////////////////////////////////////////
// SDClientUser

#define DeclareIUnknownMembers(IPURE) \
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) IPURE; \
    STDMETHOD_(ULONG,AddRef) (THIS)  IPURE; \
    STDMETHOD_(ULONG,Release) (THIS) IPURE; \


// the SDClientUser processes data received thru the SDAPI
class SDClientUser : public ISDClientUser
{
public:
    SDClientUser();
    virtual ~SDClientUser();

    DeclareIUnknownMembers(IMPL);
    DeclareISDClientUserMembers(IMPL);

    void SetCommand(SDCommand cmd, HANDLE hFile, HANDLE hFileErr);
    void SetBuffer(char *pszX, int cchX) { m_pszX = pszX; m_cchX = cchX; }
    BOOL FSucceeded() { return !m_fError; }

private:
    BOOL EnsureBuffer(int cb);

private:
    ULONG m_cRef;
    SDCommand m_cmd;
    HANDLE m_hFile;
    HANDLE m_hFileErr;
    BOOL m_fError;
    int m_cb;
    char *m_psz;
    char *m_pszX;
    int m_cchX;
#ifdef DEBUG
    BOOL m_fInitialized;
#endif
};


SDClientUser::SDClientUser()
        : m_cRef(1)
        , m_hFile(NULL)
        , m_hFileErr(NULL)
        , m_fError(TRUE)
        , m_psz(NULL)
{
#ifdef DEBUG
    m_fInitialized = FALSE;
#endif
}


SDClientUser::~SDClientUser()
{
    delete m_psz;
}


BOOL SDClientUser::EnsureBuffer(int cb)
{
    if (m_psz && cb > m_cb)
    {
        delete m_psz;
        m_psz = 0;
    }
    if (!m_psz)
    {
        m_cb = cb;
        m_psz = new char[m_cb];
    }
    return !!m_psz;
}


void SDClientUser::SetCommand(SDCommand cmd, HANDLE hFile, HANDLE hFileErr)
{
    if (!hFile)
        hFile = INVALID_HANDLE_VALUE;
    if (!hFileErr)
        hFileErr = INVALID_HANDLE_VALUE;

    m_cmd = cmd;
    m_hFile = hFile;
    m_hFileErr = hFileErr;
    m_fError = FALSE;
#ifdef DEBUG
    m_fInitialized = TRUE;
#endif
}


STDMETHODIMP_(ULONG) SDClientUser::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) SDClientUser::Release()
{
    if (--m_cRef > 0)
        return m_cRef;
    delete this;
    return 0;
}


STDMETHODIMP SDClientUser::QueryInterface(REFIID iid, void** ppvObj)
{
    HRESULT hr = S_OK;

    if (iid == IID_IUnknown || iid == IID_ISDClientUser)
        *ppvObj = (ISDClientUser*)this;
    else
    {
        *ppvObj = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppvObj)->AddRef();
    return hr;
}


STDMETHODIMP SDClientUser::OutputInfo( int cIndent, const char *pszInfo )
{
    DWORD cbWritten;

#ifdef DEBUG
    OutputDebugString("WINDIFF/SD info: ");
    OutputDebugString(pszInfo);
    OutputDebugString("\n");
#endif

    switch (m_cmd)
    {
    case sdOpened:
    case sdDescribe:
        while (cIndent--)
            m_fError = m_fError || !WriteFile(m_hFile, "... ", 4, &cbWritten, NULL);
        m_fError = m_fError || (!WriteFile(m_hFile, pszInfo, lstrlen(pszInfo), &cbWritten, NULL) ||
                                !WriteFile(m_hFile, "\r\n", 2, &cbWritten, NULL));
        break;
	case sdExists:
    case sdPrint:
        // ignore it
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::OutputText( const char *pszText, int cchText )
{
    DWORD cbWritten;
    char *pszWalk;

    switch (m_cmd)
    {
    case sdPrint:
    case sdDescribe:
        if (EnsureBuffer(cchText * 2))
        {
            for (pszWalk = m_psz; cchText; --cchText)
            {
                if (*pszText == '\n')
                    *(pszWalk++) = '\r';
                *(pszWalk++) = *(pszText++);
            }
            if (!WriteFile(m_hFile, m_psz, int(pszWalk - m_psz), &cbWritten, NULL))
                m_fError = TRUE;
        }
        else
        {
            m_fError = TRUE;
        }
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::OutputBinary( const unsigned char *pbData, int cbData )
{
    DWORD cbWritten;

    switch (m_cmd)
    {
    case sdPrint:
        if (!WriteFile(m_hFile, pbData, cbData, &cbWritten, NULL))
            m_fError = TRUE;
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::OutputWarning( int cIndent, const char *pszWarning, BOOL fEmptyReason )
{
#ifdef DEBUG
    OutputDebugString("WINDIFF/SD warning: ");
    OutputDebugString(pszWarning);
#endif

    switch (m_cmd)
    {
    case sdExists:
        m_fError = TRUE;
        break;
    case sdPrint:
        _ASSERT(0);                     // this can't happen
        m_fError = TRUE;
        break;
    case sdOpened:
    case sdDescribe:
        if (fEmptyReason)
        {
            OutputError(pszWarning);
            _ASSERT(m_fError);
        }
        else
        {
            // this can't happen.  and if it does then it's not clear what's
            // up, and we should just ignore the warning until we know how to
            // handle it properly.
            _ASSERT(0);
        }
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::OutputError( const char *pszError )
{
#ifdef DEBUG
    OutputDebugString("WINDIFF/SD error: ");
    OutputDebugString(pszError);
#endif

    switch (m_cmd)
    {
    case sdExists:
        // maxresult means it was 'too successful' so ignore those errors
        m_fError = m_fError || !(strstr("maxresult", pszError) ||
                                 strstr("MaxResult", pszError) ||
                                 strstr("MAXRESULT", pszError));
        break;
    case sdOpened:
    case sdDescribe:
        if (m_hFileErr != INVALID_HANDLE_VALUE)
        {
            DWORD cbData = lstrlen(pszError);
            DWORD cbWritten;

            WriteFile(m_hFileErr, pszError, cbData, &cbWritten, NULL);
        }
        // fall thru
    case sdPrint:
    case sdWhere:
        m_fError = TRUE;
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::OutputStructured( ISDVars *pVars )
{
    LPCSTR pszClientFile;

#ifdef DEBUG
    {
        char sz[1024];
        HRESULT hr;
        const char *pszVar;
        const char *pszValue;
        int ii;

        // dump the variables
        OutputDebugString("WINDIFF/SD structured:\n");
        for (ii = 0; 1; ii++)
        {
            hr = pVars->GetVarByIndex(ii, &pszVar, &pszValue, 0, 0);
            if (hr != S_OK)
                break;
            wsprintf(sz, "... %s=%s\n", pszVar, pszValue);
            OutputDebugString(sz);
        }
    }
#endif

    switch (m_cmd)
    {
    case sdWhere:
        _ASSERT(m_pszX && m_cchX);
        if (pVars->GetVar("unmap", &pszClientFile, 0, 0) == S_FALSE &&
            pVars->GetVar("clientFile", &pszClientFile, 0, 0) == S_OK)
        {
            lstrcpyn(m_pszX, pszClientFile, m_cchX);
        }
        break;
    default:
        _ASSERT(0);                     // oops
        m_fError = TRUE;
        break;
    }

    return S_OK;
}


STDMETHODIMP SDClientUser::Finished()
{
#ifdef DEBUG
    m_fInitialized = FALSE;
#endif
    return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// AutoInitCritSec

static CRITICAL_SECTION s_cs;
static class AutoInitCritSec
{
public:
    AutoInitCritSec(CRITICAL_SECTION *pcs) { InitializeCriticalSection(pcs); }
} s_autoinit(&s_cs);



///////////////////////////////////////////////////////////////////////////
// TempFileManager

class TempFileManager
{
    struct TempFileInfo
    {
        HANDLE m_hFile;                 // init to 0
        BOOL m_fKeep;                   // init to 0 (FALSE)
        char m_szFile[MAX_PATH];        // init to 0 ('\0')
    };

    public:
        TempFileManager() : m_cFiles(0), m_prgInfo(NULL) {}
        ~TempFileManager();

        BOOL FInitialize(int cFiles);

        HANDLE GetHandle(int ii) const;
        LPCSTR GetFilename(int ii) const;
        void KeepFile(int ii);

        void MsgBoxFromFile(int ii, LPCSTR pszTitle, DWORD flags);

    private:
        void Close(int ii);

    private:
        int m_cFiles;
        TempFileInfo *m_prgInfo;
};


TempFileManager::~TempFileManager()
{
    if (m_prgInfo)
    {
        for (int ii = m_cFiles; ii--;)
        {
            TempFileInfo *pinfo = m_prgInfo + ii;

            // close file
            Close(ii);

            // maybe delete file
            if (*pinfo->m_szFile && !m_prgInfo[ii].m_fKeep)
                DeleteFile(pinfo->m_szFile);
        }

        delete m_prgInfo;
    }
}


inline HANDLE TempFileManager::GetHandle(int ii) const
{
    _ASSERT(ii >= 0 && ii < m_cFiles);
    return m_prgInfo[ii].m_hFile;
}


inline LPCSTR TempFileManager::GetFilename(int ii) const
{
    _ASSERT(ii >= 0 && ii < m_cFiles);
    return m_prgInfo[ii].m_szFile;
}


inline void TempFileManager::KeepFile(int ii)
{
    _ASSERT(ii >= 0 && ii < m_cFiles);
    m_prgInfo[ii].m_fKeep = TRUE;
}


void TempFileManager::Close(int ii)
{
    TempFileInfo *pinfo = m_prgInfo + ii;

    if (pinfo->m_hFile && pinfo->m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(pinfo->m_hFile);

    pinfo->m_hFile = NULL;
}


BOOL TempFileManager::FInitialize(int cFiles)
{
    TempFileInfo *pinfo;
    SECURITY_ATTRIBUTES sa;
    int ii;

    _ASSERT(!m_prgInfo);
    _ASSERT(!m_cFiles);

    m_cFiles = cFiles;
    m_prgInfo = new TempFileInfo[cFiles];
    if (!m_prgInfo)
        return FALSE;

    memset(m_prgInfo, 0, sizeof(TempFileInfo) * cFiles);
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle = TRUE;

    for (ii = cFiles, pinfo = m_prgInfo; ii--; pinfo++)
    {
        GetTempPath(NUMELMS(pinfo->m_szFile), pinfo->m_szFile);
        GetTempFileName(pinfo->m_szFile, "slm", 0, pinfo->m_szFile);

        pinfo->m_hFile = CreateFile(pinfo->m_szFile,
                                    GENERIC_WRITE|GENERIC_READ,
                                    FILE_SHARE_WRITE|FILE_SHARE_READ,
                                    &sa,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_TEMPORARY,
                                    NULL);

        if (pinfo->m_hFile == INVALID_HANDLE_VALUE)
            return FALSE;
    }

    return TRUE;
}


extern HWND hwndClient;                 // main window, see windiff.c [ugly]
void TempFileManager::MsgBoxFromFile(int ii, LPCSTR pszTitle, DWORD flags)
{
    DWORD dw = GetFileSize(GetHandle(ii), NULL);

#ifdef DEBUG
    {
        char sz[1024];
        wsprintf(sz, "MsgBoxFromFile, file[%d] = '%s', size=%u\n", ii, GetFilename(ii), dw);
        OutputDebugString(sz);
    }
#endif

    if (dw && dw != 0xffffffff)
    {
        char *psz = new char[dw + 1];

        SetFilePointer(GetHandle(ii), 0, 0, FILE_BEGIN);
        if (psz && ReadFile(GetHandle(ii), psz, dw, &dw, NULL))
        {
            psz[dw] = 0;
            MessageBox(hwndClient, psz, pszTitle, flags);
        }
        else
        {
#ifdef DEBUG
            char sz[1024];
            wsprintf(sz, "MsgBoxFromFile failed, GetLastError() = %u (0x%08x)\n",
                     GetLastError(), GetLastError());
            OutputDebugString(sz);
#endif
        }

        delete[] psz;
    }
}



///////////////////////////////////////////////////////////////////////////
// SDServer Implementation
//
// The SDServer class abstracts whether the command is run via SD.EXE or the
// SDAPI.  This is desirable because it does not require changing any of the
// existing code that already assumed commands were run via SD.EXE.

SDServer *SDServer::s_pHead = NULL;
#ifdef DEBUG
int SDServer::s_cApiCreated = 0;
#endif


//#define SDAPI_USE_COCREATEINSTANCE


static BOOL s_fApiLoaded = FALSE;

#ifndef SDAPI_USE_COCREATEINSTANCE
static IClassFactory *s_pfact = 0;
#endif

static union
{
    FARPROC Purecall[4];
    struct
    {
        HRESULT (__stdcall *CoInitialize)       (LPVOID pvReserved);

#ifdef SDAPI_USE_COCREATEINSTANCE
        HRESULT (__stdcall *CoCreateInstance)   (REFCLSID rclsid,
                                                 LPUNKNOWN pUnkOuter,
                                                 DWORD dwClsContext,
                                                 REFIID riid,
                                                 LPVOID FAR* ppv);
#else
        HRESULT (__stdcall *CoGetClassObject)   (REFCLSID rclsid,
                                                 DWORD dwClsContext,
                                                 COSERVERINFO *pServerInfo,
                                                 REFIID riid,
                                                 LPVOID FAR* ppv);
#endif

        void (__stdcall *CoFreeUnusedLibraries) ();

        HRESULT (__stdcall *CreateSDAPIObject)  (REFCLSID clsid,
                                                 void** ppvObj);
    };
} s_Imports = {0};


SDServer::SDServer(ISDClientApi *papi, const char *pszDir)
{
    // initialize members

    m_papi = papi;
    if (m_papi)
        m_papi->AddRef();
    lstrcpyn(m_szDir, pszDir, NUMELMS(m_szDir));

    if (*s_szSDClient)
        SetClient(s_szSDClient);

    // link the node

    EnterCriticalSection(&s_cs);
    m_pNext = s_pHead;
    s_pHead = this;
    LeaveCriticalSection(&s_cs);
}


SDServer::~SDServer()
{
    if (m_papi)
    {
        m_papi->Final();                // disconnect from SD server
        m_papi->Release();
    }
}


SDServer *SDServer::GetServer(const char *__pszDir)
{
    SDServer *pFind;
    ISDClientApi *papi = 0;
    char szDir[MAX_PATH * 2];

    if (!__pszDir)
    {
        // get current directory
        if (!GetCurrentDirectory(NUMELMS(szDir), szDir))
            lstrcpy(szDir, ".");
    }
    else
    {
        // copy specified directory name into our temp buffer
        lstrcpyn(szDir, __pszDir, NUMELMS(szDir));

        // some SDAPI builds have a bug where non-UNC paths with a trailing
        // slash are not recognized as directories.  unfortunately the same
        // builds have a bug where UNC paths that lack a trailing slash are
        // not recognized as directories.  so we try to be clever here, and
        // always strip a trailing slash, and use fully qualified names.
        char *pszFinal = My_mbsrchr(szDir, '\\');
        if (!pszFinal)
            pszFinal = My_mbsrchr(szDir, '/');
        if (pszFinal && !*CharNext(pszFinal))
            *pszFinal = 0;
    }

    // see if we already know about this directory
    EnterCriticalSection(&s_cs);
    for (pFind = s_pHead; pFind; pFind = pFind->m_pNext)
    {
        // don't need to handle DBCS, b/c SD only supports ASCII filenames
        if (_stricmp(pFind->m_szDir, szDir) == 0)
            break;
    }
    LeaveCriticalSection(&s_cs);

    if (pFind)
        return pFind;

    // allocate a new SDServer -- we create these readily to maintain the same
    // behavior as when not using SDAPI.  before SDAPI existed, 'windiff -l'
    // worked across multiple depots, though not by intention.
    if (!s_fApiLoaded)
    {
        HMODULE h = LoadLibrary("sdapi.dll");

        if (h)
            s_Imports.Purecall[3] = GetProcAddress(h, "CreateSDAPIObject");

        if (!s_Imports.Purecall[3])
        {
            h = LoadLibrary("ole32.dll");

            if (h)
            {
                s_Imports.Purecall[0] = GetProcAddress(h, "CoInitialize");

                if (s_Imports.Purecall[0] && SUCCEEDED(s_Imports.CoInitialize(0)))
                {
                    s_Imports.Purecall[1] = GetProcAddress(h,
#ifdef SDAPI_USE_COCREATEINSTANCE
                                                           "CoCreateInstance");
#else
                    "CoGetClassObject");
#endif
                    s_Imports.Purecall[2] = GetProcAddress(h, "CoFreeUnusedLibraries");
                }

#ifndef SDAPI_USE_COCREATEINSTANCE
                if (s_Imports.Purecall[1])
                {
                    s_Imports.CoGetClassObject(CLSID_SDAPI, CLSCTX_INPROC_SERVER,
                                               NULL, IID_IClassFactory, (void**)&s_pfact);
                }
#endif
            }
        }

        // avoid trying to load the DLL(s) again, even if they failed
        s_fApiLoaded = TRUE;
    }

    if (s_Imports.Purecall[3])
    {
        s_Imports.CreateSDAPIObject(CLSID_SDAPI, (void**)&papi);
    }
    else if (s_Imports.Purecall[1])
    {
#ifdef SDAPI_USE_COCREATEINSTANCE
        s_Imports.CoCreateInstance(CLSID_SDAPI, NULL, CLSCTX_INPROC_SERVER,
                                   IID_ISDClientApi, (void**)&papi);
#else
        if (s_pfact)
            s_pfact->CreateInstance(NULL, IID_ISDClientApi, (void**)&papi);
#endif
    }

    if (papi)
    {
        char szIni[2048];
        char *psz = szIni;
        int cchMax = NUMELMS(szIni);

        // some older versions of the SDAPI (pre-2.0) fail to load the ini
        // file if the path has a trailing slash.  but some older versions
        // fail to load the ini file from a UNC path if it lacks a trailing
        // slash.  the best solution here is to just give up and require a
        // non-buggy version of the SDAPI.  however, if __pszDir contains a
        // path then we assume there's an SD.INI file there, and we can avoid
        // the bug by specifying the exact filename.
        _snprintf(szIni, NUMELMS(szIni), "%s%s", szDir, __pszDir ? "\\sd.ini" : "");

#ifdef DEBUG
        char sz[2048];
        _snprintf(sz, NUMELMS(sz), "LoadIniFile(%s)\n", szIni);
        OutputDebugString(sz);
        s_cApiCreated++;
#endif

        papi->LoadIniFile(szIni, TRUE);
    }

    pFind = new SDServer(papi, szDir);

    if (papi)
        papi->Release();

    // either returns NULL, or a pointer to an SDServer object.  if unable to
    // initialize OLE or create an SDAPI object, the SDServer falls back to
    // spawning the SD.EXE client program.
    return pFind;
}


void SDServer::FreeAll()
{
    SDServer *pDelete;

    EnterCriticalSection(&s_cs);
    while (s_pHead)
    {
        pDelete = s_pHead;
        s_pHead = s_pHead->m_pNext;
        delete pDelete;
    }
    LeaveCriticalSection(&s_cs);

#ifdef DEBUG
    if (s_cApiCreated)
    {
        char sz[64];
        wsprintf(sz, "%d SDAPI object(s) were created.", s_cApiCreated);
        MessageBox(NULL, sz, "DEBUG WINDIFF", MB_OK);
        s_cApiCreated = 0;
    }
#endif

    // reset globals (yuck)

    s_fForceSD = FALSE;
    s_fDescribe = FALSE;
    s_fOpened = FALSE;
    s_fFixupRoot = FALSE;

    *s_szSDPort = 0;
    *s_szSDClient = 0;
    *s_szSDChangeNumber = 0;
    *s_szSDOpenedArgs = 0;
    *s_szSDOpenedCwd = 0;
    *s_szSDOpenedClientRoot = 0;
    *s_szInputFile = 0;

    // free unused libraries?

    if (s_Imports.Purecall[2])
        s_Imports.CoFreeUnusedLibraries();
}


void SDServer::SetClient(const char *pszClient)
{
    if (pszClient && *pszClient)
    {
        if (!*m_szClient)
            lstrcpyn(m_szClient, pszClient, NUMELMS(m_szClient));

        // this intentionally uses m_szClient, and NOT pszClient, to ensure
        // consistency.

        if (!*m_szClientRelative)
            wsprintf(m_szClientRelative, "//%s/", m_szClient);
    }
}


void SDServer::FixupRoot(const char *__pszFile, int cch,
                         char *pszLeft, int cchMaxLeft,
                         char *pszRight, int cchMaxRight)
{
    char szFile[1024];
    char szRev[64];
    char *pszRev;

    // copy filename into a null terminated buffer for easier handling
    if (cch < 1024)
    {
        memcpy(szFile, __pszFile, cch);
        szFile[cch] = 0;
    }
    else
        lstrcpyn(szFile, __pszFile, NUMELMS(szFile));

    // strip and save revision
    szRev[0] = 0;
    pszRev = strpbrk(szFile, "#@");
    if (pszRev)
    {
        int ii = 0;
        char *pszWalk = pszRev;

        while (ii < NUMELMS(szRev) - 1 && *pszWalk && !isspace(*pszWalk))
            szRev[ii++] = *(pszWalk++);
        szRev[ii] = 0;

        *pszRev = 0;
        cch = int(pszRev - szFile);
    }

    if (s_fFixupRoot)
    {
        char szClientFile[1024];

#ifdef DEBUG
        {
            char sz[2048];
            wsprintf(sz, "FixupRoot input = '%s'\n", szFile);
            OutputDebugString(sz);
        }
#endif

        if (Where(szFile, szClientFile, NUMELMS(szClientFile)))
        {
            int cchRel = lstrlen(m_szClientRelative);

#ifdef DEBUG
            {
                char sz[2048];
                wsprintf(sz, "FixupRoot clientFile = '%s'\n", szClientFile);
                OutputDebugString(sz);
            }
#endif

            if (cchRel && !_strnicmp(szClientFile, m_szClientRelative, cchRel))
            {
                int cchClientFile = lstrlen(szClientFile);
                int cchRoot = lstrlen(s_szSDOpenedClientRoot);

                // left is the clientFile plus revision
                lstrcpyn(pszLeft, szClientFile, cchMaxLeft);
                lstrcpyn(pszLeft + cchClientFile, szRev, cchMaxLeft - cchClientFile);

                // right is the clientFile with much massaging, to transform
                // it into a usable file system path.
                lstrcpyn(pszRight, s_szSDOpenedClientRoot, cchMaxRight);
                if (cchRoot < cchMaxRight)
                    lstrcpyn(pszRight + cchRoot, szClientFile + cchRel, cchMaxRight - cchRoot);

                // convert all '/' to '\'
                for (char *psz = pszRight; *psz; psz++)
                    if (*psz == '/')
                        *psz = '\\';

                goto LOut;
            }
        }
    }

    // left is the filename plus revision
    lstrcpyn(pszLeft, szFile, cchMaxLeft);
    lstrcpyn(pszLeft + cch, szRev, cchMaxLeft - cch);

    // right is just the filename
    lstrcpyn(pszRight, szFile, cchMaxRight);

LOut:
#ifdef DEBUG
    {
        char sz[2048];
        wsprintf(sz, "FixupRoot output; pszLeft = '%s'\n", pszLeft);
        OutputDebugString(sz);
        wsprintf(sz, "FixupRoot output; pszRight = '%s'\n", pszRight);
        OutputDebugString(sz);
    }
#endif
    ;
}


BOOL SDServer::Where(const char *pszLocalFile, char *pszClientFile, int cchMax)
{
    BOOL fRet;
    TempFileManager tmpmgr;
    HANDLE h = NULL;

    *pszClientFile = 0;

    m_pszX = pszClientFile;
    m_cchX = cchMax;

    if (!m_papi)
    {
        // if we're going to launch sd.exe, create a temp file.
        if (!tmpmgr.FInitialize(1))
            return FALSE;
        h = tmpmgr.GetHandle(0);
    }

    fRet = Run(sdWhere, pszLocalFile, h, NULL, NULL);

    if (!m_papi)
    {
        char sz[2048];                  // we'll only read the first 2kb
        char *psz;
        DWORD dw = sizeof(sz) - 1;
        BOOL fSkipToTag;

        // read the temp file
        if (SetFilePointer(h, 0, 0, FILE_BEGIN) == 0xffffffff ||
            !ReadFile(h, sz, dw, &dw, NULL))
        {
            fRet = FALSE;
            goto LError;
        }
        sz[dw] = 0;

        // parse the temp file
        fSkipToTag = FALSE;
        for (psz = strtok(sz, "\r\n"); psz; psz = strtok(NULL, "\r\n"))
        {
            if (fSkipToTag && strncmp("... tag ", psz, 8) != 0)
                continue;

            fSkipToTag = FALSE;
            if (strncmp("... unmap", psz, 9) == 0)
            {
                fSkipToTag = TRUE;
                continue;
            }

            if (strncmp("... clientFile ", psz, 15) == 0)
            {
                lstrcpyn(pszClientFile, psz + 15, cchMax);
                break;
            }
        }
    }

LError:
    m_pszX = 0;
    m_cchX = 0;
    return fRet;
}


BOOL SDServer::Run(SDCommand cmd, const char *pszArgs, HANDLE hFile, HANDLE hFileErr, const char *pszCwd)
{
    BOOL fRet = FALSE;
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    SDClientUser *pui = 0;
    char sz[MAX_PATH * 2];

    static const char *c_rgCmd[] =
    {
        "changes -m1",
        "print -q",
        "opened -l",
        "describe -s",
        "where -Tfoo",
    };
    // this compile-time assert ensures the c_rgCmd array has the same number
    // of elements as the SDCommand enumeration.
    extern x_rgDummy[(NUMELMS(c_rgCmd) == sdMAX) ? 1 : -1];

#ifdef DEBUG
    if (cmd != sdExists && cmd != sdWhere)
        _ASSERT(hFile);
#endif

    if (m_papi)
    {
        pui = new SDClientUser;
        if (!pui)
            goto LError;

        if (*s_szSDPort)
            m_papi->SetPort(s_szSDPort);
        if (*s_szSDClient)
            m_papi->SetClient(s_szSDClient);
        else if (m_szClient)
            m_papi->SetClient(m_szClient);

        pui->SetCommand(cmd, hFile, hFileErr);
        pui->SetBuffer(m_pszX, m_cchX);

        ZeroMemory(sz, sizeof(sz));

        _snprintf(sz, sizeof(sz)-1, "%s %s", c_rgCmd[cmd], pszArgs);

#ifdef DEBUG
        OutputDebugString("WINDIFF/SD run: '");
        OutputDebugString(sz);
        OutputDebugString("'\n");
#endif

        HRESULT hr = m_papi->Run(sz, pui, FALSE);

        if (!SUCCEEDED(hr))
        {
            const char *pszError;
            m_papi->GetErrorString(&pszError);
            if (pszError)
                pui->OutputError(pszError);
        }

        fRet = SUCCEEDED(hr) && pui->FSucceeded();

#ifdef DEBUG
        {
            char sz[1024];
            wsprintf(sz, "WINDIFF/SD run: %s\n",
                     fRet ? "succeeded." : "FAILED!");
            OutputDebugString(sz);
        }
#endif
    }
    else
    {
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW;
        si.wShowWindow = SW_HIDE;

        lstrcpy(sz, "sd.exe");
        if (*s_szSDPort)
        {
            lstrcat(sz, " -p ");
            lstrcat(sz, s_szSDPort);
        }
        if (*s_szSDClient || *m_szClient)
        {
            lstrcat(sz, " -c ");
            lstrcat(sz, *s_szSDClient ? s_szSDClient : m_szClient);
        }
        lstrcat(sz, " ");
        lstrcat(sz, c_rgCmd[cmd]);
        lstrcat(sz, " ");
        lstrcat(sz, pszArgs);

        switch (cmd)
        {
        case sdExists:
            _ASSERT(pszCwd);
            break;
        case sdPrint:
            if (s_fOpened && *s_szSDOpenedCwd)
                pszCwd = s_szSDOpenedCwd;
            // fall thru
        case sdOpened:
        case sdDescribe:
        case sdWhere:
            si.dwFlags |= STARTF_USESTDHANDLES;
            si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
            si.hStdOutput = hFile;
            si.hStdError = hFileErr;
            if (!hFileErr || hFileErr == INVALID_HANDLE_VALUE)
                si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
            break;
        default:
            _ASSERT(0);                 // oops
            break;
        }

#ifdef DEBUG
        {
            char szX[1024];
            wsprintf(szX, "WINDIFF/SD cmdline = '%s', cwd = '%s'\n", sz, pszCwd ? pszCwd : "");
            OutputDebugString(szX);
        }
        if (pszCwd)
            _ASSERT(*pszCwd);
#endif

        if (CreateProcess(0, sz, 0, 0, TRUE, NORMAL_PRIORITY_CLASS, 0, pszCwd, &si, &pi))
        {
            DWORD dw;

            WaitForSingleObject(pi.hProcess, INFINITE);

            switch (cmd)
            {
            case sdExists:
            case sdOpened:
            case sdDescribe:
            case sdWhere:
                fRet = (GetExitCodeProcess(pi.hProcess, &dw) && !dw);
                break;
            case sdPrint:
                // this seems wrong, but this is what the logic used to be,
                // and we know this won't cause a regression.
                fRet = TRUE;
                if (GetExitCodeProcess(pi.hProcess, &dw) && dw > 0)
                    fRet = FALSE;
                break;
            default:
                _ASSERT(0);             // oops
                break;
            }
        }
    }

LError:
    if (pui)
        pui->Release();
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return fRet;
}



// -- end C++ -------------------------------------------------------------
extern "C" {


/*
 * create a slm object for the given directory. The pathname may include
 * a filename component.
 * If the directory is not enlisted in a SLM library, this will return NULL.
 *
 * Check that the directory is valid, and that we can open slm.ini, and
 * build a UNC path to the master source library before declaring everything
 * valid.
 *
 * *pidsError is set to 0 on success, or the recommended error string on failure.
 */
SLMOBJECT
SLM_New(LPCSTR pathname, UINT *pidsError)
{
    SLMOBJECT pslm;
    char tmppath[MAX_PATH];
    char slmpath[MAX_PATH];
    LPSTR pszFilenamePart;
    HANDLE fh = INVALID_HANDLE_VALUE;
    BOOL bOK = FALSE;
    LPCSTR pfinal = NULL;
    UINT idsDummy;
    BOOL fDepotSyntax = (s_fDescribe || (pathname && pathname[0] == '/' && pathname[1] == '/'));

#ifdef DEBUG
    {
        char sz[1024];
        wsprintf(sz, "SLM_New, pathname = '%s'\n", pathname ? pathname : "");
        OutputDebugString(sz);
    }
#endif

    if (!pidsError)
        pidsError = &idsDummy;
    *pidsError = IDS_BAD_SLM_INI;

    // allocate memory for the object (we rely on the fact that gmem_get
    // always zero-inits allocations).

    pslm = (SLMOBJECT) gmem_get(hHeap, sizeof(struct _slmobject));

    if (pslm == NULL)
        return(NULL);                   // (lame string, but pretty unlikely)

    if (pathname == NULL)
        pathname = ".";

    /*
     * find the directory portion of the path.
     */
    if (fDepotSyntax)
    {
        lstrcpy(pslm->CurDir, pathname);
        pszFilenamePart = My_mbsrchr(pslm->CurDir, '/');
        if (!pszFilenamePart)
            goto LError;
        *pszFilenamePart = 0;
    }
    else if (dir_isvaliddir(pathname))
    {
        /*
         * its a valid directory as it is.
         */
        lstrcpy(pslm->CurDir, pathname);
    }
    else
    {
        /* it's not a valid directory, perhaps because it has a filename on
         * the end. remove the final element and try again.
         */

        pfinal = My_mbsrchr(pathname, '\\');
        if (pfinal == NULL)
        {
            /*
             * there is no backslash in this name and it is not a directory
             * - it can only be valid if it is a file in the current dir.
             * so create a current dir of '.'
             */
            lstrcpy(pslm->CurDir, ".");

            // remember the final element in case it was a wild card
            pfinal = pathname;
        }
        else
        {
            /*
             * pfinal points to the final backslash.
             */
            My_mbsncpy(pslm->CurDir, pathname, (size_t)(pfinal - pathname));
        }
    }

    // is this a UNC path?

    if (memcmp("\\\\", pslm->CurDir, 2) == 0)
        pslm->fUNC = TRUE;

    // need to translate the root?

    if (fDepotSyntax || s_fDescribe)
        pslm->fFixupRoot = FALSE;
    else if (s_fOpened && !s_fFixupRoot)
        pslm->fFixupRoot = FALSE;
    else
        pslm->fFixupRoot = pslm->fUNC;

    // initialize path variables so we can search for slm.ini and/or sd.ini

    if (!fDepotSyntax)
    {
        lstrcpy(tmppath, pslm->CurDir);
        if (pslm->CurDir[lstrlen(pslm->CurDir) -1] != '\\')
            lstrcat(tmppath, "\\");
        if (!_fullpath(slmpath, tmppath, sizeof(slmpath)))
            goto LError;
        pszFilenamePart = slmpath + lstrlen(slmpath);

        // look for slm.ini in the specified directory

        if (!s_fForceSD)
        {
            lstrcpy(pszFilenamePart, "slm.ini");
            fh = CreateFile(slmpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        }
    }

    // try looking for SD.INI

    if (fh == INVALID_HANDLE_VALUE)
    {
        // look for SD.INI in the specified directory, moving upwards

        *pszFilenamePart = 0;
        while (pszFilenamePart > slmpath)
        {
            lstrcpy(pszFilenamePart, "sd.ini");
            fh = CreateFile(slmpath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
            if (fh != INVALID_HANDLE_VALUE)
            {
                int ii;

                // assume that the sd.ini file is in the client root path

                if (pslm->fFixupRoot)
                {
                    if (*s_szSDOpenedClientRoot)
                    {
                        lstrcpy(pslm->SlmRoot, s_szSDOpenedClientRoot);
                        ii = lstrlen(pslm->SlmRoot);
                    }
                    else
                    {
                        lstrcpy(pslm->SlmRoot, slmpath);
                        ii = (int)(pszFilenamePart - slmpath);
                        pslm->SlmRoot[ii] = 0;
                    }

                    if (ii >= 0 && pslm->SlmRoot[ii - 1] != '\\')
                    {
                        pslm->SlmRoot[ii++] = '\\';
                        pslm->SlmRoot[ii] = 0;
                    }
                }

                *pszFilenamePart = 0;

                pslm->pSD = SDServer::GetServer(s_fOpened ? NULL : slmpath);

                if (!pslm->pSD)
                    goto LError;

                pslm->fSourceDepot = TRUE;
                break;
            }

            // walk up the directory hierarchy and try again

            *pszFilenamePart = 0;
            pszFilenamePart = DirUpOneLevel(slmpath);
            if (!pszFilenamePart || GetFileAttributes(slmpath) == 0xffffffff)
                break;
            *(pszFilenamePart++) = '\\';
            *pszFilenamePart = 0;
        }

        // if we couldn't find an SD.INI file but the user forced SD mode (-L!
        // or -LO or -LD or -LP or -LC or depot syntax was used), go ahead and
        // try to get an SDServer object.

        if (!pslm->fSourceDepot && s_fForceSD)
        {
            pslm->pSD = SDServer::GetServer(NULL);
            if (pslm->pSD)
            {
                pslm->fSourceDepot = TRUE;
                bOK = TRUE;
            }
        }
    }

    // if we found the SLM.INI or SD.INI file, read it now

    if (fh != INVALID_HANDLE_VALUE)
    {
        bOK = SLM_ReadIni(pslm, fh);

        /*
         * SLM:
         *
         * if pfinal is not null, then it might be a *.* wildcard pattern at
         * the end of the path - if so, we should append it to the masterpath.
         */
        if (pfinal && (My_mbschr(pfinal, '*') || My_mbschr(pfinal, '?')))
        {
            _ASSERT(!pslm->fSourceDepot);

            if ( (pslm->MasterPath[lstrlen(pslm->MasterPath)-1] != '\\') &&
                 (pfinal[0] != '\\'))
            {
                lstrcat(pslm->MasterPath, "\\");
            }
            lstrcat(pslm->MasterPath, pfinal);
        }

        CloseHandle(fh);
    }

LError:
    if (!bOK)
    {
        if (pslm && pslm->fSourceDepot)
            *pidsError = IDS_BAD_SD_INI;
        gmem_free(hHeap, (LPSTR) pslm, sizeof(struct _slmobject));
        pslm = 0;
    }
    else
        *pidsError = 0;
    return(pslm);
}



/*
 * read slm.ini data from a file handle and
 * fill in the master path field of a slm object. return TRUE if
 * successful.
 * Read slm.ini in the current directory.  Its syntax is
 * project = pname
 * slm root = //server/share/path or //drive:disklabel/path (note forward /'s)
 * user root = //drive:disklabel/path
 * subdir = /subdirpath
 * e.g.
 *
 * project = media
 * slm root = //RASTAMAN/NTWIN
 * user root = //D:LAURIEGR6D/NT/PRIVATE/WINDOWS/MEDIA
 * sub dir = /
 *
 * and what we copy to pslm->MasterPath is
 * \\server\share\src\pname\subdirpath
 */
BOOL
SLM_ReadIni(SLMOBJECT pslm, HANDLE fh)
{
    BOOL fRet = FALSE;  // assume failure
    char *buffer = 0;   // sd.ini may be large (e.g. contains comment lines)
    const int c_cbBuffer = 8192;
    DWORD cBytes;

    // SD.INI -------------------------------------------------------------

    if (pslm->fSourceDepot)
    {
        if (pslm->fFixupRoot)
        {
            BOOL fFoundClientName = FALSE;

            buffer = gmem_get(hHeap, c_cbBuffer);
            if (!buffer)
                goto LError;

            if (!ReadFile(fh, buffer, c_cbBuffer, &cBytes, NULL))
                goto LError;

            if (cBytes > 0)
            {
                if (cBytes == c_cbBuffer)
                    cBytes--;
                buffer[cBytes] = 0;

                char *pszTokenize = buffer;
                char *pszName;

                while ((pszName = strtok(pszTokenize, "\r\n")) != NULL)
                {
                    // don't restart tokenization
                    pszTokenize = 0;

                    char *pszValue = 0;
                    char *pszStrip = 0;
                    char *pszWalk;

                    // get variable name and value
                    pszValue = strchr(pszName, '=');
                    if (pszValue)
                    {
                        *pszValue = 0;
                        pszValue++;
                    }

#ifdef DEBUG
                    {
                        char sz[1024];
                        _snprintf(sz, NUMELMS(sz), "name='%s', value='%s'\r\n",
                                  pszName ? pszName : "<none>",
                                  pszValue ? pszValue : "<none>");
                        OutputDebugString(sz);
                    }
#endif

                    // didn't find a value; get next token
                    if (!pszValue)
                        continue;

                    // skip leading whitespace on pszName
                    while (*pszName == ' ')
                        pszName++;
                    // find end of pszName
                    for (pszWalk = pszName; *pszWalk; pszWalk++)
                        if (*pszWalk != ' ')
                            pszStrip = pszWalk + 1;
                    // strip trailing whitespace on pszName
                    if (pszStrip)
                        *pszStrip = 0;

                    // we're basically looking for SDCLIENT
                    if (_stricmp(pszName, "SDCLIENT") == 0)
                    {
                        // skip leading whitespace on the value
                        while (*pszValue == ' ')
                            ++pszValue;
                        // find end of the value
                        for (pszWalk = pszValue; *pszWalk; pszWalk++)
                            if (*pszWalk != ' ')
                                pszStrip = pszWalk + 1;
                        // strip trailing whitespace from the value
                        if (pszStrip)
                            *pszStrip = 0;

                        // got the value
                        if (*pszValue)
                        {
                            fFoundClientName = TRUE;
                            pslm->pSD->SetClient(pszValue);

#ifdef DEBUG
                            {
                                char sz[1024];
                                wsprintf(sz, "client = '%s'\n", pszValue);
                                OutputDebugString(sz);
                            }
#endif
                        }
                        break;
                    }
                }
            }

            if (!fFoundClientName)
            {
                // computer names can exceed MAX_COMPUTERNAME_LENGTH
                char sz[MAX_COMPUTERNAME_LENGTH * 2];
                DWORD dw = sizeof(sz) - 1;

                // the SD.INI file exists, but does not specify the client
                // name, so if the path is a UNC path or a remote path,
                // let's make an educated guess.  this helps the case
                // where someone is trying to do a code review using -L or
                // -LO but the reviewee's client configuration is 'adhoc'.

#ifdef DEBUG
                OutputDebugString("found SD.INI, but SDCLIENT is not defined\n");
#endif

                *sz = 0;
                if (pslm->fUNC)
                {
                    if (*pslm->SlmRoot)
                    {
                        LPSTR pszMachineBegin = pslm->SlmRoot + 2;
                        LPSTR pszMachineEnd = pszMachineBegin;

                        while (*pszMachineEnd && *pszMachineEnd != '\\' && *pszMachineEnd != '/')
                            pszMachineEnd++;

                        if (DWORD(pszMachineEnd - pszMachineBegin) < dw)
                        {
                            dw = DWORD(pszMachineEnd - pszMachineBegin);
                            memcpy(sz, pszMachineBegin, dw);
                            sz[dw] = 0;
                        }
                    }
                }
                else
                {
                    // if the drive is local, we're probably better off
                    // letting SD or SDAPI figure things out anyway.  if
                    // the drive is remote, we could try to figure out the
                    // corresponding UNC path, but it's not worth the
                    // dev cost right now.

                    s_fFixupRoot = pslm->fFixupRoot = FALSE;
                }

                if (*sz)
                    pslm->pSD->SetClient(sz);
            }
        }

        // success
        fRet = TRUE;
        goto LError;
    }

    // SLM.INI ------------------------------------------------------------

    char *tok;
    char *slmroot;
    char *project;
    char *subdir;

    // only allocate on demand
    if (!buffer)
        buffer = gmem_get(hHeap, c_cbBuffer);
    if (!buffer)
        goto LError;

    // read from ini file
    if (!ReadFile(fh, buffer, c_cbBuffer, &cBytes, NULL) || !cBytes)
        goto LError;
    if (cBytes == c_cbBuffer)
        cBytes--;       // make room for sentinel
    buffer[cBytes] = 0;   /* add a sentinel */

    tok = strtok(buffer, "=");  /* project = (boring) */
    if (!tok)
        goto LError;

    project = strtok(NULL, " \r\n");  /* project name (remember) */
    if (!project) {
        return(FALSE);
    }

    tok = strtok(NULL, "=");  /* slm root */
    if (!tok)
        goto LError;

    slmroot = strtok(NULL, " \r\n");  /* PATH!! (but with / for \ */
    if (!slmroot){
        return(FALSE);
    }

    lstrcpy( pslm->SlmProject, project );
    lstrcpy( pslm->SlmRoot, slmroot );

    /* start to build up what we want */

    if ('/' == slmroot[0] &&
        '/' == slmroot[1] &&
        (('A' <= slmroot[2] && 'Z' >= slmroot[2]) ||
         ('a' <= slmroot[2] && 'z' >= slmroot[2])) &&
        ':' == slmroot[3])
    {
        // Convert slm root from //drive:disklabel/path to drive:/path

        pslm->MasterPath[0] = slmroot[2];
        pslm->MasterPath[1] = ':';
        tok = strchr(&slmroot[4], '/');
        if (!tok)
            goto LError;
        lstrcpy(&pslm->MasterPath[2], tok);
    }
    else
    {
        lstrcpy(pslm->MasterPath, slmroot);
    }

    lstrcat(pslm->MasterPath,"\\src\\");
    lstrcat(pslm->MasterPath, project);

    tok = strtok(NULL, "=");  /* ensure get into next line */
    if (!tok)
        goto LError;
    tok = strtok(NULL, "=");
    if (!tok)
        goto LError;

    if (*tok == '\"')
        tok++;

    subdir = strtok(NULL, " \"\r\n");  /* PATH!! (but with / for \*/
    if (!subdir)
        goto LError;

    lstrcpy( pslm->SubDir, subdir );

    lstrcat(pslm->MasterPath, subdir);

    /* convert all / to \  */
    {
        int ith;
        for (ith=0; pslm->MasterPath[ith]; ith++) {
            if (pslm->MasterPath[ith]=='/') {
                pslm->MasterPath[ith] = '\\';
            }
        }
    }

    // success
    fRet = TRUE;

LError:
    gmem_free(hHeap, buffer, c_cbBuffer);
    return fRet;
}


/*
 * free up all resources associated with a slm object. The SLMOBJECT is invalid
 * after this call.
 */
void
SLM_Free(SLMOBJECT pSlm)
{
    if (pSlm != NULL) {
        gmem_free(hHeap, (LPSTR) pSlm, sizeof(struct _slmobject));
    }
}


/*
 * free lingering SDServer objects.  this also disconnects from any SD servers
 * that are currently connected.
 */
void
SLM_FreeAll(void)
{
    SDServer::FreeAll();
}


/*
 * get the pathname of the master source library for this slmobject. The
 * path (UNC format) is copied to masterpath, which must be at least
 * MAX_PATH in length.
 */
BOOL
SLM_GetMasterPath(SLMOBJECT pslm, LPSTR masterpath)
{
    if (pslm == NULL) {
        return(FALSE);
    } else {
        lstrcpy(masterpath, pslm->MasterPath);
        return(TRUE);
    }
}


BOOL SLM_FServerPathExists(LPCSTR pszPath)
{
    BOOL fExists = FALSE;
    SLMOBJECT pslm;

    pslm = SLM_New(pszPath, 0);
    if (pslm)
    {
        if (pslm->fSourceDepot)
        {
            char szArgs[MAX_PATH * 2];
            char szRelative[MAX_PATH * 2];
            LPCSTR pszRelative;
            LPSTR psz;

            // run 'sd changes -m1 ...' and see if it finds anything

            if (pslm->fFixupRoot && pslm->pSD->GetClientRelative())
            {
                pszRelative = pszPath;
                pszRelative += lstrlen(pslm->SlmRoot);
                // convert all backslashes to forward slashes, since
                // client-relative pathnames don't work otherwise
                lstrcpy(szRelative, pszRelative);
                for (psz = szRelative; *psz; psz++)
                    if (*psz == '\\')
                        *psz = '/';

                wsprintf(szArgs, "%s%s...", pslm->pSD->GetClientRelative(), szRelative);
            }
            else
            {
                int cch;
                lstrcpy(szRelative, pszPath);
                cch = lstrlen(szRelative);
                if (cch && szRelative[cch - 1] != '\\')
                    lstrcpy(szRelative + cch, "\\");
                wsprintf(szArgs, "%s...", szRelative);
            }

            _ASSERT(pslm->pSD);

            fExists = pslm->pSD->Exists(szArgs, pszPath);
        }
        else
        {
            DWORD dw;

            dw = GetFileAttributes(pslm->MasterPath);
            fExists = (dw != (DWORD)-1) && (dw & FILE_ATTRIBUTE_DIRECTORY);
        }

        SLM_Free(pslm);
    }

    return fExists;
}


/*
 * extract a previous version of the file to a temp file. Returns in tempfile
 * the name of a temp file containing the requested file version. The 'version'
 * parameter should contain a SLM file & version in the format file.c@vN.
 * eg
 *    file.c@v1         is the first version
 *    file.c@v-1        is the previous version
 *    file.c@v.-1       is yesterdays version
 *
 * we use catsrc to create the previous version.
 */
BOOL
SLM_GetVersion(SLMOBJECT pslm, LPSTR version, LPSTR tempfile)
{
    TempFileManager tmpmgr;
    char commandpath[MAX_PATH * 2];
    char szPath[MAX_PATH];
    char *pszDir = 0;
    BOOL fDepotSyntax = (s_fDescribe || (version && version[0] == '/' && version[1] == '/'));

    BOOL bOK = FALSE;
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    // init 1 temp file
    if (!tmpmgr.FInitialize(1))
        return(FALSE);

    // create a process to run catsrc
    if (pslm->fSourceDepot)
    {
        if (fDepotSyntax)
        {
            wsprintf(commandpath, "\"%s\"", version);
        }
        else if (pslm->fFixupRoot && pslm->pSD->GetClientRelative())
        {
            int cchRoot = lstrlen(pslm->SlmRoot);
            LPSTR psz;

            *szPath = 0;
            if (cchRoot >= 0 && cchRoot < lstrlen(pslm->CurDir))
            {
                const char *pszFilename = version;
                const char *pszWalk;

                lstrcpy(szPath, pslm->CurDir + cchRoot);
                lstrcat(szPath, "\\");

                for (pszWalk = version; *pszWalk; ++pszWalk)
                    if (*pszWalk == '/' || *pszWalk == '\\')
                        pszFilename = pszWalk + 1;

                lstrcat(szPath, pszFilename);
            }
            else
            {
                lstrcat(szPath, version);
            }

            // convert all backslashes to forward slashes, since
            // client-relative pathnames don't work otherwise
            for (psz = szPath; *psz; psz++)
                if (*psz == '\\')
                    *psz = '/';

            wsprintf(commandpath, "\"%s%s\"", pslm->pSD->GetClientRelative(), szPath);
            pszDir = pslm->CurDir;
        }
        else
        {
            lstrcpy(szPath, pslm->CurDir);
            if (strchr(version, '\\'))
                wsprintf(commandpath, "\"%s\"", version);
            else
                wsprintf(commandpath, "\"%s\\%s\"", pslm->CurDir, version);
            pszDir = pslm->CurDir;
        }

        _ASSERT(pslm->pSD);

        bOK = pslm->pSD->Print(commandpath, tmpmgr.GetHandle(0), pszDir);
    }
    else
    {
        wsprintf(commandpath, "catsrc -s \"%s\" -p \"%s%s\" \"%s\"", pslm->SlmRoot, pslm->SlmProject, pslm->SubDir, version);

        FillMemory(&si, sizeof(si), 0);
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = tmpmgr.GetHandle(0);
        si.hStdError = GetStdHandle(STD_ERROR_HANDLE);
        si.wShowWindow = SW_HIDE;

        bOK = CreateProcess(
                           NULL,
                           commandpath,
                           NULL,
                           NULL,
                           TRUE,
                           NORMAL_PRIORITY_CLASS,
                           NULL,
                           pszDir,
                           &si,
                           &pi);

        if (bOK)
        {
            DWORD dw;

            WaitForSingleObject(pi.hProcess, INFINITE);

            if (pslm->fSourceDepot && GetExitCodeProcess(pi.hProcess, &dw) && dw > 0)
                bOK = FALSE;

            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
    }

    *tempfile = 0;

#ifdef DEBUG
    {
        char sz[1024];
        wsprintf(sz, "SLM_GetVersion: %s  ('%s')\n",
                 bOK ? "succeeded." : "FAILED!", tmpmgr.GetFilename(0));
        OutputDebugString(sz);
    }
#endif

    if (bOK)
    {
        // success, keep the tempfile and return the filename
        tmpmgr.KeepFile(0);
        lstrcpyn(tempfile, tmpmgr.GetFilename(0), MAX_PATH);
    }

    return(bOK);
}


/*
 * We don't offer SLM options unless we have seen a correct slm.ini file.
 *
 * Once we have seen a slm.ini, we log this in the profile and will permit
 * slm operations from then on. This function is called by the UI portions
 * of windiff: it returns TRUE if it is ok to offer SLM options.
 * Return 0 - This user hasn't touched SLM,
 *        1 - They have used SLM at some point (show basic SLM options)
 *        2 - They're one of us, so tell them the truth
 *        3 - (= 1 + 2).
 */
int
IsSLMOK(void)
{
    int Res = 0;;
    if (GetProfileInt(APPNAME, "SLMSeen", FALSE)) {
        // we've seen slm  - ok
        ++Res;
    } else {

        // haven't seen SLM yet - is there a valid slm enlistment in curdir?
        SLMOBJECT hslm;

        hslm = SLM_New(".", 0);
        if (hslm != NULL) {

            // yes - current dir is enlisted. log this in profile
            SLM_Free(hslm);
            WriteProfileString(APPNAME, "SLMSeen", "1");
            ++Res;
        } else {
            // aparently not a SLM user.
        }
    }

    if (GetProfileInt(APPNAME, "SYSUK", FALSE)) {
        Res+=2;
    }
    return Res;
}


int
IsSourceDepot(SLMOBJECT hSlm)
{
    if (hSlm)
        return hSlm->fSourceDepot;
    return s_fForceSD;
}

const char c_szSharpHead[] = "#head";

LPSTR SLM_ParseTag(LPSTR pszInput, BOOL fStrip)
{
    LPSTR psz;
    LPSTR pTag;

    psz = My_mbschr(pszInput, '@');
    if (!psz)
    {
        psz = My_mbschr(pszInput, '#');
        if (psz)
        {
            /*
             * look for SD tags beginning # and separate if there.
             */
            LPCSTR pszRev = psz + 1;
            if (memcmp(pszRev, "none", 5) != 0 &&
                memcmp(pszRev, "head", 5) != 0 &&
                memcmp(pszRev, "have", 5) != 0)
            {
                for (BOOL fFirst = TRUE; *pszRev; ++pszRev)
                {
                    if (fFirst)
                    {
                        fFirst = FALSE;

                        // support relative revision syntax, where revision
                        // number begins with - or + character.
                        if (*pszRev == '-' || *pszRev == '+')
                            continue;
                    }

                    // revision numbers must be wholly numeric (except for
                    // relative revision qualifiers, as noted above).
                    if (*pszRev < '0' || *pszRev > '9')
                    {
                        psz = 0;
                        break;
                    }
                }
            }
        }
    }

    // If no explicit tag but this is in depot syntax, then default to #head
    if (!psz && IsDepotPath(pszInput))
    {
        psz = (LPSTR)c_szSharpHead;
    }

    if (psz && fStrip)
    {
        pTag = gmem_get(hHeap, lstrlen(psz) + 1);
        lstrcpy(pTag, psz);
        // insert NULL to blank out the tag in the string
        if (psz != c_szSharpHead) *psz = '\0';
    }
    else
    {
        pTag = psz;
    }

    return pTag;
}


/*----------------------------------------------------------------------------
    ::SLM_GetOpenedFiles
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_GetOpenedFiles()
{
    TempFileManager tmpmgr;
    char *pszDir = 0;
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR popened = 0;
    FILEBUFFER file = 0;
    HANDLE hfile = INVALID_HANDLE_VALUE;
    SDServer *pSD;
    char szArgs[1024];
    size_t cch;

    // init 2 temp files
    if (!tmpmgr.FInitialize(2))
        goto LError;

    // get SDServer object
    pSD = SDServer::GetServer(NULL);
    if (!pSD)
        goto LError;

    // build args for 'sd opened' by combining the change number (-LO1234) and
    // file argument (-LO1234 filearg).
    cch = 0;
    if (*s_szSDChangeNumber)
    {
        lstrcpyn(szArgs, s_szSDChangeNumber, NUMELMS(szArgs) - 1);
        cch = lstrlen(szArgs);
        szArgs[cch++] = ' ';
    }
    lstrcpyn(szArgs + cch, s_szSDOpenedArgs, NUMELMS(szArgs) - cch);

    // run the 'sd opened' command
    if (pSD->Opened(szArgs, tmpmgr.GetHandle(0), tmpmgr.GetHandle(1)))
    {
        LPSTR psz;
        int L_cch;
        BOOL fUnicode;                  // dummy, since SD opened -l will never write out a unicode file
        LPWSTR pwz;                     // dummy, since SD opened -l will never write out a unicode file
        int cwch;                       // dummy, since SD opened -l will never write out a unicode file

        hfile = CreateFile(tmpmgr.GetFilename(0), GENERIC_READ,
                           FILE_SHARE_WRITE|FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, 0, NULL);
        if (hfile == INVALID_HANDLE_VALUE)
            goto LError;

        file = readfile_new(hfile, &fUnicode);
        if (file)
        {
            readfile_setdelims(reinterpret_cast<unsigned char*>("\n"));
            while (TRUE)
            {
                psz = readfile_next(file, &L_cch, &pwz, &cwch);
                if (!psz)
                    break;

                if (*psz)
                {
                    if (L_cch >= NUMELMS(popened->m_szLeft))
                        goto LError;

                    popened = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*popened));
                    if (!popened)
                        goto LError;

                    // left file will be in client namespace (//client/...)
                    // and right file will be in the file system namespace
                    // specified as the argument to -LO (or local file system
                    // namespace if no filename argument was specified).
                    // strip revision from right file (valid to not find '#',
                    // e.g. opened for add).  keep revision for left file, but
                    // strip everything following it.
                    pSD->FixupRoot(psz, L_cch,
                                   popened->m_szLeft, NUMELMS(popened->m_szLeft),
                                   popened->m_szRight, NUMELMS(popened->m_szRight));

                    if (!pHead)
                    {
                        pHead = popened;
                        pTail = popened;
                    }
                    else
                    {
                        pTail->m_pNext = popened;
                        pTail = popened;
                    }
                    popened = 0;
                }
            }
            readfile_delete(file);
            file = 0;
        }
    }
    else
    {
        tmpmgr.MsgBoxFromFile(1, "Source Depot Error", MB_OK|MB_ICONERROR);
    }

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)popened, sizeof(*popened));
    while (pHead)
    {
        popened = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)popened, sizeof(*popened));
    }
    if (file)
        readfile_delete(file);
    if (hfile != INVALID_HANDLE_VALUE)
        CloseHandle(hfile);
    return pReturn;
}


/*----------------------------------------------------------------------------
    ::SLM_GetDescribeFiles
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_GetDescribeFiles()
{
    TempFileManager tmpmgr;
    int nChange;
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR ppair = 0;
    FILEBUFFER file = 0;
    HANDLE hfile = INVALID_HANDLE_VALUE;
    SDServer *pSD;

    // init 2 temp files
    if (!tmpmgr.FInitialize(2))
        goto LError;

    // get SDServer object
    pSD = SDServer::GetServer(NULL);
    if (!pSD)
        goto LError;

    // run the 'sd describe' command
    nChange = atoi(s_szSDChangeNumber);
    if (pSD->Describe(s_szSDChangeNumber, tmpmgr.GetHandle(0), tmpmgr.GetHandle(1)))
    {
        LPSTR psz;
        int cch;
        BOOL fUnicode;                  // dummy, since SD describe will never write out a unicode file
        LPWSTR pwz;                     // dummy, since SD describe will never write out a unicode file
        int cwch;                       // dummy, since SD describe will never write out a unicode file

        hfile = CreateFile(tmpmgr.GetFilename(0), GENERIC_READ,
                           FILE_SHARE_WRITE|FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, 0, NULL);
        if (hfile == INVALID_HANDLE_VALUE)
            goto LError;

        file = readfile_new(hfile, &fUnicode);
        if (file)
        {
            BOOL fAffectedFiles = FALSE;

            readfile_setdelims(reinterpret_cast<unsigned char*>("\n"));
            while (TRUE)
            {
                psz = readfile_next(file, &cch, &pwz, &cwch);
                if (!psz)
                    break;

                if (*psz)
                {
                    // look for the filenames
                    if (!fAffectedFiles)
                    {
                        if (strncmp(psz, "Affected files ...", 18) == 0)
                            fAffectedFiles = TRUE;
                        continue;
                    }

                    // if it isn't a filename, ignore it
                    if (strncmp(psz, "... ", 4) != 0)
                        continue;

                    psz += 4;
                    cch -= 4;

                    // avoid memory overrun
                    if (cch >= NUMELMS(ppair->m_szLeft))
                        goto LError;

                    // create node
                    ppair = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*ppair));
                    if (!ppair)
                        goto LError;

                    // build right filename
                    memcpy(ppair->m_szRight, psz, cch);
                    ppair->m_szRight[cch] = 0;
                    psz = strchr(ppair->m_szRight, '#');
                    if (!psz)
                    {
                        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
                        goto LError;
                    }
                    wsprintf(psz, "@%d", nChange);

                    // build left filename
                    lstrcpy(ppair->m_szLeft, ppair->m_szRight);
                    psz = strchr(ppair->m_szLeft, '@') + 1;
                    wsprintf(psz, "%d", nChange - 1);

                    // link this node
                    if (!pHead)
                    {
                        pHead = ppair;
                        pTail = ppair;
                    }
                    else
                    {
                        pTail->m_pNext = ppair;
                        pTail = ppair;
                    }
                    ppair = 0;
                }
            }
            readfile_delete(file);
            file = 0;
        }
    }
    else
    {
        tmpmgr.MsgBoxFromFile(1, "Source Depot Error", MB_OK|MB_ICONERROR);
    }

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    while (pHead)
    {
        ppair = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    }
    if (file)
        readfile_delete(file);
    if (hfile != INVALID_HANDLE_VALUE)
        CloseHandle(hfile);
    return pReturn;
}


/*----------------------------------------------------------------------------
    ::PerformReplacement
        Call with pszReplacement == NULL to ask if pszTemplate is replaceable.
        Otherwise, replaces {} in pszTemplate with pszReplacement.

    Author: JeffRose, ChrisAnt
----------------------------------------------------------------------------*/
BOOL PerformReplacement(LPCSTR pszTemplate, LPCSTR pszReplacement, LPSTR pszDest, int cchDest)
{
    BOOL fReplacing = FALSE;
    LPSTR pszNew;
    int cchReplacement;
    int cch;
    LPSTR psz;

    if (!pszTemplate)
        return FALSE;

    cch = lstrlen(pszTemplate) + 1;
    cchReplacement = pszReplacement ? lstrlen(pszReplacement) : 0;

    psz = (LPSTR)pszTemplate;
    while ((psz = strchr(psz, '{')) && psz[1] == '}')
    {
        fReplacing = TRUE;
        cch += cchReplacement - 2;
    }

    if (!pszReplacement)
        return fReplacing;

    pszNew = gmem_get(hHeap, cch);
    if (!pszNew)
        return FALSE;

    psz = pszNew;
    while (*pszTemplate)
    {
        if (pszTemplate[0] == '{' && pszTemplate[1] == '}')
        {
            lstrcpy(psz, pszReplacement);
            psz += cchReplacement;
            pszTemplate += 2;
        }
        else
            *(psz++) = *(pszTemplate++);
    }
    *psz = '\0';

    cch = lstrlen(pszNew);
    if (cch >= cchDest)
        cch = cchDest - 1;
    memcpy(pszDest, pszNew, cch);
    pszDest[cch] = '\0';

    gmem_free(hHeap, pszNew, lstrlen(pszNew));
    return TRUE;
}


static BOOL ParseFilename(const char **ppszSrc, int *pcchSrc, char *pszDest, int cchDest)
{
    BOOL fRet = FALSE;

    if (pcchSrc && *pcchSrc > 0 && ppszSrc && *ppszSrc && **ppszSrc && cchDest > 0)
    {
        BOOL fQuote = FALSE;

        // skip leading whitespace
        while (*pcchSrc > 0 && isspace(**ppszSrc))
        {
            ++(*ppszSrc);
            --(*pcchSrc);
        }

        // parse space delimited filename, with quoting support
        while (*pcchSrc > 0 && (fQuote || !isspace(**ppszSrc)) && **ppszSrc)
        {
            LPSTR pszNext = CharNext(*ppszSrc);
            int cch = (int)(pszNext - *ppszSrc);

            fRet = TRUE;

            if (**ppszSrc == '\"')
                fQuote = !fQuote;
            else
            {
                cchDest -= cch;
                if (cchDest < 1)
                    break;
                memcpy(pszDest, *ppszSrc, cch);
                pszDest += cch;
            }

            *ppszSrc = pszNext;
            *pcchSrc -= cch;
        }

        *pszDest = 0;
    }

    return fRet;
}


/*----------------------------------------------------------------------------
    ::SLM_ReadInputFile
        sorry for the duplicated code here.  SLM_GetOpenedFiles,
        SLM_GetDescribeFiles, and SLM_ReadInputFile are very similar and could
        be factored.  this is all a hack though, and we're under tight time
        constraints.

    Author: chrisant
----------------------------------------------------------------------------*/
LEFTRIGHTPAIR SLM_ReadInputFile(LPCSTR pszLeftArg,
                                LPCSTR pszRightArg,
                                BOOL fSingle,
                                BOOL fVersionControl)
{
    LEFTRIGHTPAIR pReturn = 0;
    LEFTRIGHTPAIR pHead = 0;
    LEFTRIGHTPAIR pTail = 0;
    LEFTRIGHTPAIR ppair = 0;
    HANDLE hfile = INVALID_HANDLE_VALUE;
    FILEBUFFER file = 0;
    LPSTR psz;
    int cch;
    BOOL fStdin = FALSE;                // reading from stdin
    BOOL fUnicode;                      // dummy, we don't support unicode input file
    LPWSTR pwz;                         // dummy, we don't support unicode input file
    int cwch;                           // dummy, we don't support unicode input file

    // note, we don't use lstrcmp because it performs a lexical comparison
    // (e.g. "coop" == "co-op") but we need a real comparison.  we don't use
    // strcmp either, because it would be the first place in Windiff that we
    // use strcmp.
    if (s_szInputFile[0] == '-' && s_szInputFile[1] == '\0')
    {
        fStdin = TRUE;

        hfile = GetStdHandle(STD_INPUT_HANDLE);

        if (!hfile || hfile == INVALID_HANDLE_VALUE)
            goto LError;
    }
    else
    {
        hfile = CreateFile(s_szInputFile, GENERIC_READ, FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, 0, NULL);
        if (hfile == INVALID_HANDLE_VALUE)
            goto LError;
    }

    file = readfile_new(hfile, fStdin ? NULL : &fUnicode);
    if (file && (fStdin || !fUnicode))
    {
        readfile_setdelims(reinterpret_cast<unsigned char*>("\n"));
        while (TRUE)
        {
            psz = readfile_next(file, &cch, &pwz, &cwch);
            if (!psz)
                break;

            while (cch && (psz[cch - 1] == '\r' || psz[cch - 1] == '\n'))
                --cch;

            if (cch && *psz)
            {
                int cFiles = 0;

                if (cch >= NUMELMS(ppair->m_szLeft))
                    goto LError;

                ppair = (LEFTRIGHTPAIR)gmem_get(hHeap, sizeof(*ppair));
                if (!ppair)
                    goto LError;

                if (fSingle)
                {
                    memcpy(ppair->m_szLeft, psz, cch);
                    ppair->m_szLeft[cch] = 0;
                    ++cFiles;
                }
                else
                {
                    LPCSTR pszParse = psz;

                    // get first filename
                    if (ParseFilename(&pszParse, &cch, ppair->m_szLeft, NUMELMS(ppair->m_szLeft)))
                        ++cFiles;
                    else
                        goto LContinue;

                    // get second filename
                    if (ParseFilename(&pszParse, &cch, ppair->m_szRight, NUMELMS(ppair->m_szRight)))
                        ++cFiles;
                }

                if (cFiles == 1)
                {
                    lstrcpy(ppair->m_szRight, ppair->m_szLeft);

                    if (fVersionControl)
                    {
                        psz = SLM_ParseTag(ppair->m_szRight, FALSE);
                        if (psz)
                            *psz = 0;
                        else
                            lstrcat(ppair->m_szLeft, "#have");
                    }
                }

                PerformReplacement(pszLeftArg, ppair->m_szLeft, ppair->m_szLeft, NUMELMS(ppair->m_szLeft));
                PerformReplacement(pszRightArg, ppair->m_szRight, ppair->m_szRight, NUMELMS(ppair->m_szRight));

                if (!pHead)
                {
                    pHead = ppair;
                    pTail = ppair;
                }
                else
                {
                    pTail->m_pNext = ppair;
                    pTail = ppair;
                }
                ppair = 0;

LContinue:
                gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
                ppair = 0;
            }
        }
        readfile_delete(file);
        file = 0;
    }

    pReturn = pHead;
    pHead = 0;

LError:
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    while (pHead)
    {
        ppair = pHead;
        pHead = pHead->m_pNext;
        gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    }
    if (file)
        readfile_delete(file);
    if (!fStdin && hfile != INVALID_HANDLE_VALUE)
        CloseHandle(hfile);
    return pReturn;
}


LPCSTR LEFTRIGHTPAIR_Left(LEFTRIGHTPAIR ppair)
{
    return ppair->m_szLeft;
}


LPCSTR LEFTRIGHTPAIR_Right(LEFTRIGHTPAIR ppair)
{
    return ppair->m_szRight;
}


LEFTRIGHTPAIR LEFTRIGHTPAIR_Next(LEFTRIGHTPAIR ppair)
{
    LEFTRIGHTPAIR pNext = ppair->m_pNext;
    gmem_free(hHeap, (LPSTR)ppair, sizeof(*ppair));
    return pNext;
}

}; // extern "C" (from third one)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\slmmgr.h ===
/*
 * slmmgr.h
 *
 * interface to SLM
 *
 * provides an interface to SLM libraries that will return the
 * SLM master library for a given directory, or extract into temp files
 * earlier versions of a SLM-controlled file
 *
 * Create a slmobject by passing SLM_New() the name of a file or directory
 * path. SLM_New will look for the slm.ini file in that directory, and then
 * extract information about the master source library. SLM_GetMasterPath()
 * will then return the pathname of the master source library for a given
 * slm.ini, and SLM_GetVersion (Win32 only) will execute one of the slm
 * applications to extract a previous version of one of the slm-controlled
 * files in that directory.
 */

/*
 * handle to a SLM object. you do not need to know the structure layout.
 */
typedef struct _slmobject FAR * SLMOBJECT;

/* handle to pair of filenames */
typedef struct _leftrightpair FAR * LEFTRIGHTPAIR;


/*
 * Forces the SLMMGR to assume Source Depot mode, without ever searching for
 * an SD.INI file.
 */
void SLM_ForceSourceDepot(void);


void SLM_SetSDPort(LPCSTR pszPort);
void SLM_SetSDClient(LPCSTR pszClient);
void SLM_SetSDChangeNumber(LPCSTR pszChangeNumber);
void SLM_OverrideUncRoot(LPCSTR pszUncRoot);


/*
 * Initialize the SLMMGR to do a Source Depot 'describe' command (implemented
 * via an ugly hack -- sorry!  time constraints and all; you understand).
 */
void SLM_Describe(LPCSTR pszChangeNumber);

/*
 * Initialize the SLMMGR with the argument to the -LO switch.  This will
 * perform a Source Depot 'opened' command but may need to set the current
 * directory first if the argument is a UNC path.
 */
void SLM_Opened(LPCSTR pszArg, UINT *pidsError);

/*
 * Initialize the SLMMGR to use the indicated input file.
 */
LPCSTR SLM_SetInputFile(LPCSTR pszInputFile);

/*
 * create a slm object for the given directory. The pathname may include
 * a filename component.
 * If the directory is not enlisted in a SLM library, this will return NULL.
 */
SLMOBJECT SLM_New(LPCSTR pathname, UINT *pidsError);


/*
 * free up all resources associated with a slm object. The SLMOBJECT is invalid
 * after this call.
 */
void SLM_Free(SLMOBJECT hSlm);
void SLM_FreeAll(void);                 // frees lingering SDServer objects

/*
 * get the pathname of the master source library for this slmobject. The
 * path (UNC format) is copied to masterpath, which must be at least
 * MAX_PATH in length.
 */
BOOL SLM_GetMasterPath(SLMOBJECT hslm, LPSTR masterpath);


BOOL SLM_FServerPathExists(LPCSTR pszPath);


LEFTRIGHTPAIR SLM_GetOpenedFiles();
LEFTRIGHTPAIR SLM_GetDescribeFiles();
LEFTRIGHTPAIR SLM_ReadInputFile(LPCSTR pszLeftArg, LPCSTR pszRightArg, BOOL fSingle, BOOL fVersionControl);
BOOL PerformReplacement(LPCSTR pszTemplate, LPCSTR pszReplacement, LPSTR pszDest, int cchDest);


LPCSTR LEFTRIGHTPAIR_Left(LEFTRIGHTPAIR ppair);
LPCSTR LEFTRIGHTPAIR_Right(LEFTRIGHTPAIR ppair);
LEFTRIGHTPAIR LEFTRIGHTPAIR_Next(LEFTRIGHTPAIR ppair);


/*
 * extract a previous version of the file to a temp file. Returns in tempfile
 * the name of a temp file containing the requested file version. The 'version'
 * parameter should contain a SLM file & version in the format file.c@vN.
 * eg
 *    file.c@v1		is the first version
 *    file.c@v-1	is the previous version
 *    file.c@v.-1	is yesterdays version
 */
BOOL SLM_GetVersion(SLMOBJECT hslm, LPSTR version, LPSTR tempfile);

/*
 * We don't offer SLM options unless we have seen a correct slm.ini file.
 *
 * Once we have seen a slm.ini, we log this in the profile and will permit
 * slm operations from then on. This function is called by the UI portions
 * of windiff: it returns TRUE if it is ok to offer SLM options.
 * Return 0 - This user hasn't touched SLM,
 *        1 - They have used SLM at some point (show SLM options)
 *        2 - They're one of us, so tell them everything
 *        3 - (1 + 2).
 */
int IsSLMOK(void);

/*
 * In adding support for Source Depot, I have not refactored the original
 * abstraction for the SLM support.  The original abstraction unfortunately
 * makes some assumptions based on knowledge of SLM (dirscan assumes it has a
 * SLM share that it can directly access).  Therefore, instead of altering
 * the underlying design, dirscan explicitly checks to see whether Source
 * Depot is in use, and alters its algorithm appropriately.
 */
int IsSourceDepot(SLMOBJECT hSlm);


/*
 * More than one place needed to parse SLM/SD revision marks, which gave me
 * an excuse to factor out the code and put it in slmmgr.
 *
 * Args:
 *
 *      pszInput   [in] - input string to examine for revision marks
 *      fStrip     [in] - TRUE: copy and strip mark, return allocated memory
 *                        containing the mark;  FALSE: return pointer to mark
 *                        within pszInput.
 *
 * Return NULL - no revision mark found
 *        non-NULL - revision mark found:
 *                    - memory is allocated via gmem_get, and the revision
 *                      tag is copied there.
 *                    - the revision tag is stripped from pszInput.
 *                    - return value is pointer to the allocated memory
 *                      (hint: free it!).
 */
LPSTR SLM_ParseTag(LPSTR pszInput, BOOL fStrip);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\view.h ===
/*
 *
 * VIEW
 *
 * provide a map between lines in the displayed table, and items in the
 * COMPLIST associated with this view.
 *
 * a view owns a complist: given the request for the text of a particular
 * line number in the displayed table, it will map it to either the
 * name/result of a CompItem in the COMPLIST (one of the files compared),
 * or to a line in the compare output (a line in one of the sections in
 * the composite section list for the selected CompItem).
 *
 * the view thus maintains a mode: OUTLINE mode is when one row is one COMPITEM,
 * and EXPAND mode is when one row is a line in the selected COMPITEM. Within
 * either of these modes, global option flags can select whether to show all
 * rows or only certain rows (eg only COMPITEMs that have a state other than
 * STATE_SAME, or only lines that are in the LEFT file).
 *
 * The view is given the handle to the table window. It will send messages
 * to the table window as appropriate when the view changes for any reason.
 *
 * The view owns the COMPLIST. When the view is deleted, the complist will
 * also be deleted.
 *
 * The table class is using this view. So to get rid of a view, call
 * view_close. This will notify the table window. Only call view_delete
 * when you have received the TQ_CLOSE notification indicating that the
 * table class has finished with this view.
 */




/* view.h includes the term COMPLIST: complist.h uses the term VIEW.
 * Alas MIPS doesn't allow duplicate definitions, even harmless ones,
 * so we need to play games.  Whoever declares it first does
 * the real declares and the second one gets no-ops.
 */
#ifndef INC_VIEW_COMPLIST
#define INC_VIEW_COMPLIST
typedef struct compitem FAR* COMPITEM;          /* handle to a compitem */
typedef struct view FAR * VIEW;                 /* handle to a VIEW     */
typedef struct complist FAR * COMPLIST;         /* handle to a complist */
#endif // INC_VIEW_COMPLIST

/* create a new view. It is told the handle for the associated
 * table window. We don't know yet the COMPLIST.
 */
VIEW view_new(HWND hwndTable);

/* tell the view the handle of its COMPLIST. This is an error if this
 * function has already been called for this view. This will init the
 * view to OUTLINE mode. We return FALSE if an error occured.
 */
BOOL view_setcomplist(VIEW view, COMPLIST cl);

/* get the handle of the COMPLIST for this view */
COMPLIST view_getcomplist(VIEW view);

/*
 * close a view. This causes the table window to be told to close
 * this view. When the table window has finished with the view, it will
 * send a TQ_CLOSE notification to its owner window. On receipt of
 * that, call view_delete
 */
void view_close(VIEW view);

/* delete a view and all data associated with it, including the COMPLIST.
 *
 * DON'T call this function except on receiving a TQ_CLOSE notification
 * from the table window. In other cases, call view_close to notify the
 * table window.
 */
void view_delete(VIEW view);

/*
 * each line has three columns - a line number, a tag and the main text.
 * this function returns the text for the given row in the
 * given view. The pointer is to a text string in the
 * view or in the complist somewhere - it should not be changed, and
 * may be overwritten by the next call to gettext.
 */

LPSTR view_gettext(VIEW view, long row, int col);
LPWSTR view_gettextW(VIEW view, long row, int col);

/*
 * return the line number that this line had in the original left or
 * right list. returns 0 if we are not in expanded mode, or if the
 * line was not in the original list. returns -(linenr) if the
 * line is MOVED and this is the other copy
 */
int view_getlinenr_left(VIEW view, long row);
int view_getlinenr_right(VIEW view, long row);


/* find the max width of the given column, in characters */
int view_getwidth(VIEW view, int col);


/* return the number of visible rows in this view */
long view_getrowcount(VIEW view);


/* get the state for this row. This is one of the STATE_* properties
 * defined in state.h, and is mapped to colour settings by the caller.
 */
int view_getstate(VIEW view, long row);


/* switch to expanded view of the given row. FALSE if row not
 * expandable or no such row. Switch the mapping so that each row
 * maps to one line in the composite section list for the given
 * compitem (the one selected by row in outline mode), and notify
 * the table window to redraw.
 * It is legal (and a no-op) to have rows==-1
 */
BOOL view_expand(VIEW view, long row);

/* return to outline mode. switch the mapping back so that each
 * row maps to one CompItem, and notify the table window so that it
 * is redrawn
 */
void view_outline(VIEW);

/* return a handle to the current CompItem. if the view is currently in
 * expand mode, this will return the handle for the CompItem that is
 * being expanded (regardless of the row parameter). If the mapping is
 * currently outline mode, the handle for the CompItem representing row
 * will be returned, or NULL if that is not valid
 */
COMPITEM view_getitem(VIEW view, long row);

/*
 * return TRUE if the current mapping is expanded mode
 */
BOOL view_isexpanded(VIEW view); 	

/* return a text string describing the current compitem. Only valid
 * if in expand mode. This will be normally the file name
 */
LPSTR view_getcurrenttag(VIEW view);


/* a CompItem has been added to the list. This will cause the
 * table to be notified of the change.
 *
 * This causes a Poll() to take place, and returns TRUE if an abort
 * has been requested. The caller should arrange to abort the current
 * scan operation.
 */
BOOL view_newitem(VIEW view);


/*
 * change view mode. the options affecting view selection have changed -
 * change the mapping if necessary, and redraw if it affects this mode
 *
 * retain current line if possible
 */
void view_changeviewoptions(VIEW view);

/* the compare options have changed - discard all compares and redo
 * as necessary.
 * retain current line if possible
 */
void view_changediffoptions(VIEW view);


/* find the next highlighted line in the given direction: forward if
 * bForward. returns the row number.
 */
long view_findchange(VIEW view, long startrow, BOOL bForward);

/* return the STATE_ value for the indicated row in the view.
 */
int view_getrowstate(VIEW view, long row);

/*
 * return the marked state for a given row. Only compitems can be marked,
 * so it will be FALSE unless it is a compitem on which view_setmark or
 * compitem_setmark have previously set the mark state to TRUE.
 */
BOOL view_getmarkstate(VIEW view, long row);

/*
 * set the mark state for a given row. This is only possible for compitem rows.
 * The mark set can be retrieved by view_getmarkstate or compitem_getmark.
 *
 * We return FALSE if the state could not be set - eg because the
 * row to set is not a compitem row.
 */
BOOL view_setmarkstate(VIEW view, long row, BOOL bMark);

/*
 * the WIN32 multithread version can try view_expand and view_outline
 * (or view_newitem) at the same time. This is not correctly protected by
 * the critical section, since there are major restrictions about holding
 * critsecs when sending messages from the worker thread.
 *
 * To avoid contention, we call this function to notify that we are
 * starting expanding. view_newitem and ToOutline will return without
 * doing anything if this function has been called and view_expand has not
 * completed.
 */
void view_expandstart(VIEW);

// are we in the middle of expansion ?
BOOL view_expanding(VIEW);

HWND view_gethwnd(VIEW view);

void view_gototableline(VIEW view, LONG iLine);

BOOL view_findstring(VIEW view, LONG iCol, LPCSTR pszFind, BOOL fSearchDown, BOOL fMatchCase, BOOL fWholeWord);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\wdiffrc.h ===
#define IDC_STATIC      -1

#define IDM_FILE        111
#define IDM_DIR         112
#define IDM_PRINT       113
#define IDM_REMOTE      114
#define IDM_EXIT        115
#define IDM_TIME        116
#define IDM_TRACE       117
#define IDM_TRACEOFF    118
#define IDM_OPEN        121
#define IDM_SAVELIST    122
#define IDM_EDITLEFT    123
#define IDM_EDITRIGHT   124
#define IDM_EDITCOMP    125
#define IDM_SETEDIT     126
#define IDM_COPYFILES   127
#define IDM_EDITCOPY    128

#define IDM_CONTENTS    130
#define IDM_ABOUT       131
#define IDD_ICON        132
#define IDD_VERSION     133
#define IDD_LABEL       136
#define IDD_DIR1        137
#define IDD_DIR2        138
#define IDD_LAB1        139
#define IDD_LAB2        140
#define IDD_LAB3        141
#define IDD_SLM         142
#define IDD_RECURSIVE   143
#define IDD_LOCALSLM    144
#define IDD_SERVER      145
#define IDD_PASSWORD    146
#define IDD_SUMS        147
#define IDD_FASTSCAN    148
#define IDD_AUTOCOPY    149
#define IDD_BOTHREMOTE  150
#define IDD_LOGFILE     151
#define IDD_LOGTEXT     152
#define IDD_FIND        153
#define IDC_DRD_FINDWHAT  154
#define IDC_OPT_UP        155
#define IDC_OPT_DOWN      156
#define IDC_CHK_MATCHCASE 157
#define IDC_CHK_WHOLEWORD 158

#define IDD_GOTOLINE    159
#define IDC_EDT_GOTOLINE 160

#define IDM_CLOSE       161

#define IDD_USAGE       170
#define IDC_USAGE_TEXT  171

#define IDM_OUTLINE     180
#define IDM_EXPAND      181
#define IDM_FCHANGE     182
#define IDM_LNRS        185
#define IDM_RNRS        186
#define IDM_NONRS       187
#define IDM_LONLY       188
#define IDM_RONLY       189
#define IDM_BOTHFILES   190
#define IDM_UPDATE      194
#define IDM_FPCHANGE    195
#define IDM_IGNBLANKS   196
#define IDM_PICTURE     197
#define IDM_LAZY        198
#define IDM_ALG2        199
#define IDM_OUTLINE_INCSAME     201
#define IDM_OUTLINE_INCLEFT     202
#define IDM_OUTLINE_INCRIGHT    203
#define IDM_OUTLINE_INCDIFFER   204
#define IDM_EXPAND_INCSAME     205
#define IDM_EXPAND_INCLEFT     206
#define IDM_EXPAND_INCRIGHT    207
#define IDM_EXPAND_INCMOVEDLEFT   208
#define IDM_EXPAND_INCMOVEDRIGHT  209
#define IDM_EXPAND_INCSIMILARLEFT   210
#define IDM_EXPAND_INCSIMILARRIGHT  211
#define IDM_MONOCOLS    212
#define IDM_RESCAN      213
#define IDM_SHOWWHITESPACE  214
#define IDM_FIND        215
#define IDM_FINDNEXT    216
#define IDM_FINDPREV    217
#define IDM_GOTOLINE    218
#define IDM_SETTABWIDTH	219
#define IDM_SETFONT		220
#define IDM_FCHANGE_LAURIE		221
#define IDM_FPCHANGE_LAURIE		222
#define IDM_TABWIDTH4   223
#define IDM_TABWIDTH8   224

#define IDM_MARK        300
#define IDM_MARKPATTERN 301
#define IDM_HIDEMARK    302
#define IDM_TOGGLEMARK  303
#define IDD_IGNOREMARK  304
#define IDD_ATTRIBUTES  305
#define IDM_TOMOVED     310

#define IDC_RCDISP1     501
#define IDC_BAR         510
#define IDC_STATUS      550
#define IDM_ABORT       551
#define IDL_STATLAB     552
#define IDL_NAMES       553

#define IDD_FILE        601
#define IDD_IDENTICAL   602
#define IDD_DIFFER      603
#define IDD_LEFT        604
#define IDD_RIGHT       605

#define IDD_FROMGROUP   610
#define IDD_FROMLEFT    611
#define IDD_FROMRIGHT   612

#define IDS_LINE_NOT_VISIBLE        650
#define IDS_ONLY_IN                 651
#define IDS_DIFFERENT               652
#define IDS_IDENTICAL               653
#define IDS_SAME_SIZE               654
#define IDS_CANT_OPEN_TMP_FILE      655
#define IDS_BAD_ARGUMENT            656
#define IDS_SELECT_FIRST_FILE       657
#define IDS_SELECT_SECOND_FILE      658
#define IDS_COULDNT_FIND            659
#define IDS_CANT_OPEN               660
#define IDS_IDENTICAL_COMMA         661
#define IDS_LEFT_ONLY_COMMA         662
#define IDS_RIGHT_ONLY_COMMA        663
#define IDS_DIFFERING               664
#define IDS_FILES_LISTED            665
#define IDS_ENTER_DIR_NAME          666
#define IDS_FAILED_TO_COPY          667
#define IDS_COPYING                 668
#define IDS_COPY_ABORTED            669
#define IDS_COPY_FAILED             670
#define IDS_COPY_COMPLETE           671
#define IDS_EXIT                    672
#define IDS_COULDNT_FIND_ANYTHING   673
#define IDS_WINDIFF_USAGE           689
#define IDS_ERROR_L_OPTION          690
#define IDS_BAD_SLM_INI             691
#define IDS_PAGE                    692
#define IDS_SENT_TO_PRINTER         693
#define IDS_UNABLE_TO_PRINT         694
#define IDS_WINDIFF_ERROR           695
#define IDS_NO_MORE_CHANGES         696
#define IDS_NO_PREV_CHANGES         697
#define IDS_OUTLINE                 698
#define IDS_EXPAND                  699
#define IDS_FILE_DOESNT_EXIST       700
#define IDS_FAILED_TO_LAUNCH_EDT    701
#define IDS_COMPARING               702
#define IDS_SCANNING                703
#define IDS_ABORT                   704
#define IDS_PLEASE_WAIT             705
#define IDS_ABORT_PENDING           706
#define IDS_SECONDS                 707
#define IDS_TRACING_ENABLED         708
#define IDS_TRACING_DISABLED        709
#define IDS_CREATE_DIFF_LIST        710
#define IDS_TOOL_DESCRIPTION        711
#define IDS_EDITOR_COMMAND          712
#define IDS_HEADER_LINE_STR         713
#define IDS_IDENTICAL_TIMES         714
#define IDS_DIFF_BLANK_ONLY         715
#define IDS_ENTER_SUBSTRING1        716
#define IDS_ENTER_SUBSTRING2        717
#define IDS_MARK_FILES              718
#define IDS_ENTER_PASSWORD          719
#define IDS_COPYING_NFILES          720
#define IDS_BOTH_UNREADABLE         721
#define IDS_LEFT_UNREADABLE         722
#define IDS_RIGHT_UNREADABLE        723
#define IDS_UNREADABLE              724
#define IDS_IS_MORE_RECENT          725
#define IDS_IS_READONLY             726
#define IDS_COPY_FILES              727
#define IDS_NOTHING_RESCANNED       728
#define IDS_NOTHING_TO_EDIT         729
#define IDS_ERR_OPENING_FILE        730
#define IDS_SAVE_COMPFILE           731

#define IDS_USAGE_STR00             732
#define IDS_USAGE_STR01             733
#define IDS_USAGE_STR02             734
#define IDS_USAGE_STR03             735
#define IDS_USAGE_STR04             736
#define IDS_USAGE_STR05             737
#define IDS_USAGE_STR06             738
#define IDS_USAGE_STR07             739
#define IDS_USAGE_STR08             740
#define IDS_USAGE_STR08B            741
#define IDS_USAGE_STR09             742
#define IDS_USAGE_STR10             743
#define IDS_USAGE_STR11             744
#define IDS_USAGE_STR12             745
#define IDS_USAGE_STR12B            746
#define IDS_USAGE_STR12C            747
#define IDS_USAGE_STR13             748
#define IDS_USAGE_STR14             749
#define IDS_USAGE_STR14B            750
#define IDS_USAGE_STR15             751
#define IDS_USAGE_STR16             752
#define IDS_USAGE_STR17             753
#define IDS_USAGE_STR18             754
#define IDS_USAGE_STR19             755
#define IDS_USAGE_STR20             756
#define IDS_USAGE_STR21             757
#define IDS_USAGE_STR22             758
#define IDS_USAGE_STR23             759
#define IDS_USAGE_STR24             760
#define IDS_USAGE_STR25             761
#define IDS_USAGE_STR26             762

#define IDS_GOTOLINE_INVALIDSTRING  800
#define IDS_GOTOLINE_NOLINES        801
#define IDS_FIND_NOTFOUND           802
#define IDS_TABWIDTH				803
#define IDS_BAD_TABWIDTH			804
#define IDS_BAD_SD_INI				805
#define IDS_NOCOMPUNICODE			806
#define IDS_ERROR_LO_UNC            807
#define IDS_ERROR_OVSD_OPTION		808
#define IDS_ERROR_LD_OPTION			809
// --- UNUSED - RECYCLE ME ---          810
#define IDS_ERROR_IARGS				811
#define IDS_ERROR_IARGS_OPENFILE	812
#define IDS_ERROR_CANTLOADRICHEDIT	813
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\view.c ===
/*
 * view.c
 *
 *       map rows in window to items in COMPLIST
 *
 *
 * A view owns a COMPLIST, and talks to a table window. The table window
 * shows 3 columns: line nr, tag and text. We also need to supply a state
 * for each row (used to select colour scheme).
 *
 * The COMPLIST can give us a list of its COMPITEMs. Each of these can give
 * us a tag (eg the filenames compared) and the text (usually the compare
 * result), and the state. We make the line number from the
 * COMPITEM's place in the list.
 *
 * If we are asked to switch to 'expand' mode, we ask the selected COMPITEM
 * for its composite section list. We can then get the state (and thus
 * the tag) from each SECTION, and the line nr and text from the LINEs within
 * each section.
 *
 * When moving between expand and outline, and when refreshing the view
 * for some option change, we have to be careful to keep the current row
 * and the selected row in the table what the user would expect (!)
 *
 *
 * WIN32: Functions in this module can be called from the UI thread (to refresh
 * the display) and simultaneously from a worker thread to update the
 * view mapping (view_setcomplist, view_newitem). We use a critical section
 * to manage the synchronisation. We need to protect all access/modification
 * to the view structure elements (particularly bExpand, rows, pLines and
 * pItems), BUT we must not hold the critical section over any calls
 * to SendMessage.
 *
 * we use the global options in windiff.h, and we allocate memory from the
 * heap hHeap which has been initialised elsewhere. Points in time-intensive
 * loops call Poll() defined elsewhere.
 *
 * Geraint Davies, July 92
 */

#include <precomp.h>
#include <table.h>

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "list.h"
#include "line.h"
#include "scandir.h"
#include "file.h"
#include "section.h"
#include "compitem.h"
#include "complist.h"
#include "findgoto.h"

#include "view.h"

/*
 * data structures
 */
#ifdef WIN32
#define huge
#endif

/* in expand mode, we keep an array of one of these per screen line. */
typedef struct viewline {
        LINE line;              /* handle to LINE for this row */
        SECTION section;        /* handle to section containing this line */
        int nr_left;            /* line nr in left file */
        int nr_right;           /* line nr in right file */
} VIEWLINE, FAR * PVIEWLINE;


/*
 * The users VIEW handle is in fact a pointer to this structure
 */
struct view {

        HWND     hwnd;          /* the table window to send notifies to */

        COMPLIST cl;            /* the complist that we own */

        BOOL     bExpand;       /* true if we are in expand mode */
        BOOL     bExpanding;    /* set by view_expandstart, reset by view_expand
                                   interrogated in windiff.c, causes keystrokes
                                   to be ignored.  Protects against mappings being
                                   messed up by another thread.
                                   (I have doubts about this - Laurie).
                                */
        BOOL     bExpandGuard;  /* Protects against two threads both trying to
                                   expand the same item.
                                */

        COMPITEM ciSelect;      /* selected compitem (in expand mode) */

        int      rows;          /* number of rows in this view */

        char     nrtext[12];    /* we use this in view_gettext for the line
                                 * number column. overwritten on each call
                                 */
        int      maxtag, maxrest;/* column widths in characters for cols 1, 2 */

        /* if we are in outline mode, we map the row number to one entry
         * in this array of COMPITEM handles. this pointer will
         * be NULL in expand mode
         */
        COMPITEM FAR * pItems;

        /* in expand mode we use this array of line and section handles */
        PVIEWLINE pLines;
};

#ifdef WIN32

CRITICAL_SECTION CSView;       /* also known to Windiff.c WM_EXIT processing */
static BOOL bDoneInit = FALSE;

#define ViewEnter()     EnterCriticalSection(&CSView);
#define ViewLeave()     LeaveCriticalSection(&CSView);

#else //WIN32

#define ViewEnter()
#define ViewLeave()

#endif //WIN32


extern long selection;
extern long selection_nrows;

/*------- forward declaration of internal functions ----------------*/

void view_outline_opt(VIEW view, BOOL bRedraw, COMPITEM ci, int* prow);
void view_freemappings(VIEW view);
int view_findrow(VIEW view, int number, BOOL bRight);
BOOL view_expand_item(VIEW view, COMPITEM ci);


/* -----  externally-called functions---------------------------*/
/* view_new
 *
 * create a new view. at this point, we are told the table window handle,
 * and nothing else.
 *
 */
VIEW
view_new(HWND hwndTable)
{
        VIEW view;

#ifdef WIN32
        if (!bDoneInit) {
                InitializeCriticalSection(&CSView);
                bDoneInit = TRUE;
        }
#endif

        /* alloc the view from the heap */
        view = (VIEW) gmem_get(hHeap, sizeof(struct view));

        /* set the default fields */
        view->hwnd = hwndTable;
        view->cl = NULL;
        view->bExpand = FALSE;
        view->bExpandGuard = FALSE;
        view->ciSelect = NULL;
        view->rows = 0;
        view->pItems = NULL;
        view->pLines = NULL;

        return(view);
}


/*
 * view_setcomplist.
 *
 * We have to separate view_new and view_setcomplist because we need
 * to give the view handle to the complist and the complist handle to the
 * view. So do a view_new to create a null view; then complist_new() to
 * which you pass a view handle. The complist will then register itself
 * with the view by calling this function. During the build of the complist,
 * it will also update us by calling view_additem, so that we can refresh
 * the display.
 *
 * Here we should initialise an outline view of the complist.
 *
 * We also talk to the status bar using SetNames to set the names of
 * the two items.
 */
BOOL
view_setcomplist(VIEW view, COMPLIST cl)
{
        LPSTR both;

        if (view == NULL) {
                return(FALSE);
        }

        /* there can be only one call to this per VIEW */
        if (view->cl != NULL) {
                return (FALSE);
        }

        ViewEnter();

        view->cl = cl;

        /* set names on status bar to root names of left and right trees */
        both = complist_getdescription(cl);
        ViewLeave();                      // LKGHACK
        SetNames(both);
        ViewEnter();                      // LKGHACK
        complist_freedescription(cl, both);

        ViewLeave();

        view_outline(view);
        return TRUE;
}


/*
 * return a handle to the complist owned by this view
 */
COMPLIST
view_getcomplist(VIEW view)
{
        if (view == NULL) {
                return(NULL);
        }

        return(view->cl);
}


/*
 * close a view. notify the table window that this view should be
 * closed. When the table window has finished with it, it will send
 * a TQ_CLOSE notify that should result in view_delete being called
 * and the memory being freed.
 */
void
view_close(VIEW view)
{
        if (view == NULL) {
                return;
        }

        SendMessage(view->hwnd, TM_NEWID, 0, 0);
}


/*
 * delete a view and all associated data.
 *
 * This function should only be called in response to the table window
 * sending a TQ_CLOSE message. To close the view, call view_close and
 * wait for the TQ_CLOSE before calling this.
 *
 * We delete the associated COMPLIST and all its associated structures.
 */
void
view_delete(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* we have two arrays that are used for the mapping - an array
         * of compitem handles in outline mode, and an array of
         * VIEWLINE structures in expand mode
         */

        view_freemappings(view);

        complist_delete(view->cl);

        gmem_free(hHeap, (LPSTR) view, sizeof(struct view));
}


/*
 * view_outline
 *
 * build an outline mode mapping where one row represents one COMPITEM in
 * the list. check the global option flag outline_include to see which items
 * we should include.
 *
 * If we were in expand mode, then set as the selection the row in outline mode
 * that we were expanding. Also remember to free up the expand mode mapping
 * array
 *
 * once we have built the new mapping, notify the table window to
 * redraw itself.
 */
void
view_outline(VIEW view)
{
        if (view == NULL) {
                return;
        }

        /* all work done by view_outline_opt - this function
         * gives us the option of not updating the display
         */
        view_outline_opt(view, TRUE, NULL, NULL);
}



/*
 * switch to expand mode, expanding the given row into a view
 * of the differences in that file.
 *
 * map the given row nr into a compitem handle, and then
 * call the internal function with that.
 *
 * It is legal (and a no-op) if this function is called with
 * row==-1.
 */
BOOL
view_expand(VIEW view, long row)
{
        COMPITEM ci;
        BOOL bRet;

   if (row<0) return FALSE;

        ViewEnter();

        if ((view == NULL) || (view->bExpand)) {
                /* no view, or already expanded */
                ViewLeave();
                return(FALSE);
        }

        if (row >= view->rows) {
                /* no such row */
                ViewLeave();
                return FALSE;
        }

        /* remember the compitem we are expanding */
        ci = view->pItems[row];

        bRet = view_expand_item(view, ci);
        // view_expand_item does the...
        // ViewLeave();
        return(bRet);
}


/*
 * return the text associated with a given column of a given row.
 * Return a pointer that does not need to be freed after use - ie
 * a pointer into our data somewhere, not a copy
 */
LPSTR
view_gettext(VIEW view, long row, int col)
{
        int line;
        int state;
        LPSTR pstr;

        pstr = NULL;   /* kill spurious diagnostic */
        if (view == NULL) {
                return (NULL);
        }

        ViewEnter();

        if (row >= view->rows) {
                ViewLeave();
                return(NULL);
        }

        if (view->bExpand) {
                /* we are in expand mode */

                state = section_getstate(view->pLines[row].section);

                switch(col) {
                case 0:
                        /* row nr */

                        /* line numbers can be from either original file
                         * this is a menu-selectable option
                         */
                        line = 0;
                        switch(line_numbers) {
                        case IDM_NONRS:
                                pstr = NULL;
                                break;

                        case IDM_LNRS:
                                line = view->pLines[row].nr_left;
                                if (state == STATE_MOVEDRIGHT
                                    || state == STATE_SIMILARRIGHT) {
                                        line = -line;
                                }
                                break;

                        case IDM_RNRS:
                                line = view->pLines[row].nr_right;
                                if (state == STATE_MOVEDLEFT
                                    || state == STATE_SIMILARLEFT) {
                                        line = -line;
                                }
                                break;
                        }
                        if (line == 0) {
                                ViewLeave();
                                return(NULL);
                        }

                        if (line < 0) {
                                /* lines that are moved appear twice.
                                 * show the correct-sequence line nr
                                 * for the out-of-seq. copy in brackets.
                                 */
                                wsprintf(view->nrtext, "(%d)", abs(line));
                        } else  {
                                wsprintf(view->nrtext, "%d", line);
                        }
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag text - represents the state of the line */


                        switch(state) {
                        case STATE_SAME:
                                pstr = "    ";
                                break;

                        case STATE_LEFTONLY:
                        case STATE_SIMILARLEFT:
                                pstr = " <! ";
                                break;

                        case STATE_RIGHTONLY:
                        case STATE_SIMILARRIGHT:
                                pstr = " !> ";
                                break;

                        case STATE_MOVEDLEFT:
                                pstr = " <- ";
                                break;

                        case STATE_MOVEDRIGHT:
                                pstr = " -> ";
                                break;
                        }
                        break;

                case 2:
                        /* main text - line */
                        pstr = line_gettext(view->pLines[row].line);
                        break;
                }
        } else {
                /* outline mode */
                switch(col) {
                case 0:
                        /* row number - just the line number */
                        wsprintf(view->nrtext, "%d", row+1);
                        pstr = view->nrtext;
                        break;

                case 1:
                        /* tag */
                        pstr = compitem_gettext_tag(view->pItems[row]);
                        break;

                case 2:
                        /* result text */
                        pstr = compitem_gettext_result(view->pItems[row]);
                        break;
                }
        }
        ViewLeave();
        return(pstr);
}


/*
 * return the text associated with a given column of a given row.
 * Return a pointer that does not need to be freed after use - ie
 * a pointer into our data somewhere, not a copy
 */
LPWSTR
view_gettextW(VIEW view, long row, int col)
{
        int state;
        LPWSTR pwz;

        pwz = NULL;   /* kill spurious diagnostic */
        if (view == NULL) {
                return (NULL);
        }

        ViewEnter();

        if (row >= view->rows) {
                ViewLeave();
                return(NULL);
        }

        if (view->bExpand) {
                /* we are in expand mode */

                state = section_getstate(view->pLines[row].section);

                switch(col) {
                case 2:
                        /* main text - line */
                        pwz = line_gettextW(view->pLines[row].line);
                        break;
                }
        }
        ViewLeave();
        return(pwz);
}

/*
 * return the line number that this row had in the original left
 * file. 0 if not in expand mode. 0 if this row was not in the left file.
 * -(linenr) if this row is a MOVED line, and this is the right file
 * copy
 */
int
view_getlinenr_left(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row >= view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();
        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_left;
        if (state == STATE_MOVEDRIGHT || state == STATE_SIMILARRIGHT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}

/*
 * return the line number that this row had in the original right
 * file. 0 if not in expand mode. 0 if this row was not in the right file.
 * -(linenr) if this row is a MOVED line, and this is the left file
 * copy
 */
int
view_getlinenr_right(VIEW view, long row)
{
        int state, line;

        if ((view == NULL) || (row > view->rows) || !view->bExpand) {
                return 0;
        }

        ViewEnter();

        state = section_getstate(view->pLines[row].section);
        line = view->pLines[row].nr_right;
        if (state == STATE_MOVEDLEFT || state == STATE_SIMILARLEFT) {
                line = -line;
        }
        ViewLeave();

        return(line);
}



/* find the maximum width in characters for the given column */
int
view_getwidth(VIEW view, int col)
{
        if (view == NULL) {
                return(0);
        }

        switch(col) {
        case 0:
                /* line nr column - always 5 characters wide */
                return(5);

        case 1:
                /* this is a proportional font field, so add on a margin
                 * for error
                 */
                return(view->maxtag + (view->maxtag / 20));
        case 2:
                /* this now includes the tab expansion allowance */
                return(view->maxrest);
        default:
                return(0);
        }
}

/* how many rows are there in this view ? */
long
view_getrowcount(VIEW view)
{
        if (view == NULL) {
                return(0);
        }

        return(view->rows);
}

/* return the state for the current row. This is used
 * to select the text colour for the row
 *
 * states for sections are obtained from section_getstate (and apply, and
 * to all lines in that section. States for compitems are obtained
 * from compitem_getstate.
 */
int
view_getstate(VIEW view, long row)
{
        int state;

        if (view == NULL) {
                return(0);
        }

        ViewEnter();
        if (row >= view->rows) {
                state = 0;
        } else if (view->bExpand) {
                /* its a line state that's needed */
                state = section_getstate(view->pLines[row].section);
        } else {

                /* its a compitem state */
                state = compitem_getstate(view->pItems[row]);
        }
        ViewLeave();
        return(state);
}

/*
 * return the marked state for a given row. Only compitems can be marked,
 * so it will be FALSE unless it is a compitem on which view_setmark or
 * compitem_setmark have previously set the mark state to TRUE.
 */
BOOL
view_getmarkstate(VIEW view, long row)
{
    BOOL bMark = FALSE;

    if (view != NULL) {
   ViewEnter();
   if ( (row < view->rows) && (!view->bExpand)) {
       bMark = compitem_getmark(view->pItems[row]);
   }
   ViewLeave();
    }
    return(bMark);
}

/*
 * set the mark state for a given row. This is only possible for compitem rows.
 * The mark set can be retrieved by view_getmarkstate or compitem_getmark.
 *
 * We return FALSE if the state could not be set - eg because the
 * row to set is not a compitem row.
 */
BOOL
view_setmarkstate(VIEW view, long row, BOOL bMark)
{
    BOOL bOK = FALSE;

    if (view != NULL) {
   ViewEnter();
   if ( (row < view->rows) && !view->bExpand) {
       compitem_setmark(view->pItems[row], bMark);
       bOK = TRUE;
   }
   ViewLeave();
    }
    return (bOK);
}


/* return a handle to the current compitem. in expand mode,
 * returns the handle to the compitem we are expanding. In outline
 * mode, returns the handle to the compitem for the given row, if valid,
 * or NULL otherwise. row is only used if not in expand mode.
 */
COMPITEM
view_getitem(VIEW view, long row)
{
        COMPITEM ci;

        if (view == NULL) {
                return(NULL);
        }

        ViewEnter();

        if (!view->bExpand) {
                if ((row >= 0) && (row < view->rows)) {
                        ci = view->pItems[row];
                } else {
                        ci = NULL;
                }
        } else {
                ci = view->ciSelect;
        }

        ViewLeave();
        return(ci);
}

/*
 * return TRUE if the current mapping is expanded mode
 */
BOOL
view_isexpanded(VIEW view)
{
        if (view == NULL) {
                return(FALSE);
        }
        return(view->bExpand);
}


/*
 * return a text string describing the view. This is NULL in outline mode,
 * or the tag text for the current compitem in expanded mode
 */
LPSTR
view_getcurrenttag(VIEW view)
{
        LPSTR str;

        if ((view == NULL) || (!view->bExpand)) {
                return(NULL);
        } else {
                ViewEnter();

                str = compitem_gettext_tag(view->ciSelect);

                ViewLeave();
                return(str);

        }
}


/* notify that CompItems have been added to the complist.
 *
 * rebuild the view (if in outline mode), and refresh the table. Use
 * the table message TM_APPEND if possible (if column widths have not
 * change). If we have to do TM_NEWLAYOUT, then ensure we scroll
 * back to the right row afterwards.
 *
 * This causes a Poll() to take place. We return TRUE if an abort is
 * pending - in this case, the caller should abandon the scan loop.
 *
 * WIN32: enter the critical section for this function since this can be
 * called from the worker thread while the UI thread is using the
 * view that we are about to change.
 *
 * EXCEPT THAT WE DON'T DARE.  We cannot ever call SendMessage from the
 * worker thread within CSView.  If there is conflict, it will hang.
 *
 * 7 feb 96: restructure to hold critical during crucial parts without holding
 * over a SendMessage. This should fix the popular bug when a view_newitem on
 * the scanning thread co-incides with a view_outline caused by a menu
 * selection.
 */
BOOL
view_newitem(VIEW view)
{
        int maxtag, maxrest;
        int rownr;
        TableSelection Select;
        BOOL bSelect;
        COMPITEM ciTop = NULL;
        BOOL bRedraw = FALSE;
        BOOL bAppend = FALSE;

        // get the top row before remapping in case we need it
        /* find the row at the top of the window */
        rownr = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);
        // also remember the selection
        bSelect = (BOOL) SendMessage(view->hwnd, TM_GETSELECTION, 0, (LPARAM) &Select);

        // *important*:no critsec over SendMessage
        ViewEnter();

        if ((view != NULL) &&
            !(view->bExpand) &&
            !(view->bExpanding)) {

            /* save some state about the present mapping */
            maxtag = view->maxtag;
            maxrest = view->maxrest;


            // remember the compitem this corresponds to
            if (view->pItems && (rownr >= 0) && (rownr < view->rows)) {
                ciTop = view->pItems[rownr];
            }


            // re-do the outline mapping, but don't tell the table class.
            // ask it to check for the visible row closest to ciTop in case
            // we need to refresh the display
            //
            // since we are holding the critsec, the redraw param
            // *must* be false.
            view_outline_opt(view, FALSE, ciTop, &rownr);

            /* have the column widths changed ? */
            if ((maxtag < view->maxtag) || (maxrest < view->maxrest)) {
                /* yes - need complete redraw */
                bRedraw = TRUE;
            } else {
                bAppend = TRUE;
            }
        }

        ViewLeave();


        if (bRedraw) {

            /* switch to new mapping */
            SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

            // go to the visible row closest to the old top row
            if ((rownr >= 0) && (rownr < view->rows)) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, rownr);
            }

            // select the old selection too (if the table class allowed
            // us to get it)
            if (bSelect) {
                SendMessage(view->hwnd, TM_SELECT,0, (LPARAM) &Select);
            }

        } else if (bAppend) {
            /* we can just append */

            /*
             * in the WIN32 multiple threads case, the mapping may have
             * changed since we released the critsec. however we are still
             * safe. The table will not allow us to reduce the number of
             * rows, so the worst that can happen is that the table will
             * think there are too many rows, and the table message handler
             * will handle this correctly (return null for the text).
             * The only visible effect is therefore that the scrollbar
             * position is wrong.
             */

            SendMessage(view->hwnd, TM_APPEND, view->rows, (LPARAM) view);
        }


        /* Poll to allow multi-tasking on Win3.1, and to keep the UI
         * updated on both 3.1 and NT. Returns true if abort pending.
         */
        return(Poll());
}

/*
 * the view mapping options (eg outline_include, expand_mode) have changed -
 * re-do the mapping and then scroll back to the same position in the window
 * if possible.
 */
void
view_changeviewoptions(VIEW view)
{
        long row;
        int state, number;
        BOOL bRight;

        if (view == NULL) {
                return;
        }

        /* find what row we are currently on. Do this BEFORE we enter CSView */
        row = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        if (!view->bExpand) {


            // view_outline_opt allows us to find the first visible row
            // after a given COMPITEM. Do this to look for the old top-row
            // compitem, so that even if it is no longer visible, we can
            // still go to just after it.

            INT newrow = -1;
            if (row < view->rows) {

                COMPITEM ciTop = view->pItems[row];

                view_outline_opt(view, TRUE, ciTop, &newrow);
            } else {
                view_outline_opt(view, TRUE, NULL, NULL);
            }
            ViewLeave();

            // row now has the visible row that corresponds to
            // ciTop or where it would have been
            if ((newrow >=0) && (newrow < view->rows)) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, newrow);
            }
            return;
        }

        /* expanded mode */


        bRight = FALSE;  /* arbitrarily - avoid strange diagnostic */
        /* save the line number on one side (and remember which side) */
        if (row >= view->rows) {
                number = -1;
        } else {
                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* make the new mapping */
        view_expand_item(view, view->ciSelect);
        // view_expand does the
        // ViewLeave();

        /* things may happen now due to simultaneous scrolling from
         * two threads.  At least we won't deadlock.
         */
        /* find the nearest row in the new view */
        if (number >= 0) {

                ViewEnter();
                row = view_findrow(view, number, bRight);
                ViewLeave();

                /* scroll this row to top of window */
                if (row >= 0) {

                        /* things may happen now due to simultaneous scrolling from
                         * two threads.  At least we won't deadlock.
                         */
                        SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
                        return;
                }
        }
}

/* the compare options have changed - re-do the compare completely
 * and make the new mapping. Retain current position in the file.
 */
void
view_changediffoptions(VIEW view)
{
        int state, number;
        long row;
        BOOL bRight = FALSE;
        LIST li;
        COMPITEM ci;

        number = 0;
        if (view == NULL) {
                return;
        }

        /*
         * get current row before entering critsec.
         */
        row = (long) SendMessage(view->hwnd, TM_TOPROW, FALSE, 0);

        ViewEnter();

        /* find the current line number so we can go back to it
         * (only if we are in expanded mode
         */
        if (view->bExpand) {

                state = section_getstate(view->pLines[row].section);
                if ((state == STATE_MOVEDRIGHT) ||
                    (state == STATE_SIMILARRIGHT) ||
                    (state == STATE_RIGHTONLY)) {
                            bRight = TRUE;
                            number = view->pLines[row].nr_right;
                } else {
                        bRight = FALSE;
                        number = view->pLines[row].nr_left;
                }
        }

        /* to force a recompare using the new options, we must
         * tell each compitem to discard its current compare result.
         * we need to traverse the list of compitems calling this
         * for each compare.
         */
        li = complist_getitems(view->cl);

        for (ci = (COMPITEM) List_First(li); ci != NULL; ci = (COMPITEM) List_Next(ci)) {
                compitem_discardsections(ci);
        }

        if (!view->bExpand) {
                ViewLeave();

                // we are in outline mode. Refreshing the outline view
                // will pick up any tag and tag width changes
                view_outline(view);

                // now scroll to the previous position if still there
                if (row < view->rows) {
                    SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
                }

                return;
        }

        view_expand_item(view, view->ciSelect);
        // view_expand will have done a...
        // ViewLeave();

        /* find the nearest row in the new view */
        ViewEnter();
        row = view_findrow(view, number, bRight);
        ViewLeave();

        /* scroll this row to top of window */
        if (row >= 0) {
                SendMessage(view->hwnd, TM_TOPROW, TRUE, row);
        }
}


/* find the next changed - ie non-same - row in a given direction.
 * for outline mode we find the next STATE_DIFFER. for expand mode, we
 * find the next section
 */
long
view_findchange(VIEW view, long startrow, BOOL bForward)
{
        long i;

        if (view == NULL) {
                return(0);
        }

        if (view->rows <= 0) {
            return (-1);
        }

        ViewEnter();

        if (bForward) {

                if (startrow >= view->rows) {
                        ViewLeave();
                        return(-1);
                }

                if (!view->bExpand) {

                        /* look for next compitem with an expandable state*/
                        for (i = startrow; i < view->rows; i++) {
                                if (compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        /* none found */
                        ViewLeave();
                        return(-1);
                } else {
                        /*
                         * find the next line that matches, then go on to the
                         * next line that does not match
                         *
                         */
                        for (i= startrow; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i < view->rows; i++) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }

                        ViewLeave();

                        return(-1);
                }
        } else {
                /* same search backwards */
                if (startrow < 0) {
                        ViewLeave();
                        return(-1);
                }
                if (view->bExpand) {
                        /* search backwards for first row that is not
                         * changed (has state SAME). then carry on for
                         * the next changed row.
                         */
                        for (i = startrow; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        == STATE_SAME) {
                                                break;
                                }
                        }
                        for ( ; i >= 0; i--) {
                                if (section_getstate(view->pLines[i].section)
                                        != STATE_SAME) {
                                                ViewLeave();
                                                return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                } else {
                        for (i = startrow; i >= 0; i--) {
                                if(compitem_getstate(view->pItems[i]) == STATE_DIFFER) {
                                        ViewLeave();
                                        return(i);
                                }
                        }
                        ViewLeave();
                        return(-1);
                }
        }
}


int view_getrowstate(VIEW view, long row)
{
        int state;

        if (view == NULL) {
                return(0);
        }

        if (view->rows <= 0 || row >= view->rows) {
            return (STATE_SAME);
        }

        ViewEnter();

        state = section_getstate(view->pLines[row].section);

        ViewLeave();

        return state;
}

/*
 * the WIN32 multithread version can try view_expand and view_outline
 * (or view_newitem) at the same time. This is not correctly protected by
 * the critical section, since there are major restrictions about holding
 * critsecs when sending messages from the worker thread.
 *
 * To avoid contention, we call this function to notify that we are
 * starting expanding. view_newitem and ToOutline will return without
 * doing anything if this function has been called and view_expand has not
 * completed.
 */
void
view_expandstart(VIEW view)
{
    view->bExpanding = TRUE;
}

// are we in the middle of expansion ?
BOOL
view_expanding(VIEW view)
{
    return(view->bExpanding);

}



/* ---- internal functions ------------------------------------------ */


/* find the new row number for the line numbered 'number'
 * or the nearest line if possible. if bRight is true, number is
 * a right file number; otherwise it is a left file number.
 *
 * we must be in expand mode
 */
int
view_findrow(
             VIEW view,
             int number,
             BOOL bRight
             )
{
        int i;

        if (!view->bExpand) {
                return(0);
        }

        for (i = 0; i < view->rows; i++) {

                if (bRight) {
                        if (view->pLines[i].nr_right == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_right > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                } else {
                        if (view->pLines[i].nr_left == number) {

                                /* found the exact number */
                                return(i);

                        } else if (view->pLines[i].nr_left > number) {

                                /* passed our line -stop here */
                                return(i);
                        }
                }
        }
        return(-1);
}

/* free memory associated with the expand mode or outline mode mappings
 * called whenever we rebuild the mapping, and on deletion
 */
void
view_freemappings(
                  VIEW view
                  )
{

        if (view->pLines) {
#ifndef WIN32
      GlobalFree(LOWORD(GlobalHandle(SELECTOROF(view->pLines))));
      view->pLines = NULL;
#else
                gmem_free(hHeap, (LPSTR) view->pLines,
                        view->rows * sizeof(VIEWLINE));
                view->pLines = NULL;
#endif
        } else if (view->pItems) {

                /* previous outline mapping array is still there - free it
                 * before we build a new one
                 */

                gmem_free(hHeap, (LPSTR) view->pItems,
                        view->rows * sizeof(COMPLIST));
                view->pItems = NULL;
        }
        view->rows = 0;   // Johny Lee's fix for MIPS
}

/* build a view outline to map one row to a COMPITEM handle by traversing
 * the list of COMPITEMs obtained from our complist.
 * optionally tell the table class to redraw (if bRedraw), and if so,
 * scroll the new table to select the row that represents the
 * file we were expanding, if possible
 *
 * *important*: if you are holding the view critsec when you call this, you
 * must pass bRedraw as FALSE or you could deadlock
 *
 * if a COMPITEM ci is passed in, then return in *prow the row number that
 * corresponds to this item in the new view, or if not visible, the first
 * visible row after it (to retain current scroll position)
 */
void
view_outline_opt(
                 VIEW view,
                 BOOL bRedraw,
                 COMPITEM ciFind,
                 int * prow
                 )
{
        int prev_row = -1;      /* the row nr of the previously-expanded row*/
        int i;                  /* nr of includable items */
        LIST li;
        COMPITEM ci;
        int state;
        TableSelection select;

        /*
         * check that view_setcomplist has already been called. if not,
         * nothing to do
         */
        if (view->cl == NULL) {
                return;
        }

        ViewEnter();

        /* clear the mode flag and free up memory associated with expand mode */
        view->bExpand = FALSE;
        view_freemappings(view);

        /* traverse the list of compitems counting up the number of
         * includable items
         */
        li = complist_getitems(view->cl);

        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                if ((ciFind != NULL) && (prow != NULL)) {
                    if (ci == ciFind) {
                        // now that we have found the requested item,
                        // the next visible row is the one we want,
                        // whether it is ci or a later one
                        *prow = i;
                    }
                }

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {
                    if (!compitem_getmark(ci) || !hide_markedfiles) {
                        i++;
                    }
                }
        }


        /* allocate an array big enough for all of these */
        { /* DO NOT link in any storage with garbage pointers in it */
            COMPITEM FAR * temp;
            temp = (COMPITEM FAR *)gmem_get(hHeap, i * sizeof(COMPITEM));
       // done by gmem get
            //memset(temp, 0, i * sizeof(COMPITEM));
            view->pItems = temp;
        }
        view->rows = i;

        /* keep track of the column widths */
        view->maxtag = 0;
        view->maxrest = 0;

        /* loop through again filling the array, and at the same time looking
         * out for the handle of the previously expanded item
         */
        ci = (COMPITEM) List_First(li);
        for (i = 0; ci != NULL; ci = (COMPITEM) List_Next(ci)) {

                state = compitem_getstate(ci);

                if (((outline_include & INCLUDE_SAME) && (state == STATE_SAME)) ||
                    ((outline_include & INCLUDE_DIFFER) && (state == STATE_DIFFER)) ||
                    ((outline_include & INCLUDE_LEFTONLY) && (state == STATE_FILELEFTONLY)) ||
                    ((outline_include & INCLUDE_RIGHTONLY) && (state == STATE_FILERIGHTONLY))) {

         if (!compitem_getmark(ci) || !hide_markedfiles) {

                            view->pItems[i] = ci;

                            if (ci == view->ciSelect) {
                                    prev_row = i;
                            }

                            /* check the column widths in characters */
                            view->maxtag = max(view->maxtag,
                                               lstrlen(compitem_gettext_tag(ci)));
                            view->maxrest = max(view->maxrest,
                                                lstrlen(compitem_gettext_result(ci)));


                            i++;
         }

                }
        }
        ViewLeave();

        /* inform table of new layout of table - force refresh */
        if (bRedraw) {
                SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

                /* scroll to and highlight the row that represents the file
                 * we were previously expanding
                 */
                if (prev_row != -1) {
                        select.startrow = prev_row;
                        select.startcell = 0;
                        select.nrows = 1;
                        select.ncells = 1;
                        SendMessage(view->hwnd, TM_SELECT, 0, (LPARAM) &select);
                }
        }
}


/* expand a view - given the handle to the compitem to expand.
 *
 * called from view_expand, and also to re-do an expanded view
 * after options change in view_changediffoptions and _changeviewoptions
 *
 * we get the composite section list from the compitem,
 * and pick out all the sections that are includable (according
 * to the global option expand_mode: we include all sections, or
 * just those in one side left or right). Once we know the count of rows,
 * allocate the mapping array: in each element of the array we keep
 * a handle to the section for that row (to get the state and hence the
 * tag text), and a handle to the line within that section (for the line text).
 *
 * We no longer insist on only expanding text files that differ - if the
 * compitem can give us a composite section list, we will map it.
 *
 * We need to be able to give a line number for a line, in either of
 * the original files according to which option is in force. Each section
 * can give us its base line number (number of first line in section) in
 * each of the two files or 0 if not present, and we track these here.
 *
 * MUST BE INSIDE CSView BEFORE CALLING HERE.
 */
BOOL
view_expand_item(
                 VIEW view,
                 COMPITEM ci
                 )
{
        LIST li;
        SECTION sh;
        LINE line1, line2;
        int i, base_left, base_right, state;

        // We could be on a second thread trying to expand while it's
        // already going on.  That ain't clever!
        if (view->bExpandGuard) {
            Trace_Error(NULL, "Expansion in progress.  Please wait.", FALSE);
            ViewLeave();
            return FALSE;
        }

        // Ensure that the world knows that we are expanding
        // before we leave the critical section.
        // This is the only way into getcomposite.
        view->bExpandGuard = TRUE;

	// the compitem_getcomposite could take a long time
	// if the file is large and remote. We need to
	// release the critsec during this operation.

	ViewLeave();
        /* get the composite section list */
        li = compitem_getcomposite(ci);
        if (li == NULL) {
            view->bExpanding = FALSE;
            view->bExpandGuard = FALSE;
            return FALSE;
        }

	ViewEnter();

        /* remember the compitem we are expanding */
        view->ciSelect = ci;

        /* switch modes and free the current mapping
         *
         * NOTE: must do this AFTER the compitem_getcomposite,
         * since that can fail: if it fails it could put up a
         * message box, and that could cause a queued paint message
         * to be processed, which would cause us to use these mappings
         * and gpfault if they had been cleared first.
         */
        view->bExpand = TRUE;
        view->bExpanding = FALSE;
        view->bExpandGuard = FALSE;
        view_freemappings(view);


        /* loop through totalling the lines in sections
         * that we should include
         */
        view->rows = 0;
        for ( sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {

                state = section_getstate(sh);

                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_SIMILARLEFT) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_SIMILARRIGHT) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* include all lines in this section
                   if the section meets the include criteria */
                if ( ((state == STATE_SAME)         && (expand_include & INCLUDE_SAME))
                  || ((state == STATE_LEFTONLY)     && (expand_include & INCLUDE_LEFTONLY))
                  || ((state == STATE_RIGHTONLY)    && (expand_include & INCLUDE_RIGHTONLY))
                  || ((state == STATE_MOVEDLEFT)    && (expand_include & INCLUDE_MOVEDLEFT))
                  || ((state == STATE_MOVEDRIGHT)   && (expand_include & INCLUDE_MOVEDRIGHT))
                  || ((state == STATE_SIMILARLEFT)  && (expand_include & INCLUDE_SIMILARLEFT))
                  || ((state == STATE_SIMILARRIGHT) && (expand_include & INCLUDE_SIMILARRIGHT))) {
                         view->rows += section_getlinecount(sh);
                }
        }
#ifndef WIN32
        if ( ((long) view->rows * sizeof(VIEWLINE)) > 65535L) {
                // careful here- putting up a dialog box can
                // cause the view to be redrawn
                view->rows = 0;

                MessageBox(hwndClient,
                  "Diff info too large for 16-bit version - truncating",
                  "Windiff", MB_ICONSTOP|MB_OK);

                view->rows = (int) (65535L / sizeof(VIEWLINE));
        }
#endif

        /* allocate the memory for the mapping array */
        {    /* DO NOT chain in any storage with garbage pointers in it */
            PVIEWLINE temp;
#ifdef WIN32
            temp = (PVIEWLINE)gmem_get(hHeap, view->rows * sizeof(VIEWLINE));
       // done in gmem_get
            //memset(temp, 0, view->rows * sizeof(VIEWLINE));
#else
       temp = (PVIEWLINE) GlobalLock(GlobalAlloc(GPTR, view->rows * (long)sizeof(VIEWLINE)));
#endif
            view->pLines = temp;
        }

        /* loop through the sections again filling in the mapping array */
        i = 0;
        view->maxtag = 5;
        view->maxrest = 0;
        for (sh = (SECTION) List_First(li); sh != NULL;
            sh = (SECTION) List_Next(sh)) {

                state = section_getstate(sh);

                if (expand_mode == IDM_RONLY) {
                        if ((state == STATE_LEFTONLY) ||
                            (state == STATE_SIMILARLEFT) ||
                            (state == STATE_MOVEDLEFT)) {
                                    continue;
                        }
                } else if (expand_mode == IDM_LONLY) {
                        if ((state == STATE_RIGHTONLY) ||
                            (state == STATE_SIMILARRIGHT) ||
                            (state == STATE_MOVEDRIGHT)) {
                                    continue;
                        }
                }

                /* include all lines in this section
                   if the section meets the include criteria */
                if ( ((state == STATE_SAME)         && (expand_include & INCLUDE_SAME))
                  || ((state == STATE_LEFTONLY)     && (expand_include & INCLUDE_LEFTONLY))
                  || ((state == STATE_RIGHTONLY)    && (expand_include & INCLUDE_RIGHTONLY))
                  || ((state == STATE_MOVEDLEFT)    && (expand_include & INCLUDE_MOVEDLEFT))
                  || ((state == STATE_MOVEDRIGHT)   && (expand_include & INCLUDE_MOVEDRIGHT))
                  || ((state == STATE_SIMILARLEFT)  && (expand_include & INCLUDE_SIMILARLEFT))
                  || ((state == STATE_SIMILARRIGHT) && (expand_include & INCLUDE_SIMILARRIGHT))) {

                        /* find the base line number in each file */
                        base_left = section_getleftbasenr(sh);
                        base_right = section_getrightbasenr(sh);

                        /* add each line in section to the view. section_getfirst()
                         * returns us to a handle that is in a list. We can
                         * call List_Next and will eventually get to the
                         * line returned by section_getlast(). Sections always have
                         * at least one line
                         */
                        line1 = section_getfirstline(sh);
                        line2 = section_getlastline(sh);

                        for (; line1 != NULL; line1 = (LINE) List_Next(line1)) {

                                view->pLines[i].line = line1;
                                view->pLines[i].section = sh;

                                /* calculate the line number for this line by
                                 * incrementing the base nr for this section.
                                 * Note SIMILAR_RIGHT (or LEFT) lines DO have
                                 * left (or right) numbers, but they are dummies.
                                 */

                                view->pLines[i].nr_left = base_left;
                                if (state!=STATE_SIMILARRIGHT && base_left != 0) {
                                        base_left++;
                                }

                                view->pLines[i].nr_right = base_right;
                                if (state!=STATE_SIMILARLEFT && base_right != 0) {
                                        base_right++;
                                }

                                /* increment index into view */
                                i++;

                                /* check the column widths */
                                view->maxrest = max(view->maxrest,
                                                    (line_gettabbedlength(line1, g_tabwidth)));
#ifndef WIN32
                               // check for truncation (if VIEWLINE array too large)
                               if (i >= view->rows) {
                                   break;
                               }
#endif

                                /* end of section ? */
                                if (line1 == line2) {
                                        break;
                                }
                        }
#ifndef WIN32
                        // check for truncation (if VIEWLINE array too large)
                        if (i >= view->rows) {
                            break;
                        }
#endif
                }
        }

        /* We must NOT hold a critical section here as SendMessage may hang */
        ViewLeave();

        /*inform table window of revised mapping */
        SendMessage(view->hwnd, TM_NEWLAYOUT, 0, (LPARAM) view);

        return(TRUE);
}


/*
 *  view_gethwnd
 *
 */
HWND
view_gethwnd(VIEW view)
{
  return (view) ? view->hwnd : NULL;
}


/*
 *  view_gototableline
 *
 */
void
view_gototableline(VIEW view, LONG iLine)
{
  if (view)
    {
    const LONG cLines = view_getrowcount(view);
    if (iLine >= 0 && iLine < cLines)
      {
      TableSelection select;
      memset(&select, 0, sizeof(TableSelection));
      select.startrow = iLine;
      select.nrows    = 1L;
      select.ncells   = 1L;

      SendMessage(view_gethwnd(view), TM_SELECT, 0, (LPARAM) &select);
      }
    }
}


typedef PUCHAR (*STRSUBFUNC)(PUCHAR, PUCHAR, PUCHAR*);
extern PUCHAR My_mbsistr(PUCHAR, PUCHAR, PUCHAR*);
extern PUCHAR My_mbsstr(PUCHAR, PUCHAR, PUCHAR*);

BOOL
view_findstring(VIEW view, LONG iCol, LPCSTR pszFind, BOOL fSearchDown, BOOL fMatchCase, BOOL fWholeWord)
{
  const LONG cRows = view_getrowcount(view);
  BOOL fFound = FALSE;

  if (cRows > 0)
    {
    STRSUBFUNC pfnSub = (fMatchCase) ? My_mbsstr : My_mbsistr;
    const char *pszRow = NULL;
    const char *pszFound = NULL;
    char *pszEnd = NULL;
    LONG iEnd    = 0;
    LONG iRow    = 0;
    LONG nStep   = 0;
    LONG iWrapAt = 0;
    LONG iWrapTo = 0;

    if (fSearchDown)
      {
      nStep = 1;
      iRow = selection + selection_nrows - 1;
      iWrapAt = cRows;
      iWrapTo = 0;
      }
    else
      {
      nStep = -1;
      iRow = selection;
      iWrapAt = -1;
      iWrapTo = cRows - 1;
      }

    iRow += nStep;
    if (iRow < 0 || iRow >= cRows)
      iRow = iWrapTo;

    iEnd = iRow;

    for (;;)
      {
      pszRow = view_gettext(view, iRow, iCol);
      if (pszRow)
        {
        pszEnd = NULL;
        pszFound = (const char*)pfnSub((PUCHAR)pszRow, (PUCHAR)pszFind, (PUCHAR*)&pszEnd);
        if (pszFound)
          {
          if (!fWholeWord)
            {
            fFound = TRUE;
            }
          else
            {
            /* check end of string */
            if (!pszEnd || !*pszEnd || (!IsDBCSLeadByte(*pszEnd) && !isalpha(*pszEnd) && !isdigit(*pszEnd)))
              {
              /* check beginning of string */
              if (pszFound == pszRow)
                {
                fFound = TRUE;
                }
              else
                {
                const char *pchT = CharPrev(pszRow, pszFound);
                if (!pchT || !*pchT || (!IsDBCSLeadByte(*pchT) && !isalpha(*pchT) && !isdigit(*pchT)))
                  {
                  fFound = TRUE;
                  }
                }
              }
            }

          if (fFound)
            {
            view_gototableline(view, iRow);
            break;
            }
          }
        }

      iRow += nStep;
      if (iRow == iWrapAt)
        iRow = iWrapTo;

      if (iRow == iEnd)
        break;
      }
    }

  return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\windiff.c ===
/*
 * Windiff
 *
 * file and directory comparisons.
 *
 *
 * Geraint Davies, July 1991 - July 1992.
 * Laurie Griffiths Nov 91 ("contrast"), July 92 (windiff/contrast merge)
 *
 * Compare two directories (including all files and subdirs). Look for names
 * that are present in both (report all that are not). For files that
 * are present in both, produce a line-by-line comparison of the differences
 * between the two files (if any).
 *
 * Overview of Windiff internals - the whole program.
 *
 * Windiff is built from several modules (a "module" has a .h file
 * which describes its interface and a .c file which implements it)
 * Apart from THIS comment which tries to give an overview of the whole
 * scheme of things, each module is as self-contained as possible.
 * This is enforced by the use of opaque data types.  Modules cannot
 * see each others' internal data structures.  Modules are abstract
 * data types.  The term "Module" (from Modula2) and "Class" (from C++)
 * are used synonymously.
 *
 *    Windiff  - main program - parse arguments, put up main window,
 *               handle input, calling other modules as needed
 *               invoke table class to create the main display and
 *               service callbacks from the table class.
 *               Contains global flags for options (e.g. ignore_blanks)
 *    list     - (in gutils) a generalised LIST of anything data type
 *               has full set of operations for insert, delete, join etc.
 *    line     - a LINE is a numbered line of text.  Information is kept to
 *               allow fast comparisons of LINEs.  A LINE can hold a
 *               link to another LINE.  The links are used to connect
 *               lines in one file to matching lines in the other file.
 *    file     - a FILEDATA represents a file as a file name in the form
 *               of a DIRITEM and a LIST of LINEs
 *    scandir  - a DIRITEM represents information about a file.  (for
 *               instance its name, whether it has a known checksum whether
 *               it has a local copy).
 *               a DIRLIST represents a directory, has information on how to
 *               get to it (remote? pipename? password? UNC name etc) and
 *               (within an imbedded DIRECT structure) a LIST of DIRITEMs
 *               representing the files in the directory and a LIST of
 *               DIRECTs representing its subdirectories.
 *    compitem - a COMPITEM is a pair of files together with information
 *               on how they compare in the form of a breakdown of the
 *               files into a LIST of matching or non-matching sections.
 *               Either file can be absent.  This module contains the
 *               file "contrast" algorithm used for the actual comparison
 *               (Algorithm people see ci_compare then talk to Laurie).
 *    tree       (in gutils) A binary tree.  Important because it is what
 *               gives the file comparison its speed as it makes it
 *               an "N log N" algorithm rather than "N squared"
 *    complist - a COMPLIST is the master data structure.  It has a DIRLIST
 *               of the left hand files, a DIRLIST of the right hand files
 *               and a LIST of COMPITEMs. The left and right hand DIRLISTs
 *               are working data used to produce the COMPLIST.  The LIST
 *               is displayed as the outline table.  Any given COMPITEM can
 *               be displayed as an expanded item.
 *    section  - a SECTION is a section of a file (first line, last line)
 *               and information as to what it matches in the other file.
 *    bar.c    - the picture down the left of the screen
 *               has a WNDPROC.  There is no bar.h, neither is there much
 *               of writeup! ???
 *    view     - Although the COMPLIST is the master state, it doesn't do
 *               all the work itself.  The data is actually displayed by
 *               the table class which is highly generalised.  View
 *               owns a COMPLIST (and therefore calls upon the functions
 *               in complist to fill it and interrogate it) and calls
 *               upon (and is called back by) the functions in table to
 *               actually display it.  Read about table in gutils.h
 *    table.c    (in gutils) a highly generalised system for displaying
 *               data in rows and columns.  The interface is in gutils.h
 *               read it if you hope to understand view!
 *    status.c   (in gutils) the status line at the top. See gutils.h
 *
 * The data structures:
 * Each "module" owns storage which is an encapsulated data type, inaccessable
 * from the outside.  Thus COMPLIST holds a list of COMPITEMs, but they are
 * pointers to structures whose definitions are out of scope, thus they are
 * "just opaque pointers".  To access anything in the COMPITEM you have to
 * call functions in COMPITEM.C.  And so on.  The overall scheme of how they
 * link together is below.  Some things are identified by field name, some by
 * type name, some both, some abbreviations.  Many connecting arrows omitted.
 * Look in the C files for details.
 *
 * COMPLIST
 * > left   -----------> DIRLIST    <--------------------
 * > right  -----------> > rootname                       |
 * > LIST of items--     > bFile                          |
 *                  |    > bRemote                        |
 *                  |    > bSum                           |
 *  ----------------     > dot--------> DIRECT     <------+-------------------------
 * |                     > server       > relname         |                         |
 * |                     > hpipe        > DIRLIST head ---                          |
 * |                     > uncname      > DIRECT parent                             |
 * |                     > password     > bScanned                                  |
 * |                                    > LIST of diritems-----> DIRITEM            |
 * |                                    > LIST OF directs     -> > name             |
 * |                                    > enum pos           |   > int size         |
 * |                                    > DIRECT curdir      |   > int checksum     |
 * |                                                         |   > bool sumvalid    |
 * |                                                         |   > DIRECT direct ---
 * |                                                         |   > localname
 *  --->COMPITEM                                             |   > bLocalIsTemp
 *      > left-------------------> FILEDATA                  |
 *      > right------------------> > DIRITEM-----------------
 *      > LIST of CompSecs---      > LIST of lines--> LINE
 *      > LIST of LeftSecs---|                    --> > flags
 *      > LIST of RightSecs--|                   |    > text
 *                           |                   |    > hash
 *                           |                   |    > link
 *                           |                   |    > linenr
 *                            --> SECTION        |
 *                                > first--------|
 *                                > last---------
 *                                > bDiscard
 *                                > SECTION link
 *                                > SECTION correspond
 *                                > int state
 *                                > int leftbase
 *                                > int rightbase
 *
 *
 *************************************************************************
 *
 * Overview of THIS file's business:
 *
 *   we create a table window (gutils.dll) to show the files and the
 *   results of their comparisons. We create a COMPLIST object representing
 *   a list of files and their differences, and a VIEW object to map between
 *   the rows of the table window and the COMPLIST.
 *
 *   This module is responsible for creating and managing the main window,
 *   placing the child windows (table, status window etc) within it, and
 *   handling all menu items. We maintain global option flags set by
 *   menu commands.
 *
 *   Creating a COMPLIST creates a list of unmatched files, and of matching
 *   files that are compared with each other (these are COMPITEMS).
 *   The VIEW provides a mapping between rows on the screen, and items in
 *   the COMPLIST.
 *
 * Something about threads:  (See also thread DOGMA, below)
 *
 *   The win32 version tries to maintain a responsive user interface by
 *   creating worker threads to do long jobs.  This potentially creates
 *   conflicts between the threads as they will both want to update common
 *   variables (for instance the UI thread may be changing the options to
 *   exclude identical files while the worker thread is adding in the
 *   results of new comparisons).  Critical sections are used to manage
 *   the conflicts (as you'd expect).
 *
 *   The Edit options invoke an editor on a separate thread.  This allows
 *   us to repaint our window and thereby allow the user to refer back to
 *   what he saw before invoking the editor.  When he's finished editing,
 *   we would of course like to refresh things and if this is still on the
 *   separate thread it might clash. We avoid this clash by POSTing ourselves
 *   a (WM_COMMAND, IDM_UPDATE) message.
 */

#include <precomp.h>
#include <shellapi.h>

#include <table.h>
#include <richedit.h>           /* needed for usage dialog */

#include "list.h"               /* needed for compitem.h */
#include "scandir.h"            /* needed for file.h     */
#include "file.h"               /* needed for compitem.h */
#include "compitem.h"           /* needed for view.h     */
#include "complist.h"
#include "view.h"
#include "findgoto.h"

#include "state.h"
#include "windiff.h"
#include "wdiffrc.h"

#include "slmmgr.h"



/*--constants and data types--------------------------------------------*/

int Version = 2;
int SubVersion = 01;

/* When we print the current table, we pass this id as the table id
 * When we are queried for the properties of this table, we know they
 * want the printing properties for the current view. We use this to
 * select different fonts and colours for the printer.
 */
#define TABID_PRINTER   1



/*
 * structure containing args passed to worker thread in initial
 * case (executing command line instructions) (in WIN16 case,
 * the worker thread function is called synchronously with these args).
 */
typedef struct {
#ifdef REMOTE_SERVER
    LPSTR server;
#endif
    LPSTR first;
    LPSTR second;
    LPSTR savelist;
    LPSTR savecomp;
    LPSTR notify;
    UINT listopts;
    UINT compopts;
    VIEW view;
    BOOL fDeep;
    BOOL fExit;
    BOOL fVersionControl;               // TRUE means use SLM or Source Depot
    BOOL fOpenedFiles;                  // TRUE means use output from 'sd opened'
    BOOL fDescribeFiles;                // TRUE means use output from 'sd describe ####'
    BOOL fInputFile;                    // TRUE means read file list from input file
    BOOL fInputFileSingle;              // TRUE means input file has one filename per line
    char slmpath[MAX_PATH];
} THREADARGS, FAR * PTHREADARGS;


/* structure containing all the arguments we'd like to give to do_editfile
   Need a structure because CreateThread only allows for one argument.
*/
typedef struct {
    VIEW view;
    int option;
    long selection;
} EDITARGS, FAR * PEDITARGS;

/*---- string constants --------------------------- */

const CHAR szWinDiff[]                = "WinDiff";
static const char szD[]                      = "%d";
static const char szBlanks[]                 = "Blanks";
static const char szAlgorithm2[]             = "Algorithm2";
static const char szPicture[]                = "Picture";
static const char szMonoColours[]            = "MonoColours";
static const char szHideMark[]               = "HideMark";
static const char szWinDiffViewerClass[]     = "WinDiffViewerClass";
static const char szWinDiffMenu[]            = "WinDiffMenu";
static const char szOutlineMenu[]            = "OutlineFloatMenu";
static const char szExpandMenu[]             = "ExpandFloatMenu";
static const char szWinDiffAccel[]           = "WinDiffAccel";
static const char szBarClass[]               = "BarClass";
static const char szLineNumbers[]            = "LineNumbers";
static const char szFileInclude[]            = "FileInclude";
static const char szLineInclude[]            = "LineInclude";
static const char szOutlineSaved[]           = "OutlineSaved";
static const char szOutlineShowCmd[]         = "OutlineShowCmd";
static const char szOutlineMaxX[]            = "OutlineMaxX";
static const char szOutlineMaxY[]            = "OutlineMaxY";
static const char szOutlineNormLeft[]        = "OutlineNormLeft";
static const char szOutlineNormTop[]         = "OutlineNormTop";
static const char szOutlineNormRight[]       = "OutlineNormRight";
static const char szOutlineNormBottom[]      = "OutlineNormBottom";
static const char szEditor[]                 = "Editor";
static const char szFontFaceName[]           = "FontFaceName";
static const char szFontHeight[]             = "FontHeight";
static const char szFontBold[]               = "FontBold";
static const char szFontCharSet[]            = "FontCharSet";
static const char szExpandedSaved[]          = "ExpandedSaved";
static const char szExpandShowCmd[]          = "ExpandShowCmd";
static const char szExpandMaxX[]             = "ExpandMaxX";
static const char szExpandMaxY[]             = "ExpandMaxY";
static const char szExpandNormLeft[]         = "ExpandNormLeft";
static const char szExpandNormTop[]          = "ExpandNormTop";
static const char szExpandNormRight[]        = "ExpandNormRight";
static const char szExpandNormBottom[]       = "ExpandNormBottom";
static const char szColourPrinting[]         = "ColourPrinting";
static const char szTabWidth[]               = "TabWidth";
static const char szShowWhitespace[]         = "ShowWhitespace";
static const char szrgb_outlinehi[]          = "RGBOutlineHi";
static const char szrgb_leftfore[]           = "RGBLeftFore";
static const char szrgb_leftback[]           = "RGBLeftBack";
static const char szrgb_rightfore[]          = "RGBRightFore";
static const char szrgb_rightback[]          = "RGBRightBack";
static const char szrgb_similarleft[]        = "RGBSimilarLeft";
static const char szrgb_similarright[]       = "RGBSimilarRight";
static const char szrgb_similar[]            = "RGBSimilar";
static const char szrgb_mleftfore[]          = "RGBMLeftFore";
static const char szrgb_mleftback[]          = "RGBMLeftBack";
static const char szrgb_mrightfore[]         = "RGBMRightFore";
static const char szrgb_mrightback[]         = "RGBMRightBack";
static const char szrgb_barleft[]            = "RGBBarLeft";
static const char szrgb_barright[]           = "RGBBarRight";
static const char szrgb_barcurrent[]         = "RGBBarCurrent";
static const char szrgb_defaultfore[]        = "RGBDefaultFore";
static const char szrgb_defaultforews[]      = "RGBDefaultForeWS";
static const char szrgb_defaultback[]        = "RGBDefaultBack";

static const char szrgb_fileleftfore[]       = "RGBFileLeftFore";
static const char szrgb_fileleftback[]       = "RGBFileLeftBack";
static const char szrgb_filerightfore[]      = "RGBFileRightFore";
static const char szrgb_filerightback[]      = "RGBFileRightBack";

/*---- colour scheme------------------------------- */

DWORD rgb_outlinehi = RGB(255, 0, 0);   /* hilighted files in outline mode  */

/* expand view */
DWORD rgb_leftfore;          /* foregrnd for left lines */
DWORD rgb_leftback;          /* backgrnd for left lines */
DWORD rgb_rightfore;         /* foregrnd for right lines*/
DWORD rgb_rightback;         /* backgrnd for right lines*/

/* temp hack */
DWORD rgb_similarleft;       /* forground zebra         */
DWORD rgb_similarright;      /* foreground zebra        */
DWORD rgb_similar;           /* unused                  */

/* moved lines */
DWORD rgb_mleftfore;         /* foregrnd for moved-left */
DWORD rgb_mleftback;         /* backgrnd for moved-left */
DWORD rgb_mrightfore;        /* foregrnd for moved-right*/
DWORD rgb_mrightback;        /* backgrnd for moved-right*/

/* bar window */
DWORD rgb_barleft;           /* bar sections in left only  */
DWORD rgb_barright;          /* bar sections in right only */
DWORD rgb_barcurrent;        /* current pos markers in bar */

DWORD rgb_defaultfore;       /* default foreground */
DWORD rgb_defaultforews;     /* default foreground whitespace */
DWORD rgb_defaultback;       /* default background */

DWORD rgb_fileleftfore;       /* outline mode left only file */
DWORD rgb_fileleftback;       /* outline mode left only file */
DWORD rgb_filerightfore;      /* outline mode right only file */
DWORD rgb_filerightback;      /* outline mode right only file */

BOOL gbPerverseCompare = FALSE; // break lines on punctuation (broken & useless)

/* PickUpProfile */
void PickUpProfile( DWORD * pfoo, LPCSTR szfoo)
{
    *pfoo = GetProfileInt(APPNAME, szfoo, *pfoo);
}


void SetColours(void)
{
    /* outline */

    rgb_outlinehi = (DWORD)RGB(255, 0, 0);   /* hilighted files in outline mode  */
    PickUpProfile(&rgb_outlinehi, szrgb_outlinehi);

    rgb_fileleftfore = (DWORD)RGB(0, 0, 0);   /* left only outline mode  */
    PickUpProfile(&rgb_fileleftfore, szrgb_fileleftfore);
    rgb_fileleftback = (DWORD)RGB(255, 255, 255);
    PickUpProfile(&rgb_fileleftback, szrgb_fileleftback);

    rgb_filerightfore = (DWORD)RGB(0, 0, 0);  /* right only outline mode  */
    PickUpProfile(&rgb_filerightfore, szrgb_filerightfore);
    rgb_filerightback = (DWORD)RGB(255, 255, 255);
    PickUpProfile(&rgb_filerightback, szrgb_filerightback);

    /* expand view */
    rgb_leftfore =   (DWORD)RGB(  0,   0,   0);         /* foregrnd for left lines */
    PickUpProfile(&rgb_leftfore, szrgb_leftfore);
    rgb_leftback  =  (DWORD)RGB(255,   0,   0);         /* backgrnd for left lines */
    PickUpProfile(&rgb_leftback, szrgb_leftback);
    rgb_rightfore =  (DWORD)RGB(  0,   0,   0);         /* foregrnd for right lines*/
    PickUpProfile(&rgb_rightfore, szrgb_rightfore);
    rgb_rightback =  (DWORD)RGB(255, 255,   0);         /* backgrnd for right lines*/
    PickUpProfile(&rgb_rightback, szrgb_rightback);

    rgb_similarleft= (DWORD)RGB(  0, 255, 255);         /* foreground zebra        */
    PickUpProfile(&rgb_similarleft, szrgb_similarleft);
    rgb_similarright=(DWORD)RGB(  0, 127, 127);         /* forground zebra         */
    PickUpProfile(&rgb_similarright, szrgb_similarright);
    rgb_similar   =  (DWORD)RGB(  127, 127, 255);       /* same within comp options*/
    PickUpProfile(&rgb_similar, szrgb_similar);

    /* moved lines */
    rgb_mleftfore =  (DWORD)RGB(  0,   0, 128);         /* foregrnd for moved-left */
    PickUpProfile(&rgb_mleftfore, szrgb_mleftfore);
    rgb_mleftback =  (DWORD)RGB(255,   0,   0);         /* backgrnd for moved-left */
    PickUpProfile(&rgb_mleftback, szrgb_mleftback);
    rgb_mrightfore = (DWORD)RGB(  0,   0, 255);         /* foregrnd for moved-right*/
    PickUpProfile(&rgb_mrightfore, szrgb_mrightfore);
    rgb_mrightback = (DWORD)RGB(255, 255,   0);         /* backgrnd for moved-right*/
    PickUpProfile(&rgb_mrightback, szrgb_mrightback);

    /* bar window */
    rgb_barleft =    (DWORD)RGB(255,   0,   0);         /* bar sections in left only  */
    PickUpProfile(&rgb_barleft, szrgb_barleft);
    rgb_barright =   (DWORD)RGB(255, 255,   0);         /* bar sections in right only */
    PickUpProfile(&rgb_barright, szrgb_barright);
    rgb_barcurrent = (DWORD)RGB(  0,   0, 255);         /* current pos markers in bar */
    PickUpProfile(&rgb_barcurrent, szrgb_barcurrent);

    /* defaults */
    rgb_defaultfore = (DWORD)RGB(   0,   0,   0);       /* default foreground colour */
    PickUpProfile(&rgb_defaultfore, szrgb_defaultfore);
    rgb_defaultforews = (DWORD)RGB(192, 192, 192);      /* default foreground whitespace colour */
    PickUpProfile(&rgb_defaultforews, szrgb_defaultforews);
    rgb_defaultback = (DWORD)RGB(255, 255, 255);        /* default background colour */
    PickUpProfile(&rgb_defaultback, szrgb_defaultback);

} /* SetColours */

void SetMonoColours(void)
{
    rgb_outlinehi = GetSysColor(COLOR_WINDOW);   /* hilighted files in outline mode  */

    /* expand view - all changed or moved lines are white on black */
    rgb_leftfore =   GetSysColor(COLOR_WINDOW);         /* foregrnd for left lines */
    rgb_leftback  =  GetSysColor(COLOR_WINDOWTEXT);     /* backgrnd for left lines */
    rgb_rightfore =  GetSysColor(COLOR_WINDOW);         /* foregrnd for right lines*/
    rgb_rightback =  GetSysColor(COLOR_WINDOWTEXT);     /* backgrnd for right lines*/

    rgb_similarleft= GetSysColor(COLOR_WINDOW);         /* foreground zebra        */
    rgb_similarright=GetSysColor(COLOR_WINDOW);         /* foreground zebra        */
    rgb_similar   =  GetSysColor(COLOR_WINDOWTEXT);     /* same within comp options*/

    /* moved lines - black on white */
    rgb_mleftfore =  GetSysColor(COLOR_WINDOWTEXT);     /* foregrnd for moved-left */
    rgb_mleftback =  GetSysColor(COLOR_WINDOW);	        /* backgrnd for moved-left */
    rgb_mrightfore = GetSysColor(COLOR_WINDOWTEXT);     /* foregrnd for moved-right*/
    rgb_mrightback = GetSysColor(COLOR_WINDOW);         /* backgrnd for moved-right*/

    /* bar WINDOWTEXT */
    rgb_barleft =    GetSysColor(COLOR_WINDOWTEXT);     /* bar sections in left only  */
    rgb_barright =   GetSysColor(COLOR_WINDOWTEXT);     /* bar sections in right only */
    rgb_barcurrent = GetSysColor(COLOR_WINDOWTEXT);     /* current pos markers in bar */


    rgb_defaultfore = GetSysColor(COLOR_WINDOWTEXT);    /* default foreground colour */
    rgb_defaultforews = GetSysColor(COLOR_WINDOWTEXT);  /* default foreground whitespace colour */
    rgb_defaultback = GetSysColor(COLOR_WINDOW);        /* default background colour */

} /* SetMonoColours */

/* -------------------------------------------------- */

/* module static data -------------------------------------------------*/


/* current value of window title */
char AppTitle[256];


HWND hwndClient;        /* main window */
HWND hwndRCD;           /* table window */
HWND hwndStatus;        /* status bar across top */
HWND hwndBar;           /* graphic of sections as vertical bars */

HACCEL haccel;

/* the status bar told us it should be this high. Rest of client area
 * goes to the hwndBar and hwndRCD.
 */
int status_height;

#if 0
    #ifndef HINSTANCE
        #define HINSTANCE HANDLE
    #endif
#endif

HINSTANCE hInst;   /* handle to current app instance */
HMENU hMenu;    /* handle to menu for hwndClient */

int nMinMax = SW_SHOWNORMAL;         /* default state of window normal */

/* the message sent to us as a callback by the table window needs to be
 * registered - table_msgcode is the result of the RegisterMessage call
 */
UINT table_msgcode;

/* true if we are currently doing some scan or comparison.
 * WIN32: must get critical section before checking/changing this (call
 * SetBusy.
 */
BOOL fBusy = FALSE;


long     selection      =       -1;     /* selected row in table*/
long selection_nrows    =       0;      /* number of rows in selection */

/* options for DisplayMode field indicating what is currently shown.
 * we use this to know whether or not to show the graphic bar window.
 */
#define MODE_NULL       0       /* nothing displayed */
#define MODE_OUTLINE    1       /* a list of files displayed */
#define MODE_EXPAND     2       /* view is expanded view of one file */

int DisplayMode = MODE_NULL;    /* indicates whether we are in expand mode */

VIEW current_view = NULL;

BOOL fAutoExpand = TRUE;        /* Should we auto expand ? */

/* These two flags are peeked at by lots of other modules */
BOOL bAbort;            /* set to request abort of current operation */
BOOL bTrace;            /* set if tracing is to be enabled */
BOOL bJapan;            /* set if primary language is Japanese */
BOOL bDBCS;             /* set if primary language is Japanese/Korean/Chinese */

extern char*s;

char editor_cmdline[256] = "notepad %p";  /* editor cmdline */
/* slick version is "s %p -#%l" */

char g_szFontFaceName[LF_FACESIZE];
int g_nFontHeight;
BOOL g_fFontBold;
BYTE g_bFontCharSet;
HFONT g_hFont = 0;

/* app-wide global data --------------------------------------------- */

/* handle returned from gmem_init - we use this for all memory allocations */
HANDLE hHeap;

/* current state of menu options */
int line_numbers = IDM_LNRS;
int expand_mode = IDM_BOTHFILES;
int outline_include = INCLUDE_ALL;
int expand_include = INCLUDE_ALL;
BOOL ignore_blanks = TRUE;
BOOL show_whitespace = FALSE;
BOOL Algorithm2 = TRUE;  /* Try duplicates - used in compitem.c */
BOOL picture_mode = TRUE;
BOOL hide_markedfiles = FALSE;
BOOL mono_colours = FALSE;       /* monochrome display */

// tab width - set from TabWidth entry in registry
int g_tabwidth = TABWIDTH_DEFAULT;

BOOL TrackLeftOnly = TRUE;
BOOL TrackRightOnly = TRUE;
BOOL TrackSame = TRUE;
BOOL TrackDifferent = TRUE;
BOOL TrackReadonly = TRUE;
BOOL TrackSlmFiles = TRUE;

/* function prototypes ---------------------------------------------*/

BOOL InitApplication(HINSTANCE hInstance);
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow);
void CreateTools(void);
void DeleteTools(void);
INT_PTR APIENTRY MainWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);
BOOL SetBusy(void);
void SetNotBusy(void);
void SetSelection(long rownr, long nrows, long dyRowsFromTop);
void SetButtonText(LPSTR cmd);
BOOL ToExpand(HWND hwnd);
void ParseArgs(char * lpCmdLine);
void Trace_Status(LPSTR str);

DWORD WINAPI wd_initial(LPVOID arg);

static HANDLE ghThread = NULL;
/* Some DOGMA about threads:
   When we spin off threads and then while they are still running, try to Exit
   we get race conditions with one thread allocating and the other freeing the
   storage.  gutils\gmem has dogma about NULL pointers, but this is not enough.
   It might be that given a final structure of A->B->C we have A->B with NULL
   pointers in B when the Exit comes in.  The cleanup thread will clear out
   B and A and THEN the worker thread might try to attach C to B which is no
   longer there.  This means that the worker thread must be Stopped.  To allow
   this to happen quickly, we TerminateThread it.  This will leave the initial
   stack around, but presumably that gets cleaned up on app exit anyway.
   There is only at most one worker thread running, and ghThread is its handle.
*/

static DWORD gdwMainThreadId;     /* threadid of main (user interface) thread
                                     initialised in winmain(), thereafter constant.
                                     See windiff_UI()
                                  */

/* if you are about to put up a dialog box or in fact process input in any way
   on any thread other than the main thread - or if you MIGHT be on a thread other
   than the main thread, then you must call this function with TRUE before doing
   it and with FALSE immediately afterwards.  Otherwise you will get one of a
   number of flavours of not-very-responsiveness
*/
void windiff_UI(BOOL bAttach)
{
    DWORD dwThreadId = GetCurrentThreadId();
    if (dwThreadId==gdwMainThreadId) return;

    if (bAttach) GetDesktopWindow();
    AttachThreadInput(dwThreadId, gdwMainThreadId, bAttach);
} /* windiff_UI */

/*-functions----------------------------------------------------------*/

/* main entry point. register window classes, create windows,
 * parse command line arguments and then perform a message loop
 */

extern BOOL WINAPI LibMain(HANDLE hInstance, DWORD dwReason, LPVOID reserved);

int WINAPI
WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow
        )
{
    MSG msg;

    LibMain(GetModuleHandle(NULL), DLL_PROCESS_ATTACH, NULL);

    gdwMainThreadId = GetCurrentThreadId();

    /* create any pens/brushes etc and read in profile defaults */
    CreateTools();

    /* init window class unless other instances running */
    if (!hPrevInstance)
        if (!InitApplication(hInstance))
            return(FALSE);


    /* init this instance - create all the windows */
    if (!InitInstance(hInstance, nCmdShow))
        return(FALSE);

    ParseArgs(lpCmdLine);

    /* message loop */
    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(hwndClient, haccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    // List_Term();
    Trace_Close();       // harmless, even if never opened
    return (msg.wParam ? 1 : 0);
}

/* InitApplication
 *
 * - register window class for the main window and the bar window.
 */
BOOL
InitApplication(
                HINSTANCE hInstance
                )
{
    WNDCLASS    wc;
    BOOL resp;

    LCID lcid = GetThreadLocale();

    // set the boolean value for bJapan variable
    bJapan = (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE);
    bDBCS = ((PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
             (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE));

    /* register the bar window class */
    InitBarClass(hInstance);

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, szWinDiff);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = NULL;
    wc.lpszClassName = (LPSTR) szWinDiffViewerClass;
    wc.lpszMenuName = NULL;

    resp = RegisterClass(&wc);

    return(resp);
}

/*
 * create and show the windows
 */
BOOL
InitInstance(
             HINSTANCE hInstance,
             int nCmdShow
             )
{
    RECT rect;
    HANDLE hstatus;
    int bar_width;
    RECT childrc;
    HIGHCONTRAST hc;

    hInst = hInstance;

    /* initialise a heap. we use this one heap throughout
     * the app. for all memory requirements
     */
    hHeap = gmem_init();
    /* initialise the list package */
    List_Init();


    hMenu = LoadMenu(hInstance, szWinDiffMenu);
    haccel = LoadAccelerators(hInstance, szWinDiffAccel);

    /* create the main window */
    hwndClient = CreateWindow(szWinDiffViewerClass,
                              szWinDiff,
                              WS_OVERLAPPEDWINDOW,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              CW_USEDEFAULT,
                              NULL,
                              hMenu,
                              hInstance,
                              NULL
                             );



    if (!hwndClient) {
        return(FALSE);
    }

    /* create 3 child windows, one status, one table and one bar
     * Initially, the bar window is hidden and covered by the table.
     */

    /* create a status bar window as
     * a child of the main window.
     */

    /* build a status struct for two labels and an abort button */
    hstatus = StatusAlloc(3);
    StatusAddItem(hstatus, 0, SF_STATIC, SF_LEFT|SF_VAR|SF_SZMIN, IDL_STATLAB, 14, NULL);
    StatusAddItem(hstatus, 1, SF_BUTTON, SF_RIGHT|SF_RAISE, IDM_ABORT, 8,
                LoadRcString(IDS_EXIT));
    StatusAddItem(hstatus, 2, SF_STATIC, SF_LOWER|SF_LEFT|SF_VAR,
                  IDL_NAMES, 60, NULL);

    /* ask the status bar how high it should be for the controls
     * we have chosen, and save this value for re-sizing.
     */
    status_height = StatusHeight(hstatus);

    /* create a window of this height */
    GetClientRect(hwndClient, &rect);
    childrc = rect;
    childrc.bottom = status_height;
    hwndStatus = StatusCreate(hInst, hwndClient, IDC_STATUS, &childrc,
                              hstatus);

    /* layout constants are stated as percentages of the window width */
    bar_width = (rect.right - rect.left) * BAR_WIN_WIDTH / 100;

    /* create the table class covering all the remaining part of
     * the main window
     */
    hwndRCD = CreateWindow(TableClassName,
                           NULL,
                           WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL,
                           0,
                           status_height,
                           (int)(rect.right - rect.left),
                           (int)(rect.bottom - status_height),
                           hwndClient,
                           (HANDLE) IDC_RCDISP1,
                           hInst,
                           NULL);

    /* create a bar window as a child of the main window.
     * this window remains hidden until we switch into MODE_EXPAND
     */
    hwndBar = CreateWindow(szBarClass,
                           NULL,
                           WS_CHILD | WS_VISIBLE,
                           0,
                           status_height,
                           bar_width,
                           (int)(rect.bottom - status_height),
                           hwndClient,
                           (HANDLE) IDC_BAR,
                           hInst,
                           NULL);

    /* nMinMax indicates whether we are to be minimised on startup,
     * on command line parameters
     */
    ShowWindow(hwndBar, SW_HIDE);

    if (GetProfileInt(APPNAME, szOutlineSaved, 0)) {
        WINDOWPLACEMENT wp;
        /* restore the previous expanded size and position */
        wp.length = sizeof(wp);
        wp.flags                   = 0;
        wp.showCmd                 = GetProfileInt( APPNAME, szOutlineShowCmd,
                                                    SW_SHOWNORMAL);
        wp.ptMaxPosition.x         = GetProfileInt( APPNAME, szOutlineMaxX,       0);
        wp.ptMaxPosition.y         = GetProfileInt( APPNAME, szOutlineMaxY,       0);
        wp.rcNormalPosition.left   = (int)GetProfileInt( APPNAME, szOutlineNormLeft,  (UINT)(-1));
        wp.rcNormalPosition.top    = (int)GetProfileInt( APPNAME, szOutlineNormTop,   (UINT)(-1));
        wp.rcNormalPosition.right  = (int)GetProfileInt( APPNAME, szOutlineNormRight, (UINT)(-1));
        wp.rcNormalPosition.bottom = (int)GetProfileInt( APPNAME, szOutlineNormBottom,(UINT)(-1));

        if (!SetWindowPlacement(hwndClient,&wp)) {
            ShowWindow(hwndClient, nMinMax);
        }
    } else ShowWindow(hwndClient, nMinMax);


    /* initialise busy flag and status line to show we are idle
     * (ie not comparing or scanning)
     */
    SetNotBusy();

    /* initialise the colour globals */
    hc.cbSize = sizeof(hc);
    SystemParametersInfo(SPI_GETHIGHCONTRAST,0 ,&hc, 0);
    mono_colours = (hc.dwFlags & HCF_HIGHCONTRASTON);
    if (mono_colours) {
        SetMonoColours();
    } else {
        SetColours();
    }
    PostMessage(hwndClient, WM_SYSCOLORCHANGE, 0 , 0);
    UpdateWindow(hwndClient);

    return(TRUE);

} /* InitInstance */



/*
 * complain to command line users about poor syntax,
 * (there's a proper help file too).
 *
 * (yeah, but the help file doesn't cover the MS-internal stuff).
 */

typedef struct
{
    UINT m_ids;
    BOOL m_fInternalOnly;
    BOOL m_fExternalOnly;
    int m_cIndent;
} UsageStringInfo;

static const UsageStringInfo c_rg[] =
{
    { -1,                   0, 0, 0 },
    { IDS_USAGE_STR00,      0, 0, 0 },
    { IDS_USAGE_STR01,      0, 0, 0 },
    { IDS_USAGE_STR02,      0, 0, 1 },
    { IDS_USAGE_STR03,      0, 0, 1 },
    { IDS_USAGE_STR04,      0, 0, 3 },
    { IDS_USAGE_STR05,      0, 0, 1 },
    { IDS_USAGE_STR06,      0, 1, 1 },
    { IDS_USAGE_STR07,      1, 0, 1 },
    { IDS_USAGE_STR08,      1, 0, 1 },
    { IDS_USAGE_STR08B,     0, 0, 1 },
    { IDS_USAGE_STR09,      1, 0, 1 },
    { IDS_USAGE_STR10,      1, 0, 1 },
    { IDS_USAGE_STR11,      1, 0, 1 },
    { IDS_USAGE_STR12,      1, 0, 1 },
    { IDS_USAGE_STR12B,     1, 0, 1 },
    { IDS_USAGE_STR12C,     1, 0, 1 },
    { IDS_USAGE_STR13,      1, 0, 1 },
    { IDS_USAGE_STR14,      1, 0, 1 },
    { IDS_USAGE_STR14B,     1, 0, 1 },
    { IDS_USAGE_STR15,      0, 0, 1 },
    { IDS_USAGE_STR16,      0, 0, 1 },
    { IDS_USAGE_STR17,      0, 0, 1 },
    { IDS_USAGE_STR18,      0, 0, 1 },
    { IDS_USAGE_STR19,      0, 0, 3 },
    { IDS_USAGE_STR20,      0, 0, 1 },
    { IDS_USAGE_STR21,      1, 0, 1 },
    { IDS_USAGE_STR22,      1, 0, 3 },
    { IDS_USAGE_STR23,      1, 0, 0 },
    { IDS_USAGE_STR24,      1, 0, -1 },
    { IDS_USAGE_STR25,      1, 0, -1 },
    { IDS_USAGE_STR26,      1, 0, -1 },
};

INT_PTR CALLBACK UsageDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            HWND hwnd = GetDlgItem(hDlg, IDC_USAGE_TEXT);
            if (hwnd)
            {
                const UsageStringInfo *p;
                int c;
                char sz[256];
                PARAFORMAT pf;
                CHARFORMAT cf;
                int pos;

                pf.cbSize = sizeof(pf);

                SendMessage(hwnd, EM_SETBKGNDCOLOR, 0, GetSysColor(COLOR_BTNFACE));
                SendMessage(hwnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(4, 4));

                for (p = c_rg, c = NUMELMS(c_rg); c--; p++)
                {
                    LPCSTR psz;

                    if (p->m_fExternalOnly && (1 & IsSLMOK()))
                        continue;
                    if (p->m_fInternalOnly && !(1 & IsSLMOK()))
                        continue;

                    if (p->m_ids == -1)
                    {
                        if (2 & IsSLMOK())
                        {
                            Format(sz, s);
                            lstrcat(sz,"\n\n");
                            psz = sz;
                        }
                        else
                            continue;
                    }
                    else
                        psz = LoadRcString(p->m_ids);

                    pos = LOWORD(SendMessage(hwnd, EM_GETSEL, 0, 0));
                    SendMessage(hwnd, EM_REPLACESEL, FALSE, (LPARAM)psz);
                    SendMessage(hwnd, EM_SETSEL, pos, -1);

                    SendMessage(hwnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
                    if (p->m_cIndent >= 0)
                    {
                        static const int c_rgIndents[] = { 320*1, 320*5, 320*6 };
                        static const int c_rgOffsets[] = { 320*4, 0, 0 };

                        pf.dwMask |= PFM_STARTINDENT|PFM_OFFSET|PFM_TABSTOPS;
                        pf.dxStartIndent = 0;
                        pf.dxOffset = 0;
                        if (p->m_cIndent)
                        {
                            pf.dxStartIndent = c_rgIndents[p->m_cIndent - 1];
                            pf.dxOffset = c_rgOffsets[p->m_cIndent - 1];
                        }
                        pf.cTabCount = 2;
                        pf.rgxTabs[0] = c_rgIndents[0];
                        pf.rgxTabs[1] = c_rgIndents[1];
                    }
                    else
                    {
                        pf.dwMask |= PFM_STARTINDENT|PFM_OFFSET|PFM_NUMBERING;
                        pf.dxStartIndent = 320;
                        pf.dxOffset = 180;
                        pf.wNumbering = PFN_BULLET;
                    }
                    SendMessage(hwnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);

                    SendMessage(hwnd, EM_SETSEL, -1, -1);
                }

                cf.cbSize = sizeof(cf);
                cf.dwMask = CFM_COLOR;
                cf.dwEffects = 0;
                cf.crTextColor = GetSysColor(COLOR_BTNTEXT);
                SendMessage(hwnd, EM_SETSEL, 0, -1);
                SendMessage(hwnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
                SendMessage(hwnd, EM_SETSEL, -1, -1);
                pos = LOWORD(SendMessage(hwnd, EM_GETSEL, 0, 0));
                SendMessage(hwnd, EM_SETSEL, pos - 1, pos);
                SendMessage(hwnd, EM_REPLACESEL, 0, (LPARAM)"");
                SendMessage(hwnd, EM_SETSEL, 0, 0);
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam)
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void
windiff_usage(
              LPSTR msg
              )
{
    INT_PTR retval;
    UINT fuStyle =  MB_ICONINFORMATION|MB_OKCANCEL;


    if (msg)
    {
        char Usage[4096];

        // since msg may be a pointer returned by LoadRcString, copy it off so
        // we don't stomp on the string when we load IDS_WINDIFF_USAGE.
        lstrcpy(Usage, msg);
        msg = Usage;

        retval = MessageBox(hwndClient,
                            msg,
                            LoadRcString(IDS_WINDIFF_USAGE),
                            fuStyle);
    }
    else
    {
        HINSTANCE h;

        h = LoadLibrary("riched20.dll");
        if (!h)
            h = LoadLibrary("riched32.dll");
        if (h)
        {
            retval = DialogBox(hInst, (LPCSTR)IDD_USAGE, hwndClient, UsageDlgProc);
            FreeLibrary(h);
        }
        else
        {
            windiff_usage(LoadRcString(IDS_ERROR_CANTLOADRICHEDIT));
            retval = IDOK;
        }
    }

    if (retval == IDCANCEL)
        exit(1);
}


/*  Functionally similar to strtok except that " ... " is a token, even if
    it contains spaces and the delimiters are built in (no second parameter)
    GetNextToken(foo) delivers the first token in foo (or NULL if foo is empty)
    and caches foo so that GetNextToken(NULL) then gives the next token.  When there
    are no more tokens left it returns NULL
    It mangles the original by peppering it with NULLs as it chops the tokens
    off.  Each time except the last it inserts a new NULL.
    Obviously not thread safe!
    Command line is limited to 512 chars.

*/
char *
GetNextToken(
             char * Tok
             )
{
    static char * Source;     // The address of the original source string
                              // which gets progressively mangled

    static char RetBuff[512]; // We will build results in here
    static char *Ret;         // We build the results here (in RetBuff)
                              // but moved along each time.

    static char * p;       // the next char to parse in Source
                           // NULL if none left.

    // Quotes are a damned nuisance (they are the whole reason why strtok
    // wouldn't work).  If the string starts with quotes then we potentially
    // need to pull together fragments of the string "foo""ba"r => foobar
    // We want to pull these together into storage that we can safely write
    // into and return (can't be stack).  Mangling the original parameter
    // gets very messy so we cache a pointer to the original source that
    // we work through and we build up output tokens in a static
    // and therefore permanently wasted buffer of (arbitrarily) 512 bytes.
    // then we can set Ret to \0 and concatenate bits on as we find them.
    // The rule is that we split at the first space outside quotes.


    // cache the Source if a "first time" call.  Kill the "finished" case.
    if (Tok!=NULL) {
        Source = Tok;
        Ret = RetBuff;
        RetBuff[0] = '\0';
        p = Source;
    } else if (p==NULL) {
        return NULL;          // finished
    } else {
        Ret +=strlen(Ret)+1;  // slide it past last time's stuff
    }

    *Ret = '\0';              // empty string to concatenate onto

    // from here on Tok is used as a temporary.

    // keep taking sections and adding them to the start of Source
    for (; ; ) {

        // for each possibility we grow Ret and move p on.
        if (*p=='\"') {
            ++p;
            Tok = My_mbschr(p, '"');
            if (Tok==NULL) {
                strcat(Ret, p);
                p = NULL;
                return Ret;
            } else {
                *Tok = '\0';    // split the section off, replaceing the "
                strcat(Ret, p); // add it to the result
                p = Tok+1;      // move past the quote
            }
        } else {
            int i = strcspn(p," \"");   // search for space or quote
            if (p[i]=='\0') {
                // It's fallen off the end
                strcat(Ret, p);
                p = NULL;
                return Ret;
            } else if (p[i]==' ') {
                // We've hit a genuine delimiting space
                p[i] = '\0';
                strcat(Ret, p);
                p +=i+1;

                // strip trailing spaces (leading spaces for next time)
                while (*p==' ')
                    ++p;
                if (*p=='\0')
                    p = NULL;

                return Ret;
            } else {
                // we've hit a quote
                p[i] = '\0';
                strcat(Ret, p);
                p[i] = '\"';     // put it back so that we can find it again
                p +=i;           // aim at it and iterate
            }
        }

    } // for

} // GetNextToken





/*
 * parse command line arguments
 *
 * The user can give one or two paths. if only one, we assume the second
 * is '.' for the current directory. if one of the two paths is a directory
 * and the other a file, we compare a file of the same name in the two dirs.
 *
 * the command -s filename causes the outline list to be written to a file
 * -s{slrd} filename allows selection of which files are written out;
 * by default, we assume -sld for files left and different.
 * -s{slrd}x causes the program to exit after the list has been written out
 *
 * -r server uses server as a remote checksum server, and will also mark the
 * first of the two names as a remote path.
 * Note that this is undocumented.
 *
 * -L means that the first argument is the path from slm.ini
 * You can use -L and -R together for a remote library.
 * -LPfoo specifies the Source Depot port "foo".
 * -LCbar specifies the Source Depot client "bar".
 * -L! forces Source Depot mode without checking for slm.ini or sd.ini.
 *
 * -T means tree.  Go deep.
 * -D means Directory or Don't go deep.
 * -O means Stay in outline mode.  No auto expand.
 * -N means Notify on completion - try a NET SEND.
 *
 * The default is Deep, -L overrides and implies shallow.
 * A deep library compare requires -L and -T
 */
void
ParseArgs(
          char * lpCmdLine
          )
{
    PTHREADARGS ta;
    BOOL fMaybeVersionControl = FALSE;  // TRUE means we saw an ambiguous switch and we're not sure whether to do diff argument1 against its matching source library revisions
    BOOL fSDOpened = FALSE;             // TRUE means call SD to get list of opened files, and ONLY diff those files
    BOOL fSDDescribe = FALSE;           // TRUE means call SD to get list of files in specified change number, and ONLY diff those files
    BOOL fAllowTwoPaths = TRUE;         // FALSE means -l or -lr was used
    BOOL fReverse = FALSE;              // -lr means reverse
    BOOL fDeepDefault = TRUE;
    char * tok;         /* token from lpCmdLine */

    DWORD threadid;
    UINT idsError = 0;

    /* thread args can't be on the stack since the stack will change
     * before the thread completes execution
     */
    ta = (PTHREADARGS) gmem_get(hHeap, sizeof(THREADARGS));
#ifdef REMOTE_SERVER
    ta->server = NULL;
#endif
    ta->first = NULL;
    ta->second = NULL;
    ta->savelist = NULL;
    ta->savecomp = NULL;
    ta->listopts = 0;
    ta->compopts = 0;
    ta->notify = NULL;
    ta->fExit = FALSE;
    ta->fDeep = FALSE;  /* No -T option seen yet */

    tok = GetNextToken(lpCmdLine);

    while ((tok!=NULL) && (lstrlen(tok) > 0)) {

        if (tok[0] == '/' && tok[1] == '/')
        {
            SLM_ForceSourceDepot();
            goto LFile;
        }

        /* is this an option ? */
        if ((tok[0] == '-') || (tok[0] == '/')) {
            switch (tok[1]) {
#ifdef REMOTE_SERVER
                case 'r':
                case 'R':
                    ta->server = GetNextToken(NULL);
                    break;
#endif
                case 's':
                case 'S':
                    /* read letters for the save option: s,l,r,d */
                    for (tok+=2; *tok != '\0'; ++tok) {
                        switch (*tok) {
                            case 's':
                            case 'S':
                                ta->listopts |= INCLUDE_SAME;
                                break;
                            case 'l':
                            case 'L':
                                ta->listopts |= INCLUDE_LEFTONLY;
                                break;
                            case 'r':
                            case 'R':
                                ta->listopts |= INCLUDE_RIGHTONLY;
                                break;
                            case 'd':
                            case 'D':
                                ta->listopts |= INCLUDE_DIFFER;
                                break;
                            case 'x':
                            case 'X':
                                ta->fExit = TRUE;
                                break;
                            default:
                                idsError = 0;
                                goto LUsage;
                        }
                    }

                    if (ta->listopts == 0) {
                        /* default to left and differ */
                        ta->listopts = (INCLUDE_LEFTONLY) | (INCLUDE_DIFFER);
                    }
                    ta->savelist = GetNextToken(NULL);
                    break;
                case 'f':
                case 'F':
					/* read letters for the save option: s,l,r,d,e,i */
                    for(tok = &tok[2]; *tok != '\0'; ++tok) {
                        switch(*tok) {
                        case 'i':
                        case 'I':
                                ta->compopts |= INCLUDE_SAME;
                                break;
                        case 'l':
                        case 'L':
                                ta->compopts |= INCLUDE_LEFTONLY;
                                break;
                        case 'r':
                        case 'R':
                                ta->compopts |= INCLUDE_RIGHTONLY;
                                break;
                        case 'f':
                        case 'F':
                                ta->compopts |= INCLUDE_MOVEDLEFT;
                                break;
                        case 'g':
                        case 'G':
                                ta->compopts |= INCLUDE_MOVEDRIGHT;
                                break;
                        case 's':
                        case 'S':
                                ta->compopts |= INCLUDE_SIMILARLEFT;
                                break;
                        case 'a':
                        case 'A':
                                ta->compopts |= INCLUDE_SIMILARRIGHT;
                                break;
                        case 'x':
                        case 'X':
                                ta->fExit = TRUE;
                                break;
                        default:
                                idsError = 0;
                                goto LUsage;
                        }
                    }

                    if (ta->compopts == 0) {
                            /* default to showing all diffs (everything but same) */
                            ta->compopts = INCLUDE_LEFTONLY | INCLUDE_RIGHTONLY
                                         | INCLUDE_DIFFER | INCLUDE_MOVEDLEFT
                                         | INCLUDE_MOVEDRIGHT;
                    }
                    ta->savecomp = GetNextToken(NULL);
                    break;
                case 'i':
                case 'I':
                    ta->fInputFile = TRUE;
                    if (tok[2] == '1')
                    {
                        ta->fInputFileSingle = TRUE;
                        tok++;
                    }
                    tok += 2;
                    // allow (but don't require) a space between '-I' and the
                    // 'inputfilename' argument.
                    if (!*tok)
                        tok = GetNextToken(NULL);
                    if (!tok || !*tok)
                    {
                        idsError = IDS_ERROR_IARGS;
                        goto LUsage;
                    }
                    SLM_SetInputFile(tok);
                    break;
                case 'l':
                case 'L':
                    {
                        if (!tok[2])
                        {
                            // "-l" by itself forces version control mode
                            ta->fVersionControl = TRUE;
                            fMaybeVersionControl = FALSE;
                        }

                        /* read letters for the library option: r,! */
                        for (tok+=2; *tok != '\0'; ++tok)
                        {
                            switch (*tok)
                            {
                            case 'r':
                            case 'R':
                                fReverse = TRUE;            // reverse compare
                                // "-lr" forces version control mode
                                ta->fVersionControl = TRUE;
                                fMaybeVersionControl = FALSE;
                                break;
                            case 'p':
                            case 'P':
                                // allow (but don't require) a space between
                                // '-LP' and the 'server:port' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_SetSDPort(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;
                            case 'c':
                            case 'C':
                                // allow (but don't require) a space between
                                // '-LC' and the 'clientname' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_SetSDClient(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case 'o':
                            case 'O':
                                if (fSDDescribe)
                                {
                                    idsError = IDS_ERROR_OVSD_OPTION;
                                    goto LUsage;
                                }
                                fSDOpened = TRUE;
                                // don't allow a space between '-LO' and the
                                // 'changenum' argument, because the argument
                                // is optional.
                                SLM_SetSDChangeNumber(tok + 1);
                                tok += lstrlen(tok);
                                goto LForceSD;

                            case 'd':
                            case 'D':
                                if (fSDOpened)
                                {
                                    idsError = IDS_ERROR_OVSD_OPTION;
                                    goto LUsage;
                                }
                                fSDDescribe = TRUE;
                                // allow (but don't require) a space between
                                // '-LD' and the 'changenum' argument.
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_Describe(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case 'u':
                            case 'U':
                                if (tok[1])
                                    tok++;
                                else
                                    tok = GetNextToken(NULL);
                                if (tok)
                                {
                                    SLM_OverrideUncRoot(tok);
                                    tok += lstrlen(tok);
                                }
                                goto LForceSD;

                            case '!':
LForceSD:
                                // force SD mode without checking for any
                                // slm.ini or sd.ini files.
                                if (!ta->fVersionControl)
                                    fMaybeVersionControl = TRUE;
                                SLM_ForceSourceDepot();
                                break;
                            default:
                                idsError = 0;
                                goto LUsage;
                            }

                            if (!tok)
                                break;
                        }

                        if (!fMaybeVersionControl)
                        {
                            fMaybeVersionControl = FALSE;
                            ta->fVersionControl = TRUE;
                        }
                    }
                    break;
                case 'n':
                case 'N':
                    ta->notify = GetNextToken(NULL);
                    break;
                case 't':
                case 'T':
                    ta->fDeep = TRUE;
                    break;
                case 'd':
                case 'D':
                    ta->fDeep = FALSE;     // This directory only
                    fDeepDefault = FALSE;
                    break;
                case 'o':
                case 'O':
                    fAutoExpand = FALSE;
                    break;
                case 'p':
                case 'P':
                    gbPerverseCompare = TRUE;
                    break;
                case 'x':
                case 'X':
                    {
                        BOOL track;
                        char *c = &tok[2];
                        if (*c == '\0') {
                            TrackLeftOnly = FALSE;
                            TrackRightOnly = FALSE;
                            TrackSame = FALSE;
                            TrackDifferent = TRUE;
                            TrackReadonly = TRUE;
                            TrackSlmFiles = FALSE;
                            break;
                        }
                        track = FALSE;
                        while (*c != '\0') {
                            if (toupper(*c) == 'L') {
                                TrackLeftOnly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'R') {
                                TrackRightOnly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'S') {
                                TrackSame = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'D') {
                                TrackDifferent = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'O') {
                                TrackReadonly = track;
                                track = FALSE;
                            } else if (toupper(*c) == 'I') {
                                TrackSlmFiles = track;
                                track = FALSE;
                            } else if (toupper(*c) == '-') {
                                track = TRUE;
                            } else {
                                idsError = 0;
                                goto LUsage;
                            }
                            c++;
                        }
                        break;
                    }

#ifdef DEBUG
                case '!':
                    DebugBreak();
                    break;
#endif

                case '?':
                    {
                        int j = 0;
                        windiff_usage(NULL);
                        for (++tok; tok[1] != '\0'; ++tok)
                            if ('?'==*tok) ++j;

                        if (2==j) {
                            WriteProfileString(APPNAME, "SYSUK", "1");
                        }
                        return;
                    }
                default:
                    idsError = 0;
                    goto LUsage;
            }
        } else {
        LFile:
            if (ta->first == NULL) {
                ta->first = tok;
            } else {
                ta->second = tok;
            }
        }
        tok = GetNextToken(NULL);
    }

    // maybe version control
    if (fMaybeVersionControl)
    {
        if (!ta->second)
        {
            // if user didn't specify two paths, then kick us into version
            // control mode, where we'll compare the specified directory
            // against its matching server revisions.
            ta->fVersionControl = TRUE;
        }
    }

    if (ta->fInputFile && ta->first && !PerformReplacement(ta->first, 0, 0, 0))
    {
        idsError = IDS_ERROR_IARGS;
        goto LUsage;
    }

    // version control
    if (ta->fVersionControl && !ta->fInputFile)
    {
        if (ta->second != NULL)
        {
            idsError = IDS_ERROR_L_OPTION;
            goto LUsage;
        }
        else
        {
            SLMOBJECT hslm;
            LPSTR srcdir, slmpath;

            if (fSDOpened || fSDDescribe)
            {
                if (ta->first && fSDDescribe)
                {
                    idsError = IDS_ERROR_LD_OPTION;
                    goto LUsage;
                }

                // hand off the -LO path to the SlmMgr for special
                // processing.
                SLM_Opened(ta->first, &idsError);
                if (idsError)
                    goto LUsage;

                ta->first = NULL;
                ta->fOpenedFiles = fSDOpened;
                ta->fDescribeFiles = fSDDescribe;
            }
            else
            {
                if (ta->first == NULL)
                {
                    ta->first = ".";
                }

                if (!fReverse)
                {
                    ta->second = ta->first;
                    ta->first = ta->slmpath;    /* point at buffer */
                    srcdir = ta->second;
                    slmpath = ta->first;
                }
                else
                {
                    ta->second = ta->slmpath;
                    srcdir = ta->first;
                    slmpath = ta->second;
                }

                /*
                 * look for the slm enlistment dir in
                 * the other argument (NULL means current dir).
                 */
                if ((hslm = SLM_New(srcdir, &idsError)) == NULL)
                    goto LUsage;

                if (IsSourceDepot(hslm))
                {
                    LPSTR pTag;

                    // copy source path to the server path
                    lstrcpy(slmpath, srcdir);

                    // check if the source path specified a revision tag
                    pTag = SLM_ParseTag(srcdir, TRUE);
                    if (pTag)
                    {
                        // revision tag was specified, so now that
                        // SLM_ParseTag stripped it off of srcdir, both
                        // slmpath and srcdir contain exactly what we want
                        // them to.  now we just free pTag and we're golden.
                        gmem_free(hHeap, pTag, lstrlen(pTag)+1);
                    }
                    else
                    {
                        // no revision tag specified, so let's go against the
                        // #have revisions.  SLM goes against head revisions,
                        // but that's just because SLM happens to have those
                        // on a share.  since SD doesn't use a share, we have
                        // to query the server for specific versions anyway.
                        // use "windiff * *#head" to mimic the SLM behavior.
                        lstrcat(slmpath, "#have");
                    }
                }
                else
                {
                    SLM_GetMasterPath(hslm, slmpath);
                }
                SLM_Free(hslm);
            }
        }
    }

    /* set the correct depth */
    if (ta->fDeep)
        ;                       /* explicitly set -- leave it alone */
    else if (ta->fVersionControl)
        ;                       /* default to shallow for SLM or SD */
    else ta->fDeep = fDeepDefault;  /* global default */

    if (!fSDOpened && !fSDDescribe && !ta->fInputFile)
    {
        /* any paths to scan ? */
        if (ta->first == NULL)
            return;

        if (ta->second == NULL)
            ta->second = ".";
    }
    else
    {
        ta->fDeep = FALSE;
    }

    SetBusy();

    /* minimise the window if -s flag given */
    if (ta->savelist != NULL || ta->savecomp != NULL) {
        ShowWindow(hwndClient, SW_MINIMIZE);
    }

    /* make an empty view */
    current_view = view_new(hwndRCD);
    DisplayMode = MODE_OUTLINE;

    ta->view = current_view;

    /* attempt to create a worker thread */

    ghThread = CreateThread(NULL, 0, wd_initial, (LPVOID) ta,
                            0, &threadid);
    if (ghThread == NULL)
    {

        /* either the createthread failed, or we are
         * in WIN16 - so do without the extra thread - just
         * call the function synchronously
         */

        wd_initial( (LPVOID) ta);

    }

    return;

LUsage:
    windiff_usage(idsError ? LoadRcString(idsError) : NULL);
} /* ParseArgs */


void
GetFontPref(void)
{
    DeleteObject(g_hFont);
    g_hFont = 0;

    GetProfileString(APPNAME, szFontFaceName, "FixedSys", g_szFontFaceName, sizeof(g_szFontFaceName));
    g_nFontHeight = GetProfileInt(APPNAME, szFontHeight, 12);
    g_fFontBold = GetProfileInt(APPNAME, szFontBold, FALSE);
    g_bFontCharSet = (BYTE)GetProfileInt(APPNAME, szFontCharSet, 0);

    g_hFont = CreateFont(g_nFontHeight, 0, 0, 0,
                         g_fFontBold ? FW_BOLD : FW_DONTCARE,
                         FALSE, FALSE, FALSE,
                         g_bFontCharSet,
                         OUT_DEFAULT_PRECIS,
                         CLIP_LH_ANGLES|CLIP_STROKE_PRECIS,
                         DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                         g_szFontFaceName);
}


/* create any pens/brushes, and read defaults
 * from the profile file for menu settings etc.
 */
void
CreateTools(void)
{

    /* standard message that table class sends us for
     * notifications and queries.
     */
    table_msgcode = RegisterWindowMessage(TableMessage);

    line_numbers = GetProfileInt(APPNAME, szLineNumbers, line_numbers);
    outline_include = GetProfileInt(APPNAME, szFileInclude, outline_include);
    expand_include = GetProfileInt(APPNAME, szLineInclude, expand_include);
    ignore_blanks = GetProfileInt(APPNAME, szBlanks, ignore_blanks);
    Algorithm2 = GetProfileInt(APPNAME, szAlgorithm2, Algorithm2);
    mono_colours = GetProfileInt(APPNAME, szMonoColours, mono_colours);
    picture_mode = GetProfileInt(APPNAME, szPicture, picture_mode);
    hide_markedfiles = GetProfileInt(APPNAME, szHideMark, hide_markedfiles);

    GetProfileString(APPNAME, szEditor, editor_cmdline, editor_cmdline,
                     sizeof(editor_cmdline));

    g_tabwidth = GetProfileInt(APPNAME, szTabWidth, g_tabwidth);

    InitializeCriticalSection(&CSWindiff);

    GetFontPref();
}

/* delete any pens or brushes that were created in CreateTools */
void
DeleteTools(void)
{
    DeleteCriticalSection(&CSWindiff);
    DeleteObject(g_hFont);
}


/* check for messages to keep the UI working. Also check whether
 * we have had an abort request (IDM_ABORT), and
 * return TRUE if abort requested, otherwise FALSE
 */
BOOL
Poll(void)
{
    MSG msg;

    /* don't do the message loop in the WIN32 version since we
     * have multiple threads to handle that, and this is being called
     * on a worker thread, not the UI thread.
     *
     * in the WIN32 case, just check for abort requests
     */

    /* message loop */
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!TranslateAccelerator(hwndClient, haccel, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return(bAbort);
}

/* position child windows on a resize of the main window */

void
DoResize(
         HWND hWnd
         )
{
    RECT rc;
    int bar_width;

    GetClientRect(hWnd, &rc);
    MoveWindow(hwndStatus, 0, 0, rc.right - rc.left, status_height, TRUE);

    bar_width = (rc.right - rc.left) * BAR_WIN_WIDTH / 100;

    /* bar window is hidden unless in expand mode */
    if ((DisplayMode == MODE_EXPAND) && (picture_mode)) {
        MoveWindow(hwndBar, 0, status_height,
                   bar_width, rc.bottom - status_height, TRUE);
        MoveWindow(hwndRCD, bar_width, status_height,
                   (rc.right - rc.left) - bar_width,
                   rc.bottom - status_height, TRUE);
        ShowWindow(hwndBar, SW_SHOW);
    } else {
        MoveWindow(hwndRCD, 0, status_height, (rc.right - rc.left),
                   rc.bottom - status_height, TRUE);
        ShowWindow(hwndBar, SW_HIDE);
    }

}

INT_PTR
APIENTRY
AboutBox(
         HWND hDlg,
         unsigned message,
         WPARAM wParam,
         LPARAM lParam
         )
{
    char ch[256];

    switch (message) {

        case WM_INITDIALOG:
            wsprintf(ch, "%d.%02d", Version, SubVersion);
            SetDlgItemText(hDlg, IDD_VERSION, ch);
            return(TRUE);

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;
    }
    return(FALSE);
}


/* -- menu commands ---------------------------------------------------*/

/* print the current view */
void
DoPrint(void)
{
    Title head, foot;
    PrintContext context;
    TCHAR szPage[50];
    TCHAR szTitle[20];

    /* print context contains the header and footer. Use the
     * default margins and printer selection
     */

    /* we set the table id to be TABID_PRINTER. When the table calls
     * back to get text and properties, we use this to indicate
     * that the table refered to is the 'current_view', but in print
     * mode, and thus we will use different colours/fonts.
     */
    context.head = &head;
    context.foot = &foot;
    context.margin = NULL;
    context.pd = NULL;
    context.id = TABID_PRINTER;

    /* header is filenames or just WinDiff if no names known*/
    if (strlen(AppTitle) > 0) {
        head.ptext = AppTitle;
    } else {
        head.ptext = (LPSTR)szWinDiff;
    }

    /* header is centred, footer is right-aligned and
     * consists of the page number
     */
    head.props.valid = P_ALIGN;
    head.props.alignment = P_CENTRE;
    lstrcpy(szPage,LoadRcString(IDS_PAGE));
    foot.ptext = (LPSTR)szPage;
    foot.props.valid = P_ALIGN;
    foot.props.alignment = P_RIGHT;

    if ( SendMessage(hwndRCD, TM_PRINT, 0, (LPARAM) &context)) {
        Trace_Status(LoadRcString(IDS_SENT_TO_PRINTER));
    } else {
        windiff_UI(TRUE);
        lstrcpy(szTitle,LoadRcString(IDS_WINDIFF_ERROR));
        MessageBox(hwndClient, LoadRcString(IDS_UNABLE_TO_PRINT),
                szTitle, MB_ICONEXCLAMATION);
        windiff_UI(FALSE);
    }
}

/* find the next line in the current view that is
 * not STATE_SAME. Start from the current selection, if valid, or
 * from the top of the window if no selection.
 *
 */
#define FindNextChange()    _FindNextChange(TRUE, TRUE)
#define FindPrevChange()    _FindPrevChange(TRUE, TRUE)

BOOL
_FindNextChange(BOOL fErrorPopup, BOOL fForceAutoCenter)
{
    long row;
    long dyRowsFromTop = -1;
    long top = (int)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    /* start from the selection or top of the window if no selection */
    if (selection >= 0)
    {
        row = selection + 1;
        if (!fForceAutoCenter)
            dyRowsFromTop = selection - top;
    }
    else
    {
        row = top;
    }


    /* find the next 'interesting' line */
    row = view_findchange(current_view, row, TRUE);
    if (row >= 0) {
        SetSelection(row, 1, dyRowsFromTop);
        return(TRUE);
    } else if (fErrorPopup) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NO_MORE_CHANGES), szWinDiff,
                   MB_ICONINFORMATION|MB_OK);
        windiff_UI(FALSE);

    }
    return(FALSE);
}

/* find the previous line in the current view that is not STATE_SAME
 */
BOOL
_FindPrevChange(BOOL fErrorPopup, BOOL fForceAutoCenter)
{
    long row;
    long dyRowsFromTop = -1;
    long top = (int)SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    /* start from the selection or top of window if no selection */
    if (selection >= 0)
    {
        row = selection - 1;
        if (!fForceAutoCenter)
            dyRowsFromTop = selection - top;
    }
    else
    {
        row = top;
    }

    /* find the previous 'interesting' line */
    row = view_findchange(current_view, row, FALSE);
    if (row >= 0) {
        SetSelection(row, 1, dyRowsFromTop);
        return(TRUE);
    } else if (fErrorPopup) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NO_PREV_CHANGES), szWinDiff,
                   MB_ICONINFORMATION|MB_OK);
        windiff_UI(FALSE);

    }
    return(FALSE);
}

#ifndef WriteProfileInt // Only needed if the profile->registry
// mapping is not in use
BOOL
WriteProfileInt(
                LPSTR AppName,
                LPSTR Key,
                int Int
                )
{       char Str[40];
    wsprintf(Str, szD, Int);
    return WriteProfileString(AppName, Key, Str);

} /* WriteProfileInt */
#endif


/* switch to expand view of the selected line */
BOOL
ToExpand(
         HWND hwnd
         )
{


    if (selection < 0) {
        return(FALSE);
    }

    // nothing to do if already expanded
    if (view_isexpanded(current_view)) {
        return(FALSE);
    }

    /*
     * note that we are starting expansion
     */
    view_expandstart(current_view);


    if (!view_isexpanded(current_view)) {
        /* save the current outline size and position */
        WINDOWPLACEMENT wp;

        wp.length = sizeof(wp);

        if (GetWindowPlacement(hwndClient,&wp)) {
            WriteProfileInt(APPNAME, szOutlineShowCmd, wp.showCmd);
            WriteProfileInt(APPNAME, szOutlineMaxX, wp.ptMaxPosition.x);
            WriteProfileInt(APPNAME, szOutlineMaxY, wp.ptMaxPosition.y);
            WriteProfileInt(APPNAME, szOutlineNormLeft, wp.rcNormalPosition.left);
            WriteProfileInt(APPNAME, szOutlineNormTop, wp.rcNormalPosition.top);
            WriteProfileInt(APPNAME, szOutlineNormRight, wp.rcNormalPosition.right);
            WriteProfileInt(APPNAME, szOutlineNormBottom, wp.rcNormalPosition.bottom);
            WriteProfileInt(APPNAME, szOutlineSaved, 1);
        }

        /* restore the previous expanded size and position, if any */
        if (GetProfileInt(APPNAME, szExpandedSaved, 0)) {
            wp.flags                   = 0;
            wp.showCmd
            = GetProfileInt( APPNAME, szExpandShowCmd
                             , SW_SHOWMAXIMIZED);
            wp.ptMaxPosition.x
            = GetProfileInt( APPNAME, szExpandMaxX, 0);
            wp.ptMaxPosition.y
            = GetProfileInt( APPNAME, szExpandMaxY, 0);
            wp.rcNormalPosition.left
            = GetProfileInt( APPNAME, szExpandNormLeft
                             , wp.rcNormalPosition.left);
            wp.rcNormalPosition.top
            = GetProfileInt( APPNAME, szExpandNormTop
                             , wp.rcNormalPosition.top);
            wp.rcNormalPosition.right
            = GetProfileInt( APPNAME, szExpandNormRight
                             , wp.rcNormalPosition.right);
            wp.rcNormalPosition.bottom
            = GetProfileInt( APPNAME, szExpandNormBottom
                             , wp.rcNormalPosition.bottom);
            SetWindowPlacement(hwndClient,&wp);
        } else ShowWindow(hwndClient, SW_SHOWMAXIMIZED);
    }

    /*change the view mapping to expand mode */
    if (view_expand(current_view, selection)) {

        /* ok - we now have an expanded view - change status
         * to show this
         */

        DisplayMode = MODE_EXPAND;

        /* resize to show the graphic bar picture */
        DoResize(hwndClient);


        /* change button,status text-if we are not still busy*/
        if (!fBusy) {
            TCHAR szBuf[10];
            /* the status field when we are expanded shows the
             * tag field (normally the file name) for the
             * item we are expanding
             */
            SetStatus(view_getcurrenttag(current_view) );
            lstrcpy(szBuf,LoadRcString(IDS_OUTLINE));
            SetButtonText(szBuf);
        }

        // Skip to the first change.  (But don't do this if the first
        // line of the file itself has changed; otherwise we would skip
        // over it!)
        if (view_getrowstate(current_view, 0) == STATE_SAME) {
            _FindNextChange(FALSE, TRUE);
        }

        return(TRUE);
    }
    return(FALSE);
} /* ToExpand */

/* switch back to outline view - showing just the list of file names.
 */
void
ToOutline(
          HWND hwnd
          )
{
    // if current_view is NULL, don't access it with view_xxx functions.
    if (!current_view)
        return;

    /*
     * if we are in the middle of expanding, ignore the
     * key stroke - user can try again later
     */
    if (view_expanding(current_view)) {
        return;
    }

    if (view_isexpanded(current_view)) {
        /* save the current expanded size and position */
        WINDOWPLACEMENT wp;

        wp.length = sizeof(wp);
        if (GetWindowPlacement(hwndClient,&wp)) {
            WriteProfileInt(APPNAME, szExpandShowCmd, wp.showCmd);
            WriteProfileInt(APPNAME, szExpandMaxX, wp.ptMaxPosition.x);
            WriteProfileInt(APPNAME, szExpandMaxY, wp.ptMaxPosition.y);
            WriteProfileInt(APPNAME, szExpandNormLeft, wp.rcNormalPosition.left);
            WriteProfileInt(APPNAME, szExpandNormTop, wp.rcNormalPosition.top);
            WriteProfileInt(APPNAME, szExpandNormRight, wp.rcNormalPosition.right);
            WriteProfileInt(APPNAME, szExpandNormBottom, wp.rcNormalPosition.bottom);
            WriteProfileInt(APPNAME, szExpandedSaved, 1);
        }

        /* restore the previous expanded size and position, if any */
        if (GetProfileInt(APPNAME, szOutlineSaved, 0)) {
            wp.flags = 0;
            wp.showCmd
            = GetProfileInt( APPNAME, szOutlineShowCmd
                             , SW_SHOWNORMAL);
            wp.ptMaxPosition.x
            = GetProfileInt( APPNAME, szOutlineMaxX, 0);
            wp.ptMaxPosition.y
            = GetProfileInt( APPNAME, szOutlineMaxY, 0);
            wp.rcNormalPosition.left
            = GetProfileInt( APPNAME, szOutlineNormLeft
                             , wp.rcNormalPosition.left);
            wp.rcNormalPosition.top
            = GetProfileInt( APPNAME, szOutlineNormTop
                             , wp.rcNormalPosition.top);
            wp.rcNormalPosition.right
            = GetProfileInt( APPNAME, szOutlineNormRight
                             , wp.rcNormalPosition.right);
            wp.rcNormalPosition.bottom
            = GetProfileInt( APPNAME, szOutlineNormBottom
                             , wp.rcNormalPosition.bottom);
            SetWindowPlacement(hwndClient,&wp);
        } else {
            ShowWindow(hwndClient, SW_SHOWNORMAL);
        }
    }

    DisplayMode = MODE_OUTLINE;

    /* switch mapping back to outline view */
    view_outline(current_view);

    /* hide bar window and resize to cover */
    DoResize(hwndClient);


    /* change label on button */
    if (!fBusy) {
        TCHAR szBuf[8];
        lstrcpy(szBuf,LoadRcString(IDS_EXPAND));
        SetButtonText(szBuf);
        SetStatus(NULL);
    }
} /* ToOutline */

/*
 * if the user clicks on a MOVED line in expand mode, we jump to the
 * other line. We return TRUE if this was possible,  or FALSE otherwise.
 * If bMove is not true, then just test to see if it is possible to move
 * and don't actually make the selection change. (I was going to have
 * an IsMoved function but there seemed to be so much in common).
 */
BOOL
ToMoved(
        HWND hwnd,
        BOOL bMove
        )
{
    BOOL bIsLeft;
    int linenr, state;
    long i, total;

    if (DisplayMode != MODE_EXPAND) {
        return(FALSE);
    }
    if (selection < 0) {
        return(FALSE);
    }

    state = view_getstate(current_view, selection);
    if (state == STATE_MOVEDLEFT || state == STATE_SIMILARLEFT) {
        bIsLeft = TRUE;
        /* get the linenr of the other copy */
        linenr = abs(view_getlinenr_right(current_view, selection));
    } else if (state == STATE_MOVEDRIGHT || state == STATE_SIMILARRIGHT) {
        bIsLeft = FALSE;
        /* get the linenr of the other copy */
        linenr = abs(view_getlinenr_left(current_view, selection));
    } else {
        /* not a moved line - so we can't find another copy */
        return(FALSE);
    }

    /* search the view for this line nr */
    total = view_getrowcount(current_view);
    for (i = 0; i < total; i++) {
        if (bIsLeft) {
            if (linenr == view_getlinenr_right(current_view, i)) {
                /* found it */
                if (bMove) {
                    SetSelection(i, 1, -1);
                }
                return(TRUE);
            }
        } else {
            if (linenr == view_getlinenr_left(current_view, i)) {
                if (bMove) {
                    SetSelection(i, 1, -1);
                }
                return(TRUE);
            }
        }
    }
    return(FALSE);
} /* ToMoved */


void
RescanFile(
           HWND hwnd
           )
{
    COMPITEM ci;
    int iStart;
    int iEnd;
    int i;

    /* N.B.  This should work in both expanded and outline mode.
     * (used to work only in outline mode)
     */
    if (selection_nrows > 0 || DisplayMode == MODE_EXPAND) {
        if (DisplayMode == MODE_EXPAND) {
            iStart = 0;
            iEnd = 1;
        } else {
            iStart = selection;
            iEnd = iStart + selection_nrows;
        }
        for (i = iStart; i < iEnd; i++) {
            ci = view_getitem(current_view, i);
            if (ci != NULL) {
                compitem_rescan(ci);
            }
        }
    } else {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NOTHING_RESCANNED),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);

        return;
    }
    PostMessage(hwndClient, WM_COMMAND, IDM_UPDATE, (LPARAM) ci);
} /* RescanFile */


/*
 * launch an editor on the current file (the file we are expanding, or
 * in outline mode the selected row. Option allows selection of the
 * left file, the right file or the composite view of this item.
 * pe points to a packet of parameters that must be freed before returning.
 * The return value is meaningless (just to conform to CreateThread).
 */
LONG WINAPI
do_editfile(
            PEDITARGS pe
            )
{
    VIEW view = pe->view;
    int option = pe->option;
    long L_selection = pe->selection;

    COMPITEM item;
    LPSTR fname;
    char cmdline[MAX_PATH] = {'\0'};
    long selline, currentline;
    char * pOut = cmdline;
    char * pIn = editor_cmdline;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    item = view_getitem(view, L_selection);
    if (item == NULL) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_NOTHING_TO_EDIT),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);

        return -1;
    }

    fname = compitem_getfilename(view, item, option);

    if ( 0 == fname ) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_FILE_DOESNT_EXIST),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        goto error;
    }

    // convert the selected line into a line number within the file
    if (L_selection > 0) {
        selline = L_selection;
    } else {
        // if no current selection, look for the line at top of window
        selline = (long) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);
    }

    switch ( option ) {
        case CI_LEFT:
            do {
                currentline = view_getlinenr_left( view, selline);

                // if the selected line is not in the left file,
                // backup one line and try again until we hit the top of
                // file or find a line that is within the left file

                if (selline > 0) {
                    selline--;
                }
            } while ((currentline <= 0) && (selline > 0));

            break;

        case CI_RIGHT:
            do {
                currentline = view_getlinenr_right( view, selline);
                if (selline > 0) {
                    selline--;
                }
            } while ((currentline <= 0) && (selline > 0));
            break;

        default:
            currentline = 1;
            break;
    }

    if (currentline <=0) {
        currentline = 1;
    }


    while ( *pIn ) {
        switch ( *pIn ) {
            case '%':
                pIn++;
                switch ( *pIn ) {
                    case 'p':
                        lstrcpy( pOut, fname );
                        while ( *pOut )
                            pOut++;
                        break;

                    case 'l':
                        _ltoa( currentline, pOut, 10 );
                        while ( *pOut )
                            pOut++;
                        break;

                    default:
                        if (IsDBCSLeadByte(*pIn) && *(pIn+1)) {
                            *pOut++ = *pIn++;
                        }
                        *pOut++ = *pIn;
                        break;
                }
                pIn++;
                break;

            default:
                if (IsDBCSLeadByte(*pIn) && *(pIn+1)) {
                    *pOut++ = *pIn++;
                }
                *pOut++ = *pIn++;
                break;
        }
    }

    *pOut = '\0';

    /* WIN32 version launches the process and waits for it to
     * complete
     */

    // note - make title of window same each time since if this is
    // a command-window editor (eg slick) NT will only apply window
    // property changes to all subsequent editor windows if they
    // have the same title. If you include the full command line in the
    // window title, it will differ each time. Win95 seems not to use
    // this field.
    si.lpTitle = "Edit File";
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;
    si.lpDesktop = NULL;
    // si.dwXCountChars = 100;            // didn't work.
    // si.dwYCountChars = 60;             // dunno why not.
    si.dwFlags = STARTF_FORCEONFEEDBACK;  // |STARTF_USECOUNTCHARS; didn't work.


    if (!CreateProcess(NULL,
                       cmdline,
                       NULL,
                       NULL,
                       FALSE,
                       NORMAL_PRIORITY_CLASS,
                       NULL,
                       NULL,
                       &si,
                       &pi)) {
        windiff_UI(TRUE);
        MessageBox(hwndClient, LoadRcString(IDS_FAILED_TO_LAUNCH_EDT),
                   szWinDiff, MB_ICONSTOP|MB_OK);
        windiff_UI(FALSE);
        goto error;
    }

    /* wait for completion. */
    WaitForSingleObject(pi.hProcess, INFINITE);

    /* close process and thread handles */
    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);

    /* finished with the filename. deletes it if it was a temp. */
    compitem_freefilename(item, option, fname);

    /*
     * refresh cached view always .  A common trick is to edit the
     * composite file and then save it as a new left or right file.
     * Equally the user can edit the left and save as a new right.
     */

    /* We want to force both files to be re-read, but it's not a terribly
     * good idea to throw the lines away on this thread.  Someone might
     * be reading them on another thread! (e.g. user tries to expand
     * file, seems to be taking a long time, so user decides to edit it
     * to have a look!
     * DO NOT file_discardlines(compitem_getleftfile(item))
     * DO NOT file_discardlines(compitem_getrightfile(item))
     */

    /* We don't discard the lines (well, not on this thread) but we do discard
     * status information.  (Used to work only in expanded mode, relying on
     * status being reset when we go back to outline).
     */


    /* force the compare to be re-done */
    compitem_rescan(item);
    PostMessage(hwndClient, WM_COMMAND, IDM_UPDATE, (LPARAM)item);

    error:
    gmem_free(hHeap, (LPSTR) pe, sizeof(EDITARGS));

    return 0;

} /* do_editfile */


/* Launch an editor on a separate thread.  It will actually get a separate
   process, but we want our own thread in this process.  This thread will
   wait until it's finished and then order up a refresh of the UI.
   Need to give it its parameters as a gmem allocated packet because
   it IS on a separate thread.
*/
void
do_editthread(
              VIEW view,
              int option
              )
{
    PEDITARGS pe;
    HANDLE thread;
    DWORD threadid;

    pe = (PEDITARGS) gmem_get(hHeap, sizeof(EDITARGS));
    pe->view = view;
    pe->option = option;
    pe->selection = selection;

    thread = CreateThread( NULL
                           , 0
                           , (LPTHREAD_START_ROUTINE)do_editfile
                           , (LPVOID) pe
                           , 0
                           , &threadid
                         );
    if (thread == NULL)
    {
        /* either the createthread failed, or we are
         * in WIN16 - so do without the extra thread - just
         * call the function synchronously
         */
        do_editfile(pe);
    }
    else CloseHandle(thread);

    // new layout not needed as do_editfile sends IDM_UPDATE

} /* do_editthread */


// we are called when the right mouse button is pressed. Before we are
// called, the row clicked on has been selected. We need to put up
// a context menu.
void
OnRightClick(
            HWND hWnd,
            int x,
            int y)
{
    HMENU L_hMenu, hSubMenu;
    POINT point;
    UINT uEnable;

    if (DisplayMode == MODE_OUTLINE) {
        L_hMenu = LoadMenu(hInst, szOutlineMenu);
    } else if (DisplayMode == MODE_EXPAND) {
        L_hMenu = LoadMenu(hInst, szExpandMenu);
    } else {
        return;
    }

    if (!L_hMenu) {
        return;
    }

    hSubMenu = GetSubMenu(L_hMenu, 0);

    // -- lots of stuff to disable inappropriate menu items --

    // enable IDM_TOMOVED only if it is a moved line that we can
    // see the other copy of in this view (and only if there is a single
    // selected line)

    if (DisplayMode == MODE_EXPAND) {
        if (ToMoved(hWnd, FALSE) && (1 == selection_nrows)) {
            uEnable = MF_ENABLED;
        } else {
            uEnable = MF_GRAYED;
        }
        EnableMenuItem(L_hMenu, IDM_TOMOVED, MF_BYCOMMAND | uEnable);
    }


    // disable next/prev buttons if no more changes in that direction
    if (view_findchange(current_view, selection+1, TRUE) >=0) {
        uEnable = MF_ENABLED;
    } else {
        uEnable = MF_GRAYED;
    }
    EnableMenuItem(hSubMenu, IDM_FCHANGE, MF_BYCOMMAND | uEnable);

    if (view_findchange(current_view, selection-1, FALSE) >=0) {
        uEnable = MF_ENABLED;
    } else {
        uEnable = MF_GRAYED;
    }
    EnableMenuItem(hSubMenu, IDM_FPCHANGE, MF_BYCOMMAND | uEnable);

    // check for left-only and right-only files and disable the appropriate
    // menu item
    // disable all editxxx and Expand if multiple files selected
    if ((DisplayMode == MODE_OUTLINE) && (selection_nrows > 1)) {
        EnableMenuItem(hSubMenu, IDM_EDITLEFT, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EDITRIGHT, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EDITCOMP, MF_BYCOMMAND|MF_GRAYED);
        EnableMenuItem(hSubMenu, IDM_EXPAND, MF_BYCOMMAND|MF_GRAYED);
    } else {
        COMPITEM item = view_getitem(current_view, selection);
        UINT uEnableLeft = MF_ENABLED;
        UINT uEnableRight = MF_ENABLED;
        UINT uEnableComp = MF_ENABLED;
        int state;
        FILEDATA fd;

        state = compitem_getstate(item);

        if (state == STATE_FILERIGHTONLY) {
            uEnableLeft = MF_GRAYED;
        } else if (state == STATE_FILELEFTONLY) {
            uEnableRight = MF_GRAYED;
        }

        fd = compitem_getleftfile(item);
        if (fd && file_IsUnicode(fd)) {
            uEnableComp = MF_GRAYED;
        }
        fd = compitem_getrightfile(item);
        if (fd && file_IsUnicode(fd)) {
            uEnableComp = MF_GRAYED;
        }

        EnableMenuItem(hSubMenu, IDM_EDITLEFT, MF_BYCOMMAND | uEnableLeft);
        EnableMenuItem(hSubMenu, IDM_EDITRIGHT, MF_BYCOMMAND | uEnableRight);
        EnableMenuItem(hSubMenu, IDM_EDITCOMP, MF_BYCOMMAND | uEnableComp);

        if (DisplayMode == MODE_OUTLINE) {
            EnableMenuItem(hSubMenu, IDM_EXPAND, MF_BYCOMMAND|MF_ENABLED);
        }
    }


    // convert the window-based co-ord to a screen co-ord
    point.x = x;
    point.y = y;
    ClientToScreen(hwndRCD, &point);

    TrackPopupMenu(
                  hSubMenu,
                  TPM_LEFTALIGN|TPM_RIGHTBUTTON,
                  point.x, point.y,
                  0,
                  hWnd,
                  NULL);

    DestroyMenu(L_hMenu);
}

//
// refresh the display after a rescan of a given line.
// try to maintain existing scroll position and selection.
void
OnUpdate(
         COMPITEM item
         )
{

    // save current scroll position
    long row = (long) SendMessage(hwndRCD, TM_TOPROW, FALSE, 0);

    // ... and current selection
    long lSel = selection;
    long cSel = selection_nrows;

    /* update the display.  Options or files may have changed */
    /* discard lines  (thereby forcing re-read).
     */
    file_discardlines(compitem_getleftfile(item));
    file_discardlines(compitem_getrightfile(item));

    view_changediffoptions(current_view);

    // tell the table view to recalculate its
    // idea of the width of each col etc

    SendMessage(hwndRCD, TM_NEWLAYOUT, 0, (LPARAM) current_view);

    // set old scroll position
    SendMessage(hwndRCD, TM_TOPROW, TRUE, row);

    // set back old selection
    SetSelection(lSel, cSel, lSel - row);


    /* force repaint of bar window */
    InvalidateRect(hwndBar, NULL, TRUE);
}

/* status bar and busy flags --------------------------------------------*/


/* set the Text on the statusbar button to reflect the current state */
void
SetButtonText(
              LPSTR cmd
              )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDM_ABORT, (LPARAM) cmd);
}

/* set the status field (left-hand part) of the status bar. */
void
SetStatus(
          LPSTR cmd
          )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDL_STATLAB, (LPARAM) cmd);
}

/*
 * Trace_Status is called from the ssclient.lib functions to report
 * non-fatal errors - put them on the status line
 */
void
Trace_Status(
             LPSTR str
             )
{
    SetStatus(str);
}


/* set the names field - the central box in the status bar */
void
SetNames(
         LPSTR names
         )
{
    SendMessage(hwndStatus, SM_SETTEXT, IDL_NAMES, (LPARAM) names);
    if (names == NULL) {
        AppTitle[0] = '\0';
    } else {
        My_mbsncpy(AppTitle, names, sizeof(AppTitle));
    }
}

/*
 * if we are not already busy, set the busy flag.
 *
 * WIN32: enter critical section first.
 */
BOOL
SetBusy(void)
{
    HMENU hmenu;


    WDEnter();

    if (fBusy) {
        WDLeave();
        return(FALSE);
    }


    fBusy = TRUE;

    SetStatus(LoadRcString(IDS_COMPARING));
    /* status also on window text, so that you can see even from
     * the icon when the scan has finished
     */
    SetWindowText(hwndClient, LoadRcString(IDS_SCANNING));

    /* disable appropriate parts of menu */
    hmenu = GetMenu(hwndClient);
    EnableMenuItem(hmenu, IDM_FILE,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_DIR,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_PRINT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_SAVELIST,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_COPYFILES,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);

    /* enable abort only when busy */
    EnableMenuItem(hmenu, IDM_ABORT,MF_ENABLED|MF_BYCOMMAND);
    SetButtonText(LoadRcString(IDS_ABORT));  /* leave DisplayMode unchanged */

    WDLeave();
    return(TRUE);
} /* SetBusy */

void
SetNotBusy(void)
{
    HMENU hmenu;

    /*
     * this function can be called from the worker thread.
     * Thus we must not cause any SendMessage calls to windows
     * owned by the main thread while holding the CritSec or we
     * could cause deadlock.
     *
     * the critsec is only needed to protect the fBusy flag - so
     * clear the busy flag last, and only get the crit sec as needed.
     */

    /* reset button and status bar (clearing out busy flags) */
    if (current_view == NULL) {
        SetButtonText(LoadRcString(IDS_EXIT));
        SetStatus(NULL);
        DisplayMode = MODE_NULL;
    } else if (view_isexpanded(current_view)) {
        TCHAR szBuf[10];
        lstrcpy(szBuf,LoadRcString(IDS_OUTLINE));
        SetButtonText(szBuf);
        SetStatus(view_getcurrenttag(current_view) );
        DisplayMode = MODE_EXPAND;
    } else {
        TCHAR szBuf[8];
        lstrcpy(szBuf,LoadRcString(IDS_EXPAND));
        SetButtonText(szBuf);
        SetStatus(NULL);
        DisplayMode = MODE_OUTLINE;
    }

    SetWindowText(hwndClient, szWinDiff);

    /* re-enable appropriate parts of menu */
    hmenu = GetMenu(hwndClient);
    EnableMenuItem(hmenu, IDM_FILE,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_DIR,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_PRINT,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_SAVELIST,MF_ENABLED|MF_BYCOMMAND);
    EnableMenuItem(hmenu, IDM_COPYFILES,MF_ENABLED|MF_BYCOMMAND);

    /* disable abort now no longer busy */
    EnableMenuItem(hmenu, IDM_ABORT,MF_DISABLED|MF_GRAYED|MF_BYCOMMAND);

    /* clear the busy flag, protected by critical section */
    WDEnter();

    fBusy = FALSE;
    bAbort = FALSE;

    if (ghThread!=NULL) {
        CloseHandle(ghThread);
        ghThread = NULL;
    }
    WDLeave();
} /* SetNotBusy */


BOOL
IsBusy()
{
    BOOL bOK;

    WDEnter();
    bOK = fBusy;
    WDLeave();
    return(bOK);
} /* IsBusy */

void
BusyError(void)
{
    windiff_UI(TRUE);
    MessageBox(hwndClient,
               LoadRcString(IDS_PLEASE_WAIT),
               szWinDiff, MB_OK|MB_ICONSTOP);
    windiff_UI(FALSE);
} /* BusyError */

/* --- colour scheme --------------------------------------------------- */

/*
 * map the state given into a foreground and a background colour
 * for states that are highlighted. Return P_FCOLOUR if the foreground
 * colour (put in *foreground) is to be used, return P_FCOLOUR|P_BCOLOUR if
 * both *foreground and *background are to be used, or 0 if the default
 * colours are to be used.
 */
UINT
StateToColour(
              int state,
              BOOL bMarked,
              int col,
              DWORD * foreground,
              DWORD * foregroundws,
              DWORD * background
              )
{

    /* we always set both colours - allows all the colours to
       be controlled from the profile.  Important for the
       visually impaired.  So we first set the dafaults.
    */
    *foreground = rgb_defaultfore;
    *foregroundws = rgb_defaultforews;
    *background = rgb_defaultback;

    // marked compitems are highlighted specially - for now, use the
    // colour scheme used for different lines in expand mode
    if (bMarked) {
        *foreground = rgb_rightfore;
        *background = rgb_rightback;
        return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);
    }


    switch (state) {

        case STATE_DIFFER:
            /* files that differ are picked out in a foreground highlight,
             * with the default background
             */
            *foreground = rgb_outlinehi;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_FILELEFTONLY:
            /* zebra lines in both files - right file version */
            *foreground = rgb_fileleftfore;
            *background = rgb_fileleftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_FILERIGHTONLY:
            /* zebra lines in both files - right file version */
            *foreground = rgb_filerightfore;
            *background = rgb_filerightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILAR:
            /* for files that are same within expand compare options
             * e.g. differ only in ignorable blanks  (NYI)
            */
            *foreground = rgb_similar;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_LEFTONLY:
            /* lines only in the left file */
            *foreground = rgb_leftfore;
            *background = rgb_leftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_RIGHTONLY:
            /* lines only in the right file */
            *foreground = rgb_rightfore;
            *background = rgb_rightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_MOVEDLEFT:
            /* displaced lines in both files - left file version */
            *foreground = rgb_mleftfore;
            *background = rgb_mleftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_MOVEDRIGHT:
            /* displaced lines in both files - right file version */
            *foreground = rgb_mrightfore;
            *background = rgb_mrightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILARLEFT:
            /* zebra lines in both files - left file version */
            *foreground = rgb_similarleft;
            *background = rgb_leftback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        case STATE_SIMILARRIGHT:
            /* zebra lines in both files - right file version */
            *foreground = rgb_similarright;
            *background = rgb_rightback;
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);

        default:

            /* no highlighting - default colours */
            return(P_FCOLOUR|P_FCOLOURWS|P_BCOLOUR);
    }

}

/* table window communication routines ---------------------------------*/

/* set a given row as the selected row in the table window */
void
SetSelection(
             long rownr,
             long nrows,
             long dyRowsFromTop
             )
{
    TableSelection select;

    select.startrow = rownr;
    select.startcell = 0;
    select.nrows = nrows;
    select.ncells = 1;
    select.dyRowsFromTop = dyRowsFromTop;
    SendMessage(hwndRCD, TM_SELECT, 0, (LPARAM)&select);
}


/* handle table class call back to get nr of rows and columns,
 * and properties for the whole table.
 * the 'table id' is either TABID_PRINTER - meaning we are
 * printing the current_view, or it is the view to
 * use for row/column nr information
 */
long
do_gethdr(
          HWND hwnd,
          lpTableHdr phdr
          )
{
    VIEW view;
    BOOL bIsPrinter = FALSE;

    if (phdr->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) phdr->id;
    }
    if (view == NULL) {
        return(FALSE);
    }

    phdr->nrows = view_getrowcount(view);

    /*  three columns: line nr, tag and rest of line */

    /*
     * if IDM_NONRS (no line numbers) is selected, suppress the
     * line-nr column entirely to save screen space
     */
    if (line_numbers == IDM_NONRS) {
        phdr->ncols = 2;
        phdr->fixedcols = 0;
    } else {
        phdr->ncols = 3;
        phdr->fixedcols = 1;
    }

    phdr->fixedrows = 0;
    phdr->fixedselectable = FALSE;
    phdr->hseparator = TRUE;
    phdr->vseparator = TRUE;

    phdr->selectmode = TM_ROW | TM_MANY;
    /*
     * find if we are in expand mode - ask for the item we are expanding.
     */
    if (view_isexpanded(view) == TRUE) {

        /* use focus rect as selection mode in expand mode
         * so as not to interfere with background colours.
         */
        phdr->selectmode |= TM_FOCUS;
    } else {
        /* use default solid inversion when possible as it is clearer.*/
        phdr->selectmode |= TM_SOLID;
    }

    /* please send TQ_SCROLL notifications when the table is scrolled */
    phdr->sendscroll = TRUE;
    if (g_hFont) {
        phdr->props.valid = P_FONT;
        phdr->props.hFont = g_hFont;
    }

    return TRUE;
}

/* respond to table callback asking for the size and properties
 * of each column. table id is either TABID_PRINTER (meaning the
 * current_view, for printing) or it is the view to be used.
 */
long
do_getprops(
            HWND hwnd,
            lpColPropsList propslist
            )
{
    int i, cell;
    BOOL bIsPrinter = FALSE;
    VIEW view;
    HFONT hfontSystem = GetStockObject(SYSTEM_FONT);
    HFONT hfontFixed = g_hFont ? g_hFont : GetStockObject(SYSTEM_FIXED_FONT);

    if (propslist->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) propslist->id;
    }
    if (view == NULL) {
        return(FALSE);
    }

    if (g_hFont)
    {
        HDC hdc;
        TEXTMETRIC tmSystem;
        TEXTMETRIC tmFixed;
        HFONT hfont;

        hdc = GetDC(hwnd);
        if (hdc)
        {
            hfont = SelectObject(hdc, hfontSystem);
            GetTextMetrics(hdc, &tmSystem);
            SelectObject(hdc, hfontFixed);
            GetTextMetrics(hdc, &tmFixed);
            SelectObject(hdc, hfont);
            ReleaseDC(hwnd, hdc);

            if (tmFixed.tmHeight + 1 < tmSystem.tmHeight)
                hfontSystem = hfontFixed;
        }
    }

    /* the table inteface is slightly confused here. we are not
     * guaranteed which columns we are being asked about, so instead
     * of just setting each column cols[0], cols[1] etc, we need
     * to loop through, looking at each column in the table and
     * seeing which it is.
     */
    for (i = 0; i < propslist->ncols; i++) {
        cell = i + propslist->startcol;
        propslist->plist[i].props.valid = 0;

        /* for all column widths, add on 1 for the NULL char. */

        /*
         * skip the line nr column if IDM_NONRS
         */
        if (line_numbers == IDM_NONRS) {
            cell++;
        }

        if (cell == 0) {
            /* properties for line nr column */

            propslist->plist[i].nchars = view_getwidth(view, 0)+1;
            propslist->plist[i].props.valid |= P_ALIGN | P_FONT;
            propslist->plist[i].props.alignment = P_CENTRE;
            propslist->plist[i].props.hFont = hfontSystem;
        } else if (cell == 1) {

            /* properties for tag field */
            propslist->plist[i].nchars = view_getwidth(view, 1)+1;
            propslist->plist[i].props.valid |= P_ALIGN | P_FONT;
            propslist->plist[i].props.alignment = P_LEFT;
            propslist->plist[i].props.hFont = hfontSystem;
        } else {
            /* properties for main text column -
             * use a fixed font unless printing (if
             * printing, best to use the default font, because
             * of resolution differences.
             * add on 8 chars to the width to ensure that
             * the width of lines beginning with tabs
             * works out ok
             */
            propslist->plist[i].nchars = view_getwidth(view, 2)+1;
            propslist->plist[i].props.valid |= P_ALIGN;
            propslist->plist[i].props.alignment = P_LEFT;
            if (!bIsPrinter) {
                propslist->plist[i].props.valid |= P_FONT;
                propslist->plist[i].props.hFont = hfontFixed;
            }
        }
    }
    return (TRUE);
}

/* respond to a table callback asking for the contents of individual cells.
 * table id is either TABID_PRINTER, or it is a pointer to the view
 * to use for data. If going to the printer, don't set the
 * colours (stick to black and white).
 */
long
do_getdata(
           HWND hwnd,
           lpCellDataList cdlist
           )
{
    int start, endcell, col, i;
    int state, markedstate;
    lpCellData cd;
    VIEW view;
    LPSTR textp;
    LPWSTR pwzText;
    BOOL bIsPrinter = FALSE;

    if (cdlist->id == TABID_PRINTER) {
        view = current_view;
        bIsPrinter = TRUE;
    } else {
        view = (VIEW) cdlist->id;
    }

    /* set state data */
    state = view_getstate(view, cdlist->row);
    markedstate = view_getmarkstate(view, cdlist->row);
    start = cdlist->startcell;
    endcell = cdlist->ncells + start;
    if (cdlist->row >= view_getrowcount(view)) {
        return(FALSE);
    }
    for (i = start; i < endcell; i++) {
        cd = &cdlist->plist[i - start];


        /* skip the line number column if IDM_NONRS */
        if (line_numbers == IDM_NONRS) {
            col = i+1;
        } else {
            col = i;
        }

        /* set colour of text to mark out
         * lines that are changed, if not printer - for the
         * printer everything should stay in the default colours
         * or it will be grayed out and look ugly
         */

        if ( !bIsPrinter
          || (GetProfileInt(APPNAME, szColourPrinting, 0) > 0)) {

            /* convert the state of the requested row into a
             * colour scheme. returns P_FCOLOUR and/or
             * P_BCOLOUR if it sets either of the colours
             */
            cd->props.valid |=
            StateToColour(
                         state,
                         markedstate,
                         col,
                         &cd->props.forecolour,
                         &cd->props.forecolourws,
                         &cd->props.backcolour);
        }

        textp = view_gettext(view, cdlist->row, col);
        if (cd->nchars != 0) {
            if (textp == NULL) {
                cd->ptext[0] = '\0';
            } else {
                My_mbsncpy(cd->ptext, textp, cd->nchars -1);
                cd->ptext[cd->nchars - 1] = '\0';
            }
        }

        //$ review: (chrisant) YUCK.  this is ugly, but i'll fix it when i
        // rewrite windiff to be 100% unicode for the file contents, should be
        // about Oct00 or Nov99.
        pwzText = view_gettextW(view, cdlist->row, col);
        if (pwzText && cd->nchars)
        {
            cd->pwzText = (WCHAR*)gmem_get(hHeap, cd->nchars * sizeof(*cd->pwzText));
            wcsncpy(cd->pwzText, pwzText, cd->nchars -1);
            cd->pwzText[cd->nchars - 1] = 0;
        }
        else
        {
            gmem_free(hHeap, (LPSTR) cd->pwzText, cd->nchars * sizeof(*cd->pwzText));
            cd->pwzText = 0;
        }

    }
    return(TRUE);
}

/* table window has finished with this view. it can be deleted.
 */
void
SvrClose(void)
{
    view_delete(current_view);
    current_view = NULL;

    /* hide picture - only visible when we are in MODE_EXPAND */
    DisplayMode = MODE_NULL;
    DoResize(hwndClient);

    /* if we already busy when closing this view (ie
     * we are in the process of starting a new scan,
     * then leave the status bar alone, otherwise
     * we should clean up the state of the status bar
     */
    if (!fBusy) {
        SetButtonText(LoadRcString(IDS_EXIT));
        SetNames(NULL);
        SetStatus(NULL);

    }

} /* SvrClose */


/* handle callbacks and notifications from the table class */
long
TableServer(
            HWND hwnd,
            WPARAM cmd,
            LPARAM lParam
            )
{
    lpTableHdr phdr;
    lpColPropsList proplist;
    lpCellDataList cdlist;
    lpTableSelection pselect;

    switch (cmd) {
        case TQ_GETSIZE:
            /* get the nr of rows and cols in this table */
            phdr = (lpTableHdr) lParam;
            return(do_gethdr(hwnd, phdr));

        case TQ_GETCOLPROPS:
            /* get the size and properties of each column */
            proplist = (lpColPropsList) lParam;
            return (do_getprops(hwnd, proplist));

        case TQ_GETDATA:
            /* get the contents of individual cells */
            cdlist = (lpCellDataList) lParam;
            return (do_getdata(hwnd, cdlist));


        case TQ_SELECT:
            /* selection has changed */
        case TQ_ENTER:
            /* user has double-clicked or pressed enter */

            pselect = (lpTableSelection) lParam;

            /* store location for use in later search (IDM_FCHANGE) */

            /*
             * convert selection so that it always runs forward - we
             * do not need to know where the anchor vs endpoint is
             */
            if (pselect->nrows == 0) {
                selection = -1;
                selection_nrows = 0;
            } else {
                if (pselect->nrows < 0) {
                    selection = pselect->startrow + pselect->nrows + 1;
                    selection_nrows = -pselect->nrows;
                } else {
                    selection = (int) pselect->startrow;
                    selection_nrows = pselect->nrows;
                }
                if (cmd == TQ_ENTER) {
                    /* try to expand this row */
                    if (!ToExpand(hwnd)) {
                        /* expand failed - maybe this
                         * is a moved line- show the other
                         * copy
                         */
                        ToMoved(hwnd, TRUE);
                    }

                }
            }
            break;

        case TQ_CLOSE:
            /* close this table - table class no longer needs data*/
            SvrClose();
            break;

        case TQ_SCROLL:
            /* notification that the rows visible in the window
             * have changed -change the current position lines in
             * the graphic bar view (the sections picture)
             */
            if (picture_mode) {
                BarDrawPosition(hwndBar, NULL, TRUE);
            }
            break;

        case TQ_TABS:
            if (lParam != 0) {
                LONG * pTabs = (LONG *) lParam;
                *pTabs = g_tabwidth;
            }
            return TRUE;

        case TQ_SHOWWHITESPACE:
            if (lParam != 0) {
                LONG * pbShowWhitespace = (LONG *) lParam;
                *pbShowWhitespace = (show_whitespace && view_isexpanded(current_view));
            }
            return TRUE;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/* --- thread worker routines (called synchoronously in WIN16)--------------*/

/*
 * called on worker thread (not UI thread) to handle the work
 * requested on the command line. called directly from UI thread if
 * WIN16.
 *
 * arg is a pointer to a THREADARGS block allocated from gmem_get(hHeap). This
 * needs to be freed before exiting.
 */
DWORD WINAPI
wd_initial(
           LPVOID arg
           )
{
    PTHREADARGS pta = (PTHREADARGS) arg;
    COMPLIST cl = 0;
    COMPITEM ci = NULL;
    BOOL fOK = TRUE;
    LEFTRIGHTPAIR ppairs = 0;
    LPCSTR pszLeftHdr;
    LPCSTR pszRightHdr;
    BOOL fPairs = TRUE;

    /* build a complist from these args,
     * and register with the view we have made
     */
    if (pta->fInputFile)
    {
        ppairs = SLM_ReadInputFile(pta->first, pta->second, pta->fInputFileSingle, pta->fVersionControl);
        pszLeftHdr = "Left";
        pszRightHdr = "Right";

        if (!ppairs)
        {
            SetNotBusy();
            MessageBox(hwndClient, LoadRcString(IDS_ERROR_IARGS_OPENFILE), szWinDiff, MB_OK);
            exit(1);
        }
    }
    else if (pta->fOpenedFiles)
    {
        ppairs = SLM_GetOpenedFiles();
        pszLeftHdr = "depot#have";
        pszRightHdr = "client";
    }
    else if (pta->fDescribeFiles)
    {
        ppairs = SLM_GetDescribeFiles();
        pszLeftHdr = "before";
        pszRightHdr = "after";
    }
    else
        fPairs = FALSE;

    if (fPairs)
    {
        if (ppairs)
        {
            int sequence = 0;

            while (ppairs)
            {
                ++sequence;
                complist_append(&cl, LEFTRIGHTPAIR_Left(ppairs),
                                LEFTRIGHTPAIR_Right(ppairs), &sequence);
                ppairs = LEFTRIGHTPAIR_Next(ppairs);
            }

            fOK = complist_appendfinished(&cl, pszLeftHdr, pszRightHdr, pta->view);
        }
    }
    else
    {
#ifdef REMOTE_SERVER
        if (pta->server != NULL)
        {
            cl = complist_remote(pta->server, pta->first, pta->second,
                                 pta->view, pta->fDeep);
        }
        else
#endif
        {
            cl = complist_args(pta->first, pta->second, pta->view, pta->fDeep);
        }
    }

    /*
     * the app can be closed during execution of this routine if
     * we don't retain BUSY. This means we can be expanding structures
     * while the main thread is freeing them.
     *
     * SetNotBusy();
     */

    if (cl == NULL || !fOK) {
        SLM_FreeAll();
        view_close(pta->view);
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();
        return 0;
    }

    /* Comparison complete.  Should we tell anybody? */
    if (pta->notify!=NULL) {
        char cmdline[512];
        lstrcpy(cmdline, "NET SEND ");
        lstrcat(cmdline, pta->notify);
        lstrcat(cmdline, " Finished Windiff ");
        lstrcat(cmdline, pta->first);
        lstrcat(cmdline, " ");
        lstrcat(cmdline, pta->second);
        system(cmdline);
        /* Don't check retcode.  If it fails too bad.  What would we do?  Net send a msg? */
    }


    /* if savelist or savecomp was selected, write out the list or comp file */
    if (pta->savelist != NULL || pta->savecomp != NULL) {
        if (pta->savelist != NULL) {
            complist_savelist(cl, pta->savelist, pta->listopts);
        }

        if (pta->savecomp != NULL) {
            /* if list item was selected, use that */
            if (selection >= 0) {
                ci = view_getitem(pta->view, selection);
          }
          else {
              /* default to first visible item, if any */
              if (view_getrowcount(pta->view) > 0) {
                  ci = view_getitem(pta->view, 0);
              }
          }
          compitem_savecomp(pta->view, ci, pta->savecomp, pta->compopts);
        }
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();

        /* exit if -x was set */
        if (pta->fExit) {
            exit(0);
        }
    }


    /* if savelist was selected, write out the list and exit if -x was set */
    if (pta->savelist != NULL) {
        complist_savelist(cl, pta->savelist, pta->listopts);
        gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
        SetNotBusy();
        if (pta->fExit) exit(0);
    }

    /* if there was only one file, expand it, unless... */
    if (view_getrowcount(pta->view) == 1) {
        /* The interesting case is where there are a bunch of files
           but only one of them is Different.  In this case we do
           NOT expand it even though it is the only one showing.
        */
//        UINT nItems = complist_itemcount(view_getcomplist(pta->view));
        UINT nItems = complist_itemcount(cl);
        /* And even then, don't expand if the option said don't.
           Imagine just one HUGE REMOTE FILE.  Painful.
        */
        if (nItems==1 && fAutoExpand) {
            SetSelection(0, 1, -1);
            ToExpand(hwndClient);
        }
    }


    gmem_free(hHeap, (LPSTR) pta, sizeof(THREADARGS));
    SetNotBusy();
    return(0);
} /* wd_initial */


/*
 * called on worker thread (not UI thread) to handle a Dir request
 * (called synchronously if WIN16).
 */
DWORD WINAPI
wd_dirdialog(LPVOID arg)
{

    VIEW view = (VIEW) arg;

    /* make a COMPLIST using the directory dialog,
     * and notify the view
     */
    if (complist_dirdialog(view) == NULL) {
        view_close(view);
    }

    /* all done! */
    SetNotBusy();
    return(0);
}

#ifdef REMOTE_SERVER

/*
 * called on worker thread to do a remote diff
 */
DWORD WINAPI
wd_remote(
          LPVOID arg
          )
{
    VIEW view = (VIEW) arg;

    /* make a COMPLIST using the remote dialog,
     * and remote checksum server, and notify
     * the new view of this complist.
     */
    if (complist_remote(NULL, NULL, NULL, view, TRUE) == NULL) {
        view_close(view);
    }

    /* all done! */
    SetNotBusy();

    return(0);
} /* wd_remote */
#endif

/*
 * called on worker thread to do a copy-files operation
 * (called synchronously if WIN16).
 */
DWORD WINAPI
wd_copy(
        LPVOID arg
        )
{

    VIEW view = (VIEW) arg;

    complist_copyfiles(view_getcomplist(view), NULL, 0);

    SetNotBusy();

    return(0);
}


/*----- winproc for main window ---------------------------------
 *
 */

INT_PTR
APIENTRY
MainWndProc(
            HWND hWnd,
            UINT message,
            WPARAM wParam,
            LPARAM lParam
            )
{
    char str[32];
    long ret;
    DWORD threadid;

    switch (message) {

        case WM_CREATE:

            /* initialise menu options to default/saved
             * option settings
             */

#define CHECKMENU(id, fChecked)  \
          CheckMenuItem(hMenu, (id), (fChecked) ? MF_CHECKED:MF_UNCHECKED)

            /* outline_include options */
            CHECKMENU(IDM_OUTLINE_INCSAME,   (outline_include & INCLUDE_SAME));
            CHECKMENU(IDM_OUTLINE_INCLEFT,   (outline_include & INCLUDE_LEFTONLY));
            CHECKMENU(IDM_OUTLINE_INCRIGHT,  (outline_include & INCLUDE_RIGHTONLY));
            CHECKMENU(IDM_OUTLINE_INCDIFFER, (outline_include & INCLUDE_DIFFER));

            /* expand_include options */
            CHECKMENU(IDM_EXPAND_INCSAME,         (expand_include & INCLUDE_SAME));
            CHECKMENU(IDM_EXPAND_INCLEFT,         (expand_include & INCLUDE_LEFTONLY));
            CHECKMENU(IDM_EXPAND_INCRIGHT,        (expand_include & INCLUDE_RIGHTONLY));
            CHECKMENU(IDM_EXPAND_INCMOVEDLEFT,    (expand_include & INCLUDE_MOVEDLEFT));
            CHECKMENU(IDM_EXPAND_INCMOVEDRIGHT,   (expand_include & INCLUDE_MOVEDRIGHT));
            CHECKMENU(IDM_EXPAND_INCSIMILARLEFT,  (expand_include & INCLUDE_SIMILARLEFT));
            CHECKMENU(IDM_EXPAND_INCSIMILARRIGHT, (expand_include & INCLUDE_SIMILARRIGHT));

            /* other options */
            CHECKMENU(line_numbers, TRUE);
            CHECKMENU(expand_mode, TRUE);
            CHECKMENU(IDM_IGNBLANKS, ignore_blanks);
            CHECKMENU(IDM_SHOWWHITESPACE, show_whitespace);
            CHECKMENU(IDM_ALG2, Algorithm2);
            CHECKMENU(IDM_MONOCOLS, mono_colours);
            CHECKMENU(IDM_PICTURE, picture_mode);
            CHECKMENU(IDM_HIDEMARK, hide_markedfiles);
#undef CHECKMENU

            /* nothing currently displayed */
            DisplayMode = MODE_NULL;

            break;

        case WM_SYSCOLORCHANGE:
            {
                HIGHCONTRAST hc;

                hc.cbSize = sizeof(hc);
                SystemParametersInfo(SPI_GETHIGHCONTRAST,0 ,&hc, 0);

                mono_colours = (hc.dwFlags & HCF_HIGHCONTRASTON);
                if (mono_colours) {
                    SetMonoColours();
                } else {
                    SetColours();	
                }

                CheckMenuItem(hMenu, IDM_MONOCOLS,
                              mono_colours? MF_CHECKED:MF_UNCHECKED);
                wsprintf(str, szD, mono_colours);
                WriteProfileString(APPNAME, szMonoColours, str);
                SendMessage(hwndRCD, message, wParam, lParam);
                SendMessage(hwndStatus, message, wParam, lParam);
                SendMessage(hwndBar, message, wParam, lParam);

                /* The diffs are still valid, but force a re-display
                 * of bar window and main table.
                 */
                SendMessage(hwndBar, WM_COMMAND, IDM_MONOCOLS, 0);
                InvalidateRect(hwndBar, NULL, TRUE);
                view_changeviewoptions(current_view);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDM_EXIT:
                    if (ghThread!=NULL) {
                        // First idea was to TerminateThread.
                        // This idea didn't work.  Terminating the thread may terminate it inside
                        // a critical section below us (e.g. in heap manager) and this means that
                        // next time we try to use the heap (probably in WriteProfile) we hang!
                        //
                        // Next idea was to let the worker thread keep running and just ExitProcess.
                        // This doesn't work because it fails to clean up temp files which get left
                        // lying around - and some of these may even be read only.
                        //
                        // Next idea is just to do ABORT and let the fellow try again.
                        //
                        // This still isn't good because sometimes it just doesn't want to abort (always
                        // to do with some sort of i/o, usually network not necessarily remote server)
                        //
                        // Fourth idea (not yet implemented as I write this is to keep a separate
                        // list of temp files which should be cleaned up, spawn a separate PROCESS
                        // (n.b. NOT thread) which will clean them, and then ExitProcess.
                        // This means that whenever a temp file is created we keep track of it.
                        // The obvious way is to have a TempFile class (in the C++ sense).
                        //
                        // grep for GetTempFileName to find places where temps are created.

                        bAbort = TRUE;
                        SetStatus(LoadRcString(IDS_ABORT_PENDING));
                        break;
                    }
                    if (!view_isexpanded(current_view)) {
                        /* save the current outline size and position */
                        WINDOWPLACEMENT wp;
                        wp.length = sizeof(wp);
                        if (GetWindowPlacement(hwndClient,&wp)) {
                            WriteProfileInt(APPNAME, szOutlineShowCmd, wp.showCmd);
                            WriteProfileInt(APPNAME, szOutlineMaxX, wp.ptMaxPosition.x);
                            WriteProfileInt(APPNAME, szOutlineMaxY, wp.ptMaxPosition.y);
                            WriteProfileInt(APPNAME, szOutlineNormLeft, wp.rcNormalPosition.left);
                            WriteProfileInt(APPNAME, szOutlineNormTop, wp.rcNormalPosition.top);
                            WriteProfileInt(APPNAME, szOutlineNormRight, wp.rcNormalPosition.right);
                            WriteProfileInt(APPNAME, szOutlineNormBottom, wp.rcNormalPosition.bottom);
                            WriteProfileInt(APPNAME, szOutlineSaved, 1);
                        }
                    } else {
                        /* save the current expanded size and position */
                        WINDOWPLACEMENT wp;
                        wp.length = sizeof(wp);
                        if (GetWindowPlacement(hwndClient,&wp)) {
                            WriteProfileInt(APPNAME, szExpandShowCmd, wp.showCmd);
                            WriteProfileInt(APPNAME, szExpandMaxX, wp.ptMaxPosition.x);
                            WriteProfileInt(APPNAME, szExpandMaxY, wp.ptMaxPosition.y);
                            WriteProfileInt(APPNAME, szExpandNormLeft, wp.rcNormalPosition.left);
                            WriteProfileInt(APPNAME, szExpandNormTop, wp.rcNormalPosition.top);
                            WriteProfileInt(APPNAME, szExpandNormRight, wp.rcNormalPosition.right);
                            WriteProfileInt(APPNAME, szExpandNormBottom, wp.rcNormalPosition.bottom);
                            WriteProfileInt(APPNAME, szExpandedSaved, 1);
                        }
                    }
                    DestroyWindow(hWnd);
                    break;

                case IDM_ABORT:
                    /* abort menu item, or status bar button.
                     * the status bar button text gives the appropriate
                     * action depending on our state - abort, outline
                     * or expand. But the command sent is always
                     * IDM_ABORT. Thus we need to check the state
                     * to see what to do. If we are busy, set the abort
                     * flag. If there is nothing to view,
                     * exit, otherwise switch outline<->expand
                     */
                    if (IsBusy()) {
                        bAbort = TRUE;
                        SetStatus(LoadRcString(IDS_ABORT_PENDING));
                    } else if (DisplayMode == MODE_NULL) {
                        DestroyWindow(hWnd);
                    } else if (DisplayMode == MODE_EXPAND) {
                        ToOutline(hWnd);
                    } else {
                        ToExpand(hWnd);
                    }
                    break;

                case IDM_FILE:
                    /* select two files and compare them */
                    if (SetBusy()) {


                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        /* make a COMPLIST using the files dialog,
                         * and notify the view
                         */
                        if (complist_filedialog(current_view) == NULL) {
                            view_close(current_view);
                        }

                        /* all done! */
                        SetNotBusy();
                    } else {
                        BusyError();
                    }
                    break;

                case IDM_DIR:

                    /* read two directory names, scan them and
                     * compare all the files and subdirs.
                     */
                    if (SetBusy()) {

                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        ghThread = CreateThread(NULL, 0, wd_dirdialog,
                                                (LPVOID) current_view, 0, &threadid);

                        if (ghThread == NULL)
                        {

                            /*
                             * either we are on WIN16, or the
                             * thread call failed. continue
                             * single-threaded.
                             */
                            wd_dirdialog( (LPVOID) current_view);


                        }

                    } else {
                        BusyError();
                    }
                    break;

#ifdef REMOTE_SERVER
                case IDM_REMOTE:

                    /* compare dir against remote dir */
                    if (SetBusy()) {

                        /* close the current view */
                        view_close(current_view);

                        /* make a new empty view */
                        current_view = view_new(hwndRCD);

                        ghThread = CreateThread(NULL, 0, wd_remote,
                                                (LPVOID) current_view, 0, &threadid);

                        if (ghThread == NULL) {

                            /* thread creation failed -
                             * continue single-threaded
                             */

                            wd_remote( (LPVOID) current_view);
                        }
                    } else {
                        BusyError();
                    }

                    break;
#endif
                case IDM_CLOSE:
                    /* close the output list -
                     * discard all results so far
                     */
                    if (!IsBusy()) {
                        view_close(current_view);
                    }
                    break;

                case IDM_PRINT:
                    /* print the current view -
                     * either the outline list of filenames,
                     * or the currently expanded file.
                     */
                    if (!IsBusy()) {
                        DoPrint();
                    } else {
                        BusyError();
                    }
                    break;

                case IDM_TIME:
                    /* show time it took */
                    {       char msg[50];
                        DWORD tim;
                        if (IsBusy()) {
                            BusyError();
                        } else {
                            tim = complist_querytime();
                            wsprintf(msg, LoadRcString(IDS_SECONDS), tim/1000, tim%1000);
                            Trace_Status(msg);
                        }
                    }
                    break;

                case IDM_TRACE:
                    /* enable tracing */
                    bTrace = TRUE;
                    Trace_Status(LoadRcString(IDS_TRACING_ENABLED));
                    break;

                case IDM_TRACEOFF:
                    /* enable tracing */
                    bTrace = FALSE;
                    Trace_Status(LoadRcString(IDS_TRACING_DISABLED));
                    break;

                case IDM_SAVELIST:
                    /* allow user to save list of same/different files
                     * to a text file. dialog box to give filename
                     * and select which types of file to include
                     */
                    if (current_view == NULL) {
                        MessageBox(hWnd,
                                   LoadRcString(IDS_CREATE_DIFF_LIST),
                                   szWinDiff, MB_OK|MB_ICONSTOP);
                        break;
                    }

                    complist_savelist(view_getcomplist(current_view), NULL, outline_include);
                    break;

                case IDM_COPYFILES:
                    /*
                     * copy files that are same/different to a new
                     * root directory. dialog box allows user
                     * to select new root and inclusion options
                     */
                    if (current_view == NULL) {
                        MessageBox(hWnd,
                                   LoadRcString(IDS_CREATE_DIFF_LIST),
                                   szWinDiff, MB_OK|MB_ICONSTOP);
                        break;
                    }

                    if (SetBusy()) {
                        ghThread = CreateThread(NULL, 0, wd_copy,
                                                (LPVOID) current_view, 0, &threadid);
                        if (ghThread == NULL)
                        {

                            /* either we are on WIN16, or
                             * the thread call failed -
                             * either way, continue
                             * single threaded.
                             */

                            wd_copy( (LPVOID) current_view);
                        }

                    } else {
                        BusyError();
                    }

                    break;

                case IDM_ABOUT:
                    ShellAbout( hWnd,
                                (LPTSTR)szWinDiff,
                                LoadRcString(IDS_TOOL_DESCRIPTION),
                                LoadIcon(hInst, szWinDiff)
                              );
                    break;

                case IDM_CONTENTS:
                    /* Help contents */
                    WinHelp(hWnd, "windiff.hlp", HELP_INDEX, 0);
                    break;

                    /* launch an editor on the current item - left, right or
                     * composite view
                     */
                case IDM_EDITLEFT:
                    do_editthread(current_view, CI_LEFT);
                    break;

                case IDM_EDITRIGHT:
                    do_editthread(current_view, CI_RIGHT);
                    break;

                case IDM_EDITCOMP:
                    {
                        COMPITEM item = view_getitem(current_view, selection);
                        FILEDATA fdLeft;
                        FILEDATA fdRight;

                        fdLeft = compitem_getleftfile(item);
                        fdRight = compitem_getrightfile(item);
                        if ((fdLeft && file_IsUnicode(fdLeft)) || (fdRight && file_IsUnicode(fdRight))) {
                            MessageBox(hWnd, LoadRcString(IDS_NOCOMPUNICODE),
                                       szWinDiff, MB_OK);
                        } else {
                            do_editthread(current_view, CI_COMP);
                        }
                    }
                    break;

                    /* allow customisation of the editor command line */
                case IDM_SETEDIT:
                    if (StringInput(editor_cmdline, sizeof(editor_cmdline),
                                    LoadRcString(IDS_EDITOR_COMMAND),
                                    (LPSTR)szWinDiff, editor_cmdline)) {
                        WriteProfileString(APPNAME, szEditor,
                                           editor_cmdline);
                    }
                    break;

                case IDM_SETTABWIDTH:
                    {
                        char sz[32];
                        int n;

LTabWidth_tryagain:
                        wsprintf(sz, "%d", g_tabwidth);
                        if (StringInput(sz, sizeof(sz),
                                        LoadRcString(IDS_TABWIDTH),
                                        (LPSTR)szWinDiff, sz))
                        {
                            n = atoi(sz);
                            if (n <= 0 || n > 100)
                            {
                                MessageBox(hWnd,
                                           LoadRcString(IDS_BAD_TABWIDTH),
                                           szWinDiff, MB_OK);
                                goto LTabWidth_tryagain;
                            }
                            WriteProfileInt(APPNAME, szTabWidth, n);
                            g_tabwidth = n;
                            SendMessage(hwndRCD, TM_SETTABWIDTH, 0, n);
                        }
                    }
                    break;

                case IDM_TABWIDTH4:
                case IDM_TABWIDTH8:
                    g_tabwidth = (GET_WM_COMMAND_ID(wParam, lParam) == IDM_TABWIDTH8) ? 8 : 4;
                    SendMessage(hwndRCD, TM_SETTABWIDTH, 0, g_tabwidth);
                    break;

                case IDM_SETFONT:
                    {
                        CHOOSEFONT cf;
                        LOGFONT lf;
                        char szFace[LF_FACESIZE];

                        lstrcpy(szFace, g_szFontFaceName);

                        memset(&lf, 0, sizeof(lf));
                        lstrcpy(lf.lfFaceName, szFace);
                        lf.lfWeight = g_fFontBold ? FW_BOLD : FW_DONTCARE;
                        lf.lfHeight = g_nFontHeight;
                        lf.lfCharSet = g_bFontCharSet;

                        memset(&cf, 0, sizeof(cf));
                        cf.lStructSize = sizeof(CHOOSEFONT);
                        cf.hwndOwner = hWnd;
                        cf.lpLogFont = &lf;
                        cf.Flags = CF_INITTOLOGFONTSTRUCT|CF_FORCEFONTEXIST|
                                CF_SCREENFONTS|CF_LIMITSIZE;
                        cf.nSizeMin = 8;
                        cf.nSizeMax = 36;
                        cf.lpszStyle = szFace;
                        if (ChooseFont(&cf))
                            {
                            lstrcpy(g_szFontFaceName, lf.lfFaceName);
                            g_fFontBold = (lf.lfWeight == FW_BOLD);
                            g_nFontHeight = lf.lfHeight;
                            g_bFontCharSet = lf.lfCharSet;

                            WriteProfileString(APPNAME, szFontFaceName, g_szFontFaceName);
                            WriteProfileInt(APPNAME, szFontHeight, g_nFontHeight);
                            WriteProfileInt(APPNAME, szFontBold, g_fFontBold);
                            WriteProfileInt(APPNAME, szFontCharSet, g_bFontCharSet);

                            GetFontPref();

                            view_changeviewoptions(current_view);
                            }
                    }
                    break;



                case IDM_LNRS:
                case IDM_RNRS:
                case IDM_NONRS:

                    /* option selects whether the line nrs displayed
                     * in expand mode are the line nrs in the left
                     * file, the right file or none
                     */

                    CheckMenuItem(GetMenu(hWnd),
                                  line_numbers, MF_UNCHECKED);
                    line_numbers = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckMenuItem(GetMenu(hWnd), line_numbers, MF_CHECKED);
                    wsprintf(str, szD, line_numbers);
                    WriteProfileString(APPNAME, szLineNumbers, str);

                    /* change the display to show the line nr style
                     * chosen
                     */

                    view_changeviewoptions(current_view);
                    break;

                /*
                 * options selecting which lines to include in the
                 * expand listing, based on their state
                 */
                case IDM_EXPAND_INCSAME:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SAME;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSAME,
                              (expand_include & INCLUDE_SAME) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_LEFTONLY;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCLEFT,
                              (expand_include & INCLUDE_LEFTONLY) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_RIGHTONLY;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCRIGHT,
                              (expand_include & INCLUDE_RIGHTONLY) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCMOVEDLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_MOVEDLEFT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCMOVEDLEFT,
                              (expand_include & INCLUDE_MOVEDLEFT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCMOVEDRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_MOVEDRIGHT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCMOVEDRIGHT,
                              (expand_include & INCLUDE_MOVEDRIGHT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCSIMILARLEFT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SIMILARLEFT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSIMILARLEFT,
                              (expand_include & INCLUDE_SIMILARLEFT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                case IDM_EXPAND_INCSIMILARRIGHT:
                        /* toggle flag in expand_include options */
                        expand_include ^= INCLUDE_SIMILARRIGHT;

                        /* check/uncheck as necessary */
                        CheckMenuItem(hMenu, IDM_EXPAND_INCSIMILARRIGHT,
                              (expand_include & INCLUDE_SIMILARRIGHT) ?
                                        MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, expand_include);
                        WriteProfileString(APPNAME, szLineInclude, str);
                        view_changeviewoptions(current_view);
                        break;

                    /*
                     * options selecting which files to include in the
                     * outline listing, based on their state
                     */
                case IDM_OUTLINE_INCLEFT:


                    /* toggle flag in outline_include options */
                    outline_include ^= INCLUDE_LEFTONLY;

                    /* check/uncheck as necessary */
                    CheckMenuItem(hMenu, IDM_OUTLINE_INCLEFT,
                                  (outline_include & INCLUDE_LEFTONLY) ?
                                  MF_CHECKED:MF_UNCHECKED);

                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;

                case IDM_OUTLINE_INCRIGHT:


                    outline_include ^= INCLUDE_RIGHTONLY;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCRIGHT,
                                  (outline_include & INCLUDE_RIGHTONLY) ?
                                  MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);

                    break;

                case IDM_OUTLINE_INCSAME:


                    outline_include ^= INCLUDE_SAME;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCSAME,
                                  (outline_include & INCLUDE_SAME) ?
                                  MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;


                case IDM_OUTLINE_INCDIFFER:



                    outline_include ^= INCLUDE_DIFFER;

                    CheckMenuItem(hMenu, IDM_OUTLINE_INCDIFFER,
                                  (outline_include & INCLUDE_DIFFER) ?
                                  MF_CHECKED:MF_UNCHECKED);

                    wsprintf(str, szD, outline_include);
                    WriteProfileString(APPNAME, szFileInclude, str);
                    view_changeviewoptions(current_view);


                    break;

                case IDM_UPDATE:
                    OnUpdate( (COMPITEM) lParam);
                    break;


                case IDM_RESCAN:
                    RescanFile(hWnd);

                    /* do we need to force any repaints? */
                    // - no, as RescanFile sends a IDM_UPDATE
                    break;


                case IDM_LONLY:
                case IDM_RONLY:
                case IDM_BOTHFILES:
                    /* option selects whether the expanded file
                     * show is the combined file, or just one
                     * or other of the input files.
                     *
                     * if we are not in expand mode, this also
                     * causes us to expand the selection
                     */


                    CheckMenuItem(GetMenu(hWnd), expand_mode, MF_UNCHECKED);
                    expand_mode = GET_WM_COMMAND_ID(wParam, lParam);
                    CheckMenuItem(GetMenu(hWnd), expand_mode, MF_CHECKED);

                    /* change the current view to show only the lines
                     * of the selected type.
                     */
                    if (DisplayMode == MODE_OUTLINE) {
                        ToExpand(hWnd);
                    } else {
                        view_changeviewoptions(current_view);
                    }


                    break;


                case IDM_IGNBLANKS:

                    /* if selected, ignore all spaces and tabs on
                     * comparison - expand view only: outline view
                     * will still show that 'text files differ'
                     */

                    ignore_blanks = !ignore_blanks;
                    CheckMenuItem(hMenu, IDM_IGNBLANKS,
                                  ignore_blanks? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, ignore_blanks);
                    WriteProfileString(APPNAME, szBlanks, str);

                    /* invalidate all diffs since we have
                     * changed diff options, and re-do and display the
                     * current diff if we are in expand mode.
                     */
                    view_changediffoptions(current_view);

                    /* force repaint of bar window */
                    InvalidateRect(hwndBar, NULL, TRUE);

                    break;

                case IDM_SHOWWHITESPACE:

                        /* if selected, display all spaces and tabs in
                           the expanded text view */
                        show_whitespace = !show_whitespace;
                        CheckMenuItem(hMenu, IDM_SHOWWHITESPACE,
                                show_whitespace ? MF_CHECKED:MF_UNCHECKED);
                        wsprintf(str, szD, show_whitespace);
                        WriteProfileString(APPNAME, szShowWhitespace, str);

                        // change the current view to show only the lines
                        // of the selected type.
                        if (DisplayMode == MODE_EXPAND) {
                                view_changeviewoptions(current_view);
                        }

                        break;

                case IDM_ALG2:

                    /* if selected, do algorithm2 which does not accept
                     * unsafe matches.
                     */

                    Algorithm2 = !Algorithm2;
                    CheckMenuItem(hMenu, IDM_ALG2,
                                  Algorithm2? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, Algorithm2);
                    WriteProfileString(APPNAME, szAlgorithm2, str);

                    /* invalidate all diffs since we have
                     * changed diff options, and re-do and display the
                     * current diff if we are in expand mode.
                     */
                    view_changediffoptions(current_view);

                    /* force repaint of bar window */
                    InvalidateRect(hwndBar, NULL, TRUE);

                    break;

                case IDM_MONOCOLS:

                    /* Use monochrome colours - toggle */

                    mono_colours = !mono_colours;
                    CheckMenuItem(hMenu, IDM_MONOCOLS,
                                  mono_colours? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, mono_colours);
                    WriteProfileString(APPNAME, szMonoColours, str);
                    if (mono_colours)
                        SetMonoColours();
                    else
                        SetColours();

                    /* The diffs are still valid, but force a re-display
                     * of bar window and main table.
                     */
                    SendMessage(hwndBar, WM_COMMAND, IDM_MONOCOLS, 0);
                    InvalidateRect(hwndBar, NULL, TRUE);
                    view_changeviewoptions(current_view);

                    break;

                case IDM_PICTURE:
                    /* do we show the bar picture in expand mode ? */
                    picture_mode = !picture_mode;
                    CheckMenuItem(hMenu, IDM_PICTURE,
                                  picture_mode? MF_CHECKED:MF_UNCHECKED);
                    wsprintf(str, szD, picture_mode);
                    WriteProfileString(APPNAME, szPicture, str);
                    DoResize(hWnd);
                    break;

                case IDM_HIDEMARK:
                    // toggle state of marked files hidden or not
                    hide_markedfiles = !hide_markedfiles;
                    CheckMenuItem(hMenu, IDM_HIDEMARK,
                                  hide_markedfiles? MF_CHECKED : MF_UNCHECKED);
                    wsprintf(str, szD, hide_markedfiles);
                    WriteProfileString(APPNAME, szHideMark, str);

                    // rebuild view with new global option
                    // - note that marks only affect outline views
                    if (!view_isexpanded(current_view)) {
                        view_changeviewoptions(current_view);
                    }
                    break;

                case IDM_FIND:
                  {
                  int nRet = IDCANCEL;
                  //DLGPROC lpProc = (DLGPROC) MakeProcInstance((WINPROCTYPE) FindDlgProc, hInst);
                  //if (lpProc)
                    {
                    char *pszFind = NULL;
                    windiff_UI(TRUE);
                    //nRet = (BOOL) DialogBoxParam(hInst, (LPCTSTR) IDD_FIND, hwndClient, lpProc, 0L);
                    nRet = (BOOL) DialogBoxParam(hInst, (LPCTSTR) IDD_FIND, hwndClient, FindDlgProc, 0L);
                    windiff_UI(FALSE);
                    //FreeProcInstance(lpProc);
                    }
                  }
                  break;

                case IDM_FINDNEXT:
                  {
                  const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
                  FindString(hWnd, iCol, NULL, 1, 0);
                  break;
                  }

                case IDM_FINDPREV:
                  {
                  const LONG iCol = (view_isexpanded(current_view)) ? 2 : 1;
                  FindString(hWnd, iCol, NULL, -1, 0);
                  break;
                  }

                case IDM_GOTOLINE:
                  {
                  if (!view_getrowcount(current_view))
                    {
                    MessageBox(hWnd, LoadRcString(IDS_GOTOLINE_NOLINES), szWinDiff, MB_OK|MB_ICONSTOP|MB_TASKMODAL);
                    }
                  else
                    {
                    //DLGPROC lpProc = (DLGPROC) MakeProcInstance((WINPROCTYPE)GoToLineDlgProc, hInst);
                    //if (lpProc)
                      {
                      windiff_UI(TRUE);
                      //DialogBoxParam(hInst, (LPCTSTR) IDD_GOTOLINE, hwndClient, lpProc, 0L);
                      DialogBoxParam(hInst, (LPCTSTR) IDD_GOTOLINE, hwndClient, GoToLineDlgProc, 0L);
                      windiff_UI(FALSE);
                      //FreeProcInstance(lpProc);
                      }
                    }
                  }
                  break;

                case IDM_EDITCOPY:
                    {
                        unsigned long cb = 0;
                        LPCSTR pszText = NULL;
                        long iRow = 0;
                        const BOOL fOutline = !view_isexpanded(current_view);

                        /* first count total data size */
                        for (iRow = 0; iRow < selection_nrows; iRow++) {
                            if (fOutline) {
                                pszText = view_gettext(current_view, selection + iRow, 1);
                                if (!pszText)
                                    break;
                                cb += (lstrlen(pszText) + 3) * sizeof(char);
                            }

                            pszText = view_gettext(current_view, selection + iRow, 2);
                            if (!pszText)
                                break;
                            cb += (lstrlen(pszText)) * sizeof(char);
                        }

                        if (cb && OpenClipboard(NULL)) {
                            /* space for trailing nul char */
                            cb++;

                            /* copy data to clipboard */
                            if (EmptyClipboard()) {
                                HGLOBAL hData = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cb);

                                if (hData) {
                                    void *pv = GlobalLock(hData);
                                    if (!pv) {
                                        GlobalFree(hData);
                                    }
                                    else {
                                        LPSTR pszBuf = (LPSTR) pv;
                                        memset(pv, 0, cb);

                                        for (iRow = 0; iRow < selection_nrows; iRow++) {
                                            if (fOutline) {
                                                pszText = view_gettext(current_view, selection + iRow, 1);
                                                if (!pszText)
                                                    break;

                                                lstrcpy(pszBuf, pszText);
                                                pszBuf += lstrlen(pszBuf);
                                                *(pszBuf++) = '\t';
                                                *pszBuf = 0;
                                            }

                                            pszText = view_gettext(current_view, selection + iRow, 2);
                                            if (!pszText)
                                                break;

                                            lstrcpy(pszBuf, pszText);
                                            pszBuf += lstrlen(pszBuf);

                                            if (fOutline) {
                                                *(pszBuf++) = '\r';
                                                *(pszBuf++) = '\n';
                                                *pszBuf = 0;
                                            }
                                        }

                                        GlobalUnlock(hData);
                                        SetClipboardData(CF_TEXT, hData);
                                    }
                                }
                            }
                            CloseClipboard();
                        }
                    }
                    break;

                case IDM_MARK:
                    {
                        BOOL bChanged = FALSE;
                        int i;

                        // toggle the mark on the current selection
                        // note that the selection could be multiple rows
                        for (i = 0; i < selection_nrows; i++) {

                            if (view_setmarkstate(current_view, selection + i,
                                                  !view_getmarkstate(current_view, selection + i))) {

                                bChanged = TRUE;
                            }
                        }

                        if (bChanged) {
                            // yes the mark state was changed - need
                            // to rebuild the view.
                            if (!view_isexpanded(current_view)) {
                                view_changeviewoptions(current_view);
                            }
                        }
                        break;
                    }

                case IDM_TOGGLEMARK:
                    // toggle the state of all files: unmark all
                    // marked files and vice versa
                    complist_togglemark(view_getcomplist(current_view));

                    // rebuild view
                    if (!view_isexpanded(current_view)) {
                        view_changeviewoptions(current_view);
                    }
                    break;

                case IDM_MARKPATTERN:
                    // dialog to query the pattern, then set a mark on
                    // all compitems whose title matches that pattern
                    // returns TRUE if anything was changed
                    if (complist_markpattern(view_getcomplist(current_view))) {

                        // rebuild view
                        if (!view_isexpanded(current_view)) {
                            view_changeviewoptions(current_view);
                        }
                    }
                    break;

                case IDM_EXPAND:

                    /* show the expanded view of the
                     * selected file
                     */
                    if (current_view != NULL) {
                        ToExpand(hWnd);
                    }

                    break;

                case IDM_OUTLINE:
                    /* return to the outline view (list of filenames) */
                    ToOutline(hWnd);

                    break;

                case IDM_FCHANGE:
                    /* find the next line in the current view
                     * that is not the same in both files -
                     * in outline view, finds the next filename that
                     * is not identical
                     */
                    FindNextChange();
                    break;

                case IDM_FPCHANGE:
                    /* same as IDM_FCHANGE, but going backwards from
                     * current position
                     */
                    FindPrevChange();
                    break;

                case IDM_FCHANGE_LAURIE:
                    /* same as IDM_FCHANGE, but tries to keep cursor on same
                     * line.
                     */
                    _FindNextChange(TRUE, FALSE);
                    break;

                case IDM_FPCHANGE_LAURIE:
                    /* same as IDM_FPCHANGE, but tries to keep cursor on same
                     * line.
                     */
                    _FindPrevChange(TRUE, FALSE);
                    break;

                    // given a line that has been moved, jump to the
                    // other representation of the same line.
                    // this used to be available just through double-click
                    // but now is also available from a context menu
                case IDM_TOMOVED:
                    ToMoved(hWnd, TRUE);
                    break;
            }
            break;

        case WM_SIZE:
            DoResize(hWnd);
            break;

        case WM_SETFOCUS:
            /* set the focus on the table class so it can process
             * page-up /pagedown keys etc.
             */
            SetFocus(hwndRCD);
            break;

        case WM_KEYDOWN:
            /* although the table window has the focus, he passes
             * back to us any keys he doesn't understand
             * We handle escape here to mean 'return to outline view'
             */
            if (wParam == VK_ESCAPE) {
                ToOutline(hWnd);
            } else if (wParam == VK_APPS) {
                // Handle the context menu keyboard key
                POINT posCursor;
                GetCursorPos(&posCursor);
                ScreenToClient(hwndRCD, &posCursor);
                OnRightClick(hWnd, posCursor.x, posCursor.y);
            }
            break;

        case WM_RBUTTONDOWN:
            /*
             * the table window handles this by performing the
             * selection and then passing the message to us, allowing
             * us to put up a context menu.
             */
            OnRightClick(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_CLOSE:
            /* experiment: DO close anyway */
            SendMessage(hWnd, WM_COMMAND, IDM_EXIT, 0);   /* brutal */
            return TRUE;

            /* don't allow close when busy - process this message in
             * order to ensure this
             */
            break;

        case WM_DESTROY:

            DeleteTools();
            WinHelp(hWnd, "windiff.hlp", HELP_QUIT, 0);
            PostQuitMessage(0);
            break;

        case TM_CURRENTVIEW:
            /* allow other people such as the bar window to query the
             * current view
             */
            return((INT_PTR) current_view);

#ifdef LATER
#ifdef WM_MOUSEWHEEL
        case WM_MOUSEWHEEL:
            if (LOWORD(wParam) & MK_MBUTTON) {
                if ((short)HIWORD(wParam) < 0) {
                    // The next occurence
                    _FindNextChange(FALSE, TRUE);
                }
                else {
                    _FindPrevChange(FALSE, TRUE);
                }
            }
            break;
#endif
#endif

        case WM_QUERYENDSESSION:
            if (IsBusy())
                return FALSE;
            return TRUE;

        case WM_ENDSESSION:
            SendMessage(hWnd, WM_CLOSE, 0, 0);
            break;

        default:
            /* handle registered table messages */
            if (message == table_msgcode) {
                ret = TableServer(hWnd, wParam, lParam);
                return(ret);
            }
            return(DefWindowProc(hWnd, message, wParam, lParam));
    }
    return(0);
}

/***************************************************************************
 * Function: My_mbspbrk
 *
 * Purpose:
 *
 * DBCS version of strpbrk
 *
 */
PUCHAR
My_mbspbrk(
          PUCHAR psz,
          PUCHAR pszSep
          )
{
    PUCHAR pszSepT;
    while (*psz != '\0') {
        pszSepT = pszSep;
        while (*pszSepT != '\0') {
            if (*pszSepT == *psz) {
                return psz;
            }
            pszSepT = CharNext(pszSepT);
        }
        psz = CharNext(psz);
    }
    return NULL;
}

/***************************************************************************
 * Function: My_mbsstr
 *
 * Purpose:
 *
 * DBCS version of strstr
 *
 */
PUCHAR
My_mbsstr(
         PUCHAR str1,
         PUCHAR str2,
         PUCHAR *pstrEnd
         )
{
  PUCHAR cp = (PUCHAR) str1;
  PUCHAR s1, s2;

  if (!*str2)
    return ((PUCHAR) str1);

  while (*cp)
    {
    s1 = cp;
    s2 = (PUCHAR) str2;

    while (*s1 && *s2)
      {
      if (*s1 - *s2)
        break;

      if (IsDBCSLeadByte(*s1) && (++(*s1) - ++(*s2)))
        break;

      s1++;
      s2++;
      }

    if (!*s2)
      {
      if (pstrEnd)
        *pstrEnd = s1;
      return cp;
      }

    cp = CharNext(cp);
    }

  return NULL;
}

/***************************************************************************
 * Function: My_mbsistr
 *
 * Purpose:
 *
 * DBCS version of case-independent strstr
 *
 */
PUCHAR
My_mbsistr(
          PUCHAR str1,
          PUCHAR str2,
          PUCHAR *pstrEnd
          )
{
  PUCHAR cp = (PUCHAR) str1;
  PUCHAR s1, s2;

  if (!*str2)
    return ((PUCHAR) str1);

  while (*cp)
    {
    s1 = cp;
    s2 = (PUCHAR) str2;

    while (*s1 && *s2)
      {
      if (IsDBCSLeadByte(*s1))
        {
        if ((*s1 - *s2) || (++(*s1) - ++(*s2)))
          break;
        }
      else if (toupper(*s1) - toupper(*s2))
        {
        break;
        }

      s1++;
      s2++;
      }

    if (!*s2)
      {
      if (pstrEnd)
        *pstrEnd = s1;
      return cp;
      }

    cp = CharNext(cp);
    }

  return NULL;
}

/***************************************************************************
 * Function: My_mbschr
 *
 * Purpose:
 *
 * DBCS version of strchr
 *
 */
LPSTR
My_mbschr(
          LPCSTR psz,
          unsigned short uiSep
          )
{
    while (*psz != '\0' && *psz != uiSep) {
        psz = CharNext(psz);
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncpy
 *
 * Purpose:
 *
 * DBCS version of strncpy
 *
 */
LPSTR
My_mbsncpy(
           LPSTR psz1,
           LPCSTR psz2,
           size_t nLen
           )
{
    LPSTR pszSv = psz1;
    int Length = (int)nLen;

    while (0 < Length) {
        if (*psz2 == '\0') {
            *psz1++ = '\0';
            Length--;
        } else if (IsDBCSLeadByte(*psz2)) {
            if (Length == 1) {
                *psz1 = '\0';
            } else {
                *psz1++ = *psz2++;
                *psz1++ = *psz2++;
            }
            Length -= 2;
        } else {
            *psz1++ = *psz2++;
            Length--;
        }
    }
    return pszSv;
}

/***************************************************************************
 * Function: My_mbsrchr
 *
 * Purpose:
 *
 * DBCS version of strrchr
 *
 */
LPSTR
My_mbsrchr(
           LPCSTR psz,
           unsigned short uiSep
           )
{
    unsigned const char *pszHead;

    pszHead = psz;

    while (*psz != '\0') {
        psz++;
    }
    if (uiSep == '\0') {
        return (LPSTR)psz;
    }

    while (psz > pszHead) {
        psz = CharPrev(pszHead, psz);
        if (*psz == uiSep) {
            break;
        }
    }
    return (LPSTR)(*psz == uiSep ? psz : NULL);
}

/***************************************************************************
 * Function: My_mbsncmp
 *
 * Purpose:
 *
 * DBCS version of strncmp
 * If 'nLen' splits a DBC, this function compares the DBC's 2nd byte also.
 *
 */
int
My_mbsncmp(
           LPCSTR psz1,
           LPCSTR psz2,
           size_t nLen
           )
{
    int Length = (int)nLen;

    while (0 < Length) {
        if ('\0' == *psz1 || '\0' == *psz2) {
            return *psz1 - *psz2;
        }
        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) {
            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) {
                return *psz1 - *psz2;
            }
            psz1 += 2;
            psz2 += 2;
            Length -= 2;
        } else {
            if (*psz1 != *psz2) {
                return *psz1 - *psz2;
            }
            psz1++;
            psz2++;
            Length--;
        }
    }
    return 0;
}

/***************************************************************************
 * Function: My_mbsnicmp
 *
 * Purpose:
 *
 * DBCS version of strncmp
 * If 'nLen' splits a DBC, this function compares the DBC's 2nd byte also.
 *
 */
int
My_mbsnicmp(
           PUCHAR psz1,
           PUCHAR psz2,
           size_t nLen
           )
{
    int Length = (int)nLen;

    while (0 < Length) {
        if ('\0' == *psz1 || '\0' == *psz2) {
            return *psz1 - *psz2;
        }
        if (IsDBCSLeadByte(*psz1) || IsDBCSLeadByte(*psz2)) {
            if (*psz1 != *psz2 || *(psz1+1) != *(psz2+1)) {
                return *psz1 - *psz2;
            }
            psz1 += 2;
            psz2 += 2;
            Length -= 2;
        } else {
            if (toupper(*psz1) != toupper(*psz2)) {
                return *psz1 - *psz2;
            }
            psz1++;
            psz2++;
            Length--;
        }
    }
    return 0;
}

/***************************************************************************
 * Function: LoadRcString
 *
 * Purpose: Loads a resource string from string table and returns a pointer
 *          to the string.
 *
 * Parameters: wID - resource string id
 *
 */

LPTSTR
APIENTRY
LoadRcString(
             UINT wID
             )
{
    static TCHAR szBuf[512];

    LoadString((HANDLE)GetModuleHandle(NULL),wID,szBuf,sizeof(szBuf));
    return szBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\windiff\windiff\windiff.h ===
/*

 * windiff - file and directory comparisons
 *              FOR INTRODUCTORY NOTES ON IMPLEMENTATION SEE WINDIFF.C
 *
 *      windiff.h - user-interface definitions, and application-wide global
 *                  declarations.
 */

/* application-wide variables -------------------------------------*/

/* this is the section name in the win.ini file to which we
 * write profile info
 */
#define APPNAME szWinDiff
extern const CHAR szWinDiff[];

/* Map profile calls to the registry
 */
#include "profile.h"

/* a gmem_init() heap shared by the app. call gmem_get to alloc. */
extern HANDLE hHeap;

/* the instance handle for this app. needed by anyone who uses resources
 * such as dialogs
 */
extern HINSTANCE hInst;

extern HWND hwndClient;
extern HWND hwndRCD;

/* global option flags-------------------------------------------  */

/* which files do we show in outline mode ? all, changed... */
extern int outline_include;

/* which files do we show in expand mode ? all, different, moved... */
extern int expand_include;

/* outline_include is an OR of the following */
#define INCLUDE_SAME            0x01
#define INCLUDE_DIFFER          0x02
#define INCLUDE_LEFTONLY        0x04
#define INCLUDE_RIGHTONLY       0x08

/* expand_include is an OR of the previous (except for INCLUDE_DIFFER)
   AND the following */
#define INCLUDE_MOVEDLEFT       0x10
#define INCLUDE_MOVEDRIGHT      0x20
#define INCLUDE_SIMILARLEFT     0x40
#define INCLUDE_SIMILARRIGHT    0x80

/* bitwise OR of all flags */
#define INCLUDE_ALL             0xFF

/* do we ignore blanks during the line-by-line diff ? */
extern BOOL ignore_blanks;

/* do we show whitespace characters ? */
extern BOOL show_whitespace;

/* which line numbers do we show - left original, right original or none ?*/
extern int line_numbers;

/* what lines do we show in expand mode - all, left only, right only ? */
extern int expand_mode;

/* TRUE if marked compitems are to be excluded from the view */
extern BOOL hide_markedfiles;


// tab expansion width in characters
extern int g_tabwidth;

extern BOOL TrackLeftOnly;
extern BOOL TrackRightOnly;
extern BOOL TrackDifferent;
extern BOOL TrackSame;
extern BOOL TrackReadonly;
extern BOOL TrackSlmFiles;

/*--- colour scheme ----------------------------------------------  */

/* outline */
extern DWORD rgb_outlinehi;

/* expand view */
extern DWORD rgb_leftfore;
extern DWORD rgb_leftback;
extern DWORD rgb_rightfore;
extern DWORD rgb_rightback;
extern DWORD rgb_mleftfore;
extern DWORD rgb_mleftback;
extern DWORD rgb_mrightfore;
extern DWORD rgb_mrightback;

/* bar window */
extern DWORD rgb_barleft;
extern DWORD rgb_barright;
extern DWORD rgb_barcurrent;

extern BOOL bJapan;  /* TRUE if primary language is Japanese */
extern BOOL bDBCS;   /* TRUE if primary language is Japanese/Korean/Chinese */

/* -- display layout constants---------------------------------------*/

/* percentage of width of window taken by bar display (when visible) */
#define BAR_WIN_WIDTH   10

/* following are horizontal positions within the bar window, expressed
 * in percent of the width of the bar window
 */
#define L_POS_START     10      /* start of left position marker */
#define L_POS_WIDTH     5       /* width of left position marker */
#define R_POS_START     80      /* start of right position marker */
#define R_POS_WIDTH     5       /* width of right position marker */

#define L_UNMATCH_START 30      /* start of left bar for unmatched section */
#define L_UNMATCH_WIDTH 10      /* width of above */
#define R_UNMATCH_START 60      /* start of right bar for unmatch section */
#define R_UNMATCH_WIDTH 10      /* width of right unmatched section marker */
#define L_MATCH_START   30      /* start of left bar for matched section */
#define L_MATCH_WIDTH   10      /* width of left bar for matched section */
#define R_MATCH_START   60      /* start of right bar for matched section */
#define R_MATCH_WIDTH   10      /* width of right bar for matched section */




/* windiff.c functions */

#ifdef trace
void APIENTRY Trace_File(LPSTR msg);     /* dump msg into Windiff.trc */
#endif


/* if you are about to put up a dialog box or in fact process input in any way
   on any thread other than the main thread - or if you MIGHT be on a thread other
   than the main thread, then you must call this function with TRUE before doing
   it and with FALSE immediately afterwards.  Otherwise you will get one of a
   number of flavours of not-very-responsiveness
*/
void windiff_UI(BOOL bAttach);

/* peek the message queue. return TRUE if an abort request is pending */
BOOL Poll(void);                /* true if abort pending */

/* set the text for the 'names' field (central box) on the status bar */
void SetNames(LPSTR names);

/* set the status field (left field) on the status bar */
void SetStatus(LPSTR state);

/* dlg procs */
INT_PTR CALLBACK FindDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK GoToLineDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/* in bar.c */
BOOL InitBarClass(HINSTANCE hInstance);
void BarDrawPosition(HWND hwndBar, HDC hdcIn, BOOL bErase);

/*-- private messages -- */

/* send this to the main window. return value is the VIEW handle */
#define TM_CURRENTVIEW  WM_USER


/* --- synchronisation ----------------------------------------- */

/*
 * the WIN32 version spawns worker threads to do time-consuming actions.
 * this causes a possible conflict with the UI thread when accessing the
 * BUSY flag.
 *
 * to protect against this we have a critical section. The UI thread
 * will get this before checking/changing the Busy flag,
 * The worker thread will get this before Busy flag* changes.
 *
 */

CRITICAL_SECTION CSWindiff;
/* IF EVER YOU MIGHT ACQUIRE BOTH CSWindiff AND CSView, THEN DO SO IN
   THE ORDER:  FIRST GET CSWindiff  THEN GET CSView
   else risk deadlock when an idm_exit happens!
*/
#define WDEnter()       EnterCriticalSection(&CSWindiff);
#define WDLeave()       LeaveCriticalSection(&CSWindiff);

BOOL __BERR;

#define TRACE_ERROR(msg,flag) ( windiff_UI(TRUE),                      \
                                __BERR = Trace_Error(hwndClient, msg, flag),       \
                                windiff_UI(FALSE),                     \
                                __BERR                                 \
                              )

__inline BOOL IsDepotPath(LPCSTR path)
{
    return path[0] == '/' && path[1] == '/';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\dbg.h ===
/*
 * Debugging utilities header
 */
#if DBG

extern char szAsrtFmt[];
extern unsigned long BreakFlags;
extern unsigned long TraceFlags;

ULONG __cdecl DbgPrint( LPSTR Format, ...);
VOID DbgAssert(LPSTR file, int line);
VOID DbgTrace(DWORD tf, LPSTR lpstr);
VOID DbgBreak(DWORD bf, LPSTR file, int line);
VOID DbgPrint1(DWORD tf, LPSTR fmt, LPSTR p1);
VOID DbgEnter(LPSTR funName);
VOID DbgLeave(LPSTR funName);
VOID DbgTraceMessage(LPSTR funName, LPSTR msgName);
VOID DbgTraceDefMessage(LPSTR funName, WORD msgId);

// BreakFlags flags

#define BF_WM_CREATE            0x02000000
#define BF_DEFMSGTRACE          0x04000000
#define BF_MSGTRACE             0x08000000

#define BF_PARMTRACE            0x20000000
#define BF_PROCTRACE            0x40000000
#define BF_START                0x80000000

#undef ASSERT
#define ASSERT(fOk)             ((!(fOk)) ? DbgAssert(__FILE__, __LINE__) : ((void)0))
#define FBREAK(bf)              DbgBreak(bf, __FILE__, __LINE__)
#define TRACE(tf, lpstr)        DbgTrace(tf, lpstr)
#define PRINT(tf, fmt, p1)      DbgPrint1(tf, fmt, (LPSTR)(p1))
#define MSG(funName, msgName)   DbgTraceMessage(funName, msgName)
#define DEFMSG(funName, wMsgId) DbgTraceDefMessage(funName, wMsgId)

#define ENTER(funName)          DbgEnter(funName)
#define LEAVE(funName)          DbgLeave(funName)


#else // !DBG

#ifndef ASSERT
#define ASSERT(fOk)             ((void)0)
#endif

#define FBREAK(bf)
#define TRACE(tf, lpstr)
#define PRINT(tf, fmt, p1)
#define MSG(funName, msgName)
#define DEFMSG(funName, wMsgId)
#define ENTER(funName)
#define LEAVE(funName)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\dbg.c ===
/*
 * Debugging utilities
 */

#if DBG

    #include <winfile.h>

char szAsrtFmt[] = "Assertion Failure in %s at %d";
unsigned long TraceFlags = 0
                           // | BF_START
                           // | BF_PROCTRACE
                           // | BF_PARMTRACE
                           // | BF_MSGTRACE
                           // | BF_DEFMSGTRACE
                           ;     // set these to print on TRACEs

unsigned long BreakFlags = 0
                           // | BF_START
                           ;     // set these to break on TRACEs

VOID
DbgAssert(
         LPSTR file,
         int line
         )
{
    DbgPrint(szAsrtFmt, file, line);
    DebugBreak();
}


VOID
DbgTrace(
        DWORD tf,
        LPSTR lpstr
        )
{
    if (tf & TraceFlags) {
        DbgPrint("%s\n", lpstr);
        if (tf & BreakFlags) {
            DebugBreak();
        }
    }
}


VOID
DbgBreak(
        DWORD bf,
        LPSTR file,
        int line
        )

{
    if (bf & BreakFlags) {
        DbgPrint("BREAK at %s:%d\n", file, line);
        DebugBreak();
    }
}


VOID
DbgPrint1(
         DWORD tf,
         LPSTR fmt,
         LPSTR p1
         )
{
    if (tf & TraceFlags) {
        DbgPrint(fmt, p1);
        DbgPrint("\n");
    }
    if (tf & BreakFlags) {
        DebugBreak();
    }
}


VOID
DbgEnter(
        LPSTR funName
        )
{
    DbgPrint1(BF_PROCTRACE, "> %s", funName);
}

VOID
DbgLeave(
        LPSTR funName
        )
{
    DbgPrint1(BF_PROCTRACE, " <%s", funName);
}


VOID
DbgTraceMessage(
               LPSTR funName,
               LPSTR msgName
               )
{
    if (BF_MSGTRACE & TraceFlags) {
        DbgPrint("MSG: %s - %s\n", funName, msgName);
    }
    if (BF_MSGTRACE & BreakFlags) {
        DebugBreak();
    }
}

VOID
DbgTraceDefMessage(
                  LPSTR funName,
                  WORD msgId
                  )
{
    if (BF_DEFMSGTRACE & TraceFlags) {
        DbgPrint("MSG: %s - default(0x%x)\n", funName, msgId);
    }
    if (BF_DEFMSGTRACE & BreakFlags) {
        DebugBreak();
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\fontsel.h ===
typedef struct _MYCHOOSEFONT {
	HWND		hwndOwner;
	HDC		hdc;
	LPLOGFONT 	lpLogFont;
	DWORD		Flags;
	FARPROC		lpfnHook;
} MYCHOOSEFONT, FAR *LPMYCHOOSEFONT;

#define MYCF_SCREENFONTS	0x00000001L
#define MYCF_PRINTERFONTS	0x00000002L
#define MYCF_BOTH		(MYCF_MYCF_SCREENFONTS | MYCF_PRINTERFONTS)

BOOL  APIENTRY MyChooseFont(LPMYCHOOSEFONT lpcf);

//---------------------- private ----------------------------

#define IDD_FACE	100
#define IDD_PTSIZE	101
#define IDD_WEIGHT	102
#define IDD_TREATMENT	103
#define IDD_BOLD	104
#define IDD_ITALIC	105
#define IDD_LOWERCASE	106
#define IDD_HELP	254

#define FONTDLG			145
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\fontsel.c ===
#include "windows.h"
#include <port1632.h>
#include "fontsel.h"

#define TA_LOWERCASE	0x01	// taken from winfile.h!
#define TA_BOLD		0x02
#define TA_ITALIC	0x04

extern HANDLE hAppInstance;
extern BOOL wTextAttribs;
extern HWND hwndFrame;
extern WORD wHelpMessage;

typedef struct {
    HWND hwndLB;
    HDC hdc;
} ENUM_FONT_DATA, *LPENUM_FONT_DATA;


INT APIENTRY FontSizeEnumProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD nFontType, LPARAM lpData);
INT APIENTRY FontFaceEnumProc(const LOGFONT *lplf, const TEXTMETRIC *lptm, DWORD nFontType, LPARAM lpData);
INT_PTR APIENTRY FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);

INT  APIENTRY GetHeightFromPointsString(LPSTR sz);
VOID  APIENTRY WFHelp(HWND hwnd);


BOOL
APIENTRY
MyChooseFont(
            LPMYCHOOSEFONT lpcf
            )
{
    INT_PTR ret;

    ret = DialogBoxParam(hAppInstance, MAKEINTRESOURCE(FONTDLG), lpcf->hwndOwner, FontDlgProc, (LPARAM)lpcf);

    return ret == IDOK;
}

INT
APIENTRY
FontFaceEnumProc(
                const LOGFONT *lplf,
                const TEXTMETRIC *lptm,
                DWORD nFontType,
                LPARAM lParam
                )
{
    LPENUM_FONT_DATA lpData = (LPENUM_FONT_DATA) lParam;

    if (lplf->lfCharSet == ANSI_CHARSET) {
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)lplf->lfFaceName);
    }
    return TRUE;
}

LPSTR
NEAR
PASCAL
GetPointString(
              LPSTR buf,
              HDC hdc,
              INT height
              )
{
    wsprintf(buf, "%d", MulDiv((height < 0) ? -height : height, 72, GetDeviceCaps(hdc, LOGPIXELSY)));

    return buf;
}

INT
APIENTRY
FontSizeEnumProc(
                const LOGFONT *lplf,
                const TEXTMETRIC *lptm,
                DWORD nFontType,
                LPARAM lParam
                )
{
    INT height;
    CHAR buf[20];
    LPENUM_FONT_DATA lpData = (LPENUM_FONT_DATA) lParam;

    if (!(nFontType & RASTER_FONTTYPE)) {
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"6");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"8");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"10");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"12");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"14");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"18");
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)"24");
    } else {
        height = lptm->tmHeight - lptm->tmInternalLeading;
        GetPointString(buf, lpData->hdc, height);
        SendMessage(lpData->hwndLB, CB_ADDSTRING, 0, (LPARAM)(LPSTR)buf);
    }

    return TRUE;
}


VOID
NEAR
PASCAL
EnumFontSizes(
             HWND hDlg,
             HDC hdc,
             LPSTR szFace,
             INT height
             )
{
    ENUM_FONT_DATA data;
    CHAR szTemp[10];

    SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_RESETCONTENT, 0, 0L);

    data.hwndLB = GetDlgItem(hDlg, IDD_PTSIZE);
    data.hdc = hdc;

    EnumFonts(hdc, szFace, FontSizeEnumProc, (LPARAM)&data);

    GetPointString(szTemp, hdc, height);
    if ((INT)SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_SELECTSTRING, -1, (LPARAM)szTemp) < 0)
        SendDlgItemMessage(hDlg, IDD_PTSIZE, CB_SETCURSEL, 0, 0L);

}



// needs to be exported of course

INT_PTR
APIENTRY
FontDlgProc(
           HWND hDlg,
           UINT wMsg,
           WPARAM wParam,
           LPARAM lParam
           )
{
    LOGFONT lf;
    ENUM_FONT_DATA data;
    HDC hdc;
    CHAR szTemp[80];
    INT sel;
    static LPMYCHOOSEFONT lpcf;

    switch (wMsg) {
        case WM_INITDIALOG:

            lpcf = (LPMYCHOOSEFONT)lParam;

            hdc = GetDC(NULL);  // screen fonts

            data.hwndLB = GetDlgItem(hDlg, IDD_FACE);
            data.hdc = hdc;

            EnumFonts(hdc, NULL, FontFaceEnumProc, (LPARAM)&data);

            sel = (INT)SendDlgItemMessage(hDlg, IDD_FACE, CB_SELECTSTRING, -1, (LPARAM)(lpcf->lpLogFont)->lfFaceName);
            if (sel < 0) {
                SendDlgItemMessage(hDlg, IDD_FACE, CB_SETCURSEL, 0, 0L);
                sel = 0;
            }

            GetDlgItemText(hDlg, IDD_FACE, szTemp, sizeof(szTemp));

            EnumFontSizes(hDlg, hdc, szTemp, lpcf->lpLogFont->lfHeight);

            ReleaseDC(NULL, hdc);

            CheckDlgButton(hDlg, IDD_ITALIC, lpcf->lpLogFont->lfItalic);
            CheckDlgButton(hDlg, IDD_BOLD, (WORD)(lpcf->lpLogFont->lfWeight > 500));
            CheckDlgButton(hDlg, IDD_LOWERCASE, (WORD)(wTextAttribs & TA_LOWERCASE));

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_FACE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                        case CBN_SELCHANGE:
                            GetDlgItemText(hDlg, IDD_FACE, szTemp, sizeof(szTemp));

                            hdc = GetDC(NULL);  // screen fonts
                            EnumFontSizes(hDlg, hdc, szTemp, lpcf->lpLogFont->lfHeight);
                            ReleaseDC(NULL, hdc);
                            break;
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    if (IsDlgButtonChecked(hDlg, IDD_LOWERCASE))
                        wTextAttribs |= TA_LOWERCASE;
                    else
                        wTextAttribs &= ~TA_LOWERCASE;

                    if (IsDlgButtonChecked(hDlg, IDD_ITALIC))
                        wTextAttribs |= TA_ITALIC;
                    else
                        wTextAttribs &= ~TA_ITALIC;

                    if (IsDlgButtonChecked(hDlg, IDD_BOLD))
                        wTextAttribs |= TA_BOLD;
                    else
                        wTextAttribs &= ~TA_BOLD;

                    GetDlgItemText(hDlg, IDD_FACE, (LPSTR)lf.lfFaceName, sizeof(lf.lfFaceName));

                    GetDlgItemText(hDlg, IDD_PTSIZE, szTemp, sizeof(szTemp));
                    lf.lfHeight = (SHORT)GetHeightFromPointsString(szTemp);
                    lf.lfWeight = (SHORT)(IsDlgButtonChecked(hDlg, IDD_BOLD) ? 800 : 400);
                    lf.lfItalic = (BYTE)IsDlgButtonChecked(hDlg, IDD_ITALIC);
                    lf.lfWidth = 0;
                    lf.lfEscapement = 0;
                    lf.lfOrientation = 0;
                    lf.lfUnderline = 0;
                    lf.lfStrikeOut = 0;
                    lf.lfCharSet = ANSI_CHARSET;
                    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
                    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
                    lf.lfQuality = DEFAULT_QUALITY;
                    lf.lfPitchAndFamily = DEFAULT_PITCH;

                    *(lpcf->lpLogFont) = lf;

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\dlg.h ===
#define IDD_OBJATTRS    6000

#define IDS_NAME        6010
#define IDS_TYPE        6001
#define IDS_OTHERLABEL  6011
#define IDS_OTHERTEXT   6012

#define IDCB_INHERIT    6002
#define IDCB_PERMANENT  6003
#define IDCB_EXCLUSIVE  6004

#define IDS_PAGEDCHARGE    6005
#define IDS_NONPAGEDCHARGE 6006

#define IDS_COUNT           6100
#define IDS_HANDLES         6101
#define IDS_TOTALHANDLES    6102
#define IDS_POINTERS        6103
#define IDS_TOTALPOINTERS   6104
#define IDS_CREATIONTIME    6105
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\dosfunc.h ===
/* docfunc.h
 *
 *  declares dos functions used by file manager
 */

BOOL   APIENTRY DosFindFirst(LPDOSDTA, LPSTR, WORD);
BOOL   APIENTRY DosFindNext(LPDOSDTA);
BOOL   APIENTRY DosDelete(LPSTR);
//WORD   APIENTRY GetFileAttributes(LPSTR);
//WORD   APIENTRY SetFileAttributes(LPSTR, WORD);
DWORD  APIENTRY GetFreeDiskSpace(WORD);
DWORD  APIENTRY GetTotalDiskSpace(WORD);
INT    APIENTRY GetVolumeLabel(INT, LPSTR, BOOL);
INT    APIENTRY MySetVolumeLabel(INT, BOOL, LPSTR);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\lfn.h ===
/* lfn.h -
 *
 *  declaration of lfn aware functions
 */

#define CCHMAXFILE  260         // max size of a long name

#define FILE_83_CI  0
#define FILE_83_CS  1
#define FILE_LONG   2

#define ERROR_OOM   8

/* we need to add an extra field to distinguish DOS vs. LFNs
 */
typedef struct
{
    HANDLE hFindFile;           // handle returned by FindFirstFile()
    DWORD dwAttrFilter;         // search attribute mask.
    DWORD err;                  // error info if failure.
    WIN32_FIND_DATA fd;         // FindFirstFile() data strucrure;
} LFNDTA, FAR * LPLFNDTA, * PLFNDTA;

VOID  APIENTRY LFNInit( VOID );
VOID  APIENTRY InvalidateVolTypes( VOID );

WORD  APIENTRY GetNameType(LPSTR);
BOOL  APIENTRY IsLFN(LPSTR pName);
//BOOL  APIENTRY IsLFNDrive(WORD);

BOOL  APIENTRY WFFindFirst(LPLFNDTA lpFind, LPSTR lpName, DWORD dwAttrFilter);
BOOL  APIENTRY WFFindNext(LPLFNDTA);
BOOL  APIENTRY WFFindClose(LPLFNDTA);

BOOL  APIENTRY WFIsDir(LPSTR);
BOOL  APIENTRY LFNMergePath(LPSTR,LPSTR);

BOOL  APIENTRY IsLFNSelected(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\treectl.h ===
/* Tree Node Flags. */
#define TF_LASTLEVELENTRY   0x01
#define TF_HASCHILDREN	    0x02
#define TF_EXPANDED	    0x04
#define TF_DISABLED	    0x08
#define TF_LFN		    0x10

typedef struct tagDNODE
  {
    struct tagDNODE  *pParent;
    BYTE	    wFlags;
    BYTE	    nLevels;
    INT             iNetType;
    CHAR	    szName[1];	// variable length field
  } DNODE;
typedef DNODE *PDNODE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\lfn.c ===
/* lfn.c -
 *
 *  This file contains code that combines winnet long filename API's and
 *  the DOS INT 21h API's into a single interface.  Thus, other parts of
 *  Winfile call a single piece of code with no worries about the
 *  underlying interface.
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "winfile.h"
#include "object.h"
#include "lfn.h"                            // lfn includes
#include "dosfunc.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "wfcopy.h"

BOOL  APIENTRY IsFATName(LPSTR pName);

#define CDRIVEMAX       26

#define BUFSIZE         2048                // ff/fn buffer size

#define MAXFILES        1024

/* this is the internal buffer maintained for ff/fn operations
 */
typedef struct _find {
    HANDLE hDir;                    // search handle
    WORD cbBuffer;                  // buffer size
    WORD nEntriesLeft;              // remaining entries
    WORD ibEntry;                   // offset of next entry to return
    FILEFINDBUF2 rgFindBuf[1];      // array of find entries
} FIND, * LPFIND;


/* this structure contains an array of drives types (ie, unknown, FAT, LFN)
 * and a pointer to each of the driver functions.  It is declared this way
 * in order to get function prototypes.
 */
typedef struct _lfninfo {
    UINT hDriver;
    INT rgVolType[CDRIVEMAX];
    FARPROC lpfnQueryAbort;
    WORD ( APIENTRY *lpFindFirst)(LPSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
    WORD ( APIENTRY *lpFindNext)(HANDLE,LPINT,WORD,PFILEFINDBUF2);
    WORD ( APIENTRY *lpFindClose)(HANDLE);
    WORD ( APIENTRY *lpGetAttribute)(LPSTR,LPINT);
    WORD ( APIENTRY *lpSetAttribute)(LPSTR,WORD);
    WORD ( APIENTRY *lpCopy)(LPSTR,LPSTR,PQUERYPROC);
    WORD ( APIENTRY *lpMove)(LPSTR,LPSTR);
    WORD ( APIENTRY *lpDelete)(LPSTR);
    WORD ( APIENTRY *lpMKDir)(LPSTR);
    WORD ( APIENTRY *lpRMDir)(LPSTR);
    WORD ( APIENTRY *lpGetVolumeLabel)(WORD,LPSTR);
    WORD ( APIENTRY *lpSetVolumeLabel)(WORD,LPSTR);
    WORD ( APIENTRY *lpParse)(LPSTR,LPSTR,LPSTR);
    WORD ( APIENTRY *lpVolumeType)(WORD,LPINT);
} LFNINFO, * PLFNINFO;

/* pointer to lfn information, so we don't take up a lot of space on a
 * nonlfn system
 */
PLFNINFO pLFN = NULL;


VOID HandleSymbolicLink(HANDLE  DirectoryHandle, PCHAR ObjectName);


/* WFFindFirst -
 *
 * returns:
 *      TRUE for success - lpFind->fd,hFindFileset,attrFilter set.
 *      FALSE for failure
 *
 *  Performs the FindFirst operation and the first WFFindNext.
 */

BOOL
APIENTRY
WFFindFirst(
           LPLFNDTA lpFind,
           LPSTR lpName,
           DWORD dwAttrFilter
           )
{
    // We OR these additional bits because of the way DosFindFirst works
    // in Windows. It returns the files that are specified by the attrfilter
    // and ORDINARY files too.

#define BUFFERSIZE  1024



#define Error(N,S) {                \
    DbgPrint(#N);                    \
    DbgPrint(" Error %08lX\n", S);   \
    }

    CHAR    Buffer[BUFFERSIZE];
    NTSTATUS    Status;
    HANDLE DirectoryHandle;
    ULONG Context = 0;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;
    INT     length;

    lpFind->hFindFile = INVALID_HANDLE_VALUE;
    //DbgPrint("Find first : <%s>\n", lpName);

    // Remove drive letter
    while ((*lpName != 0) && (*lpName != '\\')) {
        lpName ++;
    }
    strcpy(Buffer, lpName);
    length = strlen(Buffer);
    length -= 4;    // Remove '\'*.*
    if (length == 0) {
        length = 1; // Replace the '\'
    }
    Buffer[length] = 0; // Truncate the string at the appropriate point

    //DbgPrint("Find first modified : <%s>\n\r", Buffer);


#define NEW
#ifdef NEW


    //
    //  Open the directory for list directory access
    //

    {
        OBJECT_ATTRIBUTES Attributes;
        ANSI_STRING DirectoryName;
        UNICODE_STRING UnicodeString;


        RtlInitAnsiString(&DirectoryName, Buffer);
        Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                               &DirectoryName,
                                               TRUE );
        ASSERT( NT_SUCCESS( Status ) );
        InitializeObjectAttributes( &Attributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL );
        if (!NT_SUCCESS( Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                         STANDARD_RIGHTS_READ |
                                                         DIRECTORY_QUERY |
                                                         DIRECTORY_TRAVERSE,
                                                         &Attributes ) )) {

            RtlFreeUnicodeString(&UnicodeString);

            if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
                DbgPrint("%Z is not a valid Object Directory Object name\n",
                         &DirectoryName );
            } else {
                DbgPrint("%Z - ", &DirectoryName );
                Error( OpenDirectory, Status );
            }
            return FALSE;
        }

        RtlFreeUnicodeString(&UnicodeString);
    }

    Status = NtQueryDirectoryObject( DirectoryHandle,
                                     Buffer,
                                     BUFFERSIZE,
                                     TRUE,
                                     TRUE,
                                     &Context,
                                     &ReturnedLength );
    if (!NT_SUCCESS( Status )) {
        Error(Find_First_QueryDirectory, Status);
        return (FALSE);
    }

    //
    //  For every record in the buffer type out the directory information
    //

    //
    //  Point to the first record in the buffer, we are guaranteed to have
    //  one otherwise Status would have been No More Files
    //

    DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

    //
    //  Check if there is another record.  If there isn't, then get out
    //  of the loop now
    //

    if (DirInfo->Name.Length == 0) {
        DbgPrint("FindFirst - name length = 0\n\r");
        return (FALSE);
    }

    {
        ANSI_STRING AnsiString;
        AnsiString.Buffer = lpFind->fd.cFileName;
        AnsiString.MaximumLength = sizeof(lpFind->fd.cFileName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &(DirInfo->Name), FALSE);
        ASSERT(NT_SUCCESS(Status));
    }

    //DbgPrint("FindFirst returning <%s>\n\r", lpFind->fd.cFileName);

    // Calculate the attribute field

    lpFind->fd.dwFileAttributes = CalcAttributes(&DirInfo->TypeName);

    #ifdef LATER
    if (lpFind->fd.dwFileAttributes == ATTR_SYMLINK) {
        HandleSymbolicLink(DirectoryHandle, lpFind->fd.cFileName);
    }

    // Label an unknown object type
    if (lpFind->fd.dwFileAttributes == 0) { // Unknown type
        strncat(lpFind->fd.cFileName, " (", MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, DirInfo->TypeName.Buffer,
                MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, ")", MAX_PATH - strlen(lpFind->fd.cFileName));
    }
    #endif

    // Save our search context

    lpFind->hFindFile = DirectoryHandle;
    lpFind->err = Context;

    return (TRUE);

#else
    dwAttrFilter |= ATTR_ARCHIVE | ATTR_READONLY | ATTR_NORMAL;
    lpFind->hFindFile = FindFirstFile(lpName, &lpFind->fd);
    if (lpFind->hFindFile != (HANDLE)0xFFFFFFFF) {
        lpFind->dwAttrFilter = dwAttrFilter;
        if ((~dwAttrFilter & lpFind->fd.dwFileAttributes) == 0L ||
            WFFindNext(lpFind)) {
            PRINT(BF_PARMTRACE, "WFFindFirst:%s", &lpFind->fd.cFileName);
            return (TRUE);
        } else {
            lpFind->err = GetLastError();
            WFFindClose(lpFind);
            return (FALSE);
        }
    } else {
        return (FALSE);
    }
#endif

}



/* WFFindNext -
 *
 *  Performs a single file FindNext operation.  Only returns TRUE if a
 *  file matching the dwAttrFilter is found.  On failure WFFindClose is
 *  called.
 */
BOOL
APIENTRY
WFFindNext(
          LPLFNDTA lpFind
          )
{
    CHAR    Buffer[BUFFERSIZE];
    NTSTATUS    Status;
    HANDLE DirectoryHandle = lpFind->hFindFile;
    ULONG Context = lpFind->err;
    ULONG ReturnedLength;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    POBJECT_NAME_INFORMATION NameInfo;

#ifdef NEW

    //ASSERT(lpFind->hFindFile != (HANDLE)0xFFFFFFFF);

    Status = NtQueryDirectoryObject( DirectoryHandle,
                                     Buffer,
                                     BUFFERSIZE,
                                     TRUE,
                                     FALSE,
                                     &Context,
                                     &ReturnedLength );
    if (!NT_SUCCESS( Status )) {
        if (Status != STATUS_NO_MORE_ENTRIES) {
            Error(FindNext_QueryDirectory, Status);
        }

        return (FALSE);
    }

    //
    //  For every record in the buffer type out the directory information
    //

    //
    //  Point to the first record in the buffer, we are guaranteed to have
    //  one otherwise Status would have been No More Files
    //

    DirInfo = (POBJECT_DIRECTORY_INFORMATION) &Buffer[0];

    //
    //  Check if there is another record.  If there isn't, then get out
    //  of the loop now
    //

    if (DirInfo->Name.Length == 0) {
        DbgPrint("FindNext - name length = 0\n\r");
        return (FALSE);
    }

    {
        ANSI_STRING AnsiString;
        AnsiString.Buffer = lpFind->fd.cFileName;
        AnsiString.MaximumLength = sizeof(lpFind->fd.cFileName);

        Status = RtlUnicodeStringToAnsiString(&AnsiString, &(DirInfo->Name), FALSE);
        ASSERT(NT_SUCCESS(Status));
    }

    //DbgPrint("FindNext returning <%s>\n\r", lpFind->fd.cFileName);

    // Calculate the attribute field

    lpFind->fd.dwFileAttributes = CalcAttributes(&DirInfo->TypeName);

    #ifdef LATER
    if (lpFind->fd.dwFileAttributes == ATTR_SYMLINK) {
        HandleSymbolicLink(DirectoryHandle, lpFind->fd.cFileName);
    }

    // Label an unknown object type
    if (lpFind->fd.dwFileAttributes == 0) { // Unknown type
        strncat(lpFind->fd.cFileName, " (", MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, DirInfo->TypeName.Buffer,
                MAX_PATH - strlen(lpFind->fd.cFileName));
        strncat(lpFind->fd.cFileName, ")", MAX_PATH - strlen(lpFind->fd.cFileName));
    }
    #endif

    // Save our search context

    lpFind->err = Context;

    return (TRUE);

#else
    #ifdef DBG
    if (lpFind->hFindFile == (HANDLE)0xFFFFFFFF) {
        DebugBreak();
        return (FALSE);
    }
    #endif
    while (FindNextFile(lpFind->hFindFile, &lpFind->fd)) {
        if ((lpFind->fd.dwFileAttributes & ~lpFind->dwAttrFilter) != 0)
            continue;           // only pick files that fit attr filter
        PRINT(BF_PARMTRACE, "WFFindNext:%s", &lpFind->fd.cFileName);
        return (TRUE);
    }
    lpFind->err = GetLastError();
    return (FALSE);
#endif

}


/* WFFindClose -
 *
 *  performs the find close operation
 */
BOOL
APIENTRY
WFFindClose(
           LPLFNDTA lpFind
           )
{
    HANDLE DirectoryHandle = lpFind->hFindFile;
    BOOL bRet;

#ifdef NEW
    if (lpFind->hFindFile != INVALID_HANDLE_VALUE) {
        (VOID) NtClose( DirectoryHandle );
        lpFind->hFindFile = INVALID_HANDLE_VALUE;
    }

    return (TRUE);

#else
    ENTER("WFFindClose");
//    ASSERT(lpFind->hFindFile != (HANDLE)0xFFFFFFFF);
    #ifdef DBG
    if (lpFind->hFindFile == (HANDLE)0xFFFFFFFF) {
        PRINT(BF_PARMTRACE, "WFFindClose:Invalid hFindFile = 0xFFFFFFFF","");
        return (FALSE);
    }
    #endif

    bRet = FindClose(lpFind->hFindFile);
    #ifdef DBG
    lpFind->hFindFile = (HANDLE)0xFFFFFFFF;
    #endif

    LEAVE("WFFindClose");
    return (bRet);
#endif

}


VOID
HandleSymbolicLink(
                  HANDLE  DirectoryHandle,
                  PCHAR   ObjectName
                  ) // Assumes this points at a MAX_PATH length buffer
{
    NTSTATUS    Status;
    OBJECT_ATTRIBUTES   Object_Attributes;
    HANDLE      LinkHandle;
    STRING      String;
    WCHAR       UnicodeBuffer[MAX_PATH];
    UNICODE_STRING UnicodeString;
    INT         Length;

    RtlInitString(&String, ObjectName);
    Status = RtlAnsiStringToUnicodeString( &UnicodeString,
                                           &String,
                                           TRUE );
    ASSERT( NT_SUCCESS( Status ) );

    InitializeObjectAttributes(&Object_Attributes,
                               &UnicodeString,
                               0,
                               DirectoryHandle,
                               NULL
                              );

    // Open the given symbolic link object
    Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                      GENERIC_ALL,
                                      &Object_Attributes);

    RtlFreeUnicodeString(&UnicodeString);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("HandleSymbolicLink : open symbolic link failed, status = %lx\n\r", Status);
        return;
    }


    strcat(ObjectName, " => ");
    Length = strlen(ObjectName);

    // Set up our String variable to point at the remains of the object name buffer
    String.Length = 0;
    String.MaximumLength = (USHORT)(MAX_PATH - Length);
    String.Buffer = &(ObjectName[Length]);

    // Go get the target of the symbolic link
    UnicodeString.Buffer = UnicodeBuffer;
    UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

    Status = NtQuerySymbolicLinkObject(LinkHandle, &UnicodeString, NULL);

    NtClose(LinkHandle);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("HandleSymbolicLink : query symbolic link failed, status = %lx\n\r", Status);
        return;
    }

    // Copy the symbolic target into return buffer
    Status = RtlUnicodeStringToAnsiString(&String, &UnicodeString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    // Add NULL terminator
    String.Buffer[String.Length] = 0;

    return;
}


/* WFIsDir
 *
 *  Determines if the specified path is a directory
 */
BOOL
APIENTRY
WFIsDir(
       LPSTR lpDir
       )
{
    DWORD attr = GetFileAttributes(lpDir);

    if (attr & 0x8000)  // BUG: what is this constant???
        return FALSE;

    if (attr & ATTR_DIR)
        return TRUE;

    return FALSE;
}


/* LFNQueryAbort -
 *
 *  wraps around WFQueryAbort and is exported/makeprocinstanced
 */

BOOL
APIENTRY
LFNQueryAbort(
             VOID
             )
{
    return WFQueryAbort();
}

/* LFNInit -
 *
 *  Initializes stuff for LFN access
 */

VOID
APIENTRY
LFNInit()
{
    INT i;

    /* find out if long names are supported.
     */
    if (!(WNetGetCaps(WNNC_ADMIN) & WNNC_ADM_LONGNAMES))
        return;

    /* get the buffer
     */
    pLFN = (PLFNINFO)LocalAlloc(LPTR,sizeof(LFNINFO));
    if (!pLFN)
        return;

    /* get the handle to the driver
     */
    if (!(pLFN->hDriver = WNetGetCaps((WORD)0xFFFF))) {
        LocalFree((HANDLE)pLFN);
        pLFN = NULL;
        return;
    }

    /* set all the volume types to unknown
     */
    for (i = 0; i < CDRIVEMAX; i++) {
        pLFN->rgVolType[i] = -1;
    }
}

/* GetNameType -
 *
 *  Shell around LFNParse.  Classifies name.
 *
 *  NOTE: this should work on unqualified names.  currently this isn't
 *        very useful.
 */
WORD
APIENTRY
GetNameType(
           LPSTR lpName
           )
{
    if (*(lpName+1) == ':') {
        if (!IsLFNDrive(lpName))
            return FILE_83_CI;
    } else if (IsFATName(lpName))
        return FILE_83_CI;

    return (FILE_LONG);
}

BOOL
APIENTRY
IsFATName(
         LPSTR pName
         )
{
    INT  cdots = 0;
    INT  cb;
    INT  i;
    INT  iFirstDot;


    cb = lstrlen(pName);
    if (cb > 12) {
        return FALSE;
    } else {
        for (i = 0; i < cb; i++) {
            if (pName[i] == '.') {
                iFirstDot = cdots ? iFirstDot : i;
                cdots++;
            }
        }

        if (cdots == 0 && cb <= 8)
            return TRUE;
        else if (cdots != 1)
            return FALSE;
        else if (cdots == 1 && iFirstDot > 8)
            return FALSE;
        else
            return TRUE;
    }

}

BOOL
APIENTRY
IsLFN(
     LPSTR pName
     )
{
    return !IsFATName(pName);
}

BOOL
APIENTRY
LFNMergePath(
            LPSTR pTo,
            LPSTR pFrom
            )
{
    PRINT(BF_PARMTRACE, "LFNMergePath:basically a NOP", "");
    pTo; pFrom;
    return (FALSE);
}

/* InvalidateVolTypes -
 *
 *  This function sets all drive types to unknown.  It should be called
 *  whenever the drive list is refreshed.
 */

VOID
APIENTRY
InvalidateVolTypes( VOID )
{
    INT i;

    if (!pLFN)
        return;

    for (i = 0; i < CDRIVEMAX; i++)
        pLFN->rgVolType[i] = -1;
}


/* WFCopy
 *
 *  Copies files
 */
WORD
APIENTRY
WFCopy(
      PSTR pszFrom,
      PSTR pszTo
      )
{
    WORD wRet;

    Notify(hdlgProgress, IDS_COPYINGMSG, pszFrom, pszTo);

    wRet = FileCopy(pszFrom,pszTo);

    if (!wRet)
        ChangeFileSystem(FSC_CREATE,pszTo,NULL);

    return wRet;
}

/* WFRemove
 *
 *  Deletes files
 */
WORD
APIENTRY
WFRemove(
        PSTR pszFile
        )
{
    WORD wRet;

    wRet = FileRemove(pszFile);
    if (!wRet)
        ChangeFileSystem(FSC_DELETE,pszFile,NULL);

    return wRet;
}

/* WFMove
 *
 *  Moves files on a volume
 */
WORD
APIENTRY
WFMove(
      PSTR pszFrom,
      PSTR pszTo
      )
{
    WORD wRet;

    wRet = FileMove(pszFrom,pszTo);
    if (!wRet)
        ChangeFileSystem(FSC_RENAME,pszFrom,pszTo);

    return wRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\treectl.c ===
/****************************************************************************/
/*                                                                          */
/*  TREECTL.C -                                                             */
/*                                                                          */
/*      Windows Directory Tree Window Proc Routines                         */
/*                                                                          */
/****************************************************************************/

#define PUBLIC           // avoid collision with shell.h
#include "winfile.h"
#include "treectl.h"
#include "lfn.h"
#include "winnet.h"
#include "wfcopy.h"

#define WS_TREESTYLE (WS_CHILD | WS_VISIBLE | LBS_NOTIFY | WS_VSCROLL | WS_HSCROLL | LBS_OWNERDRAWFIXED | LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT | LBS_DISABLENOSCROLL)

WORD    cNodes;
// BOOL    bCancelTree; .......... moved to winfile.c


VOID  RectTreeItem(HWND hwndLB, register INT iItem, BOOL bFocusOn);
VOID  GetTreePathIndirect(PDNODE pNode, register LPSTR szDest);
VOID  GetTreePath(PDNODE pNode, register LPSTR szDest);
VOID  ScanDirLevel(PDNODE pParentNode, LPSTR szPath, DWORD view);
INT   InsertDirectory(HWND hwndTreeCtl, PDNODE pParentNode, WORD iParentNode, LPSTR szName, PDNODE *ppNode);
BOOL  ReadDirLevel(HWND hwndTreeCtl, PDNODE pParentNode, LPSTR szPath,
                     WORD nLevel, INT iParentNode, DWORD dwAttribs, BOOL bFullyExpand, LPSTR szAutoExpand);
VOID  FillTreeListbox(HWND hwndTreeCtl, LPSTR szDefaultDir, BOOL bFullyExpand, BOOL bDontSteal);
WORD  FindItemFromPath(HWND hwndLB, LPSTR lpszPath, BOOL bReturnParent, PDNODE *ppNode);

VOID  APIENTRY CheckEscapes(LPSTR);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTreePathIndirect() -                                                 */
/*                                                                          */
/*  build a complete path for a given node in the tree by recursivly        */
/*  traversing the tree structure                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetTreePathIndirect(
                   PDNODE pNode,
                   register LPSTR szDest
                   )
{
    register PDNODE    pParent;

    pParent = pNode->pParent;

    if (pParent)
        GetTreePathIndirect(pParent, szDest);

    lstrcat(szDest, pNode->szName);

    if (pParent)
        lstrcat(szDest, "\\");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetTreePath() -                                                         */
/*                                                                          */
/*  build a complete path for a given node in the tree                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetTreePath(
           PDNODE pNode,
           register LPSTR szDest
           )
{
    szDest[0] = 0L;
    GetTreePathIndirect(pNode, szDest);

    /* Remove the last backslash (unless it is the root directory). */
    if (pNode->pParent)
        szDest[lstrlen(szDest)-1] = 0L;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ScanDirLevel() -                                                        */
/*                                                                          */
/*  look down to see if this node has any sub directories                   */
/*
/*--------------------------------------------------------------------------*/
// szPath is ANSI

VOID
ScanDirLevel(
            PDNODE pParentNode,
            LPSTR szPath,
            DWORD view
            )
{
    BOOL bFound;
    LFNDTA lfndta;

    ENTER("ScanDirLevel");

    /* Add '*.*' to the current path. */
    lstrcpy(szMessage, szPath);
    AddBackslash(szMessage);
    lstrcat(szMessage, szStarDotStar);

    /* Search for the first subdirectory on this level. */
    // FixAnsiPathForDos(szMessage);
    bFound = WFFindFirst(&lfndta, szMessage, ATTR_DIR | view);

    while (bFound) {
        /* Is this not a '.' or '..' directory? */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {
            pParentNode->wFlags |= TF_HASCHILDREN;
            bFound = FALSE;
        } else
            /* Search for the next subdirectory. */
            bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    LEAVE("ScanDirLevel");
}



// wizzy cool recursive path compare routine
//
// p1 and p2 must be on the same level (p1->nLevels == p2->nLevels)

INT
ComparePath(
           PDNODE p1,
           PDNODE p2
           )
{
    INT ret;

    if (p1 == p2) {
        return 0;       // equal (base case)
    } else {

        ret = ComparePath(p1->pParent, p2->pParent);

        if (ret == 0) {
            // parents are equal

            ret = lstrcmp(p1->szName, p2->szName);
#if 0
            {
                CHAR buf[200];
                wsprintf(buf, "Compare(%s, %s) -> %d\r\n", (LPSTR)p1->szName, (LPSTR)p2->szName, ret);
                OutputDebugString(buf);
            }
#endif
        }

        // not equal parents, propagate up the call tree
        return ret;
    }
}


INT
CompareNodes(
            PDNODE p1,
            PDNODE p2
            )
{
    PDNODE p1save, p2save;
    INT ret;

    ENTER("CompareNodes");

    ASSERT(p1 && p2);

    PRINT(BF_PARMTRACE, "IN: p1=%s", p1->szName);
    PRINT(BF_PARMTRACE, "IN: p2=%s", p2->szName);

    p1save = p1;
    p2save = p2;

    // get p1 and p2 to the same level

    while (p1->nLevels > p2->nLevels)
        p1 = p1->pParent;

    while (p2->nLevels > p1->nLevels)
        p2 = p2->pParent;

    // compare those paths

    ret = ComparePath(p1, p2);

    if (ret == 0)
        ret = (INT)p1save->nLevels - (INT)p2save->nLevels;

    LEAVE("CompareNodes");
    return ret;
}


//
// InsertDirectory()
//
// wizzy quick n log n binary insert code!
//
// creates and inserts a new node in the tree, this also sets
// the TF_LASTLEVELENTRY bits to mark a branch as being the last
// for a given level as well as marking parents with
// TF_HASCHILDREN | TF_EXPANDED to indicate they have been expanded
// and have children.
//
// Returns iNode and fills ppNode with pNode.
//

INT
InsertDirectory(
               HWND hwndTreeCtl,
               PDNODE pParentNode,
               WORD iParentNode,
               LPSTR szName,
               PDNODE *ppNode
               )
{
    WORD  len, x;
    PDNODE pNode, pMid;
    HWND  hwndLB;
    INT   iMin;
    INT   iMax;
    INT   iMid;

    ENTER("InsertDirectory");
    PRINT(BF_PARMTRACE, "IN: pParentNode=%lx", pParentNode);
    PRINT(BF_PARMTRACE, "IN: iParentNode=%d", iParentNode);
    PRINT(BF_PARMTRACE, "IN: szName=%s", szName);

    len = (WORD)lstrlen(szName);

    pNode = (PDNODE)LocalAlloc(LPTR, sizeof(DNODE)+len);
    if (!pNode) {
        if (ppNode) {
            *ppNode = NULL;
        }
        return 0;
    }

    pNode->pParent = pParentNode;
    pNode->nLevels = pParentNode ? (pParentNode->nLevels + (BYTE)1) : (BYTE)0;
    pNode->wFlags  = (BYTE)NULL;
    pNode->iNetType = -1;
    if (IsLFN(szName)) {
        pNode->wFlags |= TF_LFN;
    }

    lstrcpy(pNode->szName, szName);

    if (pParentNode)
        pParentNode->wFlags |= TF_HASCHILDREN | TF_EXPANDED;      // mark the parent

    hwndLB = GetDlgItem(hwndTreeCtl, IDCW_TREELISTBOX);

    // computing the real text extent is too slow so we aproximate
    // with the following (note, we don't keep this on a per tree
    // basis so it is kinda bogus anyway)

    x = (WORD)(len + 2 * pNode->nLevels) * (WORD)dxText;

    if (x > xTreeMax) {
        xTreeMax = x;
    }

    iMax = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (iMax > 0) {

        // do a binary insert

        iMin = iParentNode + 1;
        iMax--;         // last index

        do {
            iMid = (iMax + iMin) / 2;

            SendMessage(hwndLB, LB_GETTEXT, iMid, (LPARAM)&pMid);

            if (CompareNodes(pNode, pMid) > 0)
                iMin = iMid + 1;
            else
                iMax = iMid - 1;

        } while (iMax > iMin);

        SendMessage(hwndLB, LB_GETTEXT, iMax, (LPARAM)&pMid);
        if (CompareNodes(pNode, pMid) > 0)
            iMax++;         // insert after this one
    }

    // now reset the TF_LASTLEVEL flags as appropriate

    // look for the first guy on our level above us and turn off
    // his TF_LASTLEVELENTRY flag so he draws a line down to us

    iMid = iMax - 1;

    while (iMid >= 0) {
        SendMessage(hwndLB, LB_GETTEXT, iMid--, (LPARAM)&pMid);
        if (pMid->nLevels == pNode->nLevels) {
            pMid->wFlags &= ~TF_LASTLEVELENTRY;
            break;
        } else if (pMid->nLevels < pNode->nLevels)
            break;
    }

    // if no one below me or the level of the guy below is less, then
    // this is the last entry for this level

    if (((INT)SendMessage(hwndLB, LB_GETTEXT, iMax, (LPARAM)&pMid) == LB_ERR) ||
        (pMid->nLevels < pNode->nLevels))
        pNode->wFlags |=  TF_LASTLEVELENTRY;

    SendMessage(hwndLB, LB_INSERTSTRING, iMax, (LPARAM)pNode);
    if (ppNode) {
        *ppNode = pNode;
    }

    LEAVE("InsertDirectory");
    return iMax;
}


// this yeilds control to other apps and allows us to process
// messages and user input.  to avoid overrunning the stack
// from multiple tree reads being initiated at the same time
// we check how much space we have on the stack before we yield

extern WORD end;        // C compiler end of static data symbol
extern WORD pStackTop;


WORD
StackAvail(VOID)
{
#ifdef LATER
    _asm    mov ax,sp
    _asm    sub ax,pStackTop
    if (0) return 0;  // get rid of warning, optimized out
#endif

    return 0x7fff;  // Hack. shouldn't really matter. StackAvail in NT is a NOP
}


VOID
APIENTRY
wfYield()
{
    MSG msg;
#ifdef LATER
    WORD free_stack;
    free_stack = StackAvail();
#endif


#if 0
    {
        CHAR buf[30];

        wsprintf(buf, "free stack: %d\r\n", free_stack);
        OutputDebugString(buf);
    }
#endif

#if LATER
    if (free_stack < 1024*4) {
        CHAR buf[40];
        wsprintf(buf, "not enough stack %d\r\n", free_stack);
        OutputDebugString(buf);
        return;
    }
#endif

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!TranslateMDISysAccel(hwndMDIClient, &msg) &&
            (!hwndFrame || !TranslateAccelerator(hwndFrame, hAccel, &msg))) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
}


// INT iReadLevel = 0;     ...............Moved to winfile.c


//--------------------------------------------------------------------------
//
// ReadDirLevel() -
//
// this does a depth first search of the dir tree.  note, a bredth
// first implementation did not perform any better.
//
// szPath               a directory path that MUST EXIST long enough
//                      to hold the full path to the largest directory
//                      that will be found (MAXPATHLEN).  this is an
//                      ANSI string.  (ie C:\ and C:\FOO are valid)
// nLevel               level in the tree
// iParentNode          index of parent node
// dwAttribs            attributes to filter with
// bFullyExpand         TRUE means expand this node fully
// szAutoExpand         list of directories to autoexpand ANSI
//                      (eg. for "C:\foo\bar\stuff"
//                      "foo" NULL "bar" NULL "stuff" NULL NULL)
//
// returns:
//      TRUE            tree read sucessful
//      FALSE           user abort or bogus tree read
//--------------------------------------------------------------------------

BOOL
ReadDirLevel(
            HWND  hwndTreeCtl,
            PDNODE pParentNode,
            LPSTR  szPath,
            WORD  nLevel,
            INT   iParentNode,
            DWORD dwAttribs,
            BOOL  bFullyExpand,
            LPSTR  szAutoExpand
            )
{
    LPSTR      szEndPath;
    LFNDTA    lfndta;
    INT       iNode;
    BOOL      bFound;
    PDNODE     pNode;
    BOOL      bAutoExpand;
    BOOL      bResult = TRUE;
    WORD      view;
    HWND      hwndParent;
    HWND      hwndDir;
    HANDLE    hDTA;
    LPMYDTA   lpmydta;
    INT       count;
    RECT rc;

    ENTER("ReadDirLevel");
    PRINT(BF_PARMTRACE, "IN: szPath=%s", szPath);
    PRINT(BF_PARMTRACE, "IN: nLevel=%d", (LPSTR)nLevel);
    PRINT(BF_PARMTRACE, "IN: bFullyExpand=%d", IntToPtr(bFullyExpand));
    PRINT(BF_PARMTRACE, "IN: szAutoExpand=%s", szAutoExpand);

    if (StackAvail() < 1024*2)
        return(TRUE);

    hwndParent = GetParent(hwndTreeCtl);

    view = (WORD)GetWindowLong(hwndParent, GWL_VIEW);

    // we optimize the tree read if we are not adding pluses and
    // we find a directory window that already has read all the
    // directories for the path we are about to search.  in this
    // case we look through the DTA structure in the dir window
    // to get all the directories (instead of calling FindFirst/FindNext).
    // in this case we have to disable yielding since the user could
    // potentialy close the dir window that we are reading, or change
    // directory.

    hDTA = NULL;

    if (!(view & VIEW_PLUSES)) {

        if ((hwndDir = HasDirWindow(hwndParent)) &&
            (GetWindowLong(hwndParent, GWL_ATTRIBS) & ATTR_DIR)) {

            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szMessage), (LPARAM)szMessage);
            StripBackslash(szMessage);

            if (!lstrcmpi(szMessage, szPath)) {
                SendMessage(hwndDir, FS_GETFILESPEC, sizeof(szMessage), (LPARAM)szMessage);

                if (!lstrcmp(szMessage, szStarDotStar)) {
                    hDTA = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA);
                    lpmydta = (LPMYDTA)LocalLock(hDTA);
                    count = (INT)lpmydta->my_nFileSizeLow; // holds number of entries, NOT size.
                }
            }
        }
    }

    SetWindowLong(hwndTreeCtl, GWL_READLEVEL, GetWindowLong(hwndTreeCtl, GWL_READLEVEL) + 1);
    iReadLevel++;         // global for menu code

    szEndPath = (LPSTR)(szPath + lstrlen(szPath));

    /* Add '\*.*' to the current path. */
    AddBackslash(szPath);
    lstrcat(szPath, szStarDotStar);

    if (hDTA) {
        // steal the entry from the dir window
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        // search for any "real" directories

        while (count > 0 && (!(lpmydta->my_dwAttrs & ATTR_DIR) || (lpmydta->my_dwAttrs & ATTR_PARENT))) {
            lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
            count--;
        }

        if (count > 0) {
            bFound = TRUE;
            memcpy(&(lfndta.fd.dwFileAttributes), &(lpmydta->my_dwAttrs), IMPORTANT_DTA_SIZE);
            lstrcpy(lfndta.fd.cFileName, lpmydta->my_cFileName);
        } else
            bFound = FALSE;
    } else {
        // get first file from DOS
        lstrcpy(szMessage, szPath);
        FixAnsiPathForDos(szMessage);
        bFound = WFFindFirst(&lfndta, szMessage, dwAttribs);
    }

    // for net drive case where we can't actually see what is in these
    // direcotries we will build the tree automatically

    if (!bFound && *szAutoExpand) {
        LPSTR p;

        p = szAutoExpand;
        szAutoExpand += lstrlen(szAutoExpand) + 1;

        iNode = InsertDirectory(hwndTreeCtl, pParentNode, (WORD)iParentNode, p, &pNode);
        pParentNode->wFlags |= TF_DISABLED;

        /* Construct the path to this new subdirectory. */
        *szEndPath = 0;           // remove old stuff
        AddBackslash(szPath);
        lstrcat(szPath, p);

        if (pNode)
            ReadDirLevel(hwndTreeCtl, pNode, szPath, (WORD)(nLevel+1), iNode, dwAttribs, bFullyExpand, szAutoExpand);
    }

    while (bFound) {

        wfYield();

        if (bCancelTree) {
            bResult = FALSE;
            if (bCancelTree == 2)
                PostMessage(hwndFrame, WM_COMMAND, IDM_EXIT, 0L);
            goto DONE;
        }

        /* Is this not a '.' or '..' directory? */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {

            if (!hDTA)
                OemToCharBuff(lfndta.fd.cFileName, lfndta.fd.cFileName, sizeof(lfndta.fd.cFileName)/sizeof(lfndta.fd.cFileName[0]));

            // we will try to auto expand this node if it matches

            if (*szAutoExpand && !lstrcmpi(szAutoExpand, lfndta.fd.cFileName)) {
                bAutoExpand = TRUE;
                szAutoExpand += lstrlen(szAutoExpand) + 1;
            } else {
                bAutoExpand = FALSE;
            }

            iNode = InsertDirectory(hwndTreeCtl, pParentNode, (WORD)iParentNode, lfndta.fd.cFileName, &pNode);

            if (bStatusBar && ((cNodes % 7) == 0)) {

                // make sure we are the active window before we
                // update the status bar

                if (hwndParent == (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L)) {
                    wsprintf(szStatusTree, szDirsRead, cNodes);
                    // stomp over the status bar!
                    GetClientRect(hwndFrame, &rc);
                    rc.top = rc.bottom - dyStatus;
                    InvalidateRect(hwndFrame, &rc, FALSE);
                    // force the paint because we don't yield
                    UpdateWindow(hwndFrame);
                }
            }
            cNodes++;

            /* Construct the path to this new subdirectory. */
            *szEndPath = 0L;
            AddBackslash(szPath);
            lstrcat(szPath, lfndta.fd.cFileName);         // cFileName is ANSI now


            // either recurse or add pluses

            if (pNode) {
                if (bFullyExpand || bAutoExpand) {
                    if (!ReadDirLevel(hwndTreeCtl, pNode, szPath, (WORD)(nLevel+1), iNode, dwAttribs, bFullyExpand, szAutoExpand)) {
                        bResult = FALSE;
                        goto DONE;
                    }
                } else if (view & VIEW_PLUSES) {
                    ScanDirLevel(pNode, szPath, dwAttribs & ATTR_HS);
                }
            }
        }

        if (hDTA) {       // short cut, steal data from dir window
            count--;
            lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
            while (count > 0 && (!(lpmydta->my_dwAttrs & ATTR_DIR) || (lpmydta->my_dwAttrs & ATTR_PARENT))) {
                lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
                count--;
            }

            if (count > 0) {
                bFound = TRUE;
                memcpy(&(lfndta.fd.dwFileAttributes), &(lpmydta->my_dwAttrs), IMPORTANT_DTA_SIZE);
                lstrcpy(lfndta.fd.cFileName, lpmydta->my_cFileName);
            } else
                bFound = FALSE;
        } else {
            bFound = WFFindNext(&lfndta); // get it from dos
        }
    }

    *szEndPath = 0L;    // clean off any stuff we left on the end of the path

    DONE:

    if (!hDTA) {
        WFFindClose(&lfndta);
    } else {
        LocalUnlock(hDTA);
    }

    SetWindowLong(hwndTreeCtl, GWL_READLEVEL, GetWindowLong(hwndTreeCtl, GWL_READLEVEL) - 1);
    iReadLevel--;

    LEAVE("ReadDirLevel");
    return bResult;
}


// this is used by StealTreeData() to avoid alias problems where
// the nodes in one tree point to parents in the other tree.
// basically, as we are duplicating the tree data structure we
// have to find the parent node that coorisponds with the parent
// of the tree we are copying from in the tree that we are building.
// since the tree is build in order we run up the listbox, looking
// for the parent (matched by it's level being one smaller than
// the level of the node being inserted).  when we find that we
// return the pointer to that node.

PDNODE
FindParent(
          INT iLevelParent,
          INT iStartInd,
          HWND hwndLB
          )
{
    PDNODE pNode;

    while (TRUE) {
        if (SendMessage(hwndLB, LB_GETTEXT, iStartInd, (LPARAM)&pNode) == LB_ERR)
            return NULL;

        if (pNode->nLevels == (BYTE)iLevelParent) {
            SendMessage(hwndLB, LB_GETTEXT, iStartInd, (LPARAM)&pNode);
            return pNode;
        }

        iStartInd--;
    }
}



BOOL
StealTreeData(
             HWND hwndTC,
             HWND hwndLB,
             LPSTR szDir
             )
{
    HWND hwndSrc, hwndT;
    CHAR szSrc[MAXPATHLEN];
    WORD wView;
    DWORD dwAttribs;

    ENTER("StealTreeData");

    // we need to match on these attributes as well as the name

    wView    = (WORD)(GetWindowLong(GetParent(hwndTC), GWL_VIEW) & VIEW_PLUSES);
    dwAttribs = (DWORD)GetWindowLong(GetParent(hwndTC), GWL_ATTRIBS) & ATTR_HS;

    // get the dir of this new window for compare below

    for (hwndSrc = GetWindow(hwndMDIClient, GW_CHILD); hwndSrc;
        hwndSrc = GetWindow(hwndSrc, GW_HWNDNEXT)) {

        // avoid finding ourselves, make sure has a tree
        // and make sure the tree attributes match

        if ((hwndT = HasTreeWindow(hwndSrc)) &&
            (hwndT != hwndTC) &&
            !GetWindowLong(hwndT, GWL_READLEVEL) &&
            (wView  == (WORD)(GetWindowLong(hwndSrc, GWL_VIEW) & VIEW_PLUSES)) &&
            (dwAttribs == (DWORD)(GetWindowLong(hwndSrc, GWL_ATTRIBS) & ATTR_HS))) {

            SendMessage(hwndSrc, FS_GETDIRECTORY, sizeof(szSrc), (LPARAM)szSrc);
            StripBackslash(szSrc);

            if (!lstrcmpi(szDir, szSrc))     // are they the same?
                break;                  // yes, do stuff below
        }
    }

    if (hwndSrc) {

        HWND hwndLBSrc;
        PDNODE pNode, pNewNode, pLastParent;
        INT i;

        hwndLBSrc = GetDlgItem(hwndT, IDCW_TREELISTBOX);

        // don't seal from a tree that hasn't been read yet!

        if ((INT)SendMessage(hwndLBSrc, LB_GETCOUNT, 0, 0L) == 0) {
            LEAVE("StealTreeData");
            return FALSE;
        }

        pLastParent = NULL;

        for (i = 0; SendMessage(hwndLBSrc, LB_GETTEXT, i, (LPARAM)&pNode) != LB_ERR; i++) {

            if (pNewNode = (PDNODE)LocalAlloc(LPTR, sizeof(DNODE)+lstrlen(pNode->szName))) {

                *pNewNode = *pNode;                             // dup the node
                lstrcpy(pNewNode->szName, pNode->szName);       // and the name

                // accelerate the case where we are on the same level to avoid
                // slow linear search!

                if (pLastParent && pLastParent->nLevels == (pNode->nLevels - (BYTE)1)) {
                    pNewNode->pParent = pLastParent;
                } else {
                    pNewNode->pParent = pLastParent = FindParent(pNode->nLevels-1, i-1, hwndLB);
                }

                PRINT(BF_PARMTRACE, "(stolen)Inserting...0x%lx", pNewNode);
                PRINT(BF_PARMTRACE, "   at %d", IntToPtr(i));
                SendMessage(hwndLB, LB_INSERTSTRING, i, (LPARAM)pNewNode);
                ASSERT((PDNODE)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L) == pNewNode);
            }
        }

        LEAVE("StealTreeData");
        return TRUE;    // successful steal
    }

    LEAVE("StealTreeData");
    return FALSE;
}



VOID
FreeAllTreeData(
               HWND hwndLB
               )
{
    INT nIndex;
    PDNODE pNode;

    ENTER("FreeAllTreeData");

    // Free up the old tree (if any)

    nIndex = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    while (--nIndex >= 0) {
        SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&pNode);
        LocalFree((HANDLE)pNode);
    }
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

    LEAVE("FreeAllTreeData");
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillTreeListbox() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/
// szDefaultDir is ANSI

VOID
FillTreeListbox(
               HWND hwndTC,
               LPSTR szDefaultDir,
               BOOL bFullyExpand,
               BOOL bDontSteal
               )
{
    PDNODE pNode;
    INT   iNode;
    DWORD dwAttribs;
    CHAR  szTemp[MAXPATHLEN] = "\\";
    CHAR  szExpand[MAXPATHLEN];
    LPSTR  p;
    HWND  hwndLB;

    ENTER("FillTreeListbox");

    hwndLB = GetDlgItem(hwndTC, IDCW_TREELISTBOX);

    FreeAllTreeData(hwndLB);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

    bDontSteal = TRUE; // Force recalc for now

    if (bDontSteal || bFullyExpand || !StealTreeData(hwndTC, hwndLB, szDefaultDir)) {

        iNode = InsertDirectory(hwndTC, NULL, 0, szTemp, &pNode);

        if (pNode) {

            dwAttribs = ATTR_DIR | (GetWindowLong(GetParent(hwndTC), GWL_ATTRIBS) & ATTR_HS);
            cNodes = 0;
            bCancelTree = FALSE;

            if (szDefaultDir) {
                lstrcpy(szExpand, szDefaultDir+3);      // skip "X:\"

                p = szExpand;

                while (*p) {                            // null out all slashes

                    while (*p && *p != '\\')
                        p = AnsiNext(p);

                    if (*p)
                        *p++ = 0L;
                }
                p++;
                *p = 0L;      // double null terminated
            } else
                *szExpand = 0;

            if (!ReadDirLevel(hwndTC, pNode, szTemp, 1, 0, dwAttribs, bFullyExpand, szExpand)) {
                lFreeSpace = -2L;
            }

        }
    }

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);

    if (szDefaultDir) {
        FindItemFromPath(hwndLB, szDefaultDir, FALSE, &pNode);
    }

    SendMessage(hwndLB, LB_SELECTSTRING, -1, (LPARAM)pNode);

    UpdateStatus(GetParent(hwndTC));  // Redraw the Status Bar

    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    InvalidateRect(hwndLB, NULL, TRUE);
    UpdateWindow(hwndLB);                 // make this look a bit better

    LEAVE("FillTreeListbox");
}


//
// FindItemFromPath()
//
// find the PDNODE and LBIndex for a given path
//
// in:
//      hwndLB          listbox of tree
//      lpszPath        path to search for (ANSI)
//      bReturnParent   TRUE if you want the parent, not the node
//
//
// returns:
//      listbox index (0xFFFF if not found)
//      *ppNode is filled with pNode of node, or pNode of parent if bReturnParent is TRUE
//

WORD
FindItemFromPath(
                HWND hwndLB,
                LPSTR lpszPath,
                BOOL bReturnParent,
                PDNODE *ppNode
                )
{
    register WORD     i;
    register LPSTR     p;
    PDNODE             pNode;
    PDNODE             pPreviousNode;
    CHAR              szElement[1+MAXFILENAMELEN+1];

    ENTER("FindItemFromPath");

    if (lstrlen(lpszPath) < 3) {
        LEAVE("FindItemFromPath");
        return -1;
    }
    if (IsDBCSLeadByte( lpszPath[0] ) || lpszPath[1] != ':') {
        LEAVE("FindItemFromPath");
        return -1;
    }

    i = 0;
    pPreviousNode = NULL;

    while (*lpszPath) {
        /* NULL out szElement[1] so the backslash hack isn't repeated with
         * a first level directory of length 1.
         */
        szElement[1] = 0L;

        /* Copy the next section of the path into 'szElement' */
        p = szElement;
        while (*lpszPath && *lpszPath != '\\') {
            *p++ = *lpszPath;
            if (IsDBCSLeadByte( *lpszPath ))
                *p++ = lpszPath[1];     // copy 2nd byte of DBCS char.
            lpszPath = AnsiNext( lpszPath );
        }

        /* Add a backslash for the Root directory. */
        if ( !IsDBCSLeadByte( szElement[0] ) && szElement[1] == ':' )
            *p++ = '\\';

        /* NULL terminate 'szElement' */
        *p = 0L;

        /* Skip over the path's next Backslash. */
        if (*lpszPath)
            lpszPath = AnsiNext(lpszPath);
        else if (bReturnParent) {
            /* We're at the end of a path which includes a filename.  Return
             * the previously found parent.
             */
            if (ppNode) {
                *ppNode = pPreviousNode;
            }
            LEAVE("FindItemFromPath");
            return i;
        }

        while (TRUE) {
            /* Out of LB items?  Not found. */
            if (SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&pNode) == LB_ERR)
                return -1;

            if (pNode->pParent == pPreviousNode) {
                if (!lstrcmpi(szElement, pNode->szName)) {
                    /* We've found the element... */
                    pPreviousNode = pNode;
                    break;
                }
            }
            i++;
        }
    }
    if (ppNode) {
        *ppNode = pPreviousNode;
    }

    LEAVE("FindItemFromPath");
    return i;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RectTreeItem() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
RectTreeItem(
            HWND hwndLB,
            INT iItem,
            BOOL bFocusOn
            )
{
    INT           dx;
    INT           len;
    HDC           hdc;
    RECT          rc;
    RECT          rcClip;
    BOOL          bSel;
    WORD          wColor;
    PDNODE         pNode;
    HBRUSH        hBrush;
    HFONT hOld;
    CHAR          szPath[MAXPATHLEN];

    ENTER("RectTreeItem");

    if (iItem == -1) {
        LEAVE("RectTreeItem");
        return;
    }

    /* Are we over ourselves? (i.e. a selected item in the source listbox) */
    bSel = (BOOL)SendMessage(hwndLB, LB_GETSEL, iItem, 0L);
    if (bSel && (hwndDragging == hwndLB)) {
        LEAVE("RectTreeItem");
        return;
    }

    SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)&pNode);

    SendMessage(hwndLB, LB_GETITEMRECT, iItem, (LPARAM)&rc);

    hdc = GetDC(hwndLB);

    len = lstrlen(pNode->szName);
    lstrcpy(szPath, pNode->szName);

    if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
        AnsiLower(szPath);

    hOld = SelectObject(hdc, hFont);
    MGetTextExtent(hdc, szPath, len, &dx, NULL);
    dx += dyBorder;
    if (hOld)
        SelectObject(hdc, hOld);
    rc.left = pNode->nLevels * dxText * 2;
    rc.right = rc.left + dxFolder + dx + 4 * dyBorderx2;

    GetClientRect(hwndLB, &rcClip);
    IntersectRect(&rc, &rc, &rcClip);

    if (bFocusOn) {
        if (bSel) {
            wColor = COLOR_WINDOW;
            InflateRect(&rc, -dyBorder, -dyBorder);
        } else
            wColor = COLOR_WINDOWFRAME;
        if (hBrush = CreateSolidBrush(GetSysColor(wColor))) {
            FrameRect(hdc, &rc, hBrush);
            DeleteObject(hBrush);
        }
    } else {
        InvalidateRect(hwndLB, &rc, TRUE);
        UpdateWindow(hwndLB);
    }
    ReleaseDC(hwndLB, hdc);
    LEAVE("RectTreeItem");
}


// return the drive of the first window to respond to the FS_GETDRIVE
// message.  this usually starts from the source or dest of a drop
// and travels up until we find a drive or hit the MDI client

INT
APIENTRY
GetDrive(
        HWND hwnd,
        POINT pt
        )
{
    CHAR chDrive;

    chDrive = 0L;
    while (hwnd && (hwnd != hwndMDIClient)) {
        chDrive = (CHAR)SendMessage(hwnd, FS_GETDRIVE, 0, MAKELONG((WORD)pt.x, (WORD)pt.y));

        if (chDrive)
            return chDrive;

        hwnd = GetParent(hwnd); // try the next higher up
    }

    return 0;
}

BOOL
IsNetPath(
         PDNODE pNode
         )
{
    CHAR szPath[MAXPATHLEN];
    INT i;

    if (pNode->iNetType == -1) {

        GetTreePath(pNode, szPath);

        if (WNetGetDirectoryType((LPSTR)szPath, (LPDWORD)&i, TRUE) == WN_SUCCESS)
            pNode->iNetType = i;
        else
            pNode->iNetType = 0;
    }
    return pNode->iNetType;
}


VOID
TCWP_DrawItem(
             LPDRAWITEMSTRUCT lpLBItem,
             HWND hwndLB,
             HWND hWnd
             )
{
    INT               x, y, dx, dy;
    INT               nLevel;
    HDC               hdc;
    WORD              len;
    RECT              rc;
    BOOL              bHasFocus, bDrawSelected;
    PDNODE            pNode, pNTemp;
    DWORD             rgbText;
    DWORD             rgbBackground;
    HBRUSH            hBrush, hOld;
    INT iBitmap;
    WORD view;
    CHAR      szPath[MAXPATHLEN];

    ENTER("TCWP_DrawItem");

    if (lpLBItem->itemID == (DWORD)-1) {
        return;
    }

    hdc = lpLBItem->hDC;
    pNode = (PDNODE)lpLBItem->itemData;

    lstrcpy(szPath, pNode->szName);
    if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
        AnsiLower(szPath);

    len = (WORD)lstrlen(szPath);
    MGetTextExtent(hdc, szPath, len, &dx, NULL);
    dx += dyBorder;

    rc = lpLBItem->rcItem;
    rc.left = pNode->nLevels * dxText * 2;
    rc.right = rc.left + dxFolder + dx + 4 * dyBorderx2;

    if (lpLBItem->itemAction & (ODA_DRAWENTIRE | ODA_SELECT)) {

        // draw the branches of the tree first

        nLevel = pNode->nLevels;

        x = (nLevel * dxText * 2) - dxText + dyBorderx2;
        dy = lpLBItem->rcItem.bottom - lpLBItem->rcItem.top;
        y = lpLBItem->rcItem.top + (dy/2);

        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT))) {

            hOld = SelectObject(hdc, hBrush);

            if (pNode->pParent) {
                /* Draw the horizontal line over to the (possible) folder. */
                PatBlt(hdc, x, y, dyText, dyBorder, PATCOPY);

                /* Draw the top part of the vertical line. */
                PatBlt(hdc, x, lpLBItem->rcItem.top, dyBorder, dy/2, PATCOPY);

                /* If not the end of a node, draw the bottom part... */
                if (!(pNode->wFlags & TF_LASTLEVELENTRY))
                    PatBlt(hdc, x, y+dyBorder, dyBorder, dy/2, PATCOPY);

                /* Draw the verticals on the left connecting other nodes. */
                pNTemp = pNode->pParent;
                while (pNTemp) {
                    nLevel--;
                    if (!(pNTemp->wFlags & TF_LASTLEVELENTRY))
                        PatBlt(hdc, (nLevel * dxText * 2) - dxText + dyBorderx2,
                               lpLBItem->rcItem.top, dyBorder,dy, PATCOPY);

                    pNTemp = pNTemp->pParent;
                }
            }

            if (hOld)
                SelectObject(hdc, hOld);

            DeleteObject(hBrush);
        }

        bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);
        bHasFocus = (GetFocus() == lpLBItem->hwndItem);

        // draw text with the proper background or rect

        if (bHasFocus && bDrawSelected) {
            rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
            rgbBackground = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        }

        ExtTextOut(hdc, x + dxText + dxFolder + 2 * dyBorderx2,
                   y-(dyText/2), ETO_OPAQUE, &rc,
                   szPath, len, NULL);

        // draw the bitmaps as needed

        // HACK: Don't draw the bitmap when moving

        if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

            // Blt the proper folder bitmap

            view = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

            if (bNetAdmin && IsNetPath(pNode)) {
                // we need this bitmap from lisa
                if (bDrawSelected)
                    iBitmap = BM_IND_OPENDFS;
                else
                    iBitmap = BM_IND_CLOSEDFS;

            } else if (!(view & VIEW_PLUSES) || !(pNode->wFlags & TF_HASCHILDREN)) {
                if (bDrawSelected)
                    iBitmap = BM_IND_OPEN;
                else
                    iBitmap = BM_IND_CLOSE;
            } else {
                if (pNode->wFlags & TF_EXPANDED) {
                    if (bDrawSelected)
                        iBitmap = BM_IND_OPENMINUS;
                    else
                        iBitmap = BM_IND_CLOSEMINUS;
                } else {
                    if (bDrawSelected)
                        iBitmap = BM_IND_OPENPLUS;
                    else
                        iBitmap = BM_IND_CLOSEPLUS;
                }
            }
            BitBlt(hdc, x + dxText + dyBorder, y-(dyFolder/2), dxFolder, dyFolder,
                   hdcMem, iBitmap * dxFolder, (bHasFocus && bDrawSelected) ? dyFolder : 0, SRCCOPY);
        }

        // restore text stuff and draw rect as required

        if (bDrawSelected) {
            if (bHasFocus) {
                SetTextColor(hdc, rgbText);
                SetBkColor(hdc, rgbBackground);
            } else {
                HBRUSH hbr;
                if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                    FrameRect(hdc, &rc, hbr);
                    DeleteObject(hbr);
                }
            }
        }


    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        DrawFocusRect(hdc, &rc);

}

/* A helper for both ExpandLevel and TreeCtlWndProc.TC_COLLAPSELEVEL.
 * Code moved from TreeCtlWndProc to be shared.  EDH 13 Oct 91
 */
VOID
CollapseLevel(
             HWND hwndLB,
             PDNODE pNode,
             INT nIndex
             )
{
    DWORD_PTR dwTemp;
    PDNODE pParentNode = pNode;
    INT nIndexT = nIndex;

    /* Disable redrawing early. */
    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

    nIndexT++;

    /* Remove all subdirectories. */

    while (TRUE) {
        /* Make sure we don't run off the end of the listbox. */
        if (SendMessage(hwndLB, LB_GETTEXT, nIndexT, (LPARAM)&dwTemp) == LB_ERR)
            break;

        pNode = (PDNODE)dwTemp;

        if (pNode->nLevels <= pParentNode->nLevels)
            break;

        LocalFree((HANDLE)pNode);

        SendMessage(hwndLB, LB_DELETESTRING, nIndexT, 0L);
    }

    pParentNode->wFlags &= ~TF_EXPANDED;
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    InvalidateRect(hwndLB, NULL, TRUE);

}


VOID
ExpandLevel(
           HWND hWnd,
           WORD wParam,
           INT nIndex,
           PSTR szPath
           )
{
    HWND hwndLB;
    DWORD_PTR dwTemp;
    PDNODE pNode;
    INT iNumExpanded;
    INT iBottomIndex;
    INT iTopIndex;
    INT iNewTopIndex;
    INT iExpandInView;
    INT iCurrentIndex;
    RECT rc;

    if (GetWindowLong(hWnd, GWL_READLEVEL))
        return;

    hwndLB = GetDlgItem(hWnd, IDCW_TREELISTBOX);

    if (nIndex == -1)
        if ((nIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L)) == LB_ERR)
            return;

    SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&dwTemp);
    pNode = (PDNODE)dwTemp;

    // collapse the current contents so we avoid doubling existing "plus" dirs

    if (pNode->wFlags & TF_EXPANDED) {
        if (wParam)
            CollapseLevel(hwndLB, pNode, nIndex);
        else
            return;
    }

    GetTreePath(pNode, szPath);

    StripBackslash(szPath);   // remove the slash

    cNodes = 0;
    bCancelTree = FALSE;

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);   // Disable redrawing.

    iCurrentIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
    iNumExpanded = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    iTopIndex = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
    GetClientRect(hwndLB, &rc);
    iBottomIndex = iTopIndex + (rc.bottom+1) / dyFileName;

    if (IsTheDiskReallyThere(hWnd, szPath, FUNC_EXPAND))
        ReadDirLevel(hWnd, pNode, szPath, (WORD)(pNode->nLevels + 1), nIndex,
                     (DWORD)(ATTR_DIR | (GetWindowLong(GetParent(hWnd), GWL_ATTRIBS) & ATTR_HS)),
                     (BOOL)wParam, szNULL);

    // this is how many will be in view

    iExpandInView = (iBottomIndex - (INT)iCurrentIndex);

    iNumExpanded = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) - iNumExpanded;

    if (iNumExpanded >= iExpandInView) {

        iNewTopIndex = min((INT)iCurrentIndex, iTopIndex + iNumExpanded - iExpandInView + 1);

        SendMessage(hwndLB, LB_SETTOPINDEX, (WORD)iNewTopIndex, 0L);
    }

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);

    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

    if (iNumExpanded)
        InvalidateRect(hwndLB, NULL, TRUE);

    // Redraw the Status Bar

    UpdateStatus(GetParent(hWnd));
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  TreeControlWndProc() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* WndProc for the directory tree control. */

INT_PTR
APIENTRY
TreeControlWndProc(
                  register HWND hWnd,
                  UINT wMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    WORD      iSel;
    INT       i, j;
    WPARAM    nIndex;
    DWORD     dwTemp;
    PDNODE     pNode, pNodeNext;
    HWND      hwndLB;
    CHAR      szPath[MAXPATHLEN];

    STKCHK();

    hwndLB = GetDlgItem(hWnd, IDCW_TREELISTBOX);

    switch (wMsg) {
        case FS_GETDRIVE:
            MSG("TreeControlWndProc", "FS_GETDRIVE");
            return (GetWindowLong(GetParent(hWnd), GWL_TYPE) + 'A');

        case TC_COLLAPSELEVEL:
            MSG("TreeControlWndProc", "TC_COLLAPSELEVEL");
            {
                PDNODE     pParentNode;

                if (wParam)
                    nIndex = wParam;
                else {
                    nIndex = SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (nIndex == LB_ERR)
                        break;
                }

                SendMessage(hwndLB, LB_GETTEXT, nIndex, (LPARAM)&pParentNode);

                // short circuit if we are already in this state

                if (!(pParentNode->wFlags & TF_EXPANDED))
                    break;

                CollapseLevel(hwndLB, pParentNode, (int)nIndex);

                break;
            }

        case TC_EXPANDLEVEL:
            MSG("TreeControlWndProc", "TC_EXPANDLEVEL");
            ExpandLevel(hWnd, (WORD)wParam, (INT)-1, szPath);
            break;

        case TC_TOGGLELEVEL:
            MSG("TreeControlWndProc", "TC_TOGGLELEVEL");

            // don't do anything while the tree is being built

            if (GetWindowLong(hWnd, GWL_READLEVEL))
                return 1;

            SendMessage(hwndLB, LB_GETTEXT, (WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L), (LPARAM)&pNode);

            if (pNode->wFlags & TF_EXPANDED)
                wMsg = TC_COLLAPSELEVEL;
            else
                wMsg = TC_EXPANDLEVEL;

            SendMessage(hWnd, wMsg, FALSE, 0L);
            break;

        case TC_GETDIR:
            // get a full path for a particular dir
            // wParam is the listbox index of path to get
            // lParam LOWORD is PSTR to buffer to fill in

            MSG("TreeControlWndProc", "TC_GETDIR");

            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&pNode);
            GetTreePath(pNode, (LPSTR)lParam);
            break;

        case TC_SETDIRECTORY:
            MSG("TreeControlWndProc", "TC_SETDIRECTORY");
            // set the selection in the tree to that for a given path

            {
                i = (INT)FindItemFromPath(hwndLB, (LPSTR)lParam, wParam ? TRUE : FALSE, NULL);

                if (i != -1)
                    SendMessage(hwndLB, LB_SETCURSEL, i, 0L);

                break;
            }

        case TC_SETDRIVE:
#define fFullyExpand    LOBYTE(wParam)
#define fDontSteal      HIBYTE(wParam)
#define szDir           (LPSTR)lParam  // NULL -> default == window text.

            MSG("TreeControlWndProc", "TC_SETDRIVE");

            {
                RECT rc;

                if (GetWindowLong(hWnd, GWL_READLEVEL))
                    break;

                // is the drive/dir specified?

                if (szDir) {
                    lstrcpy(szPath, szDir);                  // yes, use it
                } else {
                    SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath); // no, use current
                    StripBackslash(szPath);
                }


                AnsiUpperBuff(szPath, 1);     // make sure

                SetWindowLong(GetParent(hWnd), GWL_TYPE, 2);

                // resize for new vol label

                GetClientRect(GetParent(hWnd), &rc);
                SendMessage(GetParent(hWnd), WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));

                // ensure the disk is available if the whole dir structure is
                // to be expanded

                if (!fFullyExpand || IsTheDiskReallyThere(hWnd, szPath, FUNC_EXPAND))
                    FillTreeListbox(hWnd, szPath, fFullyExpand, fDontSteal);

                // and force the dir half to update with a fake SELCHANGE message

                SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(IDCW_TREELISTBOX, hWnd, LBN_SELCHANGE));
                break;
#undef fFullyExpand
#undef fDontSteal
#undef szDir
            }

        case WM_CHARTOITEM:
            MSG("TreeControlWndProc", "WM_CHARTOITEM");
            {
                WORD      w;
                CHAR      szB[2];
                INT       cItems;
                CHAR      ch;

                if (GET_WM_CHARTOITEM_CHAR(wParam, lParam) == '\\')   // backslash means the root
                    return 0L;

                cItems = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
                i = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);

                ch = GET_WM_CHARTOITEM_CHAR(wParam, lParam);
                if (i < 0 || ch <= ' ')       // filter all other control chars
                    return -2L;

                szB[1] = 0L;
                ch &= 255;

                for (j=1; j < cItems; j++) {
                    SendMessage(hwndLB, LB_GETTEXT, (i+j) % cItems, (LPARAM)&pNode);
                    szB[0] = pNode->szName[0];

                    /* Do it this way to be case insensitive. */
                    w = ch;
                    if (!lstrcmpi((LPSTR)&w, szB))
                        break;
                }

                if (j == cItems)
                    return -2L;

                SendMessage(hwndLB, LB_SETTOPINDEX, (i+j) % cItems, 0L);
                return((i+j) % cItems);
            }

        case WM_DESTROY:
            MSG("TreeControlWndProc", "WM_DESTROY");
            if (hwndLB == GetFocus()) {
                HWND hwnd;

                if (hwnd = HasDirWindow(GetParent(hWnd)))
                    SetFocus(hwnd);
                else
                    SetFocus(HasDrivesWindow(GetParent(hWnd)));
            }
            FreeAllTreeData(hwndLB);
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "TreeControlWndProc - WM_CREATE");
            // create the owner draw list box for the tree
            {
                HWND hwnd;

                hwnd = CreateWindowEx(0L, szListbox, NULL, WS_TREESTYLE | WS_BORDER,
                                      0, 0, 0, 0, hWnd, (HMENU)IDCW_TREELISTBOX, hAppInstance, NULL);

                if (!hwnd)
                    return -1L;

                SendMessage(hwnd, WM_SETFONT, (WPARAM)hFont, 0L);

                SetWindowLong(hWnd, GWL_READLEVEL, 0);
                break;
            }

        case WM_DRAWITEM:
            MSG("TreeControlWndProc", "WM_DRAWITEM");
            TCWP_DrawItem((LPDRAWITEMSTRUCT)lParam, hwndLB, hWnd);
            break;

        case WM_FILESYSCHANGE:
            MSG("TreeControlWndProc", "WM_FILESYSCHANGE");
            {
                HWND hwndParent;
                PDNODE pNodePrev;
                PDNODE pNodeT;

                if (!lParam || wParam == FSC_REFRESH)
                    break;

                nIndex = FindItemFromPath(hwndLB, (LPSTR)lParam, wParam == FSC_MKDIR, &pNode);

                if (nIndex == 0xFFFF)   /* Did we find it? */
                    break;

                lstrcpy(szPath, (LPSTR)lParam);
                StripPath(szPath);

                switch (wParam) {
                    case FSC_MKDIR:

                        // auto expand the branch so they can see the new
                        // directory just created

                        if (!(pNode->wFlags & TF_EXPANDED) &&
                            (nIndex == (WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L)))
                            SendMessage(hWnd, TC_EXPANDLEVEL, FALSE, 0L);

                        // make sure this node isn't already here


                        if (FindItemFromPath(hwndLB, (LPSTR)lParam, FALSE, NULL) != 0xFFFF)
                            break;

                        // Insert it into the tree listbox

                        dwTemp = InsertDirectory(hWnd, pNode, (WORD)nIndex, szPath, &pNodeT);

                        // Add a plus if necessary

                        hwndParent = GetParent(hWnd);
                        if (GetWindowLong(hwndParent, GWL_VIEW) & VIEW_PLUSES) {
                            lstrcpy(szPath, (LPSTR)lParam);
                            ScanDirLevel((PDNODE)pNodeT, szPath, ATTR_DIR |
                                         (GetWindowLong(hwndParent, GWL_ATTRIBS) & ATTR_HS));

                            // Invalidate the window so the plus gets drawn if needed

                            if (((PDNODE)pNodeT)->wFlags & TF_HASCHILDREN)
                                InvalidateRect(hWnd, NULL, FALSE);
                        }

                        // if we are inserting before or at the current selection
                        // push the current selection down

                        nIndex = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                        if ((INT)LOWORD(dwTemp) <= nIndex) {
                            SendMessage(hwndLB, LB_SETCURSEL, nIndex + 1, 0L);
                        }

                        break;

                    case FSC_RMDIR:
                        if (nIndex == 0)      /* NEVER delete the Root Dir! */
                            break;

                        if (pNode->wFlags & TF_LASTLEVELENTRY) {
                            // We are deleting the last subdirectory.
                            // If there are previous sibling directories, mark one
                            // as the last, else mark the parent as empty and unexpanded.
                            // It is necessary to do these checks if this bit
                            // is set, since if it isn't, there is another sibling
                            // with TF_LASTLEVELENTRY set, and so the parent is nonempty.
                            //
                            // Find the previous entry which has a level not deeper than
                            // the level of that being deleted.
                            i = (int)nIndex;
                            do {
                                SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodePrev);
                            } while (pNodePrev->nLevels > pNode->nLevels);

                            if (pNodePrev->nLevels == pNode->nLevels) {
                                // The previous directory is a sibling... it becomes
                                // the new last level entry.
                                pNodePrev->wFlags |= TF_LASTLEVELENTRY;
                            } else {
                                // In order to find this entry, the parent must have
                                // been expanded, so if the parent of the deleted dir
                                // has no listbox entries under it, it may be assumed that
                                // the directory has no children.
                                pNodePrev->wFlags &= ~(TF_HASCHILDREN | TF_EXPANDED);
                            }
                        }

                        // Are we deleting the current selection?
                        // if so we move the selection to the item above the current.
                        // this should work in all cases because you can't delete
                        // the root.

                        if ((WPARAM)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L) == nIndex) {
                            SendMessage(hwndLB, LB_SETCURSEL, nIndex - 1, 0L);
                            SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(0, 0, LBN_SELCHANGE));
                        }

                        SendMessage(hWnd, TC_COLLAPSELEVEL, nIndex, 0L);
                        SendMessage(hwndLB, LB_DELETESTRING, nIndex, 0L);

                        LocalFree((HANDLE)pNode);
                        break;
                }
                break;
            }

        case WM_COMMAND:
            {
                WORD id;

                id = GET_WM_COMMAND_ID(wParam, lParam);
                switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                    case LBN_SELCHANGE:
                        MSG("TreeControlWndProc", "LBN_SELCHANGE");
                        {
                            HWND hwndParent;
                            HWND hwndDir;
                            INT CurSel;

                            hwndParent = GetParent(hWnd);

                            CurSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                            SendMessage(hWnd, TC_GETDIR, CurSel,(LPARAM)szPath);
                            AddBackslash(szPath);
                            SendMessage(hwndParent, FS_GETFILESPEC,  sizeof(szPath) - lstrlen(szPath), (LPARAM)szPath+lstrlen(szPath));

                            if (hwndDir = HasDirWindow(hwndParent)) {
                                // update the dir window

                                id = CD_PATH;

                                // don't allow abort on first or last directories


                                if (CurSel > 0 &&
                                    CurSel != ((INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) - 1)) {
                                    id = CD_PATH | CD_ALLOWABORT;

                                }
                                SendMessage(hwndDir, FS_CHANGEDISPLAY, id, (LPARAM)szPath);

                            } else {
                                SetMDIWindowText(hwndParent, szPath);
                            }

                            UpdateStatus(hwndParent);
                            break;
                        }

                    case LBN_DBLCLK:
                        MSG("TreeControlWndProc", "LBN_DBLCLK");
                        SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
                        break;

                    case LBN_SETFOCUS:
                        MSG("TreeControlWndProc", "LBN_SETFOCUS");
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateStatus(GetParent(hWnd));  // update the status bar
                        break;

                    case LBN_KILLFOCUS:
                        MSG("TreeControlWndProc", "LBN_KILLFOCUS");
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0);
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        break;
                }
            }
            break;


        case WM_LBTRACKPOINT:
            MSG("TreeControlWndProc", "WM_LBTRACKPOINT");
            // wParam is the listbox index that we are over
            // lParam is the mouse point

            /* Return 0 to do nothing, 1 to abort everything, or 2 to abort just dblclicks. */

            {
                HDC       hdc;
                INT       dx;
                INT       xNode;
                MSG       msg;
                RECT      rc;
                HFONT     hOld;
                POINT     pt;
                DRAGOBJECTDATA dodata;

                /* Someone clicked somewhere in the listbox. */

                // don't do anything while the tree is being built

                if (GetWindowLong(hWnd, GWL_READLEVEL))
                    return 1;

                /* Get the node they clicked on. */
                SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&pNode);
                lstrcpy(szPath, pNode->szName);
                if ((wTextAttribs & TA_LOWERCASE) && !(pNode->wFlags & TF_LFN))
                    AnsiLower(szPath);

                //        if (pNode->wFlags | TF_DISABLED)
                //              return 2L;

                // too FAR to the left?

                i = LOWORD(lParam);

                xNode = pNode->nLevels * dxText * 2;
                if (i < xNode)
                    return 2; // yes, get out now

                // too FAR to the right?

                hdc = GetDC(hwndLB);
                hOld = SelectObject(hdc, hFont);
                MGetTextExtent(hdc, szPath, lstrlen(szPath), &dx, NULL);
                dx += (dyBorderx2*2);
                if (hOld)
                    SelectObject(hdc, hOld);
                ReleaseDC(hwndLB, hdc);

                if (i > xNode + dxFolder + dx + 4 * dyBorderx2)
                    return 2; // yes

                // Emulate a SELCHANGE notification and notify our parent
                SendMessage(hwndLB, LB_SETCURSEL, wParam, 0L);
                SendMessage(hWnd, WM_COMMAND, GET_WM_COMMAND_MPS(0, hwndLB, LBN_SELCHANGE));

                // make sure mouse still down

                if (!(GetKeyState(VK_LBUTTON) & 0x8000))
                    return 1;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                ClientToScreen(hwndLB, (LPPOINT)&pt);
                ScreenToClient(hWnd, (LPPOINT)&pt);


                SetRect(&rc, pt.x - dxClickRect, pt.y - dyClickRect,
                        pt.x + dxClickRect, pt.y + dyClickRect);

                SetCapture(hWnd);
                while (GetMessage(&msg, NULL, 0, 0)) {

                    DispatchMessage(&msg);
                    if (msg.message == WM_LBUTTONUP)
                        break;

                    MPOINT2POINT(MAKEMPOINT(msg.lParam), pt);

                    if (GetCapture() != hWnd) {
                        msg.message = WM_LBUTTONUP;
                        break;
                    }

                    if ((msg.message == WM_MOUSEMOVE) && !(PtInRect(&rc, pt)))
                        break;
                }
                ReleaseCapture();

                /* Did the guy NOT drag anything? */
                if (msg.message == WM_LBUTTONUP)
                    return 1;

                /* Enter Danger Mouse's BatCave. */
                SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                StripBackslash(szPath);
                hwndDragging = hwndLB;
                iCurDrag = SINGLECOPYCURSOR;
                dodata.pch = szPath;
                dodata.hMemGlobal = 0;
                DragObject(hwndMDIClient, hWnd, (UINT)DOF_DIRECTORY, (DWORD)(ULONG_PTR)&dodata, LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag)));
                hwndDragging = NULL;
                fShowSourceBitmaps = TRUE;
                InvalidateRect(hwndLB, NULL, FALSE);

                return 2;
            }

        case WM_DRAGSELECT:
            MSG("TreeControlWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent whenever a new window returns TRUE to a
             * QUERYDROPOBJECT.
             */
            iSelHilite = LOWORD(((LPDROPSTRUCT)lParam)->dwControlData);
            RectTreeItem(hwndLB, iSelHilite, (BOOL)wParam);
            break;

        case WM_DRAGMOVE:
            MSG("TreeControlWndProc", "WM_DRAGMOVE");

            /* WM_DRAGMOVE is sent when two consequetive TRUE QUERYDROPOBJECT
             * messages come from the same window.
             */

            /* Get the subitem we are over. */
            iSel = LOWORD(((LPDROPSTRUCT)lParam)->dwControlData);

            /* Is it a new one? */
            if (iSel == (WORD)iSelHilite)
                break;

            /* Yup, un-select the old item. */
            RectTreeItem(hwndLB, iSelHilite, FALSE);

            /* Select the new one. */
            iSelHilite = iSel;
            RectTreeItem(hwndLB, iSel, TRUE);
            break;

        case WM_DRAGLOOP:
            MSG("TreeControlWndProc", "WM_DRAGLOOP");

            // wParam     TRUE on dropable target
            //            FALSE not dropable target
            // lParam     lpds
            {
                BOOL bCopy;

#define lpds ((LPDROPSTRUCT)lParam)

                /* Are we over a drop-able sink? */
                if (wParam) {
                    if (GetKeyState(VK_CONTROL) < 0)      // CTRL
                        bCopy = TRUE;
                    else if (GetKeyState(VK_MENU)<0 || GetKeyState(VK_SHIFT)<0)   // ALT || SHIFT
                        bCopy = FALSE;
                    else
                        bCopy = (GetDrive(lpds->hwndSink, lpds->ptDrop) != GetDrive(lpds->hwndSource, lpds->ptDrop));
                } else {
                    bCopy = TRUE;
                }

                if (bCopy != fShowSourceBitmaps) {
                    RECT  rc;

                    fShowSourceBitmaps = bCopy;

                    iSel = (WORD)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);

                    if (!(BOOL)SendMessage(hwndLB, LB_GETITEMRECT, iSel, (LPARAM)&rc))
                        break;

                    InvalidateRect(hwndLB, &rc, FALSE);
                    UpdateWindow(hwndLB);

                    // hack, set the cursor to match the move/copy state
                    if (wParam)
                        SetCursor(GetMoveCopyCursor());
                }
                break;
            }

        case WM_QUERYDROPOBJECT:
            MSG("TreeControlWndProc", "WM_QUERYDROPOBJECT");
            // wParam     TRUE on NC area
            //            FALSE on client area
            // lParam     lpds

            // Do nothing
            return(FALSE);

#define lpds ((LPDROPSTRUCT)lParam)

            /* Check for valid format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DOCUMENT:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                    if (fShowSourceBitmaps)
                        i = iCurDrag | 1;       // copy
                    else
                        i = iCurDrag & 0xFFFE;
                    break;

                default:
                    return FALSE;
            }

            /* Must be dropping on the listbox client area. */
            if (lpds->hwndSink != hwndLB)
                return FALSE;

            if (LOWORD(lpds->dwControlData) == 0xFFFF)
                return FALSE;

            return (INT_PTR)GetMoveCopyCursor();

        case WM_DROPOBJECT:       // tree being dropped on do your thing
#define lpds ((LPDROPSTRUCT)lParam) // BUG: WM_DROPOBJECT structure packing!

            // Do nothing
            return(TRUE);

            MSG("TreeControlWndProc", "WM_DROPOBJECT");

            // dir (search) drop on tree:
            //    HIWORD(dwData)  0
            //    LOWORD(dwData)  LPSTR to files being dragged
            //
            // tree drop on tree:
            //    HIWORD(dwData)  index of source drag
            //    LOWORD(dwData)  LPSTR to path

            {
                LPSTR      pFrom;

                nIndex = LOWORD(lpds->dwControlData);
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

                // Get the destination

                SendMessage(hWnd, TC_GETDIR, nIndex, (LPARAM)szPath);
                CheckEscapes(szPath);

                // if source and dest are the same make this a NOP

                if (!lstrcmpi(szPath, pFrom))
                    return TRUE;

                AddBackslash(szPath);
                lstrcat(szPath, szStarDotStar);

                DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

                RectTreeItem(hwndLB, (int)nIndex, FALSE);
            }
            return TRUE;
#undef lpds

        case WM_MEASUREITEM:
            MSG("TreeControlWndProc", "WM_MEASUREITEM");
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

            pLBMItem->itemHeight = (WORD)dyFileName;
            break;

        case WM_VKEYTOITEM:
            MSG("TreeControlWndProc", "WM_VKEYTOITEM");
            if (wParam == VK_ESCAPE) {
                bCancelTree = TRUE;
                return -2L;
            }

            i = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
            if (i < 0)
                return -2L;

            j = 1;
            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&pNode);

            switch (GET_WM_VKEYTOITEM_ITEM(wParam, lParam)) {
                case VK_LEFT:
                    while (SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodeNext) != LB_ERR) {
                        if (pNode == pNode->pParent)
                            return(i);
                    }
                    goto SameSelection;

                case VK_RIGHT:
                    if ((SendMessage(hwndLB, LB_GETTEXT, i+1, (LPARAM)&pNodeNext) == LB_ERR)
                        || (pNodeNext->pParent != pNode)) {
                        goto SameSelection;
                    }
                    return(i+1);

                case VK_UP:
                    j = -1;
                    /** FALL THRU ***/

                case VK_DOWN:
                    /* If the control key is not down, use default behavior. */
                    if (GetKeyState(VK_CONTROL) >= 0)
                        return(-1L);

                    while (SendMessage(hwndLB, LB_GETTEXT, i += j, (LPARAM)&pNodeNext) != LB_ERR) {
                        if (pNodeNext->pParent == pNode->pParent)
                            return(i);
                    }

                    SameSelection:
                    MessageBeep(0);
                    return(-2L);

                case VK_F6:       // like excel
                case VK_TAB:
                    {
                        HWND hwndDir, hwndDrives;
                        BOOL bDir;

                        GetTreeWindows(GetParent(hWnd), NULL, &hwndDir, &hwndDrives);

                        // Check to see if we can change to the directory window

                        if (hwndDir) {
                            HWND L_hwndLB; /* Local scope ONLY */

                            L_hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
                            if (L_hwndLB) {
                                SendMessage (L_hwndLB,LB_GETTEXT,0, (LPARAM) &pNode);
                                bDir = pNode ? TRUE : FALSE;
                            }
                        }

                        if (GetKeyState(VK_SHIFT) < 0)
                            SetFocus(hwndDrives);
                        else
                            if (bDir)
                            SetFocus (hwndDir);
                        else
                            SetFocus (hwndDrives);
                        return -2L;   // I dealt with this!
                    }

                case VK_BACK:
                    {
                        BYTE nStartLevel;

                        if (i <= 0)
                            return -2L;     // root case

                        nStartLevel = pNode->nLevels;

                        do {
                            SendMessage(hwndLB, LB_GETTEXT, --i, (LPARAM)&pNodeNext);
                        } while (i > 0 && pNodeNext->nLevels >= nStartLevel);

                        return i;
                    }

                default:
                    if (GetKeyState(VK_CONTROL) < 0)
                        return SendMessage(GetDlgItem(GetParent(hWnd), IDCW_DRIVES), wMsg, wParam, lParam);
                    return -1L;
            }
            break;

        case WM_SETFOCUS:
        case WM_LBUTTONDOWN:
            MSG("TreeControlWndProc", "WM_LBUTTONDOWN");
            SetFocus(hwndLB);
            break;

        case WM_SIZE:
            MSG("TreeControlWndProc", "WM_SIZE");
            if (!IsIconic(GetParent(hWnd))) {
                INT iMax;

                MoveWindow(hwndLB, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);

                iMax = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                if (iMax >= 0) {
                    RECT rc;
                    INT top, bottom;

                    GetClientRect(hwndLB, &rc);
                    top = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                    bottom = top + rc.bottom / dyFileName;
                    if (iMax < top || iMax > bottom)
                        SendMessage(hwndLB, LB_SETTOPINDEX, iMax - ((bottom - top) / 2), 0L);
                }
            }
            break;

        default:
            DEFMSG("TreeControlWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }
    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\object.h ===
VOID DisplayObjectInformation(HWND hwndParent, LPSTR lpstrObject);
LONG CalcAttributes(PUNICODE_STRING);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\object.c ===
/* object.c -
 *
 * Handles display of object attributes
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdio.h>

#include "winfile.h"
#include "object.h"

INT_PTR APIENTRY ObjectAttributesDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    ObjectInformationDlgInit(HWND, LPSTR);
HANDLE  OpenObject(HWND, LPSTR);
BOOL    GetObjectInfo(HWND, HANDLE);
VOID    CloseObject(HANDLE);

VOID    StripObjectPath(LPSTR lpszPath);
VOID    StripObjectSpec(LPSTR lpszPath);


// Define known object type names

#define DIRECTORYTYPE   L"Directory"
#define SYMLINKTYPE     L"SymbolicLink"
#define ADAPTERTYPE     L"Adapter"
#define CONTROLLERTYPE  L"Controller"
#define DEVICETYPE      L"Device"
#define DRIVERTYPE      L"Driver"
#define EVENTTYPE       L"Event"
#define EVENTPAIRTYPE   L"EventPair"
#define FILETYPE        L"File"
#define MUTANTTYPE      L"Mutant"
#define PORTTYPE        L"Port"
#define PROFILETYPE     L"Profile"
#define SECTIONTYPE     L"Section"
#define SEMAPHORETYPE   L"Semaphore"
#define TIMERTYPE       L"Timer"
#define TYPETYPE        L"Type"
#define PROCESSTYPE     L"Process"



VOID
DisplayObjectInformation(
                        HWND    hwndParent,
                        LPSTR   lpstrObject
                        )
{
    WNDPROC lpProc;
    HANDLE  hInst = hAppInstance;

    DialogBoxParam(hInst,(LPSTR)IDD_OBJATTRS, hwndParent, ObjectAttributesDlgProc, (LPARAM)lpstrObject);
}


INT_PTR
APIENTRY
ObjectAttributesDlgProc(
                       HWND hDlg,
                       UINT message,
                       WPARAM wParam,
                       LPARAM lParam
                       )
{
    switch (message) {

        case WM_INITDIALOG:

            if (!ObjectInformationDlgInit(hDlg, (HANDLE)lParam)) {
                // Failed to initialize dialog, get out
                EndDialog(hDlg, FALSE);
            }

            return (TRUE);

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    // we're done, drop through to quit dialog....

                case IDCANCEL:

                    //MainDlgEnd(hDlg, LOWORD(wParam) == IDOK);

                    EndDialog(hDlg, TRUE);
                    return TRUE;
                    break;

                default:
                    // We didn't process this message
                    return FALSE;
                    break;
            }
            break;

        default:
            // We didn't process this message
            return FALSE;

    }

    // We processed the message
    return TRUE;
}



BOOL
ObjectInformationDlgInit(
                        HWND    hwnd,
                        LPSTR   lpstrObject
                        )
{
    HANDLE      ObjectHandle;
    BOOL        Result;

    ObjectHandle = OpenObject(hwnd, lpstrObject);
    if (ObjectHandle == NULL) {
        return(FALSE);
    }

    Result = GetObjectInfo(hwnd, ObjectHandle);

    CloseObject(ObjectHandle);

    return(Result);
}


/* Open the object given only its name.
 * First find the object type by enumerating the directory entries.
 * Then call the type-specific open routine to get a handle
 */
HANDLE
OpenObject(
          HWND    hwnd,
          LPSTR   lpstrObject
          )
{
#define BUFFER_SIZE 1024

    NTSTATUS    Status;
    HANDLE      DirectoryHandle;
    ULONG       Context = 0;
    ULONG       ReturnedLength;
    CHAR        Buffer[BUFFER_SIZE];
    ANSI_STRING AnsiString;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    WCHAR       ObjectNameBuf[MAX_PATH];
    UNICODE_STRING ObjectName;
    WCHAR       ObjectTypeBuf[MAX_PATH];
    UNICODE_STRING ObjectType;
    HANDLE      ObjectHandle;
    OBJECT_ATTRIBUTES Attributes;
    UNICODE_STRING DirectoryName;
    IO_STATUS_BLOCK IOStatusBlock;

    //DbgPrint("Open object: raw full name = <%s>\n", lpstrObject);

    // Remove drive letter
    while ((*lpstrObject != 0) && (*lpstrObject != '\\')) {
        lpstrObject ++;
    }

    //DbgPrint("Open object: full name = <%s>\n", lpstrObject);

    // Initialize the object type buffer
    ObjectType.Buffer = ObjectTypeBuf;
    ObjectType.MaximumLength = sizeof(ObjectTypeBuf);

    // Initialize the object name string
    strcpy(Buffer, lpstrObject);
    StripObjectPath(Buffer);
    RtlInitAnsiString(&AnsiString, Buffer);

    ObjectName.Buffer = ObjectNameBuf;
    ObjectName.MaximumLength = sizeof(ObjectNameBuf);

    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, FALSE);
    ASSERT(NT_SUCCESS(Status));

    //DbgPrint("Open object: name only = <%wZ>\n", &ObjectName);

    //
    //  Open the directory for list directory access
    //

    strcpy(Buffer, lpstrObject);
    StripObjectSpec(Buffer);

    RtlInitAnsiString(&AnsiString, Buffer);
    Status = RtlAnsiStringToUnicodeString( &DirectoryName, &AnsiString, TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes( &Attributes,
                                &DirectoryName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    //DbgPrint("Open object: dir only = <%wZ>\n", &DirectoryName);

    if (!NT_SUCCESS( Status = NtOpenDirectoryObject( &DirectoryHandle,
                                                     STANDARD_RIGHTS_READ |
                                                     DIRECTORY_QUERY |
                                                     DIRECTORY_TRAVERSE,
                                                     &Attributes ) )) {

        if (Status == STATUS_OBJECT_TYPE_MISMATCH) {
            DbgPrint( "%wZ is not a valid Object Directory Object name\n",
                      &DirectoryName );
        } else {
            DbgPrint("OpenObject: failed to open directory, status = 0x%lx\n\r", Status);
        }

        RtlFreeUnicodeString(&DirectoryName);

        MessageBox(hwnd, "Unable to open object", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return NULL;
    }

    RtlFreeUnicodeString(&DirectoryName);


    //
    //  Query the entire directory in one sweep
    //
    ObjectType.Length = 0;

    for (Status = NtQueryDirectoryObject( DirectoryHandle,
                                          Buffer,
                                          sizeof(Buffer),
                                          // LATER FALSE,
                                          TRUE, // one entry at a time for now
                                          TRUE,
                                          &Context,
                                          &ReturnedLength );
        ObjectType.Length == 0;
        Status = NtQueryDirectoryObject( DirectoryHandle,
                                         Buffer,
                                         sizeof(Buffer),
                                         // LATER FALSE,
                                         TRUE, // one entry at a time for now
                                         FALSE,
                                         &Context,
                                         &ReturnedLength ) ) {
        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status != STATUS_NO_MORE_ENTRIES) {
                DbgPrint("OpenObject: failed to query directory object, status = 0x%lx\n\r", Status);
            }
            break;
        }

        //
        //  For every record in the buffer compare name with the one we're
        // looking for
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)Buffer;

        while (DirInfo->Name.Length != 0) {

            //
            //  Compare with object we're searching for
            //

            //DbgPrint("Found object <%wZ>\n", &(DirInfo->Name));

            if (RtlEqualString((PSTRING)&ObjectName, (PSTRING)&(DirInfo->Name), TRUE)) {
                RtlCopyString((PSTRING)&ObjectType, (PSTRING)&DirInfo->TypeName);
                break;
            }

            //
            //  Advance DirInfo to the next entry
            //

            DirInfo ++;
        }
    }

    if (ObjectType.Length == 0) {
        DbgPrint("Object not found in directory\n\r");
        MessageBox(hwnd, "Unable to open object", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        return(NULL);
    }

    // We now have the type of the object in ObjectType
    // We still have the full object name in lpstrObject
    // Use the appropriate open routine to get a handle

    ObjectHandle = NULL;

    RtlInitString(&AnsiString, lpstrObject);
    Status = RtlAnsiStringToUnicodeString(&ObjectName, &AnsiString, TRUE);
    ASSERT(NT_SUCCESS(Status));

    InitializeObjectAttributes(&Attributes,
                               &ObjectName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                              );

    switch (CalcAttributes(&ObjectType)) {

        case ATTR_SYMLINK:
            Status = NtOpenSymbolicLinkObject(&ObjectHandle,
                                              READ_CONTROL | SYMBOLIC_LINK_QUERY,
                                              &Attributes);
            break;

        case ATTR_EVENT:
            Status = NtOpenEvent(&ObjectHandle,
                                 READ_CONTROL,
                                 &Attributes);
            break;

        case ATTR_EVENTPAIR:
            Status = NtOpenEventPair(&ObjectHandle,
                                     READ_CONTROL,
                                     &Attributes);
            break;

        case ATTR_FILE:
            Status = NtOpenFile(&ObjectHandle,
                                READ_CONTROL,
                                &Attributes,
                                &IOStatusBlock,
                                FILE_SHARE_VALID_FLAGS,
                                0);
            break;

        case ATTR_MUTANT:
            Status = NtOpenMutant(&ObjectHandle,
                                  READ_CONTROL,
                                  &Attributes);
            break;

        case ATTR_SECTION:
            Status = NtOpenSection(&ObjectHandle,
                                   READ_CONTROL,
                                   &Attributes);
            break;

        case ATTR_SEMAPHORE:
            Status = NtOpenSemaphore(&ObjectHandle,
                                     READ_CONTROL,
                                     &Attributes);
            break;

        case ATTR_TIMER:
            Status = NtOpenTimer(&ObjectHandle,
                                 READ_CONTROL,
                                 &Attributes);
            break;

        case ATTR_PROCESS:
            Status = NtOpenProcess(&ObjectHandle,
                                   READ_CONTROL,
                                   &Attributes,
                                   NULL);
            break;

        default:
            DbgPrint("No open routine for this object type\n\r");
            MessageBox(hwnd, "I don't know how to open an object of this type", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
            Status = 0;
            break;
    }

    if (!NT_SUCCESS(Status)) {
        DbgPrint("Type specific open failed, status = 0x%lx\n\r", Status);
        MessageBox(hwnd, "Object open failed", NULL, MB_ICONSTOP | MB_APPLMODAL | MB_OK);
        ObjectHandle = NULL;
    }

    RtlFreeUnicodeString(&ObjectName);

    return(ObjectHandle);
}


VOID
CloseObject(
           HANDLE  ObjectHandle
           )
{
    NtClose(ObjectHandle);
}


BOOL
GetObjectInfo(
             HWND    hwnd,
             HANDLE  ObjectHandle
             )
{
    NTSTATUS    Status;
    OBJECT_BASIC_INFORMATION    BasicInfo;
    OBJECT_TYPE_INFORMATION    TypeInfo;
    WCHAR TypeName[ 64 ];
#define BUFFER_SIZE 1024
    CHAR        Buffer[BUFFER_SIZE];
    STRING      String;
    TIME_FIELDS TimeFields;
    WCHAR       UnicodeBuffer[BUFFER_SIZE];
    UNICODE_STRING UnicodeString;

    //
    // Name
    //

    Status = NtQueryObject(ObjectHandle, ObjectNameInformation,
                           (PVOID)Buffer, sizeof(Buffer), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get name info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    Status = RtlUnicodeStringToAnsiString(&String, &(((POBJECT_NAME_INFORMATION)Buffer)->Name), TRUE);
    ASSERT(NT_SUCCESS(Status));

    SetDlgItemText(hwnd, IDS_NAME, String.Buffer);

    RtlFreeAnsiString(&String);


    //
    // Type
    //

    Status = NtQueryObject(ObjectHandle, ObjectTypeInformation,
                           (PVOID)Buffer, sizeof(Buffer), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get type info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    Status = RtlUnicodeStringToAnsiString(&String, &(((POBJECT_TYPE_INFORMATION)Buffer)->TypeName), TRUE);
    ASSERT(NT_SUCCESS(Status));

    SetDlgItemText(hwnd, IDS_TYPE, String.Buffer);

    RtlFreeAnsiString(&String);


    //
    // Symbolic link target if this is a symlink
    //

    RtlInitUnicodeString(&UnicodeString, SYMLINKTYPE);

    if (RtlEqualString((PSTRING)&UnicodeString,
                       (PSTRING)&(((POBJECT_TYPE_INFORMATION)Buffer)->TypeName), TRUE)) {

        ShowWindow(GetDlgItem(hwnd, IDS_OTHERLABEL), SW_SHOWNOACTIVATE);
        ShowWindow(GetDlgItem(hwnd, IDS_OTHERTEXT), SW_SHOWNOACTIVATE);

        UnicodeString.Buffer = UnicodeBuffer;
        UnicodeString.MaximumLength = sizeof(UnicodeBuffer);

        Status = NtQuerySymbolicLinkObject(ObjectHandle, &UnicodeString, NULL);

        if (!NT_SUCCESS(Status)) {
            DbgPrint("GetObjectInfo: Failed to query symbolic link target, status = 0x%lx\n\r", Status);
            return(FALSE);
        }

        RtlUnicodeStringToAnsiString(&String, &UnicodeString, TRUE);

        SetDlgItemText(hwnd, IDS_OTHERTEXT, String.Buffer);

        RtlFreeAnsiString(&String);
    }


    //
    // Basic info
    //

    Status = NtQueryObject(ObjectHandle, ObjectBasicInformation,
                           (PVOID)&BasicInfo, sizeof(BasicInfo), NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get basic info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    TypeInfo.TypeName.Buffer = TypeName;
    TypeInfo.TypeName.MaximumLength = sizeof( TypeName );
    Status = NtQueryObject(ObjectHandle, ObjectTypeInformation,
                           (PVOID)&TypeInfo, sizeof(TypeInfo) + TypeInfo.TypeName.MaximumLength, NULL);

    if (!NT_SUCCESS(Status)) {
        DbgPrint("GetObjectInfo: Failed to get type info, status = 0x%lx\n\r", Status);
        return(FALSE);
    }

    CheckDlgButton(hwnd, IDCB_INHERIT, (BasicInfo.Attributes & OBJ_INHERIT) != 0);
    CheckDlgButton(hwnd, IDCB_PERMANENT, (BasicInfo.Attributes & OBJ_PERMANENT) != 0);
    CheckDlgButton(hwnd, IDCB_EXCLUSIVE, (BasicInfo.Attributes & OBJ_EXCLUSIVE) != 0);

    SetDlgItemInt(hwnd, IDS_PAGEDCHARGE, BasicInfo.PagedPoolCharge, FALSE);
    SetDlgItemInt(hwnd, IDS_NONPAGEDCHARGE, BasicInfo.NonPagedPoolCharge, FALSE);
    SetDlgItemInt(hwnd, IDS_HANDLES, BasicInfo.HandleCount, FALSE);
    SetDlgItemInt(hwnd, IDS_TOTALHANDLES, TypeInfo.TotalNumberOfHandles, FALSE);
    SetDlgItemInt(hwnd, IDS_POINTERS, BasicInfo.PointerCount, FALSE);
    SetDlgItemInt(hwnd, IDS_TOTALPOINTERS, 0, FALSE);
    SetDlgItemInt(hwnd, IDS_COUNT, TypeInfo.TotalNumberOfObjects, FALSE);

    RtlTimeToTimeFields(&BasicInfo.CreationTime, &TimeFields);

    sprintf(Buffer, "%hd/%hd/%hd @ %02hd:%02hd:%02hd",
            TimeFields.Year, TimeFields.Month, TimeFields.Day,
            TimeFields.Hour, TimeFields.Minute, TimeFields.Second);

    SetDlgItemText(hwnd, IDS_CREATIONTIME, Buffer);

    return(TRUE);
}


/* Converts the type-name into an attribute value */

LONG
CalcAttributes(
              PUNICODE_STRING Type
              )
{
    UNICODE_STRING  TypeName;

    RtlInitUnicodeString(&TypeName, DIRECTORYTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DIR;
    }
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SYMLINK;
    }
    RtlInitUnicodeString(&TypeName, ADAPTERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_ADAPTER;
    }
    RtlInitUnicodeString(&TypeName, CONTROLLERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_CONTROLLER;
    }
    RtlInitUnicodeString(&TypeName, DEVICETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DEVICE;
    }
    RtlInitUnicodeString(&TypeName, DRIVERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_DRIVER;
    }
    RtlInitUnicodeString(&TypeName, EVENTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_EVENT;
    }
    RtlInitUnicodeString(&TypeName, EVENTPAIRTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_EVENTPAIR;
    }
    RtlInitUnicodeString(&TypeName, FILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_FILE;
    }
    RtlInitUnicodeString(&TypeName, MUTANTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_MUTANT;
    }
    RtlInitUnicodeString(&TypeName, PORTTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PORT;
    }
    RtlInitUnicodeString(&TypeName, PROFILETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PROFILE;
    }
    RtlInitUnicodeString(&TypeName, SECTIONTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SECTION;
    }
    RtlInitUnicodeString(&TypeName, SEMAPHORETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_SEMAPHORE;
    }
    RtlInitUnicodeString(&TypeName, TIMERTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_TIMER;
    }
    RtlInitUnicodeString(&TypeName, TYPETYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_TYPE;
    }
    RtlInitUnicodeString(&TypeName, PROCESSTYPE);
    if (RtlEqualString((PSTRING)Type, (PSTRING)&TypeName, TRUE)) {
        return ATTR_PROCESS;
    }
    return(0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectSpec() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Remove the filespec portion from a path (including the backslash). */

VOID
StripObjectSpec(
               LPSTR lpszPath
               )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    /* Don't strip backslash from root directory entry. */
    if ((p == lpszPath) && (*p == '\\')) {
        p++;
    }

    *p = '\000';
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripObjectPath() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Extract only the filespec portion from a path. */

VOID
StripObjectPath(
               LPSTR lpszPath
               )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (*p == '\\')
        p++;

    if (p != lpszPath)
        lstrcpy(lpszPath, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfcomman.c ===
/****************************************************************************/
/*                                                                          */
/*  WFCOMMAN.C -                                                            */
/*                                                                          */
/*      Windows File System Command Proc                                    */
/*                                                                          */
/****************************************************************************/
#include <nt.h>


#include <ntrtl.h>


#include <nturtl.h>



#include "winfile.h"
#include "object.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#define HELP_PARTIALKEY 0x0105L   /* call the search engine in winhelp */


HWND LocateDirWindow(LPSTR pszPath, BOOL bDirOnly);
VOID AddNetMenuItems(VOID);

VOID InitNetMenuItems(VOID);



VOID
NotifySearchFSC(
               PSTR pszPath,
               WORD wFunction
               )
{
    CHAR szPath[MAXPATHLEN];

    if (!hwndSearch)
        return;

    SendMessage(hwndSearch, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);

    if (DRIVEID(pszPath) == DRIVEID(szPath)) {
        SendMessage(hwndSearch, WM_FILESYSCHANGE, wFunction, 0L);
    }
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  LocateDirWindow() -                                                     */
/*                                                                          */
// bDirOnly     TRUE if pszPath does not contain a filespec
/*--------------------------------------------------------------------------*/

HWND
LocateDirWindow(
               LPSTR pszPath,
               BOOL bDirOnly
               )
{
    register HWND hwndT;
    HWND hwndDir;
    LPSTR pT2;
    CHAR szTemp[MAXPATHLEN];
    CHAR szPath[MAXPATHLEN];

    pT2 = pszPath;

    /* Only work with well-formed pathes. */
    if (lstrlen(pT2) < 3)
        return NULL;

    if (IsDBCSLeadByte( pT2[0] ) || pT2[1] != ':')
        return NULL;

    lstrcpy(szPath, pT2);

    if (!bDirOnly)                // remove extension stuff
        StripFilespec(szPath);

    for (hwndT = GetWindow(hwndMDIClient, GW_CHILD);
        hwndT;
        hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {

        if (hwndDir = HasDirWindow(hwndT)) {

            // Get the Window's path information, remove the extension file spec

            GetMDIWindowText(hwndT, szTemp, sizeof(szTemp));
            StripFilespec(szTemp);

            /* No need to worry about the window's filespec. */
            if (!lstrcmpi(szTemp, szPath))
                break;
        }
    }

    return hwndT;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  EnableFSC() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
EnableFSC()
{
    HWND hwnd;

    if (--cDisableFSC)
        return;

    for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
        hwnd;
        hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {
        // a tree or search window

        if (!GetWindow(hwnd, GW_OWNER) && GetWindowLong(hwnd,GWL_FSCFLAG))
            SendMessage(hwnd,WM_FILESYSCHANGE,FSC_REFRESH,0L);
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DisableFSC() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
DisableFSC()
{
    cDisableFSC++;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChangeFileSystem() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* There are two sources of FileSysChange messages.  They can be sent from
 * the 386 WinOldAp or they can be posted by WINFILE's callback function (i.e.
 * from Kernel).  In both cases, we are free to do processing at this point.
 * For posted messages, we have to free the buffer passed to us as well.
 *
 * we are really in the other tasks context when we get entered here.
 * (this routine should be in a DLL)
 *
 * the file names are partially qualified, they have at least a drive
 * letter and initial directory part (c:\foo\..\bar.txt) so our
 * QualifyPath() calls should work.
 */

VOID
APIENTRY
ChangeFileSystem(
                register WORD wFunction,
                LPSTR lpszFile,
                LPSTR lpszTo
                )
{
    HWND                 hwnd, hwndTC;
    HWND          hwndOld;
    CHAR          szFrom[MAXPATHLEN];
    CHAR          szTo[MAXPATHLEN];
    CHAR          szTemp[MAXPATHLEN];
    CHAR          szPath[MAXPATHLEN + MAXPATHLEN];

    ENTER("ChangeFileSystem");
    OemToCharBuff(lpszFile, szFrom, _MAX_PATH);
    QualifyPath(szFrom);  // already partly qualified

    /* Handle cases where we're passed a DOS function number rather
     * than an FSC index (for the Kernel callback).
     */
    if (wFunction & 0x8000) {
        switch (wFunction & 0x7FFF) {
            case 0x56:
                wFunction = FSC_RENAME;
                break;

            case 0x3C:
            case 0x5A:
            case 0x5B:
            case 0x6C:
                wFunction = FSC_CREATE;
                break;

            case 0x41:
                wFunction = FSC_DELETE;
                break;

            case 0x43:
                wFunction = FSC_ATTRIBUTES;
                break;

            case 0x39:
                wFunction = FSC_MKDIR;
                break;

            case 0x3A:
                wFunction = FSC_RMDIR;
                break;
        }
    }

    bFileSysChanging = TRUE;

    // as FSC messages come in from outside winfile
    // we set a timer, and when that expires we
    // refresh everything.  if another FSC comes in while
    // we are waiting on this timer we reset it so we
    // only refresh on the last operations.  this lets
    // the timer be much shorter

    if (cDisableFSC == 0 || bFSCTimerSet) {
        if (bFSCTimerSet)
            KillTimer(hwndFrame, 1);                // reset the timer
        if (SetTimer(hwndFrame, 1, 1000, NULL)) {       // 1 second

            bFSCTimerSet = TRUE;
            if (cDisableFSC == 0)                   // only disable once
                DisableFSC();
        }
    }

    switch (wFunction) {
        case FSC_RENAME:
            OemToCharBuff(lpszTo, szTo, _MAX_PATH);
            QualifyPath(szTo);    // already partly qualified

            NotifySearchFSC(szFrom, wFunction);

            /* Update the original directory window (if any). */
            if (hwndOld = LocateDirWindow(szFrom, FALSE))
                SendMessage(hwndOld, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);

            NotifySearchFSC(szTo, wFunction);

            /* Update the new directory window (if any). */
            if ((hwnd = LocateDirWindow(szTo, FALSE)) && (hwnd != hwndOld))
                SendMessage(hwnd, WM_FILESYSCHANGE, wFunction, (LPARAM)szTo);

            /* Are we renaming a directory? */
            lstrcpy(szTemp, szTo);
            FixAnsiPathForDos(szTemp);
            if (GetFileAttributes(szTemp) & ATTR_DIR) {

                for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                    if (hwndTC = HasTreeWindow(hwnd)) {

                        // if the current selection is szFrom, we update the
                        // selection after the rename occurs

                        SendMessage(hwnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                        StripBackslash(szPath);

                        // add the new name first

                        SendMessage(hwndTC, WM_FILESYSCHANGE, FSC_MKDIR, (LPARAM)szTo);

                        // update the selection if necessary, also
                        // change the window text in this case to
                        // reflect the new name

                        if (!lstrcmpi(szPath, szFrom)) {
                            SendMessage(hwndTC, TC_SETDIRECTORY, FALSE, (LPARAM)szTo);

                            lstrcpy(szPath, szTo);

                            // update the window title

                            AddBackslash(szPath);
                            SendMessage(hwnd, FS_GETFILESPEC, MAXPATHLEN, (LPARAM)szPath + lstrlen(szPath));
                            // if (wTextAttribs & TA_LOWERCASE)
                            //         AnsiLower(szPath);

                            SetMDIWindowText(hwnd, szPath);
                        }

                        SendMessage(hwndTC, WM_FILESYSCHANGE, FSC_RMDIR, (LPARAM)szFrom);
                    }
                }
            }
            break;

        case FSC_RMDIR:
            /* Close any open directory window. */
            if ((hwnd = LocateDirWindow(szFrom, TRUE)) && !HasTreeWindow(hwnd))
                SendMessage(hwnd, WM_CLOSE, 0, 0L);
            /*** FALL THRU ***/

        case FSC_MKDIR:
            {
                HWND L_hwnd;
                HWND hwndTree;
                /* Update the tree. */

                for (L_hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                    L_hwnd;
                    L_hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                    if (hwndTree = HasTreeWindow(L_hwnd)) {

                        SendMessage(hwndTree, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);
                    }
                }
            }
            /*** FALL THRU ***/

        case FSC_DELETE:
        case FSC_CREATE:
        case FSC_REFRESH:
        case FSC_ATTRIBUTES:

            lFreeSpace = -1L;     // cause this stuff to be refreshed


            if (hwnd = LocateDirWindow(szFrom, FALSE))
                SendMessage(hwnd, WM_FILESYSCHANGE, wFunction, (LPARAM)szFrom);

            NotifySearchFSC(szFrom, wFunction);

            break;
    }

    bFileSysChanging = FALSE;
    LEAVE("ChangeFileSystem");
}

//
// HWND  APIENTRY CreateTreeWindow(LPSTR szPath, int dxSplit)
//
// creates a tree window with all the extras
//
// in:
//      szPath  fully qualified ANSI path name WITH filespec
//      dxSplit split position of tree and dir windows, if this is
//              less than the threshold a tree will not be created,
//              if it is more then a dir will not be created.
//              0 to create a dir only
//              very large number for tree only
//              < 0 to have the split put in the middle
// returns:
//      the hwnd of the mdi child created
//

HWND
APIENTRY
CreateTreeWindow(
                LPSTR szPath,
                INT dxSplit
                )
{
    MDICREATESTRUCT MDICS;
    HWND hwnd;

    ENTER("CreateTreeWindow");
    PRINT(BF_PARMTRACE, "szPath=%s", szPath);
    PRINT(BF_PARMTRACE, "dxSplit=%ld", IntToPtr(dxSplit));

    // if (wTextAttribs & TA_LOWERCASE)
    //         AnsiLower(szPath);

    // Create the Directory Tree window

    MDICS.szClass = szTreeClass;
    MDICS.szTitle = szPath;
    MDICS.hOwner = hAppInstance;

    MDICS.style = 0L;
    MDICS.x  = CW_USEDEFAULT;
    MDICS.y  = 0;
    MDICS.cx = CW_USEDEFAULT;
    MDICS.cy = 0;

    MDICS.lParam = MAKELONG(dxSplit, 0);    // pass the split parameter
                                            // on down

    hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwnd && GetWindowLong(hwnd, GWL_STYLE) & WS_MAXIMIZE)
        MDICS.style |= WS_MAXIMIZE;

    hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDICREATE, 0L, (LPARAM)&MDICS);

    if (hwnd) {

        SetMDIWindowText(hwnd, szPath);
#if 0
        HMENU hMenu;
        hMenu = GetSystemMenu(hwnd, FALSE);
        AppendMenu(hMenu, MF_SEPARATOR, 0, NULL);
        AppendMenu(hMenu, MF_STRING, SC_SPLIT, "Sp&lit");
#endif
    }
    PRINT(BF_PARMTRACE, "OUT: hwndTree=%d", hwnd);
    LEAVE("CreateTreeWindow");
    return hwnd;
}



//
// HWND  APIENTRY CreateDirWindow(register LPSTR szPath, BOOL bStartUp)
//
// in:
//      szPath          fully qualified path with no filespec
//      bReplaceOpen    default replacement mode, shift always toggles this
//      hwndActive      active mdi child that we are working on
//                      on open flag
// returns:
//      hwnd of window created or of existing dir window that we
//      activated or replaced if replace on open was active
//

HWND
APIENTRY
CreateDirWindow(
               register LPSTR szPath,
               BOOL bReplaceOpen,
               HWND hwndActive
               )
{
    register HWND     hwndT;
    CHAR szFileSpec[MAXPATHLEN];

    // shift toggels 'replace on open'

    if (GetKeyState(VK_SHIFT) < 0)
        bReplaceOpen = !bReplaceOpen;

    /* Is a window with this path already open? */
    if (!bReplaceOpen && (hwndT = LocateDirWindow(szPath, TRUE)) && !HasTreeWindow(hwndT)) {

        SendMessage(hwndMDIClient, WM_MDIACTIVATE, GET_WM_MDIACTIVATE_MPS(0, 0, hwndT));
        if (IsIconic(hwndT))
            SendMessage(hwndT, WM_SYSCOMMAND, SC_RESTORE, 0L);
        return hwndT;
    }


    // Are we replacing the contents of the currently active child?

    if (bReplaceOpen) {

        // update the tree if necessary, before we throw on the filespec

        if (hwndT = HasTreeWindow(hwndActive))
            SendMessage(hwndT, TC_SETDIRECTORY, FALSE, (LPARAM)szPath);

        SendMessage(hwndActive, FS_GETFILESPEC, sizeof(szFileSpec), (LPARAM)szFileSpec);

        AddBackslash(szPath);                   // need to add this stuff to the path
        lstrcat(szPath, szFileSpec);

        SendMessage(GetDlgItem(hwndActive, IDCW_DIR), FS_CHANGEDISPLAY, CD_PATH, (LPARAM)szPath);


        return hwndActive;
    }

    AddBackslash(szPath);                   // default to all files
    lstrcat(szPath, szStarDotStar);

    return CreateTreeWindow(szPath, 0);     // dir only tree window
}



VOID
OpenSelection(
             HWND hwndActive
             )
{
    LPSTR p;
    BOOL bDir;
    WORD ret;
    HCURSOR hCursor;
    CHAR szTemp[MAXPATHLEN];

    CHAR szPath[MAXPATHLEN];
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;

    // Is the active MDI child minimized? if so restore it!

    if (IsIconic(hwndActive)) {
        SendMessage(hwndActive, WM_SYSCOMMAND, SC_RESTORE, 0L);
        return;
    }

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    // set the current directory

    SetWindowDirectory();

    // get the relavant parameters

    GetTreeWindows(hwndActive, &hwndTree, &hwndDir, &hwndDrives);
    if (hwndTree || hwndDir)
        hwndFocus = GetTreeFocus(hwndActive);
    else
        hwndFocus = NULL;

    if (hwndDrives && hwndFocus == hwndDrives) {

        // open a drive by sending a <CR>

        SendMessage(hwndDrives, WM_KEYDOWN, VK_RETURN, 0L);

        goto OpenExit;
    }


    /* Get the first selected item. */
    p = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, TRUE, (LPARAM)&bDir);

    if (!*p)
        goto OpenExit;


    GetNextFile(p, szPath, sizeof(szPath));
    LocalFree((HANDLE)p);

    if (!szPath[0])
        goto OpenExit;

    if (bDir) {

        if (hwndDir && hwndFocus == hwndDir) {

            if (hwndTree)
                SendMessage(hwndTree, TC_EXPANDLEVEL, FALSE, 0L);

            CreateDirWindow(szPath, TRUE, hwndActive);

            SetFocus(hwndDir);      // undo some things that happen in TC_EXPANDLEVEL

        } else if (hwndTree) {

            // this came through because of
            // SHIFT open a dir only tree

            if (GetKeyState(VK_SHIFT) < 0) {
                CreateDirWindow(szPath, TRUE, hwndActive);
            } else {
                SendMessage(hwndTree, TC_TOGGLELEVEL, FALSE, 0L);
            }
        }

    } else {
        // Display the object information

        GetSelectedDirectory(0, szTemp);

        AddBackslash(szTemp);

        strcat(szTemp, szPath);

        DisplayObjectInformation(hwndFrame, szTemp);
    }

    OpenExit:
    ShowCursor(FALSE);
    SetCursor(hCursor);
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AppCommandProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
AppCommandProc(
              register WORD id
              )
{
    WORD          wFlags;
    BOOL          bMaxed;
    HMENU         hMenu;
    register HWND hwndActive;
    BOOL          bTemp;
    HWND          hwndT;
    CHAR          szPath[MAXPATHLEN];
    INT           ret;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        bMaxed = 1;
    else
        bMaxed = 0;


    dwContext = IDH_HELPFIRST + id;

    switch (id) {
        case IDM_SPLIT:
            MSG("AppCommandProc", "IDM_SPLIT");
            SendMessage(hwndActive, WM_SYSCOMMAND, SC_SPLIT, 0L);
            break;

        case IDM_TREEONLY:
        case IDM_DIRONLY:
        case IDM_BOTH:
            MSG("AppCommandProc", "IDM_TREEONLY/IDM_DIRONLY/IDM_BOTH");
            {
                RECT rc;
                INT x;

                if (hwndActive != hwndSearch) {

                    GetClientRect(hwndActive, &rc);

                    if (id == IDM_DIRONLY)
                        x = 0;
                    else if (id == IDM_TREEONLY)
                        x = rc.right;
                    else
                        x = rc.right / 2;

                    if (ResizeSplit(hwndActive, x))
                        SendMessage(hwndActive, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
                }
                break;
            }

        case IDM_OPEN:
            MSG("AppCommandProc", "IDM_OPEN");
            if (GetKeyState(VK_MENU) < 0)
                PostMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_ATTRIBS, 0, 0));
            else
                OpenSelection(hwndActive);
            break;

        case IDM_ASSOCIATE:
            MSG("AppCommandProc", "IDM_ASSOCIATE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(ASSOCIATEDLG), hwndFrame, AssociateDlgProc);
            break;

        case IDM_SEARCH:
            MSG("AppCommandProc", "IDM_SEARCH");
            DialogBox(hAppInstance, MAKEINTRESOURCE(SEARCHDLG), hwndFrame, SearchDlgProc);
            break;

        case IDM_RUN:
            MSG("AppCommandProc", "IDM_RUN");
            DialogBox(hAppInstance, MAKEINTRESOURCE(RUNDLG), hwndFrame, RunDlgProc);
            break;

        case IDM_SELECT:

            MSG("AppCommandProc", "IDM_SELECT");
            // push the focus to the dir half so when they are done
            // with the selection they can manipulate without undoing the
            // selection.

            if (hwndT = HasDirWindow(hwndActive))
                SetFocus(hwndT);

            DialogBox(hAppInstance, MAKEINTRESOURCE(SELECTDLG), hwndFrame, SelectDlgProc);
            break;

        case IDM_MOVE:
        case IDM_COPY:
        case IDM_RENAME:
            MSG("AppCommandProc", "IDM_MOVE/IDM_COPY/IDM_RENAME");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(MOVECOPYDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_PRINT:
            MSG("AppCommandProc", "IDM_PRINT");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(MYPRINTDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_DELETE:
            MSG("AppCommandProc", "IDM_DELETE");
            wSuperDlgMode = id;
            DialogBox(hAppInstance, MAKEINTRESOURCE(DELETEDLG), hwndFrame, SuperDlgProc);
            break;

        case IDM_UNDELETE:
            MSG("AppCommandProc", "IDM_UNDELETE");

            if (lpfpUndelete) {
                SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                StripBackslash(szPath);
                if ((*lpfpUndelete)(hwndActive, (LPSTR)szPath) == IDOK)
                    RefreshWindow(hwndActive);
            }
            break;

        case IDM_ATTRIBS:
            MSG("AppCommandProc", "IDM_ATTRIBS");
            {
                LPSTR pSel, p;
                INT count;

                // should do the multiple or single file properties

                pSel = GetSelection(FALSE);

                if (!pSel)
                    break;

                count = 0;
                p = pSel;

                while (p = GetNextFile(p, szPath, sizeof(szPath)))
                    count++;

                LocalFree((HANDLE)pSel);

                if (count == 0)
                    break;          // nothing selected

                if (count > 1)
                    DialogBox(hAppInstance, MAKEINTRESOURCE(MULTIPLEATTRIBSDLG), hwndFrame, AttribsDlgProc);
                else
                    DialogBox(hAppInstance, MAKEINTRESOURCE(ATTRIBSDLG), hwndFrame, AttribsDlgProc);

                break;
            }

        case IDM_MAKEDIR:
            MSG("AppCommandProc", "IDM_MAKEDIR");
            DialogBox(hAppInstance, MAKEINTRESOURCE(MAKEDIRDLG), hwndFrame, MakeDirDlgProc);
            break;

        case IDM_SELALL:
        case IDM_DESELALL:

            MSG("AppCommandProc", "IDM_SELALL/IDM_DESELALL");
            // FIX31: this code could be replace with calls to
            // DSSetSelection()
            {
                INT       iSave;
                HWND      hwndLB;
                LPMYDTA lpmydta;

                hwndActive = HasDirWindow(hwndActive);

                if (!hwndActive)
                    break;

                hwndLB = GetDlgItem(hwndActive, IDCW_LISTBOX);

                if (!hwndLB)
                    break;

                SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);

                iSave = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                SendMessage(hwndLB, LB_SETSEL, (id == IDM_SELALL), -1L);

                if (id == IDM_DESELALL)
                    SendMessage(hwndLB, LB_SETSEL, TRUE, (LONG)iSave);
                else if (GetParent(hwndActive) != hwndSearch) {
                    /* Is the first item the [..] directory? */
                    SendMessage(hwndLB, LB_GETTEXT, 0, (LPARAM)&lpmydta);
                    if (lpmydta->my_dwAttrs & ATTR_PARENT)
                        SendMessage(hwndLB, LB_SETSEL, 0, 0L);
                }
                SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hwndLB, NULL, FALSE);

                /* Emulate a SELCHANGE notification. */
                SendMessage(hwndActive, WM_COMMAND, GET_WM_COMMAND_MPS(0, hwndActive, LBN_SELCHANGE));

            }
            break;

        case IDM_EXIT:

            MSG("AppCommandProc", "IDM_EXIT");
            if (iReadLevel) {
                bCancelTree = 2;
                //break;
            }

            SheChangeDir(szOriginalDirPath);

            if (bSaveSettings)
                SaveWindows(hwndFrame);

            return FALSE;
            break;

        case IDM_LABEL:
            MSG("AppCommandProc", "IDM_LABEL");
            DialogBox(hAppInstance, MAKEINTRESOURCE(DISKLABELDLG), hwndFrame, DiskLabelDlgProc);
            break;

        case IDM_DISKCOPY:

            MSG("AppCommandProc", "IDM_DISKCOPY");
            if (nFloppies == 1) {

                iCurrentDrive = iFormatDrive = rgiDrive[0];
            } else {

                wSuperDlgMode = id;
                ret = (int)DialogBox(hAppInstance, MAKEINTRESOURCE(CHOOSEDRIVEDLG), hwndFrame, ChooseDriveDlgProc);

                if (ret < 1)
                    break;
            }

            if (bConfirmFormat) {
                LoadString(hAppInstance, IDS_DISKCOPYCONFIRMTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_DISKCOPYCONFIRM, szMessage, sizeof(szMessage));
                if (MessageBox(hwndFrame, szMessage, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES)
                    break;
            }

            if (CopyDiskette(hwndFrame, (WORD)iCurrentDrive, (WORD)iFormatDrive) <= 0) {
                if (!bUserAbort) {
                    LoadString(hAppInstance, IDS_COPYDISKERR, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_COPYDISKERRMSG, szMessage, sizeof(szMessage));
                    MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                }
            }
            break;

        case IDM_FORMAT:
            MSG("AppCommandProc", "IDM_FORMAT");
            FormatDiskette(hwndFrame);
            break;

        case IDM_SYSDISK:
            MSG("AppCommandProc", "IDM_SYSDISK");
            /*** FIX30: This ASSUMEs that A: is the first floppy drive in the system! ***/
            if (nFloppies == 1) {
                iFormatDrive = rgiDrive[0];
                LoadString(hAppInstance, IDS_SYSDISK, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SYSDISKRUSURE, szPath, sizeof(szPath));
                wsprintf(szMessage, szPath, 'A'+iFormatDrive);
                if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                    break;
            } else {
                wSuperDlgMode = id;
                if (DialogBox(hAppInstance, MAKEINTRESOURCE(CHOOSEDRIVEDLG), hwndFrame, ChooseDriveDlgProc) < 1)
                    break;
            }


            bUserAbort = FALSE;

            /* Display the Format dialog. */
            hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(SYSDISKPROGRESSDLG), hwndFrame, ProgressDlgProc);
            if (!hdlgProgress)
                goto SysDiskExit;

            EnableWindow(hwndFrame, FALSE);

            LoadString(hAppInstance, IDS_SYSDISKERR, szTitle, sizeof(szTitle));

            if (MakeSystemDiskette((WORD)iFormatDrive, FALSE)) {
                if (!bUserAbort) {
                    LoadString(hAppInstance, IDS_SYSDISKADDERR, szMessage, sizeof(szMessage));
                    MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                }
            }
            SysDiskExit:
            if (hdlgProgress) {
                EnableWindow(hwndFrame, TRUE);
                DestroyWindow(hdlgProgress);
                hdlgProgress = NULL;
            }
            break;

        case IDM_CONNECTIONS:
            MSG("AppCommandProc", "IDM_CONNECTIONS");
            ret = WNetConnectionDialog(hwndFrame, RESOURCETYPE_DISK);

            if ( ret == WN_SUCCESS )
                UpdateConnections();
            else if ( ret == WN_NO_NETWORK || ret == WN_NOT_SUPPORTED ) {
                DialogBox(hAppInstance, MAKEINTRESOURCE(CONNECTDLG), hwndFrame, ConnectDlgProc);
            } else if ( ret != WN_CANCEL ) {
                WNetErrorText((WORD)ret, szMessage, (WORD)sizeof(szMessage));
                LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
                MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
            }
            break;

        case IDM_EXPONE:
            MSG("AppCommandProc", "IDM_EXPONE");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_EXPANDLEVEL, FALSE, 0L);
            break;

        case IDM_EXPSUB:
            MSG("AppCommandProc", "IDM_EXPSUB");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_EXPANDLEVEL, TRUE, 0L);
            break;

        case IDM_EXPALL:
            MSG("AppCommandProc", "IDM_EXPALL");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_SETDRIVE, MAKEWORD(TRUE, 0), 0L);
            break;

        case IDM_COLLAPSE:
            MSG("AppCommandProc", "IDM_COLLAPSE");
            if (hwndT = HasTreeWindow(hwndActive))
                SendMessage(hwndT, TC_COLLAPSELEVEL, 0, 0L);
            break;

        case IDM_VNAME:
            MSG("AppCommandProc", "IDM_VNAME");
            wFlags = (WORD)(VIEW_NAMEONLY | (GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES));
            id = CD_VIEW;
            goto ChangeDisplay;

        case IDM_VDETAILS:
            MSG("AppCommandProc", "IDM_VDETAILS");
            wFlags = (WORD)(VIEW_EVERYTHING | (GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES));
            id = CD_VIEW;
            goto ChangeDisplay;

        case IDM_VOTHER:
            MSG("AppCommandProc", "IDM_VOTHER");
            DialogBox(hAppInstance, MAKEINTRESOURCE(OTHERDLG), hwndFrame, OtherDlgProc);
            break;

        case IDM_BYNAME:
        case IDM_BYTYPE:
        case IDM_BYSIZE:
        case IDM_BYDATE:
            MSG("AppCommandProc", "IDM_BYNAME/IDM_BYTYPE/IDM_BYSIZE/IDM_BYDATE");
            wFlags = (WORD)((id - IDM_BYNAME) + IDD_NAME);
            id = CD_SORT;

            ChangeDisplay:

            if (hwndT = HasDirWindow(hwndActive)) {
                SendMessage(hwndT, FS_CHANGEDISPLAY, id, MAKELONG(wFlags, 0));
            } else if (hwndActive == hwndSearch) {
                SetWindowLong(hwndActive, GWL_VIEW, wFlags);
                InvalidateRect(hwndActive, NULL, TRUE);
            }

            break;

        case IDM_VINCLUDE:
            MSG("AppCommandProc", "IDM_VINCLUDE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(INCLUDEDLG), hwndFrame, IncludeDlgProc);
            break;

        case IDM_CONFIRM:
            MSG("AppCommandProc", "IDM_CONFIRM");
            DialogBox(hAppInstance, MAKEINTRESOURCE(CONFIRMDLG), hwndFrame, ConfirmDlgProc);
            break;


        case IDM_STATUSBAR:
            MSG("AppCommandProc", "IDM_STATUSBAR");
            {
                RECT      rc;

                bTemp = bStatusBar = !bStatusBar;
                WritePrivateProfileBool(szStatusBar, bStatusBar);

                GetClientRect(hwndFrame, &rc);
                SendMessage(hwndFrame, WM_SIZE, SIZENORMAL, MAKELONG(rc.right, rc.bottom));
                UpdateStatus(hwndActive);
                InvalidateRect(hwndFrame, NULL, TRUE);

                goto CHECK_OPTION;

                break;
            }

        case IDM_FONT:
            MSG("AppCommandProc", "IDM_FONT");
            dwContext = IDH_FONT;
            NewFont();
            break;

        case IDM_ADDPLUSES:
            MSG("AppCommandProc", "IDM_ADDPLUSES");
            {
                HWND hwnd;
                WORD view;

                if (!(hwnd = HasTreeWindow(hwndActive)))
                    break;

                // toggle pluses view bit

                view = (WORD)(GetWindowLong(hwndActive, GWL_VIEW) ^ VIEW_PLUSES);

                SetWindowLong(hwndActive, GWL_VIEW, view);

                if (view & VIEW_PLUSES) {
                    // need to reread the tree to do this

                    SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                    SendMessage(hwnd, TC_SETDRIVE, MAKEWORD(FALSE, 0), (LPARAM)szPath);
                } else {
                    // repaint only
                    InvalidateRect(hwnd, NULL, FALSE);
                }

                bTemp = view & VIEW_PLUSES;
                goto CHECK_OPTION;
            }

        case IDM_SAVESETTINGS:
            MSG("AppCommandProc", "IDM_SAVESETTINGS");
            bTemp = bSaveSettings = !bSaveSettings;
            WritePrivateProfileBool(szSaveSettings, bSaveSettings);
            goto CHECK_OPTION;

        case IDM_MINONRUN:
            MSG("AppCommandProc", "IDM_MINONRUN");
            bTemp = bMinOnRun = !bMinOnRun;
            WritePrivateProfileBool(szMinOnRun, bMinOnRun);

            CHECK_OPTION:
            /* Check/Uncheck the menu item. */
            hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_OPTIONS + bMaxed);
            CheckMenuItem(hMenu, id, (bTemp ? MF_CHECKED : MF_UNCHECKED));
            break;

        case IDM_NEWWINDOW:
            MSG("AppCommandProc", "IDM_NEWWINDOW");
            NewTree((INT)SendMessage(hwndActive, FS_GETDRIVE, 0, 0L) - 'A', hwndActive);
            break;

        case IDM_CASCADE:
            MSG("AppCommandProc", "IDM_CASCADE");
            SendMessage(hwndMDIClient, WM_MDICASCADE, 0L, 0L);
            break;

        case IDM_TILE:
            MSG("AppCommandProc", "IDM_TILE");
            SendMessage(hwndMDIClient, WM_MDITILE,
                        GetKeyState(VK_SHIFT) < 0 ? 0 : 1, 0L);
            break;

        case IDM_ARRANGE:
            MSG("AppCommandProc", "IDM_ARRANGE");
            SendMessage(hwndMDIClient, WM_MDIICONARRANGE, 0L, 0L);
            break;

        case IDM_REFRESH:
            MSG("AppCommandProc", "IDM_REFRESH");
            {
                INT i;

                for (i = 0; i < iNumExtensions; i++) {
                    (extensions[i].ExtProc)(hwndFrame, FMEVENT_USER_REFRESH, 0L);
                }

                InvalidateVolTypes();
                RefreshWindow(hwndActive);
                lFreeSpace = -1L;             // update free space
                UpdateStatus(hwndActive);
                AddNetMenuItems();

                break;
            }

        case IDM_HELPINDEX:
            MSG("AppCommandProc", "IDM_HELPINDEX");
            wFlags = HELP_INDEX;
            goto ACPCallHelp;

        case IDM_HELPKEYS:
            MSG("AppCommandProc", "IDM_HELPKEYS");
            wFlags = HELP_PARTIALKEY;
            goto ACPCallHelp;

        case IDM_HELPHELP:
            MSG("AppCommandProc", "IDM_HELPHELP");
            wFlags = HELP_HELPONHELP;
            goto ACPCallHelp;

            ACPCallHelp:
            SheChangeDir(szOriginalDirPath);
            if (!WinHelp(hwndFrame, szWinObjHelp, wFlags, (ULONG_PTR)szNULL)) {
                MyMessageBox(hwndFrame, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            }
            break;

        case IDM_ABOUT:
            MSG("AppCommandProc", "IDM_ABOUT");
            LoadString(hAppInstance, IDS_WINFILE, szTitle, sizeof(szTitle));
            ShellAbout(hwndFrame, szTitle, NULL, NULL);
            break;

        case IDM_DRIVESMORE:
            MSG("AppCommandProc", "IDM_DRIVESMORE");
            DialogBox(hAppInstance, MAKEINTRESOURCE(DRIVEDLG), hwndFrame, DrivesDlgProc);
            break;

        default:
            DEFMSG("AppCommandProc", id);
            {
                INT i;

                for (i = 0; i < iNumExtensions; i++) {
                    WORD delta = extensions[i].Delta;

                    if ((id >= delta) && (id < (WORD)(delta + 100))) {
                        (extensions[i].ExtProc)(hwndFrame, (WORD)(id - delta), 0L);
                        break;
                    }
                }

            }
            return FALSE;
    }

    return TRUE;
}


VOID
AddNetMenuItems(VOID)

{
    HMENU hMenu;


    hMenu = GetMenu(hwndFrame);


    // add only if net menuitems do not already exist

    if ((GetMenuState(hMenu, IDM_CONNECT, MF_BYCOMMAND) == -1) &&

        (GetMenuState(hMenu, IDM_CONNECTIONS, MF_BYCOMMAND) == -1)) {

        InitNetMenuItems();
    }
}





VOID
InitNetMenuItems(VOID)

{

    HMENU hMenu;

    UINT i;

    INT iMax;

    CHAR szValue[MAXPATHLEN];

    HWND hwndActive;





    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)

        iMax = 1;

    else

        iMax = 0;

    hMenu = GetMenu(hwndFrame);



    // No. Now add net items if net has been started.



    i = (WORD)WNetGetCaps(WNNC_DIALOG);

    bConnect    = i & WNNC_DLG_ConnectDialog;     // note, these should both

    bDisconnect = i & WNNC_DLG_DisconnectDialog;  // be true or both false



    // use submenu because we are doing this by position



    hMenu = GetSubMenu(hMenu, IDM_DISK + iMax);



    if (i)

        InsertMenu(hMenu, 5, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);



    if (bConnect && bDisconnect) {



        // lanman style double connect/disconnect



        LoadString(hAppInstance, IDS_CONNECT, szValue, sizeof(szValue));

        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECT, szValue);

        LoadString(hAppInstance, IDS_DISCONNECT, szValue, sizeof(szValue));

        InsertMenu(hMenu, 7, MF_BYPOSITION | MF_STRING, IDM_DISCONNECT, szValue);

    } else if (WNetGetCaps(WNNC_CONNECTION)) {



        // our style



        LoadString(hAppInstance, IDS_CONNECTIONS, szValue, sizeof(szValue));

        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECTIONS, szValue);

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfcopy.c ===
/****************************************************************************/
/*                                                                          */
/*  WFCOPY.C -                                                              */
/*                                                                          */
/*      Windows File System File Copying Routines                           */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "lfn.h"
#include "wfcopy.h"

#ifdef TRACECOPY
    #define dbg(x) DebugF x
#else
    #define dbg(x)
#endif

BOOL *pbConfirmAll;
CHAR szSpace[] = " ";
INT ManySource;

INT nCopyNumQueue;      // # of items in the queue
INT nCopyMaxQueue;      // size of the queue
PCOPYQUEUE pCopyQueue;      // copy queue buffer
BOOL bCopyReport;       // do notifications? bogus


LPSTR lpCopyBuffer;     // global memory for FileCopy() buffer
WORD wCopyBufferSize;       // size of this buffer

VOID APIENTRY wfYield(VOID);

INT  CopyMoveRetry(PSTR, INT);
VOID CopyError(PSTR, PSTR, INT, WORD, INT);
BOOL IsRootDirectory(PSTR pPath);
BOOL IsDirectory(PSTR pPath);

WORD ConfirmDialog(
                  HWND hDlg, WORD dlg,
                  LPSTR pFileDest, PLFNDTA pDTADest,
                  LPSTR pFileSource, PLFNDTA pDTASource,
                  BOOL bConfirmByDefault, BOOL *pbAll);

VOID MergePathName(LPSTR pPath, LPSTR pName);
BOOL IsInvalidPath(register LPSTR pPath);
WORD GetNextPair(register PCOPYROOT pcr, LPSTR pFrom, LPSTR pToPath, LPSTR pToSpec, WORD wFunc);
INT  CheckMultiple(LPSTR pInput);
VOID DialogEnterFileStuff(register HWND hwnd);
WORD SafeFileRemove(LPSTR szFileOEM);
BOOL IsWindowsFile(LPSTR szFileOEM);

INT_PTR APIENTRY ReplaceDlgProc(register HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);


BOOL
APIENTRY
IsValidChar(
           BYTE ch,
           BOOL fPath
           )
{
    switch (ch) {
        case ';':       // terminator
        case ',':       // terminator
        case '|':       // pipe
        case '>':       // redir
        case '<':       // redir
        case '"':       // quote
            return FALSE;

        case '?':       // wc           we only do wilds here because they're
        case '*':       // wc           legal for qualifypath
        case '\\':      // path separator
        case ':':       // drive colon
        case '/':       // path sep
            return fPath;
    }

    // cannot be a control character or space
    return ch > ' ';
}



//--------------------------------------------------------------------------
//
// StripColon() -
//
// removes trailing colon if not a drive letter.
// this is to support DOS character devices (CON:, COM1: LPT1:).  DOS
// can't deal with these things having a colon on the end (so we strip it).
//
//--------------------------------------------------------------------------

PSTR
StripColon(
          register PSTR pPath
          )
{
    register INT cb = lstrlen(pPath);

    dbg(("StripColon(%s)\r\n",(LPSTR)pPath));

    {
        LPSTR pTailp = AnsiPrev( pPath, &(pPath[cb]) );
        if (cb > 2 && *pTailp == ':')
            *pTailp = 0;
    }

    return pPath;
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  FindFileName() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Returns a pointer to the last component of a path string. */

PSTR
FindFileName(
            register PSTR pPath
            )
{
    register LPSTR pT;

    dbg(("FindFileName(%s);\r\n",(LPSTR)pPath));

    for (pT=pPath; *pPath; pPath=(LPSTR)AnsiNext(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':') && pPath[1])
            pT = pPath+1;
    }

    return (pT);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  AppendToPath() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Appends a filename to a path.  Checks the \ problem first
 *  (which is why one can't just use lstrcat())
 * Also don't append a \ to : so we can have drive-relative paths...
 * this last bit is no longer appropriate since we qualify first!
 *
 * is this relative junk needed anymore?  if not this can be
 * replaced with AddBackslash(); lstrcat()
 */

VOID
APIENTRY
AppendToPath(
            PSTR pPath,
            PSTR pMore
            )
{

    dbg(("AppendToPath(%s,%s);\r\n",(LPSTR)pPath,(LPSTR)pMore));

    /* Don't append a \ to empty paths. */
    if (*pPath) {
        LPSTR pPathBase = pPath;
        BYTE ch;

        while (*pPath)
            pPath++;

        ch = *AnsiPrev(pPathBase, pPath );
        if (ch != '\\')
            *pPath++='\\';
    }

    /* Skip any initial terminators on input. */
    while (*pMore == '\\')
        pMore = (LPSTR)AnsiNext(pMore);

    lstrcpy(pPath, pMore);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  RemoveLast() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Deletes the last component of a filename in a string. */

VOID
APIENTRY
RemoveLast(
          PSTR pFile
          )
{
    PSTR pT;

    dbg(("RemoveLast(%s);\r\n",(LPSTR)pFile));

    for (pT=pFile; *pFile; pFile=(LPSTR)AnsiNext(pFile)) {
        if (*pFile == '\\')
            pT = pFile;
        else if (*pFile == ':') {
            if (pFile[1] =='\\')
                pFile++;
            pT = pFile + 1;
        }
    }
    *pT = TEXT('\0');
}




// qualify a DOS (or LFN) file name based on the currently active window.
// this code is not careful to not write more than MAXPATHLEN characters
// into psz
//
// in:
//      psz     path to be qualified (of at least MAXPATHLEN characters)
//              ANSI string
//
// out:
//      psz     fully qualified version of input string based
//              on the current active window (current directory)
//

VOID
APIENTRY
QualifyPath(
           PSTR psz
           )
{
    INT cb, nSpaceLeft;
    CHAR szTemp[MAXPATHLEN];
    INT iDrive = 0;
    LPSTR pOrig;
    BOOL flfn = FALSE;

    STKCHK();

    dbg(("QualifyPath(%s);\r\n",(LPSTR)psz));

    /* Save it away. */
    strncpy(szTemp, psz, sizeof(szTemp));
    CheckSlashies(szTemp);
    StripColon(szTemp);

    nSpaceLeft = MAXPATHLEN;

    pOrig = szTemp;

    if (pOrig[0] == '\\' && pOrig[1] == '\\') {
        // leave the \\ in the buffer so that the various parts
        // of the UNC path will be qualified and appended.  Note
        // we must assume that UNCs are FAT's.
        psz[2] = 0;
        nSpaceLeft -= 3;
        goto GetComps;
    }

    if (pOrig[0] && pOrig[1]==':' && !IsDBCSLeadByte(pOrig[0])) {
        iDrive = DRIVEID(pOrig);

        /* Skip over the drive letter. */
        pOrig += 2;
    } else
        iDrive = GetSelectedDrive();

    flfn = IsLFNDrive(pOrig);
    #ifdef DEBUG
    if (flfn)
        dbg(("lfn qualify!\r\n"));
    else
        dbg(("normal qualify!\r\n"));
    #endif

    // on FAT devices, replace any illegal chars with underscores
    if (!flfn)
    {
        LPSTR pT;

        for (pT = pOrig; *pT; pT = (LPSTR)AnsiNext(pT));
        {
            if (!IsValidChar(*pT,TRUE))
                *pT = '_';
        }
    }

    if (pOrig[0]=='\\') {
        psz[0] = (CHAR)iDrive + (CHAR)'A';
        psz[1] = ':';
        psz[2] = '\\';
        psz[3] = 0;
        nSpaceLeft -= 4;
        pOrig++;
    } else {
        /* Get current dir of drive in path.  Also returns drive. */
        GetSelectedDirectory((WORD)(iDrive+1), psz);
        nSpaceLeft -= (lstrlen(psz) + 1);
    }

    GetComps:

    while (*pOrig && nSpaceLeft > 0) {
        /* If the component is parent dir, go up one dir.
         * If its the current dir, skip it, else add it normally
         */
        if (pOrig[0] == '.') {
            if (pOrig[1] == '.')
                RemoveLast(psz);
            else if (pOrig[1] && pOrig[1] != '\\')
                goto addcomponent;

            while (*pOrig && *pOrig != '\\')
                pOrig = (LPSTR)AnsiNext(pOrig);

            if (*pOrig)
                pOrig++;
        } else {
            LPSTR pT, pTT = NULL;

            addcomponent:
            AddBackslash(psz);
            nSpaceLeft--;

            pT = psz + lstrlen(psz);

            if (flfn) {
                // copy the component
                while (*pOrig && *pOrig != '\\') {
                    nSpaceLeft--;
                    if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                        if (nSpaceLeft <= 0) {
                            pT--;
                        } else {
                            *pT++ = *pOrig++;
                            nSpaceLeft--;
                        }
                    }
                }
            } else {
                // copy the filename (up to 8 chars)
                for (cb = 0; *pOrig && *pOrig != '\\' && *pOrig != '.' && nSpaceLeft > 0;) {
                    if (cb < 8) {
                        cb++;
                        nSpaceLeft--;
                        if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                            if (nSpaceLeft <= 0) {
                                pT--;
                            } else {
                                cb++;
                                *pT++ = *pOrig++;
                                nSpaceLeft--;
                            }
                        }
                    } else {
                        pOrig = AnsiNext(pOrig);
                    }
                }

                // if there's an extension, copy it, up to 3 chars
                if (*pOrig == '.' && nSpaceLeft > 0) {
                    *pT++ = '.';
                    nSpaceLeft--;
                    pOrig++;
                    for (cb = 0; *pOrig && *pOrig != '\\' && nSpaceLeft > 0;) {
                        if (*pOrig == '.')
                            cb = 3;

                        if (cb < 3) {
                            cb++;
                            nSpaceLeft--;
                            if (IsDBCSLeadByte(*pT++ = *pOrig++)) {
                                if (nSpaceLeft <= 0) {
                                    pT--;
                                } else {
                                    cb++;
                                    *pT++ = *pOrig++;
                                    nSpaceLeft--;
                                }
                            }
                        } else {
                            pOrig = AnsiNext(pOrig);
                        }
                    }
                }
            }

            // skip the backslash

            if (*pOrig)
                pOrig++;

            // null terminate for next pass...
            *pT = 0;

        }
    }

    StripBackslash(psz);

    // remove any trailing dots

    if (*(psz + lstrlen(psz) - 1) == '.')
        *(psz + lstrlen(psz) - 1) = 0;

}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsRootDirectory() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
IsRootDirectory(
               register LPSTR pPath
               )
{
    if (!IsDBCSLeadByte( *pPath )) {
        if (!lstrcmpi(pPath+1, ":\\"))
            return (TRUE);
        if (!lstrcmpi(pPath+1, ":"))
            return TRUE;
    }
    if (!lstrcmpi(pPath, "\\"))
        return (TRUE);
    return (FALSE);
}

// returns:
//  TRUE    if pPath is a directory, including the root and
//      relative paths "." and ".."
//  FALSE   not a dir

BOOL
IsDirectory(
           PSTR pPath
           )
{
    PSTR pT;
    CHAR szTemp[MAXPATHLEN];

    STKCHK();

    if (IsRootDirectory(pPath))
        return TRUE;

    // check for "." and ".."

    pT = FindFileName(pPath);
    if (pT[0] == '.') {
        if (!pT[1] || pT[1] == '.')
            return TRUE;
    }

    lstrcpy(szTemp, pPath);
    FixAnsiPathForDos(szTemp);

    return WFIsDir(szTemp);
}


//
// note: this has the side effect of setting the
// current drive to the new disk if it is successful
//

WORD
APIENTRY
IsTheDiskReallyThere(
                    HWND hwnd,
                    register LPSTR pPath,
                    WORD wFunc
                    )
{
    INT           i;
    register INT  drive;
    CHAR szTemp[MAXPATHLEN];
    INT err = 0;
    WORD wError;

    STKCHK();

#ifdef DEBUG
    {
        char szMsg[200];

        wsprintf(szMsg, "IsTheDiskReallyThere(%s)\r\n",(LPSTR)pPath);
        OutputDebugString(szMsg);
    }
#endif

    if (pPath[1]==':' && !IsDBCSLeadByte( *pPath ))
        drive = DRIVEID(pPath);
    else
        return TRUE;

Retry:

    err = SheGetDir(drive + 1, szTemp);

    if (err)
        goto DiskNotThere;

    return TRUE;

    DiskNotThere:
    wError = (WORD)GetExtendedError();

    if (wError == 0x15) {
        // drive not ready (no disk in the drive)

        LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_DRIVENOTREADY, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, drive + 'A');
        if (MessageBox(hwnd, szMessage, szTitle, MB_ICONEXCLAMATION | MB_RETRYCANCEL) == IDRETRY)
            goto Retry;
        else
            return FALSE;
    } else if (wError == 0x1F) {
        // general failue (disk not formatted)

        LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_UNFORMATTED, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, drive + 'A');
        if (MessageBox(hwnd, szMessage, szTitle, MB_ICONEXCLAMATION| MB_YESNO) == IDYES) {
            HWND hwndSave;

            // this is ugly: hdlgProgress is a global that is used
            // by the copy code and the format code.  this should
            // be rewritten so it is not a global (hdlgProgress should
            // be passed to all QueryAbort() functions, etc)

            hwndSave = hdlgProgress;
            nLastDriveInd = 0;
            for (i = 0; i < cDrives; i++) {
                if (IsRemovableDrive(rgiDrive[i])) {
                    if (rgiDrive[i] == drive)
                        break;
                    nLastDriveInd++;
                }
            }
            fFormatFlags |= FF_ONLYONE;     // alow only one format

            if (FormatDiskette(hwnd) != TRUE) {
                hdlgProgress = hwndSave;
                return FALSE;
            }
            hdlgProgress = hwndSave;
            goto Retry;
        } else
            return FALSE;
    }

    LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, 32);
    LoadString(hAppInstance, IDS_NOSUCHDRIVE, szTemp, sizeof(szTemp));
    wsprintf(szMessage, szTemp, drive + 'A');
    MessageBox(hwnd, szMessage, szTitle, MB_ICONHAND);

    return FALSE;
}



VOID
BuildDateLine(
             LPSTR szTemp,
             PLFNDTA plfndta
             )
{
    wsprintf(szTemp, szBytes, plfndta->fd.nFileSizeLow);
    lstrcat(szTemp, szSpace);
    PutDate(&plfndta->fd.ftLastWriteTime, szTemp + lstrlen(szTemp));
    lstrcat(szTemp, szSpace);
    PutTime(&plfndta->fd.ftLastWriteTime, szTemp + lstrlen(szTemp));
}


typedef struct {
    LPSTR pFileDest;
    LPSTR pFileSource;
    PLFNDTA plfndtaDest;
    PLFNDTA plfndtaSrc;
    INT bWriteProtect;
} PARAM_REPLACEDLG, *LPPARAM_REPLACEDLG;


VOID
SetDlgItemPath(
              HWND hDlg,
              INT id,
              LPSTR pszPath
              )
{
    RECT rc;
    HDC hdc;
    HFONT L_hFont;
    CHAR szPath[MAXPATHLEN+1] = {0};      // can have one extra char
    HWND hwnd;

    hwnd = GetDlgItem(hDlg, id);

    if (!hwnd)
        return;

    strncat(szPath, pszPath, sizeof(szPath)-1);

    GetClientRect(hwnd, &rc);

    hdc = GetDC(hDlg);
    L_hFont = (HANDLE)SendMessage(hwnd, WM_GETFONT, 0, 0L);
    if (L_hFont = SelectObject(hdc, L_hFont)) {
        CompactPath(hdc, szPath, (WORD)rc.right);
        SelectObject(hdc, L_hFont);
    }
    ReleaseDC(hDlg, hdc);
    SetWindowText(hwnd, szPath);
}



INT_PTR
APIENTRY
ReplaceDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    STKCHK();

    switch (wMsg) {
        case WM_INITDIALOG:
            {
#define lpdlgparams ((LPPARAM_REPLACEDLG)lParam)

                if (lpdlgparams->bWriteProtect) {
                    LoadString(hAppInstance, IDS_WRITEPROTECTFILE, szMessage, sizeof(szMessage));
                    SetDlgItemText(hDlg, IDD_STATUS, szMessage);
                }

                EnableWindow(GetDlgItem(hDlg, IDD_YESALL), !lpdlgparams->bWriteProtect && ManySource);

                lstrcpy(szMessage, lpdlgparams->pFileSource);
                lstrcat(szMessage, "?");
                SetDlgItemPath(hDlg, IDD_FROM, szMessage);

                if (lpdlgparams->pFileDest) {
                    BuildDateLine(szMessage, lpdlgparams->plfndtaSrc);
                    SetDlgItemText(hDlg, IDD_DATE2, szMessage);

                    SetDlgItemPath(hDlg, IDD_TO, lpdlgparams->pFileDest);
                    BuildDateLine(szMessage, lpdlgparams->plfndtaDest);
                    SetDlgItemText(hDlg, IDD_DATE1, szMessage);
                }

                break;
            }

        case WM_COMMAND:
            {
                WORD id;

                id = GET_WM_COMMAND_ID(wParam, lParam);
                switch (id) {
                    case IDD_HELP:
                        goto DoHelp;

                    case IDD_FLAGS:
                        break;

                    case IDD_YESALL:
                        *pbConfirmAll = TRUE;
                        id = IDYES;
                        // fall through
                    case IDYES:
                        // fall through
                    default:        // this is IDNO and IDCANCEL
                        EndDialog(hDlg, id);
                        return FALSE;
                }
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}





WORD
ConfirmDialog(
             HWND hDlg, WORD dlg,
             LPSTR pFileDest, PLFNDTA plfndtaDest,
             LPSTR pFileSource, PLFNDTA plfndtaSrc,
             BOOL bConfirmByDefault,
             BOOL *pbAll
             )
{
    INT w;
    PARAM_REPLACEDLG params;

    params.pFileDest = pFileDest;
    params.pFileSource = pFileSource;
    params.plfndtaDest = plfndtaDest;
    params.plfndtaSrc = plfndtaSrc;
    params.bWriteProtect = FALSE;

    pbConfirmAll = pbAll;         // set global for dialog box

    if (plfndtaDest->fd.dwFileAttributes & (ATTR_READONLY | ATTR_SYSTEM | ATTR_HIDDEN)) {
        DWORD dwSave = dwContext;

        dwContext = IDH_DLGFIRST + dlg;

        params.bWriteProtect = TRUE;
        w = (INT)DialogBoxParam(hAppInstance, MAKEINTRESOURCE(dlg), hDlg, ReplaceDlgProc, (LPARAM)&params);
        dwContext = dwSave;

        if (w == IDYES) {
            lstrcpy(szMessage, pFileDest ? (LPSTR)pFileDest : (LPSTR)pFileSource);
            FixAnsiPathForDos(szMessage);
            WFSetAttr(szMessage, plfndtaDest->fd.dwFileAttributes & ~(ATTR_READONLY|ATTR_HIDDEN|ATTR_SYSTEM));
        }

    } else if (!bConfirmByDefault || *pbConfirmAll) {
        w = IDYES;
    } else {
        DWORD dwSave = dwContext;

        dwContext = IDH_DLGFIRST + dlg;
        w = (INT)DialogBoxParam(hAppInstance, MAKEINTRESOURCE(dlg), hDlg, ReplaceDlgProc, (LPARAM)&params);
        dwContext = dwSave;
    }

    if (w == -1)
        w = DE_INSMEM;

    return (WORD)w;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  NetCheck() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* check rmdirs and mkdirs with the net driver
 */

WORD
APIENTRY
NetCheck(
        LPSTR pPath,
        WORD wType
        )
{
    UNREFERENCED_PARAMETER(pPath);
    UNREFERENCED_PARAMETER(wType);

    return WN_SUCCESS;
}



/*** FIX30: This "could use some cleaning up." ***/
/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MergePathName() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  Used to generate destination filenames given a pattern and an original
 *  source name.  ? is replaced by the corresponding character in the source,
 *  and * is replaced by the remainder of the source name.
 *
 *  pPath   path with wildcards to be expanded
 *  pName   mask used to expand pName
 *
 * DBCS by 07/21/90 - Yukinin
 *
 */

VOID
MergePathName(
             LPSTR pPath,
             LPSTR pName
             )
{
    INT   i;
    INT   cch;
    LPSTR pWild, p2, pEnd;
    BOOL  bNoDir  = FALSE;
    CHAR  szWildPart[13];

    // if there are no wild cards the destination path does not need merging.
    if (!IsWild(pPath))
        return;

    if (LFNMergePath(pPath,pName))
        return;

    // copy only 8.3... this part may not be fully qualified for rename
    pWild = FindFileName(pPath);

    for (p2=szWildPart,i=0; *pWild && *pWild != '.' && i<8; i++, pWild++, p2++) {
        *p2 = *pWild;
        if (IsDBCSLeadByte(*pWild)) {
            if (i == 7)
                break;
            *(++p2) = *(++pWild);
            i++;
        }
    }

    while (*pWild && *pWild != '.')
        pWild = (LPSTR)AnsiNext(pWild);

    if (*pWild == '.') {
        *p2++ = '.';
        pWild++;
        for (i=0; *pWild && i < 3; i++, pWild++, p2++) {
            *p2 = *pWild;
            if (IsDBCSLeadByte( *pWild )) {
                if (i == 2)
                    break;
                *(++p2) = *(++pWild);
                i++;
            }
        }
    }
    *p2 = 0;

    // szWildPart now has the 8.3 form of the wildcard mask

    RemoveLast(pPath);
    AddBackslash(pPath);
    for (pEnd = pPath; *pEnd; pEnd++);    // point to end of string

    pWild = szWildPart;
    cch = 8;

    merge:

    for (i=0; i < cch; i+=(IsDBCSLeadByte(*pWild)?2:1), pWild=AnsiNext(pWild)) {
        switch (*pWild) {
            case '\0':
            case ' ':
            case '.':
                break;

            case '*':
                pWild--;
                /*** FALL THRU ***/

            case '?':
                if (*pName && *pName!='.')
                    *pEnd++ = *pName++;
                continue;

            default:
                *pEnd++ = *pWild;
                if (IsDBCSLeadByte(*pWild)) {
                    *pEnd++ = pWild[1];
                    if (*pName && *pName != '.')
                        pName++;
                }
                continue;
        }
        break;
    }

    while (*pName && *pName != '.')
        pName = AnsiNext(pName);
    if (*pName)
        pName++;

    while (*pWild && *pWild != '.')
        pWild = AnsiNext(pWild);
    if (*pWild)
        pWild++;

    if (*pWild) {
        *pEnd++ = '.';
        cch = 3;
        goto merge;       // do it for the extension part now
    } else {
        if (pEnd[-1]=='.')
            pEnd[-1]=0;
        else
            pEnd[0] = TEXT('\0');
    }

    QualifyPath(pPath);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsInvalidPath() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks to see if a file spec is an evil character device or if it is
 * too long...
 */

BOOL
IsInvalidPath(
             register LPSTR pPath
             )
{
    CHAR  sz[9];
    INT   n = 0;

    if (lstrlen(pPath) >= MAXPATHLEN-1)
        return (TRUE);

    pPath = FindFileName(pPath);

    while (*pPath && *pPath != '.' && *pPath != ':' && n < 8) {
        if (IsDBCSLeadByte( *pPath )) {
            if (n == 7)
                break;
            sz[n++] = *pPath;
        }
        sz[n++] = *pPath++;
    }

    sz[n] = TEXT('\0');

    if (!_stricmp(sz,"CON"))
        return (TRUE);

    if (!_stricmp(sz,"MS$MOUSE"))
        return (TRUE);

    if (!_stricmp(sz,"EMMXXXX0"))
        return (TRUE);

    if (!_stricmp(sz,"CLOCK$"))
        return (TRUE);

    return (FALSE);
}


PLFNDTA CurPDTA(PCOPYROOT pcr)
{
    if (pcr->cDepth) {
        return (pcr->rgDTA + pcr->cDepth - 1);
    } else {
        return pcr->rgDTA;
    }
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  GetNextCleanup() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

VOID
GetNextCleanup(
              PCOPYROOT pcr
              )
{
    while (pcr->cDepth) {
        WFFindClose(CurPDTA(pcr));
        pcr->cDepth--;
    }
}


/* GetNameDialog
 *
 *  Runs the dialog box to prompt the user for a new filename when copying
 *  or moving from HPFS to FAT.
 */

WORD GetNameDialog(WORD, LPSTR, LPSTR);
INT_PTR  APIENTRY GetNameDlgProc(HWND,UINT,WPARAM,LPARAM);

WORD wDialogOp;
LPSTR pszDialogFrom;
LPSTR pszDialogTo;

INT_PTR
APIENTRY
GetNameDlgProc(
              HWND hwnd,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    CHAR szT[14];
    LPSTR p;
    INT i, j, cMax, fDot;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            // inform the user of the old name
            SetDlgItemText(hwnd, IDD_FROM, pszDialogFrom);

            // generate a guess for the new name
            p = FindFileName(pszDialogFrom);
            for (i = j = fDot = 0, cMax = 8; *p; p++) {
                if (*p == '.') {
                    // if there was a previous dot, step back to it
                    // this way, we get the last extension
                    if (fDot)
                        i -= j+1;

                    // set number of chars to 0, put the dot in
                    j = 0;
                    szT[i++] = '.';

                    // remember we saw a dot and set max 3 chars.
                    fDot = TRUE;
                    cMax = 3;
                } else if (j < cMax && IsValidChar(*p,FALSE)) {
                    if (IsDBCSLeadByte(*p)) {
                        szT[i] = *p++;
                        if (++j >= cMax)
                            continue;
                        ++i;
                    }
                    j++;
                    szT[i++] = *p;
                }
            }
            szT[i] = 0;
            SetDlgItemText(hwnd, IDD_TO, szT);
            SendDlgItemMessage(hwnd,IDD_TO,EM_LIMITTEXT,13,0L);

            // directory the file will go into
            RemoveLast(pszDialogTo);
            SetDlgItemText(hwnd, IDD_DIR, pszDialogTo);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDOK:
                    GetDlgItemText(hwnd,IDD_TO,szT,14);
                    AppendToPath(pszDialogTo,szT);
                    QualifyPath(pszDialogTo);
                    EndDialog(hwnd,IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd,IDCANCEL);
                    break;

                case IDD_HELP:
                    goto DoHelp;

                case IDD_TO:
                    GetDlgItemText(hwnd,IDD_TO,szT,14);
                    for (p = szT; *p; p=AnsiNext(p))
                    {
                        if (!IsValidChar(*p,FALSE))
                            break;
                    }

                    EnableWindow(GetDlgItem(hwnd,IDOK),((!*p) && (p != szT)));
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hwnd);
                return TRUE;
            }
            return FALSE;
    }

    return TRUE;
}

WORD
GetNameDialog(
             WORD wOp,
             LPSTR pFrom,
             LPSTR pTo
             )
{
    WORD wRet = -1;
    DWORD dwSave;

    dwSave = dwContext;
    dwContext = IDH_DLGFIRST + LFNTOFATDLG;

    wDialogOp = wOp;
    pszDialogFrom = pFrom;
    pszDialogTo = pTo;

    wRet = (WORD)DialogBox(hAppInstance, MAKEINTRESOURCE(LFNTOFATDLG), hdlgProgress, GetNameDlgProc);
    dwContext = dwSave;
    return wRet;
}

/*============================================================================
;
; GetNextPair
;
; The following function determines the next pair of files to copy, rename,
; move, or delete.
;
; Parameters:
;
; pcr     - Pointer to structure for recursing directory tree
; pFrom   - Source file or directory to copy
; pToPath - Path to destination file or directory
; pToSpec - Raw destination file or directory name
; wFunc   - Operation being performed.  Can be one of:
;
;           FUNC_DELETE - Delete files in pFrom
;           FUNC_RENAME - Rename files (same directory)
;           FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;           FUNC_COPY   - Copy files in pFrom to pTo
;
; Return Value:  Type of operation to perform.  Can be one of:
;
;                OPER_ERROR  - Error processing filenames
;                OPER_DOFILE - Go ahead and copy, rename, or delete file
;                OPER_MKDIR  - Make a directory specified in pTo
;                OPER_RMDIR  - Remove directory
;                0           - No more files left
;
; Revision History:
;
; Modified by C. Stevens, August, 1991.  Added logic so that we would call
; IsTheDiskReallyThere only once per drive.  Also changed some of the code
; to minimize the number of calls which access the disk.
;
============================================================================*/

WORD
GetNextPair(
           PCOPYROOT pcr,
           PSTR pFrom,
           PSTR pToPath,
           PSTR pToSpec,
           WORD wFunc
           )

{
    PSTR pT;                  /* Temporary pointer */
    WORD wOp;                 /* Return value (operation to perform */
    PLFNDTA pDTA;             /* Pointer to file DTA data */
    CHAR szOEM[MAXPATHLEN+1]; /* OEM version of string */

    STKCHK();
    *pFrom = TEXT('\0');
    dbg(("GetNextPair(-,-,%s,%s,%d);\r\n", (LPSTR)pToPath, (LPSTR)pToSpec, wFunc));

    /* Keep recursing directory structure until we get to the bottom */

    while (TRUE) {
        dbg (("    top of loop....\r\n"));
        if (pcr->cDepth) {

            /* The directory we returned last call needs to be recursed. */

            pDTA = pcr->rgDTA + pcr->cDepth - 1;   // use this DTA below

            dbg (("    pcr->cDepth=%d\r\n",pcr->cDepth));

            if (pcr->fRecurse && pcr->cDepth == 1 && !pcr->rgDTA[0].fd.cFileName[0])
                /* The last one was the recursion root. */
                goto BeginDirSearch;

            if (pcr->cDepth >= (MAXDIRDEPTH - 1)) {    // reached the limit?
                wOp = OPER_ERROR | DE_PATHTODEEP;
                goto ReturnPair;
            }

            if (pcr->fRecurse && (pDTA->fd.dwFileAttributes & ATTR_DIR) &&
                !(pDTA->fd.dwFileAttributes & ATTR_RETURNED)) {

                /* Was returned on last call, begin search. */

                pDTA->fd.dwFileAttributes |= ATTR_RETURNED;

                pcr->cDepth++;
                pDTA++;

                BeginDirSearch:

                /* Search for all subfiles in directory. */

                dbg (("    BeginDirSearch\r\n"));
                AppendToPath (pcr->sz,szStarDotStar);
                goto BeginSearch;
            }

            SkipThisFile:

            /* Search for the next matching file. */

            dbg (("    SkipThisFile:\r\n"));
            if (!WFFindNext (pDTA)) {
                dbg (("    FindNext() fails\r\n"));
                WFFindClose (pDTA);

                LeaveDirectory:

                /* This spec has been exhausted... */

                pcr->cDepth--;

                /* Remove the child file spec. */

                RemoveLast (pcr->sz);
                RemoveLast (pcr->szDest);

                if (pcr->fRecurse) {

                    /* Tell the move/copy driver it can now delete
                       the source directory if necessary. */

                    wOp = OPER_RMDIR;
                    goto ReturnPair;
                }

                /* Not recursing, get more stuff. */

                continue;
            }

            ProcessSearchResult:

            /* Got a file or dir in the DTA which matches the wild card
                originally passed in...  */

            dbg (("     ProcessSearchResult:\r\n"));
            dbg (("     found %s\r\n",(LPSTR)pDTA->fd.cFileName));
            if (pDTA->fd.dwFileAttributes & ATTR_DIR) {

                /* Ignore directories if we're not recursing. */

                if (!pcr->fRecurse)
                    goto SkipThisFile;

                /* Skip the current and parent directories. */

                if (pDTA->fd.cFileName[0]=='.') {
                    if (!pDTA->fd.cFileName[1] || pDTA->fd.cFileName[1] == '.')
                        goto SkipThisFile;
                }

                /* We need to create this directory, and then begin searching
                   for subfiles. */

                wOp = OPER_MKDIR;
                RemoveLast (pcr->sz);
                OemToCharBuff (pDTA->fd.cFileName,pDTA->fd.cFileName, sizeof(pDTA->fd.cFileName)/sizeof(pDTA->fd.cFileName[0]));
                AppendToPath (pcr->sz,pDTA->fd.cFileName);
                AppendToPath (pcr->szDest,pDTA->fd.cFileName);
                goto ReturnPair;
            }

            if (pcr->fRecurse || !(pDTA->fd.dwFileAttributes & ATTR_DIR)) {

                /* Remove the original spec. */

                RemoveLast (pcr->sz);

                /* Replace it. */

                AppendToPath (pcr->sz,pDTA->fd.cFileName);

                /* Convert to ANSI. */

                pT = FindFileName (pcr->sz);
                OemToCharBuff (pT,pT, strlen(pT)+1);

                /* If its a dir, tell the driver to create it
                   otherwise, tell the driver to "operate" on the file. */

                wOp = (WORD)((pDTA->fd.dwFileAttributes & ATTR_DIR) ? OPER_RMDIR : OPER_DOFILE);
                goto ReturnPair;
            }
            continue;
        } else {

            /* Read the next source spec out of the raw source string. */

            pcr->fRecurse = 0;
            pcr->pSource = GetNextFile (pcr->pSource,pcr->sz,sizeof(pcr->sz));
            pcr->szDest[0] = 0;
            if (!pcr->pSource)
                return (0);

            /* Fully qualify the path */

            QualifyPath(pcr->sz);

            /* Ensure the source disk really exists before doing anything.
               Only call IsTheDiskReallyThere once for each drive letter.
               Set pcr->cIsDiskThereCheck[DRIVEID] after disk has been
               checked.  Modified by C. Stevens, August 1991 */

            if (pcr->sz[1]==':' && !pcr->cIsDiskThereCheck[DRIVEID (pcr->sz)]) {
                if (!IsTheDiskReallyThere(hdlgProgress, pcr->sz, wFunc))
                    return (0);
                pcr->cIsDiskThereCheck[DRIVEID (pcr->sz)] = 1;
            }

            /* Classify the input string. */

            if (IsWild (pcr->sz)) {

                /* Wild card... operate on all matches but not recursively. */

                pcr->cDepth = 1;
                pDTA = pcr->rgDTA;
                pcr->pRoot = NULL;

                BeginSearch:

                dbg (("   BeginSearch: (on %s)\r\n",(LPSTR)pcr->sz));

                /* Quit if pcr->sz gets too big. */

                if (lstrlen (pcr->sz) - lstrlen (FindFileName (pcr->sz)) >= MAXPATHLEN)
                    goto SearchStartFail;

                lstrcpy (szOEM,pcr->sz);
                FixAnsiPathForDos (szOEM);

                /* Search for the wildcard spec in pcr->sz. */

                if (!WFFindFirst(pDTA, szOEM, ATTR_ALL)) {

                    SearchStartFail:

                    dbg(("   StartSearchFail:\r\n"));
                    if (pcr->fRecurse) {

                        /* We are inside a recursive directory delete, so
                           instead of erroring out, go back a level */

                        goto LeaveDirectory;
                    }
                    lstrcpy (pFrom,pcr->sz);

                    /* Back up as if we completed a search. */

                    RemoveLast (pcr->sz);
                    pcr->cDepth--;

                    /* Find First returned an error.  Return FileNotFound. */

                    wOp = OPER_ERROR | DE_FILENOTFOUND;
                    goto ReturnPair;
                }
                goto ProcessSearchResult;
            } else {

                /* This could be a file or a directory.  Fill in the DTA
                   structure for attrib check */

                if (!IsRootDirectory(pcr->sz)) {
                    lstrcpy(szOEM,pcr->sz);
                    FixAnsiPathForDos(szOEM);
                    if (!WFFindFirst(pcr->rgDTA, szOEM, ATTR_ALL)) {
                        wOp = OPER_ERROR | DE_FILENOTFOUND;
                        goto ReturnPair;
                    }
                    WFFindClose(pcr->rgDTA);
                }

                /* Now determine if its a file or a directory */

                pDTA = pcr->rgDTA;
                if (IsRootDirectory(pcr->sz) || (pDTA->fd.dwFileAttributes & ATTR_DIR)) {

                    /* Process directory */

                    if (wFunc == FUNC_RENAME) {
                        if (IsRootDirectory (pcr->sz))
                            wOp = OPER_ERROR | DE_ROOTDIR;
                        else
                            wOp = OPER_DOFILE;
                        goto ReturnPair;
                    }

                    /* Directory: operation is recursive. */

                    pcr->fRecurse = TRUE;
                    pcr->cDepth = 1;
                    pDTA->fd.cFileName[0] = 0;
                    pcr->pRoot = FindFileName (pcr->sz);
                    lstrcpy (pcr->szDest,pcr->pRoot);
                    wOp = OPER_MKDIR;
                    goto ReturnPair;
                } else {

                    /* Process file */

                    pcr->pRoot = NULL;
                    wOp = OPER_DOFILE;
                    goto ReturnPair;
                }
            }
        }
    }

    ReturnPair:

    /* The source filespec has been derived into pcr->sz
       that is copied to pFrom.  pcr->sz and pToSpec are merged into pTo. */

    dbg(("    ReturnPair:\r\n"));
    if (!*pFrom)
        lstrcpy(pFrom,pcr->sz);
    QualifyPath(pFrom);

    if (wFunc != FUNC_DELETE) {
        if (wFunc == FUNC_RENAME && !*pToPath) {
            lstrcpy(pToPath, pFrom);
            RemoveLast(pToPath);
            AppendToPath(pToPath, pToSpec);
        } else {
            AppendToPath(pToPath,pcr->szDest);
            if (wOp == OPER_MKDIR)
                RemoveLast(pToPath);
            AppendToPath(pToPath,pToSpec);
        }

        if ((wOp == OPER_MKDIR || wOp == OPER_DOFILE) &&
            (!IsLFNDrive(pToPath) && IsLFNDrive(pFrom))  &&
            IsLFN (FindFileName (pFrom)) &&
            (IsWild(pToSpec) || IsLFN(pToSpec))) {

            if (GetNameDialog(wOp, pFrom, pToPath) != IDOK)
                return 0;   /* User cancelled the operation, return failure */

            /* Update the "to" path with the FAT name chosen by the user. */

            if (wOp == OPER_MKDIR) {
                RemoveLast(pcr->szDest);
                AppendToPath(pcr->szDest, FindFileName(pToPath));
            }
        } else
            MergePathName(pToPath, FindFileName(pFrom));
    }

    if (wOp == OPER_MKDIR) {

        /* Make sure the new directory is not a subdir of the original... */

        while (*pFrom && *pFrom == *pToPath) {
            pFrom++;
            pToPath++;
        }
        if (!*pFrom && (!*pToPath || *pToPath == '\\')) {

            /* The two fully qualified strings are equal up to the end of the
               source directory ==> the destination is a subdir.Must return
               an error. */

            wOp = OPER_ERROR | DE_DESTSUBTREE;
        }
    }

    return wOp;
}


VOID
CdDotDot (
         PSTR szOrig
         )
{
    CHAR szTemp[MAXPATHLEN] = {0};

    STKCHK();

    strncat(szTemp, szOrig, sizeof(szTemp)-1);
    StripFilespec(szTemp);
    SheChangeDir(szTemp);
}

/* p is a fully qualified ANSI string. */

BOOL
IsCurrentDirectory (
                   PSTR p
                   )
{
    CHAR szTemp[MAXPATHLEN];

    STKCHK();

    SheGetDir(DRIVEID(p) + 1, szTemp);
    OemToCharBuff(szTemp, szTemp, sizeof(szTemp)/sizeof(szTemp[0]));
    return (lstrcmpi(szTemp, p) == 0);
}


//
// test input for "multiple" filespec
//
// examples:
//  0   foo.bar         (single non directory file)
//  1   *.exe           (wild card)
//  1   foo.bar bletch.txt  (multiple files)
//  2   c:\         (directory)
//
// note: this may hit the disk in the directory check
//

INT
CheckMultiple(
             register PSTR pInput
             )
{
    PSTR pT;
    CHAR szTemp[MAXPATHLEN];

    /* Wildcards imply multiple files. */
    if (IsWild(pInput))
        return 1;     // wild card

    /* More than one thing implies multiple files. */
    pT = GetNextFile(pInput, szTemp, sizeof(szTemp));
    if (!pT)
        return 0;     // blank string

    StripBackslash(szTemp);

    if (IsDirectory(szTemp))
        return 2;     // directory

    pT = GetNextFile(pT, szTemp, sizeof(szTemp));

    return pT ? 1 : 0;    // several files, or just one
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DialogEnterFileStuff() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Prevents the user from diddling anything other than the cancel button. */

VOID
DialogEnterFileStuff(
                    register HWND hwnd
                    )
{
    register HWND hwndT;

    /* set the focus to the cancel button so the user can hit space or esc
     */
    if (hwndT = GetDlgItem(hwnd, IDCANCEL)) {
        SetFocus(hwndT);
        SendMessage(hwnd,DM_SETDEFID,IDCANCEL,0L);
    }

    /* disable the ok button and the edit controls
     */
    if (hwndT = GetDlgItem(hwnd, IDOK))
        EnableWindow(hwndT, FALSE);

    if (hwndT = GetDlgItem(hwnd, IDD_TO))
        EnableWindow(hwndT, FALSE);

    if (hwndT = GetDlgItem(hwnd, IDD_FROM))
        EnableWindow(hwndT, FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Notify() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Sets the status dialog item in the modeless status dialog box. */

// used for both the drag drop status dialogs and the manual user
// entry dialogs so be careful what you change

VOID
Notify(
      HWND hDlg,
      WORD idMessage,
      PSTR szFrom,
      PSTR szTo
      )
{
    CHAR szTemp[40];

    if (!bCopyReport)
        return;

    if (idMessage) {
        LoadString(hAppInstance, idMessage, szTemp, sizeof(szTemp));
        SetDlgItemText(hDlg, IDD_STATUS, szTemp);
        SetDlgItemPath(hDlg, IDD_NAME, szFrom);
    } else {
        SetDlgItemText(hDlg, IDD_STATUS, szNULL);
        SetDlgItemText(hDlg, IDD_NAME, szNULL);
    }

    // is this the drag/drop status dialog or the move/copy dialog

    SetDlgItemPath(hDlg, IDD_TONAME, szTo);

}

//
// BOOL IsWindowsFile(LPSTR szFileOEM)
//
// this is a bit strange.  kernel strips off the path info so he
// will match only on the base name of the file.  so if the base
// name matches a currently open windows file we get the full
// path string and compare against that.  that will tell
// us that we have a file that kernel has open.
//
// LFN: detect long names and ignore them?

BOOL
IsWindowsFile(
             LPSTR szFileOEM
             )
{
    HANDLE hMod;
    CHAR szModule[MAXPATHLEN];

    STKCHK();

    /* kernel can't load an lfn...
     */
    if (GetNameType(szFileOEM) == FILE_LONG)
        return FALSE;

    // kernel won't accept long paths

    lstrcpy(szModule, szFileOEM);
    StripPath(szModule);

    hMod = GetModuleHandle(szModule);

    // check for one cause that's what's returned if its MSDOS
    // but it isn't really loaded because of xl 2.1c kernel hack
    if (!hMod || hMod == (HANDLE)1)
        return FALSE;

    GetModuleFileName(hMod, szModule, sizeof(szModule));

    if (!lstrcmpi(szFileOEM, szModule))     // they are both OEM & we
        return TRUE;                    // just care about equality
    else
        return FALSE;
}


WORD
SafeFileRemove(
              LPSTR szFileOEM
              )
{
    if (IsWindowsFile(szFileOEM))
        return DE_WINDOWSFILE;
    else
        return WFRemove(szFileOEM);
}


INT
APIENTRY
WF_CreateDirectory(
                  HWND hwndParent,
                  LPSTR szDestOEM
                  )
{
    INT ret = 0;
    CHAR szTemp[MAXPATHLEN + 1];    // +1 for AddBackslash()
    LPSTR p;
    BOOL bCheckPath = IsRemoteDrive(DRIVEID(szDestOEM));

    STKCHK();

#ifdef DEBUG
    if (szDestOEM[1] != ':')
        OutputDebugString("CreateDirectory() with non qualified path\r\n");
#endif

    // now create the full dir tree on the destination

    strncpy(szTemp, szDestOEM, sizeof(szTemp)-1);

    AddBackslash(szTemp); // for the loop below

    p = szTemp + 3;   // assume we have 'X:\' to start

    // create each part of the dir in order

    while (*p) {
        while (*p && *p != '\\')
            p = AnsiNext(p);

        if (*p) {

            *p = 0;

            if (!(ret = MKDir(szTemp))) {
                if (bCheckPath) {
                    static CHAR szTempTemp[] = "temptemp.tmp";

                    BOOL bFoundFile = FALSE;
                    PSTR pEnd;
                    CHAR szTempFile[MAXPATHLEN+sizeof(szTempTemp)];
                    LFNDTA DTA;
                    HDC hDC;
                    INT fh;

                    /* Note that this assumes the dir has just been created,
                     * so it is empty (except possibly for "." and "..")
                     */
                    lstrcpy(szTempFile, szTemp);
                    pEnd = szTempFile + lstrlen(szTempFile);
                    *pEnd++ = '\\';
                    lstrcpy(pEnd, szTempTemp);
                    if (fh=_lcreat(szTempFile, 0)!= -1) {
                        _lclose(fh);
                        lstrcpy(pEnd, szStarDotStar);
                        if (WFFindFirst(&DTA, szTempFile, ATTR_ALL&(~ATTR_DIR))) {
                            do {
                                if (!lstrcmpi(DTA.fd.cFileName, szTempTemp)) {
                                    bFoundFile = TRUE;
                                    break;
                                }
                            } while (WFFindNext(&DTA)) ;
                            WFFindClose(&DTA);
                        }
                        lstrcpy(pEnd, szTempTemp);
                        WFRemove(szTempFile);
                    }

                    if (!bFoundFile) {
                        *(pEnd-1) = '\0';
                        hDC = GetDC(NULL);
                        CompactPath(hDC, szTempFile, (WORD)(GetSystemMetrics(SM_CXSCREEN)/2));
                        ReleaseDC(NULL, hDC);

                        LoadString(hAppInstance, IDS_CREATELONGDIR,
                                   szTitle, sizeof(szTitle));
                        wsprintf(szMessage, szTitle, (LPSTR)szTempFile);
                        LoadString(hAppInstance, IDS_CREATELONGDIRTITLE,
                                   szTitle, sizeof(szTitle));

                        if (MessageBox(hwndParent, szMessage, szTitle,
                                       MB_ICONHAND|MB_YESNO) != IDYES) {
                            RMDir(szTemp);
                            return (DE_OPCANCELLED);
                        }
                    }
                }

                /* Allow the WM_FILESYSCHANGE messages to be processed
                 */
                wfYield();
            }

            *p++ = '\\';
        }
    }

    return ret;   // return the last error code
}

/*============================================================================
;
; WFMoveCopyDriver
;
; The following function is the mainline function for COPYing, RENAMEing,
; DELETEing, and MOVEing single or multiple files.
;
; Parameters:
;
; pFrom - String containing list of source specs
; pTo   - String containing destination specs
; wFunc - Operation to be performed.  Possible values are:
;         FUNC_DELETE - Delete files in pFrom
;         FUNC_RENAME - Rename files (same directory)
;         FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;         FUNC_COPY   - Copy files in pFrom to pTo
;
; Return Value: A 0 indicates success.
;
; Modification History:
;
; August 1991 - Modified by C. Stevens.  Added code to allow us to queue
;               calls to GetNextPair.  The purpose of this is to examine as
;               many source files at once as possible.  This keeps the source
;               disk spinning, so we don't suffer from having to wait for the
;               source disk to speed up every time we call GetNextPair.  Also
;               see the comments for WFCopy and FileCopy.  I have changed the
;               code here so we can queue the copy operations.  This allows
;               us to open several source and destination files in one go,
;               minimizing seek time to the directory track.
;
============================================================================*/

WORD
APIENTRY
WFMoveCopyDriver(
                PSTR pFrom,
                PSTR pTo,
                WORD wFunc
                )
{
    INT i = 0;                         // Counter
    WORD ret = 0;                      // Return value from WFMoveCopyDriver
    PSTR pSpec;                        // Pointer to file spec
    WORD wAttr;                        // File attributes
    WORD oper = 0;                     // Disk operation being performed
    CHAR szDestSpec[MAXFILENAMELEN+1]; // Dest file spec
    CHAR szDest[MAXPATHLEN];           // Dest file (ANSI string)
    CHAR szDestOEM[MAXPATHLEN];        // OEM version of above
    CHAR szSource[MAXPATHLEN];         // Source file (ANSI string)
    CHAR szSourceOEM[MAXPATHLEN];      // OEM version of above
    LFNDTA DTADest;                    // DTA block for reporting dest errors
    PLFNDTA pDTA;                      // DTA pointer for source errors
    PCOPYROOT pcr;                 // Structure for searching source tree
    BOOL bReplaceAll = FALSE;          // Replace all flag
    BOOL bSubtreeDelAll = FALSE;       // Delete entire subtree flag
    BOOL bDeleteAll = FALSE;           // Delete all files flag
    BOOL bFalse = FALSE;               // For cases that aren't disableable
    INT nNumQueue = 0;                 // Number of calls to GetNextPair
    PGETNEXTQUEUE pGetNextQueue = NULL;// Pointer to GetNextPair queue buffer
    INT CurIDS = 0;            // Current string displayed in status

    /* Initialization stuff.  Disable all file system change processing until
       we're all done */

    STKCHK();

    bCopyReport = TRUE;
    szDest[0] = szSource[0] = 0;
    DisableFSC();

    /* Change all '/' characters to '\' characters in dest spec */

    CheckSlashies(pFrom);
    bUserAbort = FALSE;

    /* Check for multiple source files */

    ManySource = CheckMultiple(pFrom);

    /* Allocate buffer for searching the source tree */

    pcr = (PCOPYROOT)LocalAlloc(LPTR, sizeof(COPYROOT));
    if (!pcr) {
        ret = DE_INSMEM;
        goto ShowMessageBox;
    }

    /* Allocate a buffer so we can queue calls to GetNextPair. */

    pGetNextQueue = (PGETNEXTQUEUE)LocalAlloc(LPTR, COPYMAXFILES * sizeof (GETNEXTQUEUE));
    if (!pGetNextQueue) {
        ret = DE_INSMEM;
        goto ShowMessageBox;
    }

    /* Skip destination specific processing if we are deleting files */

    if (wFunc != FUNC_DELETE) {

        // it is an error condition if there are multiple files
        // specified as the dest (but not a single directory)

        pSpec = GetNextFile(pTo, szMessage, MAXPATHLEN);

        if (GetNextFile(pSpec, szMessage, MAXPATHLEN) != NULL) {
            // move, copy specified with multiple destinations
            // not allowed, error case
            ret = DE_MANYDEST;
            goto ShowMessageBox;
        }

        lstrcpy(pTo, szMessage);
        QualifyPath(pTo);

        if (wFunc == FUNC_RENAME) {
            // don't let them rename multiple files to one single file

            if ((ManySource == 1) && !IsWild(pTo)) {
                ret = DE_MANYSRC1DEST;
                goto ShowMessageBox;
            }

        } else {

            /* We are either executing FUNC_COPY or FUNC_MOVE at this point.
               Check that the destination disk is there.  NOTE: There's a disk
               access here slowing us down. */

            if (!IsTheDiskReallyThere(hdlgProgress,pTo,wFunc))
                goto CancelWholeOperation;

            // deal with case where directory is implicit in source
            // move/copy: *.* -> c:\windows, c:\windows -> c:\temp
            // or foo.bar -> c:\temp

            if (!IsWild(pTo) && (ManySource || IsDirectory(pTo))) {
                AddBackslash(pTo);
                lstrcat(pTo, szStarDotStar);
            }
        }

        /* FUNC_RENAME or FUNC_MOVE FUNC_COPY with a file name dest
           (possibly including wildcards).  Save the filespec and the path
           part of the destination */

        pSpec = FindFileName(pTo);
        lstrcpy(szDestSpec,pSpec);
        lstrcpy(szDest,pTo);
        RemoveLast(szDest);

        pSpec = szDest + lstrlen(szDest);
    }
    pcr->pSource = pFrom;

    /* Disable all but the cancel button on the notify dialog */

    DialogEnterFileStuff(hdlgProgress);

    /* Set up arguments for queued copy commands */

    lpCopyBuffer = NULL;
    pCopyQueue = NULL;

    while (pcr) {

        /* Allow the user to abort the operation */

        if (WFQueryAbort())
            goto CancelWholeOperation;

        /* Now queue up a bunch of GetNextPair calls. */

        for (nNumQueue = 0; nNumQueue < COPYMAXFILES; nNumQueue++) {

            /* Clean off the last filespec for multiple file copies */

            if (wFunc != FUNC_DELETE) {
                *pSpec = TEXT('\0');
            }

            oper = GetNextPair(pcr,szSource,szDest,szDestSpec,wFunc);

            /* Check for no operation or error */

            if (!oper) {
                LocalFree((HANDLE)pcr);
                pcr = NULL;
                break;
            }
            if ((oper & OPER_MASK) == OPER_ERROR) {
                ret = LOBYTE (oper);
                oper = OPER_DOFILE;
                goto ShowMessageBox;
            }

            pGetNextQueue[nNumQueue].nOper = oper;
            lstrcpy(pGetNextQueue[nNumQueue].szSource, szSource);
            lstrcpy(pGetNextQueue[nNumQueue].szDest, szDest);
            pGetNextQueue[nNumQueue].SourceDTA = *CurPDTA(pcr);
        }

        /* Execute the queued GetNextPair calls */

        for (i = 0; i < nNumQueue; i++) {

            /* Allow the user to abort the operation */

            if (WFQueryAbort())
                goto CancelWholeOperation;

            oper = (WORD)pGetNextQueue[i].nOper;
            lstrcpy(szSource, pGetNextQueue[i].szSource);
            lstrcpy(szDest, pGetNextQueue[i].szDest);
            pDTA = &pGetNextQueue[i].SourceDTA;

            dbg(("Gonna do OPER:%x FUNC:%x '%s' and '%s'.\r\n",oper,wFunc, (LPSTR)szSource, (LPSTR)szDest));

            /* Fix up source spec */

            lstrcpy (szSourceOEM,szSource);
            FixAnsiPathForDos (szSourceOEM);
            if (IsInvalidPath (szSource)) {
                ret = DE_ACCESSDENIED;
                goto ShowMessageBox;
            }

            if (wFunc != FUNC_DELETE) {

                /* Fix up dest spec */

                lstrcpy(szDestOEM, szDest);
                FixAnsiPathForDos(szDestOEM);
                if (!lstrcmpi(szSource, szDest)) {
                    ret = DE_SAMEFILE;
                    goto ShowMessageBox;
                } else if (IsInvalidPath (szDest)) {
                    ret = DE_ACCESSDENIED | ERRORONDEST;
                    goto ShowMessageBox;
                }

                /* Check to see if we are overwriting an existing file.  If so,
                   better confirm */

                if (oper == OPER_DOFILE) {

                    // we can avoid this expensive call on dos 4.0 and up
                    // by using the extended open don't replace option

                    if (WFFindFirst(&DTADest, szDestOEM, ATTR_ALL)) {
                        WFFindClose(&DTADest);

                        if (wFunc == FUNC_RENAME) {
                            ret = DE_RENAMREPLACE;
                            goto ShowMessageBox;
                        }

                        // we need to check if we are trying to copy a file
                        // over a directory and give a reasonable error message

                        switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMREPLACE,
                                                       szDest,&DTADest,szSource,
                                                       pDTA,bConfirmReplace,
                                                       &bReplaceAll)) {

                            case IDYES: /* Perform the delete */

                                if ((wFunc == FUNC_MOVE) &&
                                    (DRIVEID(szSource) == DRIVEID(szDest))) {

                                    /* For FUNC_MOVE we need to delete the
                         * destination first.  Do that now. */

                                    if (DTADest.fd.dwFileAttributes & ATTR_DIR) {
                                        if (IsCurrentDirectory(szDestOEM))
                                            CdDotDot(szDestOEM);

                                        switch (NetCheck(szDest, WNDN_RMDIR)) {

                                            case WN_SUCCESS:

                                                /* Remove directory */

                                                ret = RMDir(szDestOEM);
                                                break;

                                            case WN_CONTINUE:
                                                break;

                                            case WN_CANCEL:
                                                goto CancelWholeOperation;
                                        }
                                    } else {
                                        ret = SafeFileRemove (szDestOEM);
                                    }
                                    if (ret) {
                                        ret |= ERRORONDEST;
                                        goto ShowMessageBox;
                                    }
                                }
                                break;

                            case IDNO:

                                /* Don't perform operation on current file */

                                continue;

                            case IDCANCEL:
                                goto CancelWholeOperation;

                            default:
                                ret = (WORD) wAttr;
                                goto ShowMessageBox;
                        }
                    }
                }
            }

            /* Now determine which operation to perform */

            switch (oper | wFunc) {

                case OPER_MKDIR | FUNC_COPY:  // Create destination directory
                case OPER_MKDIR | FUNC_MOVE:  // Create dest, verify source delete

                    CurIDS = IDS_CREATINGMSG;
                    Notify(hdlgProgress, IDS_CREATINGMSG, szDest, szNULL);

                    switch (NetCheck(szDest, WNDN_MKDIR)) {
                        case WN_SUCCESS:
                            break;

                        case WN_CONTINUE:
                            goto SkipMKDir;

                        case WN_CANCEL:
                            goto CancelWholeOperation;
                    }

                    ret = (WORD)WF_CreateDirectory(hdlgProgress, szDestOEM);

                    if (!ret)
                        /* set attributes of dest to source (not including the
                           subdir and vollabel bits) */
                        WFSetAttr(szDestOEM, pDTA->fd.dwFileAttributes & ~(ATTR_DIR|ATTR_VOLUME));

                    // if it already exits ingore the error return
                    if (ret == DE_ACCESSDENIED)
                        ret = 0;

                    if (ret)
                        ret |= ERRORONDEST;

                    /* set attributes of new directory to those of the source */

                    SkipMKDir:
                    break;

                case OPER_MKDIR | FUNC_DELETE:

                    /* Confirm removal of directory on this pass.  The directories
                       are actually removed on the OPER_RMDIR pass */

                    /* We can't delete the root directory, so don't bother
                       confirming it */

                    if (IsRootDirectory(szSource))
                        break;

                    switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMRMDIR,
                                                   NULL,pDTA,szSource, NULL,
                                                   bConfirmSubDel,
                                                   &bSubtreeDelAll)) {

                        case IDYES:
                            break;

                        case IDNO:
                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD) wAttr;
                            goto ShowMessageBox;
                    }
                    break;

                case OPER_RMDIR | FUNC_MOVE:
                case OPER_RMDIR | FUNC_DELETE:

                    CurIDS = IDS_REMOVINGDIRMSG;
                    Notify(hdlgProgress, IDS_REMOVINGDIRMSG, szSource, szNULL);
                    if (IsRootDirectory (szSource))
                        break;
                    if (IsCurrentDirectory (szSource))
                        CdDotDot (szSource);

                    /* We already confirmed the delete at MKDIR time, so attempt
                       to delete the directory */

                    switch (NetCheck (szSource,WNDN_RMDIR)) {

                        case WN_SUCCESS:
                            ret = RMDir (szSourceOEM);
                            break;

                        case WN_CONTINUE:
                            break;

                        case WN_CANCEL:
                            goto CancelWholeOperation;
                    }
                    break;

                case OPER_RMDIR | FUNC_COPY:
                    break;

                case OPER_DOFILE | FUNC_COPY:

                    if (IsWindowsFile(szDestOEM)) {
                        ret = DE_WINDOWSFILE | ERRORONDEST;
                        break;
                    }

                    TRY_COPY_AGAIN:

                    /* Now try to copy the file.  Do extra error processing only
                       in 2 cases:

                       1) If a floppy is full let the user stick in a new disk
                       2) If the path doesn't exist (the user typed in
                          and explicit path that doesn't exits) ask if
                          we should create it for him.

                       NOTE:  This processing is normally done by WFCopy.  But in
                              the case where LFN copy support is invoked, we have
                              to support this error condition here.  Modified by
                              C. Stevens, August 1991 */

                    ret = WFCopy(szSourceOEM, szDestOEM);

                    if (bUserAbort)
                        goto CancelWholeOperation;

                    if ((((ret & ~ERRORONDEST) == DE_NODISKSPACE) &&
                         IsRemovableDrive(DRIVEID(szDestOEM))) ||
                        ((ret & ~ERRORONDEST) == DE_PATHNOTFOUND)) {

                        ret = (WORD)CopyMoveRetry(szDestOEM, (INT)ret);
                        if (!ret)
                            goto TRY_COPY_AGAIN;
                        else
                            goto CancelWholeOperation;
                    }

                    break;

                case OPER_DOFILE | FUNC_RENAME:
                    {
                        CHAR save1,save2;
                        PSTR p;

                        if (CurIDS != IDS_RENAMINGMSG) {
                            CurIDS = IDS_RENAMINGMSG;
                            Notify(hdlgProgress, IDS_RENAMINGMSG, szNULL, szNULL);
                        }

                        /* Get raw source and dest paths.  Check to make sure the
                           paths are the same */

                        p = FindFileName(szSource);
                        save1 = *p;
                        *p = TEXT('\0');
                        p = FindFileName(szDest);
                        save2 = *p;
                        *p = TEXT('\0');
                        ret = (WORD)lstrcmpi(szSource, szDest);
                        szSource[lstrlen(szSource)] = save1;
                        szDest[lstrlen(szDest)] = save2;
                        if (ret) {
                            ret = DE_DIFFDIR;
                            break;
                        }
                        goto DoMoveRename;
                    }

                case OPER_DOFILE | FUNC_MOVE:

                    if (CurIDS != IDS_MOVINGMSG) {
                        CurIDS = IDS_MOVINGMSG;
                        Notify(hdlgProgress, IDS_MOVINGMSG, szNULL, szNULL);
                    }
                    DoMoveRename:

                    /* Don't allow the user to rename from or to the root
                       directory */

                    if (IsRootDirectory(szSource)) {
                        ret = DE_ROOTDIR;
                        break;
                    }
                    if (IsRootDirectory(szDest)) {
                        ret = DE_ROOTDIR | ERRORONDEST;
                        break;
                    }

                    if (IsCurrentDirectory(szSource))
                        CdDotDot(szSource);

                    /* Confirm the rename */

                    switch (wAttr = ConfirmDialog (hdlgProgress,
                                                   (WORD)(wFunc == FUNC_MOVE ?
                                                          CONFIRMMOVE : CONFIRMRENAME),
                                                   NULL,pDTA,szSource,NULL,FALSE,
                                                   (BOOL *)&bFalse)) {

                        case IDYES:
                            break;

                        case IDNO:
                            continue;

                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD) wAttr;
                            goto ShowMessageBox;
                    }

                    if (IsWindowsFile(szSourceOEM)) {
                        ret = DE_WINDOWSFILE;
                    } else {
                        if (DRIVEID(szSource) == DRIVEID(szDest)) {
                            ret = WFMove(szSourceOEM, szDestOEM);
                            if (!ret)
                                /* set attributes of dest to those of the source */
                                WFSetAttr(szDestOEM, pDTA->fd.dwFileAttributes);
                        } else {
                            // we must force all copies to go through
                            // straight so we can remove the source
                            // and have the
                            ret = WFCopy(szSourceOEM, szDestOEM);

                            if (!ret) {
                                ret = EndCopy();
                                if (!ret)
                                    WFRemove(szSourceOEM);
                            }
                            if (bUserAbort)
                                goto CancelWholeOperation;
                        }
                    }
                    break;

                case OPER_DOFILE | FUNC_DELETE:

                    if (CurIDS != IDS_DELETINGMSG) {
                        CurIDS = IDS_DELETINGMSG;
                        Notify(hdlgProgress,IDS_DELETINGMSG,szNULL, szNULL);
                    }

                    /* Confirm the delete first */

                    switch (wAttr = ConfirmDialog (hdlgProgress,CONFIRMDELETE,
                                                   NULL,pDTA,szSource,NULL,
                                                   bConfirmDelete,&bDeleteAll)) {

                        case IDYES:
                            break;

                        case IDNO:
                            continue;

                        case IDCANCEL:
                            goto CancelWholeOperation;

                        default:
                            ret = (WORD)wAttr;
                            goto ShowMessageBox;
                    }

                    /* make sure we don't delete any open windows
                       apps or dlls (lets hope this isn't too slow) */

                    ret = SafeFileRemove(szSourceOEM);
                    break;

                default:
                    ret = DE_HOWDIDTHISHAPPEN;   // internal error
                    break;
            }

            /* Report any errors which have occurred */

            if (ret) {

                ShowMessageBox:

                CopyError(szSource, szDest, ret, wFunc, oper);

                /* Continue the operation where one file is a windows file
                   in use */

                if ((ret & ~ERRORONDEST) != DE_WINDOWSFILE) {

                    CancelWholeOperation:

                    /* Force a CopyAbort in case there are any files in the
                       copy queue */

                    bUserAbort = TRUE;
                    goto ExitLoop;
                }
            }
        }
    }

    ExitLoop:

    /* Copy any outstanding files in the copy queue */

    if (!bUserAbort) {

        if (EndCopy())
            CopyAbort();
    } else
        CopyAbort();

    // this happens in error cases where we broke out of the pcr loop
    // without hitting the end

    if (pcr) {
        GetNextCleanup(pcr);
        LocalFree((HANDLE)pcr);
    }

    if (pGetNextQueue)
        LocalFree((HANDLE)pGetNextQueue);

    /* goofy way to make sure we've gotten all the WM_FILESYSCHANGE messages */
    WFQueryAbort();

    EnableFSC();

    return ret;
}


/*--------------------------------------------------------------------------*/
/*                                          */
/*  DMMoveCopyHelper() -                            */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Used by Danger Mouse to do moves and copies. */

WORD
APIENTRY
DMMoveCopyHelper(
                register LPSTR pFrom,
                register LPSTR pTo,
                BOOL bCopy
                )
{
    WORD      iStatus;

    dbg(("DMMoveCopyHelper(%s,%s);\r\n",(LPSTR)pFrom,(LPSTR)pTo));

    /* Confirm mouse operations. */
    if (bConfirmMouse) {
        LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, sizeof(szTitle));
        LoadString(hAppInstance,
                   bCopy ? IDS_COPYMOUSECONFIRM : IDS_MOVEMOUSECONFIRM,
                   szMessage, sizeof(szMessage));

        if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
            return DE_OPCANCELLED;
    }

    hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(DMSTATUSDLG), hwndFrame, ProgressDlgProc);
    if (!hdlgProgress) {
        return DE_INSMEM;
    }

    /* Set the destination directory in the dialog.
     * use IDD_TONAME 'cause IDD_TO gets disabled....
     */
    // SetDlgItemText(hdlgProgress, IDD_TONAME, pTo);

    /* The dialog title defaults to "Moving..." */
    if (bCopy) {
        LoadString(hAppInstance, IDS_COPYINGTITLE, szMessage, sizeof(szMessage));
        SetWindowText(hdlgProgress, szMessage);
    }

    /* Display and paint the status dialog. */
    EnableWindow(hwndFrame,FALSE);
    ShowWindow(hdlgProgress, SW_SHOW);
    UpdateWindow(hdlgProgress);

    /* Move/Copy things. */
    iStatus = WFMoveCopyDriver(pFrom, pTo, (WORD)(bCopy ? FUNC_COPY : FUNC_MOVE));

    /* Destroy the status dialog. */
    EnableWindow(hwndFrame,TRUE);
    DestroyWindow(hdlgProgress);

    return (iStatus);
}

WORD
APIENTRY
FileRemove(
          PSTR pSpec
          )
{
    if (DeleteFile(pSpec))
        return (WORD)0;
    else
        return (WORD)GetLastError();
}


WORD
APIENTRY
FileMove(
        PSTR pFrom,
        PSTR pTo
        )
{
    WORD result;

    TryAgain:

    if (MoveFile(pFrom, pTo))
        result = 0;
    else
        result = (WORD)GetLastError();

    // try to create the destination if it is not there

    if (result == DE_PATHNOTFOUND) {
        result = (WORD)CopyMoveRetry(pTo, (INT)result);
        if (!result)
            goto TryAgain;
        else
            return result;
    }
    return 0;
}


/*============================================================================
;
; FileCopy
;
; The following function replaces the old FileCopy function which performed
; single file copies.  This function queues copies.  The function StartCopy
; is called to initialize the copy queue if required.  If the queue is full,
; the function EndCopy is called to purge the copy queue before queueing
; up new copy commands.  Note that the function EndCopy must be called to
; purge the copy queue.
;
; Parameters:
;
; pszSource - Fully qualified source path
; pszDest   - Fully qualifies destination path
;
; returns:
;   0   success
;   dos error code for failure
;
============================================================================*/

WORD
APIENTRY
FileCopy(
        PSTR pszSource,
        PSTR pszDest
        )
{
    WORD ret;

    if (ret = StartCopy())
        return ret;       // failure

    // if the queue is full we must empty it first

    if (nCopyNumQueue >= nCopyMaxQueue) {

        // queue is full, now we empty it by really doing copies

        if (ret = EndCopy())
            return ret;    // failure

        if (ret = StartCopy())
            return ret;    // failure
    }

    // add this to the queue

    lstrcpy(pCopyQueue[nCopyNumQueue].szSource, pszSource);
    lstrcpy(pCopyQueue[nCopyNumQueue].szDest, pszDest);
    pCopyQueue[nCopyNumQueue].hSource = -1;
    pCopyQueue[nCopyNumQueue].hDest   = -1;
    pCopyQueue[nCopyNumQueue].ftLastWriteTime.dwLowDateTime = 0;
    pCopyQueue[nCopyNumQueue].ftLastWriteTime.dwHighDateTime = 0;

    nCopyNumQueue++;
    return 0;        // success
}

/*============================================================================
;
; StartCopy
;
; The following function is called automatically by WFCopy to initialize the
; copy queue.  The function is called each time by WFCopy, but will only
; initialize the first time.  The function allocates a buffer for reading and
; writing, and a buffer for storing the source and destination filenames,
; handles, and time stamps.  The function EndCopy must be called to flush the
; copy queue, and perform the actual disk transfer.
;
; Parameters: None
;
; return:
;   0   success
;   != 0    dos error code (DE_ value)
;
; Written by C. Stevens, August 1991
;
============================================================================*/

WORD
APIENTRY
StartCopy(VOID)
{
    WORD wSize;     /* Buffer size */
    register INT i; /* Counter */

    // have we already been called?

    if (lpCopyBuffer && pCopyQueue)
        return 0;     // success, buffers already allocated

    /* Allocate and lock buffer for reading and writing */

    wSize = COPYMAXBUFFERSIZE;
    while (!lpCopyBuffer) {
        lpCopyBuffer = GlobalAllocPtr(GHND, (DWORD)wSize);
        if (!lpCopyBuffer) {
            wSize /= 2;
            if (wSize < COPYMINBUFFERSIZE)
                return DE_INSMEM;   // memory failure
        }
    }
    wCopyBufferSize = wSize;

    /* Allocate and lock buffer for copy queue.  Note that magic +5 below is
       because we always have stdin, stdout, stderr, and AUX files open all
       the time, and we can't count them as available file handles */

    // someone opens files on our psp, leave them 2 handles
    // so we don't run on in the midst of copying

    nCopyMaxQueue = min(SetHandleCount(11 * 2) / 2 - 1, 10);

#ifdef DEBUG
    {
        char buf[80];
        wsprintf(buf, "SetHandleCount() -> %d\r\n", nCopyMaxQueue);
        OutputDebugString(buf);
    }
#endif

    wSize = (WORD)(nCopyMaxQueue * sizeof(COPYQUEUEENTRY));
    while (!pCopyQueue) {
        pCopyQueue = (PCOPYQUEUE)LocalAlloc(LPTR,wSize);
        if (!pCopyQueue) {
            wSize /= 2;
            if (wSize < (COPYMINFILES * sizeof(COPYQUEUEENTRY))) {
                GlobalFreePtr(lpCopyBuffer);
                lpCopyBuffer = NULL;
                return DE_INSMEM;   // memory failure
            }
        }
    }

    /* Initialize other Copy Queue variables and return success */

    nCopyMaxQueue = (int) wSize / sizeof (COPYQUEUEENTRY);
    nCopyNumQueue = 0;
    for (i = 0; i < nCopyMaxQueue; i++) {
        pCopyQueue[i].szSource[0] = 0;
        pCopyQueue[i].szDest[0]   = 0;
        pCopyQueue[i].hSource = -1;
        pCopyQueue[i].hDest   = -1;
    }
    return 0;        // success
}

// in:
//  pszFile     file to open/create
//  wAttrib     attributes to use on create
//
// returns:
//  flags register  (carry set on error)
//  *pfh        file handle or dos error code


WORD
OpenDestFile(
            PSTR pszFile,
            WORD wAttrib,
            INT *pfh
            )
{
    INT fh;
    WORD wStatus = 0;
    OFSTRUCT ofs;

    // use new extended open on dos > 4

    if (wDOSversion >= 0x0400) {
        if (wAttrib & ATTR_ATTRIBS)
            wAttrib &= ATTR_USED;
        else
            wAttrib = ATTR_ARCHIVE;

        {
            fh = OpenFile(pszFile, &ofs,
                          OF_READWRITE  | OF_SHARE_DENY_WRITE | OF_CREATE);
            if (fh == (INT)-1) {
                fh = GetLastError();
                wStatus |= CARRY_FLAG;
            } else {
                wStatus = 0;
                SetFileAttributes(pszFile, wAttrib);
            }

            // fh now contains a file handle or error code
        }

    } else {
        {
            fh = OpenFile(pszFile, &ofs,
                          OF_READWRITE  | OF_SHARE_DENY_WRITE | OF_CREATE);
            if (fh == (INT)-1) {
                fh = GetLastError();
                wStatus |= CARRY_FLAG;
            } else
                wStatus = 0;
        }
    }
    *pfh = fh;

    return wStatus;
}


/*============================================================================
;
; EndCopy
;
; The following function flushes the copy queue, attempting to copy all files
; in the queue.  The function ALWAYS frees global memory and flushes the
; queue and reports it's own errors.
;
; strategy:
;   we will do as many operations on one drive as we can, thus
;   avoiding disk spin up time (really bad on floppies).
;
; Parameters: None
;
; returns:
;   0   successful operation
;   != 0    dos error code (DE_OPCANCELLED) failure
;
; use like:
;
;    loop {
;   ret = WFCopy();
;   if (ret) {
;     ReportError(ret);
;     goto Error;
;   }
;    }
;
;    ret = EndCopy();
;    if (ret)
;      goto Error;
;
;    return success;
;
;Error:
;    CopyAbort();
;    ReportError(ret);
;
============================================================================*/

WORD
APIENTRY
EndCopy(VOID)
{
    INT i, j;           /* Counter */
    PSTR pTemp;         /* Pointer to source or dest filename */
    INT  fh;        /* File handle for DOS calls */
    WORD wStatus;       /* Status flags returned from DOS calls */
    DWORD wRead;         /* Number of bytes read from source file */
    DWORD wWrite;        /* Number of bytes written to destination file */
    FILETIME ftLastWriteTime; /* Source file date and time */
    DWORD wAttrib;       /* File attributes */

#ifdef DEBUG
    {
        char buf[80];
        wsprintf(buf, "EndCopy() nCopyNumQueue == %d\r\n", nCopyNumQueue);
        OutputDebugString(buf);
    }
#endif

    /* Open as many source files as possible.  Note we are assuming here
       that nCopyNumQueue < nCopyMaxQueue.  This should always be true
       because WFCopy calls EndCopy to purge the queue if it becomes full.
       We should never get an out of handles error opening source files or
       destination files.  If we do get an out of handles error opening
       source files, cause a fatal error and abort the copy. */

    // open all source files

    Notify(hdlgProgress, IDS_OPENINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        if (WFQueryAbort())
            return DE_OPCANCELLED;

        pTemp = pCopyQueue[i].szSource;
        {
            OFSTRUCT ofs;

            fh = OpenFile(pTemp, &ofs, OF_READ);
            if (fh == (INT)-1)
                fh = OpenFile(pTemp, &ofs, OF_SHARE_DENY_WRITE);
        }

        if (fh == (INT)-1) {

            CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, fh, FUNC_COPY, OPER_DOFILE);

            return DE_OPCANCELLED; // error already reported

        } else
            pCopyQueue[i].hSource = fh;

        /* Get the source file date, time, and attributes if necessary */

        fh = pCopyQueue[i].hSource;
        if (!IsSerialDevice(fh)) {
            {
                FILETIME ft;

                // Call DOS Get Date/Time of File.
                if (GetFileTime((HANDLE)LongToHandle(fh), NULL, NULL, (LPFILETIME)&ft))
                    pCopyQueue[i].ftLastWriteTime = ft;
            }

            pTemp = pCopyQueue[i].szSource;
            {
                // Call DOS Get File Attributes
                wAttrib = GetFileAttributes(pTemp);
                if (wAttrib != (DWORD)-1)
                    pCopyQueue[i].wAttrib |= (wAttrib | ATTR_ATTRIBS);
            }
        }
    }

    /* Now open as many destination files as possible.  If we get an out of
       handles error, cause a fatal abort because we already called
       Windows SetHandleCount to ensure we had enough.

       Note:  We are assuming the files do not exist when we try to open
              them, although for DOS 4.0 and above files WILL be replaced
              if they do happen to exist. */

    // open all destination files

    for (i = 0; i < nCopyNumQueue; i++) {

        if (WFQueryAbort())
            return DE_OPCANCELLED;

        TryOpen:

        wStatus = OpenDestFile(pCopyQueue[i].szDest, (WORD)pCopyQueue[i].wAttrib, (INT *)&fh);

        if (wStatus & CARRY_FLAG) {

            // error operning/creating destinaton file

            if (fh == DE_PATHNOTFOUND) {
                TryOpenDestAgain:
                // ask the user to stick in another disk

                fh = CopyMoveRetry(pCopyQueue[i].szDest, fh);
                if (!fh) {
                    goto TryOpen;
                } else {
                    // didn't happen, abort this copy

                    CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, (WORD)fh | ERRORONDEST, FUNC_COPY, OPER_DOFILE);
                    return DE_OPCANCELLED;   // error already reported
                }

            } else {
                // some other error condition

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, (WORD)fh | ERRORONDEST, FUNC_COPY, OPER_DOFILE);
                return DE_OPCANCELLED;  // error already reported
            }

        } else {
            pCopyQueue[i].hDest = fh;  // dest file open success
        }
    }

    /* Now copy between the open files */

    for (i = 0; i < nCopyNumQueue; i++) {

        Notify(hdlgProgress, IDS_COPYINGMSG, pCopyQueue[i].szSource, pCopyQueue[i].szDest);

        wRead = wCopyBufferSize;

        do {

            if (WFQueryAbort())
                return DE_OPCANCELLED;

            fh = pCopyQueue[i].hSource;
            {

                wRead = _lread(fh, lpCopyBuffer, wCopyBufferSize);
                if (wRead == (DWORD)-1) {
                    wStatus |= CARRY_FLAG;
                    wRead = GetLastError();
                } else
                    wStatus = 0;

                // wRead is either # bytes read or error code
            }
            if (wStatus & CARRY_FLAG) {

                // Error during file read

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, wRead, FUNC_COPY, OPER_DOFILE);

                return DE_OPCANCELLED;   // error already reported
            }

            fh = pCopyQueue[i].hDest;
            {

                // size can be zero to terminate file

                wWrite = _lwrite(fh, lpCopyBuffer, wRead);
                if (wWrite == (DWORD)-1) {
                    wStatus |= CARRY_FLAG;
                    wWrite = GetLastError();
                } else
                    wStatus = 0;

                // wWrite is either # bytes read or error code
            }
            if (wStatus & CARRY_FLAG) {

                CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, wWrite | ERRORONDEST, FUNC_COPY, OPER_DOFILE);

                return DE_OPCANCELLED;   // error already reported
            }

            // write did not complete and removable drive?

            if (wRead != wWrite) {

                if (IsRemovableDrive(DRIVEID(pCopyQueue[i].szDest)) &&
                    (DRIVEID(pCopyQueue[i].szDest) != DRIVEID(pCopyQueue[i].szSource))) {

                    // destination disk must be full. delete the destination
                    // files, give the user the option to insert a new disk.

                    for (j = i; j < nCopyNumQueue; j++) {

                        _lclose(pCopyQueue[j].hDest);
                        pCopyQueue[j].hDest = -1;

                        pTemp = pCopyQueue[j].szDest;
                        DeleteFile(pTemp);
                    }
                    fh = DE_NODISKSPACE;
                    goto TryOpenDestAgain;  // and try to create the destiations
                } else {

                    // not removable, error condition
                    CopyError(pCopyQueue[i].szSource, pCopyQueue[i].szDest, DE_NODISKSPACE | ERRORONDEST, FUNC_COPY, OPER_DOFILE);

                    return DE_OPCANCELLED;  // error already reported
                }

            }
            // we have moved all the data, so don't delete this on
            // clean up.

            if (!wRead)
                pCopyQueue[i].wAttrib |= ATTR_COPIED;

        } while (wRead);
    }

    // Close all destination files, set date time attribs

    Notify(hdlgProgress, IDS_CLOSINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        fh = pCopyQueue[i].hDest;
        if (!IsSerialDevice(fh)) {
            ftLastWriteTime = pCopyQueue[i].ftLastWriteTime;
            if (ftLastWriteTime.dwLowDateTime &&
                ftLastWriteTime.dwHighDateTime) {
                SetFileTime((HANDLE)LongToHandle(fh), NULL, NULL, (LPFILETIME)&ftLastWriteTime);
            }
        }

        _lclose(pCopyQueue[i].hDest);
        pCopyQueue[i].hDest = -1;

        /* Now set the file attributes if necessary */

        if (wDOSversion < 0x0400) {

            pTemp = pCopyQueue[i].szDest;
            wAttrib = pCopyQueue[i].wAttrib;

            // only set attribs if necessary (this is slow)

            if (wAttrib & ATTR_ATTRIBS) {
                wAttrib &= ATTR_USED;
                SetFileAttributes(pTemp, wAttrib);
            }
        }
    }

    // Close all source files (and delete them if necessary)


    if (pCopyQueue && (pCopyQueue[0].wAttrib & ATTR_DELSRC))
        Notify(hdlgProgress, IDS_REMOVINGMSG, szNULL, szNULL);

    for (i = 0; i < nCopyNumQueue; i++) {

        _lclose(pCopyQueue[i].hSource);
        pCopyQueue[i].hSource = -1;

        if (pCopyQueue[i].wAttrib & ATTR_DELSRC) {
            WFRemove(pCopyQueue[i].szSource);
        }
    }


    if (lpCopyBuffer) {
        GlobalFreePtr(lpCopyBuffer);
        lpCopyBuffer = NULL;
    }
    if (pCopyQueue) {
        LocalFree((HANDLE)pCopyQueue);
        pCopyQueue = NULL;
    }

    nCopyMaxQueue = 0;
    nCopyNumQueue = 0;

    return 0;        // success
}


/*============================================================================
;
; CopyError
;
; The following function reports an error during a file copy operation
;
; Parameters
;
; lpszSource - Source file name
; lpszDest   - Destination file name
; nError     - dos (or our exteneded) error code
;          0xFFFF for special case NET error
; wFunc      - Operation being performed during error.  Can be one of:
;              FUNC_DELETE - Delete files in pFrom
;              FUNC_RENAME - Rename files (same directory)
;              FUNC_MOVE   - Move files in pFrom to pTo (different disk)
;              FUNC_COPY   - Copy files in pFrom to pTo
; nOper      - Operation being performed.  Can be one of:
;              OPER_ERROR  - Error processing filenames
;              OPER_DOFILE - Go ahead and copy, rename, or delete file
;              OPER_MKDIR  - Make a directory specified in pTo
;              OPER_RMDIR  - Remove directory
;              0           - No more files left
;
; Return Value: None
;
; Written by C. Stevens, August 1991
;
============================================================================*/

VOID
CopyError(
         PSTR pszSource,
         PSTR pszDest,
         INT nError,
         WORD wFunc,
         INT nOper
         )
{
    CHAR szVerb[70];    /* Verb describing error */
    CHAR szReason[200]; /* Reason for error */
    BOOL bDest;

    bDest = nError & ERRORONDEST;    // was dest file cause of error
    nError &= ~ERRORONDEST;      // clear the dest bit

    if (nError == DE_OPCANCELLED)    // user abort
        return;

    if (!bCopyReport)        // silent, don't report errors
        return;

    LoadString(hAppInstance, IDS_COPYERROR + wFunc, szTitle, sizeof(szTitle));

    // get the verb string

    if (nOper == OPER_DOFILE || !nOper) {

        if (nError != 0xFFFF && bDest)
            // this is bogus, this could be IDS_CREATING as well...
            LoadString(hAppInstance, IDS_REPLACING, szVerb, sizeof(szVerb));
        else
            LoadString(hAppInstance, IDS_VERBS + wFunc, szVerb, sizeof(szVerb));

    } else {
        LoadString(hAppInstance, IDS_ACTIONS + (nOper >> 8), szVerb, sizeof(szVerb));
    }

    // get the reason string

    if (nError == 0xFFFF) {
        // special case LFN net error
        WNetErrorText(WN_NET_ERROR, szReason, sizeof(szReason));
    } else {
        // transform some error cases

        if (bDest) {
            if (nError != DE_ACCESSDENIED && GetFreeDiskSpace((WORD)DRIVEID(pszDest)) == 0L)
                nError = DE_NODISKSPACE;
        } else {
            if (nError == DE_ACCESSDENIED)
                nError = DE_ACCESSDENIEDSRC;    // soruce file access denied
        }

        LoadString(hAppInstance, IDS_REASONS + nError, szReason, sizeof(szReason));
    }

    // use the files names or "Selected files" if file list too long

    if (!nOper && (lstrlen(pszSource) > 64))
        LoadString(hAppInstance, IDS_SELECTEDFILES, pszSource, 32);

    wsprintf(szMessage, szVerb, (LPSTR)(bDest ? pszDest : pszSource), (LPSTR)szReason);

    MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
}

/*============================================================================
;
; CopyAbort
;
; The following function aborts a queued copy operation.  The function closes
; all source and destination files, deleteing all destination files
; including and following the specified index.
;
; Parameters:
;
; nIndex - Index of first destination file to delete
;
; Return Value: None
;
; Written by C. Stevens, August 1991
;
============================================================================*/

VOID
APIENTRY
CopyAbort(VOID)
{
    INT i;
    PSTR pTemp;

    // close all source files

    for (i = 0; i < nCopyMaxQueue; i++) {
        if (pCopyQueue[i].hSource != -1)
            _lclose(pCopyQueue[i].hSource);
    }

    // close and delete (if necessary) destination files

    for (i = 0; i < nCopyMaxQueue; i++) {
        if (pCopyQueue[i].hDest != -1) {
            _lclose(pCopyQueue[i].hDest);

            if (!(pCopyQueue[i].wAttrib & ATTR_COPIED)) {
                pTemp = pCopyQueue[i].szDest;
                DeleteFile(pTemp);
            }
        }
    }

    if (lpCopyBuffer) {
        GlobalFreePtr(lpCopyBuffer);
        lpCopyBuffer = NULL;
    }
    if (pCopyQueue) {
        LocalFree((HANDLE)pCopyQueue);
        pCopyQueue = NULL;
    }

    nCopyMaxQueue = 0;   /* Clear other Copy Queue variables */
    nCopyNumQueue = 0;
}

/*============================================================================
;
; CopyMoveRetry
;
; The following function is used to retry failed move/copy operations
; due to out of disk situations or path not found errors
; on the destination.
;
; NOTE: the destination drive must be removable or this function
;   does not make a whole lot of sense
;
; Parameters:
;
; pszDest   - Fully qualified path to destination file
; nError    - Type of error which occured: DE_NODISKSPACE or DE_PATHNOTFOUND
;
; returns:
;   0   success (destination path has been created)
;   != 0    dos error code including DE_OPCANCELLED
;
============================================================================*/

INT
CopyMoveRetry(
             PSTR pszDest,
             INT nError
             )
{
    CHAR szReason[128]; /* Error message string */
    PSTR pTemp;         /* Pointer into filename */
    WORD wFlags;        /* Message box flags */
    INT  result;        /* Return from MessageBox call */

    do {     // until the destination path has been created

        GetWindowText(hdlgProgress, szTitle, sizeof(szTitle));

        if (nError == DE_PATHNOTFOUND) {

            LoadString(hAppInstance, IDS_PATHNOTTHERE, szReason, sizeof(szReason));

            /* Note the -1 below here is valid in both SBCS and DBCS because
               pszDest is fully qualified and the character preceding the
               file name must be a backslash */

            pTemp = FindFileName(pszDest) - 1;
            *pTemp = 0;
            wsprintf(szMessage, szReason, (LPSTR)pszDest);
            *pTemp = '\\';
            wFlags = MB_ICONEXCLAMATION | MB_YESNO;
        } else {
            wFlags = MB_ICONEXCLAMATION | MB_RETRYCANCEL;
            LoadString(hAppInstance, IDS_DESTFULL, szMessage, sizeof(szMessage));
        }

        result = MessageBox(hdlgProgress,szMessage,szTitle,wFlags);

        if (result == IDRETRY || result == IDYES) {

            // Allow the disk to be formatted
            if (!IsTheDiskReallyThere(hdlgProgress, pszDest, FUNC_COPY))
                return DE_OPCANCELLED;

            pTemp = FindFileName(pszDest) - 1;
            *pTemp = 0;
            result = WF_CreateDirectory(hdlgProgress, pszDest);
            *pTemp = '\\';

            // only as once if creating the destionation failed

            if (result == DE_OPCANCELLED)
                return DE_OPCANCELLED;
            if (result && (nError == DE_PATHNOTFOUND))
                return result | ERRORONDEST;
        } else
            return DE_OPCANCELLED;

    } while (result);

    return 0;        // success
}

BOOL
IsSerialDevice(
              INT hFile
              )
{
    UNREFERENCED_PARAMETER(hFile);
    return FALSE;  // BUG BUG. How to findout if its a serialdevice
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfcopy.h ===
/****************************************************************************/
/*                                      */
/*  WFCOPY.H -                                  */
/*                                      */
/*  Include for WINFILE's File Copying Routines             */
/*                                      */
/****************************************************************************/

#define FIND_DIRS       0x0010

#define CNF_DIR_EXISTS      0x0001
#define CNF_ISDIRECTORY     0x0002

#define BUILD_TOPLEVEL      0
#define BUILD_RECURSING     1
#define BUILD_NORECURSE     2

#define FUNC_MOVE       0x0001
#define FUNC_COPY       0x0002
#define FUNC_DELETE     0x0003
#define FUNC_RENAME     0x0004

/* These should not be used in the move/copy code;
 * only for IsTheDiskReallyThere */
#define FUNC_SETDRIVE       0x0005
#define FUNC_EXPAND     0x0006
#define FUNC_LABEL      0x0007

#define OPER_MASK       0x0F00
#define OPER_MKDIR      0x0100
#define OPER_RMDIR      0x0200
#define OPER_DOFILE     0x0300
#define OPER_ERROR      0x0400

#define CCHPATHMAX      260
#define MAXDIRDEPTH     20      // arbitrary limit

#define COPYMAXBUFFERSIZE 0xFFFF
#define COPYMINBUFFERSIZE  4096 /* Minimum buffer size for FileCopy */
#define COPYMAXFILES         10 /* Maximum number of source files to open */
#define COPYMINFILES          1 /* Minimum number of source files to open */
#define CARRY_FLAG            1 /* Carry flag mask in status word */
#define ATTR_ATTRIBS      0x200 /* Flag indicating we have file attributes */
#define ATTR_COPIED       0x400 /* we have copied this file */
#define ATTR_DELSRC       0x800 /* delete the source when done */

typedef struct TAGCopyQueue {
   CHAR szSource[MAXPATHLEN];
   CHAR szDest[MAXPATHLEN];
   INT hSource;
   INT hDest;
   FILETIME ftLastWriteTime;
   DWORD wAttrib;
} COPYQUEUEENTRY, *PCOPYQUEUE, *LPCOPYQUEUE;

typedef struct _copyroot
  {
    BOOL    fRecurse;
    WORD    cDepth;
    LPSTR   pSource;
    LPSTR   pRoot;
    CHAR cIsDiskThereCheck[26];
    CHAR    sz[MAXPATHLEN];
    CHAR    szDest[MAXPATHLEN];
    LFNDTA  rgDTA[MAXDIRDEPTH];
  } COPYROOT, *PCOPYROOT;

typedef struct _getnextqueue
  {
    char szSource[MAXPATHLEN];
    char szDest[MAXPATHLEN];
    int nOper;
    LFNDTA SourceDTA;
  } GETNEXTQUEUE, *PGETNEXTQUEUE, *LPGETNEXTQUEUE;

/* WFFILE.ASM */
BOOL IsSerialDevice(INT hFile);
BOOL IsDirectory(LPSTR szPath);
WORD  APIENTRY FileMove(LPSTR, LPSTR);
WORD  APIENTRY FileRemove(LPSTR);
WORD  APIENTRY MKDir(LPSTR);
WORD  APIENTRY RMDir(LPSTR);
BOOL APIENTRY WFSetAttr(LPSTR lpFile, DWORD dwAttr);

VOID APIENTRY QualifyPath(LPSTR);
VOID APIENTRY AppendToPath(LPSTR,LPSTR);
VOID APIENTRY RemoveLast(LPSTR pFile);
VOID APIENTRY Notify(HWND,WORD,PSTR,PSTR);

extern BOOL bCopyReport;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdir.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDIR.C -                                                               */
/*                                                                          */
/*      Windows File System Directory Window Proc Routines                  */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

#define MAXDIGITSINSIZE 8

#define DATEMASK        0x001F
#define MONTHMASK       0x01E0
#define MINUTEMASK      0x07E0
#define SECONDSMASK     0x001F

#define DATESEPERATOR   '-'
#define TIMESEPERATOR   ':'

CHAR    szAttr[]        = "RHSA";
INT     iLastSel = -1;

INT_PTR APIENTRY DirWndProc(register HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

LPSTR DirGetSelection(HWND hwndDir, HWND hwndLB, INT iSelType, BOOL *pfDir);
VOID DirGetAnchorFocus(register HWND hwndLB, HANDLE hDTA, LPSTR szAnchor, LPSTR szCaret, LPSTR szTopIndex);
VOID FillDirList(HWND hWnd, HANDLE hDirEntries);
VOID DrawItemFast(HWND hWnd, LPDRAWITEMSTRUCT lpLBItem, LPMYDTA lpmydta, BOOL bHasFocus);
INT GetPict(CHAR ch, LPSTR szStr);
INT DirFindIndex(HWND hwndLB, HANDLE hDTA, LPSTR szFile);
INT CompareDTA(register LPMYDTA item1, LPMYDTA item2, WORD wSort);
VOID CreateLBLine(register WORD wLineFormat, LPMYDTA lpmydta, LPSTR szBuffer);
HANDLE CreateDTABlock(HWND hWnd, LPSTR pPath, DWORD dwAttribs, BOOL bAllowAbort, BOOL bDontSteal);
BOOL SetSelection(HWND hwndLB, HANDLE hDTA, LPSTR pSel);
INT CreateDate(WORD *wValArray, LPSTR szOutStr);
INT CreateTime(WORD * wValArray, LPSTR szOutStr);
VOID GetDirStatus(HWND hWnd, LPSTR szMsg1, LPSTR szMsg2);
INT GetMaxExtent(HWND hwndLB, HANDLE hDTA);
BOOL CheckEarlyAbort(VOID);
BOOL SetDirFocus(HWND hwndDir);

VOID  APIENTRY CheckEscapes(LPSTR);
VOID SortDirList(HWND, LPMYDTA, WORD ,LPMYDTA *);




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrawItemFast() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DrawItemFast(
            HWND hWnd,
            LPDRAWITEMSTRUCT lpLBItem,
            LPMYDTA lpmydta,
            BOOL bHasFocus
            )
{
    INT x, y, i;
    HDC hDC;
    BOOL bDrawSelected;
    HWND hwndLB;
    RECT rc;
    DWORD rgbText, rgbBackground;
    CHAR szBuf[MAXFILENAMELEN+2];

    hWnd;

    ENTER("DrawItemFast");

    hDC = lpLBItem->hDC;
    hwndLB = lpLBItem->hwndItem;

    bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);

    if (bHasFocus && bDrawSelected) {
        rgbText = SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        rgbBackground = SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        goto FocusOnly;

    /* Draw the black/white background. */

    x = lpLBItem->rcItem.left + 1;
    y = lpLBItem->rcItem.top + (dyFileName/2);

    lstrcpy(szBuf, lpmydta->my_cFileName);
    if ((wTextAttribs & TA_LOWERCASE) && !(lpmydta->my_dwAttrs & ATTR_LFN))
        AnsiLower(szBuf);

    ExtTextOut(hDC, x + dxFolder + dyBorderx2 + dyBorder, y-(dyText/2),
               ETO_OPAQUE, &lpLBItem->rcItem, szBuf, lstrlen(szBuf), NULL);

    if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

        LONG    ySrc;

        i = lpmydta->iBitmap;

        if (i & 0x40) {
            // It's an object type bitmap
            ySrc = (dyFolder * 2) + dyDriveBitmap;
            i = i & (~0x40);
            while (i >= 16) {
                i -= 16;
                ySrc += (dyFolder * 2);
            }
        } else {
            ySrc = 0;
        }

        ySrc += (bHasFocus && bDrawSelected) ? dyFolder : 0;

        BitBlt(hDC, x + dyBorderx2, y-(dyFolder/2), dxFolder, dyFolder, hdcMem,
               i * dxFolder, ySrc, SRCCOPY);
    }

    if (lpLBItem->itemState & ODS_FOCUS)
        FocusOnly:
        DrawFocusRect(hDC, &lpLBItem->rcItem);    // toggles focus (XOR)

    /* Restore the normal drawing colors. */
    if (bDrawSelected) {
        if (bHasFocus) {
            SetTextColor(hDC, rgbText);
            SetBkColor(hDC, rgbBackground);
        } else {
            HBRUSH hbr;
            if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                rc = lpLBItem->rcItem;
                rc.left += dyBorder;
                rc.right -= dyBorder;

                if (lpLBItem->itemID > 0 &&
                    (BOOL)SendMessage(hwndLB, LB_GETSEL, lpLBItem->itemID - 1, 0L))
                    rc.top -= dyBorder;

                FrameRect(hDC, &rc, hbr);
                DeleteObject(hbr);
            }
        }
    }
    LEAVE("DrawItemFast");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillDirList() -                                                         */
/*                                                                          */
/* HANDLE       hDirEntries;                     Array of directory entries */
/*--------------------------------------------------------------------------*/

VOID
FillDirList(
           HWND hWnd,
           HANDLE hDTA
           )
{
    register WORD count;
    LPMYDTA       lpmydta;
    LPMYDTA  *alpmydtaSorted;
    WORD          i;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    count = (WORD)lpmydta->my_nFileSizeLow;

    if (count == 0) {
        SendMessage(hWnd, LB_ADDSTRING, 0, 0L); // tolken for no items
    } else {

        alpmydtaSorted = (LPMYDTA *)LocalAlloc(LMEM_FIXED,
                                                   sizeof(LPMYDTA) * count);
        if (alpmydtaSorted != NULL) {
            SortDirList(hWnd, lpmydta, count, alpmydtaSorted);

            for (i = 0; i < count; i++) {
                alpmydtaSorted[i]->nIndex = i;
                SendMessage(hWnd, LB_INSERTSTRING,(WPARAM)-1, (LPARAM)alpmydtaSorted[i]);
            }
            LocalFree((HANDLE)alpmydtaSorted);
        }
    }

    LocalUnlock(hDTA);
}



BOOL
CheckEarlyAbort()
{
    MSG msg;

    if (PeekMessage(&msg, NULL, WM_KEYDOWN, WM_KEYDOWN, PM_NOREMOVE | PM_NOYIELD)) {

        if (msg.wParam == VK_UP ||
            msg.wParam == VK_DOWN) {
            return TRUE;
        }
    }
    return FALSE;
}



HANDLE
CopyDTABlock(
            HANDLE hDTASrc
            )
{
    LPMYDTA lpmydtaSrc, lpmydtaDst;
    HANDLE hDTADst;
    SIZE_T dwSize;

    lpmydtaSrc = (LPMYDTA)LocalLock(hDTASrc);

    dwSize = LocalSize(hDTASrc);

    if (hDTADst = LocalAlloc(LPTR, dwSize)) {

        lpmydtaDst = (LPMYDTA)LocalLock(hDTADst);

        memcpy(lpmydtaDst, lpmydtaSrc, (size_t)dwSize);

        LocalUnlock(hDTASrc);
        LocalUnlock(hDTADst);

        return hDTADst;

    } else {
        LocalUnlock(hDTASrc);
        return NULL;
    }
}


HANDLE
StealDTABlock(
             HWND hWnd,
             LPSTR pPath,
             DWORD dwAttribs
             )
{
    HWND hwnd;
    HWND hwndDir;
    HANDLE hDTA;
    CHAR szPath[MAXPATHLEN];

    ENTER("StealDTABlock");

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        if ((hwndDir = HasDirWindow(hwnd)) && (hwndDir != hWnd)) {

            GetMDIWindowText(hwnd, szPath, sizeof(szPath));

            if ((dwAttribs == (DWORD)GetWindowLong(hwnd, GWL_ATTRIBS)) &&
                !lstrcmpi(pPath, szPath) &&
                (hDTA = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA))) {
                LEAVE("StealDTABlock");
                return CopyDTABlock(hDTA);
            }
        }
    }

    LEAVE("StealDTABlock");

    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateDTABlock() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Builds a global memory block full of DTAs for the path 'pPath'.          */

/* Returns:
 *      An unlocked global memory handle to DTA block with first DTA
 *      my_nFileSizeLow field indicating the number of DTA blocks that follow
 *
 * This builds a global memory block that has DTA entries for all
 * of the files with dwAttributes in pPath.  The first DTA entry's
 * my_nFileSizeLow field indicates the number of actual DTA areas found
 */

HANDLE
CreateDTABlock(
              HWND hWnd,
              LPSTR pPath,
              DWORD dwAttribs,
              BOOL bAllowAbort,
              BOOL bDontSteal
              )
{
    register LPSTR pName;
    WORD wPathLen;
    BOOL bDoc, bProgram;
    DWORD dwCurrentSize, dwBlockSize;
    WORD wSize, wLastSize;
    LFNDTA lfndta;
    HANDLE hMem;
    LPMYDTA lpmydta, lpStart;
    CHAR szPathOEM[MAXPATHLEN];
    DWORD iBitmap;
    WORD wDrive;

    ENTER("CreateDTABlock");
    PRINT(BF_PARMTRACE, "IN: pPath=%s", pPath);
    PRINT(BF_PARMTRACE, "IN: dwAttribs=0x%lx", UlongToPtr(dwAttribs));
    PRINT(BF_PARMTRACE, "IN: bDontSteal=%d", IntToPtr(bDontSteal));

#define BLOCK_SIZE_GRANULARITY  512     // must be larger than MYDTA

    // get the drive index assuming path is
    // fully qualified...
    wDrive = (WORD)((*pPath - 'A') & 31);

    if (bAllowAbort && CheckEarlyAbort()) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=-1", 0);
        LEAVE("CreateDTABlock");
        return (HANDLE)-1;
    }

    if (!bDontSteal && (hMem = StealDTABlock(hWnd, pPath, dwAttribs))) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
        LEAVE("CreateDTABlock");
        return hMem;
    }

    dwBlockSize = BLOCK_SIZE_GRANULARITY;
    hMem = LocalAlloc(LPTR, (DWORD)dwBlockSize);
    if (!hMem) {
        PRINT(BF_PARMTRACE, "OUT: hDTA=NULL", 0);
        LEAVE("CreateDTABlock");
        return NULL;
    }

    lpmydta = lpStart = (LPMYDTA)LocalLock(hMem);
    lpStart->my_nFileSizeLow = 0;
    wLastSize = sizeof(MYDTA);
    wLastSize = (WORD)DwordAlign(wLastSize);
    lpStart->wSize = wLastSize;
    dwCurrentSize = (DWORD)wLastSize;

    lstrcpy(szPathOEM, pPath);

    FixAnsiPathForDos(szPathOEM);

    wPathLen = (WORD)(lstrlen(szPathOEM)-3);        /* Ignore '*.*' */

    if (!WFFindFirst(&lfndta, szPathOEM, (dwAttribs | ATTR_DIR) & ATTR_ALL)) {

        // Try again if the disk is available

        if (!IsTheDiskReallyThere(hWnd, pPath, FUNC_EXPAND) ||
            !WFFindFirst(&lfndta, szPathOEM, (dwAttribs | ATTR_DIR) & ATTR_ALL))
            goto CDBDone;
    }

    while (TRUE) {

        pName = lfndta.fd.cFileName;
        OemToCharBuff(pName, pName, sizeof(lfndta.fd.cFileName)/sizeof(lfndta.fd.cFileName[0]));

        // be safe, zero unused DOS dta bits

        lfndta.fd.dwFileAttributes &= ATTR_USED;

        // filter unwanted stuff here based on current view settings

        if (!(lfndta.fd.dwFileAttributes & ATTR_DIR)) {

            bProgram = IsProgramFile(pName);
            bDoc     = IsDocument(pName);
        }

        // figure out the bitmap type here

        if (lfndta.fd.dwFileAttributes & ATTR_DIR) {

            // ignore the "." directory

            if (pName[0] == '.' && pName[1] != '.')
                goto CDBCont;

            // parent ".." dir

            if (pName[0] == '.') {

                pName = szNULL;

                iBitmap = BM_IND_DIRUP;
                lfndta.fd.dwFileAttributes |= ATTR_PARENT;      // mark this!

            } else {

                // We always include DIRs so that the .. is
                // included.  Now we filter other dirs off.

                if (!(dwAttribs & ATTR_DIR))
                    goto CDBCont;

                iBitmap = BM_IND_CLOSE;
            }

        } else if (lfndta.fd.dwFileAttributes & ATTR_TYPES) {
            iBitmap = ((lfndta.fd.dwFileAttributes & ATTR_TYPES) >> 16) | 0x40;
        } else {
            iBitmap = BM_IND_DOC;
        }

        //
        // calc the size of this portion
        //
        // pName is assumed to be ANSI re: OemToAnsi() call,
        // so lstrlen() should be size in bytes.  We just need to add one
        // for the terminating NULL


        wSize = (WORD)(sizeof(MYDTA) + lstrlen(pName) + sizeof('\0'));
        wSize = (WORD)DwordAlign(wSize);

        if ((wSize + dwCurrentSize) > dwBlockSize) {
            DWORD dwDelta;

            // grow the block

            dwBlockSize += BLOCK_SIZE_GRANULARITY;
            LocalUnlock(hMem);
            dwDelta = (DWORD)((LPBYTE)lpmydta - (LPBYTE)lpStart);

            {
                void *pv = LocalReAlloc(hMem, dwBlockSize, LMEM_MOVEABLE);
                if (!pv)
                    goto CDBMemoryErr;
                else
                    hMem = pv;
            }

            lpStart = (LPMYDTA)LocalLock(hMem);
            lpmydta = (LPMYDTA)((LPBYTE)lpStart + dwDelta);
        }

        lpStart->my_nFileSizeLow++;
        dwCurrentSize += wSize;

        // now it is safe to advance the pointer

        lpmydta = GETDTAPTR(lpmydta, wLastSize);
        wLastSize = lpmydta->wSize = wSize;
        lpmydta->my_dwAttrs = lfndta.fd.dwFileAttributes;
        lpmydta->my_ftLastWriteTime = lfndta.fd.ftLastWriteTime;
        lpmydta->my_nFileSizeLow = lfndta.fd.nFileSizeLow;
        lpmydta->my_nFileSizeHigh = lfndta.fd.nFileSizeHigh;
        lpmydta->iBitmap = (SHORT)iBitmap;

        if (IsLFN(pName)) {
            lpmydta->my_dwAttrs |= ATTR_LFN;
        }
        lstrcpy(lpmydta->my_cFileName, pName);

        CDBCont:
        if (bAllowAbort && CheckEarlyAbort()) {
            LocalUnlock(hMem);
            LocalFree(hMem);
            WFFindClose(&lfndta);
            PRINT(BF_PARMTRACE, "OUT: hDTA=-1", 0);
            LEAVE("CreateDTABlock");
            return (HANDLE)-1;
        }

        if (!WFFindNext(&lfndta)) {
            break;
        }
    }

    CDBDone:
    LocalUnlock(hMem);
    WFFindClose(&lfndta);
    PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
    LEAVE("CreateDTABlock");
    return hMem;

    CDBMemoryErr:
    WFFindClose(&lfndta);
    MyMessageBox(hwndFrame, IDS_OOMTITLE, IDS_OOMREADINGDIRMSG, MB_OK | MB_ICONEXCLAMATION);
    PRINT(BF_PARMTRACE, "OUT: hDTA=0x%lx", hMem);
    LEAVE("CreateDTABlock");
    return hMem;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirGetSelection() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Takes a Listbox and returns a string containing the names of the selected
 * files seperated by spaces.
 *
 * bSingle == 1 return only the first file
 * bSingle == 2 test for LFN files in the selection, doesn't return string
 * bSingle == 3 return fully qualified names
 *
 * returns:
 *      if (bSingle == 1)
 *              TRUE/FALSE if LFN is in the selection
 *      else
 *              pointer to the list of names (ANSI strings)
 *              (must be freed by caller!)
 *              *pfDir -> bool indicating directories are
 *              contained in the selection (or that LFN names are present)
 *
 * NOTE: The caller must free the returned pointer!
 */

LPSTR
DirGetSelection(
               HWND hwndDir,
               HWND hwndLB,
               INT  iSelType,
               BOOL *pfDir
               )
{
    LPSTR p, pT;
    WORD i;
    WORD          cch;
    WORD          iMac;
    LPMYDTA       lpmydta;
    CHAR          szFile[MAXPATHLEN];
    CHAR          szPath[MAXPATHLEN];
    BOOL          bDir, bPropertyDialog;
    LPINT         lpSelItems;

    BOOL          bLFNTest;

    if (bLFNTest = (iSelType == 2)) {
        // determine if the directory it self is long...
        iSelType = FALSE;
        SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        StripBackslash(szPath);
        if (IsLFN(szPath))
            if (pfDir) {
                *pfDir = TRUE;
            }
        return NULL;
    }

    if (bPropertyDialog = (iSelType == 3)) {
        iSelType = FALSE;
    }

    bDir = FALSE;

    if (!bLFNTest) {
        cch = 1;
        p = (LPSTR)LocalAlloc(LPTR, cch);
        if (!p)
            return NULL;
        *p = '\0';
    }
    #ifdef DEBUG
    else
        p = (LPSTR)0xFFFF;       // force a GP fault with bogus p use below
    #endif


    iLastSel = -1;

    iMac = (WORD)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L);
    lpSelItems = LocalAlloc(LMEM_FIXED, sizeof(INT) * iMac);
    if (lpSelItems == NULL)
        return NULL;
    iMac = (WORD)SendMessage(hwndLB, LB_GETSELITEMS, (WPARAM)iMac, (LPARAM)lpSelItems);
    for (i=0; i < iMac; i++) {


        if (iLastSel == -1)   // remember the first selection
            iLastSel = lpSelItems[i];

        SendMessage(hwndLB, LB_GETTEXT, lpSelItems[i], (LPARAM)&lpmydta);

        if (!lpmydta)
            break;

        lstrcpy(szFile, (LPSTR)lpmydta->my_cFileName);

        if (lpmydta->my_dwAttrs & ATTR_DIR) {  // is this a dir

            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);

            if (lpmydta->my_dwAttrs & ATTR_PARENT) {       // parent dir?

                // if we are getting a full selection don't
                // return the parent ".." entry (avoid deleting
                // and other nasty operations on the parent)

                if (!iSelType)
                    continue;

                StripBackslash(szPath);       // trim it down
                StripFilespec(szPath);

            } else {
                lstrcat(szPath, szFile);      // fully qualified
            }

            lstrcpy(szFile, szPath);
            bDir = TRUE;
        }

        if (bPropertyDialog)
            QualifyPath(szFile);

        if (bLFNTest && lpmydta->my_dwAttrs & ATTR_LFN) {
            return (LPSTR)TRUE;
        }

        CheckEscapes(szFile);

        if (!bLFNTest) {
            cch += lstrlen(szFile) + 1;
            pT = (LPSTR)LocalReAlloc((HANDLE)p, cch, LMEM_MOVEABLE | LMEM_ZEROINIT);
            if (!pT)
                goto GDSExit;
            p = pT;
            lstrcat(p, szFile);
        }

        if (iSelType)
            goto GDSExit;

        if (!bLFNTest)
            lstrcat(p, szBlank);
    }

    GDSExit:
    LocalFree(lpSelItems);

    if (bLFNTest) {
        if (pfDir) {
            *pfDir = FALSE;
        }
        return NULL;
    }

    if (pfDir) {
        *pfDir = bDir;
    }
    return p;
}



// compute the max extent of all the files in this DTA block
// and update the case to match (wTextAttribs & TA_LOWERCASE)

INT
GetMaxExtent(
            HWND hwndLB,
            HANDLE hDTA
            )
{
    LPMYDTA lpmydta;
    HDC hdc;
    INT nItems;
    INT maxWidth = 0;
    INT wWidth;
    HFONT hOld;
    CHAR szPath[MAXPATHLEN];

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    nItems = (INT)lpmydta->my_nFileSizeLow;

    hdc = GetDC(hwndLB);

    hOld = SelectObject(hdc, hFont);

    while (nItems-- > 0) {
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        lstrcpy(szPath, lpmydta->my_cFileName);

        // set the case of the file names here!
        if (!(lpmydta->my_dwAttrs & ATTR_LFN)) {
            if (wTextAttribs & TA_LOWERCASE)
                AnsiLower(szPath);
            else
                AnsiUpper(szPath);
        }

        MGetTextExtent(hdc, szPath, lstrlen(szPath), &wWidth, NULL);

        maxWidth = max(wWidth, maxWidth);
    }

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(hwndLB, hdc);

    LocalUnlock(hDTA);

    return maxWidth + 3;    // pad it out
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirFindIndex() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
DirFindIndex(
            HWND hwndLB,
            HANDLE hDTA,
            LPSTR szFile
            )
{
    register INT i;
    INT           nSel;
    LPMYDTA       lpmydta;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    nSel = (INT)lpmydta->my_nFileSizeLow;

    for (i = 0; i < nSel; i++) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)i, (LPARAM)&lpmydta);

        if (!lstrcmpi(szFile, (LPSTR)lpmydta->my_cFileName))
            goto DFIExit;
    }
    i = -1;               // not found, return this

    DFIExit:
    LocalUnlock(hDTA);
    return i;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DirGetAnchorFocus() -                                                   */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DirGetAnchorFocus(
                 register HWND hwndLB,
                 HANDLE hDTA,
                 LPSTR szAnchor,
                 LPSTR szCaret,
                 LPSTR szTopIndex
                 )
{
    register INT      iSel, iCount;
    LPMYDTA           lpmydta;

    hDTA;                                      // fix compiler warning
    iSel = (INT)SendMessage(hwndLB, LB_GETANCHORINDEX, 0, 0L);

    iCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (iCount == 1) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        if (!lpmydta) {
            *szAnchor = 0L;
            *szCaret = 0L;
            *szTopIndex = 0L;
            return;
        }
    }
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);

        lstrcpy(szAnchor, (LPSTR)lpmydta->my_cFileName);
    } else
        *szAnchor = 0L;

    iSel = (INT)SendMessage(hwndLB, LB_GETCARETINDEX, 0, 0L);
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        lstrcpy(szCaret, (LPSTR)lpmydta->my_cFileName);
    } else
        *szCaret = 0L;

    iSel = (WORD)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
    if (iSel >= 0 && iSel < iCount) {
        SendMessage(hwndLB, LB_GETTEXT, (WORD)iSel, (LPARAM)&lpmydta);
        lstrcpy(szTopIndex, (LPSTR)lpmydta->my_cFileName);
    } else
        *szTopIndex = 0L;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetSelection() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
SetSelection(
            HWND hwndLB,
            HANDLE hDTA,
            LPSTR pSel
            )
{
    INT i;
    CHAR szFile[MAXPATHLEN];
    BOOL bDidSomething = FALSE;

    while (pSel = GetNextFile(pSel, szFile, sizeof(szFile))) {

        i = DirFindIndex(hwndLB, hDTA, (LPSTR)szFile);

        if (i != -1) {
            SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)i);
            bDidSomething = TRUE;
        }
    }
    return bDidSomething;
}


/*** FIX30: Why do we use LONG buffer ptrs here? ***/

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetPict() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This gets the number of consecutive chrs of the same kind.  This is used
 *  to parse the time picture.  Returns 0 on error.
 */

INT
GetPict(
       CHAR ch,
       LPSTR szStr
       )
{
    register INT  count;

    count = 0;
    while (ch == *szStr++)
        count++;

    return(count);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateDate() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted date.
 *  wValArray should contain Month-Day-Year (in that order).
 */

INT
CreateDate(
          WORD *wValArray,
          LPSTR szOutStr
          )

{
    INT           i;
    INT           cchPictPart;
    WORD          wDigit;
    WORD          wIndex;
    WORD          wTempVal;
    register LPSTR pszPict;
    register LPSTR pszInStr;

    pszPict = szShortDate;
    pszInStr = szOutStr;

    for (i=0; i < 3; i++) {
        cchPictPart = GetPict(*pszPict, pszPict);
        switch (*pszPict) {
            case 'M':
                wIndex = 0;
                goto CDDoIt;

            case 'D':
                wIndex = 1;
                goto CDDoIt;

            case 'Y':
                wIndex = 2;
                if (cchPictPart == 4) {
                    *pszInStr++ = '1';
                    *pszInStr++ = '9';
                }
                CDDoIt:
                /* This assumes that the values are of two digits only. */
                wTempVal = wValArray[wIndex];

                wDigit = wTempVal / (WORD)10;
                if (wDigit)
                    *pszInStr++ = (CHAR)(wDigit + '0');
                else if (cchPictPart > 1)
                    *pszInStr++ = '0';
#if 0
                else {
                    *pszInStr++ = ' ';
                    *pszInStr++ = ' ';
                }
#endif

                *pszInStr++ = (CHAR)((wTempVal % 10) + '0');

                pszPict += cchPictPart;

                /* Add the separator. */
                if (*pszPict)
                    *pszInStr++ = *pszPict;

                break;
        }
        pszPict++;
    }

    *pszInStr = 0L;

    return(lstrlen(szOutStr));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateTime() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This picks up the values in wValArray, converts them
 *  in a string containing the formatted time.
 *  wValArray should contain Hour-Min-Sec (in that order).
 */

INT
CreateTime(
          WORD * wValArray,
          LPSTR szOutStr
          )
{
    INT           i;
    BOOL          bAM;
    WORD          wHourMinSec;
    register WORD wDigit;
    register LPSTR pszInStr;

    pszInStr = szOutStr;

    wDigit = wValArray[0];
    bAM = (wDigit < 12);

    if (!iTime) {
        if (wDigit >= 12)
            wDigit -= 12;

        if (!wDigit)
            wDigit = 12;
    }

    wValArray[0] = wDigit;

    for (i=0; i < 3; i++) {
        wHourMinSec = wValArray[i];

        /* This assumes that the values are of two digits only. */
        wDigit = wHourMinSec / (WORD)10;

        if (i > 0)
            *pszInStr++ = (CHAR)(wDigit + '0');
        else if (wDigit || iTLZero)
            *pszInStr++ = (CHAR)(wDigit + '0');
#if 0
        else {
            /* NOTE: 2 blanks is the same width as one digit. */
            // wrong!
            *pszInStr++ = ' ';
            *pszInStr++ = ' ';
        }
#endif

        *pszInStr++ = (CHAR)((wHourMinSec % 10) + '0');

        if (i < 2)
            *pszInStr++ = *szTime;     /* Assumes time sep. is 1 char long */
    }

    // *pszInStr++ = ' ';

    if (bAM)
        lstrcpy(pszInStr, sz1159);
    else
        lstrcpy(pszInStr, sz2359);

    return lstrlen(szOutStr);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutSize() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutSize(
       DWORD dwSize,
       LPSTR szOutStr
       )
{
    // LPSTR szStr;
    // int  cBlanks;
    // char szTemp[30];

    // Convert it into string

    return wsprintf(szOutStr, "%lu", dwSize);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutDate() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutDate(
       LPFILETIME lpftDate,
       LPSTR szStr
       )
{
    WORD  wValArray[3];
    WORD wDate, wTime;

    if (FileTimeToDosDateTime(lpftDate, &wDate, &wTime)) {
        wValArray[0] = (WORD)((wDate & MONTHMASK) >> 5);              /* Month */
        wValArray[1] = (WORD)((wDate & DATEMASK));                    /* Date  */
        wValArray[2] = (WORD)((wDate >> 9) + 80);                     /* Year  */
        return(CreateDate((WORD *)wValArray, szStr));
    } else {
        return 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutTime() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutTime(
       LPFILETIME lpftTime,
       LPSTR szStr
       )
{
    WORD wValArray[3];
    WORD wDate, wTime;

    if (FileTimeToDosDateTime(lpftTime, &wDate, &wTime)) {
        wValArray[0] = (wTime >> 0x0B);
        wValArray[1] = (WORD)((wTime & MINUTEMASK) >> 5);
        wValArray[2] = (WORD)((wTime & SECONDSMASK) << 1);
    
        return(CreateTime((WORD *)wValArray, szStr));
    } else {
        return 0;
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PutAttributes() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
PutAttributes(
             register DWORD dwAttribute,
             register LPSTR pszStr
             )
{
    WORD  i;
    INT   cch = 0;

    for (i=0; i < 4; i++) {
        if (dwAttribute & 1) {  // BUG hardcoded.
            *pszStr++ = szAttr[i];
            cch++;
        } else {
#if 0
            *pszStr++ = '-';
            *pszStr++ = '-';
            cch += 2;
#endif
        }

        if (i == 2)
            dwAttribute >>= 3;                 /* Skip next two bits */
        else
            dwAttribute >>= 1;                 /* Goto next bit */
    }
    *pszStr = 0;
    return(cch);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateLBLine() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This creates a character string that contains all the required
 * details of a file;  (Name, Size, Date, Time, Attr)
 */

VOID
CreateLBLine(
            register WORD wLineFormat,
            LPMYDTA lpmydta,
            LPSTR szBuffer
            )
{
    register LPSTR pch;
    DWORD dwAttr;

    pch = szBuffer;

    dwAttr = lpmydta->my_dwAttrs;

    /* Copy the file name. */
    lstrcpy(pch, lpmydta->my_cFileName);
    pch += lstrlen(pch);

    *pch = 0L;

    /* Should we show the size? */
    if (wLineFormat & VIEW_SIZE) {
        *pch++ = TABCHAR;
        if (!(dwAttr & ATTR_DIR))
            pch += PutSize(lpmydta->my_nFileSizeLow, pch);
        else
            *pch = 0;
    }

    /* Should we show the date? */
    if (wLineFormat & VIEW_DATE) {
        *pch++ = TABCHAR;
        pch += PutDate(&lpmydta->my_ftLastWriteTime, pch);
    }

    /* Should we show the time? */
    if (wLineFormat & VIEW_TIME) {
        *pch++ = TABCHAR;
        pch += PutTime(&lpmydta->my_ftLastWriteTime, pch);
    }

    /* Should we show the attributes? */
    if (wLineFormat & VIEW_FLAGS) {
        *pch++ = TABCHAR;
        pch += PutAttributes(dwAttr, pch);
    }

    //  *pch = 0L;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CompareDTA() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
CompareDTA(
          register LPMYDTA lpItem1,
          LPMYDTA lpItem2,
          WORD wSort
          )
{
    register INT  ret;


    if (lpItem1->my_dwAttrs & ATTR_PARENT) {
        ret = -1;
        goto CDDone;
    }

    if (lpItem2->my_dwAttrs & ATTR_PARENT) {
        ret = 1;
        goto CDDone;
    }

    if ((lpItem1->my_dwAttrs & ATTR_DIR) > (lpItem2->my_dwAttrs & ATTR_DIR)) {
        ret = -1;
        goto CDDone;
    } else if ((lpItem1->my_dwAttrs & ATTR_DIR) < (lpItem2->my_dwAttrs & ATTR_DIR)) {
        ret = 1;
        goto CDDone;
    }

    switch (wSort) {
        case IDD_TYPE:
            {
                LPSTR ptr1;
                LPSTR ptr2;

                // BUG: should use strrchr for long file names.
                for (ptr1 = lpItem1->my_cFileName; *ptr1 && *ptr1 != '.'; ptr1++)
                    ;
                for (ptr2 = lpItem2->my_cFileName; *ptr2 && *ptr2 != '.'; ptr2++)
                    ;

                ret = lstrcmpi(ptr1, ptr2);

                if (ret == 0)
                    goto CompareNames;
                break;
            }

        case IDD_SIZE:
            if (lpItem1->my_nFileSizeLow > lpItem2->my_nFileSizeLow)
                ret = -1;
            else if (lpItem1->my_nFileSizeLow < lpItem2->my_nFileSizeLow)
                ret = 1;
            else
                goto CompareNames;
            break;

        case IDD_DATE:
            {
                DWORD d1High, d1Low;
                DWORD d2High, d2Low;

                d1High = lpItem1->my_ftLastWriteTime.dwHighDateTime;
                d2High = lpItem2->my_ftLastWriteTime.dwHighDateTime;

                if (d1High > d2High) {
                    ret = -1;
                } else if (d1High < d2High) {
                    ret = 1;
                } else {
                    d1Low = lpItem1->my_ftLastWriteTime.dwLowDateTime;
                    d2Low = lpItem2->my_ftLastWriteTime.dwLowDateTime;

                    if (d1Low > d2Low)
                        ret = -1;
                    else if (d1Low < d2Low)
                        ret = 1;
                    else
                        goto CompareNames;

                }
                break;
            }

        case IDD_NAME:
            CompareNames:
            ret = lstrcmpi(lpItem1->my_cFileName, lpItem2->my_cFileName);
            break;
    }

    CDDone:
    return ret;
}


// load the status buffers with the appropriate stuff and invalidates
// the status area causing it to repaint.

VOID
APIENTRY
UpdateStatus(
            HWND hWnd
            )
{
    CHAR szTemp[128];
    WCHAR szNumBuf1[40];
    WCHAR szNumBuf2[40];
    WORD wDrive;
    HWND hwndDir;
    RECT rc;

    if (!bStatusBar)
        return;

    if (hWnd != (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L))
        return;

    hwndDir = HasDirWindow(hWnd);

    szStatusTree[0] = 0L;

    if (hwndDir)
        GetDirStatus(hwndDir, szStatusTree, szStatusDir);
    else
        szStatusDir[0] = 0L;

    // force the status area to update

    GetClientRect(hwndFrame, &rc);
    rc.top = rc.bottom - dyStatus;
    InvalidateRect(hwndFrame, &rc, FALSE);
}


HWND
GetDirSelData(
             HWND hWnd,
             DWORD *pdwSelSize,
             INT *piSelCount,
             DWORD *pdwTotalSize,
             INT *piTotalCount
             )
{
    INT i;
    LPMYDTA lpmydta;
    HWND hwndLB;
    INT countSel, countTotal;
    LPINT lpSelItems, lpSelItemsT;
    HANDLE hDTA;

    if (!(hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX))) {       // fast scroll
        return NULL;
    }

    *pdwSelSize = *pdwTotalSize = 0L;
    *piSelCount = *piTotalCount = 0;
    countSel = (INT)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L);
    lpSelItems = LocalAlloc(LMEM_FIXED, sizeof(INT) * countSel);
    if (lpSelItems == NULL)
        return NULL;
    countSel = (INT)SendMessage(hwndLB, LB_GETSELITEMS, (WPARAM)countSel, (LPARAM)lpSelItems);

    hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);
    if (hDTA == NULL)
        return NULL;

    lpmydta = (LPMYDTA)LocalLock(hDTA);
    countTotal = (INT)lpmydta->my_nFileSizeLow;


    lpSelItemsT = lpSelItems;
    for (i = 0; i < countTotal; i++) {

        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);

        if (lpmydta->my_dwAttrs & ATTR_PARENT)
            continue;

        if (countSel && *lpSelItems == lpmydta->nIndex) {
            (*piSelCount)++;
            *pdwSelSize += lpmydta->my_nFileSizeLow;
            countSel--;
            lpSelItems++;
        }
        (*piTotalCount)++;
        *pdwTotalSize += lpmydta->my_nFileSizeLow;
    }


    LocalUnlock(hDTA);
    LocalFree(lpSelItemsT);
    return hwndLB;

}



VOID
GetDirStatus(
            HWND hWnd,
            LPSTR szMessage1,
            LPSTR szMessage2
            )
{
    INT iSelCount, iCount;
    DWORD dwSelSize, dwSize;
    CHAR szNumBuf[40];
    HWND hwndLB;

    szMessage2[0] = 0;

    hwndLB = GetDirSelData(hWnd, &dwSelSize, &iSelCount, &dwSize, &iCount);

    if (LoadString(hAppInstance, IDS_STATUSMSG, szMessage, sizeof(szMessage)))
        wsprintf(szMessage2, szMessage, iCount);

    if ((HWND)GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS) == hwndLB) {
        if (LoadString(hAppInstance, IDS_STATUSMSG2, szMessage, sizeof(szMessage)))
            wsprintf(szMessage1, szMessage, iSelCount);
    }
}


// given a descendant of an MDI child (or an MDI child) return
// the MDI child in the descendant chain.  returns NULL if not
// found.


HWND
APIENTRY
GetMDIChildFromDecendant(
                        HWND hwnd
                        )
{
    HWND hwndT;

    while (hwnd && ((hwndT = GetParent(hwnd)) != hwndMDIClient))
        hwnd = hwndT;

    return hwnd;
}



// setup the defTabStops[] array for subsequent TabbedTextOut() calls.
//
// in:
//      iMaxWidthFileName       the largest dx width of files to be
//                              displayed
//
// returns:
//      total extent of the "File Details" view.  used to
//      set scroll extents


INT
APIENTRY
FixTabsAndThings(
                HWND hwndLB,
                WORD *pwTabs,
                INT iMaxWidthFileName,
                WORD wViewOpts
                )
{
    INT i;
    HDC hdc;
    HFONT hOld;
    CHAR szBuf[30];
    INT  ixExtent = 0;

    i = iMaxWidthFileName;  // the widest filename

    if (pwTabs == NULL)
        return i;

    hdc = GetDC(NULL);
    hOld = SelectObject(hdc, hFont);

    // max size digits field
    if (wViewOpts & VIEW_SIZE) {
        MGetTextExtent(hdc, "99999999", 8, &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Size
    }

    if (wViewOpts & VIEW_DATE) {
        FILETIME filetime;

        DosDateTimeToFileTime((WORD)((19 << 9) | (12 << 5) | 30), (WORD)0xFFFF, &filetime);
        PutDate(&filetime, szBuf);
        // max date digits
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Date
    }

    // max time digits
    if (wViewOpts & VIEW_TIME) {
        FILETIME filetime;

        DosDateTimeToFileTime((WORD)((19 << 9) | (12 << 5) | 30), (WORD)0xFFFF, &filetime);
        PutTime(&filetime, szBuf);
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Time
    }

    // max attris digits
    if (wViewOpts & VIEW_FLAGS) {
        PutAttributes(ATTR_ALL, szBuf);
        MGetTextExtent(hdc, szBuf, lstrlen(szBuf), &ixExtent, NULL);
        i += ixExtent + dxText;
        *pwTabs++ = (WORD)i;  // Attributes
    }

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(NULL, hdc);

    SendMessage(hwndLB, LB_SETHORIZONTALEXTENT,
                i + dxFolder + 4 * dyBorderx2, 0L);

    return i;               // total extent
}


// sets the font and adjusts the dimension parameters for the
// new font
//
// in:
//      hWnd            hwnd of a dir window
//      hwndLB          and it's listbox
//      hFont           the font to set
//
// uses:
//      dyFileName      GLOBAL; set based on new font height
//      GWL_VIEW        window word of hWnd for either full or name view
//      GWL_HDTA        to compute the max extent given the new font
//
// sets:
//  Listbox tabs array
//      LB_SETCOLUMNWIDTH
//      or
//      LB_SETHORIZONTALEXTENT


VOID
APIENTRY
SetLBFont(
         HWND hWnd,
         HWND hwndLB,
         HANDLE hNewFont
         )
{
    INT dxMaxExtent;
    HANDLE hDTA;
    WORD wViewFlags = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

    SendMessage(hwndLB, WM_SETFONT, (WPARAM)hNewFont, 0L);

    // this is needed when changing the font. when creating
    // the return from WM_MEASUREITEM will set the cell height

    SendMessage(hwndLB, LB_SETITEMHEIGHT, 0, (LONG)dyFileName);

    hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);

    dxMaxExtent = (INT)GetMaxExtent(hwndLB, hDTA);

    // if we are in name only view we change the width

    if ((VIEW_EVERYTHING & wViewFlags) == VIEW_NAMEONLY) {
        SendMessage(hwndLB, LB_SETCOLUMNWIDTH, dxMaxExtent + dxFolder + dyBorderx2, 0L);
    } else {
        FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY),
                         dxMaxExtent, wViewFlags);
    }
}

VOID
APIENTRY
UpdateSelection(
               HWND hwndLB
               )
{
    INT count, i;
    RECT rc;

    count = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    for (i=0; i < count; i++) {

        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {
            SendMessage(hwndLB, LB_GETITEMRECT, i, (LPARAM)&rc);
            InvalidateRect(hwndLB, &rc, TRUE);
        }
    }
}



LONG
CreateFSCChangeDisplayMess(
                          HWND hWnd,
                          UINT wMsg,
                          WPARAM wParam,
                          LPARAM lParam
                          )
{
    CHAR         szCaret[MAXFILENAMELEN+1];
    CHAR         szAnchor[MAXFILENAMELEN+1];
    CHAR         szTopIndex[MAXFILENAMELEN+1];
    CHAR         szPath[256];
    HCURSOR  hCursor;
    HWND     hwndLB, hwndT;
    HANDLE   hDTA;
    LPMYDTA lpmydta;
    DWORD ws;
    LPSTR  pSel;
    INT   iSel, iTop=0;
    RECT  rc;
    BOOL  bResetFocus;
    WORD *pwTabs;

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {

        case WM_FILESYSCHANGE:
            if (cDisableFSC) {
                // I need to be updated
                SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, TRUE);
                break;
            }

            wParam = CD_PATH;
            lParam = 0L;
            /*** FALL THRU ***/

        case FS_CHANGEDISPLAY:

            // We dont want to reset the flag, if the operation is not CD_PATH.
            // This is because, only the operation CD_PATH implies a true
            // refresh. The operations CD_VEIW and CD_SORT are not refresh
            // operations. They merely reformat the existing contents of a dir
            // window. The flag is now reset in 'case CD_PATH:'.

            //SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, FALSE);

            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            pSel = NULL;          // init this

            bResetFocus = (GetFocus() == hwndLB);

            hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA);

            switch (wParam) {
                case CD_SORT:

                    // change the sort order of the listbox

                    // we want to save the current selection and things here
                    // and restore them once the listbox has been rebuilt

                    // But first, save a list of the selected items FIX31

                    pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                    DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                    iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);

                    SetWindowLong(GetParent(hWnd), GWL_SORT, LOWORD(lParam));

                    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

                    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
                    FillDirList(hwndLB, hDTA);

                    goto ResetSelection;

                case CD_VIEW:
                    {
                        WORD      wCurView;

                        // change the view type (name only, vs full details)
                        // Warning! Convoluted Code!  We want to destroy the
                        // listbox only if we are going between Name Only view
                        // and Details view.

                        wNewView = LOWORD(lParam);
                        wCurView = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

                        if (wNewView == wCurView)
                            break;    // NOP

                        // special case the long and partial view change
                        // this doesn't require us to recreate the listbox

                        if ((VIEW_EVERYTHING & wNewView) && (VIEW_EVERYTHING & wCurView)) {
                            SetWindowLong(GetParent(hWnd), GWL_VIEW, wNewView);
                            FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY),
                                             GetMaxExtent(hwndLB, hDTA), wNewView);

                            InvalidateRect(hwndLB, NULL, TRUE);
                            break;
                        }


                        /* Things are a changing radically.  Destroy the listbox. */

                        // But first, save a list of the selected items

                        pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                        DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                        iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                        lstrcpy(szTopIndex, szCaret);

                        if ((HWND)GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS) == hwndLB)
                            SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0L);

                        DestroyWindow(hwndLB);

                        /* Create a new one (preserving the Sort setting). */
                        wNewSort = (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT);
                        dwNewAttribs = (DWORD)GetWindowLong(GetParent(hWnd), GWL_ATTRIBS);

                        goto CreateLB;
                    }

                case CD_PATH | CD_ALLOWABORT:
                case CD_PATH:
                case CD_PATH_FORCE:

                    // bad things happens if we change the path
                    // while we are reading the tree.  bounch this
                    // in that case.  this causes the steal data
                    // code in the tree to barf because we would
                    // free the hDTA while it is being traversed
                    // (very bad thing)

                    // we set the GWL_FSCFLAG to true, if we could not refresh.
                    // else we set it to FALSE. However if the flag was previously
                    // TRUE we set lParam to NULL. lParam = NULL implies 'forced'
                    // refresh.

                    hwndT = HasTreeWindow(GetParent(hWnd));
                    if (hwndT && GetWindowLong(hwndT, GWL_READLEVEL)) {
                        SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, TRUE);
                        break;
                    } else {
                        if (SetWindowLong(GetParent(hWnd), GWL_FSCFLAG, FALSE))
                            lParam = 0L;
                    }

                    // change the path of the current directory window (basically
                    // recreate the whole thing)

                    // if lParam == NULL this is a refresh, otherwise
                    // check for short circut case to avoid rereading
                    // the directory

                    GetMDIWindowText(GetParent(hWnd), szPath, sizeof(szPath));

                    if (lParam) {

                        // get out early if this is a NOP

                        if ((wParam != CD_PATH_FORCE) &&
                            !lstrcmpi(szPath, (LPSTR)lParam))
                            break;

                        lstrcpy(szPath, (LPSTR)lParam);

                        iLastSel = -1;          // invalidate the last selection
                    }

                    // if this is a refresh save the current selection, anchor stuff, etc

                    if (!lParam) {
                        pSel = (LPSTR)DirGetSelection(hWnd, hwndLB, 0, NULL);
                        iTop = (INT)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);
                        DirGetAnchorFocus(hwndLB, hDTA, szAnchor, szCaret, szTopIndex);
                    }

                    // Create a new one (preserving the Sort setting)

                    wNewSort = (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT);
                    wNewView = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);
                    dwNewAttribs = GetWindowLong(GetParent(hWnd), GWL_ATTRIBS);

                    if (hDTA) {     // fast scroll case
                        LocalFree(hDTA);
                        hDTA = NULL;
                        SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);
                    }
                    goto CreateNewPath;
            }

            SetCursor(hCursor);
            ShowCursor(FALSE);
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "CreateFSCChangeDisplayMess - WM_CREATE");

            // wNewView, wNewSort and dwNewAddribs define the viewing
            // parameters of the new window (GLOBALS)
            // the window text of the parent window defines the
            // filespec and the directory to open up

            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            wParam = 0;           // don't allow abort in CreateDTABlock()
            lParam = 1L;          // allow DTA steal optimization
            pSel = NULL;          // no selection to restore
            bResetFocus = FALSE;  // no focus to restore

            // get the dir to open from our parent window text

            GetMDIWindowText(GetParent(hWnd), szPath, sizeof(szPath));

            if ((pwTabs = (WORD *)LocalAlloc(LPTR,sizeof(WORD) * 4)) == NULL)
                return -1L;

            SetWindowLongPtr(hWnd, GWLP_TABARRAY, (ULONG_PTR)pwTabs);

            CreateNewPath:

            // at this point szPath has the directory to read.  this
            // either came from the WM_CREATE case or the
            // FS_CHANGEDISPLAY (CD_PATH) directory reset

#ifdef DEBUG
            {
                char buf[80];

                wsprintf(buf, "attribs %4.4X\r\n", dwNewAttribs);
                OutputDebugString(buf);

            }
#endif

            if (!dwNewAttribs)
                dwNewAttribs = ATTR_DEFAULT;

            hDTA = CreateDTABlock(hWnd, szPath, dwNewAttribs, wParam & CD_ALLOWABORT ? TRUE : FALSE, lParam == 0L);

            // check for user abort (fast scroll case)

            if (hDTA == (HANDLE)-1) {
                SetWindowLongPtr(hWnd, GWLP_HDTA, 0L);
                goto FastScrollExit;
            }

            // for the FS_CHANGEDISPLAY case we set this now, to avoid
            // multiple title repaints when the user is fast scrolling

            if (wMsg != WM_CREATE)
                SetMDIWindowText(GetParent(hWnd), szPath);

            SetWindowLongPtr(hWnd, GWLP_HDTA, (LONG_PTR)hDTA);

            if (!hDTA)
                goto CDAbort;

            if (wMsg != WM_CREATE)
                goto SkipWindowCreate;

            CreateLB:
            if ((wNewView & VIEW_EVERYTHING) == VIEW_NAMEONLY)
                ws = WS_DIRSTYLE | LBS_MULTICOLUMN | WS_HSCROLL | WS_VISIBLE | WS_BORDER | LBS_DISABLENOSCROLL;
            else
                ws = WS_DIRSTYLE | WS_HSCROLL | WS_VSCROLL |  WS_VISIBLE | WS_BORDER | LBS_DISABLENOSCROLL;

            GetClientRect(hWnd, &rc);

            // the border stuff is for the non initial create case
            // I don't know why

            hwndLB = CreateWindowEx(0L, szListbox, NULL, ws,
                                    dyBorder, dyBorder,
                                    rc.right - 2*dyBorder, rc.bottom - 2*dyBorder,
                                    hWnd, (HMENU)IDCW_LISTBOX,
                                    hAppInstance, NULL);

            if (!hwndLB) {
                if (hDTA)
                    LocalFree(hDTA);

                if (wMsg != WM_CREATE)
                    SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                CDAbort:
                ShowCursor(FALSE);
                SetCursor(hCursor);
                return -1L;
            }

            // set all the view/sort/include parameters here

            SetWindowLong(GetParent(hWnd), GWL_VIEW, wNewView);
            SetWindowLong(GetParent(hWnd), GWL_SORT, wNewSort);
            SetWindowLong(GetParent(hWnd), GWL_ATTRIBS, dwNewAttribs);

            // restore the last focus stuff if we are recreating here
            if (!GetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS))
                SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LONG_PTR)hwndLB);

            // set the font and dimensions here

            SkipWindowCreate:
            SetLBFont(hWnd, hwndLB, hFont);

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            FillDirList(hwndLB, hDTA);

            if (pSel) {
                BOOL bDidSomething;

                ResetSelection:
                /* Give the selected item the focus rect and anchor pt. */
                bDidSomething = SetSelection(hwndLB, hDTA, pSel);
                LocalFree((HANDLE)pSel);

                if (!bDidSomething)
                    goto SelectFirst;

                iSel = DirFindIndex(hwndLB, hDTA, szTopIndex);
                if (iSel == -1)
                    iSel = 0;
                SendMessage(hwndLB, LB_SETTOPINDEX, iSel, 0L);

                iSel = DirFindIndex(hwndLB, hDTA, szAnchor);
                if (iSel == -1)
                    iSel = 0;
                SendMessage(hwndLB, LB_SETANCHORINDEX, iSel, 0L);

                iSel = DirFindIndex(hwndLB, hDTA, szCaret);
                if (iSel == -1)
                    iSel = 0;
                /* SETCARETINDEX will scroll item into view */
                SendMessage(hwndLB, LB_SETCARETINDEX, iSel, 0L);

            } else {
                INT iLBCount;
                SelectFirst:
                iLBCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

                if (iLastSel != -1 && (iLastSel <= iLBCount)) {

                    iSel = iLastSel;

                    // check the case of the last item being deleted

                    if (iSel == iLBCount)
                        iSel--;

                    SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)iSel);

                } else {

                    // Select the first non-directory item

                    iSel = 0;
                    while (iSel < iLBCount) {

                        SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)&lpmydta);
                        if (!lpmydta)
                            break;
                        if (!(lpmydta->my_dwAttrs & ATTR_PARENT)) {
                            iTop = iSel;
                            break;
                        }
                        iSel++;
                    }
                    LocalUnlock(hDTA);

                    if (iSel == iLBCount)
                        iSel = 0;
                }

                SendMessage(hwndLB, LB_SETTOPINDEX, iTop, 0L);
                // and select this item if no tree window
                if (!HasTreeWindow(GetParent(hWnd)))
                    SendMessage(hwndLB, LB_SETSEL, TRUE, (DWORD)iSel);
                SendMessage(hwndLB, LB_SETANCHORINDEX, iSel, 0L);
                /* SETCARETINDEX will scroll item into view */
                SendMessage(hwndLB, LB_SETCARETINDEX, iSel, 0L);
            }

            if (bResetFocus)
                if (SetDirFocus(hWnd))
                    SetFocus(hWnd);

            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);

            InvalidateRect(hwndLB, NULL, TRUE);

            lFreeSpace = -1;              // force status update
            UpdateStatus(GetParent(hWnd));

            FastScrollExit:

            ShowCursor(FALSE);
            SetCursor(hCursor);
            break;
    }

    return 0L;
}


INT_PTR
APIENTRY
DirWndProc(
          HWND hWnd,
          UINT wMsg,
          WPARAM wParam,
          LPARAM lParam
          )
{
    INT      iSel, i;
    LPSTR    pSel;
    HWND     hwndLB;
    HANDLE   hDTA;
    LPMYDTA lpmydta;
    CHAR szTemp[MAXPATHLEN] = {0};
    CHAR szSourceFile[MAXPATHLEN];

    static HWND       hwndOwnerDraw = NULL;

    STKCHK();

    /* Here we generate OWNERDRAWBEGIN and OWNERDRAWEND messages
     * to speed up the painting operations.  We do the expensive stuff
     * at the beginning instead of on every DRAWITEM message.
     */

    if (hwndOwnerDraw == hWnd && wMsg != WM_DRAWITEM) {
        hwndOwnerDraw = NULL;
        SendMessage(hWnd, WM_OWNERDRAWEND, 0, 0L);
    } else if (wMsg == WM_DRAWITEM && hwndOwnerDraw != hWnd) {
        SendMessage(hWnd, WM_OWNERDRAWBEGIN, wParam, lParam);
        hwndOwnerDraw = hWnd;
    }

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {
        // returns in lParam upper case ANSI directory string with
        // a trailing backslash.  if you want to do a SetCurrentDirecotor()
        // you must first StripBackslash() the thing!

        case FS_GETDIRECTORY:
            MSG("DirWndProc", "FS_GETDIRECTORY");

            GetMDIWindowText(GetParent(hWnd), (LPSTR)lParam, (INT)wParam);        // get the string

            StripFilespec((LPSTR)lParam); // Remove the trailing extention

            AddBackslash((LPSTR)lParam);  // terminate with a backslash

            //AnsiUpper((LPSTR)lParam);     // and upper case
            break;

        case FS_GETDRIVE:
            MSG("DirWndProc", "FS_GETDRIVE");
            // Returns the letter of the corresponding directory

            GetWindowText(GetParent(hWnd), szTemp, sizeof(szTemp));
            AnsiUpper(szTemp);
            return szTemp[0];     // first character

        case FS_GETFILESPEC:
            MSG("DirWndProc", "FS_GETFILESPEC");
            // returns the current filespec (from View.Include...).  this is
            // an uppercase ANSI string

            GetMDIWindowText(GetParent(hWnd), (LPSTR)lParam, (INT)wParam);
            StripPath((LPSTR)lParam);
            //AnsiUpper((LPSTR)lParam);     // and upper case
            break;

        case FS_SETSELECTION:
            MSG("DirWndProc", "FS_SETSELECTION");
            // wParam is the select(TRUE)/unselect(FALSE) param
            // lParam is the filespec to match against

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            DSSetSelection(hwndLB, wParam ? TRUE : FALSE, (LPSTR)lParam, FALSE);
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            break;

        case FS_GETSELECTION:
            // return = pszDir
#define pfDir       (BOOL *)lParam
#define fSingleSel  (BOOL)wParam
            MSG("DirWndProc", "FS_GETSELECTION");

            return (INT_PTR)DirGetSelection(hWnd, hwndLB, fSingleSel, pfDir);
#undef pfDir
#undef fSingleSel

        case WM_CREATE:
        case WM_FILESYSCHANGE:
        case FS_CHANGEDISPLAY:
            TRACE(BF_WM_CREATE, "DirWndProc - WM_CREATE");
            return CreateFSCChangeDisplayMess(hWnd, wMsg, wParam, lParam);


        case WM_DESTROY:
            MSG("DirWndProc", "WM_DESTROY");
            {
                HANDLE hMem;
                HWND hwnd;

                if (hwndLB == GetFocus())
                    if (hwnd = HasTreeWindow(GetParent(hWnd)))
                        SetFocus(hwnd);

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_TABARRAY))
                    LocalFree(hMem);
            }
            break;

        case WM_CHARTOITEM:
            MSG("DirWndProc", "WM_CHARTOITEM");
            {
                WORD      j;
                WORD      cItems;
                CHAR      ch[2];

                if ((ch[0] = GET_WM_CHARTOITEM_CHAR(wParam, lParam)) <= ' ')
                    return(-1L);

                i = GET_WM_CHARTOITEM_POS(wParam, lParam);
                cItems = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

                szTemp[1] = 0L;
                ch[0] &= 255;
                ch[1] = '\0';

                for (j=1; j <= cItems; j++) {
                    SendMessage(hwndLB, LB_GETTEXT, (i + j) % cItems, (LPARAM)&lpmydta);

                    szTemp[0] = lpmydta->my_cFileName[0];

                    /* Do it this way to be case insensitive. */
                    if (!lstrcmpi((LPSTR)ch, szTemp))
                        break;
                }

                if (j > cItems)
                    return -2L;

                return(MAKELONG((i + j) % cItems, 0));
            }

        case WM_COMPAREITEM:
            MSG("DirWndProc", "WM_COMPAREITEM");
            {
#define lpci ((LPCOMPAREITEMSTRUCT)lParam)

                return (LONG)CompareDTA((LPMYDTA)lpci->itemData1,
                                        (LPMYDTA)lpci->itemData2,
                                        (WORD)GetWindowLong(GetParent(hWnd), GWL_SORT));
            }

        case WM_NCDESTROY:
            MSG("DirWndProc", "WM_NCDESTROY");

            if (hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTA)) {
                LocalFree(hDTA);
            }

            break;

        case WM_DRAGLOOP:
            MSG("DirWndProc", "WM_DRAGDROP");
            /* WM_DRAGLOOP is sent to the source window as the object is moved.
             *
             *    wParam: TRUE if the object is currently over a droppable sink
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGLOOP is used to turn the source bitmaps on/off as we drag. */

            DSDragLoop(hwndLB, wParam, (LPDROPSTRUCT)lParam, FALSE);
            break;

        case WM_DRAGSELECT:
            MSG("DirWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent to a sink whenever an new object is dragged
             * inside of it.
             *
             *    wParam: TRUE if the sink is being entered, FALSE if it's being
             *            exited.
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGSELECT is used to turn our selection rectangle on or off. */

#define lpds ((LPDROPSTRUCT)lParam)

            iSelHilite = LOWORD(lpds->dwControlData);
            DSRectItem(hwndLB, iSelHilite, (BOOL)wParam, FALSE);
            break;

        case WM_DRAGMOVE:
            MSG("DirWndProc", "WM_DRAGMOVE");
            /* WM_DRAGMOVE is sent to a sink as the object is being dragged
             * within it.
             *
             *    wParam: Unused
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGMOVE is used to move our selection rectangle among sub-items. */

#define lpds ((LPDROPSTRUCT)lParam)

            /* Get the subitem we are over. */
            iSel = LOWORD(lpds->dwControlData);

            /* Is it a new one? */
            if (iSel == iSelHilite)
                break;

            /* Yup, un-select the old item. */
            DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);

            /* Select the new one. */
            iSelHilite = iSel;
            DSRectItem(hwndLB, iSel, TRUE, FALSE);
            break;

        case WM_OWNERDRAWBEGIN:
#define lpLBItem ((LPDRAWITEMSTRUCT)lParam)

            MSG("DirWndProc", "WM_OWNERDRAWBEGIN");

            /* Set the default bk and text colors. */
            SetTextColor(lpLBItem->hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(lpLBItem->hDC, GetSysColor(COLOR_WINDOW));

#undef lpLBItem
            break;

        case WM_OWNERDRAWEND:
            MSG("DirWndProc", "WM_OWNERDRAWEND");
            break;

        case WM_DRAWITEM:
#define lpLBItem ((LPDRAWITEMSTRUCT)lParam)

            MSG("DirWndProc", "WM_DRAWITEM");
            {
                WORD wViewFlags;
                LPMYDTA lpmydta;

                /* Don't do anything to empty listboxes. */
                if (lpLBItem->itemID == -1)
                    break;

                if (lpLBItem->itemData == (DWORD)0) {

                    LoadString(hAppInstance, IDS_NOFILES, szTemp, sizeof(szTemp));
                    TextOut(lpLBItem->hDC,
                            lpLBItem->rcItem.left,
                            lpLBItem->rcItem.top,
                            szTemp, lstrlen(szTemp));
                } else {

                    lpmydta = (LPMYDTA)lpLBItem->itemData;
                    wViewFlags = (WORD)GetWindowLong(GetParent(hWnd), GWL_VIEW);

                    if (wViewFlags & VIEW_EVERYTHING) {

                        // if any of the wViewFlags bits set, we are in slow mode

                        CreateLBLine(wViewFlags, lpmydta, szTemp);
                        DrawItem(lpLBItem, szTemp, lpmydta->my_dwAttrs, (HWND)GetFocus()==lpLBItem->hwndItem,
                                 (WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAY));
                    } else
                        DrawItemFast(hWnd, lpLBItem, lpmydta,
                                     (HWND)GetFocus()==lpLBItem->hwndItem);
                }
            }
#undef lpLBItem
            break;

        case WM_DROPOBJECT:
            MSG("DirWndProc", "WM_DROPOBJECT");
            {
                WORD      ret;
                LPSTR      pFrom;
                DWORD     dwAttrib = 0;       // init this to not a dir
                WORD      iSelSink;

#define lpds  ((LPDROPSTRUCT)lParam)

                // Do nothing - but remove selection rectangle
                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                return(TRUE);

                /* WM_DROPOBJECT is sent to a sink when the user releases an
                 * acceptable object over it
                 *
                 *    wParam: TRUE if over the non-client area, FALSE if over the
                 *            client area.
                 *    lParam: LPDROPSTRUCT
                 */

                // this is the listbox index of the destination
                iSelSink = LOWORD(lpds->dwControlData);

                /* Are we dropping onto ourselves? (i.e. a selected item in the
                 * source listbox OR an unused area of the source listbox)  If
                 * so, don't do anything. */

                if (hWnd == lpds->hwndSource) {
                    if ((iSelSink == 0xFFFF) || SendMessage(hwndLB, LB_GETSEL, iSelSink, 0L))
                        return TRUE;
                }

                // set the destination, assume move/copy case below (c:\foo\)
                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                // Are we dropping on a unused portion of some listbox?
                if (iSelSink == 0xFFFF)
                    goto NormalMoveCopy;

                // check for drop on a directory
                SendMessage(hwndLB, LB_GETTEXT, iSelSink, (LPARAM)&lpmydta);
                lstrcpy(szSourceFile, lpmydta->my_cFileName);
                dwAttrib = lpmydta->my_dwAttrs;

                if (dwAttrib & ATTR_DIR) {
                    if (dwAttrib & ATTR_PARENT) {      // special case the parent
                        StripBackslash(szTemp);
                        StripFilespec(szTemp);
                    } else {
                        lstrcat(szTemp, szSourceFile);
                    }
                    goto DirMoveCopy;
                }

                // dropping on a program?

                if (!IsProgramFile(szSourceFile))
                    goto NormalMoveCopy;              // no, normal stuff

                // directory drop on a file? this is a NOP

                if (lpds->wFmt == DOF_DIRECTORY) {
                    DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                    break;
                }

                // We're dropping a file onto a program.
                // Exec the program using the source file as the parameter.

                // set the directory to that of the program to exec

                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                StripBackslash(szTemp);
                FixAnsiPathForDos(szTemp);
                SheChangeDir(szTemp);

                // get the selected file

                pSel = (LPSTR)SendMessage(lpds->hwndSource, FS_GETSELECTION, TRUE, 0L);

                if (lstrlen(pSel) > MAXPATHLEN)   // don't blow up below!
                    goto DODone;

                if (bConfirmMouse) {

                    LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_EXECMOUSECONFIRM, szTemp, sizeof(szTemp));

                    wsprintf(szMessage, szTemp, (LPSTR)szSourceFile, (LPSTR)pSel);
                    if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
                        goto DODone;
                }


                // create an absolute path to the argument (search window alaready
                // is absolute)

                if (lpds->hwndSource == hwndSearch) {
                    szTemp[0] = 0L;
                } else {
                    SendMessage(lpds->hwndSource, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                }

                lstrcat(szTemp, pSel);        // this is the parameter to the exec

                // put a "." extension on if none found
                if (*GetExtension(szTemp) == 0)
                    lstrcat(szTemp, ".");

                FixAnsiPathForDos(szSourceFile);
                FixAnsiPathForDos(szTemp);
                ret = ExecProgram(szSourceFile, szTemp, NULL, FALSE);

                if (ret)
                    MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

                DODone:
                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);
                LocalFree((HANDLE)pSel);
                return TRUE;

                NormalMoveCopy:
                /* Make sure that we don't move into same dir. */
                if (GetParent(hWnd) == (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L))
                    return TRUE;
                DirMoveCopy:

                // the source filename is in the loword
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);
                // SetSourceDir(lpds);

                AddBackslash(szTemp);
                lstrcat(szTemp, szStarDotStar);   // put files in this dir

                CheckEscapes(szTemp);
                ret = DMMoveCopyHelper(pFrom, szTemp, fShowSourceBitmaps);

                DSRectItem(hwndLB, iSelHilite, FALSE, FALSE);

                if (ret)
                    return TRUE;

                if (!fShowSourceBitmaps)
                    SendMessage(lpds->hwndSource, WM_FILESYSCHANGE, FSC_REFRESH, 0L);

                // we got dropped on, but if this is a dir we don't need to refresh

                if (!(dwAttrib & ATTR_DIR))
                    SendMessage(hWnd, WM_FILESYSCHANGE, FSC_REFRESH, 0L);

                return TRUE;
            }

#if 0
        case WM_GETTEXT:
            MSG("DirWndProc", "WM_GETTEXT");
            {
                HDC       hDC;
                RECT      rc;

                /* This is where we make sure that the Directory's caption fits
                 * inside the caption bar.
                 */

                /* Get the full path name. */
                DefWindowProc(hWnd, wMsg, wParam, lParam);

                GetClientRect(hWnd, (LPRECT)&rc);
                hDC = GetDC(hWnd);
                CompactPath(hDC, (LPSTR)lParam, rc.right-rc.left-(dxText * 6));
                ReleaseDC(hWnd, hDC);

                return((LONG)lstrlen((LPSTR)lParam)); /* Don't call DefWindowProc()! */
            }
#endif

        case WM_LBTRACKPOINT:
            MSG("DirWndProc", "WM_LBTRACKPOINT");
            return DSTrackPoint(hWnd, hwndLB, wParam, lParam, FALSE);

        case WM_MEASUREITEM:
            MSG("DirWndProc", "WM_MEASUREITEM");
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

            pLBMItem->itemHeight = dyFileName;    // the same as in SetLBFont()
            break;

        case WM_QUERYDROPOBJECT:
            MSG("DirWndProc", "WM_QUERYDROPOBJECT");

            // lParam LPDROPSTRUCT
            //
            // return values:
            //    0       don't accept (use ghost buster)
            //    1       accept, use cursor from DragObject()
            //    hCursor accept, change to this cursor
            //

            /* Ensure that we are dropping on the client area of the listbox. */
#define lpds ((LPDROPSTRUCT)lParam)

            /* Ensure that we can accept the format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                    if (lpds->hwndSink == hWnd)
                        lpds->dwControlData = (DWORD)-1L;

                    return (INT_PTR)GetMoveCopyCursor();
            }
            return FALSE;

        case WM_SETFOCUS:

            // Fall through

        case WM_LBUTTONDOWN:
            MSG("DirWndProc", "WM_SETFOCUS/WM_LBUTTONDOWN");
            SetFocus(hwndLB);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                case LBN_DBLCLK:
                    MSG("DirWndProc", "LBN_DBLCLK");
                    /* Double-click... Open the blasted thing. */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
                    break;

                case LBN_SELCHANGE:
                    MSG("DirWndProc", "LBN_SELCHANGE");
                    for (i = 0; i < iNumExtensions; i++) {
                        (extensions[i].ExtProc)(hwndFrame, FMEVENT_SELCHANGE, 0L);
                    }
                    UpdateStatus(GetParent(hWnd));
                    break;

                case LBN_SETFOCUS:
                    MSG("DirWndProc", "LBN_SETFOCUS");

                    // Make sure there are files in this window.  If not, set
                    // the focus to the tree or drives window.  Note:  This
                    // message was caused by a mouse click and not an
                    // accelerator, because these were handled in the window
                    // routine that was losing the focus.
                    if (SetDirFocus(hWnd)) {
                        SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                        UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                    }
                    break;

                case LBN_KILLFOCUS:
                    MSG("DirWndProc", "LBN_KILLFOCUS");
                    SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, 0L);
                    UpdateSelection(GET_WM_COMMAND_HWND(wParam, lParam));
                    SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)GET_WM_COMMAND_HWND(wParam, lParam));
                    break;
            }
            break;

        case WM_VKEYTOITEM:
            MSG("DirWndProc", "WM_VKEYTOITEM");
            switch (GET_WM_VKEYTOITEM_ITEM(wParam, lParam)) {
                case VK_ESCAPE:
                    bCancelTree = TRUE;
                    return -2L;

                case 0xBF:        /* Ctrl-/ */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_SELALL, 0, 0));
                    return -2;

                case 0xDC:        /* Ctrl-\ */
                    SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_DESELALL, 0, 0));
                    return -2;

                case VK_F6:       // like excel
                case VK_TAB:
                    {
                        HWND hwndTree, hwndDrives;

                        GetTreeWindows(GetParent(hWnd), &hwndTree, NULL, &hwndDrives);

                        if (GetKeyState(VK_SHIFT) < 0)
                            SetFocus(hwndTree ? hwndTree : hwndDrives);
                        else
                            SetFocus(hwndDrives);
                        break;
                    }

                case VK_BACK:
                    SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                    // are we already at the root?
                    if (lstrlen(szTemp) <= 3)
                        return -1;

                    StripBackslash(szTemp);
                    StripFilespec(szTemp);

                    CreateDirWindow(szTemp, TRUE, GetParent(hWnd));
                    return -2;

                default:
                    {
                        HWND hwndDrives;

                        // check for Ctrl-[DRIVE LETTER] and pass on to drives
                        // window
                        if ((GetKeyState(VK_CONTROL) < 0) && (hwndDrives = HasDrivesWindow(GetParent(hWnd)))) {
                            return SendMessage(hwndDrives, wMsg, wParam, lParam);
                        }
                        break;
                    }
            }
            return -1;

        case WM_SIZE:
            MSG("DirWndProc", "WM_SIZE");
            if (!IsIconic(GetParent(hWnd))) {
                INT iMax;

                MoveWindow(hwndLB, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);


                iMax = (INT)SendMessage(hwndLB, LB_GETCARETINDEX, 0, 0L);
                if (iMax >= 0) // scroll item into view
                    /* SETCARETINDEX will scroll item into view */
                    SendMessage(hwndLB, LB_SETCARETINDEX, iMax, 0L);
                //MakeItemVisible(iMax, hwndLB);

            }
            break;

        default:
            DEFMSG("DirWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}



VOID
SortDirList(
           HWND hWnd,
           LPMYDTA lpmydta,
           WORD count,
           LPMYDTA *lplpmydta
           )
{
    INT i, j;
    WORD wSort;
    INT iMax, iMin, iMid;

    wSort = (WORD)GetWindowLong(GetParent(GetParent(hWnd)), GWL_SORT);
    for (i = 0; i < (INT)count; i++) {
        // advance to next
        lpmydta = GETDTAPTR(lpmydta, lpmydta->wSize);
        if (i == 0) {
            lplpmydta[i] = lpmydta;
        } else {

            // do a binary insert

            iMin = 0;
            iMax = i-1;       // last index

            do {
                iMid = (iMax + iMin) / 2;
                if (CompareDTA(lpmydta, lplpmydta[iMid], wSort) > 0)
                    iMin = iMid + 1;
                else
                    iMax = iMid - 1;

            } while (iMax > iMin);

            if (iMax < 0)
                iMax = 0;

            if (CompareDTA(lpmydta, lplpmydta[iMax], wSort) > 0)
                iMax++;         // insert after this one
            if (i != iMax) {
                for (j = i; j > iMax; j--)
                    lplpmydta[j] = lplpmydta[j-1];
            }
            lplpmydta[iMax] = lpmydta;
        }

    }
}


BOOL
SetDirFocus(
           HWND hwndDir
           )
/*
    Set the focus to whoever deserves it if not the directory window.
    Return whether focus needs to be set to directory window.
*/
{
    DWORD dwTemp;
    HWND hwndLB = GetDlgItem(hwndDir, IDCW_LISTBOX);

    SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &dwTemp);

    if (!dwTemp) {
        HWND hwndFocus,hwndTree,hwndDrives,hwndParent = GetParent(hwndDir);

        GetTreeWindows(hwndParent,&hwndTree,NULL,&hwndDrives);

        if ((hwndFocus = GetTreeFocus(hwndParent)) == hwndDir)
            SetFocus(hwndTree ? hwndTree : hwndDrives);
        else
            SetFocus(hwndFocus);

        return FALSE;
    } else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdcopy.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDCOPY.C -                                                             */
/*                                                                          */
/*      File Manager Diskette Copying Routines                              */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

LONG  APIENTRY   LongPtrAdd(LPSTR, DWORD);

PBPB GetBootBPB(INT nSrceDrive);
PBPB GetBPB(INT nDrive, PDevPB pDevicePB);
BOOL CheckBPBCompatibility(PBPB pSrceBPB, int nSrcDriveType, PBPB pDestBPB, int nDestDriveType);

BOOL ModifyDeviceParams(
                                   INT nDrive,
                                   PDevPB pdpbParams,
                                   HANDLE *phSaveParams,
                                   PBPB pDriveBPB,
                                   PBPB pMediaBPB);

BOOL FormatAllTracks(
                                PDISKINFO pDisketteInfo,
                                WORD wStartCylinder,
                                WORD wStartHead,
                                LPSTR lpDiskBuffer);

BOOL AllocDiskCopyBuffers(PDISKINFO pDisketteInfo);
VOID FreeBuffers(VOID);
VOID GetDisketteInfo(PDISKINFO pDisketteInfo, PBPB pBPB);
VOID DCopyMessageBox(HWND hwnd, WORD idString, WORD wFlags);
VOID PromptDisketteChange(HWND hwnd, BOOL bWrite);
INT ReadWriteMaxPossible(BOOL bWrite, WORD wStartCylinder, PDISKINFO pDisketteInfo);
INT ReadWrite(BOOL bWrite, WORD wStartCylinder, PDISKINFO pDisketteInfo);
BOOL RestoreDPB(INT nDisk, HANDLE hSavedParams);
INT ReadWriteCylinder(BOOL bWrite, WORD wCylinder, PDISKINFO pDisketteInfo);


/* The following structure is the Parameter block for the read-write
 * operations using the IOCTL calls in DOS
 */
struct RW_PARMBLOCK {
    BYTE        bSplFn;
    WORD        wHead;
    WORD        wCylinder;
    WORD        wStSector;
    WORD        wCount;
    LPSTR       lpBuffer;
};

/* Global Variables */
BOOL        bFormatDone;
BOOL        bSingleDrive            = TRUE;
WORD        wCompletedCylinders     = 0;
DWORD       dwDisketteBufferSize;
LPSTR       lpDosMemory;
LPSTR       lpFormatBuffer;
LPSTR       lpReadWritePtr;
LPSTR       hpDisketteBuffer;
HANDLE      hFormatBuffer;
HANDLE      hDosMemory;
HANDLE      hDisketteBuffer;
PDevPB      pTrackLayout;           /* DevPB with the track layout */
BOOTSEC     BootSec;

/* External Variables */
extern BPB  bpbList[];



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetBootBPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads the boot sector of a floppy and returns a ptr to
 * the BIOS PARAMETER BLOCK in the Boot sector.
 */

PBPB
GetBootBPB(
          INT nSrceDrive
          )
{
    INT       rc;

    /* Make sure that the source diskette's boot sector is valid. */
    rc = GenericReadWriteSector((LPSTR)&BootSec, INT13_READ, (WORD)nSrceDrive, 0, 0, 1);

    if ((rc < 0) || ((BootSec.jump[0] != 0xE9) && (BootSec.jump[0] != 0xEB)))
        return (PBPB)NULL;

    return (PBPB)&(BootSec.BPB);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetBPB() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Gets get the BPB of the Physical Drive.
 *
 * This uses the IOCTL calls if DOS ver >= 3.2; Otherwise it uses the
 * BIOS calls to find out the drive type and picks us the BPB from a table.
 * It also returns the DeviceParameterBlock thro params if DOS >= 3.2.
 * Sets devType field of DeviceParameterBlock in any case (11.12.91) v-dougk
 */

PBPB
GetBPB(
      INT nDrive,
      PDevPB pDevicePB
      )
{
    INT       iDisketteType;
    PBPB      pBPB = NULL;

    /* Check the DOS version */
    if (wDOSversion >= DOS_320) {
        /* All fields in pDevicePB must be initialized to zero. */
        memset(pDevicePB, 0, sizeof(DevPB));

        /* Spl Function field must be set to get parameters */
        pDevicePB->SplFunctions = 0;
        pBPB = &(pDevicePB->BPB);
    } else {
        /* Find out the Drive type using the BIOS. */
        if ((iDisketteType = GetDriveCapacity((WORD)nDrive)) == 0)
            goto GBPB_Error;

        /* Lookup this drive's default BPB. */
        pBPB = &bpbList[iDisketteType+2];

        switch (iDisketteType) {
            case 1:
                pDevicePB->devType = 0; // 360K
                break;
            case 2:
                pDevicePB->devType = 1; // 1.2M
                break;
        }
    }

    GBPB_Error:
    return (pBPB);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckBPBCompatibility() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks whether the two BPB are compatible for the purpose of performing
 * the diskcopy operation.
 */

BOOL
CheckBPBCompatibility(
                     PBPB pSrceBPB,
                     int nSrcDriveType,
                     PBPB pDestBPB,
                     int nDestDriveType
                     )
{
    /* Let us compare the media byte */
    if (pSrceBPB->bMedia == 0xF9) {
        /* If the source and dest have the same number of sectors,
         * or if srce is 720KB and Dest is 1.44MB floppy drive,
         * thnigs are kosher.
         */
        if ((pSrceBPB->cSec == pDestBPB->cSec) ||
            ((pSrceBPB->secPerTrack == 9) && (pDestBPB -> bMedia == 0xF0)))
            return (TRUE);
    } else {
        /* If they have the same media byte */
        if ((pSrceBPB->bMedia == pDestBPB->bMedia) &&
            (pSrceBPB->cbSec  == pDestBPB->cbSec) && // bytes per sector are the same
            (pSrceBPB->cSec   == pDestBPB->cSec))    // total sectors on drive are the same
            return (TRUE); /* They are compatible */
        else if
            /* srce is 160KB and dest is 320KB drive */
             (((pSrceBPB->bMedia == MEDIA_160) && (pDestBPB->bMedia == MEDIA_320)) ||
              /* or if srce is 180KB and dest is 360KB drive */
              ((pSrceBPB->bMedia == MEDIA_180) && (pDestBPB->bMedia == MEDIA_360)) ||
              /* or if srce is 1.44MB and dest is 2.88MB drive */
              ((pSrceBPB->bMedia == MEDIA_1440) && (pDestBPB->bMedia == MEDIA_2880)
               && ((nSrcDriveType == 7) || (nSrcDriveType == 9))
               &&  (nDestDriveType == 9)) ||
              /* or if srce is 360KB and dest is 1.2MB drive */
              ((pSrceBPB->bMedia == MEDIA_360) && (pDestBPB->secPerTrack == 15)))
            return (TRUE); /* They are compatible */
    }

    /* All other combinations are currently incompatible. */
    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ModifyDeviceParams() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Saves a copy of the drive parameters block and
 * Checks if the BPB of Drive and BPB of disk are different and if
 * so, modifies the drive parameter block accordingly.
 */

BOOL
ModifyDeviceParams(
                  INT nDrive,
                  PDevPB pdpbParams,
                  HANDLE *phSaveParams,
                  PBPB pDriveBPB,
                  PBPB pMediaBPB)
{
    INT       iDriveCode;
    HANDLE    hNewDPB;
    PDevPB    pNewDPB;

    if (!(*phSaveParams = BuildDevPB(pdpbParams)))
        return FALSE;

    /* Check if the Disk and Drive have the same parameters */
    if (pMediaBPB->bMedia != pDriveBPB->bMedia) {
        /* They are not equal; So, it must be a 360KB floppy in a 1.2MB drive
         * or a 720KB floppy in a 1.44MB drive kind of situation!.
         * So, modify the DriveParameterBlock's BPB.
         */
        *(PBPB)&(pdpbParams->BPB) = *pMediaBPB;
    }

    if (wDOSversion >= DOS_320) {
        /* Build a DPB with TrackLayout */
        if (!(hNewDPB = BuildDevPB(pdpbParams)))
            goto MDP_Error;

        pNewDPB = (PDevPB)LocalLock(hNewDPB);

        pNewDPB->SplFunctions = 4;        /* To Set parameters */

        /* Check if this is a 360KB floppy; And if it is a 1.2MB drive, the
         * number of cylinders and mediatype field are wrong; So, we modify
         * these fields here anyway;
         * This is required to format a 360KB floppy on a NCR PC916 machine;
         * Fix for Bug #6894 --01-10-90-- SANKAR
         */
        if (pMediaBPB->bMedia == MEDIA_360) {
            pNewDPB->NumCyls = 40;
            pNewDPB->bMediaType = 1;
        }

        LocalUnlock(hNewDPB);
        LocalFree(hNewDPB);
    } else {
        iDriveCode = 0;
        switch (pMediaBPB->bMedia) {
            case MEDIA_360:
            case MEDIA_320:
                if ((pDriveBPB->bMedia == MEDIA_360) ||
                    (pDriveBPB->bMedia == MEDIA_320))
                    iDriveCode = 1;  /* Must be 360/320KB in 360KB drive */
                else
                    iDriveCode = 2;  /* Must be 360/320Kb in 1.2MB drive */
                break;

            case MEDIA_1200:
                iDriveCode = 3;  /* Must be 1.2MB in 1.2MB drive */
                break;
        }
        if (iDriveCode)
            SetDASD((WORD)nDrive, (BYTE)iDriveCode);
    }
    return (TRUE);

    /* Error handling */
    MDP_Error:
    if (hNewDPB)
        LocalFree(hNewDPB);
    if (*phSaveParams) {
        LocalFree(*phSaveParams);
        *phSaveParams = NULL;
    }
    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatAllTracks() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
FormatAllTracks(
               PDISKINFO pDisketteInfo,
               WORD wStartCylinder,
               WORD wStartHead,
               LPSTR lpDiskBuffer)
{
    INT   iErrCode;
    BOOL  bRetValue = TRUE;
    WORD  wTotalCylinders;
    WORD  wSecPerTrack;
    WORD  wHeads;
    WORD  wDrive;

    LoadString(hAppInstance, IDS_FORMATTINGDEST, szMessage, 128);
    SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);

    bFormatDone = TRUE;
    wDrive = pDisketteInfo->wDrive;

    if (wDOSversion >= DOS_320) {
        pTrackLayout->SplFunctions = 5;
    } else {
        if ((pTrackLayout->BPB.bMedia == 0xF9) &&      /* high density */
            (pTrackLayout->BPB.secPerTrack == 15))     /* 1.2 Meg Drive */
            SetDASD(wDrive, 3);         /* 1.2 MB floppy in 1.2MB drive */
    }

    wTotalCylinders = pDisketteInfo->wLastCylinder + 1;
    wSecPerTrack = pDisketteInfo->wSectorsPerTrack;
    wHeads = pDisketteInfo->wHeads;

    /* Format tracks one by one, checking if the user has "Aborted"
     * after each track is formatted; DlgProgreeProc() will set the global
     * bUserAbort, if the user has aborted;
     */
    while (wStartCylinder < wTotalCylinders) {
        /* Has the user aborted? */
        if (WFQueryAbort()) {
            bRetValue = FALSE;
            break;
        }

        /* If no message is pending, go ahead and format one track */
        if ((iErrCode = GenericFormatTrack(wDrive, wStartCylinder, wStartHead, wSecPerTrack, lpDiskBuffer))) {
            /* Check if it is a fatal error */
            if (iErrCode == -1) {
                bRetValue = FALSE;
                break;
            }
        }

        if (++wStartHead >= wHeads) {
            wStartHead = 0;
            wStartCylinder++;
        }
    }

    if (wDOSversion >= DOS_320) {
        pTrackLayout->SplFunctions = 4;
    }

    return (bRetValue);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GenericReadWriteSector() -                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Checks the DOS version number; If it is >= 3.2, then IOCTL
 * calls are made to read/write; Else it calls int13 read/write.
 */

INT
APIENTRY
GenericReadWriteSector(
                      LPSTR lpBuffer,
                      WORD wFunction,
                      WORD wDrive,
                      WORD wCylinder,
                      WORD wHead,
                      WORD wCount)
{
    struct RW_PARMBLOCK  RW_ParmBlock;

    /* If the DOS version is >= 3.2, we use DOS IOCTL function calls. */
    if (wDOSversion >= DOS_320) {
        RW_ParmBlock.bSplFn = 0;
        RW_ParmBlock.wHead = wHead;
        RW_ParmBlock.wCylinder = wCylinder;
        RW_ParmBlock.wStSector = 0;
        RW_ParmBlock.wCount = wCount;
        RW_ParmBlock.lpBuffer = lpBuffer;

        return (0);
    } else
        /* Use Int13 function calls. */
        return (MyReadWriteSector(lpBuffer, wFunction, wDrive, wCylinder, wHead, wCount));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AllocDiskCopyBuffers() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
AllocDiskCopyBuffers(
                    PDISKINFO pDisketteInfo
                    )
{
    HANDLE    hMemTemp;

    ENTER("AllocDiskCopyBuffers");

    hFormatBuffer = LocalAlloc(LHND, (LONG)(2*CBSECTORSIZE));
    if (!hFormatBuffer)
        return FALSE;
    lpFormatBuffer = (LPSTR)LocalLock(hFormatBuffer);

    // We will try to reserve 16K for dialog boxes that comeup during diskcopy

    hMemTemp = LocalAlloc(LHND, (16 * 1024));
    if (!hMemTemp)
        goto Failure;

    hDosMemory = (HANDLE)NULL;

    // now, lets try to allocate a buffer for the whole disk, and
    // if that fails try smaller
    // note, standard mode will only give us 1M chuncks

    dwDisketteBufferSize = pDisketteInfo->wCylinderSize * (pDisketteInfo->wLastCylinder + 1);

    // we will try down to 8 cylinders worth, less than that means
    // there will be too much disk swapping so don't bother

    do {
        hDisketteBuffer = LocalAlloc(LHND, dwDisketteBufferSize);

        if (hDisketteBuffer) {
            hpDisketteBuffer = (LPSTR)LocalLock(hDisketteBuffer);
            break;
        } else {
            // reduce request by 4 cylinders.
            dwDisketteBufferSize -= pDisketteInfo->wCylinderSize * 4;
        }

    } while (dwDisketteBufferSize > (DWORD)(8 * pDisketteInfo->wCylinderSize));

    LocalFree(hMemTemp);         // now free this up for user

    if (hDisketteBuffer)
        return TRUE;

    // fall through here to the failure case
    Failure:

    if (lpFormatBuffer) {
        LocalUnlock(hFormatBuffer);
        LocalFree(hFormatBuffer);
    }

    if (hDosMemory)
//      +++GlobalDosFree - NO 32BIT FORM+++(hDosMemory);
        LocalFree(hDosMemory);

    LEAVE("AllocDiskCopyBuffers");
    return FALSE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FreeBuffers() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
FreeBuffers()
{
    if (lpFormatBuffer) {
        LocalUnlock(hFormatBuffer);
        LocalFree(hFormatBuffer);
    }

    if (hDosMemory)
//      +++GlobalDosFree - NO 32BIT FORM+++(hDosMemory);
        LocalFree(hDosMemory);

    if (hpDisketteBuffer) {
        LocalUnlock(hDisketteBuffer);
        LocalFree(hDisketteBuffer);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetDisketteInfo() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetDisketteInfo(
               PDISKINFO pDisketteInfo,
               PBPB pBPB
               )
{
    WORD  secPerTrack;

    secPerTrack = pBPB->secPerTrack;

    /* Fill the DisketteInfo with the info from the default BPB. */
    pDisketteInfo->wCylinderSize    = secPerTrack * pBPB->cbSec * pBPB->cHead;
    pDisketteInfo->wLastCylinder    = (pBPB->cSec / (secPerTrack * pBPB->cHead))-1;
    pDisketteInfo->wHeads           = pBPB->cHead;
    pDisketteInfo->wSectorsPerTrack = secPerTrack;
    pDisketteInfo->wSectorSize      = pBPB->cbSec;

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DCopyMessageBox() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
DCopyMessageBox(
               HWND hwnd,
               WORD idString,
               WORD wFlags
               )
{
    LoadString(hAppInstance, IDS_COPYDISK, szTitle, sizeof(szTitle));
    LoadString(hAppInstance, idString, szMessage, sizeof(szMessage));

    MessageBox(hwnd, szMessage, szTitle, wFlags);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PromptDisketteChange() -                                                */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
PromptDisketteChange(
                    HWND hwnd,
                    BOOL bWrite
                    )
{
    WORD      idString;

    if (bWrite)
        idString = IDS_INSERTDEST;
    else
        idString = IDS_INSERTSRC;

    /* These dialogs have to be sysmodal because the DiskCopy progress dialog
     * is now made a SysModal one; The following messagebox will hang if it
     * is NOT sysmodal;
     * A part of the Fix for Bug #10075 --SANKAR-- 03-05-90
     */
    DCopyMessageBox(hwnd, idString, MB_OK | MB_SYSTEMMODAL | MB_ICONINFORMATION);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWriteCylinder() -                                                   */
// BOOL             bWrite;             TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
ReadWriteCylinder(
                 BOOL bWrite,
                 WORD wCylinder,
                 PDISKINFO pDisketteInfo
                 )
{
    register INT  rc;
    WORD          wHead;
    WORD          wDrive;
    WORD          wSectorCount;
    WORD          wTrackSize;
    LPSTR         lpBuffer;

    wDrive = pDisketteInfo->wDrive;
    wSectorCount = pDisketteInfo->wSectorsPerTrack;
    wTrackSize = (wSectorCount * pDisketteInfo->wSectorSize);

    if (hDosMemory)
        lpBuffer = lpDosMemory;

    /* Perform the operation for all the heads for a given cylinder */
    for (wHead=0; wHead < pDisketteInfo->wHeads; wHead++) {
        if (!hDosMemory)
            lpBuffer = lpReadWritePtr;

        if (bWrite) {
            if (hDosMemory)
                memcpy(lpBuffer, lpReadWritePtr, wTrackSize);

            rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                        INT13_WRITE,
                                        wDrive,
                                        wCylinder,
                                        wHead,
                                        wSectorCount);
            if (rc) {
                /* Format all tracks starting from the given track */
                if (!bFormatDone) {
                    if (!FormatAllTracks(pDisketteInfo, wCylinder, wHead, lpFormatBuffer))
                        return (-1);  /* Failure */
                    rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                                INT13_WRITE,
                                                wDrive,
                                                wCylinder,
                                                wHead,
                                                wSectorCount);
                } else
                    break;
            }
        } else {
            rc = GenericReadWriteSector((LPSTR)lpBuffer,
                                        INT13_READ,
                                        wDrive,
                                        wCylinder,
                                        wHead,
                                        wSectorCount);
            if (hDosMemory)
                memcpy(lpReadWritePtr, lpBuffer, wTrackSize);

            /*** FIX30: What about the DOS 4.0 volume stuff??? ***/
        }

        if (rc)
            return (-1);

        lpReadWritePtr += wTrackSize;
    }
    return (0);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWriteMaxPossible() -                                                */
// BOOL bWrite  TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads or writes as many cylinders as possible into the hpDisketteBuffer.
 * It returns the next cylinder to be read.
 */

INT
ReadWriteMaxPossible(
                    BOOL bWrite,
                    WORD wStartCylinder,
                    PDISKINFO pDisketteInfo
                    )
{
    MSG       msg;
    WORD      wPercentDone;
    DWORD     dwBufferSize;

    dwBufferSize = dwDisketteBufferSize;

    /* We will read a cylinder only if we can read the entire cylinder. */
    while (dwBufferSize >= pDisketteInfo->wCylinderSize) {
        /* Check if any messages are pending */
        if (!PeekMessage((LPMSG)&msg, (HWND)NULL, 0, 0, PM_REMOVE)) {
            /* No message; So, go ahead with read/write */
            if (ReadWriteCylinder(bWrite, wStartCylinder, pDisketteInfo))
                return (-1);

            wStartCylinder++;
            wCompletedCylinders++;

            /* Have we read/written all the cylinders? */
            if (wStartCylinder > pDisketteInfo->wLastCylinder)
                break;

            /* Since each cylinder is counted once during read and once during
             * write, number of cylinders is multiplied by 50 and not 100.
             */
            wPercentDone = (wCompletedCylinders * 50) / (pDisketteInfo->wLastCylinder + 1);
            if (LoadString(hAppInstance, IDS_PERCENTCOMP, szTitle, 32)) {
                wsprintf(szMessage, szTitle, wPercentDone);
                SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);
            }

            dwBufferSize -= pDisketteInfo->wCylinderSize;
        } else {
            /* Check if this is a message for the ProgressDlg */
            if (!IsDialogMessage(hdlgProgress, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                /* That message might have resulted in a Abort */
                if (bUserAbort)
                    return (-1);
            }
        }
    }
    return (wStartCylinder);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ReadWrite() -                                                           */
// BOOL     bWrite TRUE for Write, FALSE for Read
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This reads or writes as many cylinders as possible into the hpDisketteBuffer.
 * It returns the next cylinder to be read.
 */

INT
ReadWrite(
         BOOL bWrite,
         WORD wStartCylinder,
         PDISKINFO pDisketteInfo
         )
{
    INT   iRetVal = 0;
    return (iRetVal);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RestoreDPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
RestoreDPB(
          INT nDisk,
          HANDLE hSavedParams
          )
{
    register PDevPB  pDevPB;

    if (!(pDevPB = (PDevPB)LocalLock(hSavedParams)))
        return (FALSE);

    pDevPB->SplFunctions = 4;
    LocalUnlock(hSavedParams);
    LocalFree(hSavedParams);
    return (TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CopyDiskette() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* NOTE: Returns positive value for success otherwise failure. */

INT
APIENTRY
CopyDiskette(
            HWND hwnd,
            WORD nSourceDisk,
            WORD nDestDisk
            )
{
    INT           rc = -1;
    register WORD wCylinder;
    WORD          wNextCylinder;
    PBPB          pIoctlBPB;      /* Source Drive's BPB (taken from DevicePB)  */
    PBPB          pBootBPB;       /* Boot Drive's BPB (taken from Boot sector) */
    PBPB          pDestBPB;
    DevPB         dpbSrceParams;
    DevPB         dpbDestParams;
    HANDLE        hTrackLayout = NULL;
    HANDLE        hSaveSrceParams;
    HANDLE        hSaveDestParams;
    FARPROC       lpfnDialog;
    DISKINFO      SourceDisketteInfo;
    DISKINFO      DestDisketteInfo;

    /* Check if it is a two drive system; put message to insert both floppies */
    if (nSourceDisk != nDestDisk) {
        bSingleDrive = FALSE;
        DCopyMessageBox(hwnd, IDS_INSERTSRCDEST, MB_OK);
    } else {
        bSingleDrive = TRUE;
        DCopyMessageBox(hwnd, IDS_INSERTSRC, MB_OK);
    }

    /* Get the BiosParameterBlock of source drive */
    if (!(pIoctlBPB = GetBPB(nSourceDisk, &dpbSrceParams)))
        return (0);

    /* Get the BiosParameterBlock of the Source Diskette */
    if (!(pBootBPB = GetBootBPB(nSourceDisk)))
        return (0);

    /* Get the BPB and DPB for the Destination drive also; */
    if (!bSingleDrive) {
        if (!(pDestBPB = GetBPB(nDestDisk, &dpbDestParams)))
            return (0);

        /* Compare BPB of source and Dest to see if they are compatible */
        if (!(CheckBPBCompatibility(pIoctlBPB, dpbSrceParams.devType, pDestBPB, dpbDestParams.devType))) {
            DCopyMessageBox(hwnd, IDS_COPYSRCDESTINCOMPAT, MB_ICONHAND | MB_OK);
            return (0);
        }
    }

    if (!ModifyDeviceParams(nSourceDisk, &dpbSrceParams, &hSaveSrceParams, pIoctlBPB, pBootBPB))
        return (0);

    if (!bSingleDrive) {
        if (!ModifyDeviceParams(nDestDisk, &dpbDestParams, &hSaveDestParams, pDestBPB, pBootBPB)) {
            RestoreDPB(nSourceDisk, hSaveSrceParams);
            return (0);
        }
    }

    GetDisketteInfo((PDISKINFO)&SourceDisketteInfo, pBootBPB);

    /* The Destination Diskette must have the same format as the source */
    DestDisketteInfo = SourceDisketteInfo;

    /* Except the drive number */
    SourceDisketteInfo.wDrive = nSourceDisk;
    DestDisketteInfo.wDrive = nDestDisk;

    /* In case we need to format the destination diskette, we need to know the
     * track layout; So, build a DPB with the required track layout;
     */
    if (wDOSversion >= DOS_320) {
        if (!(hTrackLayout = BuildDevPB(&dpbSrceParams)))
            goto Failure0;

        pTrackLayout = (PDevPB)LocalLock(hTrackLayout);

        /* The following is required to format a 360KB floppy in a 1.2MB
         * drive of NCR PC916 machine; We do formatting, if the destination
         * floppy is an unformatted one;
         * Fix for Bug #6894 --01-10-90-- SANKAR --
         */
        if (pTrackLayout->BPB.bMedia == MEDIA_360) {
            pTrackLayout->NumCyls = 40;
            pTrackLayout->bMediaType = 1;
        }
    }

    /* We wish we could do the following allocation at the begining of this
     * function, but we can not do so, because we need SourceDisketteInfo
     * and we just got it;
     */
    if (!AllocDiskCopyBuffers((PDISKINFO)&SourceDisketteInfo)) {
        DCopyMessageBox(hwnd, IDS_REASONS+DE_INSMEM, MB_ICONHAND | MB_OK);
        goto Failure0;
    }

    bUserAbort = FALSE;
    wCompletedCylinders = 0;

    hdlgProgress = CreateDialog(hAppInstance, (LPSTR)MAKEINTRESOURCE(DISKCOPYPROGRESSDLG), hwnd, ProgressDlgProc);
    if (!hdlgProgress)
        goto Failure2;

    EnableWindow(hwnd, FALSE);

    /* Start with the first cylinder. */
    wCylinder = 0;
    while (wCylinder <= SourceDisketteInfo.wLastCylinder) {
        /* If this is a single drive system, ask the user to insert
         * the source diskette.
         * Do not prompt for the first time, because the Source diskette is
         * already in the drive.
         */
        if (bSingleDrive && (wCylinder > 0))
            PromptDisketteChange(hdlgProgress, FALSE);

        /* Read in the current cylinder. */
        rc = ReadWrite(FALSE, wCylinder, (PDISKINFO)&SourceDisketteInfo);
        if (rc < 0)
            break;
        else
            wNextCylinder = (WORD)rc;

        /* If this is a single drive system, ask the user to insert
         * the destination diskette.
         */
        if (bSingleDrive)
            PromptDisketteChange(hdlgProgress, TRUE);

        /* Write out the current cylinder. */
        bFormatDone = FALSE;
        rc = ReadWrite(TRUE, wCylinder, (PDISKINFO)&DestDisketteInfo);
        if (rc < 0)
            break;

        wCylinder = wNextCylinder;
    }

    EnableWindow(hwnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    Failure2:
    FreeBuffers();
    Failure0:
    if (wDOSversion >= DOS_320) {
        /* Reset the Source drive parameters to the same as old */
        RestoreDPB(nSourceDisk, hSaveSrceParams);
        if (!bSingleDrive) {
            /* Reset the Dest drive parameters to the same as old */
            RestoreDPB(nDestDisk, hSaveDestParams);
        }
    }

    if ((wDOSversion >= DOS_320) && hTrackLayout) {
        LocalUnlock(hTrackLayout);
        LocalFree(hTrackLayout);
    }

    return (rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdisk.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDISK.C -                                                              */
/*                                                                          */
/*      Ported code from wfdisk.asm                                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"

DWORD
APIENTRY
LongShift(
         DWORD dwValue,
         WORD wCount
         )
{
    return (dwValue >> wCount);
}


VOID
APIENTRY
SetDASD(
       WORD drive,
       BYTE dasdvalue
       )
{
    // only used by diskette copy.
}


LPDBT
APIENTRY
GetDBT()
{
    return (0);  // only used by format.
}

VOID
APIENTRY
DiskReset()
{
}


INT
APIENTRY
IsHighCapacityDrive(
                   WORD iDrive
                   )
{
    return (0);  // only use for format and make system diskette.
}


WORD
APIENTRY
GetDPB(
      WORD drive,
      PDPB pDPB
      )
{
    return (0);  // used by hasSystemFiles() and IsSYSable()
}


VOID
APIENTRY
SetDPB(
      WORD drive,
      PBPB pBPB,
      PDPB pDPB
      )
{               // only used by Format()
}


INT
APIENTRY
ModifyDPB(
         WORD drive
         )
{
    return (0);  // only used by IsSYSAble()
}


INT
APIENTRY
MyInt25(
       WORD drive,
       LPSTR buffer,
       WORD count,
       WORD sector
       )
{
    return (0);          // only used for formatting and sys disk
}


INT
APIENTRY
MyReadWriteSector(
                 LPSTR lpBuffer,
                 WORD function,
                 WORD drive,
                 WORD cylinder,
                 WORD head,
                 WORD count
                 )
{
    return (0);  // only used by DiskCopy()
}


INT
APIENTRY
FormatTrackHead(
               WORD drive,
               WORD track,
               WORD head,
               WORD cSec,
               LPSTR lpTrack
               )
{
    return (0);  // only used for formatting
}


INT
APIENTRY
MyGetDriveType(
              WORD drive
              )
{
    return (0);  // only used for formatting
}


INT
APIENTRY
WriteBootSector(
               WORD srcDrive,
               WORD dstDrive,
               PBPB pBPB,
               LPSTR lpBuf
               )
{
    return (0);  // only used for formatting and syssing.
}


DWORD
APIENTRY
ReadSerialNumber(
                INT iDrive,
                LPSTR lpBuf
                )
{
    return (0);  // only used for syssing.
}


INT
APIENTRY
ModifyVolLabelInBootSec(
                       INT iDrive,
                       LPSTR lpszVolLabel,
                       DWORD lSerialNo,
                       LPSTR lpBuf
                       )
{
    return (0); // only used for syssing.
}


/*
 * Note: returned value must not be written to or freed
 */
LPSTR
GetRootPath(
           WORD wDrive
           )
{
    static CHAR rp[] = "A:\\";

    rp[0] = 'A' + wDrive;
    return (rp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdirsrc.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDIRSRC.C -                                                            */
/*                                                                          */
/*      Routines Common to the Directory and Search Windows                 */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

#define DO_DROPFILE 0x454C4946L
#define DO_PRINTFILE 0x544E5250L
#define DO_DROPONDESKTOP 0x504D42L

HWND hwndGlobalSink = NULL;

VOID SelectItem(HWND hwndLB, WPARAM wParam, BOOL bSel);
VOID ShowItemBitmaps(HWND hwndLB, BOOL bShow);
DWORD GetSearchAttribs(HWND hwndLB, WORD wIndex);

HCURSOR
APIENTRY
GetMoveCopyCursor()
{
    if (fShowSourceBitmaps)
        // copy
        return LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag | 1));
    else
        // move
        return LoadCursor(hAppInstance, MAKEINTRESOURCE(iCurDrag & 0xFFFE));
}


DWORD
GetSearchAttribs(
                HWND hwndLB,
                WORD wIndex
                )
{
    DWORD dwAttribs;
    HANDLE hDTA;
    LPDTASEARCH lpschdta;

    hDTA = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);
    lpschdta = (LPDTASEARCH)LocalLock(hDTA);
    dwAttribs = lpschdta[(INT)SendMessage(hwndLB, LB_GETITEMDATA, wIndex, 0L)].sch_dwAttrs;
    LocalUnlock(hDTA);

    return dwAttribs;
}


// match a DOS wild card spec against a dos file name
// both strings are ANSI and Upper case

BOOL
MatchFile(
         LPSTR szFile,
         LPSTR szSpec
         )
{
    ENTER("MatchFile");
    PRINT(BF_PARMTRACE, "IN:szFile=%s", szFile);
    PRINT(BF_PARMTRACE, "IN:szSpec=%s", szSpec);

#define IS_DOTEND(ch)   ((ch) == '.' || (ch) == 0)

    if (!lstrcmp(szSpec, "*") ||            // "*" matches everything
        !lstrcmp(szSpec, szStarDotStar))    // so does "*.*"
        return TRUE;

    while (*szFile && *szSpec) {

        switch (*szSpec) {
            case '?':
                szFile++;
                szSpec++;
                break;

            case '*':

                while (!IS_DOTEND(*szSpec))     // got till a terminator
                    szSpec = AnsiNext(szSpec);

                if (*szSpec == '.')
                    szSpec++;

                while (!IS_DOTEND(*szFile))     // got till a terminator
                    szFile = AnsiNext(szFile);

                if (*szFile == '.')
                    szFile++;

                break;

            default:
                if (*szSpec == *szFile) {
                    if (IsDBCSLeadByte(*szSpec)) {
                        szFile++;
                        szSpec++;
                        if (*szFile != *szSpec)
                            return FALSE;
                    }
                    szFile++;
                    szSpec++;
                } else
                    return FALSE;
        }
    }
    return !*szFile && !*szSpec;
}


VOID
APIENTRY
DSSetSelection(
              HWND hwndLB,
              BOOL bSelect,
              LPSTR szSpec,
              BOOL bSearch
              )
{
    WORD            i;
    WORD            iMac;
    HANDLE          hMem;
    LPMYDTA         lpmydta;
    CHAR            szTemp[MAXPATHLEN];

    AnsiUpper(szSpec);

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    if (bSearch)
        hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);
    else
        hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTA);

    LocalLock(hMem);

    for (i = 0; i < iMac; i++) {

        if (bSearch) {
            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szTemp);
            StripPath(szTemp);
        } else {

            SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);

            if (lpmydta->my_dwAttrs & ATTR_PARENT)
                continue;

            lstrcpy(szTemp, lpmydta->my_cFileName);
        }

        AnsiUpper(szTemp);

        if (MatchFile(szTemp, szSpec))
            SendMessage(hwndLB, LB_SETSEL, bSelect, MAKELONG(i, 0));
    }

    LocalUnlock(hMem);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ShowItemBitmaps() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
ShowItemBitmaps(
               HWND hwndLB,
               BOOL bShow
               )
{
    INT       iSel;
    RECT      rc;

    if (bShow == fShowSourceBitmaps)
        return;

    fShowSourceBitmaps = bShow;

    /* Invalidate the bitmap parts of all visible, selected items. */
    iSel = (WORD)SendMessage(hwndLB, LB_GETTOPINDEX, 0, 0L);

    while (SendMessage(hwndLB, LB_GETITEMRECT, iSel, (LPARAM)&rc) != LB_ERR) {
        /* Is this item selected? */
        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, iSel, 0L)) {
            /* Invalidate the bitmap area. */
            rc.right = rc.left + dxFolder + dyBorderx2 + dyBorder;
            InvalidateRect(hwndLB, &rc, FALSE);
        }
        iSel++;
    }
    UpdateWindow(hwndLB);
}


INT
CharCountToTab(
              LPSTR pStr
              )
{
    LPSTR pTmp = pStr;

    while (*pStr && *pStr != '\t') {
        pStr = AnsiNext(pStr);
    }

    return (INT)(pStr-pTmp);
}


// this only deals with opaque text for now

VOID
RightTabbedTextOut(
                  HDC hdc,
                  INT x,
                  INT y,
                  LPSTR pLine,
                  WORD *pTabStops,
                  INT x_offset
                  )
{
    INT len, cch;
    INT x_ext;
    INT x_initial;
    RECT rc;

    len = lstrlen(pLine);

    // setup opaquing rect (we adjust the right border as we
    // output the string)

    rc.left = x;
    rc.top  = y;
    rc.bottom = y + dyText; // global max char height

    x_initial = x;

    cch = CharCountToTab(pLine);
    MGetTextExtent(hdc, pLine, cch, &x_ext, NULL);

    // first position is left alligned so bias initial x value
    x += x_ext;

    while (len) {

        len -= cch + 1;

        rc.right = x;
        ExtTextOut(hdc, x - x_ext, y, ETO_OPAQUE, &rc, pLine, cch, NULL);

        if (len <= 0)
            return;

        rc.left = rc.right;
        pLine += cch + 1;

        cch = CharCountToTab(pLine);
        MGetTextExtent(hdc, pLine, cch, &x_ext, NULL);

        x = *pTabStops + x_offset;
        pTabStops++;
    }
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrawItem() -                                                            */
/*                                                                          */
/*--------------------------------------------------------------------------*/


VOID
APIENTRY
DrawItem(
        LPDRAWITEMSTRUCT lpLBItem,
        LPSTR szLine,
        DWORD dwAttrib,
        BOOL bHasFocus,
        WORD *pTabs
        )
{
    INT x, y;
    CHAR ch;
    LPSTR psz;
    HDC hDC;
    BOOL bDrawSelected;
    HWND hwndLB;
    INT iBitmap;

    hwndLB = lpLBItem->hwndItem;

    bDrawSelected = (lpLBItem->itemState & ODS_SELECTED);

    hDC = lpLBItem->hDC;

    if (bHasFocus && bDrawSelected) {
        SetTextColor(hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    if (lpLBItem->itemAction == ODA_FOCUS)
        goto FocusOnly;

    /* Draw the black/white background. */
    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &lpLBItem->rcItem, NULL, 0, NULL);

    x = lpLBItem->rcItem.left + 1;
    y = lpLBItem->rcItem.top + (dyFileName/2);

    if (fShowSourceBitmaps || (hwndDragging != hwndLB) || !bDrawSelected) {

        if (dwAttrib & ATTR_DIR) {
            if (dwAttrib & ATTR_PARENT) {
                iBitmap = BM_IND_DIRUP;
                szLine = szNULL;  // no date/size stuff!
            } else
                iBitmap = BM_IND_CLOSE;
        } else {

            // isolate the name so we can see what type of file this is

            psz = szLine + CharCountToTab(szLine);
            ch = *psz;
            *psz = 0;

            if (dwAttrib & (ATTR_HIDDEN | ATTR_SYSTEM))
                iBitmap = BM_IND_RO;
            else if (IsProgramFile(szLine))
                iBitmap = BM_IND_APP;
            else if (IsDocument(szLine))
                iBitmap = BM_IND_DOC;
            else
                iBitmap = BM_IND_FIL;

            *psz = ch;                           // resore the old character
        }

        BitBlt(hDC, x + dyBorder, y-(dyFolder/2), dxFolder, dyFolder, hdcMem,
               iBitmap * dxFolder, (bHasFocus && bDrawSelected) ? dyFolder : 0, SRCCOPY);
    }

    x += dxFolder + dyBorderx2;

    if ((wTextAttribs & TA_LOWERCASE) && !(dwAttrib & ATTR_LFN))
        AnsiLower(szLine);

    RightTabbedTextOut(hDC, x, y-(dyText/2), szLine, (WORD *)pTabs, x);

    if (lpLBItem->itemState & ODS_FOCUS)
        FocusOnly:
        DrawFocusRect(hDC, &lpLBItem->rcItem);    // toggles focus (XOR)


    if (bDrawSelected) {
        if (bHasFocus) {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            SetBkColor(hDC, GetSysColor(COLOR_WINDOW));
        } else {
            HBRUSH hbr;
            RECT rc;

            if (hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT))) {
                rc = lpLBItem->rcItem;
                rc.right = rc.left + (INT)SendMessage(hwndLB, LB_GETHORIZONTALEXTENT, 0, 0L);

                if (lpLBItem->itemID > 0 &&
                    (BOOL)SendMessage(hwndLB, LB_GETSEL, lpLBItem->itemID - 1, 0L))
                    rc.top -= dyBorder;

                FrameRect(hDC, &rc, hbr);
                DeleteObject(hbr);
            }
        }
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SelectItem() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
SelectItem(
          HWND hwndLB,
          WPARAM wParam,
          BOOL bSel
          )
{
    /* Add the current item to the selection. */
    SendMessage(hwndLB, LB_SETSEL, bSel, (DWORD)wParam);

    /* Give the selected item the focus rect and anchor pt. */
    SendMessage(hwndLB, LB_SETCARETINDEX, wParam, 0L);
    SendMessage(hwndLB, LB_SETANCHORINDEX, wParam, 0L);
}


//
// void  APIENTRY DSDragLoop(register HWND hwndLB, WPARAM wParam, LPDROPSTRUCT lpds, BOOL bSearch)
//
// called by for the directory and search drag loops. this must handle
// detecting all kinds of different destinations.
//
// in:
//      hwndLB  source listbox (either the dir or the sort)
//      wParam  same as sent for WM_DRAGLOOP (TRUE if we are on a dropable sink)
//      lpds    drop struct sent with the message
//      bSearch TRUE if we are in the search listbox
//

VOID
APIENTRY
DSDragLoop(
          HWND hwndLB,
          WPARAM wParam,
          LPDROPSTRUCT lpds,
          BOOL bSearch
          )
{
    BOOL          bTemp;
    BOOL          bShowBitmap;
    LPMYDTA       lpmydta;
    HWND          hwndMDIChildSink, hwndDir;


    // bShowBitmap is used to turn the source bitmaps on or off to distinguish
    // between a move and a copy or to indicate that a drop can
    // occur (exec and app)

    // hack: keep around for drop files!
    hwndGlobalSink = lpds->hwndSink;

    bShowBitmap = TRUE;   // default to copy

    if (!wParam)
        goto DragLoopCont;        // can't drop here

    // Is the user holding down the CTRL key (which forces a copy)?
    if (GetKeyState(VK_CONTROL) < 0) {
        bShowBitmap = TRUE;
        goto DragLoopCont;
    }

    // Is the user holding down the ALT or SHIFT key (which forces a move)?
    if (GetKeyState(VK_MENU)<0 || GetKeyState(VK_SHIFT)<0) {
        bShowBitmap = FALSE;
        goto DragLoopCont;
    }

    hwndMDIChildSink = GetMDIChildFromDecendant(lpds->hwndSink);

    // Are we over the source listbox? (sink and source the same)

    if (lpds->hwndSink == hwndLB) {

        // Are we over a valid listbox entry?
        if (LOWORD(lpds->dwControlData) == 0xFFFF) {
            goto DragLoopCont;
        } else {
            /* Yup, are we over a directory entry? */
            if (bSearch) {

                bTemp = (GetSearchAttribs(hwndLB, (WORD)(lpds->dwControlData)) & ATTR_DIR) != 0L;

            } else {

                SendMessage(hwndLB, LB_GETTEXT, (WORD)(lpds->dwControlData), (LPARAM)&lpmydta);

                bTemp = lpmydta->my_dwAttrs & ATTR_DIR;

            }
            if (!bTemp)
                goto DragLoopCont;
        }
    }

    /* Now we need to see if we are over an Executable file.  If so, we
     * need to force the Bitmaps to draw.
     */

    /* Are we over a directory window? */

    if (hwndMDIChildSink)
        hwndDir = HasDirWindow(hwndMDIChildSink);
    else
        hwndDir = NULL;

    if (hwndDir && (hwndDir == GetParent(lpds->hwndSink))) {

        // Are we over an occupided part of the list box?

        if (LOWORD(lpds->dwControlData) != 0xFFFF) {

            // Are we over an Executable?

            SendMessage(lpds->hwndSink, LB_GETTEXT, (WORD)(lpds->dwControlData), (LPARAM)&lpmydta);

            bTemp = IsProgramFile(lpmydta->my_cFileName);

            if (bTemp)
                goto DragLoopCont;
        }
    }

    // Are we dropping into the same drive (check the source and dest drives)

    bShowBitmap = ((INT)SendMessage(GetParent(hwndLB), FS_GETDRIVE, 0, 0L) !=
                   GetDrive(lpds->hwndSink, lpds->ptDrop));

    DragLoopCont:

    ShowItemBitmaps(hwndLB, bShowBitmap);

    // hack, set the cursor to match the move/copy state
    if (wParam)
        SetCursor(GetMoveCopyCursor());
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DSRectItem() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
DSRectItem(
          HWND hwndLB,
          INT iItem,
          BOOL bFocusOn,
          BOOL bSearch
          )
{
    RECT      rc;
    RECT      rcT;
    HDC       hDC;
    BOOL      bSel;
    WORD      wColor;
    HBRUSH    hBrush;
    LPMYDTA   lpmydta;
    CHAR      szTemp[MAXPATHLEN];

    /* Are we over an unused part of the listbox? */
    if (iItem == 0xFFFF)
        return;

    /* Are we over ourselves? (i.e. a selected item in the source listbox) */
    bSel = (BOOL)SendMessage(hwndLB, LB_GETSEL, iItem, 0L);
    if (bSel && (hwndDragging == hwndLB))
        return;

    /* We only put rectangles around directories and program items. */
    if (bSearch) {
        SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)szTemp);

        // this is bused, we must test this as attributes

        if (!(BOOL)(GetSearchAttribs(hwndLB, (WORD)iItem) & ATTR_DIR) && !IsProgramFile((LPSTR)szTemp))
            return;
    } else {
        SendMessage(hwndLB, LB_GETTEXT, iItem, (LPARAM)&lpmydta);

        if (!(lpmydta->my_dwAttrs & ATTR_DIR) &&
            !IsProgramFile(lpmydta->my_cFileName)) {
            return;
        }
    }

    /* Turn the item's rectangle on or off. */

    SendMessage(hwndLB, LB_GETITEMRECT, iItem, (LPARAM)&rc);
    GetClientRect(hwndLB,&rcT);
    IntersectRect(&rc,&rc,&rcT);

    if (bFocusOn) {
        hDC = GetDC(hwndLB);
        if (bSel) {
            wColor = COLOR_WINDOW;
            InflateRect(&rc, -1, -1);
        } else
            wColor = COLOR_WINDOWFRAME;

        if (hBrush = CreateSolidBrush(GetSysColor(wColor))) {
            FrameRect(hDC, &rc, hBrush);
            DeleteObject(hBrush);
        }
        ReleaseDC(hwndLB, hDC);
    } else {
        InvalidateRect(hwndLB, &rc, FALSE);
        UpdateWindow(hwndLB);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DropFilesOnApplication() -                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* this function will determine whether the application we are currently
 * over is a valid drop point and drop the files
 */

WORD
DropFilesOnApplication(
                      LPSTR pszFiles
                      )
{
    POINT pt;
    HWND hwnd;
    RECT rc;
    HANDLE hDrop,hT;
    LPSTR lpList;
    WORD cbList = 2;
    OFSTRUCT ofT;
    WORD cbT;
    LPDROPFILESTRUCT lpdfs;
    CHAR szFile[MAXPATHLEN];

    if (!(hwnd = hwndGlobalSink))
        return 0;

    hwndGlobalSink = NULL;

    GetCursorPos(&pt);

    cbList = 2 + sizeof (DROPFILESTRUCT);
    hDrop = GlobalAlloc(GMEM_DDESHARE|GMEM_MOVEABLE|GMEM_ZEROINIT,cbList);
    if (!hDrop)
        return 0;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);

    GetClientRect(hwnd,&rc);
    ScreenToClient(hwnd,&pt);
    lpdfs->pt = pt;
    lpdfs->fNC = !PtInRect(&rc,pt);
    lpdfs->pFiles = sizeof(DROPFILESTRUCT);

    GlobalUnlock(hDrop);

    while (pszFiles = GetNextFile(pszFiles, szFile, sizeof(szFile))) {

        MOpenFile(szFile, &ofT, OF_PARSE);

        cbT = (WORD)(lstrlen(ofT.szPathName)+1);
        hT = GlobalReAlloc(hDrop,cbList+cbT,GMEM_MOVEABLE|GMEM_ZEROINIT);
        if (!hT)
            break;
        hDrop = hT;
        lpList = GlobalLock(hDrop);
        OemToCharBuff(ofT.szPathName, lpList+cbList-2, sizeof(ofT.szPathName)/sizeof(ofT.szPathName[0]));
        GlobalUnlock(hDrop);
        cbList += cbT;
    }

    PostMessage(hwnd, WM_DROPFILES, (WPARAM)hDrop, 0L);

    return 1;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DSTrackPoint() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Return 0 for normal mouse tracking, 1 for no mouse single-click processing,
 * and 2 for no mouse single- or double-click tracking.
 */

INT
APIENTRY
DSTrackPoint(
            HWND hWnd,
            HWND hwndLB,
            WPARAM wParam,
            LPARAM lParam,
            BOOL bSearch
            )
{
    UINT       iSel;
    MSG       msg;
    RECT      rc;
    WORD      wAnchor;
    DWORD     dwTemp;
    LPSTR      pch;
    BOOL      bDir;
    BOOL      bSelected;
    BOOL      bSelectOneItem;
    BOOL      bUnselectIfNoDrag;
    CHAR      szFileName[MAXPATHLEN+1];
    INT iNoYieldCount;
    WORD wYieldFlags;
    POINT     pt;
    HANDLE hHackForHDC = NULL;    // hDC Express editor relies on this
    DRAGOBJECTDATA dodata;

    bSelectOneItem = FALSE;
    bUnselectIfNoDrag = FALSE;

    bSelected = (BOOL)SendMessage(hwndLB, LB_GETSEL, wParam, 0L);

    if (GetKeyState(VK_SHIFT) < 0) {
        /* What is the state of the Anchor point? */
        wAnchor = (WORD)SendMessage(hwndLB, LB_GETANCHORINDEX, 0, 0L);
        bSelected = (BOOL)SendMessage(hwndLB, LB_GETSEL, wAnchor, 0L);

        /* If Control is up, turn everything off. */
        if (!(GetKeyState(VK_CONTROL) < 0))
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

        /* Select everything between the Anchor point and the item. */
        SendMessage(hwndLB, LB_SELITEMRANGE, bSelected, MAKELONG(wParam, wAnchor));

        /* Give the selected item the focus rect. */
        SendMessage(hwndLB, LB_SETCARETINDEX, wParam, 0L);
    } else if (GetKeyState(VK_CONTROL) < 0) {
        if (bSelected)
            bUnselectIfNoDrag = TRUE;
        else
            SelectItem(hwndLB, wParam, TRUE);
    } else {
        if (bSelected)
            bSelectOneItem = TRUE;
        else {
            /* Deselect everything. */
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

            /* Select the current item. */
            SelectItem(hwndLB, wParam, TRUE);
        }
    }

    if (!bSearch)
        UpdateStatus(GetParent(hWnd));

    LONG2POINT(lParam, pt);
    ClientToScreen(hwndLB, (LPPOINT)&pt);
    ScreenToClient(hWnd, (LPPOINT)&pt);

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, pt.x - dxClickRect, pt.y - dyClickRect,
            pt.x + dxClickRect, pt.y + dyClickRect);

    SetCapture(hWnd);
    wYieldFlags = PM_NOYIELD | PM_REMOVE;
    iNoYieldCount = 50;
    for (;;) {
#if 0
        {
            CHAR szBuf[80];

            wsprintf(szBuf, "Message %4.4X\r\n", msg.message);
            OutputDebugString(szBuf);
        }
#endif

        if (PeekMessage(&msg, NULL, 0, 0, wYieldFlags))
            DispatchMessage(&msg);

        if (iNoYieldCount <= 0)
            wYieldFlags = PM_REMOVE;
        else
            iNoYieldCount--;

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop

        if (GetCapture() != hWnd) {
            msg.message = WM_LBUTTONUP;   // don't proceed below
            break;
        }

        if (msg.message == WM_LBUTTONUP)
            break;

        LONG2POINT(msg.lParam, pt);
        if ((msg.message == WM_MOUSEMOVE) && !(PtInRect(&rc, pt)))
            break;
    }
    ReleaseCapture();

    /* Did the guy NOT drag anything? */
    if (msg.message == WM_LBUTTONUP) {
        if (bSelectOneItem) {
            /* Deselect everything. */
            SendMessage(hwndLB, LB_SETSEL, FALSE, -1L);

            /* Select the current item. */
            SelectItem(hwndLB, wParam, TRUE);
        }

        if (bUnselectIfNoDrag)
            SelectItem(hwndLB, wParam, FALSE);

        // notify the appropriate people

        SendMessage(hWnd, WM_COMMAND,
                    GET_WM_COMMAND_MPS(0, hwndLB, LBN_SELCHANGE));

        return 1;
    }

    /* Enter Danger Mouse's BatCave. */
    if ((WORD)SendMessage(hwndLB, LB_GETSELCOUNT, 0, 0L) == 1) {
        /* There is only one thing selected.
         * Figure out which cursor to use.
         */
        if (bSearch) {
            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)szFileName);
            bDir = (BOOL)(GetSearchAttribs(hwndLB, (WORD)wParam) & ATTR_DIR);
        } else {
            LPMYDTA lpmydta;

            SendMessage(hwndLB, LB_GETTEXT, wParam, (LPARAM)&lpmydta);

            lstrcpy(szFileName, lpmydta->my_cFileName);
            bDir = lpmydta->my_dwAttrs & ATTR_DIR;

            // avoid dragging the parrent dir

            if (lpmydta->my_dwAttrs & ATTR_PARENT) {
                return 1;
            }
        }

        if (bDir) {
            iSel = DOF_DIRECTORY;
        } else if (IsProgramFile(szFileName)) {
            iSel = DOF_EXECUTABLE;
            goto HDC_HACK_FROM_HELL;
        } else if (IsDocument(szFileName)) {
            iSel = DOF_DOCUMENT;
            HDC_HACK_FROM_HELL:
            hHackForHDC = GlobalAlloc(GHND | GMEM_DDESHARE, sizeof(OFSTRUCT));
            if (hHackForHDC) {
                LPOFSTRUCT lpof;

                lpof = (LPOFSTRUCT)GlobalLock(hHackForHDC);
                QualifyPath(szFileName);
                lstrcpy(lpof->szPathName, szFileName);
                GlobalUnlock(hHackForHDC);
            }
        } else
            iSel = DOF_DOCUMENT;

        iCurDrag = SINGLECOPYCURSOR;
    } else {
        /* Multiple files are selected. */
        iSel = DOF_MULTIPLE;
        iCurDrag = MULTCOPYCURSOR;
    }


    /* Get the list of selected things. */
    pch = (LPSTR)SendMessage(hWnd, FS_GETSELECTION, FALSE, 0L);

    /* Wiggle things around. */
    hwndDragging = hwndLB;
    dodata.pch = pch;
    dodata.hMemGlobal = hHackForHDC;
    dwTemp = DragObject(GetDesktopWindow(),hWnd,(UINT)iSel,(DWORD)(ULONG_PTR)&dodata,GetMoveCopyCursor());

    if (hHackForHDC)
        GlobalFree(hHackForHDC);

    SetWindowDirectory();

    if (dwTemp == DO_PRINTFILE) {
        // print these 
        hdlgProgress = NULL;
        WFPrint(pch);
    } else if (dwTemp == DO_DROPFILE) {
        // try and drop them on an application
        DropFilesOnApplication(pch);
    }

    LocalFree((HANDLE)pch);

    if (IsWindow(hWnd))
        ShowItemBitmaps(hwndLB, TRUE);

    hwndDragging = NULL;

    if (!bSearch && IsWindow(hWnd))
        UpdateStatus(GetParent(hWnd));

    return 2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdisk.h ===
#define FF_CAPMASK  0x00FF
#define FF_SAVED    0x0100
#define FF_MAKESYS  0x0200
#define FF_QUICK    0x0400
#define FF_HIGHCAP  0x0800
#define FF_ONLYONE  0x1000

#define MS_720      0
#define MS_144      4
#define MS_288      6

#define SS48        2   // indexs into bpbList[] and cCluster[]
#define DS48        3
#define DS96        4
#define DS720KB     5
#define DS144M      6
#define DS288M      7

#define FAT_READ    1
#define FAT_WRITE   2

#define BOOTSECSIZE 512

/* FormatTrackHead() Error Codes */
#define DATAERROR       0x1000
#define ADDMARKNOTFOUND     0x0200
#define SECTORNOTFOUND      0x0400

#define IOCTL_FORMAT        0x42
#define IOCTL_SETFLAG       0x47
#define IOCTL_MEDIASSENSE   0x68
#define IOCTL_GET_DPB       0x60
#define IOCTL_SET_DPB       0x40
#define IOCTL_READ      0x61
#define IOCTL_WRITE     0x41

/* Media descriptor values for different floppy drives */
// NOTE: these are not all unique!
#define  MEDIA_160  0xFE    /* 160KB */
#define  MEDIA_320  0xFF    /* 320KB */
#define  MEDIA_180  0xFC    /* 180KB */
#define  MEDIA_360  0xFD    /* 360KB */
#define  MEDIA_1200 0xF9    /* 1.2MB */
#define  MEDIA_720  0xF9    /* 720KB */
#define  MEDIA_1440 0xF0    /* 1.44M */
#define  MEDIA_2880 0xF0    /* 2.88M */

#define  DOS_320    0x314   /* DOS version # 3.20 */

#define DRIVEID(path) ((path[0] - 'A')&31)


/* IOCTL_Functions() error codes */
#define NOERROR         0
#define SECNOTFOUND     0x1B
#define CRCERROR        0x17
#define GENERALERROR        0x1F

/*--------------------------------------------------------------------------*/
/*  BIOS Parameter Block Structure -                        */
/*--------------------------------------------------------------------------*/

typedef struct tagBPB
  {
    WORD    cbSec;      /* Bytes per sector         */
    BYTE    secPerClus;     /* Sectors per cluster      */
    WORD    cSecRes;        /* Reserved sectors         */
    BYTE    cFAT;       /* FATS             */
    WORD    cDir;       /* Root Directory Entries       */
    WORD    cSec;       /* Total number of sectors in image */
    BYTE    bMedia;     /* Media descriptor         */
    WORD    secPerFAT;      /* Sectors per FAT          */
    WORD    secPerTrack;    /* Sectors per track        */
    WORD    cHead;      /* Heads                */
    WORD    cSecHidden;     /* Hidden sectors           */
  } BPB;
typedef BPB         *PBPB;
typedef BPB FAR         *LPBPB;


/*--------------------------------------------------------------------------*/
/*  Drive Parameter Block Structure -                       */
/*--------------------------------------------------------------------------*/

typedef struct tagDPB
  {
    BYTE    drive;
    BYTE    unit;
    WORD    sector_size;
    BYTE    cluster_mask;
    BYTE    cluster_shift;
    WORD    first_FAT;
    BYTE    FAT_count;
    WORD    root_entries;
    WORD    first_sector;
    WORD    max_cluster;
    BYTE    FAT_size;
    WORD    dir_sector;
    LONG    reserved1;
    BYTE    media;
    BYTE    first_access;
    BYTE    reserved2[4];
    WORD    next_free;
    WORD    free_cnt;
    BYTE    DOS4_Extra; /*  FAT_size field is a WORD in DOS 4.X.
             * To compensate for it, we have one extra byte
             */
  } DPB;
typedef DPB         *PDPB;
typedef DPB FAR         *LPDPB;

#define MAX_SEC_PER_TRACK   40

/*--------------------------------------------------------------------------*/
/*  Device Parameter Block Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagDevPB
  {
    CHAR    SplFunctions;
    CHAR    devType;
    CHAR    reserved1[2];
    INT     NumCyls;
    CHAR    bMediaType;  /* 0=>1.2MB and 1=>360KB */
    BPB     BPB;
    CHAR    reserved3[MAX_SEC_PER_TRACK * 4 + 2];
  } DevPB, NEAR *PDevPB, FAR *LPDevPB;

#define TRACKLAYOUT_OFFSET  (7+31)  /* Offset of tracklayout
                         * in a Device Parameter Block */


/*--------------------------------------------------------------------------*/
/*  Disk Base Table Structure -                         */
/*--------------------------------------------------------------------------*/

typedef struct tagDBT
  {
    CHAR    SRHU;
    CHAR    HLDMA;
    CHAR    wait;
    CHAR    bytespersec;
    CHAR    lastsector;
    CHAR    gaplengthrw;
    CHAR    datalength;
    CHAR    gaplengthf;
    CHAR    datavalue;
    CHAR    HeadSettle;
    CHAR    MotorStart;
  } DBT;
typedef DBT         *PDBT;
typedef DBT FAR         *LPDBT;


/*--------------------------------------------------------------------------*/
/*  Directory Entry Structure -                         */
/*--------------------------------------------------------------------------*/

typedef struct tagDIRTYPE
  {
    CHAR     name[11];
    BYTE     attr;
    CHAR     pad[10];
    WORD     time;
    WORD     date;
    WORD     first;
    LONG     size;
  } DIRTYPE;
typedef DIRTYPE FAR *LPDIRTYPE;


/*--------------------------------------------------------------------------*/
/*  MS-DOS Boot Sector Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagBOOTSEC
  {
    BYTE    jump[3];        /* 3 byte jump */
    CHAR    label[8];       /* OEM name and version */
    BPB     BPB;        /* BPB */
    BYTE    bootdrive;      /* INT 13h indicator for boot device */
    BYTE    dontcare[BOOTSECSIZE-12-3-sizeof(BPB)];
    BYTE    phydrv;
    WORD    signature;
  } BOOTSEC;


/*--------------------------------------------------------------------------*/
/*  Disk Information Structure -                        */
/*--------------------------------------------------------------------------*/

typedef struct tagDISKINFO
  {
    WORD    wDrive;
    WORD    wCylinderSize;
    WORD    wLastCylinder;
    WORD    wHeads;
    WORD    wSectorsPerTrack;
    WORD    wSectorSize;
  } DISKINFO;
typedef DISKINFO     *PDISKINFO;
typedef DISKINFO FAR *LPDISKINFO;


/*--------------------------------------------------------------------------*/
/*  DOS Disk Transfer Area Structure -                      */
/*--------------------------------------------------------------------------*/

typedef struct tagDOSDTA
  {
    BYTE        Reserved[21];           /* 21 */
    BYTE        Attrib;             /* 22 */
    WORD        Time;               /* 24 */
    WORD        Date;               /* 26 */
    DWORD       Length;             /* 30 */
    CHAR        szName[MAXDOSFILENAMELEN];      /* 43 */
    CHAR        dummy[1];               /* 44 */
// we do WORD move of 22 words so pad this out by 1 byte
  } DOSDTA;
typedef DOSDTA       *PDOSDTA;
typedef DOSDTA   FAR *LPDOSDTA;


// this is the structure used to store file information in the
// directory window.  these are variable length blocks.  the
// first entry is a dummy that holds the number of entries in
// the whole block in the Length field.  use the wSize field
// to give you a pointer to the next block

typedef struct tagMYDTA
  {
    WORD        wSize;          // size of this structure (cFileName is variable)
    SHORT       iBitmap;
    INT         nIndex;

    DWORD       my_dwAttrs;     // must match WIN32_FIND_DATA from here down!
    FILETIME    my_ftCreationTime;
    FILETIME    my_ftLastAccessTime;
    FILETIME    my_ftLastWriteTime;
    DWORD       my_nFileSizeHigh;
    DWORD       my_nFileSizeLow;
    CHAR        my_cFileName[];
  } MYDTA;
typedef MYDTA     *PMYDTA;
typedef MYDTA FAR *LPMYDTA;

#define IMPORTANT_DTA_SIZE \
    (sizeof(MYDTA) - \
    sizeof(INT) - \
    sizeof(WORD) - \
    sizeof(SHORT))

#define GETDTAPTR(lpStart, offset)  ((LPMYDTA)((LPSTR)lpStart + offset))

// stuff used by the search window

typedef struct tagDTASEARCH {
    DWORD       sch_dwAttrs;    // must match WIN32_FIND_DATA
    FILETIME    sch_ftCreationTime;
    FILETIME    sch_ftLastAccessTime;
    FILETIME    sch_ftLastWriteTime;
    DWORD       sch_nFileSizeHigh;
    DWORD       sch_nFileSizeLow;
} DTASEARCH, FAR *LPDTASEARCH;


/*--------------------------------------------------------------------------*/
/*  DOS Extended File Control Block Structure -                 */
/*--------------------------------------------------------------------------*/

typedef struct tagEFCB
  {
    BYTE        Flag;
    BYTE        Reserve1[5];
    BYTE        Attrib;
    BYTE        Drive;
    BYTE        Filename[11];
    BYTE        Reserve2[5];
    BYTE        NewName[11];
    BYTE        Reserve3[9];
  } EFCB;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdlgs.h ===
#define RUNDLG		    10
#define MYPRINTDLG	    11
#define ASSOCIATEDLG	    12
#define SEARCHDLG	    13
#define MOVECOPYDLG	    14
#define DELETEDLG	    15
#define ATTRIBSDLG	    16
#define MAKEDIRDLG	    17
#define EXITDLG 	    18
#define CHOOSEDRIVEDLG	    19
#define DISKCOPYDLG	    20
#define DISKCOPY2DLG	    21
#define DISKCOPYPROGRESSDLG 22
#define DISKLABELDLG	    23
#define FORMATDLG	    24
#define FORMAT2DLG	    25
#define FORMATPROGRESSDLG   26
#define SYSDISKPROGRESSDLG  27
#define CONNECTDLG	    28
#define PREVIOUSDLG	    29
#define OTHERDLG	    30
#define SORTBYDLG	    31
#define INCLUDEDLG	    32
#define CONFIRMDLG	    33
#define DMSTATUSDLG	    35
#define PRTDLG		    36
#define CHOOSENETDRIVEDLG   37
#define MULTIPLEATTRIBSDLG	38
#define CONFIRMREPLACE		39
#define CONFIRMDELETE		40
#define CONFIRMRMDIR		41
#define CONFIRMMOVE		42
#define CONFIRMRENAME		43
#define SELECTDLG		44
#define DRIVEDLG		45
#define LFNTOFATDLG		46
#define CHOOSESYSDRIVEDLG       47
#define FONTDLG		        145

#define IDD_TEXT	    100
#define IDD_DIR 	    101
#define IDD_FROM	    102
#define IDD_TO		    103
#define IDD_STATUS	    104
#define IDD_DATE1	    105
#define IDD_DATE2	    106
#define IDD_YESALL	    107
#define IDD_TOSTATUS	    108
#define IDD_TONAME	    109


#define IDD_NAME	    201
#define IDD_TYPE	    202
#define IDD_SIZE	    203
#define IDD_DATE	    204
#define IDD_TIME	    205
#define IDD_FLAGS	    206

#define IDD_UPPERCASE	    207
#define IDD_SETDEFAULT	    208
#define IDD_ASSOC	    209
#define IDD_PROGRAMS	    210
#define IDD_DOCS	    211
#define IDD_OTHER	    212
#define IDD_FOUND	    213
#define IDD_LOAD	    214
#define IDD_READONLY	    215
#define IDD_HIDDEN	    216
#define IDD_ARCHIVE	    217
#define IDD_SYSTEM	    218
#define IDD_DELETE	    219
#define IDD_SUBDEL	    220
#define IDD_REPLACE	    221
#define IDD_DRIVE	    222
#define IDD_PATH	    223
#define IDD_PASSWORD	    224
#define IDD_ADDPREV	    225
#define IDD_PREV	    226
#define IDD_NETBROWSE	    227
#define IDD_SERVERS	    228
#define IDD_SHARES	    229
#define IDD_EXT 	    230
#define IDD_SAVESETTINGS    231
#define IDD_SEARCHALL	    232
#define IDD_HIGHCAP	    241
#define IDD_MAKESYS	    242
#define IDD_PROGRESS	    243
#define IDD_VERIFY	    244
#define IDD_DRIVE1	    245
#define IDD_DRIVE2	    246
#define IDD_DRIVE3	    247
#define IDD_DRIVE4	    248
#define IDD_MOUSE	    249
#define IDD_SHOWHIDDEN	    250
#define IDD_CONFIG	    251
#define IDD_CLOSE	    252
#define IDD_PERM	    253
#define IDD_HELP	    254
#define IDD_DISCONNECT	    255
#define IDD_COPYTOCLIP	    256
#define IDD_COPYTOFILE      257

#define IDD_CLASSLIST	   111
#define IDD_EXTENSION	   112
#define IDD_PROGRAMNAME    113

#define IDD_ASSOCFIRST	   100
#define IDD_ASSOCLAST	   110

#define IDD_NETWORKFIRST   500
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdlgs.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS.C -                                                              */
/*                                                                          */
/*      Windows File System Dialog procedures                               */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"
#include "commdlg.h"
#include "dlgs.h"

typedef BOOL (APIENTRY *LPFNFONTPROC)(HWND, UINT, DWORD, LONG);

VOID
APIENTRY
SaveWindows(
            HWND hwndMain
            )
{
    CHAR szPath[MAXPATHLEN];
    CHAR buf2[MAXPATHLEN + 6*12];
    CHAR key[10];
    INT dir_num;
    UINT sw;
    HWND hwnd;
    BOOL bCounting;
    POINT ptIcon;
    RECT rcWindow;
    LONG view, sort, attribs;

    // save main window position

    sw = GetInternalWindowPos(hwndMain, &rcWindow, &ptIcon);

    wsprintf(buf2, "%d,%d,%d,%d, , ,%d", rcWindow.left, rcWindow.top,
             rcWindow.right - rcWindow.left, rcWindow.bottom - rcWindow.top, sw);

    WritePrivateProfileString(szSettings, szWindow, buf2, szTheINIFile);

    // write out dir window strings in reverse order
    // so that when we read them back in we get the same Z order

    bCounting = TRUE;
    dir_num = 0;

    DO_AGAIN:

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {
        HWND ht = HasTreeWindow(hwnd);
        INT nReadLevel = ht? GetWindowLong(ht, GWL_READLEVEL) : 0;

        // don't save MDI icon title windows or search windows,
        // or any dir window which is currently recursing

        if ((GetWindow(hwnd, GW_OWNER) == NULL) &&
            GetWindowLong(hwnd, GWL_TYPE) != TYPE_SEARCH)
        //nReadLevel == 0)
        {
            if (bCounting) {
                dir_num++;
                continue;
            }

            sw = GetInternalWindowPos(hwnd, &rcWindow, &ptIcon);
            view = GetWindowLong(hwnd, GWL_VIEW);
            sort = GetWindowLong(hwnd, GWL_SORT);
            attribs = GetWindowLong(hwnd, GWL_ATTRIBS);

            GetMDIWindowText(hwnd, szPath, sizeof(szPath));

            wsprintf(key, szDirKeyFormat, dir_num--);

            // format:
            //   x_win, y_win,
            //   x_win, y_win,
            //   x_icon, y_icon,
            //   show_window, view, sort, attribs, split, directory

            wsprintf(buf2, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%s",
                     rcWindow.left, rcWindow.top,
                     rcWindow.right, rcWindow.bottom,
                     ptIcon.x, ptIcon.y,
                     sw, view, sort, attribs,
                     GetSplit(hwnd),
                     (LPSTR)szPath);

            // the dir is an ANSI string (?)

            WritePrivateProfileString(szSettings, key, buf2, szTheINIFile);
        }
    }

    if (bCounting) {
        bCounting = FALSE;

        // erase the last dir window so that if they save with
        // fewer dirs open we don't pull in old open windows

        wsprintf(key, szDirKeyFormat, dir_num + 1);
        WritePrivateProfileString(szSettings, key, NULL, szTheINIFile);

        goto DO_AGAIN;
    }
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  OtherDlgProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
OtherDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LONG          wView;
    register HWND hwndActive;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    switch (wMsg) {
        case WM_INITDIALOG:

            wView = GetWindowLong(hwndActive, GWL_VIEW);
            CheckDlgButton(hDlg, IDD_SIZE,  wView & VIEW_SIZE);
            CheckDlgButton(hDlg, IDD_DATE,  wView & VIEW_DATE);
            CheckDlgButton(hDlg, IDD_TIME,  wView & VIEW_TIME);
            CheckDlgButton(hDlg, IDD_FLAGS, wView & VIEW_FLAGS);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    {
                        HWND hwnd;

                        wView = GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES;

                        if (IsDlgButtonChecked(hDlg, IDD_SIZE))
                            wView |= VIEW_SIZE;
                        if (IsDlgButtonChecked(hDlg, IDD_DATE))
                            wView |= VIEW_DATE;
                        if (IsDlgButtonChecked(hDlg, IDD_TIME))
                            wView |= VIEW_TIME;
                        if (IsDlgButtonChecked(hDlg, IDD_FLAGS))
                            wView |= VIEW_FLAGS;

                        EndDialog(hDlg, TRUE);

                        if (hwnd = HasDirWindow(hwndActive))
                            SendMessage(hwnd, FS_CHANGEDISPLAY, CD_VIEW, (DWORD)wView);
                        else if (hwndActive == hwndSearch) {
                            SetWindowLong(hwndActive, GWL_VIEW, wView);
                            InvalidateRect(hwndActive, NULL, TRUE);
                        }

                        break;
                    }

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IncludeDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
IncludeDlgProc(
               HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    DWORD dwAttribs;
    HWND hwndActive;
    CHAR szTemp[MAXPATHLEN];
    CHAR szInclude[MAXFILENAMELEN];
    HWND hwndDir;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    switch (wMsg) {
        case WM_INITDIALOG:

            SendMessage(hwndActive, FS_GETFILESPEC, sizeof(szTemp), (LPARAM)szTemp);
            SetDlgItemText(hDlg, IDD_NAME, szTemp);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, MAXFILENAMELEN-1, 0L);

            dwAttribs = (DWORD)GetWindowLong(hwndActive, GWL_ATTRIBS);

            CheckDlgButton(hDlg, IDD_DIR,        dwAttribs & ATTR_DIR);
            CheckDlgButton(hDlg, IDD_PROGRAMS,   dwAttribs & ATTR_PROGRAMS);
            CheckDlgButton(hDlg, IDD_DOCS,       dwAttribs & ATTR_DOCS);
            CheckDlgButton(hDlg, IDD_OTHER,      dwAttribs & ATTR_OTHER);
            CheckDlgButton(hDlg, IDD_SHOWHIDDEN, dwAttribs & ATTR_HIDDEN);

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_NAME, szInclude, sizeof(szInclude));

                    if (szInclude[0] == 0L)
                        lstrcpy(szInclude, szStarDotStar);

                    dwAttribs = 0;
                    if (IsDlgButtonChecked(hDlg, IDD_DIR))
                        dwAttribs |= ATTR_DIR;
                    if (IsDlgButtonChecked(hDlg, IDD_PROGRAMS))
                        dwAttribs |= ATTR_PROGRAMS;
                    if (IsDlgButtonChecked(hDlg, IDD_DOCS))
                        dwAttribs |= ATTR_DOCS;
                    if (IsDlgButtonChecked(hDlg, IDD_OTHER))
                        dwAttribs |= ATTR_OTHER;
                    if (IsDlgButtonChecked(hDlg, IDD_SHOWHIDDEN))
                        dwAttribs |= ATTR_HS;

                    if (!dwAttribs)
                        dwAttribs = ATTR_EVERYTHING;

                    EndDialog(hDlg, TRUE);        // here to avoid exces repaints

                    // we need to update the tree if they changed the system/hidden
                    // flags.  major bummer...  FIX31

                    if (hwndDir = HasDirWindow(hwndActive)) {
                        SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);
                        lstrcat(szTemp, szInclude);
                        SetWindowText(hwndActive, szTemp);
                        SetWindowLong(hwndActive, GWL_ATTRIBS, dwAttribs);
                        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH, 0L);
                    }

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


INT_PTR
APIENTRY
SelectDlgProc(
              HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam)
{
    HWND hwndActive, hwnd;
    CHAR szList[128];
    CHAR szSpec[MAXFILENAMELEN];
    LPSTR p;

    switch (wMsg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szList)-1, 0L);
            SetDlgItemText(hDlg, IDD_NAME, szStarDotStar);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:      // select
                case IDYES:     // unselect

                    // change "Cancel" to "Close"

                    LoadString(hAppInstance, IDS_CLOSE, szSpec, sizeof(szSpec));
                    SetDlgItemText(hDlg, IDCANCEL, szSpec);

                    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

                    if (!hwndActive)
                        break;

                    GetDlgItemText(hDlg, IDD_NAME, szList, sizeof(szList));

                    if (hwndActive == hwndSearch)
                        hwnd = hwndSearch;
                    else
                        hwnd = HasDirWindow(hwndActive);

                    if (hwnd) {

                        p = szList;

                        while (p = GetNextFile(p, szSpec, sizeof(szSpec)))
                            SendMessage(hwnd, FS_SETSELECTION, (BOOL)(GET_WM_COMMAND_ID(wParam, lParam) == IDOK), (LPARAM)szSpec);
                    }

                    UpdateStatus(hwndActive);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


UINT_PTR
FontHookProc(
             HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, chx3, wTextAttribs & TA_LOWERCASE);
            break;

        case WM_COMMAND:
            switch (wParam) {
                case pshHelp:
                    SendMessage(hwndFrame, wHelpMessage, 0, 0L);
                    break;

                case IDOK:
                    if (IsDlgButtonChecked(hDlg, chx3))
                        wTextAttribs |= TA_LOWERCASE;
                    else
                        wTextAttribs &= ~TA_LOWERCASE;
                    break;
            }
    }
    return FALSE;
}

#define abs(x) ((x < 0) ? -x : x)

VOID
APIENTRY
NewFont()
{
    HFONT hOldFont;
    HANDLE hOld;
    HWND hwnd, hwndT;
    HDC hdc;
    RECT rc;
    LOGFONT lf;
    CHOOSEFONT cf;
    CHAR szBuf[10];
    INT res;
    WORD iOld,iNew;

#define MAX_PT_SIZE 36

    GetObject(hFont, sizeof(lf), (LPSTR)(LPLOGFONT)&lf);
    iOld = (WORD)abs(lf.lfHeight);

    cf.lStructSize    = sizeof(cf);
    cf.hwndOwner      = hwndFrame;
    cf.lpLogFont      = &lf;
    cf.hInstance      = hAppInstance;
    cf.lpTemplateName = MAKEINTRESOURCE(FONTDLG);
    cf.lpfnHook       = FontHookProc;
    cf.nSizeMin       = 4;
    cf.nSizeMax       = 36;
    cf.Flags          = CF_SCREENFONTS | CF_ANSIONLY | CF_SHOWHELP |
                        CF_ENABLEHOOK | CF_ENABLETEMPLATE |
                        CF_INITTOLOGFONTSTRUCT | CF_LIMITSIZE;

    res = ChooseFont(&cf);

    if (!res)
        return;

    wsprintf(szBuf, "%d", cf.iPointSize / 10);
    iNew = (WORD)abs(lf.lfHeight);

    // Set wTextAttribs BOLD and ITALIC flags

    if (lf.lfWeight == 700)
        wTextAttribs |= TA_BOLD;
    else
        wTextAttribs &= ~TA_BOLD;
    if (lf.lfItalic != 0)
        wTextAttribs |= TA_ITALIC;
    else
        wTextAttribs &= ~TA_ITALIC;

    WritePrivateProfileString(szSettings, szFace, lf.lfFaceName, szTheINIFile);
    WritePrivateProfileString(szSettings, szSize, szBuf, szTheINIFile);
    WritePrivateProfileBool(szLowerCase, wTextAttribs);

    hOldFont = hFont;

    hFont = CreateFontIndirect(&lf);

    if (!hFont) {
        DeleteObject(hOldFont);
        return;
    }

    // recalc all the metrics for the new font

    hdc = GetDC(NULL);
    hOld = SelectObject(hdc, hFont);
    GetTextStuff(hdc);
    if (hOld)
        SelectObject(hdc, hOld);
    ReleaseDC(NULL, hdc);

    // now update all listboxes that are using the old
    // font with the new font

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd;
        hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        if (GetWindow(hwnd, GW_OWNER))
            continue;

        if ((INT)GetWindowLong(hwnd, GWL_TYPE) == TYPE_SEARCH) {
            SendMessage((HWND)GetDlgItem(hwnd, IDCW_LISTBOX), WM_SETFONT, (WPARAM)hFont, 0L);
            SendMessage((HWND)GetDlgItem(hwnd, IDCW_LISTBOX), LB_SETITEMHEIGHT, 0, (LONG)dyFileName);
            // we should really update the case of the search
            // window here.  but this is a rare case...
        } else {

            // resize the drives, tree, dir

            if (hwndT = HasDrivesWindow(hwnd)) {
                GetClientRect(hwnd, &rc);
                SendMessage(hwnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
            }

            if (hwndT = HasDirWindow(hwnd))
                SetLBFont(hwndT, GetDlgItem(hwndT, IDCW_LISTBOX), hFont);

            if (hwndT = HasTreeWindow(hwnd)) {

                // the tree list box

                hwndT = GetDlgItem(hwndT, IDCW_TREELISTBOX);

                /*
                    Kludge alert: xTreeMax is a single var representing the width of
                    all tree windows.  It always grows, never shrinks (like the budget
                    deficit).
                */
                xTreeMax = (WORD)((xTreeMax * iNew) / iOld);
                SendMessage(hwndT, LB_SETHORIZONTALEXTENT, xTreeMax, 0L);
                SendMessage(hwndT, WM_SETFONT, (WPARAM)hFont, 0L);
                SendMessage(hwndT, LB_SETITEMHEIGHT, 0, (LONG)dyFileName);
            }
        }

        // now repaint after all the font changes
        InvalidateRect(hwnd, NULL, TRUE);
    }
    DeleteObject(hOldFont); // done with this now, delete it
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConfirmDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ConfirmDlgProc(
               HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    switch (wMsg) {
        case WM_INITDIALOG:
            CheckDlgButton(hDlg, IDD_DELETE,  bConfirmDelete);
            CheckDlgButton(hDlg, IDD_SUBDEL,  bConfirmSubDel);
            CheckDlgButton(hDlg, IDD_REPLACE, bConfirmReplace);
            CheckDlgButton(hDlg, IDD_MOUSE,   bConfirmMouse);
            CheckDlgButton(hDlg, IDD_CONFIG,  bConfirmFormat);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    bConfirmDelete  = IsDlgButtonChecked(hDlg, IDD_DELETE);
                    bConfirmSubDel  = IsDlgButtonChecked(hDlg, IDD_SUBDEL);
                    bConfirmReplace = IsDlgButtonChecked(hDlg, IDD_REPLACE);
                    bConfirmMouse   = IsDlgButtonChecked(hDlg, IDD_MOUSE);
                    bConfirmFormat  = IsDlgButtonChecked(hDlg, IDD_CONFIG);

                    WritePrivateProfileBool(szConfirmDelete,  bConfirmDelete);
                    WritePrivateProfileBool(szConfirmSubDel,  bConfirmSubDel);
                    WritePrivateProfileBool(szConfirmReplace, bConfirmReplace);
                    WritePrivateProfileBool(szConfirmMouse,   bConfirmMouse);
                    WritePrivateProfileBool(szConfirmFormat,  bConfirmFormat);

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdos.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDOS.C -                                                               */
/*                                                                          */
/*      Ported code from wfdos.asm                                          */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"

DWORD
APIENTRY
GetExtendedError()
{
    return (GetLastError());     // temp fix, called by IsDiskReallyThere().
}


VOID
APIENTRY
DosGetDTAAddress()
{
}


VOID
APIENTRY
DosResetDTAAddress()
{
}


DWORD
APIENTRY
GetFreeDiskSpace(
                WORD wDrive
                )
{
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwTotalClusters;

    if (GetDiskFreeSpace(GetRootPath(wDrive),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters)) {
        return (dwFreeClusters * dwSectorsPerCluster * dwBytesPerSector);
    } else {
        return (0);
    }
}


DWORD
APIENTRY
GetTotalDiskSpace(
                 WORD wDrive
                 )
{
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwTotalClusters;

    if (GetDiskFreeSpace(GetRootPath(wDrive),
                         &dwSectorsPerCluster,
                         &dwBytesPerSector,
                         &dwFreeClusters,
                         &dwTotalClusters)) {
        return (dwTotalClusters * dwSectorsPerCluster * dwBytesPerSector);
    } else {
        return (0);
    }
}


INT
APIENTRY
ChangeVolumeLabel(
                 INT nDrive,
                 LPSTR lpNewVolName
                 )
{
    UNREFERENCED_PARAMETER(nDrive);
    UNREFERENCED_PARAMETER(lpNewVolName);
    return (0);

}



INT
APIENTRY
GetVolumeLabel(
              INT nDrive,
              LPSTR lpszVol,
              BOOL bBrackets
              )
{
    *lpszVol = 0;

    if (apVolInfo[nDrive] == NULL)
        FillVolumeInfo(nDrive);

    if (apVolInfo[nDrive]) {

        if ((BOOL)*apVolInfo[nDrive]->szVolumeName)
            lstrcpy(&lpszVol[bBrackets ? 1 : 0],
                    apVolInfo[nDrive]->szVolumeName);
        else
            return (0);

    } else {
        return (0);
    }

    if (bBrackets) {
        lpszVol[0] = '[';
        lstrcat(lpszVol, "]");
    }
    return (1);
}


INT
APIENTRY
DeleteVolumeLabel(
                 INT nDrive
                 )
{
    UNREFERENCED_PARAMETER(nDrive);
    return (0);
}


HFILE
APIENTRY
CreateVolumeFile(
                LPSTR lpFileName
                )
{
    UNREFERENCED_PARAMETER(lpFileName);
    return (0);
}



VOID
APIENTRY
FillVolumeInfo(
              INT iVol
              )
{
    VOLINFO vi;

    vi.dwDriveType = rgiDriveType[iVol];

    if (GetVolumeInformation(
                            GetRootPath((WORD)iVol),
                            &vi.szVolumeName[0], MAX_VOLNAME,
                            &vi.dwVolumeSerialNumber,
                            &vi.dwMaximumComponentLength,
                            &vi.dwFileSystemFlags,
                            &vi.szFileSysName[0], MAX_FILESYSNAME)) {;

        if (apVolInfo[iVol] == NULL)
            apVolInfo[iVol] = LocalAlloc(LPTR, sizeof(VOLINFO));
        
        if (apVolInfo[iVol])
            *apVolInfo[iVol] = vi;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdlgs2.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS2.C -                                                             */
/*                                                                          */
/*      More Windows File System Dialog procedures                          */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "commdlg.h"

CHAR szShellOpenCommand[] = "\\shell\\open\\command";

VOID CheckAttribsDlgButton(HWND hDlg, INT id, DWORD dwAttribs, DWORD dwAttribs3State, DWORD dwAttribsOn);


// Return pointers to various bits of a path.
// ie where the dir name starts, where the filename starts and where the
// params are.
VOID
GetPathInfo(
           LPSTR szTemp,
           LPSTR *ppDir,
           LPSTR *ppFile,
           LPSTR *ppPar
           )
{
    /* strip leading spaces
     */
    for (*ppDir = szTemp; **ppDir == ' '; (*ppDir)++)
        ;

    /* locate the parameters
     */
    for (*ppPar = *ppDir; **ppPar && **ppPar != ' '; (*ppPar)++)
        ;

    /* locate the start of the filename and the extension.
     */
    for (*ppFile = *ppPar; *ppFile > *ppDir; --(*ppFile)) {
        if (((*ppFile)[-1] == ':') || ((*ppFile)[-1] == '\\'))
            break;
    }
}

VOID
ValidateExtension(
                 HWND hDlg
                 )
{
    CHAR szTemp[10];
    INT count;

    count = GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, sizeof(szTemp));
    EnableWindow(GetDlgItem(hDlg, IDD_SEARCHALL), count);
    EnableWindow(GetDlgItem(hDlg, IDOK), count);
    SendMessage(hDlg, DM_SETDEFID, count ? IDOK : IDCANCEL, 0L);
}

// since LoadString() only reads up to a null we have to mark
// special characters where we want nulls then convert them
// after loading.

VOID
FixupNulls(
          LPSTR p
          )
{
    LPSTR pT;

    while (*p) {
        if (*p == '#') {
            pT = p;
            p = AnsiNext(p);
            *pT = TEXT('\0');
        } else
            p = AnsiNext(p);
    }
}

// Find the key associated with the given value.
BOOL
ValidFileTypeValue(
                  LPSTR szVal,
                  LPSTR szKey,
                  WORD cbMaxKey
                  )
{
    HKEY hk = NULL;
    WORD wTmp;
    LONG lTmp;
    BOOL retval = FALSE;
    CHAR szValTmp[128];

    if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) != ERROR_SUCCESS)
        return(FALSE);

    for (wTmp = 0;
        RegEnumKey(hk, wTmp, szKey, cbMaxKey) == ERROR_SUCCESS;
        wTmp++) {
        // Skip things that aren't file type things.
        if (szKey[0] == '.')
            continue;

        lTmp = 128;
        if (RegQueryValue(hk, szKey, szValTmp, &lTmp) != ERROR_SUCCESS) {
            continue;
        }

        if (!szValTmp[0])
            continue;

        if (!lstrcmp(szValTmp, szVal)) {
#ifdef VERBDEBUG
            OutputDebugString("wf.vftv: Found a match\n\r");
#endif
            //  Found a match.
            retval = TRUE;
            goto ProcExit;
        }

    }
    szKey[0] = TEXT('\0');
    ProcExit:
    RegCloseKey(hk);
    return retval;
}

// Sets the selection of a listbox to that matching the given string.
VOID
SetLBSelection(
              HWND hDlg,
              INT nDlgItem,
              LPSTR sz
              )
{
    INT iMatch;

    iMatch = (INT) SendDlgItemMessage(hDlg, nDlgItem, LB_SELECTSTRING, -1, (LPARAM) sz);
    if (iMatch == LB_ERR) {
#ifdef VERBDEBUG
        OutputDebugString("wf.sdft: Selection missing from list box.\n\r");
#endif
        return;
    }

    return;
}

// Given an extension (with or without a dot) set the list box or the
// programname fields properly.
VOID
UpdateSelectionOrName(
                     HWND hDlg
                     )
{
    CHAR szExt[128];
    CHAR szTemp[128];
    LONG cbTemp;
    LPSTR p;

    // Get the current extension (after the dot).
    GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, sizeof(szTemp));

    // Make sure it has a dot.
    if (szTemp[0] != '.') {
        // Add one.
        szExt[0] = '.';
        lstrcpy(szExt+1, szTemp);
    } else {
        // It's already got one.
        lstrcpy(szExt, szTemp);
    }

    cbTemp = sizeof(szTemp);
    if (RegQueryValue(HKEY_CLASSES_ROOT,szExt,
                      szMessage,&cbTemp) == ERROR_SUCCESS) {
        if (*szMessage) {
            // it's associated with a class
#ifdef VERBDEBUG
            OutputDebugString("wf.uson: ");
            OutputDebugString(szTemp);
            OutputDebugString(" associated with class (");
            OutputDebugString(szMessage);
            OutputDebugString(")\n\r");
#endif
            szTemp[0] = TEXT('\0');
            cbTemp = sizeof(szTemp);
            RegQueryValue(HKEY_CLASSES_ROOT,szMessage,szTemp,&cbTemp);
#ifdef VERBDEBUG
            OutputDebugString("wf.uson: Associated with value (");
            OutputDebugString(szTemp);
            OutputDebugString(")\n\r");
#endif
            // Set the list box selection to the right type.
            SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
            // Put the type name in the program name field.
            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
        } else {
            // it's not associated with a class, see if it has a
            // shell open command and treat it as a command association
            lstrcat(szExt,szShellOpenCommand);
            cbTemp = sizeof(szTemp);
            if (RegQueryValue(HKEY_CLASSES_ROOT, szExt, szTemp, &cbTemp) == ERROR_SUCCESS
                && szTemp[0]) {
#ifdef VERBDEBUG
                OutputDebugString("wf.uson: It has a shell open command.\n\r");
#endif
                goto ProgramAssoc;
            } else {
                // Put "none" in the field.
#ifdef VERBDEBUG
                OutputDebugString("wf.uson: Class set to nothing.\n\r");
#endif
                LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                SetDlgItemText(hDlg,IDD_PROGRAMNAME, szTemp);
                SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
                goto NoAssoc;
            }
        }
    } else if (GetProfileString(szExtensions, szExt+1, szNULL, szTemp, sizeof(szTemp))) {
        ProgramAssoc:
        /* Remove the "^." bulloney. */
        p = szTemp;
        while ((*p) && (*p != '^') && (*p != '%'))
            p = AnsiNext(p);
        *p = TEXT('\0');

        p--;
        if (*p == ' ')
            *p = 0;
        SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
        // Set clear the selection.
        SendDlgItemMessage(hDlg, IDD_CLASSLIST, LB_SETCURSEL, -1, 0L);
    } else {
        // Nothing.
#ifdef VERBDEBUG
        OutputDebugString("wf.uson: No association.\n\r");
#endif
        LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
        SetDlgItemText(hDlg,IDD_PROGRAMNAME, szTemp);
        SetLBSelection(hDlg, IDD_CLASSLIST, szTemp);
    }

    NoAssoc:
    SendDlgItemMessage(hDlg, IDD_PROGRAMNAME, EM_LIMITTEXT, sizeof(szTemp) - 1, 0L);
}


// Given a class key returns the shell\open\command string in szValue
// and the number of chars copied in cbMaxValue. cbMaxValue should
// be initialised to the max siz eof szValue.
VOID
GetAssociatedExe(
                LPSTR szKey,
                LPSTR szValue,
                LONG *plcbValue
                )
{
    CHAR szTemp[1289] = {0};
    LONG i;

    strncpy(szTemp, szKey, sizeof(szTemp)-1);
    strncat(szTemp, szShellOpenCommand, sizeof(szTemp)-strlen(szTemp)-1);
#ifdef VERBDEBUG
    OutputDebugString("wf.gae: Key Query ");
    OutputDebugString(szTemp);
    OutputDebugString("\n\r");
#endif


    RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szValue, plcbValue);
    // Strip any params.
    for (i=0; szValue[i] != TEXT('\0'); i++) {
        if (szValue[i] == ' ') {
            szValue[i] = TEXT('\0');
            break;
        }
    }}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AssociateDlgProc() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
AssociateDlgProc(
                register HWND hDlg,
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    CHAR szTemp[128];
    CHAR szTemp2[128];
    HKEY hk = NULL;

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPSTR  p;
                register LPSTR pSave;
                INT iItem;
                CHAR szTemp3[128];
                CHAR szTemp4[128];
                LONG lcbTemp;

                SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_RESETCONTENT,0,0L);

                if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) == ERROR_SUCCESS) {
                    for (wParam = 0;
                        RegEnumKey(hk, (DWORD)wParam, szTemp, sizeof(szTemp)) == ERROR_SUCCESS;
                        wParam++) {

                        // Skip things that aren't file type things.
                        if (szTemp[0] == '.')
                            continue;

                        lParam = 128;
                        if (RegQueryValue(hk, szTemp, szTemp2, (PLONG)&lParam) != ERROR_SUCCESS) {
                            continue;
                        }

                        // Skip things that aren't relevant ot the shell.
                        lParam = 128;
                        lstrcpy(szTemp3, szTemp);
                        lstrcat(szTemp3, "\\shell");
                        if (RegQueryValue(hk, szTemp3, szTemp4, (PLONG)&lParam) != ERROR_SUCCESS) {
                            continue;
                        }


                        if (!szTemp2[0])
                            continue;

                        // Add on program info
                        lcbTemp = sizeof(szTemp3);
                        szTemp3[0] = TEXT('\0');
                        GetAssociatedExe(szTemp, szTemp3, &lcbTemp);
                        if (szTemp3[0] != TEXT('\0')) {
                            lstrcat(szTemp2, " (");
                            lstrcat(szTemp2, szTemp3);
                            lstrcat(szTemp2, ")");
                        }

                        iItem = (INT)SendDlgItemMessage(hDlg,IDD_CLASSLIST, LB_ADDSTRING,0,(LPARAM)szTemp2);

                        SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_SETITEMDATA,iItem,
                                           (DWORD)AddAtom(szTemp));
                    }

                    RegCloseKey(hk);
                }

                // Add the (None) entry at the begining.
                LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                SendDlgItemMessage(hDlg,IDD_CLASSLIST, LB_INSERTSTRING,0,(LPARAM)szTemp);

                lstrcpy(szTitle,".");

                /* Make 'p' point to the file's extension. */
                pSave = GetSelection(TRUE);
                if (pSave) {
                    p = GetExtension(pSave);
                    if (!IsProgramFile(pSave)) {
                        lstrcat(szTitle,p);
                    }
                    LocalFree((HANDLE)pSave);
                }

                SendDlgItemMessage(hDlg, IDD_EXTENSION, EM_LIMITTEXT, 4, 0L);
                SetDlgItemText(hDlg, IDD_EXTENSION, szTitle+1);
                SendDlgItemMessage(hDlg, IDD_EXTENSION, EM_SETMODIFY, 0, 0L);

                /* this is empty if there is no class association
                 */
                szMessage[0]=0;
                szTemp2[0]=0;

                UpdateSelectionOrName(hDlg);

                ValidateExtension(hDlg);

                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                HWND hwndT, hwndNext;

                case IDD_HELP:
                    goto DoHelp;

                case IDD_EXTENSION:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) {
                        ValidateExtension(hDlg);
                        UpdateSelectionOrName(hDlg);
                    }
                    break;

                case IDD_SEARCHALL:
                    {
                        OPENFILENAME ofn;
                        DWORD dwSave = dwContext;

                        dwContext = IDH_ASSOC_BROWSE;

                        LoadString(hAppInstance, IDS_PROGRAMS, szTemp2, sizeof(szTemp2));
                        FixupNulls(szTemp2);
                        LoadString(hAppInstance, IDS_ASSOCIATE, szTitle, sizeof(szTitle));

                        szTemp[0] = TEXT('\0');

                        ofn.lStructSize        = sizeof(ofn);
                        ofn.hwndOwner                   = hDlg;
                        ofn.hInstance         = NULL;
                        ofn.lpstrFilter        = szTemp2;
                        ofn.lpstrCustomFilter = NULL;
                        ofn.nFilterIndex        = 1;
                        ofn.lpstrFile                = szTemp;
                        ofn.lpstrFileTitle        = NULL;
                        ofn.nMaxFile                   = sizeof(szTemp);
                        ofn.lpstrInitialDir   = NULL;
                        ofn.lpstrTitle        = szTitle;
                        ofn.Flags                = OFN_SHOWHELP | OFN_HIDEREADONLY;
                        ofn.lpfnHook                   = NULL;
                        ofn.lpstrDefExt           = NULL;
                        if (GetOpenFileName(&ofn)) {
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp);
                        }

                        dwContext = dwSave;
                    }
                    DosResetDTAAddress(); // undo any bad things COMMDLG did
                    break;

                case IDD_CLASSLIST:
                    // Handle a selection change.
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) {
                        INT iSel;
                        LONG lTemp2;
                        ATOM aClass;

                        // Get selection number.
                        if (SendDlgItemMessage(hDlg,IDD_CLASSLIST,LB_GETCURSEL,0,0L) == 0) {
                            // User selected "none".
                            LoadString(hAppInstance, IDS_ASSOCNONE, szTemp, sizeof(szTemp));
                            // Copy into PROGRAMNAME field.
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, (LPSTR) szTemp);
                        } else {
                            // User selected a file type.
                            // Get the atom from the list box.
                            iSel = (WORD) SendDlgItemMessage(hDlg, IDD_CLASSLIST,
                                                             LB_GETCURSEL,0,0L);
                            aClass = (ATOM) SendDlgItemMessage(hDlg, IDD_CLASSLIST,
                                                               LB_GETITEMDATA, iSel, 0L);
                            // Use the atom to get the file type key.
                            GetAtomName(aClass, szTemp, sizeof(szTemp));
                            // Use the file type key to get the file type value.
                            lTemp2 = sizeof(szTemp2);
                            RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szTemp2,
                                          &lTemp2);
                            // Splat the file type value into PROGRAMNAME field.
                            SetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp2);
                        }
                        break;
                    }

                case IDD_PROGRAMNAME:
                    break;

                case IDOK:
                    {
                        GetDlgItemText(hDlg, IDD_EXTENSION, szTemp, 5);

                        if (szTemp[0] != '.') {
                            lstrcpy(szTitle,".");
                            lstrcat(szTitle, szTemp);
                        } else
                            lstrcpy(szTitle, szTemp);

                        if (IsProgramFile(szTitle)) {
                            LoadString(hAppInstance, IDS_NOEXEASSOC, szTemp, sizeof(szTemp));
                            wsprintf(szMessage, szTemp, (LPSTR)szTitle);
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            SetDlgItemText(hDlg, IDD_EXTENSION, szNULL);
                            break;
                        }



                        // Read IDD_PROGRAMNAME bit.
                        GetDlgItemText(hDlg, IDD_PROGRAMNAME, szTemp, sizeof(szTemp));
                        LoadString(hAppInstance, IDS_ASSOCNONE, szTemp2, sizeof(szTemp2));

                        // Is it "(None)" ?
                        if (!lstrcmp(szTemp, szTemp2)) {
                            DeleteAssoc:
                            // Yep, They selected none.
                            RegDeleteKey(HKEY_CLASSES_ROOT,szTitle);
                            WriteProfileString(szExtensions, szTitle+1, NULL);
                        } else if (ValidFileTypeValue(szTemp, szTemp2, sizeof(szTemp2))) {
                            LPSTR p1, p2;

                            // The file type key is in szTemp2 (eg wrifile).
                            // The extension key (eg .wri) is in szTitle.
                            // The file type value (eg Write Document) is in
                            // szTemp.
#ifdef VERBDEBUG
                            OutputDebugString("wf.adp: Valid file type selected.\n\r");
                            OutputDebugString("wf.adp: Extension ");
                            OutputDebugString(szTitle);
                            OutputDebugString("\n\r");
                            OutputDebugString("wf.adp: File type key ");
                            OutputDebugString(szTemp2);
                            OutputDebugString("\n\r");
                            OutputDebugString("wf.adp: File type value ");
                            OutputDebugString(szTemp);
                            OutputDebugString("\n\r");
#endif

                            /* set the class
                             */
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szTemp2, 0L);

                            /* get the class's SHELL\OPEN\COMMAND
                             */
                            lstrcpy(szTemp, szTemp2);
                            lstrcat(szTemp, szShellOpenCommand);
                            lParam = 128;
                            szTemp2[0] = 0;
                            RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szTemp2, (PLONG)&lParam);

                            /* insert ^.ext in for %1 in win.ini!
                             */
                            for (p1 = szTemp, p2 = szTemp2; *p2; p2 = AnsiNext(p2)) {
                                if (*p2 == '%') {
                                    p2++;
                                    if (!*p2)
                                        break;
                                    if (*p2 == '1') {
                                        *p1++ = '^';
                                        lstrcpy(p1,szTitle);
                                        p1 += lstrlen(p1);
                                    } else {
                                        *p1++ = *p2;
                                    }
                                } else {
                                    *p1++=*p2;
                                }
                            }

                            *p1 = 0; // null terminate

                            /* and use it for the extensions section
                             */
                            WriteProfileString(szExtensions,szTitle+1, szTemp);
                        } else {
                            // It must be a program name.

                            /* if no command line, treat as none
                             */
                            if (!szTemp[0])
                                goto DeleteAssoc;

                            // make sure it has an extension

                            if (*GetExtension(szTemp) == 0)
                                lstrcat(szTemp, ".exe");

                            if (!IsProgramFile(szTemp)) {
                                LoadString(hAppInstance, IDS_ASSOCNOTEXE, szTemp2, sizeof(szTemp2));
                                wsprintf(szMessage, szTemp2, (LPSTR)szTemp);
                                GetWindowText(hDlg, szTitle, sizeof(szTitle));
                                MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                                SetDlgItemText(hDlg, IDD_PROGRAMNAME, szNULL);
                                break;
                            }

                            /* unassociate the class from the extension
                             */
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szNULL, 0L);

                            /* update the [extensions] section
                             */
                            lstrcpy(szTemp2, szTemp);
                            lstrcat(szTemp2, " ^.");
                            lstrcat(szTemp2, szTitle+1);
                            WriteProfileString(szExtensions, szTitle+1, szTemp2);

                            /* update the reg database
                             */
                            lstrcat(szTemp," %1");
                            lstrcat(szTitle, szShellOpenCommand);
                            RegSetValue(HKEY_CLASSES_ROOT, szTitle, REG_SZ, szTemp, 0L);
                        }

                        // rebuild the list of document extensions
                        LocalFree((HANDLE)szDocuments);
                        BuildDocumentString();

                        /* Update all of the Directory Windows in order to see
                         * the effect of the new extensions.
                         */
                        hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                        while (hwndT) {
                            hwndNext = GetWindow(hwndT, GW_HWNDNEXT);
                            if (!GetWindow(hwndT, GW_OWNER))
                                SendMessage(hwndT, WM_FILESYSCHANGE, FSC_REFRESH, 0L);
                            hwndT = hwndNext;

                        }
                    }
                    /*** FALL THRU ***/

                case IDCANCEL:
                    {
                        INT iItem;
                        INT cItems;
                        ATOM aClass;

                        cItems = (INT)SendDlgItemMessage(hDlg,IDD_CLASSLIST,
                                                         LB_GETCOUNT,0,0L);

                        /* clean out them atoms except for "(none)".
                         */
                        for (iItem = 1; iItem < cItems; iItem++) {
                            aClass = (ATOM)SendDlgItemMessage(hDlg,IDD_CLASSLIST,
                                                              LB_GETITEMDATA,iItem,0L);
                            if (aClass == LB_ERR)
                                break;

                            DeleteAtom(aClass);
                        }

                        EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage || wMsg == wBrowseMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return(TRUE);
}


//
// Strips off the path portion and replaces the first part of an 8-dot-3
// filename with an asterisk.
//

VOID
StarFilename(
            LPSTR pszPath
            )
{
    LPSTR p;

    /* Remove any leading path information. */
    StripPath(pszPath);

    for (p = pszPath; *p && *p != '.'; p = (LPSTR)AnsiNext(p));

    if (*p == '.') {
        lstrcpy(pszPath+1, p);
        pszPath[0] = '*';
    } else
        lstrcpy(pszPath, szStarDotStar);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchDlgProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
SearchDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LPSTR     p;
    MDICREATESTRUCT   MDICS;
    CHAR szStart[MAXFILENAMELEN];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hDlg, IDD_DIR, EM_LIMITTEXT, sizeof(szSearch)-(1+MAXFILENAMELEN), 0L);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szStart)-1, 0L);

            GetSelectedDirectory(0, szSearch);
            SetDlgItemText(hDlg, IDD_DIR, szSearch);

            p = GetSelection(TRUE);

            if (p) {
                GetNextFile(p, szStart, sizeof(szStart));
                StarFilename(szStart);
                SetDlgItemText(hDlg, IDD_NAME, szStart);
                LocalFree((HANDLE)p);
            }

            CheckDlgButton(hDlg, IDD_SEARCHALL, bSearchSubs);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_DIR, szSearch, sizeof(szSearch));
                    QualifyPath(szSearch);

                    GetDlgItemText(hDlg, IDD_NAME, szStart, sizeof(szStart));
                    AppendToPath(szSearch, szStart);

                    bSearchSubs = IsDlgButtonChecked(hDlg, IDD_SEARCHALL);

                    EndDialog(hDlg, TRUE);

                    /* Is the search window already up? */
                    if (hwndSearch) {
                        if (SendMessage(hwndSearch, FS_CHANGEDISPLAY, CD_PATH, (LPARAM)szSearch)) {
                            SendMessage(hwndMDIClient, WM_MDIACTIVATE, GET_WM_MDIACTIVATE_MPS(0, 0, hwndSearch));
                            if (IsIconic(hwndSearch))
                                ShowWindow(hwndSearch, SW_SHOWNORMAL);
                        }
                    } else {

                        LoadString(hAppInstance, IDS_SEARCHTITLE, szMessage, 32);
                        lstrcat(szMessage, szSearch);

                        /* Have the MDIClient create the MDI directory window. */
                        MDICS.szClass = szSearchClass;
                        MDICS.hOwner = hAppInstance;
                        MDICS.szTitle = szMessage;
                        MDICS.style = 0;
                        MDICS.x  = CW_USEDEFAULT;
                        MDICS.y  = 0;
                        MDICS.cx = CW_USEDEFAULT;
                        MDICS.cy = 0;

                        // it would be nice to pass szSearch through here
                        // as well...

                        {
                            HWND hwnd;

                            hwnd = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE,
                                                     0, 0L);
                            MDICS.lParam = 0;
                            if (hwnd &&
                                (GetWindowLong(hwnd, GWL_STYLE) & WS_MAXIMIZE))
                                MDICS.lParam |= WS_MAXIMIZE;
                        }

                        SendMessage(hwndMDIClient, WM_MDICREATE, 0, (LPARAM)&MDICS);

                        if (hwndSearch && MDICS.lParam)
                            SendMessage(hwndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hwndSearch, 0L);


                    }
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


#define RUN_LENGTH      120

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  RunDlgProc() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
RunDlgProc(
          HWND hDlg,
          UINT wMsg,
          WPARAM wParam,
          LPARAM lParam
          )
{
    LPSTR p,pDir,pFile,pPar;
    register WORD ret;
    LPSTR pDir2;
    CHAR szTemp[MAXPATHLEN];
    CHAR szTemp2[MAXPATHLEN];
    CHAR sz3[MAX_PATH+1];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SetDlgDirectory(hDlg, NULL);
            SetWindowDirectory();          // and really set the DOS current directory

            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szTemp)-1, 0L);

            p = GetSelection(TRUE);

            if (p) {
                SetDlgItemText(hDlg, IDD_NAME, p);
                LocalFree((HANDLE)p);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;
#if 0
                case IDD_BROWSE:
                    {
                        OPENFILENAME ofn;
                        DWORD dwSave = dwContext;

                        dwContext = IDH_RUN_BROWSE;

                        LoadString(hAppInstance, IDS_PROGRAMS, szTemp2, sizeof(szTemp2));
                        FixupNulls(szTemp2);

                        LoadString(hAppInstance, IDS_RUN, szTitle, sizeof(szTitle));

                        GetSelectedDirectory(0, szDir);
                        szTemp[0] = 0;

                        ofn.lStructSize = sizeof(ofn);
                        ofn.hwndOwner = hDlg;
                        ofn.hInstance = NULL;
                        ofn.lpstrFilter = szTemp2;
                        ofn.lpstrCustomFilter = NULL;
                        ofn.nFilterIndex = 1;
                        ofn.nMaxCustFilter = NULL;
                        ofn.lpstrFile = szTemp;
                        ofn.nMaxFile = sizeof(szTemp);
                        ofn.lpstrInitialDir = szDir;
                        ofn.lpstrTitle = szTitle;
                        ofn.lpstrFileTitle = NULL;
                        ofn.nMaxFile = sizeof(szTemp);
                        ofn.Flags = OFN_SHOWHELP|OFN_HIDEREADONLY;
                        ofn.lpfnHook = NULL;
                        ofn.lpstrDefExt = "EXE";

                        if (GetOpenFileName(&ofn)) {
                            SetDlgItemText(hDlg, IDD_NAME, szTemp);
                            PostMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
                        }
                        DosResetDTAAddress(); // undo any bad things COMMDLG did
                        dwContext = dwSave;

                        break;
                    }
#endif

                case IDOK:
                    {
                        BOOL bLoadIt;

                        GetDlgItemText(hDlg, IDD_NAME, szTemp, sizeof(szTemp));
                        GetPathInfo(szTemp, &pDir, &pFile, &pPar);

                        // copy away parameters
                        lstrcpy(sz3,pPar);
                        *pPar = 0;    // strip the params from the program

                        // REVIEW HACK Hard code UNC style paths.
                        if (*pDir == '\\' && *(pDir+1) == '\\') {
                            // This is a UNC style filename so NULLify directory.
                            pDir2 = NULL;
                        } else {
                            GetSelectedDirectory(0, szTemp2);
                            pDir2 = szTemp2;
                        }

                        bLoadIt = IsDlgButtonChecked(hDlg, IDD_LOAD);
                        FixAnsiPathForDos(szTemp);
                        if (pDir2)
                            FixAnsiPathForDos(pDir2);
                        ret = ExecProgram(szTemp, sz3, pDir2, bLoadIt);
                        if (ret)
                            MyMessageBox(hDlg, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                        else
                            EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage || wMsg == wBrowseMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


VOID
CopyToClipboard(
               LPSTR pszFrom
               )
{
    CHAR szPath[MAXPATHLEN];
    UINT wFormat;
    HANDLE hMem;

    GetNextFile(pszFrom, szPath, sizeof(szPath));

    QualifyPath(szPath);
    FixAnsiPathForDos(szPath);

    wFormat = RegisterClipboardFormat("FileName");

    if (!wFormat)
        return;

    hMem = GlobalAlloc(GPTR|GMEM_DDESHARE, lstrlen(szPath)+1);

    if (!hMem)
        return;

    lstrcpy(GlobalLock(hMem), szPath);
    GlobalUnlock(hMem);

    if (OpenClipboard(hwndFrame)) {
        EmptyClipboard();
        SetClipboardData(wFormat, hMem);
#if 0
        // write, excel and winword will not past the package
        // if we put text in the clipboard.

        hMem = GlobalAlloc(GPTR | GMEM_DDESHARE, lstrlen(szPath)+1);
        if (hMem) {
            lstrcpy(GlobalLock(hMem), szPath);
            GlobalUnlock(hMem);
            SetClipboardData(CF_OEMTEXT, hMem);
        }
#endif
        CloseClipboard();
    }

}

VOID
EnableCopy(
          HWND hDlg,
          BOOL bCopy
          )
{
    HWND hwnd;

    // turn these on
    hwnd = GetDlgItem(hDlg, IDD_COPYTOCLIP);
    if (hwnd) {
        EnableWindow(hwnd, bCopy);
        ShowWindow(hwnd, bCopy ? SW_SHOWNA : SW_HIDE);
    }

    hwnd = GetDlgItem(hDlg, IDD_COPYTOFILE);
    if (hwnd) {
        EnableWindow(hwnd, bCopy);
        ShowWindow(hwnd, bCopy ? SW_SHOWNA : SW_HIDE);
    }

    // turn these off

    hwnd = GetDlgItem(hDlg, IDD_STATUS);
    if (hwnd) {
        EnableWindow(hwnd, !bCopy);
        ShowWindow(hwnd, !bCopy ? SW_SHOWNA : SW_HIDE);
    }

    hwnd = GetDlgItem(hDlg, IDD_NAME);
    if (hwnd) {
        EnableWindow(hwnd, !bCopy);
        ShowWindow(hwnd, !bCopy ? SW_SHOWNA : SW_HIDE);
    }
}

VOID
MessWithRenameDirPath(
                     PSTR pszPath
                     )
{
    CHAR szPath[MAXPATHLEN];

    // absolute path? don't tamper with it!
    if (!lstrcmp(pszPath + 1, ":\\") ||
        (lstrlen(pszPath) > (sizeof(szPath) - 4)))
        return;

    // prepend "..\" to this non absolute path
    lstrcpy(szPath, "..\\");
    lstrcat(szPath, pszPath);
    lstrcpy(pszPath, szPath);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SuperDlgProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This proc handles the Print, Move, Copy, Delete, and Rename functions.
 * The calling routine (AppCommandProc()) sets 'wSuperDlgMode' before
 * calling DialogBox() to indicate which function is being used.
 */

INT_PTR
APIENTRY
SuperDlgProc(
            register HWND hDlg,
            UINT wMsg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    WORD                len;
    LPSTR                pszFrom;
    CHAR                szTo[MAXPATHLEN];
    static BOOL   bTreeHasFocus;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                LPSTR  p;
                HWND  hwndActive;

                SetDlgDirectory(hDlg, NULL);

                EnableCopy(hDlg, wSuperDlgMode == IDM_COPY);

                hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                bTreeHasFocus = (GetTreeFocus(hwndActive) == HasTreeWindow(hwndActive));

                p = GetSelection(FALSE);

                switch (wSuperDlgMode) {

                    case IDM_COPY:
                        LoadString(hAppInstance, IDS_COPY, szTitle, sizeof(szTitle));
                        SetWindowText(hDlg, szTitle);

                        if (bTreeHasFocus) {      // selection came from the tree
                            AddBackslash(p);
                            lstrcat(p, szStarDotStar);
                        }
                        break;
                    case IDM_RENAME:
                        LoadString(hAppInstance, IDS_RENAME, szTitle, sizeof(szTitle));
                        SetWindowText(hDlg, szTitle);

                        // when renaming the current directory we cd up a level
                        // (not really) and apply the appropriate hacks

                        if (bTreeHasFocus) {
                            lstrcpy(szTo, p);
                            StripFilespec(szTo);
                            SetDlgDirectory(hDlg, szTo);  // make the user think this!

                            StripPath(p);         // name part of dir
                        }
                        break;
                }

                SetDlgItemText(hDlg, IDD_FROM, p);
                LocalFree((HANDLE)p);

                if ((wSuperDlgMode == IDM_PRINT) || (wSuperDlgMode == IDM_DELETE))
                    wParam = IDD_FROM;
                else
                    wParam = IDD_TO;
                SendDlgItemMessage(hDlg, (int)wParam, EM_LIMITTEXT, sizeof(szTo) - 1, 0L);

                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                WORD id = GET_WM_COMMAND_ID(wParam, lParam);
                case IDD_HELP:
                    goto DoHelp;

                case IDD_COPYTOFILE:
                case IDD_COPYTOCLIP:
                    CheckButtons:
                    CheckRadioButton(hDlg, IDD_COPYTOCLIP, IDD_COPYTOFILE, id);
                    break;

                case IDD_TO:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_SETFOCUS) {
                        id = IDD_COPYTOFILE;
                        goto CheckButtons;
                    }
                    break;

                case IDCANCEL:
                    /* This is for when this dialog is being used to print. */
                    bUserAbort = TRUE;
                    SuperDlgExit:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    len = (WORD)(SendDlgItemMessage(hDlg, IDD_FROM, EM_LINELENGTH, -1, 0L) + 1);

                    // make sure the pszFrom buffer is big enough to
                    // add the "..\" stuff in MessWithRenameDirPath()
                    len += 4;

                    pszFrom = (LPSTR)LocalAlloc(LPTR, len);
                    if (!pszFrom)
                        goto SuperDlgExit;

                    GetDlgItemText(hDlg, IDD_FROM, pszFrom, len);
                    GetDlgItemText(hDlg, IDD_TO, szTo, sizeof(szTo));

                    if (wSuperDlgMode == IDM_COPY && IsDlgButtonChecked(hDlg, IDD_COPYTOCLIP)) {
                        CopyToClipboard(pszFrom);
                        goto SuperDlgExit;
                    }

                    if (!szTo[0]) {
                        switch (wSuperDlgMode) {
                            case IDM_RENAME:
                            case IDM_MOVE:
                                goto SuperDlgExit;

                            case IDM_COPY:
                                szTo[0] = '.';
                                szTo[1] = '\0';
                                break;
                        }
                    }

                    EnableCopy(hDlg, FALSE);

                    hdlgProgress = hDlg;
                    if (wSuperDlgMode == IDM_PRINT)
                        WFPrint(pszFrom);
                    else {

                        if (wSuperDlgMode == IDM_RENAME && bTreeHasFocus) {
                            MessWithRenameDirPath(pszFrom);
                            MessWithRenameDirPath(szTo);
                        }
                        /* HACK: Compute the FUNC_ values from WFCOPY.H */
                        WFMoveCopyDriver(pszFrom, szTo, (WORD)(wSuperDlgMode-IDM_MOVE+1));
                    }

                    LocalFree((HANDLE)pszFrom);

                    lFreeSpace = -1L;     // force status info refresh

                    EndDialog(hDlg, TRUE);
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


VOID
CheckAttribsDlgButton(
                     HWND hDlg,
                     INT id,
                     DWORD dwAttribs,
                     DWORD dwAttribs3State,
                     DWORD dwAttribsOn
                     )
{
    INT i;

    if (dwAttribs3State & dwAttribs)
        i = 2;
    else if (dwAttribsOn & dwAttribs)
        i = 1;
    else
        i = 0;

    CheckDlgButton(hDlg, id, i);
}

INT
InitPropertiesDialog(
                    HWND hDlg
                    )
{
    HWND hwndLB, hwndActive, hwndTree;
    DWORD_PTR dwTemp;
    HANDLE hMem;
    LPMYDTA lpmydta;
    DWORD dwAttribsOn, dwAttribs3State, dwAttribsLast;
    HWND hwndDir, hwnd;
    CHAR szName[MAXPATHLEN];
    CHAR szPath[MAXPATHLEN];
    CHAR szTemp[MAXPATHLEN + 20];
    CHAR szBuf[80];
    WCHAR szNum[30];
    INT i, iMac, iCount, dyButton;
    DWORD dwSize;
    RECT rc, rcT;
    DWORD dwAttrib;
    FILETIME Time;
    DWORD Length;
    LFNDTA lfndta;
    PSTR p;
    HFONT L_hFont;
    INT nType = 0;

    // this is needed for relative findfirst calls below
    SetWindowDirectory();

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    hwndDir = HasDirWindow(hwndActive);
    hwndTree = HasTreeWindow(hwndActive);

    iCount = 0;
    dwAttribsOn = 0;                // all bits to check
    dwAttribs3State = 0;    // all bits to 3 state
    dwAttribsLast = 0xFFFF; // previous bits
    dwSize = 0L;

    if (hwndTree && hwndTree == GetTreeFocus(hwndActive)) {

        SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        StripBackslash(szPath);
        FixAnsiPathForDos(szPath);
        if (!WFFindFirst(&lfndta, szPath, ATTR_ALL | ATTR_DIR)) {
            LoadString(hAppInstance, IDS_REASONS+DE_PATHNOTFOUND, szMessage, sizeof(szMessage));
            MessageBox(hwndFrame, szMessage, szPath, MB_OK | MB_ICONSTOP);
            EndDialog(hDlg, FALSE);
            return 0;
        }
        WFFindClose(&lfndta);
        OemToCharBuff(szPath, szPath, sizeof(szPath)/sizeof(szPath[0]));
        dwAttribsOn = lfndta.fd.dwFileAttributes;
        Time = lfndta.fd.ftLastWriteTime;
        Length = lfndta.fd.nFileSizeLow; // BUG < 64 bits!

        goto FULL_PATH_KINDA_THING;
    }

    if (hwndDir) {
        hwndLB = GetDlgItem(hwndDir, IDCW_LISTBOX);
        hMem = (HANDLE)GetWindowLongPtr(hwndDir, GWLP_HDTA);
    } else {
        hwndLB = GetDlgItem(hwndActive, IDCW_LISTBOX);
        hMem = (HANDLE)GetWindowLongPtr(hwndActive, GWLP_HDTASEARCH);
    }

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    for (i = 0; i < iMac; i++) {
        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {

            // get info from either dir or search window

            if (hwndDir) {
                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);
                dwAttrib = lpmydta->my_dwAttrs;
                /* Check that this is not the .. entry */

                if (dwAttrib & ATTR_DIR && dwAttrib & ATTR_PARENT)
                    continue;

                Time   = lpmydta->my_ftLastWriteTime;
                Length = lpmydta->my_nFileSizeLow;
                lstrcpy(szName, lpmydta->my_cFileName);
            } else {
                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szPath);
                dwTemp = SendMessage(hwndLB, LB_GETITEMDATA, i, 0L);
                dwAttrib = ((LPDTASEARCH)lpmydta)[dwTemp].sch_dwAttrs;
                Time   = ((LPDTASEARCH)lpmydta)[dwTemp].sch_ftLastWriteTime;
                Length = ((LPDTASEARCH)lpmydta)[dwTemp].sch_nFileSizeLow;
            }

            dwAttribsOn |= dwAttrib;

            if (dwAttribsLast == 0xFFFF)
                // save the previous bits for future compares
                dwAttribsLast = dwAttrib;
            else
                // remember all bits that don't compare to last bits
                dwAttribs3State |= (dwAttrib ^ dwAttribsLast);

            dwSize += Length;

            iCount++;
        }
    }

    GetDlgItemText(hDlg, IDD_TEXT, szTemp, sizeof(szTemp));
    wsprintf(szBuf, szTemp, iCount, AddCommasW(dwSize, szNum));
    SetDlgItemText(hDlg, IDD_TEXT, szBuf);

    if (iCount == 1) {
        if (hwndDir) {
            SendMessage(hwndDir, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
        } else {
            FULL_PATH_KINDA_THING:
            lstrcpy(szName, szPath);
            StripPath(szName);
            StripFilespec(szPath);
        }
        StripBackslash(szPath);

        GetWindowText(hDlg, szTitle, sizeof(szTitle));
        wsprintf(szTemp, szTitle, (LPSTR)szName);
        SetWindowText(hDlg, szTemp);

        SetDlgItemText(hDlg, IDD_NAME, szName);
        SetDlgItemText(hDlg, IDD_DIR, szPath);

        wsprintf(szTemp, szSBytes, (LPSTR)AddCommasW(Length, szNum));
        SetDlgItemText(hDlg, IDD_SIZE, szTemp);

        PutDate(&Time, szTemp);
        lstrcat(szTemp, "  ");
        PutTime(&Time, szTemp + lstrlen(szTemp));

        SetDlgItemText(hDlg, IDD_DATE, szTemp);
    } else
        dwContext = IDH_GROUP_ATTRIBS;

    // add the network specific property buttons

    if (WNetGetCaps(WNNC_DIALOG) & WNNC_DLG_PROPERTYDIALOG) {
        GetWindowRect(GetDlgItem(hDlg,IDOK), &rcT);
        GetWindowRect(GetDlgItem(hDlg,IDCANCEL), &rc);
        dyButton = rc.top - rcT.top;

        GetWindowRect(GetDlgItem(hDlg,IDD_HELP), &rc);
        ScreenToClient(hDlg,(LPPOINT)&rc.left);
        ScreenToClient(hDlg,(LPPOINT)&rc.right);

        p = GetSelection(3);
        if (p) {

            for (i = 0; i < 6; i++) {

                if (iCount > 1)
                    nType = WNPS_MULT;
                else if (dwAttribsOn & ATTR_DIR)
                    nType = WNPS_DIR;
                else
                    nType = WNPS_FILE;

                if (WNetGetPropertyText((WORD)i, (WORD)nType, p, szTemp, 30, WNTYPE_FILE) != WN_SUCCESS)
                    break;

                if (!szTemp[0])
                    break;

                OffsetRect(&rc,0,dyButton);
                hwnd = CreateWindowEx(0, "button", szTemp,
                                      WS_VISIBLE|WS_CHILD|WS_TABSTOP|BS_PUSHBUTTON,
                                      rc.left, rc.top,
                                      rc.right - rc.left, rc.bottom-rc.top,
                                      hDlg, (HMENU)IntToPtr(i + IDD_NETWORKFIRST), hAppInstance, NULL);

                if (hwnd) {
                    L_hFont = (HFONT)SendDlgItemMessage(hDlg, IDOK, WM_GETFONT, 0, 0L);
                    SendMessage(hwnd, WM_SETFONT, (WPARAM)L_hFont, 0L);
                }
            }

            LocalFree((HANDLE)p);

            ClientToScreen(hDlg,(LPPOINT)&rc.left);
            ClientToScreen(hDlg,(LPPOINT)&rc.right);
            GetWindowRect(hDlg,&rcT);
            rc.bottom += dyButton;
            if (rcT.bottom <= rc.bottom) {
                SetWindowPos(hDlg,NULL,0,0,rcT.right-rcT.left,
                             rc.bottom - rcT.top, SWP_NOMOVE|SWP_NOZORDER);
            }
        }
    }

    // change those that don't need to be 3state to regular

    if (ATTR_READONLY & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_READONLY), GWL_STYLE, WS_VISIBLE | WS_GROUP | WS_TABSTOP | BS_AUTO3STATE | WS_CHILD);

    if (ATTR_HIDDEN & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_HIDDEN), GWL_STYLE, WS_VISIBLE | BS_AUTO3STATE | WS_CHILD);
    if (ATTR_ARCHIVE & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_ARCHIVE), GWL_STYLE, WS_VISIBLE |  BS_AUTO3STATE | WS_CHILD);
    if (ATTR_SYSTEM & dwAttribs3State)
        SetWindowLong(GetDlgItem(hDlg, IDD_SYSTEM), GWL_STYLE, WS_VISIBLE | BS_AUTO3STATE | WS_CHILD);

    CheckAttribsDlgButton(hDlg, IDD_READONLY, ATTR_READONLY, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_HIDDEN,   ATTR_HIDDEN, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_ARCHIVE,  ATTR_ARCHIVE, dwAttribs3State, dwAttribsOn);
    CheckAttribsDlgButton(hDlg, IDD_SYSTEM,   ATTR_SYSTEM, dwAttribs3State, dwAttribsOn);

    return nType;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AttribsDlgProc() -                                                      */
/*                                                                          */
// assumes the active MDI child has a directory window
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
AttribsDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    LPSTR p, pSel;
    BOOL bRet;
    HCURSOR hCursor;
    DWORD dwAttribsNew, dwAttribs, dwChangeMask;
    UINT state;
    CHAR szName[MAXPATHLEN];
    static INT nType;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {

        case WM_INITDIALOG:
            nType = InitPropertiesDialog(hDlg);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_NETWORKFIRST+0:
                case IDD_NETWORKFIRST+1:
                case IDD_NETWORKFIRST+2:
                case IDD_NETWORKFIRST+3:
                case IDD_NETWORKFIRST+4:
                case IDD_NETWORKFIRST+5:

                    p = GetSelection(3);
                    if (p) {
                        WNetPropertyDialog(hDlg, (WORD)(GET_WM_COMMAND_ID(wParam, lParam)-IDD_NETWORKFIRST), (WORD)nType, p, WNTYPE_FILE);
                        LocalFree((HANDLE)p);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    bRet = TRUE;
                    dwChangeMask = ATTR_READWRITE;
                    dwAttribsNew = ATTR_READWRITE;

                    if ((state = IsDlgButtonChecked(hDlg, IDD_READONLY)) < 2) {
                        dwChangeMask |= ATTR_READONLY;
                        if (state == 1)
                            dwAttribsNew |= ATTR_READONLY;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_HIDDEN)) < 2) {
                        dwChangeMask |= ATTR_HIDDEN;
                        if (state == 1)
                            dwAttribsNew |= ATTR_HIDDEN;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_ARCHIVE)) < 2) {
                        dwChangeMask |= ATTR_ARCHIVE;
                        if (state == 1)
                            dwAttribsNew |= ATTR_ARCHIVE;
                    }

                    if ((state = IsDlgButtonChecked(hDlg, IDD_SYSTEM)) < 2) {
                        dwChangeMask |= ATTR_SYSTEM;
                        if (state == 1)
                            dwAttribsNew |= ATTR_SYSTEM;
                    }

                    EndDialog(hDlg, bRet);

                    pSel = GetSelection(FALSE);

                    if (!pSel)
                        break;

                    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    ShowCursor(TRUE);

                    DisableFSC();

                    p = pSel;

                    while (p = GetNextFile(p, szName, sizeof(szName))) {

                        QualifyPath(szName);
                        FixAnsiPathForDos(szName);

                        dwAttribs = GetFileAttributes(szName);

                        if (dwAttribs & 0x8000)     // BUG hardcoded!
                            goto AttributeError;
                        else
                            dwAttribs &= ~ATTR_DIR;

                        dwAttribs = (dwChangeMask & dwAttribsNew) | (~dwChangeMask & dwAttribs);

                        if (WFSetAttr(szName, dwAttribs)) {
                            AttributeError:
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_ATTRIBERR, szMessage, sizeof(szMessage));
                            MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            bRet = FALSE;
                            break;
                        }

                        // clear all the FSC messages from the message queue
                        wfYield();
                    }

                    EnableFSC();

                    ShowCursor(FALSE);
                    SetCursor(hCursor);

                    LocalFree((HANDLE)pSel);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MakeDirDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
MakeDirDlgProc(
              HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    CHAR szPath[MAXPATHLEN];
    INT ret;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            SetDlgDirectory(hDlg, NULL);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szPath)-1, 0L);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    GetDlgItemText(hDlg, IDD_NAME, szPath, sizeof(szPath));

                    EndDialog(hDlg, TRUE);

                    // parse out any quoted strings

                    GetNextFile(szPath, szPath, sizeof(szPath));

                    QualifyPath(szPath);

                    hdlgProgress = hDlg;
                    if (NetCheck(szPath,WNDN_MKDIR) == WN_SUCCESS) {
                        FixAnsiPathForDos(szPath);

                        ret = WF_CreateDirectory(hDlg, szPath);
                        if (ret && ret!=DE_OPCANCELLED) {
                            if (WFIsDir(szPath))
                                ret = IDS_MAKEDIREXISTS;
                            else
                                ret += IDS_REASONS;

                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, ret, szMessage, sizeof(szMessage));
                            MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                        }
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfext.c ===
//-------------------------------------------------------------------------
// File Manager Extensions support routines
//
//
// radical
//
//-------------------------------------------------------------------------

#include "winfile.h"
#include "winnet.h"


LONG
GetExtSelection(
               HWND hWnd,
               WORD wItem,
               LPFMS_GETFILESEL lpSel,
               BOOL bSearch,
               BOOL bGetCount,
               BOOL bLFNAware
               )
{
    HANDLE hDTA;
    LPMYDTA lpmydta;
    LPDTASEARCH lpdtasch, lpdtaschT;
    INT count, sel_ind, i;
    HWND hwndLB;
    CHAR szPath[MAXPATHLEN];
    FMS_GETFILESEL file;

    if (bGetCount)
        lpSel = &file;

    if (bSearch) {
        hDTA = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
        lpdtasch = (LPDTASEARCH)LocalLock(hDTA);
        hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);
    } else {
        hDTA = (HANDLE)GetWindowLongPtr(HasDirWindow(hWnd), GWLP_HDTA);
        hwndLB = GetDlgItem(HasDirWindow(hWnd), IDCW_LISTBOX);
        LocalLock(hDTA);
    }

    count = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    sel_ind = 0;            // index of current selected item

    for (i = 0; i < count; i++) {

        if ((BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L)) {

            if (bSearch) {

                lpdtaschT = &(lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L)]);

                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szPath);
                lpSel->bAttr = (BYTE)lpdtaschT->sch_dwAttrs;
                lpSel->ftTime = lpdtaschT->sch_ftLastWriteTime;
                lpSel->dwSize = lpdtaschT->sch_nFileSizeLow;
            } else {

                SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)&lpmydta);

                if (lpmydta->my_dwAttrs & ATTR_PARENT)
                    continue;

                SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
                lstrcat(szPath, lpmydta->my_cFileName);
                lpSel->bAttr = (BYTE)lpmydta->my_dwAttrs;
                lpSel->ftTime = lpmydta->my_ftLastWriteTime;
                lpSel->dwSize = lpmydta->my_nFileSizeLow;
            }
            // skip LFN stuff for non LFN aware dudes!

            if (!bLFNAware && (lpSel->bAttr & ATTR_LFN))
                continue;

            FixAnsiPathForDos(szPath);
            lstrcpy(lpSel->szName, szPath);

            if (!bGetCount) {

                if (wItem == (WORD)sel_ind)
                    goto BailOutDude;
            }

            sel_ind++;
        }
    }

    BailOutDude:
    LocalUnlock(hDTA);

    return (LONG)sel_ind;
}



LONG
GetDriveInfo(
            HWND hwnd,
            LPFMS_GETDRIVEINFO lpSel
            )
{
    CHAR szPath[MAXPATHLEN];
    CHAR szVol[14];

    // this has to work for hwnd a tree or search window

    SendMessage(hwnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
    StripBackslash(szPath);
    FixAnsiPathForDos(szPath);

    lstrcpy(lpSel->szPath, szPath);
    lpSel->dwTotalSpace = lTotalSpace;
    lpSel->dwFreeSpace = lFreeSpace;
    GetVolumeLabel((szPath[0] & ~0x20) - 'A', szVol, FALSE);
    lstrcpy(lpSel->szVolume, szVol);
    szPath[2] = 0;
    if (WFGetConnection(szPath, lpSel->szShare, FALSE) != WN_SUCCESS)
        lpSel->szShare[0] = 0;

    return 1L;
}


VOID
APIENTRY
FreeExtensions()
{
    INT i;
    HMENU hMenuFrame;
    INT iMax;
    HWND hwndActive;

    hMenuFrame = GetMenu(hwndFrame);
    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    for (i = 0; i < iNumExtensions; i++) {
        (extensions[i].ExtProc)(NULL, FMEVENT_UNLOAD, 0L);
        DeleteMenu(hMenuFrame, IDM_EXTENSIONS + iMax, MF_BYPOSITION);
        FreeLibrary((HANDLE)extensions[i].hModule);
    }
    iNumExtensions = 0;
}


INT_PTR
APIENTRY
ExtensionMsgProc(
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    HWND hwndActive;
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    GetTreeWindows(hwndActive, &hwndTree, &hwndDir, &hwndDrives);

    switch (wMsg) {

        case FM_RELOAD_EXTENSIONS:
            SendMessage(hwndFrame, WM_CANCELMODE, 0, 0L);
            FreeExtensions();
            InitExtensions();
            DrawMenuBar(hwndFrame);
            break;

        case FM_GETFOCUS:
            // wParam       unused
            // lParam       unused
            // return       window tyep with focus

            if (hwndActive == hwndSearch)
                return FMFOCUS_SEARCH;

            hwndFocus = GetTreeFocus(hwndActive);

            if (hwndFocus == hwndTree)
                return FMFOCUS_TREE;
            else if (hwndFocus == hwndDir)
                return FMFOCUS_DIR;
            else if (hwndFocus == hwndDrives)
                return FMFOCUS_DRIVES;
            break;

        case FM_GETDRIVEINFO:
            // wParam       unused
            // lParam       LPFMS_GETDRIVEINFO structure to be filled in

            return GetDriveInfo(hwndActive, (LPFMS_GETDRIVEINFO)lParam);

            break;

        case FM_REFRESH_WINDOWS:
            // wParam       0 refresh the current window
            //              non zero refresh all windows
            // lParam       unused

            if (wParam == 0)
                RefreshWindow(hwndActive);
            else {
                HWND hwndT, hwndNext;

                hwndT = GetWindow(hwndMDIClient, GW_CHILD);
                while (hwndT) {
                    hwndNext = GetWindow(hwndT, GW_HWNDNEXT);
                    if (!GetWindow(hwndT, GW_OWNER))
                        RefreshWindow(hwndT);
                    hwndT = hwndNext;
                }
            }
            lFreeSpace = -1L;
            UpdateStatus(hwndActive);
            break;

        case FM_GETSELCOUNT:
        case FM_GETSELCOUNTLFN:
            // wParam       unused
            // lParam       unused
            // return       # of selected items

        case FM_GETFILESEL:
        case FM_GETFILESELLFN:
            // wParam       index of selected item to get
            // lParam       LPFMS_GETFILESEL structure to be filled in

            if (hwndActive != hwndSearch && !hwndDir)
                return 0L;

            // note, this uses the fact that LFN messages are odd!

            return GetExtSelection(hwndActive, (WORD)wParam, (LPFMS_GETFILESEL)lParam,
                                   hwndActive == hwndSearch, (wMsg & ~1) == FM_GETSELCOUNT,
                                   (BOOL)(wMsg & 1));
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdlgs3.c ===
/****************************************************************************/
/*                                                                          */
/*  WFDLGS.C -                                                              */
/*                                                                          */
/*      Windows File System Dialog procedures                               */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "wnetcaps.h"			// WNetGetCaps()
#include "lfn.h"
#include "wfcopy.h"


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ChooseDriveDlgProc() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ChooseDriveDlgProc(
                  register HWND hDlg,
                  UINT wMsg,
                  WPARAM wParam,
                  LPARAM lParam
                  )
{
    CHAR szDrive[5];

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                INT   i;
                HWND  hwndLB;
                lstrcpy(szDrive, "A:");

                hwndLB = GetDlgItem(hDlg, IDD_DRIVE);

                switch (wSuperDlgMode) {
                    case IDM_SYSDISK:
                    case IDM_DISKCOPY:
                        FillFloppies:
                        for (i = 0; i < cDrives; i++) {
                            if (IsRemovableDrive(rgiDrive[i])) {
                                szDrive[0] = (CHAR)('A'+rgiDrive[i]);
                                SendMessage(hwndLB, CB_ADDSTRING, 0, (LPARAM)szDrive);
                            }
                        }
                        if (wSuperDlgMode == IDM_DISKCOPY && hwndLB == GetDlgItem(hDlg, IDD_DRIVE)) {
                            SendMessage(hwndLB, CB_SETCURSEL, 0, 0L);
                            hwndLB = GetDlgItem(hDlg, IDD_DRIVE1);
                            goto FillFloppies;
                        }
                        break;

                    case IDM_DISCONNECT:
                        for (i=0; i < cDrives; i++) {
                            wParam = rgiDrive[i];
                            if (!IsCDRomDrive((WORD)wParam)) {
                                CHAR szTemp[80];

                                szDrive[0] = szTemp[0] = (CHAR)('A' + wParam);
                                szDrive[1] = szTemp[1] = ':';
                                szDrive[2] = szTemp[2] = 0;
                                szTemp[2] = ' ';

                                if (WFGetConnection(szDrive, szTemp+3, FALSE) != WN_SUCCESS)
                                    continue;

                                SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szTemp);
                            }
                        }
                        SendMessage(hwndLB,LB_SETCURSEL,0,0L);
                        return TRUE;
                }
                SendMessage(hwndLB, CB_SETCURSEL, 0, 0L);
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDOK:
                    {
                        CHAR szTemp[80];

                        if (wSuperDlgMode == IDM_DISCONNECT) {
                            SendDlgItemMessage(hDlg, IDD_DRIVE, LB_GETTEXT,
                                               (WPARAM)SendDlgItemMessage(hDlg, IDD_DRIVE,
                                                                          WM_COMMAND,
                                                                          GET_WM_COMMAND_MPS(LB_GETCURSEL,0,0)),
                                               (LPARAM)szTemp);
                        } else
                            GetDlgItemText(hDlg, IDD_DRIVE, szTemp, sizeof(szTemp) - 1);

                        iFormatDrive = (INT)(szTemp[0] - 'A');

                        if (wSuperDlgMode == IDM_DISKCOPY) {
                            GetDlgItemText(hDlg, IDD_DRIVE1, szTemp, sizeof(szTemp) - 1);
                            iCurrentDrive = (INT)(szTemp[0] - 'A');
                        }

                        EndDialog(hDlg, TRUE);
                        break;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DiskLabelDlgProc() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
DiskLabelDlgProc(
                register HWND hDlg,
                UINT wMsg,
                WPARAM wParam,
                LPARAM lParam
                )
{
    CHAR szOldVol[13];
    CHAR szNewVol[13];

    switch (wMsg) {
        case WM_INITDIALOG:

            /* Get the current volume label */

            szNewVol[0] = (CHAR)(GetSelectedDrive() + 'A');
            szNewVol[1] = ':';
            szNewVol[2] = '\0';
            if (!IsTheDiskReallyThere(hDlg, szNewVol, FUNC_LABEL)) {
                EndDialog(hDlg, FALSE);
                break;
            }

            GetVolumeLabel(szNewVol[0]-'A', szOldVol, FALSE);
            OemToCharBuff(szOldVol, szOldVol, sizeof(szOldVol)/sizeof(szOldVol[0]));

            /* Display the current volume label. */
            SetDlgItemText(hDlg, IDD_NAME, szOldVol);
            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szNewVol)-2, 0L);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:
                    {
                        HWND hwnd;
                        BOOL bOldVolExists;

                        GetVolumeLabel(GetSelectedDrive(), szOldVol, FALSE);

                        bOldVolExists = (szOldVol[0] != TEXT('\0'));
                        GetDlgItemText(hDlg, IDD_NAME, szNewVol, sizeof(szNewVol));

                        if (MySetVolumeLabel(GetSelectedDrive(), bOldVolExists, szNewVol)) {
                            GetWindowText(hDlg, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_LABELDISKERR, szMessage, sizeof(szMessage));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            EndDialog(hDlg, FALSE);
                            break;
                        }

                        for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                            hwnd;
                            hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                            // refresh windows on this drive

                            if ((LONG)GetSelectedDrive() == GetWindowLong(hwnd, GWL_TYPE))
                                SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
                        }
                        EndDialog(hDlg, TRUE);
                        break;
                    }

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


INT
APIENTRY
FormatDiskette(
              HWND hwnd
              )
{
    WNDPROC lpfnDialog;
    INT res;
    DWORD dwSave;

    // in case current drive is on floppy

    GetSystemDirectory(szMessage, sizeof(szMessage));
    SheChangeDir(szMessage);

    dwSave = dwContext;
    dwContext = IDH_FORMAT;
    res = (int)DialogBox(hAppInstance, MAKEINTRESOURCE(FORMATDLG), hwnd, FormatDlgProc);
    dwContext = dwSave;

    return res;
}



WORD fFormatFlags = 0;
WORD nLastDriveInd = 0;

VOID
FillDriveCapacity(
                 HWND hDlg,
                 INT nDrive
                 )
{
    INT count, cap;

    SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_RESETCONTENT, 0, 0L);

    cap = (INT)GetDriveCapacity((WORD)nDrive);

    count = 0;      // index of each string, since we are inserting at the end

    // 3.5 (720 1.44 2.88
    if ((cap >= 3) && (cap <= 5)) {

        // 1.44

        LoadString(hAppInstance, IDS_144MB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_144MB,0));

        // 720

        LoadString(hAppInstance, IDS_720KB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_720KB,0));

        if (cap == 5) { // 2.88
            LoadString(hAppInstance, IDS_288MB, szTitle, sizeof(szTitle));
            SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
            SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_288MB,0));
        }
    } else if ((cap >= 1) && (cap <= 2)) {

        // 1.2

        LoadString(hAppInstance, IDS_12MB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_12MB,0));

        // 360

        LoadString(hAppInstance, IDS_360KB, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count++, MAKELONG(IDS_360KB,0));
    } else {
        // device cap

        LoadString(hAppInstance, IDS_DEVICECAP, szTitle, sizeof(szTitle));
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_INSERTSTRING, count, (LPARAM)szTitle);
        SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETITEMDATA, count, MAKELONG(IDS_DEVICECAP, 0));

    }
    SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_SETCURSEL, FF_CAPMASK & fFormatFlags, 0L);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatDlgProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
FormatDlgProc(
             register HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    CHAR szLabel[13];
    CHAR szBuf[128];
    INT  i, iCap, iDrive = 0;
    WORD count;

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:

            // fill drives combo

            count = 0;
            LoadString(hAppInstance, IDS_DRIVETEMP, szTitle, sizeof(szTitle));
            for (i=0; i < cDrives; i++) {
                if (IsRemovableDrive(rgiDrive[i])) {
                    wsprintf(szMessage, szTitle, (CHAR)('A'+rgiDrive[i]), ' ');

                    if (count == (WORD)nLastDriveInd)
                        iDrive = i;

                    SendDlgItemMessage(hDlg, IDD_DRIVE, CB_INSERTSTRING, count, (LPARAM)szMessage);
                    SendDlgItemMessage(hDlg, IDD_DRIVE, CB_SETITEMDATA, count++, MAKELONG(rgiDrive[i], 0));
                }
            }

            SendDlgItemMessage(hDlg, IDD_NAME, EM_LIMITTEXT, sizeof(szLabel)-2, 0L);

            if (fFormatFlags & FF_SAVED) {
                CheckDlgButton(hDlg, IDD_VERIFY, fFormatFlags & FF_QUICK);
                CheckDlgButton(hDlg, IDD_MAKESYS, fFormatFlags & FF_MAKESYS);
            }

            SendDlgItemMessage(hDlg, IDD_DRIVE, CB_SETCURSEL, nLastDriveInd, 0L);

            FillDriveCapacity(hDlg, rgiDrive[iDrive]);

            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {

                case IDD_HELP:
                    goto DoHelp;

                case IDD_DRIVE:
                    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
                        case CBN_SELCHANGE:
                            i = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETCURSEL, 0, 0L);
                            i = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETITEMDATA, i, 0L);
                            fFormatFlags &= ~FF_CAPMASK;
                            FillDriveCapacity(hDlg, i);
                            break;
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                case IDOK:

                    nLastDriveInd = (WORD)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETCURSEL, 0, 0L);
                    iFormatDrive = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, CB_GETITEMDATA, nLastDriveInd, 0L);

                    i = (INT)SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_GETCURSEL, 0, 0L);
                    fFormatFlags &= ~FF_CAPMASK;    // clear any previous bits
                    fFormatFlags |= (WORD)i;        // save last selection as default

                    if (i >= 0)
                        iCap = (INT)SendDlgItemMessage(hDlg, IDD_HIGHCAP, CB_GETITEMDATA, i, 0L);
                    else
                        iCap = IDS_DEVICECAP;

                    if (iCap == IDS_DEVICECAP)
                        iCap = -1;
                    else
                        iCap -= IDS_DRIVEBASE;  // normalize down to
                                                // indexes into bpbList[]

                    fFormatFlags |= FF_SAVED;

                    if (IsDlgButtonChecked(hDlg, IDD_MAKESYS))
                        fFormatFlags |= FF_MAKESYS;
                    else
                        fFormatFlags &= ~FF_MAKESYS;

                    if (IsDlgButtonChecked(hDlg, IDD_VERIFY))
                        fFormatFlags |= FF_QUICK;
                    else
                        fFormatFlags &= ~FF_QUICK;

                    GetDlgItemText(hDlg, IDD_NAME, szLabel, sizeof(szLabel));

                    if (bConfirmFormat) {
                        LoadString(hAppInstance, IDS_FORMATCONFIRMTITLE, szTitle, sizeof(szTitle));
                        LoadString(hAppInstance, IDS_FORMATCONFIRM, szBuf, sizeof(szBuf));
                        wsprintf(szMessage, szBuf, (CHAR)('A'+iFormatDrive));

                        if (MessageBox(hDlg, szMessage, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON1) != IDYES)
                            break;
                    }
                    if (FormatFloppy(hDlg, (WORD)iFormatDrive, iCap, (fFormatFlags & FF_MAKESYS), (fFormatFlags & FF_QUICK))) {

                        if (szLabel[0])
                            MySetVolumeLabel(iFormatDrive, FALSE, szLabel);

                        if (fFormatFlags & FF_ONLYONE) {
                            fFormatFlags &= ~FF_ONLYONE;    // clear the flag
                            EndDialog(hDlg, TRUE);
                        } else {
                            SetDlgItemText(hDlg, IDD_NAME, szNULL); // clear it

                            LoadString(hAppInstance, IDS_FORMATCOMPLETE, szTitle, sizeof(szTitle));
                            LoadString(hAppInstance, IDS_FORMATANOTHER, szMessage, sizeof(szMessage));

                            wsprintf(szBuf, szMessage, GetTotalDiskSpace((WORD)iFormatDrive), GetFreeDiskSpace((WORD)iFormatDrive));

                            if (MessageBox(hDlg, szBuf, szTitle, MB_ICONEXCLAMATION | MB_YESNO | MB_DEFBUTTON2) != IDYES) {
                                EndDialog(hDlg, TRUE);
                            }
                        }
#if 0
                        // this doesn't work quite right

                        // refresh all windows open on this drive

                        for (hwnd = GetWindow(hwndMDIClient, GW_CHILD);
                            hwnd;
                            hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

                            // refresh windows on this drive

                            if (iFormatDrive == (INT)GetWindowLong(hwnd, GWL_TYPE))
                                SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);

                        }
#endif

                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}


/*--------------------------------------------------------------------------*/
/*                                                                            */
/*  ProgressDlgProc() -                                                     */
/*                                                                            */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ProgressDlgProc(
               register HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    switch (wMsg) {
        case WM_INITDIALOG:
            /* Check if this is the dialog for DISKCOPY */
            if (GetDlgItem(hDlg, IDD_DRIVE)) {
                /* Yes! Then, tell the user the drive we are copying from. */
                LoadString(hAppInstance, IDS_DRIVETEMP, szTitle, sizeof(szTitle));
                wsprintf(szMessage, szTitle, (CHAR)('A' + iCurrentDrive), '.');
                SetDlgItemText(hDlg, IDD_DRIVE, szMessage);
            }
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDCANCEL:
                    bUserAbort = TRUE;
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


// update all the windows and things after drives have been connected
// or disconnected.

VOID
APIENTRY
UpdateConnections()
{
    HWND hwnd, hwndNext;
    INT i, iDrive;
    HCURSOR hCursor;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    cDrives = UpdateDriveList();    // updates rgiDrive[]
    InitDriveBitmaps();

    // close all windows that have the current drive set to
    // the one we just disconnected

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = hwndNext) {

        hwndNext = GetWindow(hwnd, GW_HWNDNEXT);

        // ignore the titles and search window
        if (GetWindow(hwnd, GW_OWNER) || hwnd == hwndSearch)
            continue;

        iDrive = GetWindowLong(hwnd, GWL_TYPE);

        if (IsValidDisk(iDrive)) {
            // refresh drive bar only
            SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
        } else {
            // this drive has gone away
            if (IsLastWindow()) {
                // disconecting the last drive
                // set this guy to the first non floppy
                for (i = 0; i < cDrives; i++) {
                    if (!IsRemovableDrive(rgiDrive[i])) {
                        SendMessage(HasDrivesWindow(hwnd), FS_SETDRIVE, i, 0L);
                        break;
                    }
                }
            } else
                SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
        }
    }
    ShowCursor(FALSE);
    SetCursor(hCursor);
}


BOOL
DisconnectDrive(
               HWND hDlg,
               INT iDrive
               )
{
    CHAR szTemp[MAXPATHLEN];
    CHAR szDrive[5];
    INT ret, nIsNet;

    // don't allow disconnecting from the system directory

    GetSystemDirectory(szTemp, sizeof(szTemp));
    SheChangeDir(szTemp);        // to fix confused lanman

    if (iDrive == (INT)(*szTemp - 'A')) {
        LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, IDS_NETDISCONWINERR, szMessage, sizeof(szMessage));
        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        return FALSE;
    }

    lstrcpy(szDrive, "A:");
    szDrive[0] = (CHAR)('A'+iDrive);

    nIsNet = IsNetDrive((WORD)iDrive);
    ret = WNetCancelConnection(szDrive, FALSE);     // don't force this

    // remove from the permanent connection list (even in error case)
    WriteProfileString(szNetwork, szDrive, szNULL);

    if (nIsNet != 2 && ret != WN_SUCCESS && ret != WN_NOT_CONNECTED) {

        LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));

        if (ret == WN_OPEN_FILES)
            LoadString(hAppInstance, (UINT)IDS_NETDISCONOPEN, szMessage, sizeof(szMessage));
        else
            WNetErrorText((WORD)ret, szMessage, sizeof(szMessage));

        MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        return FALSE;
    }
    return TRUE;
}


VOID
FillDrives(
          HWND hDlg
          )
{
    INT i, iDrive, count = 0;
    CHAR szDrive[4];
    CHAR szTemp[120];
    HWND hwndLB, hwndCB;

    hwndLB = GetDlgItem(hDlg, IDD_DRIVE1);
    hwndCB = GetDlgItem(hDlg, IDD_DRIVE);

    SendMessage(hwndCB, CB_RESETCONTENT, 0, 0L);
    SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

    // fill the list of drives to connect to...

    lstrcpy(szDrive, "A:");

    iDrive = 0;
    for (i = 0; i < 26; i++) {
        if (rgiDrive[iDrive] == i) {
            iDrive++;
        } else {
            if (i == 1)
                continue;        // skip B:?

            szDrive[0] = (CHAR)('A'+i);

            // WN_BAD_LOCALNAME means the drive is not sutable for
            // making a connection to (lastdrive limit, etc).

            if (WFGetConnection(szDrive, szTemp, TRUE) == WN_BAD_LOCALNAME)
                continue;

            SendMessage(hwndCB, CB_INSERTSTRING, -1, (LPARAM)szDrive);
        }
    }

    SendMessage(hwndCB, CB_SETCURSEL, 0, 0L);

    SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
    for (i = 0; i < cDrives; i++) {
        if (IsRemoteDrive(rgiDrive[i])) {

            szDrive[0] = szTemp[0] = (CHAR)('A' + rgiDrive[i]);
            szDrive[1] = szTemp[1] = ':';
            szDrive[2] = szTemp[2] = 0;
            szTemp[2] = ' ';

            if (WFGetConnection(szDrive, szTemp+3, FALSE) != WN_SUCCESS)
                continue;

            count++;
            SendMessage(hwndLB, LB_INSERTSTRING, -1, (LPARAM)szTemp);
        }
    }
    SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(hwndLB, NULL, TRUE);

    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);

    EnableWindow(GetDlgItem(hDlg, IDD_DISCONNECT), count);
}

LPSTR pszPrevPath;

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConnectDlgProc() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
ConnectDlgProc(
              register HWND hDlg,
              UINT wMsg,
              WPARAM wParam,
              LPARAM lParam
              )
{
    BOOL              bPrevs;
    CHAR              szDrive[4];
    CHAR              szPath[WNBD_MAX_LENGTH], szPathSave[WNBD_MAX_LENGTH];
    CHAR              szPassword[32];
    HCURSOR           hCursor;

    switch (wMsg) {
        case WM_INITDIALOG:
            hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            ShowCursor(TRUE);

            FillDrives(hDlg);

            if (!(WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_BROWSEDIALOG))
                EnableWindow(GetDlgItem(hDlg, IDD_NETBROWSE), FALSE);

            SendDlgItemMessage(hDlg, IDD_PATH, EM_LIMITTEXT, sizeof(szPath)-1, 0L);
            SendDlgItemMessage(hDlg, IDD_PASSWORD, EM_LIMITTEXT, sizeof(szPassword)-1, 0L);

            /* Are there any Previous connections? */
            bPrevs = (GetPrivateProfileString(szPrevious, NULL, szNULL,
                                              szPath, sizeof(szPath)-1, szTheINIFile) != 0);

            EnableWindow(GetDlgItem(hDlg, IDD_PREV), bPrevs);

            ShowCursor(FALSE);
            SetCursor(hCursor);
            break;

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDOK:
                    {
                        HCURSOR   L_hCursor;
                        LPSTR p;
                        UINT  id;

                        L_hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                        ShowCursor(TRUE);

                        GetDlgItemText(hDlg, IDD_DRIVE, szDrive, sizeof(szDrive));
                        GetDlgItemText(hDlg, IDD_PATH, szPath, sizeof(szPath));
                        GetDlgItemText(hDlg, IDD_PASSWORD, szPassword, sizeof(szPassword));
                        lstrcpy(szPathSave, szPath);  // may have comments

                        // support saving extra stuff after the first double space
                        // put a NULL in at the first double space

                        p = szPath;
                        while (*p && *p != ' ')
                            p = AnsiNext(p);
                        if (*(p + 1) == ' ')
                            *p = 0;

                        if ((id = WNetAddConnection(szPath, szPassword, szDrive)) != WN_SUCCESS) {
                            ShowCursor(FALSE);
                            SetCursor(L_hCursor);

                            LoadString(hAppInstance, IDS_NETERR, szTitle, sizeof(szTitle));
                            WNetErrorText(id, szMessage, sizeof(szMessage));
                            MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                            break;
                        }

                        UpdateConnections();
                        InvalidateVolTypes();

                        FillDrives(hDlg);

                        SetDlgItemText(hDlg, IDD_PATH, szNULL);
                        SetDlgItemText(hDlg, IDD_PASSWORD, szNULL);

                        // always add to previous...
                        WritePrivateProfileString(szPrevious, szPathSave, szNULL, szTheINIFile);

                        // store the connection in win.ini for reconect at
                        // startup if the winnet driver does not support this
                        // itself
                        //
                        // allow SHIFT to make the connection not permenent

                        if (!(WNetGetCaps(WNNC_CONNECTION) & WNNC_CON_RESTORECONNECTION) &&
                            (GetKeyState(VK_SHIFT) >= 0))
                            WriteProfileString(szNetwork, szDrive, szPath);

                        ShowCursor(FALSE);
                        SetCursor(L_hCursor);
                        break;
                    }

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    break;

                case IDD_NETBROWSE:

                    //	          if (WNetBrowseDialog(hDlg, WNBD_CONN_DISKTREE, szPath) == WN_SUCCESS)
                    //                      SetDlgItemText(hDlg, IDD_PATH, szPath);
                    break;

                case IDD_DISCONNECT:

                    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
                    ShowCursor(TRUE);

                    wParam = (WPARAM)SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_GETCURSEL, 0, 0L);
                    SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_GETTEXT, wParam, (LPARAM)szPath);

                    if (DisconnectDrive(hDlg, (INT)(szPath[0] - 'A'))) {
                        SendDlgItemMessage(hDlg, IDD_DRIVE1, LB_DELETESTRING, wParam, 0L);
                        UpdateConnections();
                        FillDrives(hDlg);
                        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_PATH), 1L);
                    }

                    ShowCursor(FALSE);
                    SetCursor(hCursor);
                    break;

                case IDD_PREV:
                    {
                        DWORD dwSave = dwContext;

                        dwContext = IDH_DLG_PREV;

                        pszPrevPath = szPath;

                        if (DialogBox(hAppInstance, MAKEINTRESOURCE(PREVIOUSDLG), hDlg, PreviousDlgProc) > 0) {
                            SetDlgItemText(hDlg, IDD_PATH, pszPrevPath);
                            GetPrivateProfileString(szPrevious, pszPrevPath, szNULL, szPassword, 12, szTheINIFile);
                            SetDlgItemText(hDlg, IDD_PASSWORD, szNULL);
                            SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDD_PASSWORD), 1L);
                        }
                        dwContext = dwSave;
                        break;
                    }

                case IDD_DRIVE:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE) {
                        if (GetDlgItemText(hDlg,IDD_DRIVE,szDrive,3)) {
                            if (WFGetConnection(szDrive,szPath,FALSE) == WN_SUCCESS)
                                SetDlgItemText(hDlg,IDD_PATH,szPath);
                        }
                    }
                    break;

                case IDD_PATH:
                    if (!(wParam = GetDlgItemText(hDlg,IDD_PATH,szPath,64)) &&
                        GetFocus()==GetDlgItem(hDlg, IDOK))
                        SendMessage(hDlg, WM_NEXTDLGCTL,
                                    (WPARAM)GetDlgItem(hDlg, IDCANCEL), 1L);
                    EnableWindow(GetDlgItem(hDlg,IDOK),wParam ? TRUE : FALSE);
                    SendMessage(hDlg, DM_SETDEFID, wParam ? IDOK : IDCANCEL, 0L);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}

INT_PTR
APIENTRY
DrivesDlgProc(
             HWND hDlg,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT nDrive, iSel;
    HWND hwndDrives, hwndActive;
    CHAR szTemp[MAXPATHLEN];
    CHAR szVolShare[MAXPATHLEN];

    UNREFERENCED_PARAMETER(lParam);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                INT nCurDrive;
                INT nIndex;

                nCurDrive = GetSelectedDrive();
                nIndex = 0;

                for (nDrive=0; nDrive < cDrives; nDrive++) {

                    if (IsRemovableDrive(rgiDrive[nDrive])) // avoid flopies
                        szVolShare[0] = (CHAR)NULL;
                    else
                        GetVolShare((WORD)rgiDrive[nDrive], szVolShare);

                    if (nCurDrive == rgiDrive[nDrive])
                        nIndex = nDrive;

                    wsprintf(szTemp, "%c: %s", rgiDrive[nDrive] + 'A', (LPSTR)szVolShare);

                    SendDlgItemMessage(hDlg, IDD_DRIVE, LB_ADDSTRING, 0, (LPARAM)szTemp);
                }
                SendDlgItemMessage(hDlg, IDD_DRIVE, LB_SETCURSEL, nIndex, 0L);
                break;
            }

        case WM_COMMAND:

            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_DRIVE:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                        break;

                    // fall through
                case IDOK:
                    iSel = (INT)SendDlgItemMessage(hDlg, IDD_DRIVE, LB_GETCURSEL, 0, 0L);
                    EndDialog(hDlg, TRUE);

                    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                    if (hwndDrives = HasDrivesWindow(hwndActive)) {
                        SendMessage(hwndDrives, FS_SETDRIVE, iSel, 0L);
                    }
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

            }
            break;
        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}




/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PreviousDlgProc() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
PreviousDlgProc(
               register HWND hDlg,
               UINT wMsg,
               WPARAM wParam,
               LPARAM lParam
               )
{
    HWND hwndLB;
    INT iSel;
    CHAR szTemp[64];

    hwndLB = GetDlgItem(hDlg, IDD_PREV);

    switch (wMsg) {
        case WM_INITDIALOG:
            {
                WORD      nSize;
                LPSTR      pstrT;
                LPSTR      szBuffer;

                /*** FIX30: We should be able to process a partial buffer here. ***/

                /* Get the connections out of WINFILE.INI. */
                nSize = 256;
                if (!(szBuffer = (LPSTR)LocalAlloc(LPTR, nSize))) {
                    PreviousDlgExit:
                    EndDialog(hDlg, FALSE);
                    break;
                }

                while ((INT)GetPrivateProfileString(szPrevious,
                                                    NULL, szNULL,
                                                    szBuffer, nSize,
                                                    szTheINIFile) == (INT)nSize-2) {
                    nSize += 512;
                    LocalFree((HANDLE)szBuffer);
                    if (!(szBuffer = (LPSTR)LocalAlloc(LPTR, nSize)))
                        goto PreviousDlgExit;
                }

                /* Put the connections into the list box. */
                pstrT = szBuffer;
                while (*pstrT) {
                    SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)pstrT);
                    while (*pstrT)
                        pstrT++;
                    pstrT++;
                }

                LocalFree((HANDLE)szBuffer);

                SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
                break;
            }

        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
                case IDD_HELP:
                    goto DoHelp;

                case IDD_DELETE:
                    iSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (iSel == LB_ERR)
                        break;
                    SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)szTemp);
                    SendMessage(hwndLB, LB_DELETESTRING, iSel, 0L);
                    SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
                    WritePrivateProfileString(szPrevious, szTemp, NULL, szTheINIFile);
                    break;

                case IDD_PREV:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                        return FALSE;
                    /*** FALL THRU ***/

                case IDOK:
                    // return the selection through this global

                    *pszPrevPath = TEXT('\0');
                    iSel = (INT)SendMessage(hwndLB, LB_GETCURSEL, 0, 0L);
                    if (iSel != LB_ERR)
                        SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)pszPrevPath);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:

            if (wMsg == wHelpMessage) {
                DoHelp:
                WFHelp(hDlg);

                return TRUE;
            } else
                return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfext.h ===
//
// File Manager Extensions definitions
//

#define MENU_TEXT_LEN       40

#define FMMENU_FIRST        1
#define FMMENU_LAST     99

#define FMEVENT_LOAD        100
#define FMEVENT_UNLOAD      101
#define FMEVENT_INITMENU    102
#define FMEVENT_USER_REFRESH    103
#define FMEVENT_SELCHANGE        104

#define FMFOCUS_DIR                1
#define FMFOCUS_TREE                2
#define FMFOCUS_DRIVES                3
#define FMFOCUS_SEARCH                4

#define FM_GETFOCUS     (WM_USER + 0x0200)
#define FM_GETDRIVEINFO     (WM_USER + 0x0201)
#define FM_GETSELCOUNT      (WM_USER + 0x0202)
#define FM_GETSELCOUNTLFN   (WM_USER + 0x0203)  // LFN versions are odd
#define FM_GETFILESEL       (WM_USER + 0x0204)
#define FM_GETFILESELLFN    (WM_USER + 0x0205)  // LFN versions are odd
#define FM_REFRESH_WINDOWS  (WM_USER + 0x0206)
#define FM_RELOAD_EXTENSIONS    (WM_USER + 0x0207)

typedef struct _FMS_GETFILESEL {
    FILETIME ftTime;
    DWORD dwSize;
    BYTE bAttr;
    CHAR szName[260];       // alwyas fully qualified
} FMS_GETFILESEL, FAR *LPFMS_GETFILESEL;

typedef struct _FMS_GETDRIVEINFO {  // for drive
    DWORD dwTotalSpace;
    DWORD dwFreeSpace;
    CHAR szPath[260];       // current directory
    CHAR szVolume[14];      // volume label
    CHAR szShare[128];      // if this is a net drive
} FMS_GETDRIVEINFO, FAR *LPFMS_GETDRIVEINFO;

typedef struct _FMS_LOAD {
    DWORD dwSize;               // for version checks
    CHAR  szMenuName[MENU_TEXT_LEN];    // output
    HMENU hMenu;                // output
    WORD  wMenuDelta;           // input
} FMS_LOAD, FAR *LPFMS_LOAD;


typedef INT_PTR (APIENTRY *FM_EXT_PROC)(HWND, WPARAM, LPARAM);
typedef DWORD (APIENTRY *FM_UNDELETE_PROC)(HWND, LPSTR);


//------------------ private stuff ---------------------------        /* ;Internal */
                                                                /* ;Internal */
typedef struct _EXTENSION {                                        /* ;Internal */
        INT_PTR (APIENTRY *ExtProc)(HWND, WPARAM, LPARAM);                /* ;Internal */
        WORD        Delta;                                                /* ;Internal */
        HANDLE        hModule;                                        /* ;Internal */
        HMENU         hMenu;                                                /* ;Internal */
        DWORD   dwFlags;                                        /* ;Internal */
} EXTENSION;                                                        /* ;Internal */
                                                                /* ;Internal */
#define MAX_EXTENSIONS 5                                        /* ;Internal */
extern EXTENSION extensions[MAX_EXTENSIONS];                        /* ;Internal */
                                                                /* ;Internal */
INT_PTR APIENTRY ExtensionMsgProc(UINT wMsg, WPARAM wParam, LPARAM lpSel);/* ;Internal */
VOID APIENTRY FreeExtensions(VOID);                                     /* ;Internal */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfdrives.c ===
//---------------------------------------------------------------------------
//
// wfdrives.c
//
// window procs and other stuff for the drive bar
//
//---------------------------------------------------------------------------

#define PUBLIC           // avoid collision with shell.h
#include "winfile.h"
#include "treectl.h"
#include "lfn.h"
#include "wfcopy.h"
#include "winnet.h"
#include <winnetp.h>


VOID InvalidateDrive(HWND hwnd, INT nDrive);
VOID RectDrive(HWND hWnd, INT nDrive, BOOL bFocusOn);
VOID GetDriveRect(HWND hWnd, INT nDrive, PRECT prc);
INT  DriveFromPoint(HWND hWnd, POINT pt);
VOID DrawDrive(HDC hdc, INT x, INT y, INT nDrive, BOOL bCurrent, BOOL bFocus);
INT  KeyToItem(HWND hWnd, WORD nDriveLetter);

VOID  GetVolShareString(WORD wDrive, LPSTR szStr);
VOID  SetVolumeString(HWND hWnd, INT nDrive);

VOID  APIENTRY CheckEscapes(LPSTR);

// create a new split tree window for the given drive
// and inherit all the properties of the current window
// the current directory is set to the DOS current directory
// for this drive.  note, this can be somewhat random given
// that windows does not keep this info for each app (it is
// global to the system)
//
// in:
//      iDrive  the driver number to create the window for
//      hwndSrc    the window to take all the properties from
//

VOID
APIENTRY
NewTree(
       INT iDrive,
       HWND hwndSrc
       )
{
    HWND hwnd, hwndTree, hwndDir;
    CHAR szDir[MAXPATHLEN * 2];
    INT dxSplit;

    ENTER("NewTree");
    PRINT(BF_PARMTRACE, "iDrive=%d", IntToPtr(iDrive));

    // make sure the floppy/net drive is still valid

    if (!CheckDrive(hwndSrc, iDrive))
        return;

    if (hwndSrc == hwndSearch)
        dxSplit = -1;
    else {
        hwndTree = HasTreeWindow(hwndSrc);
        hwndDir = HasDirWindow(hwndSrc);

        if (hwndTree && hwndDir)
            dxSplit = GetWindowLong(hwndSrc, GWL_SPLIT);
        else if (hwndDir)
            dxSplit = 0;
        else
            dxSplit = 10000;
    }

    // take all the attributes from the current window
    // (except the filespec, we may want to change this)
    wNewSort     = (WORD)GetWindowLong(hwndSrc, GWL_SORT);
    wNewView     = (WORD)GetWindowLong(hwndSrc, GWL_VIEW);
    dwNewAttribs = (DWORD)GetWindowLong(hwndSrc, GWL_ATTRIBS);

    GetSelectedDirectory((WORD)(iDrive + 1), szDir);
    AddBackslash(szDir);
    SendMessage(hwndSrc, FS_GETFILESPEC, MAXPATHLEN, (LPARAM)szDir+lstrlen(szDir));

    hwnd = CreateTreeWindow(szDir, dxSplit);

    if (hwnd && (hwndTree = HasTreeWindow(hwnd)))
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);

    LEAVE("NewTree");
}



VOID
SetVolumeString(
               HWND hWnd,
               INT nDrive
               )
{
    LPSTR pVol;
    CHAR szVolShare[128];

    // clean up any old label

    if (pVol = (LPSTR)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME)) {
        LocalFree((HANDLE)pVol);
    }

    GetVolShareString((WORD)nDrive, szVolShare);

    if (pVol = (LPSTR)LocalAlloc(LPTR, lstrlen(szVolShare)+1))
        lstrcpy(pVol, szVolShare);

    SetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME, (LONG_PTR)pVol);
}



VOID
GetVolShareString(
                 WORD wDrive,
                 LPSTR szStr
                 )
{
    CHAR szVolShare[128];

    GetVolShare(wDrive, szVolShare);
    wsprintf(szStr, "%c: %s", wDrive + 'A', (LPSTR)szVolShare);
}


DWORD
APIENTRY
GetVolShareExtent(
                 HWND hwndDrives
                 )
{
    HDC hdc;
    CHAR szVolShare[128];
    HFONT hOld;
    INT i;

    lstrcpy(szVolShare, (LPSTR)GetWindowLongPtr(hwndDrives, GWLP_LPSTRVOLUME));

    hdc = GetDC(hwndDrives);

    hOld = SelectObject(hdc, hFont);

    MGetTextExtent(hdc, szVolShare, lstrlen(szVolShare), &i, NULL);

    if (hOld)
        SelectObject(hdc, hOld);

    ReleaseDC(hwndDrives, hdc);

    return ((DWORD)i);
}


VOID
GetDriveRect(
            HWND hWnd,
            INT nDrive,
            PRECT prc
            )
{
    RECT rc;
    INT nDrivesPerRow;

    GetClientRect(hWnd, &rc);

    if (!dxDrive)           // avoid div by zero
        dxDrive++;

    nDrivesPerRow = rc.right / dxDrive;

    if (!nDrivesPerRow)     // avoid div by zero
        nDrivesPerRow++;

    prc->top = dyDrive * (nDrive / nDrivesPerRow);
    prc->bottom = prc->top + dyDrive;

    prc->left = dxDrive * (nDrive % nDrivesPerRow);
    prc->right = prc->left + dxDrive;
}

INT
DriveFromPoint(
              HWND hWnd,
              POINT pt
              )
{
    RECT rc, rcDrive;
    INT x, y, nDrive;

    GetClientRect(hWnd, &rc);

    x = 0;
    y = 0;
    nDrive = 0;

    for (nDrive = 0; nDrive < cDrives; nDrive++) {
        rcDrive.left = x;
        rcDrive.right = x + dxDrive;
        rcDrive.top = y;
        rcDrive.bottom = y + dyDrive;
        InflateRect(&rcDrive, -dyBorder, -dyBorder);

        if (PtInRect(&rcDrive, pt))
            return nDrive;

        x += dxDrive;

        if (x + dxDrive > rc.right) {
            x = 0;
            y += dyDrive;
        }
    }

    return -1;      // no hit
}

VOID
InvalidateDrive(
               HWND hwnd,
               INT nDrive
               )
{
    RECT rc;

    GetDriveRect(hwnd, nDrive, &rc);
    InvalidateRect(hwnd, &rc, TRUE);
}


//
// void RectDrive(HWND hWnd, int nDrive, BOOL bDraw)
//
// draw the hilight rect around the drive to indicate that it is
// the target of a drop action.
//
// in:
//      hWnd    Drives window
//      nDrive  the drive to draw the rect around
//      bDraw   if TRUE, draw a rect around this drive
//              FALSE, erase the rect (draw the default rect)
//

VOID
RectDrive(
         HWND hWnd,
         INT nDrive,
         BOOL bDraw
         )
{
    RECT rc, rcDrive;
    HBRUSH hBrush;
    HDC hdc;

    GetDriveRect(hWnd, nDrive, &rc);
    rcDrive = rc;
    InflateRect(&rc, -dyBorder, -dyBorder);

    if (bDraw) {

        hdc = GetDC(hWnd);

        hBrush = CreateSolidBrush(GetSysColor(COLOR_WINDOWTEXT));
        if (hBrush) {
            FrameRect(hdc, &rc, hBrush);
            DeleteObject(hBrush);
        }
        ReleaseDC(hWnd, hdc);

    } else {
        InvalidateRect(hWnd, &rcDrive, TRUE);
        UpdateWindow(hWnd);
    }
}

//
// void DrawDrive(HDC hdc, int x, int y, int nDrive, BOOL bCurrent, BOOL bFocus)
//
// paint the drive icons in the standard state, given the
// drive with the focus and the current selection
//
// in:
//      hdc             dc to draw to
//      x, y            position to start (dxDrive, dyDrive are the extents)
//      nDrive          the drive to paint
//      bCurrent        draw as the current drive (pushed in)
//      bFocus          draw with the focus
//

VOID
DrawDrive(
         HDC hdc,
         INT x,
         INT y,
         INT nDrive,
         BOOL bCurrent,
         BOOL bFocus
         )
{
    RECT rc;
    CHAR szTemp[2];
    DWORD rgb;

    rc.left = x;
    rc.right = x + dxDrive;
    rc.top = y;
    rc.bottom = y + dyDrive;

    rgb = GetSysColor(COLOR_BTNTEXT);

    if (bCurrent) {
        HBRUSH hbr;

        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
        if (hbr) {
            if (bFocus) {
                rgb = GetSysColor(COLOR_HIGHLIGHTTEXT);
                FillRect(hdc, &rc, hbr);
            } else {
                InflateRect(&rc, -dyBorder, -dyBorder);
                FrameRect(hdc, &rc, hbr);
            }
            DeleteObject(hbr);
        }
    }

    if (bFocus)
        DrawFocusRect(hdc, &rc);


    szTemp[0] = (CHAR)(chFirstDrive + rgiDrive[nDrive]);

    SetBkMode(hdc, TRANSPARENT);

    rgb = SetTextColor(hdc, rgb);
    TextOut(hdc, x + dxDriveBitmap+(dyBorder*6), y + (dyDrive - dyText) / 2, szTemp, 1);
    SetTextColor(hdc, rgb);

    BitBlt(hdc, x + 4*dyBorder, y + (dyDrive - dyDriveBitmap) / 2, dxDriveBitmap, dyDriveBitmap,
           hdcMem, rgiDrivesOffset[nDrive], 2 * dyFolder, SRCCOPY);
}


// check net/floppy drives for validity, sets the net drive bitmap
// when the thing is not available
//
// note: IsTheDiskReallyThere() has the side effect of setting the
// current drive to the new disk if it is successful

BOOL
CheckDrive(
          HWND hwnd,
          INT nDrive
          )
{
    UINT err;
    CHAR szDrive[5];
    int iDriveInd;
    return TRUE;
}


VOID
DrivesDropObject(
                HWND hWnd,
                LPDROPSTRUCT lpds
                )
{
    INT nDrive;
    CHAR szPath[MAXPATHLEN * 2];
    PSTR pFrom;
    BOOL bIconic;

    bIconic = IsIconic(GetParent(hWnd));

    if (bIconic) {
        UseCurDir:
        SendMessage(GetParent(hWnd), FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
    } else {

        nDrive = DriveFromPoint(hWnd, lpds->ptDrop);

        if (nDrive < 0)
            goto UseCurDir;
        // this searches windows in the zorder then asks dos
        // if nothing is found...

        GetSelectedDirectory((WORD)(rgiDrive[nDrive] + 1), szPath);
    }
    AddBackslash(szPath);           // add spec part
    lstrcat(szPath, szStarDotStar);

    pFrom = (PSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

    CheckEscapes(szPath);
    DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

    if (!bIconic)
        RectDrive(hWnd, nDrive, FALSE);
}


VOID
DrivesPaint(
           HWND hWnd,
           INT nDriveFocus,
           INT nDriveCurrent
           )
{
    RECT rc;
    INT nDrive;
    CHAR szPath[MAXPATHLEN * 2];

    HDC hdc;
    PAINTSTRUCT ps;
    DWORD dw;
    WORD dxAfterDrives;
    INT x, y;
    HANDLE hOld;
    INT cDriveRows, cDrivesPerRow;

    GetClientRect(hWnd, &rc);

    if (!rc.right)
        return;

    hdc = BeginPaint(hWnd, &ps);

    hOld = SelectObject(hdc, hFont);

    cDrivesPerRow = rc.right / dxDrive;

    if (!cDrivesPerRow)
        cDrivesPerRow++;

    cDriveRows = ((cDrives-1) / cDrivesPerRow) + 1;

    x = 0;
    y = 0;
    for (nDrive = 0; nDrive < cDrives; nDrive++) {

        if (GetFocus() != hWnd)
            nDriveFocus = -1;

        DrawDrive(hdc, x, y, nDrive, nDriveCurrent == nDrive, nDriveFocus == nDrive);
        x += dxDrive;

        if (x + dxDrive > rc.right) {
            x = 0;
            y += dyDrive;
        }
    }

    // now figure out where to put that stupid volume string

    lstrcpy(szPath, (PSTR)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME));

    MGetTextExtent(hdc, szPath, lstrlen(szPath), (INT *)&dw, NULL);

    dxAfterDrives = (WORD)(rc.right - x);

    // does it fit after the drives in the last row?

    if (dxAfterDrives < LOWORD(dw)) {
        x = dxText;               // no, flush left
        y = rc.bottom - dyText - dyBorderx2;
    } else {
        x += (dxAfterDrives - LOWORD(dw)) / 2;    // yes, centered
        y = rc.bottom - (dyDrive + dyText) / 2;
    }

    SetBkMode(hdc, TRANSPARENT);

    TextOut(hdc, x, y, szPath, lstrlen(szPath));

    if (hOld)
        SelectObject(hdc, hOld);

    EndPaint(hWnd, &ps);
}

// set the current window to a new drive
//
//

VOID
DrivesSetDrive(
              HWND hWnd,
              INT iDriveInd,
              INT nDriveCurrent
              )
{
    CHAR szPath[MAXPATHLEN * 2];

    HWND        hwndTree;
    HWND        hwndDir;

    InvalidateRect(hWnd, NULL, TRUE);

    // save the current directory on this drive for later so
    // we don't have to hit the drive to get the current directory
    // and other apps won't change this out from under us

    GetSelectedDirectory(0, szPath);
    SaveDirectory(szPath);

    // this also sets the current drive if successful

    if (!CheckDrive(hWnd, rgiDrive[iDriveInd]))
        return;

    // cause current tree read to abort if already in progress

    hwndTree = HasTreeWindow(GetParent(hWnd));
    if (hwndTree && GetWindowLong(hwndTree, GWL_READLEVEL)) {

        // bounce any clicks on a drive that is currently being read

        if (iDriveInd != nDriveCurrent)
            bCancelTree = TRUE;
        return;
    }

    // do again after in case a dialog cause the drive bar
    // to repaint

    InvalidateRect(hWnd, NULL, TRUE);

    // get this from our cache if possible

    GetSelectedDirectory((WORD)(rgiDrive[iDriveInd] + 1), szPath);

    // set the drives window parameters and repaint

    SetWindowLong(hWnd, GWL_CURDRIVEIND, iDriveInd);
    SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, iDriveInd);
    SetVolumeString(hWnd, rgiDrive[iDriveInd]);

    // this is set in TC_SETDRIVE as well but the FS_CHANGEDISPLAY
    // likes to have this set before for the UpdateStatus() call

    SetWindowLong(GetParent(hWnd), GWL_TYPE, rgiDrive[iDriveInd]);

    // reset the dir first to allow tree to steal data
    // if szPath is not valid the TC_SETDRIVE will reinit
    // the files half (if there is no tree we are dicked)

    if (hwndDir = HasDirWindow(GetParent(hWnd))) {

        AddBackslash(szPath);
        SendMessage(hwndDir, FS_GETFILESPEC, MAXFILENAMELEN, (LPARAM)szPath + lstrlen(szPath));
        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH_FORCE, (LPARAM)szPath);

        StripFilespec(szPath);
    }

    // do this before TC_SETDRIVE incase the tree read
    // is aborted and lFreeSpace gets set to -2L

    lFreeSpace = -1L;   // force status info refresh

    // tell the tree control to do it's thing
    if (hwndTree)
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(GetKeyState(VK_SHIFT) < 0, 0), (LPARAM)(szPath));
    else { // at least resize things
        RECT rc;
        GetClientRect(GetParent(hWnd), &rc);
        ResizeWindows(GetParent(hWnd),(WORD)(rc.right+1),(WORD)(rc.bottom+1));
    }

    UpdateStatus(GetParent(hWnd));
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DrivesWndProc() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
DrivesWndProc(
             HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT nDrive, nDriveCurrent, nDriveFocus;
    RECT rc;
    static INT nDriveDoubleClick = -1;
    static INT nDriveDragging = -1;

    nDriveCurrent = GetWindowLong(hWnd, GWL_CURDRIVEIND);
    nDriveFocus = GetWindowLong(hWnd, GWL_CURDRIVEFOCUS);

    switch (wMsg) {
        case WM_CREATE:
            TRACE(BF_WM_CREATE, "DrivesWndProc - WM_CREATE");
            {
                INT i;

                // Find the current drive, set the drive bitmaps

                nDrive = GetWindowLong(GetParent(hWnd), GWL_TYPE);

                SetVolumeString(hWnd, nDrive);

                for (i=0; i < cDrives; i++) {

                    if (rgiDrive[i] == nDrive) {
                        SetWindowLong(hWnd, GWL_CURDRIVEIND, i);
                        SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, i);
                    }

                }
                break;
            }

        case WM_DESTROY:
            MSG("DrivesWndProc", "WM_DESTROY");
            LocalFree((HANDLE)GetWindowLongPtr(hWnd, GWLP_LPSTRVOLUME));
            break;

        case WM_VKEYTOITEM:
            KeyToItem(hWnd, (WORD)wParam);
            return -2L;
            break;

        case WM_KEYDOWN:
            MSG("DrivesWndProc", "WM_KEYDOWN");
            switch (wParam) {

                case VK_ESCAPE:
                    bCancelTree = TRUE;
                    break;

                case VK_F6:   // like excel
                case VK_TAB:
                    {
                        HWND hwndTree, hwndDir;
                        BOOL bDir;
                        DWORD dwTemp;

                        GetTreeWindows(GetParent(hWnd), &hwndTree, &hwndDir, NULL);

                        // Check to see if we can change to the directory window

                        bDir = hwndDir ? TRUE : FALSE;
                        if (bDir) {
                            HWND hwndLB; /* Local scope ONLY */

                            hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
                            if (hwndLB) {
                                SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &dwTemp);
                                bDir = dwTemp ? TRUE : FALSE;
                            }
                        }

                        if (GetKeyState(VK_SHIFT) < 0) {
                            if (bDir)
                                SetFocus (hwndDir);
                            else
                                SetFocus (hwndTree ? hwndTree : hWnd);
                        } else
                            SetFocus (hwndTree ? hwndTree :
                                      (bDir ? hwndDir : hWnd));
                        break;
                    }

                case VK_RETURN:               // same as double click
                    NewTree(rgiDrive[nDriveFocus], GetParent(hWnd));
                    break;

                case VK_SPACE:                // same as single click
                    SendMessage(hWnd, FS_SETDRIVE, nDriveFocus, 0L);
                    break;

                case VK_LEFT:
                    nDrive = max(nDriveFocus-1, 0);
                    break;

                case VK_RIGHT:
                    nDrive = min(nDriveFocus+1, cDrives-1);
                    break;
            }

            if ((wParam == VK_LEFT) || (wParam == VK_RIGHT)) {

                SetWindowLong(hWnd, GWL_CURDRIVEFOCUS, nDrive);

                GetDriveRect(hWnd, nDriveFocus, &rc);
                InvalidateRect(hWnd, &rc, TRUE);
                GetDriveRect(hWnd, nDrive, &rc);
                InvalidateRect(hWnd, &rc, TRUE);
            } else if ((wParam >= 'A') && (wParam <= 'Z'))
                KeyToItem(hWnd, (WORD)wParam);

            break;

        case FS_GETDRIVE:
            MSG("DrivesWndProc", "FS_GETDRIVE");
            {
                POINT pt;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                nDrive = DriveFromPoint(hWnd, pt);

                if (nDrive < 0)
                    nDrive = nDriveCurrent;

                return rgiDrive[nDrive] + 'A';
            }

        case WM_DRAGMOVE:
            MSG("DrivesWndProc", "WM_DRAGSELECT/WM_DRAGMOVE");

#define lpds ((LPDROPSTRUCT)lParam)

            nDrive = DriveFromPoint(hWnd, lpds->ptDrop);

#if 0
            {
                char buf[100];

                wsprintf(buf, "WM_DRAGSELECT nDrive=%d nDriveDragging=%d\r\n", nDrive, nDriveDragging);
                OutputDebugString(buf);
            }
#endif
            // turn off?

            if ((nDrive != nDriveDragging) && (nDriveDragging >= 0)) {

                RectDrive(hWnd, nDriveDragging, FALSE);
                nDriveDragging = -1;
            }

            // turn on?

            if ((nDrive >= 0) && (nDrive != nDriveDragging)) {
                RectDrive(hWnd, nDrive, TRUE);
                nDriveDragging = nDrive;
            }

            break;

        case WM_DRAGSELECT:
#define lpds ((LPDROPSTRUCT)lParam)

#if 0
            {
                char buf[100];

                wsprintf(buf, "WM_DRAGSELECT wParam=%d\r\n", wParam);
                OutputDebugString(buf);
            }
#endif
            if (wParam) {
                // entered, turn it on
                nDriveDragging = DriveFromPoint(hWnd, lpds->ptDrop);
                if (nDriveDragging >= 0)
                    RectDrive(hWnd, nDriveDragging, TRUE);
            } else {
                // leaving, turn it off
                if (nDriveDragging >= 0)
                    RectDrive(hWnd, nDriveDragging, FALSE);
            }

            break;

        case WM_QUERYDROPOBJECT:
            MSG("DrivesWndProc", "WM_QUERYDROPOBJECT");
            /* Validate the format. */
#define lpds ((LPDROPSTRUCT)lParam)

            // if (DriveFromPoint(hWnd, lpds->ptDrop) < 0)
            //    return FALSE;

            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_MULTIPLE:
                case DOF_DOCUMENT:
                    return (INT_PTR)GetMoveCopyCursor();
                default:
                    return FALSE;
            }
            break;

        case WM_DROPOBJECT:
            MSG("DrivesWndProc", "WM_DROPOBJECT");
            DrivesDropObject(hWnd, (LPDROPSTRUCT)lParam);
            return TRUE;

        case WM_SETFOCUS:
            MSG("DrivesWndProc", "WM_SETFOCUS");
            SetWindowLongPtr(GetParent(hWnd), GWLP_LASTFOCUS, (LPARAM)hWnd);
            // fall through

        case WM_KILLFOCUS:

            MSG("DrivesWndProc", "WM_KILLFOCUS");
            GetDriveRect(hWnd, nDriveFocus, &rc);
            InvalidateRect(hWnd, &rc, TRUE);
            break;

        case WM_PAINT:
            DrivesPaint(hWnd, nDriveFocus, nDriveCurrent);
            break;

        case WM_MDIACTIVATE:
            /*  we're not an MDI child, but the real MDI child proc
                is sending us this so we can handle the following problem.
                nDriveDoubleClick is static, and is shared by all the child window
                drivewindow instances.  If the user rapidly clicks two child window
                drivewindows, then we can mistakenly interpret the second click
                as a double click in the first window.
            */
            if (!wParam && (nDriveDoubleClick != -1))
                /* terminate wait for doubleclick, make it a single click */
                SendMessage(hWnd,WM_TIMER,1,0L);
            break;


        case WM_TIMER:
            MSG("DrivesWndProc", "WM_TIMER");

            KillTimer(hWnd, wParam);
            if (nDriveDoubleClick > -1)
                SendMessage(hWnd, FS_SETDRIVE, nDriveDoubleClick, 0L); // single click action

            nDriveDoubleClick = -1; // default

            break;

        case WM_LBUTTONDOWN:

            MSG("DrivesWndProc", "WM_LBUTTONDOWN");
            {
                POINT pt;

                MPOINT2POINT(MAKEMPOINT(lParam), pt);
                nDrive = DriveFromPoint(hWnd, pt);
                if (nDrive < 0)
                /* clicked outside of drive box */
                {
                    if (nDriveDoubleClick == -2)
                    /* legit doubleclick outside */
                    {
                        nDriveDoubleClick = -1; // default value
                        KillTimer(hWnd, 1);
                        PostMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_DRIVESMORE, 0, 0));
                    } else /* first click outside */ {
                        if (nDriveDoubleClick != -1) // fast click on drivebox then outside drivebox
                            KillTimer(hWnd, 1);
                        nDriveDoubleClick = -2; // see WM_TIMER
                        SetTimer(hWnd, 1, GetDoubleClickTime(), NULL);
                    }
                } else {
                    if (nDriveDoubleClick == nDrive)
                    /* double click in drivebox */
                    {
                        nDriveDoubleClick = -1; // default
                        KillTimer(hWnd, 1);

                        InvalidateRect(hWnd, NULL, TRUE);   // erase the rect from the click

                        NewTree(rgiDrive[nDrive], GetParent(hWnd)); // double click action
                    } else if (nDriveDoubleClick == -2) // fast click outside drive then in drivebox
                    {
                        KillTimer(hWnd, 1);
                        nDriveDoubleClick = -1;
                    } else { // legit first click in drivebox
                        nDriveDoubleClick = nDrive;
                        SetTimer(hWnd, 1, GetDoubleClickTime(), NULL);
                    }
                }
            }

            break;

        case FS_SETDRIVE:
            MSG("DrivesWndProc", "FS_SETDRIVE");
            // wParam     the drive index to set
            // lParam     not used

            DrivesSetDrive(hWnd, (WORD)wParam, nDriveCurrent);
            break;


        default:
            DEFMSG("DrivesWndProc", (WORD)wMsg);
            return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}

/* Returns nDrive if found, else -1 */
INT
KeyToItem(
         HWND hWnd,
         WORD nDriveLetter
         )
{
    INT nDrive;

    if (nDriveLetter > 'Z')
        nDriveLetter -= 'a';
    else
        nDriveLetter -= 'A';

    for (nDrive = 0; nDrive < cDrives; nDrive++) {
        if (rgiDrive[nDrive] == (int)nDriveLetter) {
            SendMessage(hWnd, FS_SETDRIVE, nDrive, 0L);
            return nDrive;
        }
    }
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wffile.c ===
/****************************************************************************/
/*                                      */
/*  WFFILE.C -                                          */
/*                                      */
/*  Ported code from wffile.asm                                         */
/*                                      */
/****************************************************************************/

#include "winfile.h"

WORD
APIENTRY
MKDir(
     LPSTR pName
     )
{
    WORD wErr = 0;

    if (CreateDirectory(pName, NULL)) {
        ChangeFileSystem(FSC_MKDIR,pName,NULL);
    } else {
        wErr = (WORD)GetLastError();
    }

    return (wErr);
}


WORD
APIENTRY
RMDir(
     LPSTR pName
     )
{
    WORD wErr = 0;

    if (RemoveDirectory(pName)) {
        ChangeFileSystem(FSC_RMDIR,pName,NULL);
    } else {
        wErr = (WORD)GetLastError();
    }

    return (wErr);
}



BOOL
APIENTRY
WFSetAttr(
         LPSTR lpFile,
         DWORD dwAttr
         )
{
    BOOL bRet;

    bRet = SetFileAttributes(lpFile,dwAttr);
    if (bRet)
        ChangeFileSystem(FSC_ATTRIBUTES,lpFile,NULL);

    return (BOOL)!bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfformat.c ===
/****************************************************************************/
/*                                                                          */
/*  WFFORMAT.C -                                                            */
/*                                                                          */
/*      Windows File Manager Diskette Formatting Routines                   */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"


/* MyGetDriveType() returns */
#define NOCHANGE            0
#define CHANGE              1

/* Parameter Block for IOCTL Format call */
struct FORMATPARAMS {
    BYTE   bSpl;                    /* Special byte */
    WORD   wHead;
    WORD   wCylinder;
};


typedef struct _MEDIASENSE {
    BYTE IsDefault;
    BYTE DeviceType;
    BYTE res[10];
} MEDIASENSE;


/*--------------------------------------------------------------------------*/
/*  BIOS Parameter Block Table for Removable Media                          */
/*--------------------------------------------------------------------------*/

/* Each entry contains data about a floppy drive type in the following format:
 *                                                          Length
 *      cbSec               - Bytes/Sector                    2
 *      secPerClus          - Sectors/Cluster                 1
 *      cSecRes             - # of Reserved Sectors           2
 *      cFAT                - # of FATs                       1
 *      cDir                - # of Root Directory Entries     2
 *      cSec                - # of Sectors on the disk        2
 *      bMedia              - Media Descriptor Byte           1
 *      secPerFAT           - Sectors/FAT                     2
 *      secPerTrack         - Sectors/Track                   2
 *      cHead               - # of Disk Heads                 2
 *      cSecHidden          - # of Hidden Sectors             2
 */

BPB     bpbList[] =
{
    {512, 1, 1, 2,  64,  1*8*40, MEDIA_160,  1,  8, 1, 0}, /*  8sec SS 48tpi 160KB 5.25" DOS 1.0 & above */
    {512, 2, 1, 2, 112,  2*8*40, MEDIA_320,  1,  8, 2, 0}, /*  8sec DS 48tpi 320KB 5.25" DOS 1.1 & above */
    {512, 1, 1, 2,  64,  1*9*40, MEDIA_180,  2,  9, 1, 0}, /*  9sec SS 48tpi 180KB 5.25" DOS 2.0 & above */
    {512, 2, 1, 2, 112,  2*9*40, MEDIA_360,  2,  9, 2, 0}, /*  9sec DS 48tpi 360KB 5.25" DOS 2.0 & above */
    {512, 1, 1, 2, 224, 2*15*80, MEDIA_1200, 7, 15, 2, 0}, /* 15sec DS 96tpi 1.2MB 5.25" DOS 3.0 & above */
    {512, 2, 1, 2, 112,  2*9*80, MEDIA_720,  3,  9, 2, 0}, /*  9sec DS 96tpi 720KB  3.5" DOS 3.2 & above */
    {512, 1, 1, 2, 224, 2*18*80, MEDIA_1440, 9, 18, 2, 0}, /* 18sec DS 96tpi 1.44M  3.5" DOS 3.3 & above */
    {512, 2, 1, 2, 240, 2*36*80, MEDIA_2880, 9, 36, 2, 0}  /* 36sec DS 96tpi 2.88M  3.5" DOS 5.0 & above */
};


/* Precompute the total number of usable clusters...
 *   cCluster = (cSec/secPerClus) - { cSecRes
 *                                    + (cFAT * secPerFat)
 *                                    + (cDir*32+cbSec-1)/cbSec }/secPerClus;
 */
WORD cCluster[] = {0x0139, 0x013B, 0x015F, 0x0162, 0x0943, 0x02C9, 0x0B1F, 0xB2F, 0};





/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BuildDevPB() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE
APIENTRY
BuildDevPB(
          PDevPB pDevPB
          )
{
    WORD              wCount;
    register HANDLE   hNewDevPB;
    PDevPB            pNewDevPB;
    WORD              wSecSize;
    register WORD     *wPtr;
    WORD              wTrackNumber;

    wCount = pDevPB->BPB.secPerTrack;

    if (!(hNewDevPB = LocalAlloc(LHND, TRACKLAYOUT_OFFSET+2+wCount*4)))
        return NULL;

    pNewDevPB = (PDevPB)LocalLock(hNewDevPB);

    memcpy(pNewDevPB, pDevPB, TRACKLAYOUT_OFFSET);
    wSecSize = pDevPB->BPB.cbSec;

    wPtr = (WORD *)((LPSTR)pNewDevPB + TRACKLAYOUT_OFFSET);
    *wPtr++ = wCount;

    for (wTrackNumber=1; wTrackNumber <= wCount; wTrackNumber++) {
        *wPtr++ = wTrackNumber;
        *wPtr++ = wSecSize;
    }

    LocalUnlock(hNewDevPB);
    return hNewDevPB;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetDevParamsForFormat() -                                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
SetDevParamsForFormat(
                     INT nDrive,
                     PDevPB pDevPB,
                     BOOL fLowCapacity
                     )
{
    HANDLE   hLocHandle;
    PDevPB   pNewDevPB;

    /* Allocate for the DPB with track layout */
    if (!(hLocHandle = BuildDevPB(pDevPB)))
        return FALSE;

    pNewDevPB = (PDevPB)LocalLock(hLocHandle);

    pNewDevPB->SplFunctions = 5;
    /* Is this a 360KB floppy in a 1.2Mb drive */
    if (fLowCapacity) {
        /* Yes! Then change the number of cylinders and Media type */
        /* Fix for Bug #???? --SANKAR-- 01-10-90 -- */
        pNewDevPB->NumCyls = 40;
        pNewDevPB->bMediaType = 1;
    }

    LocalUnlock(hLocHandle);
    LocalFree(hLocHandle);

    return TRUE;

}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GenericFormatTrack() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* This calls IOCTL format if DOS ver >= 3.2; Else calls BIOS.
 *
 *  Returns : 0 if no error
 *          > 0 if tolerable error (resuling in bad sectors);
 *          -1  if fatal error (Format has to be aborted);
 */

INT
APIENTRY
GenericFormatTrack(
                  WORD nDisk,
                  WORD wCylinder,
                  WORD wHead,
                  WORD wSecPerTrack,
                  LPSTR lpDiskBuffer
                  )
{
    struct FORMATPARAMS   FormatParams;
    INT                   iRetVal = -1;   /* FATAL Error by default */
    register INT          iErrCode;

#ifdef DEBUG
    wsprintf(szMessage, "Formatting Head #%d, Cylinder#%d\n\r", wHead, wCylinder);
    OutputDebugString(szMessage);
#endif

    /* Check the DOS version */
    if (wDOSversion >= DOS_320) {
        FormatParams.bSpl = 0;
        FormatParams.wHead = wHead;
        FormatParams.wCylinder = wCylinder;
        switch (iErrCode = 0) {
            case NOERROR:
            case CRCERROR:
            case SECNOTFOUND:
            case GENERALERROR:
                iRetVal = iErrCode;
                break;
        }
    } else {
        switch (iErrCode = FormatTrackHead(nDisk, wCylinder, wHead, wSecPerTrack, lpDiskBuffer)) {
            case NOERROR:
            case DATAERROR:
            case ADDMARKNOTFOUND:
            case SECTORNOTFOUND:
                iRetVal = iErrCode;
                break;
        }
    }
    return (iRetVal);
}


INT  APIENTRY GetMediaType(INT nDrive)
{
    return 0;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FormatFloppy() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

// note, the below comment is out of date.  leave for reference only

/* The Format routine is intended to mimic the actions of the FORMAT command
 * on MSDOS.  We restrict the possible set of operations that Format must use
 * in order to simplify life. The RESTRICTIONS are:
 *
 *  -- If the drive selected for formatting is a Quad density drive, then the
 *         user will be asked if he wants to format it for 1.2 MB or 360 KB
 *         and the format will proceed accordingly;
 *  -- For all other types of drives, it will format the disk to the maximum
 *         capacity that the drive can handle.
 *
 * The requirements for Format are:
 *
 *  1) there be a disk in a "source" drive that contains a valid boot sector
 *  2) there be a disk in a "destination" drive that is formattable.
 *
 * The algorithm for determining a drive's capacity is as follows:
 *
 *      If Source == Destination then
 *          error
 *      If dosversion >= 3.20
 *       {
 *         Use generic get_device_parameters and Get BPB.
 *         if (the drive is a Quad density drive (1.2 MB), and if user wants
 *             to format for 360KB), take BPB for 360KB from the bpbList[].
 *         In all other cases, use the BPB of the device.
 *       }
 *      else
 *       {
 *         Ask INT 13 for the drive type.
 *         If error then {
 *            assume 48tpi double side
 *            Attempt to format track 0, head 1
 *            If error then
 *               assume 48tpi single side
 *         else
 *            if sectors per track = 15 then
 *                assume 96tpi
 *                Ask user if he wants to format for 1.2MB or 360KB and
 *                use the proper BPB from bpbList[]
 *            else
 *                error
 *       }
 *
 * Note that this does NOT take into account non-contiguous drive letters
 * (see 3.2 spec) nor future drives nor user-installed device drivers.
 *
 * Format (dSrc, nDstDrive, nDstDriveInt13) will format drive nDstDrive using an updated
 * boot sector from drive dSrc. We will allocate two blocks of memory, but
 * only one at a time.  The first one we allocate is the bit-map of bad
 * clusters that we find during the format.  The second is for the boot
 * sector.
 *
 *  Returns:    0           Success
 *              <> 0        error code
 *                      1 =>  NOMEMORY
 *                      3 =>  Invalid boot sector.
 *                      4 =>  System area of the floppy is bad
 *                      7 =>  Problem in writing in Dest diskette.
 *                      8 =>  Internal error
 *                      9 =>  Format has been aborted by user.
 */

// in:
//     hWnd            window to base messages on
//
//     nSource         drive to swipe boot stuff from
//
//     nDest           drive to format
//
//     iCapacity       SS48
//                     DS48
//                     DS96
//                     DS720KB
//                     DS144M
//                     DS288M
//                     -1      (device capacity)
//
//     bMakeSysDisk    make a system disk too
//
//     bQuick          do a quick format
//
// returns:
//     0               success
//     != 0            error
//

INT
APIENTRY
FormatFloppy(
            HWND hWnd,
            WORD nDest,
            INT iCapacity,
            BOOL bMakeSysDisk,
            BOOL bQuick
            )
{
    DPB           DPB;
    DBT           dbtSave;                /* Disk Base Table */
    INT           iErrCode;
    PBPB pBPB;
    WORD          w;
    WORD          cClusters;
    WORD          wFATValue;
    WORD          wBadCluster;
    WORD          cBadSectors;
    WORD          cTotalTracks;
    WORD          wCurrentHead;
    WORD          wPercentDone;
    WORD          wCurrentTrack;
    WORD          cTracksToFormat;
    WORD          wFirstDataSector;
    WORD      nSource;
    DevPB         dpbDiskParms;           /* Device Parameters */
    LPDBT         lpDBT;
    LPSTR         lpDiskBuffer;
    LPSTR         lpBadClusterList;
    HANDLE        hDiskBuffer;
    HANDLE        hBadClusterList;
    HANDLE        hSaveDiskParms = NULL;
    PDevPB        pdpbSaveDiskParms;
    CHAR          szMsg[128];
    BOOL          fLowCapacity = FALSE; /* Is a 360KB floppy in a 1.2MB drive? */
    INT           ret = 0;        // default to success

    nSource = (WORD)GetBootDisk();

    /* Initialize for cleanup. */
    hDiskBuffer      = NULL;
    lpDiskBuffer     = NULL;
    hBadClusterList  = NULL;
    lpBadClusterList = NULL;
    bUserAbort       = FALSE;

    /* Create a dialogbox that displays the progress of formatting; and also
     * gives the user a chance to abort formatting at anytime.
     */
    hdlgProgress = CreateDialog(hAppInstance, MAKEINTRESOURCE(FORMATPROGRESSDLG), hWnd, ProgressDlgProc);
    if (!hdlgProgress) {
        ret = IDS_FFERR_MEM;      // out of memory
        goto FFErrExit1;
    }

    EnableWindow(hWnd, FALSE);

    /* Flush to DOS disk buffers. */
    DiskReset();

    /* Get the Disk Base Table. */
    if (!(lpDBT = GetDBT())) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit2;
    }

    dbtSave = *lpDBT;

    // this checks to see if we are trying to format the boot drive
    // this is a no no

    if ((nDest == nSource) || (!IsRemovableDrive(nDest))) {
        ret = IDS_FFERR_SRCEQDST;
        goto FFErrExit3;
    }

    /* Check if the sector size is of standard size; If not report error */
    if (HIWORD(GetClusterInfo(nSource)) > CBSECTORSIZE) {
        ret = IDS_FFERR_SECSIZE;
        goto FFErrExit3;
    }

    /* Allocate boot sector, sector buffer, track buffer */
    if (!(hDiskBuffer = LocalAlloc(LHND, (LONG)(2*CBSECTORSIZE)))) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit3;
    }

    lpDiskBuffer = LocalLock(hDiskBuffer);


    /* If DOS Version is 3.2 or above, use DeviceParameters() to get the BPB. */
    if (wDOSversion >= DOS_320) {

        /* NOTE: All the fields of dpbDiskParms must be initialized to 0,
         *           otherwise, INT 21h, Function 44h, Subfunction 0Dh does NOT work;
         *           This function is called in DeviceParameters().
         */
        memset(&dpbDiskParms, 0, sizeof(DevPB));
        pBPB = &(dpbDiskParms.BPB);

        if (iCapacity != -1) {

            w = (WORD)GetMediaType(nDest);

            if (w) {
                switch (w) {
                    case 2:         // 720
                        if (iCapacity > DS720KB) {
                            w = IDS_720KB;
                            iCapacity = DS720KB;
                        } else
                            goto SensePass;
                        break;

                    case 7:         // 1.44
                        if (iCapacity > DS144M) {
                            w = IDS_144MB;
                            iCapacity = DS144M;
                        } else
                            goto SensePass;
                        break;
                    default:        // 2.88 and unknown case
                        goto SensePass;
                }

                LoadString(hAppInstance, IDS_FFERR_MEDIASENSE, szMsg, sizeof(szMsg));
                LoadString(hAppInstance, w, szTitle, sizeof(szTitle));
                wsprintf(szMessage, szMsg, (LPSTR)szTitle);
                LoadString(hAppInstance, IDS_FORMATERR, szTitle, sizeof(szTitle));
                if (MessageBox(hdlgProgress, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION) != IDYES) {
                    ret = IDS_FFERR_USERABORT;
                    goto FFErrExit3;
                }
            }

            SensePass:

            pBPB = &bpbList[iCapacity];
            cClusters = cCluster[iCapacity];

            // if we are formatting a 360K disk in a 1.2 MB drive set this
            // special flag

            if (iCapacity == DS48) {
                // We must remember to change the number of cylinders
                // while doing Set Device parameters; So, set this flag;
                fLowCapacity = TRUE;
            }
        } else {
            DWORD dwSec = pBPB->cSec;

            // use the default device parameters
            // NOTE: pBPB already points to proper data

            /* HPVECTRA: DOS 3.2 and above gives wrong sector count. */
            if (!pBPB->cSec)
                dwSec = dpbDiskParms.NumCyls * pBPB->secPerTrack * pBPB->cHead;

            /* Calculate the clusters for the disk. */
            cClusters = (WORD)(dwSec / pBPB->secPerClus) -
                        (pBPB->cSecRes + (pBPB->cFAT * pBPB->secPerFAT) +
                         (pBPB->cDir*32 + pBPB->cbSec - 1) / pBPB->cbSec) / pBPB->secPerClus;
        }

        /* Save the DriveParameterBlock for restoration latter */
        hSaveDiskParms = BuildDevPB(&dpbDiskParms);
        if (!hSaveDiskParms) {
            ret = IDS_FFERR_MEM;
            goto FFErrExit3;
        }
        pdpbSaveDiskParms = (PDevPB)LocalLock(hSaveDiskParms);

        /* Modify the parameters just for format */
        memcpy(&(dpbDiskParms.BPB), pBPB, sizeof(BPB));
        if (!SetDevParamsForFormat(nDest, &dpbDiskParms, fLowCapacity)) {
            ret = IDS_FFERR_MEM;
            goto FFErrExit3;
        }

    } else {
        // DOS < 3.2

        /* See if INT 13 knows the drive type. */
        switch (MyGetDriveType(nDest)) {
            case NOCHANGE:
                /* We assume that the machine is using old ROMS...
                 * Assume that we are using a 9-sector Double-sided 48tpi diskette.
                 */
                pBPB = &bpbList[DS48];
                cClusters = cCluster[DS48];
                lpDBT->lastsector = (BYTE)pBPB->secPerTrack;
                lpDBT->gaplengthf = 0x50;

                /* Try to format a track on side 1.  If this fails, assume that we
                 * have a Single-sided 48tpi diskette.
                 */
                if (FormatTrackHead(nDest, 0, 1, pBPB->secPerTrack, lpDiskBuffer)) {
                    pBPB = &bpbList[SS48];
                    cClusters = cCluster[SS48];
                }
                break;

            case CHANGE:
                if (iCapacity == DS48) {
                    /* User wants to format a 360KB floppy. */
                    pBPB = &bpbList[DS48];
                    cClusters = cCluster[DS48];
                } else {
                    /* User wants to format a 1.2 MB floppy */
                    pBPB = &bpbList[DS96];
                    cClusters = cCluster[DS96];
                }
                break;

            default:
                ret = IDS_FFERR_DRIVETYPE;
                goto FFErrExit5;
        }
    }

    lpDBT->lastsector = (BYTE)pBPB->secPerTrack;
    lpDBT->gaplengthf = (BYTE)(pBPB->secPerTrack == 15 ? 0x54 : 0x50);

    if (wDOSversion < DOS_320) {
        /* If 96tpi, fix up the Disk Base Table. */
        if (pBPB->bMedia == MEDIA_1200)      /* high density */
            if (pBPB->secPerTrack == 15)     /* then 1.2 Meg Drive */
                SetDASD(nDest, 3);           /* 1.2 MB floppy in 1.2MB drive */
    }

    LoadString(hAppInstance, IDS_PERCENTCOMP, szMsg, sizeof(szMsg));

    /* We believe that we know EXACTLY what is out there.  Allocate the boot
     * sector and the bad-cluster bit-map.  The boot sector buffer is reused as
     * two consecutive sectors of the FAT.
     */
    if (!(hBadClusterList = LocalAlloc(LHND, (LONG)((2 + cClusters + 7) / 8)))) {
        ret = IDS_FFERR_MEM;
        goto FFErrExit5;
    }

    lpBadClusterList = LocalLock(hBadClusterList);

    /* Let's format 1 track at a time and record the bad sectors in the
     * bitmap.  Note that we round DOWN the number of tracks so that we
     * don't format what might not be ours.  Fail if there are any bad
     * sectors in the system area.
     */

    /* Compute number of tracks to format. */
    if (!pBPB->cSec)
        cTracksToFormat = (WORD)dpbDiskParms.NumCyls;
    else
        cTracksToFormat = (WORD)(pBPB->cSec / pBPB->secPerTrack);


    /* Compute the starting track and head. */
    wCurrentTrack = pBPB->cSecHidden / (pBPB->secPerTrack * pBPB->cHead);
    wCurrentHead = (pBPB->cSecHidden % (pBPB->secPerTrack * pBPB->cHead))/pBPB->secPerTrack;

    /* Compute the number of the first sector after the system area. */
    wFirstDataSector = pBPB->cSecRes + pBPB->cFAT * pBPB->secPerFAT +
                       (pBPB->cDir * 32 + pBPB->cbSec-1) / pBPB->cbSec;

    cTotalTracks = cTracksToFormat;

    if (bQuick) {

        // read the boot sector to make sure the capacity selected
        // matches what it has been formated to

        iErrCode = GenericReadWriteSector(lpDiskBuffer, INT13_READ, nDest, 0, 0, 1);

        if (iErrCode || ((iCapacity != -1) && ((BOOTSEC *)lpDiskBuffer)->BPB.bMedia != bpbList[iCapacity].bMedia)) {

            fFormatFlags &= ~FF_QUICK;
            bQuick = FALSE;

            LoadString(hAppInstance, IDS_FORMATQUICKFAILURE, szMessage, 128);
            LoadString(hAppInstance, IDS_FORMAT, szTitle, 128);

            iErrCode = MessageBox(hdlgProgress, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION);

            if (iErrCode == IDYES)
                goto NormalFormat;
            else {
                ret = IDS_FFERR_USERABORT;
                goto FFErrExit;
            }
        }

    } else {

        NormalFormat:

        /* Format tracks one by one, checking if the user has "Aborted"
        * after each track is formatted; DlgProgreeProc() will set the global
        * bUserAbort, if the user has aborted;
        */
        while (cTracksToFormat) {

            /* Has the user aborted? */
            if (WFQueryAbort()) {
                ret = IDS_FFERR_USERABORT;
                goto FFErrExit;
            }

            /* If no message is pending, go ahead and format one track */
            if ((iErrCode = GenericFormatTrack(nDest, wCurrentTrack, wCurrentHead, pBPB->secPerTrack, lpDiskBuffer))) {

                /* Check if it is a fatal error */
                if (iErrCode == -1) {
                    // ret = IDS_FFERR_BADTRACK;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }

                /* Bad Track.  Compute the number of the first bad sector */
                cBadSectors = (wCurrentTrack * pBPB->cHead + wCurrentHead) * pBPB->secPerTrack;

                /* Fail if bad sector is in the system area */
                if (cBadSectors < wFirstDataSector) {
                    // ret = IDS_FFERR_BADTRACK;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }

                /* Enumerate all bad sectors and mark the corresponding
                * clusters as bad.
                */
                for (w=cBadSectors; w < cBadSectors + pBPB->secPerTrack; w++) {
                    wBadCluster = (w - wFirstDataSector) / pBPB->secPerClus + 2;
                    lpBadClusterList[wBadCluster/8] |= 1 << (wBadCluster % 8);
                }
            }

            cTracksToFormat--;

            /* Display the percentage of progress message */
            wPercentDone = (WORD)MulDiv(cTotalTracks - cTracksToFormat, 100, cTotalTracks);

            /* All tracks might have been formatted. But,
            * Still FAT and Root dir are to be created; It takes time; So,
            * make the user believe that still 1% formatting is left.
            */
            if (wPercentDone == 100)
                LoadString(hAppInstance, IDS_CREATEROOT, szMessage, sizeof(szMessage));
            else
                wsprintf(szMessage, szMsg, wPercentDone);

            SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);

            if (++wCurrentHead >= pBPB->cHead) {
                wCurrentHead = 0;
                wCurrentTrack++;
            }
        }
    }

    /* Write out the boot sector(s). */
    w = (WORD)WriteBootSector(nSource, nDest, pBPB, lpDiskBuffer);
    if (w) {
        // ret = IDS_FFERR_WRITEBOOT;
        if (w == 0x16)            // int24 unknown command, assume
            ret = IDS_SYSDISKNOFILES; // the int25 read failed
        else
            ret = IDS_FFERR;
        goto FFErrExit;
    }

    /* Has the user aborted? */
    if (WFQueryAbort()) {
        ret = IDS_FFERR_USERABORT;
        goto FFErrExit;
    }

    /* Format is complete.  Create correct DPB in system */
    SetDPB(nDest, pBPB, &DPB);

    // if doing a quick format keep the old bad cluster list

    /* Create FAT entries for each of the formatted clusters. */
    for (w=2; w < (WORD)(cClusters+2); w++) {

        if (bQuick) {
            wFATValue = 0;

            // is this entry reserved or marked as bad

            if ((wFATValue >= 0xFFF0) &&
                (wFATValue <= 0xFFF7)) {
                // yes, don't change it!
            } else {
                // mark as free

                if (0) {
                    // ret = IDS_FFERR_WRITEFAT;
                    ret = IDS_FFERR;
                    goto FFErrExit;
                }
            }

        } else {
            /* Was this cluster bad? */
            if (lpBadClusterList[w/8] & (1 << (w % 8)))
                wFATValue = 0xFFF7;
            else
                wFATValue = 0;

            /* Add this entry to the FAT (possibly writing the sector). */
            if (0) {
                // ret = IDS_FFERR_WRITEFAT;
                ret = IDS_FFERR;
                goto FFErrExit;
            }

        }
        if (WFQueryAbort()) {           /* Has the user aborted? */
            ret = IDS_FFERR_USERABORT;
            goto FFErrExit;
        }
    }

    /* Clean out the root directory. */
    memset(lpDiskBuffer, 0, CBSECTORSIZE);

    for (w=0; w < (WORD)((pBPB->cDir*32 + pBPB->cbSec-1)/pBPB->cbSec); w++) {
        /* Has the user aborted? */
        if (WFQueryAbort()) {
            ret = IDS_FFERR_USERABORT;
            goto FFErrExit;
        }
    }

    /* Should we make it a system disk also? */
    if (bMakeSysDisk) {
        LoadString(hAppInstance, IDS_COPYSYSFILES, szMessage, 32);
        SendDlgItemMessage(hdlgProgress, IDD_PROGRESS, WM_SETTEXT, 0, (LPARAM)szMessage);
        if (MakeSystemDiskette(nDest, TRUE)) {
            if (bUserAbort)
                ret = IDS_FFERR_USERABORT;
            else
                ret = IDS_FFERR_SYSFILES;
            goto FFErrExit;
        }
    }

    /* Normal Exit. */

    LocalUnlock(hBadClusterList);
    LocalFree(hBadClusterList);
    LocalUnlock(hDiskBuffer);

    if (hSaveDiskParms) {
        /* Restore the DriveParameterBlock */
        pdpbSaveDiskParms->SplFunctions = 4;

        LocalUnlock(hSaveDiskParms);
        LocalFree(hSaveDiskParms);
    }

    LocalFree(hDiskBuffer);
    *lpDBT = dbtSave;
    EnableWindow(hWnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    return TRUE;

    FFErrExit:
    LocalUnlock(hBadClusterList);
    LocalFree(hBadClusterList);
    FFErrExit5:
    if (hSaveDiskParms) {
        /* Restore the DriveParameterBlock */
        pdpbSaveDiskParms->SplFunctions = 4;

        LocalUnlock(hSaveDiskParms);
        LocalFree(hSaveDiskParms);
    }
    LocalUnlock(hDiskBuffer);
    LocalFree(hDiskBuffer);
    FFErrExit3:
    *lpDBT = dbtSave;
    FFErrExit2:
    EnableWindow(hWnd, TRUE);
    DestroyWindow(hdlgProgress);
    hdlgProgress = NULL;
    FFErrExit1:

    if (ret != IDS_FFERR_USERABORT) {
        LoadString(hAppInstance, IDS_FORMATERR, szTitle, sizeof(szTitle));
        LoadString(hAppInstance, ret, szMessage, sizeof(szMessage));
        MessageBox(hWnd, szMessage, szTitle, MB_OK | MB_ICONSTOP);
    }
    return FALSE;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetDriveCapacity() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Parameter:
 *    Drive number;
 * Returns:
 *    0  if Error;
 *    1  if 360KB floppy;
 *    2  if 1.2MB floppy;
 *    3  if 720KB, 3.5" floppy;
 *    4  if 1.44MB, 3.5" floppy;
 *    5  if 2.88MB, 3.5" floppy;
 *
 * these are used +2 as indexes into bpbList[] FIX31
 *
 * HACK ALERT:
 *    One might wonder why on earth we are not using int13h Fn 8 to
 * perform this function; The reason is that in old compaq 386/16
 * machines(though the BIOS is dated Sep 1986), this function is NOT
 * supported! So, we are forced to do the following:
 *    We check the DOS version; If it is >= 3.2, then we make IOCTL
 * calls to get the Drive parameters and we find the Drive capacity;
 * If DOS version is < 3.2, then there can't be 3.5" floppies at all;
 * The only high capacity floppy possible is the 5.25", 1.2MB floppy;
 * So, we call MyGetDriveType() (int13h, Fn 15h) to find if the
 * change-line is supported by the drive; If it is supported then it
 * must be a 1.2MB floppy; Otherwise, it is a 360KB floppy;
 *    What do you think?  Smart! Ugh?
 */

WORD
APIENTRY
GetDriveCapacity(
                WORD nDrive
                )
{
    DevPB dpbDiskParms;           /* Device Parameters */
    PBPB pBPB;


    if (wDOSversion >= DOS_320) {

        /* NOTE: All the fields of dpbDiskParms must be initialized to 0,
         *   otherwise, INT 21h, Function 44h, Subfunction 0Dh does NOT work;
         *   This function is called in DeviceParameters().
         */
        memset(&dpbDiskParms, 0, sizeof(DevPB));
        dpbDiskParms.SplFunctions = 0;

        pBPB = &(dpbDiskParms.BPB);

        /* Check if this is a 1.44MB drive */
        if (pBPB->bMedia == MEDIA_1440) {
            if (pBPB->secPerTrack == 18)
                return 4;     /* 1.44MB drive */
            else if (pBPB->secPerTrack == 36)
                return 5;     /* 2.88MB drive */
        }

        /* Check if this is a 720KB or 1.2MB drive */
        if (pBPB->bMedia == MEDIA_1200) {
            if (pBPB->secPerFAT == 3)
                return 3; /* 720KB drive */
            if (pBPB->secPerFAT == 7)
                return 2; /* 1.2MB drive */
        }

        if (pBPB->bMedia == MEDIA_360)
            return 1;       /* Must be a 386KB floppy. */

        return 0;                 // I don't know!
    } else {

        /* See if INT 13 Fn 15h knows the drive type. */
        switch (MyGetDriveType(nDrive)) {
            case NOCHANGE:
                /* We assume that the machine is using old ROMS... */
                return 1;  /* No changeline support! Must be 360KB floppy */
                break;

            case CHANGE:
                return 2;  /* DOS versions < 3.2 can not have 1.44 or 720KB
                             * drive; So, this has to be a 1.2MB drive
                             */
                break;
            default:
                return 0;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfgwl.h ===
typedef struct {
    HWND  hwnd;
    HWND  hwndLastFocus;
    WORD  wDriveNum;
    WORD  wView;
    BOOL  fFSCFlag;
    WORD  wSort;
    DWORD dwAttribs;
    INT   iSplit;
    LPTREECTLDATA lptcd;
    LPDIRDDATA    lpdird;
    LPDRIVESDATA  lpdrvd;
} TREEDATA, FAR *LPTREEDATA;

typedef struct {
    HWND  hwnd;
    INT   iReadLevel;
    HWND  hwndLB;
    LPTREEDATA lptreed;
} TREECTLDATA, FAR *LPTREECTLDATA;

typedef struct {
    HWND   hwnd;
    INT    iFirstTab;
    HANDLE hDTA;
    HWND   hwndLB;
    LPTREEDATA lptreed;
} DIRDATA, FAR *LPDIRDATA;

typedef struct {
    HWND  hwnd;
    LPSTR lpstrVolume;
    INT   iCurDriveInd;
    INT   iCurDriveFocus;
    LPTREEDATA lptreed;
} DRIVESDATA, FAR *LPDRIVESDATA;

typedef struct {
    HWND  hwnd;
    WORD  wDriveNum;
    WORD  wView;
    BOOL  fFSCFlag;
    WORD  wSort;
    DWORD dwAttribs;
    HANDLE hDTASearch;
    HWND  hwndLB;
    LPTREEDATA lptreed;
} SEARCHDATA, FAR *LPSEARCHDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wffsc.c ===
/****************************************************************************
 *                                      *
 *  WFFSC.ASM -                                 *
 *                                      *
 *  WINFILE's File System Change Notification Handler           *
 *                                      *
 ****************************************************************************/

#include "winfile.h"


VOID
APIENTRY
KernelChangeFileSystem(
                      LPSTR lpFile,
                      WORD wDosFunc
                      )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wflabel.c ===
/****************************************************************************/
/*                                      */
/*  WFLABEL.C -                                 */
/*                                      */
/*  Windows File System Diskette Labelling Routines             */
/*                                      */
/****************************************************************************/

#include "winfile.h"
//#include "lstrfns.h"

/*--------------------------------------------------------------------------*/
/*                                      */
/*  CreateVolumeLabel() -                           */
/*                                      */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
CreateVolumeLabel(
                 INT nDrive,
                 LPSTR lpNewVolLabel
                 )
{
    HFILE     fh;
    register INT  i;
    register LPSTR p;
    CHAR      szFullVolName[16];      /* Sample: A:\12345678.EXT,\0 */
    LPSTR         lpStart = lpNewVolLabel;

    lstrcpy((LPSTR)szFullVolName, GetRootPath((WORD)nDrive));

    /* If the volume label has more than 8 chars, we must seperate the
     * name and the extension by a '.'
     */

    p = &szFullVolName[3];

    /* Copy the file 8 characters of the VolLabel */
    for (i=0; i < 8; i++) {
        if (!(*p++ = *lpNewVolLabel++))
            break;
    }

    if (i == 8) {
        /* Seperate the extension part of it with a '.' */
        *p++ = '.';

        /* Copy the extension */
        i = 0;
        while (*p++ = *lpNewVolLabel++) {
            if (++i == 3) {
                /* Make sure we do not end on a lead byte; notice this is not
                 * necessary if the label came from an edit box with
                 * EM_LIMITEXT of 11; also notice that according to the
                 * DBCS seminar notes, we do NOT need this check before the '.'
                 */
                for (lpNewVolLabel=lpStart; lpNewVolLabel-lpStart<11;
                    lpNewVolLabel = AnsiNext(lpNewVolLabel))
                    /* do nothing */ ;
                if (lpNewVolLabel-lpStart > 11)
                    --p;
                *p = TEXT('\0');
                break;
            }
        }
    }

    /* Create a file with the attribute "VOLUME LABEL" */
    if ((fh = CreateVolumeFile(szFullVolName)) == 0)
        return (-1);

    M_lclose(fh);
    return (0);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  SetVolumeLabel() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
MySetVolumeLabel(
                INT nDrive,
                BOOL bOldVolLabelExists,
                LPSTR lpNewVolLabel
                )
{
    INT   iRet = 0;
    CHAR  szTemp[MAXFILENAMELEN];

    AnsiToOem(lpNewVolLabel, szTemp);

    // invalid chars copied from DOS user docs

#ifdef STRCSPN_IS_DEFINED_OR_LABEL_MENUITEM_IS_ENABLED
    if (szTemp[StrCSpn(szTemp, " *?/\\|.,;:+=[]()&^<>\"")] != '\0')
        return (-1);
#endif

    /* Check if there is an old volume label. */
    if (bOldVolLabelExists) {
        /* Are we changing or deleting the volume label? */
        if (*szTemp) {
            /* Yup! There is a new one too! So, change the Vol label */
// EDH ChangeVolumeLabel cannot change label to an existing dir/file name,
//     since it uses the DOS Rename to do the work. (I consider this a bug
//     in DOS' Rename func.)  Anyway, use delete/create to change label
//     instead.  13 Oct 91
//    iRet = ChangeVolumeLabel(nDrive, szTemp);
            iRet = DeleteVolumeLabel(nDrive);
            iRet = CreateVolumeLabel(nDrive, szTemp);
        } else {
            /* User wants to remove the Vol label. Remove it */
            iRet = DeleteVolumeLabel(nDrive);
        }
    } else {
        /* We are creating a new label. */
        if (*szTemp)
            iRet = CreateVolumeLabel(nDrive, szTemp);
    }

    return (iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfinit.c ===
/****************************************************************************/
/*                                                                          */
/*  WFINIT.C -                                                              */
/*                                                                          */
/*      Windows File System Initialization Routines                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "stdlib.h"

typedef DWORD ( APIENTRY *EXTPROC)(HWND, WORD, LONG);
typedef DWORD ( APIENTRY *UNDELPROC)(HWND, LPSTR);
typedef VOID  ( APIENTRY *FNPENAPP)(WORD, BOOL);

VOID (APIENTRY *lpfnRegisterPenApp)(WORD, BOOL);
CHAR szPenReg[] = "RegisterPenApp";
CHAR szHelv[] = "MS Shell Dlg";    // default font, status line font face name

HBITMAP hbmSave;


INT     GetDriveOffset(register WORD wDrive);
DWORD   RGBToBGR(DWORD rgb);
VOID    BoilThatDustSpec(register CHAR *pStart, BOOL bLoadIt);
VOID    DoRunEquals(PINT pnCmdShow);
VOID    GetSavedWindow(LPSTR szBuf, PSAVE_WINDOW pwin);
VOID    GetSettings(VOID);
VOID    InitMenus(VOID);



INT
APIENTRY
GetHeightFromPointsString(
                         LPSTR szPoints
                         )
{
    HDC hdc;
    INT height;

    hdc = GetDC(NULL);
    height = MulDiv(-atoi(szPoints), GetDeviceCaps(hdc, LOGPIXELSY), 72);
    ReleaseDC(NULL, hdc);

    return height;
}

VOID
BiasMenu(
        HMENU hMenu,
        INT Bias
        )
{
    INT pos, id, count;
    HMENU hSubMenu;
    CHAR szMenuString[80];

    ENTER("BiasMenu");

    count = GetMenuItemCount(hMenu);

    if (count < 0)
        return;

    for (pos = 0; pos < count; pos++) {

        id = GetMenuItemID(hMenu, pos);

        if (id < 0) {
            // must be a popup, recurse and update all ID's here
            if (hSubMenu = GetSubMenu(hMenu, pos))
                BiasMenu(hSubMenu, Bias);
        } else if (id) {
            // replace the item that was there with a new
            // one with the id adjusted

            GetMenuString(hMenu, (WORD)pos, szMenuString, sizeof(szMenuString), MF_BYPOSITION);
            DeleteMenu(hMenu, pos, MF_BYPOSITION);
            InsertMenu(hMenu, (WORD)pos, MF_BYPOSITION | MF_STRING, id + Bias, szMenuString);
        }
    }
    LEAVE("BiasMenu");
}


VOID
APIENTRY
InitExtensions()
{
    CHAR szBuf[300] = {0};
    CHAR szPath[MAXPATHLEN];
    LPSTR p;
    HANDLE hMod;
    FM_EXT_PROC fp;
    HMENU hMenu;
    INT iMax;
    HMENU hMenuFrame;
    HWND  hwndActive;

    ENTER("InitExtensions");

    hMenuFrame = GetMenu(hwndFrame);

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    GetPrivateProfileString(szAddons, NULL, szNULL, szBuf, sizeof(szBuf), szTheINIFile);

    for (p = szBuf; *p && iNumExtensions < MAX_EXTENSIONS; p += lstrlen(p) + 1) {

        GetPrivateProfileString(szAddons, p, szNULL, szPath, sizeof(szPath), szTheINIFile);

        hMod = MLoadLibrary(szPath);

        if (hMod >= (HANDLE)32) {
            fp = (FM_EXT_PROC)GetProcAddress(hMod, "FMExtensionProc");

            if (fp) {
                WORD bias;
                FMS_LOAD ls;

                bias = (WORD)((IDM_EXTENSIONS + iNumExtensions + 1)*100);
                ls.wMenuDelta = bias;
                if ((*fp)(hwndFrame, FMEVENT_LOAD, (LPARAM)&ls)) {

                    if (ls.dwSize != sizeof(FMS_LOAD) || !ls.hMenu)
                        goto LoadFail;

                    hMenu = ls.hMenu;

                    extensions[iNumExtensions].ExtProc = fp;
                    extensions[iNumExtensions].Delta = bias;
                    extensions[iNumExtensions].hModule = hMod;
                    extensions[iNumExtensions].hMenu = hMenu;

                    BiasMenu(hMenu, bias);

                    InsertMenu(hMenuFrame,
                               IDM_EXTENSIONS + iNumExtensions + iMax,
                               MF_BYPOSITION | MF_POPUP,
                               (UINT_PTR)hMenu, ls.szMenuName);

                    iNumExtensions++;
                }
            } else {
                LoadFail:
                FreeLibrary(hMod);
            }
        }
    }
    LEAVE("InitExtensions");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetSettings() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
GetSettings()
{
    CHAR szTemp[128] = {0};
    INT size;

    ENTER("GetSettings");

    /* Get the flags out of the INI file. */
    bMinOnRun       = GetPrivateProfileInt(szSettings, szMinOnRun,      bMinOnRun,      szTheINIFile);
    wTextAttribs    = (WORD)GetPrivateProfileInt(szSettings, szLowerCase,     wTextAttribs,   szTheINIFile);
    bStatusBar      = GetPrivateProfileInt(szSettings, szStatusBar,     bStatusBar,     szTheINIFile);
    bConfirmDelete  = GetPrivateProfileInt(szSettings, szConfirmDelete, bConfirmDelete, szTheINIFile);
    bConfirmSubDel  = GetPrivateProfileInt(szSettings, szConfirmSubDel, bConfirmSubDel, szTheINIFile);
    bConfirmReplace = GetPrivateProfileInt(szSettings, szConfirmReplace,bConfirmReplace,szTheINIFile);
    bConfirmMouse   = GetPrivateProfileInt(szSettings, szConfirmMouse,  bConfirmMouse,  szTheINIFile);
    bConfirmFormat  = GetPrivateProfileInt(szSettings, szConfirmFormat, bConfirmFormat, szTheINIFile);
    bSaveSettings   = GetPrivateProfileInt(szSettings, szSaveSettings,  bSaveSettings, szTheINIFile);

    // test font for now

    GetPrivateProfileString(szSettings, szSize, "8", szTemp, sizeof(szTemp), szTheINIFile);
    size = GetHeightFromPointsString(szTemp);

    GetPrivateProfileString(szSettings, szFace, szHelv, szTemp, sizeof(szTemp), szTheINIFile);

    hFont = CreateFont(size, 0, 0, 0,
                       wTextAttribs & TA_BOLD ? 700 : 400,
                       wTextAttribs & TA_ITALIC, 0, 0,
                       ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                       DEFAULT_QUALITY, DEFAULT_PITCH | FF_SWISS, szTemp);

    LEAVE("GetSettings");
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetInternational() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
GetInternational()
{
    ENTER("GetInternational");

    GetProfileString(szInternational, "sShortDate", szShortDate, szShortDate, 11);
    AnsiUpper(szShortDate);
    GetProfileString(szInternational, "sTime", szTime, szTime, 2);
    GetProfileString(szInternational, "s1159", sz1159, sz1159, 9);
    GetProfileString(szInternational, "s2359", sz2359, sz2359, 9);
    GetProfileString(szInternational, "sThousand", szComma, szComma, sizeof(szComma));
    iTime   = GetProfileInt(szInternational, "iTime", iTime);
    iTLZero = GetProfileInt(szInternational, "iTLZero", iTLZero);

    LEAVE("GetInternational");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BuildDocumentString() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Create a string which contains all of the extensions the user wants us to
 * display with document icons.  This consists of any associated extensions
 * as well as any extensions listed in the "Documents=" WIN.INI line.
 */

VOID
APIENTRY
BuildDocumentString()
{
    register LPSTR     p;
    register INT      len;
    INT               lenDocs;
    CHAR              szT[10];
    INT               i;
    HKEY hk;


    ENTER("BuildDocumentString");

    len = 32;

    /* Get all of the "Documents=" stuff. */
    szDocuments = (LPSTR)LocalAlloc(LPTR, len);
    if (!szDocuments)
        return;

    while ((lenDocs = GetProfileString(szWindows, "Documents", szNULL, szDocuments, len-1)) == len-1) {
        len += 32;
        {
            void *pv = (LPSTR)LocalReAlloc((HANDLE)szDocuments, len, LMEM_MOVEABLE);
            if (!pv) {
                LEAVE("BuildDocumentString");
                return;
            } else
                szDocuments = pv;
        }
    }

    lstrcat(szDocuments, szBlank);
    lenDocs++;
    p = (LPSTR)(szDocuments + lenDocs);

    /* Read all of the [Extensions] keywords into 'szDocuments'. */
    while ((INT)GetProfileString(szExtensions, NULL, szNULL, p, len-lenDocs) > (len-lenDocs-3)) {
        len += 32;
        {
            void *pv =(LPSTR)LocalReAlloc((HANDLE)szDocuments, len, LMEM_MOVEABLE);
            if (!pv) {
                LEAVE("BuildDocumentString");
                return;
            } else {
                szDocuments = pv;
            }
        }
        p = (LPSTR)(szDocuments + lenDocs);
    }

    /* Step through each of the keywords in 'szDocuments' changing NULLS into
     * spaces until a double-NULL is found.
     */
    p = szDocuments;
    while (*p) {
        /* Find the next NULL. */
        while (*p)
            p++;

        /* Change it into a space. */
        *p = ' ';
        p++;
    }


    if (RegOpenKey(HKEY_CLASSES_ROOT,szNULL,&hk) == ERROR_SUCCESS) {
        /* now enumerate the classes in the registration database and get all
         * those that are of the form *.ext
         */
        for (i = 0; RegEnumKey(hk,(DWORD)i,szT,sizeof(szT))
            == ERROR_SUCCESS; i++) {
            if (szT[0] != '.' ||
                (szT[1] && szT[2] && szT[3] && szT[4])) {
                /* either the class does not start with . or it has a greater
                 * than 3 byte extension... skip it.
                 */
                continue;
            }

            if (FindExtensionInList(szT+2,szDocuments)) {
                // don't add it if it's already there!
                continue;
            }

            len += 4;
            {
                void *pv = (PSTR)LocalReAlloc((HANDLE)szDocuments, len, LMEM_MOVEABLE);
                if (!pv) {
                    break;
                } else {
                    szDocuments = pv;
                }
            }
            lstrcat(szDocuments, szT+1);
            lstrcat(szDocuments, szBlank);
        }

        RegCloseKey(hk);
    }

    PRINT(BF_PARMTRACE, "OUT: szDocuments=%s", szDocuments);
    LEAVE("BuildDocumentString - ok");
    return;
}




INT
GetDriveOffset(
              register WORD wDrive
              )
{
    if (IsCDRomDrive(wDrive))
        return dxDriveBitmap * 0;

    switch (IsNetDrive(wDrive)) {
        case 1:
            return dxDriveBitmap * 4;
        case 2:
            return dxDriveBitmap * 5;
    }

    if (IsRemovableDrive(wDrive))
        return dxDriveBitmap * 1;

    if (IsRamDrive(wDrive))
        return dxDriveBitmap * 3;

    return dxDriveBitmap * 2;
}


VOID
APIENTRY
InitDriveBitmaps()
{
    INT nDrive;

    ENTER("InitDiskMenus");

    // and now add all new ones
    for (nDrive=0; nDrive < cDrives; nDrive++) {
        // refresh/init this here as well
        rgiDrivesOffset[nDrive] = GetDriveOffset((WORD)rgiDrive[nDrive]);
    }
    LEAVE("InitDiskMenus");
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitMenus() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
InitMenus()
{
    WORD i;
    HMENU hMenu;
    OFSTRUCT os;
    INT iMax;
    CHAR szValue[MAXPATHLEN];
    HWND hwndActive;

    ENTER("InitMenus");

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
    if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
        iMax = 1;
    else
        iMax = 0;

    GetPrivateProfileString(szSettings, szUndelete, szNULL, szValue, sizeof(szValue), szTheINIFile);

    if (szValue[0]) {

        // create explicit filename to avoid searching the path

        GetSystemDirectory(os.szPathName, sizeof(os.szPathName));
        AddBackslash(os.szPathName);
        lstrcat(os.szPathName, szValue);

        if (MOpenFile(os.szPathName, &os, OF_EXIST) > 0) {

            hModUndelete = MLoadLibrary(szValue);

            if (hModUndelete >= (HANDLE)32) {
                lpfpUndelete = (FM_UNDELETE_PROC)GetProcAddress(hModUndelete, "UndeleteFile");

                if (lpfpUndelete) {
                    hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_FILE + iMax);
                    LoadString(hAppInstance, IDS_UNDELETE, szValue, sizeof(szValue));
                    InsertMenu(hMenu, 4, MF_BYPOSITION | MF_STRING, IDM_UNDELETE, szValue);
                }
            } else {
                FreeLibrary(hModUndelete);

            }
        }
    }

    /* Init the Disk menu. */
    hMenu = GetMenu(hwndFrame);

    if (nFloppies == 0) {
        EnableMenuItem(hMenu, IDM_DISKCOPY, MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, IDM_FORMAT,   MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, IDM_SYSDISK,  MF_BYCOMMAND | MF_GRAYED);
    }

    bNetAdmin = WNetGetCaps(WNNC_ADMIN) & WNNC_ADM_GETDIRECTORYTYPE;

    /* Should we enable the network items? */
    i = (WORD)WNetGetCaps(WNNC_DIALOG);

    i = 0;

    bConnect    = i & WNNC_DLG_ConnectDialog;     // note, these should both
    bDisconnect = i & WNNC_DLG_DisconnectDialog;  // be true or both false

    // use submenu because we are doing this by position

    hMenu = GetSubMenu(GetMenu(hwndFrame), IDM_DISK + iMax);

    if (i)
        InsertMenu(hMenu, 5, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

    if (bConnect && bDisconnect) {

        // lanman style double connect/disconnect

        LoadString(hAppInstance, IDS_CONNECT, szValue, sizeof(szValue));
        InsertMenu(hMenu, 6, MF_BYPOSITION | MF_STRING, IDM_CONNECT, szValue);
        LoadString(hAppInstance, IDS_DISCONNECT, szValue, sizeof(szValue));
        InsertMenu(hMenu, 7, MF_BYPOSITION | MF_STRING, IDM_DISCONNECT, szValue);
    } else if (WNetGetCaps(WNNC_CONNECTION)) {

    }

    hMenu = GetMenu(hwndFrame);

    if (bStatusBar)
        CheckMenuItem(hMenu, IDM_STATUSBAR, MF_BYCOMMAND | MF_CHECKED);
    if (bMinOnRun)
        CheckMenuItem(hMenu, IDM_MINONRUN,  MF_BYCOMMAND | MF_CHECKED);
    if (bSaveSettings)
        CheckMenuItem(hMenu, IDM_SAVESETTINGS,  MF_BYCOMMAND | MF_CHECKED);

    InitDriveBitmaps();

    InitExtensions();

    LEAVE("InitMenus");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  BoilThatDustSpec() -                                                    */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Parses the command line (if any) passed into WINFILE and exec's any tokens
 * it may contain.
 */

VOID
BoilThatDustSpec(
                register CHAR *pStart,
                BOOL bLoadIt
                )
{
    register CHAR *pEnd;
    WORD          ret;
    BOOL          bFinished;

    ENTER("BoilThatDustSpec");

    if (*pStart == TEXT('\0'))
        return;

    bFinished = FALSE;
    while (!bFinished) {
        pEnd = pStart;
        while ((*pEnd) && (*pEnd != ' ') && (*pEnd != ','))
            pEnd = AnsiNext(pEnd);

        if (*pEnd == TEXT('\0'))
            bFinished = TRUE;
        else
            *pEnd = TEXT('\0');

        ret = ExecProgram(pStart, szNULL, NULL, bLoadIt);
        if (ret)
            MyMessageBox(NULL, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);

        pStart = pEnd+1;
    }
    LEAVE("BoilThatDustSpec");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DoRunEquals() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Handle the "Run=" and "Load=" lines in WIN.INI. */

VOID
DoRunEquals(
           PINT pnCmdShow
           )
{
    CHAR      szBuffer[128] = {0};

    /* "Load" apps before "Run"ning any. */
    GetProfileString(szWindows, "Load", szNULL, szBuffer, 128);
    if (*szBuffer)
        BoilThatDustSpec(szBuffer, TRUE);

    GetProfileString(szWindows, "Run", szNULL, szBuffer, 128);
    if (*szBuffer) {
        BoilThatDustSpec(szBuffer, FALSE);
        *pnCmdShow = SW_SHOWMINNOACTIVE;
    }
}


//
// BOOL APIENTRY LoadBitmaps()
//
// this routine loads DIB bitmaps, and "fixes up" their color tables
// so that we get the desired result for the device we are on.
//
// this routine requires:
//      the DIB is a 16 color DIB authored with the standard windows colors
//      bright blue (00 00 FF) is converted to the background color!
//      light grey  (C0 C0 C0) is replaced with the button face color
//      dark grey   (80 80 80) is replaced with the button shadow color
//
// this means you can't have any of these colors in your bitmap
//

#define BACKGROUND      0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright blue
#define BUTTONFACE      0x00C0C0C0      // bright grey
#define BUTTONSHADOW    0x00808080      // dark grey

DWORD
FlipColor(
         DWORD rgb
         )
{
    return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}


BOOL
APIENTRY
LoadBitmaps()
{
    HDC                   hdc;
    HANDLE                h;
    DWORD                 *p;
    LPSTR                 lpBits;
    HANDLE                hRes;
    LPBITMAPINFOHEADER    lpBitmapInfo;
    INT numcolors;
    DWORD n;
    DWORD rgbSelected;
    DWORD rgbUnselected;
    PVOID pv;

    ENTER("LoadBitmaps");

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(hAppInstance, MAKEINTRESOURCE(BITMAPS), RT_BITMAP);
    if (!h) {
        return FALSE;
    }

    n = SizeofResource(hAppInstance, h);
    lpBitmapInfo = (LPBITMAPINFOHEADER)LocalAlloc(LPTR, n);
    if (!lpBitmapInfo)
        return FALSE;

    /* Load the bitmap and copy it to R/W memory */
    hRes = LoadResource(hAppInstance, h);
    pv = (PVOID) LockResource(hRes);
    if (pv)
        memcpy( lpBitmapInfo, pv, n );
    UnlockResource(hRes);
    FreeResource(hRes);

    p = (DWORD *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    /* Search for the Solid Blue entry and replace it with the current
     * background RGB.
     */
    numcolors = 16;

    while (numcolors-- > 0) {
        if (*p == BACKGROUND)
            *p = rgbUnselected;
        else if (*p == BACKGROUNDSEL)
            *p = rgbSelected;
        else if (*p == BUTTONFACE)
            *p = FlipColor(GetSysColor(COLOR_BTNFACE));
        else if (*p == BUTTONSHADOW)
            *p = FlipColor(GetSysColor(COLOR_BTNSHADOW));

        p++;
    }

    /* Now create the DIB. */

    /* First skip over the header structure */
    lpBits = (LPSTR)(lpBitmapInfo + 1);

    /* Skip the color table entries, if any */
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    hdc = GetDC(NULL);
    if (hdcMem = CreateCompatibleDC(hdc)) {

        if (hbmBitmaps = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits, (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS))
            hbmSave = SelectObject(hdcMem, hbmBitmaps);

    }
    ReleaseDC(NULL, hdc);



    LEAVE("LoadBitmaps");

    return TRUE;
}

//
// void GetSavedWindow(LPSTR szBuf, PSAVE_WINDOW pwin)
//
// in:
//      szBuf   buffer to parse out all the saved window stuff
//              if NULL pwin is filled with all defaults
// out:
//      pwin    this structure is filled with all fields from
//              szBuf.  if any fields do not exist this is
//              initialized with the standard defaults
//

VOID
GetSavedWindow(
              LPSTR szBuf,
              PSAVE_WINDOW pwin
              )
{
    PINT pint;
    INT count;

    ENTER("GetSavedWindow");

    // defaults

    pwin->rc.right = pwin->rc.left = CW_USEDEFAULT;
    pwin->pt.x = pwin->pt.y = pwin->rc.top = pwin->rc.bottom = 0;
    pwin->sw = SW_SHOWNORMAL;
    pwin->sort = IDD_NAME;
    pwin->view = VIEW_NAMEONLY;
    pwin->attribs = ATTR_DEFAULT;
    pwin->split = 0;

    pwin->szDir[0] = 0;

    if (!szBuf)
        return;

    count = 0;
    pint = (PINT)&pwin->rc;         // start by filling the rect

    while (*szBuf && count < 11) {

        *pint++ = atoi(szBuf);  // advance to next field

        while (*szBuf && *szBuf != ',')
            szBuf++;

        while (*szBuf && *szBuf == ',')
            szBuf++;

        count++;
    }

    lstrcpy(pwin->szDir, szBuf);    // this is the directory

    LEAVE("GetSavedWindow");
}


// szDir (OEM) path to check for existance

BOOL
CheckDirExists(
              LPSTR szDir
              )
{
    BOOL bRet = FALSE;

    ENTER("CheckDirExists");
    PRINT(BF_PARMTRACE, "szDir=%s", szDir);

    if (IsNetDrive((WORD)(DRIVEID(szDir))) == 2)
        return FALSE;

    if (IsValidDisk(DRIVEID(szDir)))
        bRet = !SheChangeDir(szDir);

    LEAVE("CheckDirExists");

    return bRet;
}



// return the tree directory in szTreeDir

BOOL
APIENTRY
CreateSavedWindows()
{
    CHAR buf[MAXPATHLEN+7*7], key[10];
    INT dir_num;
    HWND hwnd;
    SAVE_WINDOW win;
    INT iNumTrees;

    ENTER("CreateSavedWindows");

    // make sure this thing exists so we don't hit drives that don't
    // exist any more

    dir_num = 1;
    iNumTrees = 0;

    do {
        wsprintf(key, szDirKeyFormat, dir_num++);

        GetPrivateProfileString(szSettings, key, szNULL, buf, sizeof(buf), szTheINIFile);

        if (*buf) {
            CHAR szDir[MAXPATHLEN];

            GetSavedWindow(buf, &win);
            AnsiUpperBuff(win.szDir, 1);

            // clean off some junk so we
            // can do this test

            lstrcpy(szDir, win.szDir);
            StripFilespec(szDir);
            StripBackslash(szDir);
            FixAnsiPathForDos(szDir);

            if (!CheckDirExists(szDir))
                continue;

            wNewView = (WORD)win.view;
            wNewSort = (WORD)win.sort;
            dwNewAttribs = win.attribs;

            hwnd = CreateTreeWindow(win.szDir, win.split);

            if (!hwnd) {
                LEAVE("CreateSavedWindows");
                return FALSE;
            }

            iNumTrees++;

            // keep track of this for now...


            SetInternalWindowPos(hwnd, win.sw, &win.rc, &win.pt);
        }

    } while (*buf);

    // if nothing was saved create a tree for the current drive

    if (!iNumTrees) {
        //lstrcpy(buf, szOriginalDirPath);
        lstrcpy(buf, "\\"); // Don't use current filesystem directory
        lstrcat(buf, szStarDotStar);

        hwnd = CreateTreeWindow(buf, -1);// default to split window
        if (!hwnd)
            return FALSE;

        // ShowWindow(hwnd, SW_MAXIMIZE);

        iNumTrees++;
    }

    LEAVE("CreateSavedWindows - Ok");
    return TRUE;
}


// void  APIENTRY GetTextStuff(HDC hdc)
//
// this computues all the globals that are dependant on the
// currently selected font
//
// in:
//      hdc     DC with font selected into it
//

VOID
APIENTRY
GetTextStuff(
            HDC hdc
            )
{
    ENTER("GetTextStuff");

    MGetTextExtent(hdc, "M", 1, &dxText, &dyText);
    MGetTextExtent(hdc, szEllipses, 3, &dxEllipses, NULL);

    // these are all dependant on the text metrics

    dxDrive = dxDriveBitmap + dxText + (4*dyBorderx2);
    dyDrive = max(dyDriveBitmap + (4*dyBorderx2), dyText);

    // dxFileName = dxFolder + (12*dxText);
    dyFileName = max(dyText, dyFolder);   //  + dyBorder;

    LEAVE("GetTextStuff");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  InitFileManager() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
InitFileManager(
               HANDLE hInstance,
               HANDLE hPrevInstance,
               LPSTR lpCmdLine,
               INT nCmdShow
               )
{
    INT           i;
    WORD          ret;
    INT           nHardDisk;
    HDC           hdcScreen;
    CHAR          szBuffer[128];
    HCURSOR       hcurArrow;
    WNDCLASS      wndClass;
    SAVE_WINDOW   win;
    HWND          hwnd;
    HANDLE hOld;
    LPSTR         lpT;
    TEXTMETRIC    tm;
    CHAR szTemp[80];

    ENTER("InitFileManager");
    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%d", IntToPtr(nCmdShow));

    // ProfStart();

    hAppInstance = hInstance;     // Preserve this instance's module handle
    /* Set the Global DTA Address. This must be done before ExecProgram. */
    DosGetDTAAddress();

    if (*lpCmdLine)
        nCmdShow = SW_SHOWMINNOACTIVE;

    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%d", IntToPtr(nCmdShow));

#ifdef LATER
    if (hPrevInstance) {
        // if we are already running bring up the other instance

        +++GetInstanceData - NOOP on 32BIT side+++(hPrevInstance, (NLPSTR)&hwndFrame, sizeof(HWND));

        if (hwndFrame) {

            hwnd = GetLastActivePopup(hwndFrame);

            BringWindowToTop(hwndFrame);

            if (IsIconic(hwndFrame))
                ShowWindow(hwndFrame, SW_RESTORE);
            else
                SetActiveWindow(hwnd);
        }
        LEAVE("InitFileManager");
        return FALSE;
    }
#else
    UNREFERENCED_PARAMETER(hPrevInstance);
    {
        HWND hwndT;
        BYTE szClass[20];

        if (CreateEvent(NULL, TRUE, FALSE, szFrameClass) == NULL) {
            for (hwndT = GetWindow(GetDesktopWindow(), GW_CHILD); hwndT;
                hwndT = GetWindow(hwndT, GW_HWNDNEXT)) {
                if (GetClassName(hwndT, szClass, sizeof(szClass)))
                    if (!lstrcmpi(szFrameClass, szClass)) {
                        SetForegroundWindow(hwndT);
                        if (IsIconic(hwndT))
                            ShowWindow(hwndT, SW_RESTORE);
                        return FALSE;
                    }
            }

            return FALSE;
        }
    }
#endif


    SetErrorMode(1);              // turn off critical error 

//    if (lpfnRegisterPenApp = (FNPENAPP)GetProcAddress((HANDLE)GetSystemMetrics(SM_PENWINDOWS), szPenReg))
//        (*lpfnRegisterPenApp)(1, TRUE);


    /* Remember the current directory. */
    SheGetDir(0, szOriginalDirPath);

    if (!GetWindowsDirectory(szTheINIFile, sizeof(szTheINIFile))) {
        szTheINIFile[0] = '\0';
    }

    AddBackslash(szTheINIFile);
    lstrcat(szTheINIFile, szINIFile);

    GetProfileString(szWindows, "Programs", szDefPrograms, szTemp, sizeof(szTemp));
    szPrograms = (LPSTR)LocalAlloc(LPTR, lstrlen(szTemp)+1);
    if (!szPrograms)
        szPrograms = szNULL;
    else
        lstrcpy(szPrograms, szTemp);

    BuildDocumentString();

    /* Deal with any RUN= or LOAD= lines in WIN.INI. */

    if (*lpCmdLine) {
        // skip spaces
        while (*lpCmdLine == ' ')
            lpCmdLine++;

        for (lpT = lpCmdLine; *lpT; lpT = AnsiNext(lpT)) {
            if (*lpT == ' ')
                break;
        }
        if (*lpT == ' ')
            *lpT++ = 0;

        ret = ExecProgram(lpCmdLine, lpT, NULL, FALSE);
        if (ret)
            MyMessageBox(NULL, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
        else
            nCmdShow = SW_SHOWMINNOACTIVE;
    }

    /* Read WINFILE.INI and set the approriate variables. */
    GetSettings();

    /* Read the International constants out of WIN.INI. */
    GetInternational();

    dyBorder = GetSystemMetrics(SM_CYBORDER);
    dyBorderx2 = dyBorder * 2;
    dxFrame = GetSystemMetrics(SM_CXFRAME) - dyBorder;

    dxDriveBitmap = DRIVES_WIDTH;
    dyDriveBitmap = DRIVES_HEIGHT;
    dxFolder = FILES_WIDTH;
    dyFolder = FILES_HEIGHT;

    if (!LoadBitmaps())
        return FALSE;

    hicoTree = LoadIcon(hAppInstance, MAKEINTRESOURCE(TREEICON));
    hicoTreeDir = LoadIcon(hAppInstance, MAKEINTRESOURCE(TREEDIRICON));
    hicoDir = LoadIcon(hAppInstance, MAKEINTRESOURCE(DIRICON));

    chFirstDrive = (CHAR)((wTextAttribs & TA_LOWERCASE) ? 'a' : 'A');

    // now build the parameters based on the font we will be using

    hdcScreen = GetDC(NULL);

    hOld = SelectObject(hdcScreen, hFont);
    GetTextStuff(hdcScreen);
    if (hOld)
        SelectObject(hdcScreen, hOld);

    dxClickRect = max(GetSystemMetrics(SM_CXDOUBLECLK) / 2, 2 * dxText);
    dyClickRect = max(GetSystemMetrics(SM_CYDOUBLECLK) / 2, dyText);

    hFontStatus = CreateFont(GetHeightFromPointsString("10"), 0, 0, 0, 400, 0, 0, 0,
                             ANSI_CHARSET, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, VARIABLE_PITCH | FF_SWISS, szHelv);

    hOld = SelectObject(hdcScreen, hFontStatus);

    GetTextMetrics(hdcScreen, &tm);

    if (hOld)
        SelectObject(hdcScreen, hOld);

    dyStatus = tm.tmHeight + tm.tmExternalLeading + 7 * dyBorder;
    dxStatusField = GetDeviceCaps(hdcScreen, LOGPIXELSX) * 3;

    ReleaseDC(NULL, hdcScreen);

    cDrives = UpdateDriveList();

    /* Create an array of INT 13h drive numbers (floppies only). */
    nFloppies = 0;
    nHardDisk = 0x80;
    for (i=0; i < cDrives; i++) {
        if (IsRemovableDrive(rgiDrive[i])) {
            /* Avoid Phantom B: problems. */
            if ((nFloppies == 1) && (i > 1))
                nFloppies = 2;
            nFloppies++;
        } else {
            nHardDisk++;
        }
    }

    /* Load the accelerator table. */
    hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(WFACCELTABLE));

    LoadString(hInstance, IDS_DIRSREAD, szDirsRead, sizeof(szDirsRead));
    LoadString(hInstance, IDS_BYTES, szBytes, sizeof(szBytes));
    LoadString(hInstance, IDS_SBYTES, szSBytes, sizeof(szSBytes));

    wDOSversion = DOS_320;

    wHelpMessage = RegisterWindowMessage("ShellHelp");
    wBrowseMessage = RegisterWindowMessage("commdlg_help");

    hhkMessageFilter = SetWindowsHook(WH_MSGFILTER, MessageFilter);

    hcurArrow = LoadCursor(NULL, IDC_ARROW);

    wndClass.lpszClassName  = szFrameClass;
    wndClass.style          = 0;
    wndClass.lpfnWndProc    = FrameWndProc;
    wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = 0;
    wndClass.hInstance      = hInstance;
    wndClass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(APPICON));
    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1); // COLOR_WINDOW+1;
    wndClass.lpszMenuName   = MAKEINTRESOURCE(FRAMEMENU);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szTreeClass;
    wndClass.style          = CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = TreeWndProc;
//  wndClass.cbClsExtra     = 0;
    wndClass.cbWndExtra     = sizeof(LONG) +// GWL_TYPE
                              sizeof(LONG) +// wViewStyle GWL_VIEW
                              sizeof(LONG) +// wSortStyle GWL_SORT
                              sizeof(LONG) +// dwAttrStyle GWL_ATTRIBS
                              sizeof(LONG) +// FSC flag GWL_FSCFLAG
                              sizeof(PVOID) +// hwndLastFocus GWL_LASTFOCUS
                              sizeof(LONG); // dxSplit GWL_SPLIT

    wndClass.hIcon          = NULL;
    wndClass.hCursor        = LoadCursor(hInstance, MAKEINTRESOURCE(SPLITCURSOR));
    wndClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wndClass.lpszMenuName   = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szDrivesClass;
    wndClass.style          = CS_HREDRAW | CS_VREDRAW;
    wndClass.lpfnWndProc    = DrivesWndProc;
    wndClass.cbWndExtra     = sizeof(LONG) +// GWL_CURDRIVEIND
                              sizeof(LONG) +// GWL_CURDRIVEFOCUS
                              sizeof(PVOID); // GWLP_LPSTRVOLUME

    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_BTNFACE+1);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szTreeControlClass;
    wndClass.style          = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = TreeControlWndProc;
    wndClass.cbWndExtra     = sizeof(LONG); // GWL_READLEVEL
    wndClass.hCursor        = hcurArrow;
    wndClass.hbrBackground  = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szDirClass;
    wndClass.style          = CS_VREDRAW | CS_HREDRAW;
    wndClass.lpfnWndProc    = DirWndProc;
    wndClass.cbWndExtra     = sizeof(PVOID)+ // DTA data GWLP_HDTA
                              sizeof(PVOID); // GWLP_TABARRAY

    wndClass.hIcon          = NULL;
    wndClass.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    wndClass.lpszClassName  = szSearchClass;
    wndClass.style          = 0;
    wndClass.lpfnWndProc    = SearchWndProc;
    wndClass.cbWndExtra     = sizeof(LONG) +        // GWL_TYPE
                              sizeof(LONG) +        // wViewStyle GWL_VIEW
                              sizeof(LONG) +        // wSortStyle GWL_SORT
                              sizeof(LONG) +        // dwAttrStyle GWL_ATTRIBS
                              sizeof(LONG) +        // FSC flag GWL_FSCFLAG
                              sizeof(PVOID) +       // GWLP_HDTASEARCH
                              sizeof(PVOID) +       // GWLP_TABARRAYSEARCH
                              sizeof(PVOID);        // GWLP_LASTFOCUSSEARCH

    wndClass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(DIRICON));
    wndClass.hbrBackground  = NULL;

    if (!RegisterClass(&wndClass)) {
        LEAVE("InitFileManager");
        return FALSE;
    }


    if (!LoadString(hInstance, IDS_WINFILE, szTitle, 32)) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    GetPrivateProfileString(szSettings, szWindow, szNULL, szBuffer, sizeof(szBuffer), szTheINIFile);
    GetSavedWindow(szBuffer, &win);


    if (!CreateWindowEx(0, szFrameClass, szTitle,WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                        win.rc.left, win.rc.top, win.rc.right, win.rc.bottom,
                        NULL, NULL, hInstance, NULL)) {

        LEAVE("InitFileManager - Frame class creation failure");
        return FALSE;
    }


    InitMenus();            // after the window/menu has been created

    // support forced min or max

    if (nCmdShow == SW_SHOWNORMAL && win.sw == SW_SHOWMAXIMIZED)
        nCmdShow = SW_SHOWMAXIMIZED;

    ShowWindow(hwndFrame, nCmdShow);
    UpdateWindow(hwndFrame);

    LFNInit();

    if (!CreateSavedWindows()) {
        LEAVE("InitFileManager");
        return FALSE;
    }

    ShowWindow(hwndMDIClient, SW_NORMAL);

    // now refresh all tree windows (start background tree read)
    //
    // since the tree reads happen in the background the user can
    // change the Z order by activating windows once the read
    // starts.  to avoid missing a window we must restart the
    // search through the MDI child list, checking to see if the
    // tree has been read yet (if there are any items in the
    // list box).  if it has not been read yet we start the read

    hwnd = GetWindow(hwndMDIClient, GW_CHILD);

    while (hwnd) {
        HWND hwndTree;

        if ((hwndTree = HasTreeWindow(hwnd)) &&
            (INT)SendMessage(GetDlgItem(hwndTree, IDCW_TREELISTBOX), LB_GETCOUNT, 0, 0L) == 0) {
            SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);
            hwnd = GetWindow(hwndMDIClient, GW_CHILD);
        } else {
            hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        }
    }

    // ProfStop();

    LEAVE("InitFileManager - OK");
    return TRUE;
}


VOID
APIENTRY
DeleteBitmaps()
{
    ENTER("DeleteBitmaps");

    if (hdcMem) {

        SelectObject(hdcMem, hbmSave);

        if (hbmBitmaps)
            DeleteObject(hbmBitmaps);
        DeleteDC(hdcMem);
    }
    LEAVE("DeleteBitmaps");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FreeFileManager() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
FreeFileManager()
{
    ENTER("FreeFileManager");


    if (lpfnRegisterPenApp)
        (*lpfnRegisterPenApp)(1, FALSE);

    DeleteBitmaps();

    if (hFont)
        DeleteObject(hFont);

    if (hFontStatus)
        DeleteObject(hFontStatus);

    LEAVE("FreeFileManager");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfhelp.h ===
#define IDH_HELPFIRST		5000
#define IDH_SYSMENU	(IDH_HELPFIRST + 2000)

#define IDH_MBFIRST		(IDH_HELPFIRST + 2001)
#define IDH_ASSOC_BROWSE	(IDH_HELPFIRST + 2002)
// NB Removed IDH_RUN_BROWSE_
#define IDH_FONT 		(IDH_HELPFIRST + 2004)
#define IDH_MBLAST		(IDH_HELPFIRST + 2099)

#define IDH_DLGFIRST	(IDH_HELPFIRST + 3000)

#define IDH_MB_FORMATCURERR	(IDH_MBFIRST + 0)

#define IDH_DLG_PREV		(IDH_DLGFIRST + PREVIOUSDLG)
#define IDH_DLG_CONFIRMREPLACE	(IDH_DLGFIRST + CONFIRMREPLACE)
#define IDH_DLG_CONFIRMRMDIR	(IDH_DLGFIRST + CONFIRMRMDIR)
#define IDH_DLG_CONFIRMRENAME	(IDH_DLGFIRST + CONFIRMRENAME)
#define IDH_DLG_CONFIRMMOVE	(IDH_DLGFIRST + CONFIRMMOVE)
#define IDH_DLG_CONFIRMDEL	(IDH_DLGFIRST + CONFIRMDELETE)


#define IDH_FILE 	(IDM_FILE + IDH_HELPFIRST)
#define IDH_OPEN 	(IDM_OPEN + IDH_HELPFIRST)
#define IDH_PRINT 	(IDM_PRINT + IDH_HELPFIRST)
#define IDH_ASSOCIATE 	(IDM_ASSOCIATE + IDH_HELPFIRST)
#define IDH_SEARCH 	(IDM_SEARCH + IDH_HELPFIRST)
#define IDH_RUN  	(IDM_RUN  + IDH_HELPFIRST)
#define IDH_MOVE 	(IDM_MOVE + IDH_HELPFIRST)
#define IDH_COPY 	(IDM_COPY + IDH_HELPFIRST)
#define IDH_DELETE 	(IDM_DELETE + IDH_HELPFIRST)
#define IDH_RENAME 	(IDM_RENAME + IDH_HELPFIRST)
#define IDH_ATTRIBS 	(IDM_ATTRIBS + IDH_HELPFIRST)
#define IDH_MAKEDIR 	(IDM_MAKEDIR + IDH_HELPFIRST)
#define IDH_SELALL 	(IDM_SELALL + IDH_HELPFIRST)
#define IDH_DESELALL 	(IDM_DESELALL + IDH_HELPFIRST)
#define IDH_UNDO 	(IDM_UNDO + IDH_HELPFIRST)
#define IDH_EXIT 	(IDM_EXIT + IDH_HELPFIRST)
#define IDH_SELECT 	(IDM_SELECT + IDH_HELPFIRST)
#define IDH_UNDELETE 	(IDM_UNDELETE + IDH_HELPFIRST)
#define IDH_GROUP_ATTRIBS 	(118 + IDH_HELPFIRST)
#define IDH_DISK 	(IDM_DISK + IDH_HELPFIRST)
#define IDH_DISKCOPY 	(IDM_DISKCOPY + IDH_HELPFIRST)
#define IDH_LABEL 	(IDM_LABEL + IDH_HELPFIRST)
#define IDH_FORMAT 	(IDM_FORMAT + IDH_HELPFIRST)
#define IDH_SYSDISK 	(IDM_SYSDISK + IDH_HELPFIRST)
#define IDH_CONNECT 	(IDM_CONNECT + IDH_HELPFIRST)
#define IDH_DISCONNECT 	(IDM_DISCONNECT + IDH_HELPFIRST)
#define IDH_CONNECTIONS (IDM_CONNECTIONS + IDH_HELPFIRST)
#define IDH_DRIVESMORE 	(IDM_DRIVESMORE + IDH_HELPFIRST)
#define IDH_TREE 	(IDM_TREE + IDH_HELPFIRST)
#define IDH_EXPONE 	(IDM_EXPONE + IDH_HELPFIRST)
#define IDH_EXPSUB 	(IDM_EXPSUB + IDH_HELPFIRST)
#define IDH_EXPALL 	(IDM_EXPALL + IDH_HELPFIRST)
#define IDH_COLLAPSE 	(IDM_COLLAPSE + IDH_HELPFIRST)
#define IDH_VIEW 	(IDM_VIEW + IDH_HELPFIRST)
#define IDH_VNAME 	(IDM_VNAME + IDH_HELPFIRST)
#define IDH_VDETAILS 	(IDM_VDETAILS + IDH_HELPFIRST)
#define IDH_VOTHER 	(IDM_VOTHER + IDH_HELPFIRST)
#define IDH_BYNAME 	(IDM_BYNAME + IDH_HELPFIRST)
#define IDH_BYTYPE 	(IDM_BYTYPE + IDH_HELPFIRST)
#define IDH_BYSIZE 	(IDM_BYSIZE + IDH_HELPFIRST)
#define IDH_BYDATE 	(IDM_BYDATE + IDH_HELPFIRST)
#define IDH_VINCLUDE 	(IDM_VINCLUDE + IDH_HELPFIRST)
#define IDH_REPLACE 	(IDM_REPLACE + IDH_HELPFIRST)
#define IDH_TREEONLY 	(IDM_TREEONLY + IDH_HELPFIRST)
#define IDH_DIRONLY 	(IDM_DIRONLY + IDH_HELPFIRST)
#define IDH_BOTH 	(IDM_BOTH + IDH_HELPFIRST)
#define IDH_SPLIT 	(IDM_SPLIT + IDH_HELPFIRST)
#define IDH_OPTIONS 	(IDM_OPTIONS + IDH_HELPFIRST)
#define IDH_CONFIRM 	(IDM_CONFIRM + IDH_HELPFIRST)
#define IDH_FONT_MENU 	(IDM_FONT + IDH_HELPFIRST)
#define IDH_LOWERCASE 	(IDM_LOWERCASE + IDH_HELPFIRST)
#define IDH_STATUSBAR 	(IDM_STATUSBAR + IDH_HELPFIRST)
#define IDH_MINONRUN 	(IDM_MINONRUN + IDH_HELPFIRST)
#define IDH_ADDPLUSES 	(IDM_ADDPLUSES + IDH_HELPFIRST)
#define IDH_EXPANDTREE 	(IDM_EXPANDTREE + IDH_HELPFIRST)
#define IDH_SAVESETTINGS 	(IDM_SAVESETTINGS + IDH_HELPFIRST)
#define IDH_EXTENSIONS 	(IDM_EXTENSIONS + IDH_HELPFIRST)
#define IDH_WINDOW 	(IDM_WINDOW + IDH_HELPFIRST)
#define IDH_CASCADE 	(IDM_CASCADE + IDH_HELPFIRST)
#define IDH_TILE 	(IDM_TILE + IDH_HELPFIRST)
#define IDH_REFRESH 	(IDM_REFRESH + IDH_HELPFIRST)
#define IDH_CLOSEALL 	(IDM_CLOSEALL + IDH_HELPFIRST)
#define IDH_CHILDSTART 	(IDM_CHILDSTART + IDH_HELPFIRST)
#define IDH_SAVE 	(IDM_SAVE + IDH_HELPFIRST)
#define IDH_ARRANGE 	(IDM_ARRANGE + IDH_HELPFIRST)
#define IDH_NEWWINDOW 	(IDM_NEWWINDOW + IDH_HELPFIRST)
#define IDH_HELPGENERAL (IDM_HELP + IDH_HELPFIRST)
#define IDH_HELPINDEX 	(IDM_HELPINDEX + IDH_HELPFIRST)
#define IDH_HELPKEYS 	(IDM_HELPKEYS + IDH_HELPFIRST)
#define IDH_HELPCOMMANDS 	(IDM_HELPCOMMANDS + IDH_HELPFIRST)
#define IDH_HELPPROCS 	(IDM_HELPPROCS + IDH_HELPFIRST)
#define IDH_HELPHELP 	(IDM_HELPHELP + IDH_HELPFIRST)
#define IDH_ABOUT 	(IDM_ABOUT + IDH_HELPFIRST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfprint.c ===
/****************************************************************************/
/*                                                                          */
/*  WFPRINT.C -                                                             */
/*                                                                          */
/*      Windows Print Routines                                              */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winexp.h"

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  PrintFile() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD
PrintFile(
         HWND hwnd,
         LPSTR szFile
         )
{
    WORD          ret;
    INT           iCurCount;
    INT           i;
    HCURSOR       hCursor;

    ret = 0;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    iCurCount = ShowCursor(TRUE) - 1;

    /* open the object            +++ ShellExecute() returns an hInstance?!?!?
     */
    ret = (WORD)RealShellExecute(hwnd, "print", szFile, "", NULL, NULL, NULL, NULL, SW_SHOWNORMAL, NULL);

    DosResetDTAAddress(); // undo any bad things COMMDLG did
    switch (ret) {
        case 0:
        case 8:
            ret = IDS_NOMEMORYMSG;
            break;

        case 2:
            ret = IDS_FILENOTFOUNDMSG;
            break;

        case 3:
        case 5:   // access denied
            ret = IDS_BADPATHMSG;
            break;

        case 4:
            ret = IDS_MANYOPENFILESMSG;
            break;

        case 10:
            ret = IDS_NEWWINDOWSMSG;
            break;

        case 12:
            ret = IDS_OS2APPMSG;
            break;

        case 15:
            /* KERNEL has already put up a messagebox for this one. */
            ret = 0;
            break;

        case 16:
            ret = IDS_MULTIPLEDSMSG;
            break;

        case 18:
            ret = IDS_PMODEONLYMSG;
            break;

        case 19:
            ret = IDS_COMPRESSEDEXE;
            break;

        case 20:
            ret = IDS_INVALIDDLL;
            break;

        case SE_ERR_SHARE:
            ret = IDS_SHAREERROR;
            break;

        case SE_ERR_ASSOCINCOMPLETE:
            ret = IDS_ASSOCINCOMPLETE;
            break;

        case SE_ERR_DDETIMEOUT:
        case SE_ERR_DDEFAIL:
        case SE_ERR_DDEBUSY:
            ret = IDS_DDEFAIL;
            break;

        case SE_ERR_NOASSOC:
            ret = IDS_NOASSOCMSG;
            break;

        default:
            if (ret < 32)
                goto EPExit;
            ret = 0;
    }

    EPExit:
    i = ShowCursor(FALSE);

    /* Make sure that the cursor count is still balanced. */
    if (i != iCurCount)
        ShowCursor(TRUE);

    SetCursor(hCursor);

    return (ret);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WFPrint() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

WORD
APIENTRY
WFPrint(
       LPSTR pSel
       )
{
    CHAR szFile[MAXPATHLEN];
    CHAR szTemp[20];
    WORD ret;

    /* Turn off the print button. */
    if (hdlgProgress)
        EnableWindow(GetDlgItem(hdlgProgress, IDOK), FALSE);

    bUserAbort = FALSE;

    if (!(pSel = GetNextFile(pSel, szFile, sizeof(szFile))))
        return TRUE;

    /* See if there is more than one file to print.  Abort if so
     */
    if (pSel = GetNextFile(pSel, szTemp, sizeof(szTemp))) {
        MyMessageBox(hwndFrame, IDS_WINFILE, IDS_PRINTONLYONE, MB_OK | MB_ICONEXCLAMATION);
        return (FALSE);
    }

    if (hdlgProgress) {
        /* Display the name of the file being printed. */
        LoadString(hAppInstance, IDS_PRINTINGMSG, szTitle, 32);
        wsprintf(szMessage, szTitle, (LPSTR)szFile);
        SetDlgItemText(hdlgProgress, IDD_STATUS, szMessage);
    }

    ret = PrintFile(hdlgProgress ? hdlgProgress : hwndFrame, szFile);

    if (ret) {
        MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfsearch.c ===
/****************************************************************************/
/*                                                                          */
/*  WFSEARCH.C -                                                            */
/*                                                                          */
/*      File System Search Routines                                         */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"

INT maxExt;
INT iDirsRead;
DWORD LastUpdateTime;


WORD APIENTRY StackAvail(VOID);
INT FillSearchLB(HWND hwndLB, LPSTR szSearchFileSpec, BOOL bSubDirOnly);
INT SearchList(HWND hwndLB, LPSTR szPath, LPSTR szFileSpec, BOOL bRecurse, LPHANDLE lphMem, INT iFileCount);
LPSTR SearchGetSelection(HWND hwndLB, BOOL bMostRecent, BOOL *pfDir);


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchList() -                                                          */
/*                                                                          */
/*  This is a recursive routine.  It returns the number of files found.     */
//  szPath      OEM
//  szFileSpec  OEM
/*                                                                          */
/*--------------------------------------------------------------------------*/

#define DTA_GRANULARITY 20

INT
SearchList(
          HWND hwndLB,
          LPSTR szPath,
          LPSTR szFileSpec,
          BOOL bRecurse,
          LPHANDLE lphMem,
          INT iFileCount
          )
{
    INT           iRetVal;
    INT           cxExt;
    BOOL          bFound;
    LPSTR          pszNewPath;
    LPSTR          pszNextFile;
    LFNDTA        lfndta;
    LPDTASEARCH   lpdtasch;
    HDC hdc;
    HANDLE hOld;
    HANDLE hMem, hMemT;
    DWORD     TimeNow;
    DWORD NewPathLen;

    STKCHK();

    hMem = *lphMem;

    /* Just return 0 files so parent dirs will still be searched
     */
    if (StackAvail() < 1024)
        return(iFileCount);

    TimeNow = GetTickCount();

    if (TimeNow > LastUpdateTime+1000) {
        LastUpdateTime = TimeNow;
        if (LoadString(hAppInstance, IDS_DIRSREAD, szMessage, sizeof(szMessage)))
            wsprintf(szStatusTree, szMessage, iDirsRead);

        InvalidateRect(hwndFrame, NULL, FALSE);
        UpdateWindow(hwndFrame);
    }

    iDirsRead++;

    if (!hMem) {
        hMem = LocalAlloc(LPTR, (DWORD)DTA_GRANULARITY * sizeof(DTASEARCH));
        if (!hMem)
            return -1;
        *lphMem = hMem;
    }
    lpdtasch = (LPDTASEARCH)LocalLock(hMem);

    // allocate the buffer for this level
    NewPathLen = lstrlen(szPath) + MAXFILENAMELEN + 2;
    pszNewPath = (LPSTR)LocalAlloc(LPTR, NewPathLen);
    if (!pszNewPath)
        return -1;

    strncpy(pszNewPath, szPath, NewPathLen-1);
    AddBackslash(pszNewPath);
    pszNextFile = pszNewPath + lstrlen(pszNewPath);
    strncpy(pszNextFile, szFileSpec, pszNewPath + NewPathLen - pszNextFile - 1);

    bFound = WFFindFirst(&lfndta, pszNewPath, ATTR_ALL);

    hdc = GetDC(hwndLB);
    hOld = SelectObject(hdc, hFont);

    while (bFound) {

        // alow escape to exit
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            bRecurse = FALSE;
            iFileCount = -1;
            break;
        }

        // Make sure this is not a "." or ".." directory

        if (lfndta.fd.cFileName[0] != '.') {
            BOOL bLFN;

            *pszNextFile = '\0';
            strncpy(pszNextFile, lfndta.fd.cFileName, pszNewPath + NewPathLen - pszNextFile - 1 );
            OemToCharBuff(pszNewPath, szMessage, NewPathLen);

            bLFN = IsLFN(lfndta.fd.cFileName);

            iRetVal = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szMessage);

            MGetTextExtent(hdc, szMessage, lstrlen(szMessage), &cxExt, NULL);
            maxExt = max(maxExt, cxExt);

            if (iRetVal >= 0) {

                if (iFileCount && ((iFileCount % DTA_GRANULARITY) == 0)) {
                    LocalUnlock(hMem);

                    if (!(hMemT = LocalReAlloc(hMem, (DWORD)((iFileCount + DTA_GRANULARITY) * sizeof(DTASEARCH)), LMEM_MOVEABLE))) {
                        LocalLock(hMem);
                        bRecurse = FALSE;       // simulate an abort
                        iFileCount = -1;
                        break;
                    } else {
                        hMem = hMemT;
                        *lphMem = hMemT;
                    }

                    lpdtasch = (LPDTASEARCH)LocalLock(hMem);
                }
                lpdtasch[iFileCount] = *((LPDTASEARCH)(&lfndta.fd));
                if (bLFN)
                    lpdtasch[iFileCount].sch_dwAttrs |= ATTR_LFN;
                SendMessage(hwndLB, LB_SETITEMDATA, iRetVal, (LONG)iFileCount);
                iFileCount++;
            }
        }

        /* Search for more files in the current directory */
        bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    if (hOld)
        SelectObject(hdc, hOld);
    ReleaseDC(hwndLB, hdc);

    LocalUnlock(hMem);
    SetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH, (LONG_PTR)hMem);

    if (!bRecurse)
        goto SearchEnd;

    /* Now see if there are any subdirectories here */
    lstrcpy(pszNextFile, szStarDotStar);

    bFound = WFFindFirst(&lfndta, pszNewPath, ATTR_DIR | ATTR_HS);

    while (bFound) {

        // alow escape to exit
        if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) {
            bRecurse = FALSE;
            iFileCount = -1;
            break;
        }

        /* Make sure this is not a "." or ".." directory. */
        if ((lfndta.fd.cFileName[0] != '.') && (lfndta.fd.dwFileAttributes & ATTR_DIR)) {
            /* Yes, search and add files in this directory */
            lstrcpy(pszNextFile, lfndta.fd.cFileName);

            /* Add all files in this subdirectory. */
            if ((iRetVal = SearchList(hwndLB, pszNewPath, szFileSpec, bRecurse, lphMem, iFileCount)) < 0) {
                iFileCount = iRetVal;
                break;
            }
            iFileCount = iRetVal;

        }
        bFound = WFFindNext(&lfndta);
    }

    WFFindClose(&lfndta);

    SearchEnd:

    LocalFree((HANDLE)pszNewPath);
    return iFileCount;
}


VOID
FixUpFileSpec(
             LPSTR szFileSpec
             )
{
    CHAR szTemp[MAXPATHLEN+1];
    register LPSTR p;

    if (*szFileSpec == '.') {
        lstrcpy(szTemp, "*");
        lstrcat(szTemp, szFileSpec);
        lstrcpy(szFileSpec, szTemp);
    }


    /* HACK:  If there isn't a dot and the last char is a *, append ".*" */
    p = szFileSpec;
    while ((*p) && (*p != '.'))
        p = AnsiNext(p);

    if ((!*p) && (p != szFileSpec)) {
        p = AnsiPrev(szFileSpec, p);
        if (*p == '*')
            lstrcat(p, ".*");
    }

}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FillSearchLB() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/*  This parses the given string for Drive, PathName, FileSpecs and
 *  calls SearchList() with proper parameters;
 *
 *  hwndLB           : List box where files are to be displayed;
 *  szSearchFileSpec : ANSI path to search
 *  bSubDirOnly      : TRUE, if only subdirectories are to be searched;
 */

INT
FillSearchLB(
            HWND hwndLB,
            LPSTR szSearchFileSpec,
            BOOL bRecurse
            )
{
    INT           iRet;
    HCURSOR       hCursor;
    CHAR          szFileSpec[MAXPATHLEN+1];
    CHAR          szPathName[MAXPATHLEN+1];
    HANDLE        hMemIn = NULL;

    FixAnsiPathForDos(szSearchFileSpec);
    /* Get the file specification part of the string. */
    lstrcpy(szFileSpec, szSearchFileSpec);
    lstrcpy(szPathName, szSearchFileSpec);
    StripPath(szFileSpec);
    StripFilespec(szPathName);

    FixUpFileSpec(szFileSpec);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);
    maxExt = 0;
    iDirsRead = 1;
    LastUpdateTime = 0;
    iRet = SearchList(hwndLB, szPathName, szFileSpec, bRecurse, &hMemIn, 0);
    ShowCursor(FALSE);
    SetCursor(hCursor);

    SendMessage(hwndLB, LB_SETSEL, TRUE, 0L);

    return(iRet);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SearchGetSelection() -                                                  */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns a string containing the names of the selected
 * files seperated by spaces.  If bMostRecent is TRUE, it only returns the
 * most recently selected file.
 *
 * The string is returned and a *pfDir is set indicating if it points
 * to a directory.
 *
 * NOTE: The caller must free the returned pointer!
 */

LPSTR
SearchGetSelection(
                  HWND hwndLB,
                  BOOL bMostRecent,
                  BOOL *pfDir
                  )
{
    register LPSTR p;
    LPSTR          pT;
    register WORD i;
    WORD          iMac;
    WORD          cch = 1;
    BOOL          bDir;
    HANDLE hMem;
    LPDTASEARCH lpdtasch;
    CHAR szTemp[MAXPATHLEN];

    BOOL bLFNTest;

    if (bLFNTest = (bMostRecent == 2)) {
        bMostRecent = FALSE;
    } else {
        p = (LPSTR)LocalAlloc(LPTR, 1);
        if (!p)
            return NULL;
    }

    if (bMostRecent == 3)
        bMostRecent = 0;

    bDir = TRUE;

    iMac = (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

    hMem = (HANDLE)GetWindowLongPtr(GetParent(hwndLB), GWLP_HDTASEARCH);

    lpdtasch = (LPDTASEARCH)LocalLock(hMem);

    for (i=0; i < iMac; i++) {
        if (!(BOOL)SendMessage(hwndLB, LB_GETSEL, i, 0L))
            continue;

        cch += (WORD)SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)szTemp);
        cch++;

        if (bLFNTest) {
            if (IsLFN(szTemp)) {
                if (pfDir)
                    *pfDir = TRUE;
                return NULL;
            }
        } else {
            pT = (LPSTR)LocalReAlloc((HANDLE)p, cch, LMEM_MOVEABLE | LMEM_ZEROINIT);
            if (!pT)
                goto SGSExit;
            p = pT;
            lstrcat(p, szTemp);

            bDir = lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, i, 0L)].sch_dwAttrs & ATTR_DIR;

            if (bMostRecent)
                break;

            lstrcat(p, szBlank);
        }
    }
    SGSExit:
    LocalUnlock(hMem);

    if (bLFNTest) {
        if (pfDir)
            *pfDir = FALSE;
        return NULL;
    }

    if (pfDir)
        *pfDir = bDir;
    return(p);
}


VOID
CreateLine(
          WORD wLineFormat,
          LPSTR szFile,
          LPDTASEARCH lpdtasch,
          LPSTR szBuffer
          )
{
    LPSTR pch;
    BYTE chAttribute;

    pch = szBuffer;

    chAttribute = (BYTE)lpdtasch->sch_dwAttrs;

    /* Copy the file name. */
    lstrcpy(pch, szFile);
    pch += lstrlen(pch);

    *pch = TEXT('\0');

    /* Should we show the size? */
    if (wLineFormat & VIEW_SIZE) {
        *pch++ = TABCHAR;
        if (!(chAttribute & ATTR_DIR))
            pch += PutSize(lpdtasch->sch_nFileSizeLow, pch);
    }

    /* Should we show the date? */
    if (wLineFormat & VIEW_DATE) {
        *pch++ = TABCHAR;
        pch += PutDate(&lpdtasch->sch_ftLastWriteTime, pch);
    }

    /* Should we show the time? */
    if (wLineFormat & VIEW_TIME) {
        *pch++ = TABCHAR;
        pch += PutTime(&lpdtasch->sch_ftLastWriteTime, pch);
    }

    /* Should we show the attributes? */
    if (wLineFormat & VIEW_FLAGS) {
        *pch++ = TABCHAR;
        pch += PutAttributes((WORD)chAttribute, pch);
    }
}


// the window text looks like "Search Window: C:\FOO\BAR\*.*"

VOID
GetSearchPath(
             HWND hWnd,
             LPSTR pszPath
             )
{
    LPSTR p;

    CHAR szTemp[MAXPATHLEN+32];

    // the search window doesn't have a current directory
    GetWindowText(hWnd, szTemp, sizeof(szTemp));

    // the window text looks like "Search Window: C:\FOO\BAR\*.*"
    p = szTemp;
    while (*p && *p != ':') // find the :
        p = AnsiNext(p);

    p += 2;                 // skip the ": "

    lstrcpy(pszPath, p);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  UpdateSearchStatus() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

VOID
UpdateSearchStatus(
                  HWND hwndLB
                  )
{
    INT nCount;

    nCount = (INT)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);
    if (LoadString(hAppInstance, IDS_SEARCHMSG, szMessage, sizeof(szMessage)))
        wsprintf(szStatusTree, szMessage, nCount);
    szStatusDir[0] = '\0';
    InvalidateRect(hwndFrame, NULL, FALSE);
}

/*--------------------------------------------------------------------------*/
/*                                      */
/*  SearchWndProc() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
SearchWndProc(
             register HWND hWnd,
             UINT wMsg,
             WPARAM wParam,
             LPARAM lParam
             )
{
    INT  iRet;
    INT  iSel;
    HWND hwndLB;
    CHAR szTemp[MAXPATHLEN + 32];
    CHAR szPath[MAXPATHLEN];

    STKCHK();

    hwndLB = GetDlgItem(hWnd, IDCW_LISTBOX);

    switch (wMsg) {
        case FS_GETDRIVE:
            MSG("SearchWndProc", "FS_GETDRIVE");
            // Returns the letter of the corresponding directory

            SendMessage(hWnd, FS_GETDIRECTORY, sizeof(szPath), (LPARAM)szPath);
            return szPath[0];     // first character

        case FS_GETDIRECTORY:
            MSG("SearchWndProc", "FS_GETDIRECTORY");

            GetSearchPath(hWnd, szPath);

            StripFilespec(szPath);        // remove the filespec
            AddBackslash(szPath);         // to be the same as DirWndProc
            lstrcpy((LPSTR)lParam, szPath);
            break;

        case FS_GETFILESPEC:

            MSG("SearchWndProc", "FS_GETFILESPEC");
            // the search window doesn't have a current directory
            GetSearchPath(hWnd, szPath);
            StripPath(szPath);                    // remove the path (leave the filespec)
            lstrcpy((LPSTR)lParam, szPath);
            break;

        case FS_SETSELECTION:
            MSG("SearchWndProc", "FS_SETSELECTION");
            // wParam is the select(TRUE)/unselect(FALSE) param
            // lParam is the filespec to match against

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            DSSetSelection(hwndLB, wParam ? TRUE : FALSE, (LPSTR)lParam, TRUE);
            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            break;

        case FS_GETSELECTION:
            MSG("SearchWndProc", "FS_GETSELECTION");
            return (INT_PTR)SearchGetSelection(hwndLB, wParam ? TRUE : FALSE, (BOOL *)lParam);
            break;

        case WM_MDIACTIVATE:
            if (wParam) {
                UpdateSearchStatus(hwndLB);

                // if we are dirty, ask if we should update

                if (GetWindowLong(hWnd, GWL_FSCFLAG))
                    PostMessage(hWnd, FS_CHANGEDISPLAY, CD_SEARCHUPDATE, 0L);
            }
            break;

        case WM_FILESYSCHANGE:
            SetWindowLong(hWnd, GWL_FSCFLAG, TRUE);   // I need updating

            // if the search window is not active or FSCs are disabled
            // don't prompt now, wait till we get the end FSC or are
            // activated (above in WM_ACTIVATE)
            if (cDisableFSC ||
                (hWnd != (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L)) &&
                (GetActiveWindow() != hwndFrame))
                break;

            PostMessage(hWnd, FS_CHANGEDISPLAY, CD_SEARCHUPDATE, 0L);
            break;

        case FS_CHANGEDISPLAY:
            MSG("SearchWndProc", "FS_CHANGEDISPLAY");

            SetWindowLong(hWnd, GWL_FSCFLAG, FALSE);  // I am clean

            if (wParam == CD_SEARCHUPDATE) {
                LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SEARCHREFRESH, szMessage, sizeof(szMessage));
                if (MessageBox(hWnd, szMessage, szTitle, MB_YESNO | MB_ICONQUESTION) != IDYES)
                    break;
            }

            // is this a refresh?

            if (!lParam) {
                GetSearchPath(hWnd, szPath);
            } else {
                lstrcpy(szPath, (LPSTR)lParam);   // explicit re-search
            }

            LoadString(hAppInstance, IDS_SEARCHTITLE, szMessage, 32);
            lstrcat(szMessage, szPath);
            SetWindowText(hWnd, szMessage);

            SendMessage(hwndLB, WM_SETREDRAW, FALSE, 0L);
            SendMessage(hwndLB, LB_RESETCONTENT, 0, 0L);

            iRet = FillSearchLB(hwndLB, szPath, bSearchSubs);

            FixTabsAndThings(hwndLB,(WORD *)GetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH), maxExt + dxText,wNewView);

            SendMessage(hwndLB, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hwndLB, NULL, TRUE);
            if (iRet == 0) {
                LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                LoadString(hAppInstance, IDS_SEARCHNOMATCHES, szMessage, sizeof(szMessage));
                MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONINFORMATION);

                ShowWindow(hWnd, SW_HIDE);
                PostMessage(hWnd, WM_CLOSE, 0, 0L);
                return FALSE;
            } else {
                UpdateSearchStatus(hwndLB);
            }

            if (GetFocus() != hwndLB)
                return(iRet);

            /*** FALL THRU ***/

        case WM_SETFOCUS:
            MSG("SearchWndProc", "WM_SETFOCUS");

            SetFocus(hwndLB);
            return (WORD)SendMessage(hwndLB, LB_GETCOUNT, 0, 0L);

        case WM_CLOSE:
            MSG("SearchWndProc", "WM_CLOSE");
            hwndSearch = NULL;
            goto DefChildProc;

        case WM_COMMAND:
            /* Was this a double-click? */
            if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_DBLCLK)
                SendMessage(hwndFrame, WM_COMMAND, GET_WM_COMMAND_MPS(IDM_OPEN, 0, 0));
            else if (GET_WM_COMMAND_CMD(wParam, lParam) == LBN_SELCHANGE) {
                INT i;
                for (i = 0; i < iNumExtensions; i++) {
                    (extensions[i].ExtProc)(hwndFrame, FMEVENT_SELCHANGE, 0L);
                }
            }
            break;

        case WM_DESTROY:
            MSG("SearchWndProc", "WM_DESTROY");
            {
                HANDLE hMem;

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH))
                    LocalFree(hMem);

                if (hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH))
                    LocalFree(hMem);
            }
            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "SearchWndProc - WM_CREATE");
            {
                // globals used:
                //    szSearch        path to start search at
                //    bSearchSubs     tells us to do a recursive search

                RECT      rc;
                WORD      *pwTabs;

                GetClientRect(hWnd, &rc);
                hwndLB = CreateWindowEx(0, szListbox, NULL,
                                        WS_CHILD | WS_BORDER | LBS_SORT | LBS_NOTIFY |
                                        LBS_OWNERDRAWFIXED | LBS_EXTENDEDSEL |
                                        LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT |
                                        LBS_HASSTRINGS | WS_VSCROLL | WS_HSCROLL | WS_VISIBLE,
                                        -1, -1, rc.right+2, rc.bottom+2,
                                        hWnd, (HMENU)IDCW_LISTBOX,
                                        hAppInstance, NULL);
                if (!hwndLB)
                    return -1L;

                if ((pwTabs = (WORD *)LocalAlloc(LPTR,sizeof(WORD) * 4)) == NULL)
                    return -1L;

                hwndSearch = hWnd;
                SetWindowLong(hWnd, GWL_TYPE,   TYPE_SEARCH);
                SetWindowLong(hWnd, GWL_VIEW,   wNewView);
                SetWindowLong(hWnd, GWL_SORT,   IDD_NAME);
                SetWindowLong(hWnd, GWL_ATTRIBS,ATTR_DEFAULT);
                SetWindowLong(hWnd, GWL_FSCFLAG,   FALSE);
                SetWindowLongPtr(hWnd, GWLP_HDTASEARCH, 0);
                SetWindowLongPtr(hWnd, GWLP_TABARRAYSEARCH, (LONG_PTR)pwTabs);
                SetWindowLongPtr(hWnd, GWLP_LASTFOCUSSEARCH, (LONG_PTR)hwndLB);

                // Fill the listbox
                if (!FillSearchLB(hwndLB, szSearch, bSearchSubs)) {
                    LoadString(hAppInstance, IDS_SEARCHTITLE, szTitle, sizeof(szTitle));
                    LoadString(hAppInstance, IDS_SEARCHNOMATCHES, szMessage, sizeof(szMessage));
                    MessageBox(hwndFrame, szMessage, szTitle, MB_OK | MB_ICONINFORMATION);
                    hwndSearch = NULL;
                    return -1L;
                } else {
                    FixTabsAndThings(hwndLB,pwTabs, maxExt + dxText,wNewView);
                    SendMessage(hwndLB, WM_SETFONT, (WPARAM)hFont, 0L);
                    ShowWindow(hwndSearch, SW_SHOWNORMAL);
                }

                break;
            }

        case WM_DRAGLOOP:
            MSG("SearchWndProc", "WM_DRAGLOOP");
            /* WM_DRAGLOOP is sent to the source window as the object is moved.
             *
             *    wParam: TRUE if the object is currently over a droppable sink
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGLOOP is used to turn the source bitmaps on/off as we drag. */

            DSDragLoop(hwndLB, wParam, (LPDROPSTRUCT)lParam, TRUE);
            break;

        case WM_DRAGSELECT:
            MSG("SearchWndProc", "WM_DRAGSELECT");
            /* WM_DRAGSELECT is sent to a sink whenever an new object is dragged
             * inside of it.
             *
             *    wParam: TRUE if the sink is being entered, FALSE if it's being
             *            exited.
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGSELECT is used to turn our selection rectangle on or off. */
#define lpds ((LPDROPSTRUCT)lParam)

            iSelHilite = LOWORD(lpds->dwControlData);
            DSRectItem(hwndLB, iSelHilite, (BOOL)wParam, TRUE);
            break;

        case WM_DRAGMOVE:
            MSG("SearchWndProc", "WM_DRAGMOVE");
            /* WM_DRAGMOVE is sent to a sink as the object is being dragged
             * within it.
             *
             *    wParam: Unused
             *    lParam: LPDROPSTRUCT
             */

            /* DRAGMOVE is used to move our selection rectangle among sub-items. */

#define lpds ((LPDROPSTRUCT)lParam)

            /* Get the subitem we are over. */
            iSel = LOWORD(lpds->dwControlData);

            /* Is it a new one? */
            if (iSel == iSelHilite)
                break;

            /* Yup, un-select the old item. */
            DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);

            /* Select the new one. */
            iSelHilite = iSel;
            DSRectItem(hwndLB, iSel, TRUE, TRUE);
            break;

        case WM_DRAWITEM:
            MSG("SearchWndProc", "WM_DRAWITEM");
            {
                LPDRAWITEMSTRUCT      lpLBItem;
                HANDLE hMem;
                LPDTASEARCH lpdtasch;

                lpLBItem = (LPDRAWITEMSTRUCT)lParam;
                iSel = lpLBItem->itemID;

                if (iSel < 0)
                    break;

                SendMessage(hwndLB, LB_GETTEXT, iSel, (LPARAM)szPath);

                hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
                lpdtasch = (LPDTASEARCH)LocalLock(hMem);

                iSel = (INT)SendMessage(hwndLB, LB_GETITEMDATA, iSel, 0L);
                CreateLine((WORD)GetWindowLong(hWnd, GWL_VIEW), szPath, &(lpdtasch[iSel]), szTemp);
                DrawItem(lpLBItem, szTemp, lpdtasch[iSel].sch_dwAttrs, TRUE,
                         (WORD *)GetWindowLongPtr(hWnd,GWLP_TABARRAYSEARCH));
                LocalUnlock(hMem);

                break;
            }

        case WM_DROPOBJECT:
            MSG("SearchWndProc", "WM_DROPOBJECT");
            {
                LPSTR      pFrom;
                WORD      ret;
                WORD      iSelSink;
                HANDLE hMem;
                LPDTASEARCH lpdtasch;
                DWORD attrib;

                /* WM_DROPOBJECT is sent to a sink when the user releases an
                 * acceptable object over it
                 *
                 *    wParam: TRUE if over the non-client area, FALSE if over the
                 *            client area.
                 *    lParam: LPDROPSTRUCT
                 */

#define lpds ((LPDROPSTRUCT)lParam)

                iSelSink = LOWORD(lpds->dwControlData);

                /* Are we dropping onto ourselves? (i.e. a selected item in the
                 * source listbox OR an unused area of the source listbox)  If
                 * so, don't do anything.
                 */
                if (hWnd == lpds->hwndSource) {
                    if ((iSelSink == 0xFFFF) || (SendMessage(hwndLB, LB_GETSEL, iSelSink, 0L)))
                        return TRUE;
                }

                /* Are we dropping on a unused portion of the listbox? */
                if (iSelSink == 0xFFFF)
                    return TRUE;

                /* Get the sink's filename. */
                SendMessage(hwndLB, LB_GETTEXT, iSelSink, (LPARAM)szPath);

                hMem = (HANDLE)GetWindowLongPtr(hWnd, GWLP_HDTASEARCH);
                lpdtasch = (LPDTASEARCH)LocalLock(hMem);
                attrib = lpdtasch[(INT)SendMessage(hwndLB, LB_GETITEMDATA, iSelSink, 0L)].sch_dwAttrs;
                LocalUnlock(hMem);

                /* Are we dropping on a subdirectory? */
                if (attrib & ATTR_DIR)
                    goto DirMoveCopy;

                /* Are we not dropping on a Program file? */
                if (!IsProgramFile(szPath))
                    return TRUE;

                if (lpds->wFmt == DOF_DIRECTORY) {
                    goto DODone;
                }

                /* We're dropping a file onto a program.
                 * Exec the program using the source file as the parameter.
                 */

                /* Should we confirm it first? */
                if (bConfirmMouse) {
                    LoadString(hAppInstance, IDS_MOUSECONFIRM, szTitle, MAXTITLELEN);
                    LoadString(hAppInstance, IDS_EXECMOUSECONFIRM, szTemp, sizeof(szTemp));

                    wsprintf(szMessage, szTemp, (LPSTR)szPath, (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch));
                    if (MessageBox(hwndFrame, szMessage, szTitle, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                        goto DODone;
                }


                /* If we dragged from a Dir Window, add path information. */
                if (lpds->hwndSource == hWnd)
                    szTemp[0] = TEXT('\0');
                else
                    SendMessage(lpds->hwndSource, FS_GETDIRECTORY, sizeof(szTemp), (LPARAM)szTemp);

                lstrcat(szTemp, (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch));
                // put a "." extension on if none found
                if (*GetExtension(szTemp) == 0)
                    lstrcat(szTemp, ".");
                FixAnsiPathForDos(szTemp);

                FixAnsiPathForDos(szPath);
                ret = ExecProgram(szPath,szTemp,NULL,FALSE);
                if (ret)
                    MyMessageBox(hwndFrame, IDS_EXECERRTITLE, ret, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
                DODone:
                DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);
                return TRUE;

                DirMoveCopy:
                pFrom = (LPSTR)(((LPDRAGOBJECTDATA)(lpds->dwData))->pch);

                AddBackslash(szPath);     // add filespec filter
                lstrcat(szPath, szStarDotStar);

                DMMoveCopyHelper(pFrom, szPath, fShowSourceBitmaps);

                DSRectItem(hwndLB, iSelHilite, FALSE, TRUE);
                return TRUE;
            }

        case WM_LBTRACKPOINT:
            MSG("SearchWndProc", "WM_LBTRACKPOINT");
            return(DSTrackPoint(hWnd, hwndLB, wParam, lParam, TRUE));

        case WM_MEASUREITEM:
            MSG("SearchWndProc", "WM_MEASUREITEM");
            {
#define pLBMItem ((LPMEASUREITEMSTRUCT)lParam)

                pLBMItem->itemHeight = dyFileName;
                break;
            }

        case WM_QUERYDROPOBJECT:
            MSG("SearchWndProc", "WM_QUERYDROPOBJECT");
            /* Ensure that we are dropping on the client area of the listbox. */
#define lpds ((LPDROPSTRUCT)lParam)

            /* Ensure that we can accept the format. */
            switch (lpds->wFmt) {
                case DOF_EXECUTABLE:
                case DOF_DIRECTORY:
                case DOF_DOCUMENT:
                case DOF_MULTIPLE:
                    if (lpds->hwndSink == hWnd)
                        lpds->dwControlData = -1L;
                    return TRUE;
            }
            return FALSE;

        case WM_SIZE:
            MSG("SearchWndProc", "WM_SIZE");
            if (wParam != SIZEICONIC) {
                MoveWindow(GetDlgItem(hWnd, IDCW_LISTBOX),
                           -1, -1,
                           LOWORD(lParam)+2,
                           HIWORD(lParam)+2,
                           TRUE);
            }
            /*** FALL THRU ***/

        default:
            DefChildProc:
            DEFMSG("SearchWndProc", (WORD)wMsg);
            return(DefMDIChildProc(hWnd, wMsg, wParam, lParam));
    }
    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\winexp.h ===
#ifndef NOATOM
/* atom manager internals */
#define ATOMSTRUC struct atomstruct
typedef ATOMSTRUC *PATOM;
typedef ATOMSTRUC {
    PATOM chain;
    WORD  usage;             /* Atoms are usage counted. */
    BYTE  len;               /* length of ASCIZ name string */
    BYTE  name;              /* beginning of ASCIZ name string */
} ATOMENTRY;

typedef struct {
    int     numEntries;
    PATOM   pAtom[ 1 ];
} ATOMTABLE;
ATOMTABLE * pAtomTable;
#endif

LPSTR lstrbscan(LPSTR, LPSTR);
LPSTR lstrbskip(LPSTR, LPSTR);

int  OpenPathName(LPSTR, int);
int  DeletePathName(LPSTR);
WORD _ldup(int);


/* scheduler things that the world knows not */
BOOL        WaitEvent( HANDLE );
BOOL        PostEvent( HANDLE );
BOOL        KillTask( HANDLE );

/* print screen hooks */
BOOL        SetPrtScHook(FARPROC);
FARPROC     GetPrtScHook(void);

/* module stuff */
HANDLE  GetDSModule( WORD );
HANDLE  GetDSInstance( WORD );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfutil.c ===
/****************************************************************************/
/*                                                                          */
/*  WFUTIL.C -                                                              */
/*                                                                          */
/*      Windows File System String Utility Functions                        */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "lfn.h"
#include "winnet.h"
#include "wnetcaps.h"           // WNetGetCaps()
#include "stdlib.h"

int rgiDriveType[26];
PSTR CurDirCache[26];

// cache GetDriveType calls for speed

INT
DriveType(
         INT iDrive
         )
{
    if (rgiDriveType[iDrive] != -1)
        return rgiDriveType[iDrive];

    return rgiDriveType[iDrive] = MGetDriveType(iDrive);
}

VOID
InvalidateDriveType()
{
    INT i;

    for (i = 0; i < 26; i++)
        rgiDriveType[i] = -1;
}

// iDrive   zero based drive number (0 = A, 1 = B)
// returns:
//  TRUE    we have it saved pszPath gets path
//  FALSE   we don't have it saved

BOOL
APIENTRY
GetSavedDirectory(
                 INT iDrive,
                 PSTR pszPath
                 )
{

    if (CurDirCache[iDrive]) {
        lstrcpy(pszPath, CurDirCache[iDrive]);
        return TRUE;
    } else
        return FALSE;
}

VOID
APIENTRY
SaveDirectory(
             PSTR pszPath
             )
{
    INT i;

    i = DRIVEID(pszPath);

    if (CurDirCache[i])
        LocalFree((HANDLE)CurDirCache[i]);

    CurDirCache[i] = (PSTR)LocalAlloc(LPTR, lstrlen(pszPath)+1);

    if (CurDirCache[i])
        lstrcpy(CurDirCache[i], pszPath);
}

/*
 *  GetSelectedDrive() -
 *
 *  Get the selected drive from the currently active window
 *
 *  should be in wfutil.c
 */

INT
APIENTRY
GetSelectedDrive()
{
    HWND hwnd;

    hwnd = (HWND)SendMessage(hwndMDIClient,WM_MDIGETACTIVE,0,0L);
    return (INT)SendMessage(hwnd,FS_GETDRIVE,0,0L) - (INT)'A';
}

/*
 *  GetSelectedDirectory() -
 *
 *  Gets the directory selected for the drive. uses the windows
 *  z-order to give precidence to windows higher in the order.
 *
 *  works like GetCurrentDirectory() except it looks through
 *  the window list for directories first (and returns ANSI)
 *
 *  returns:
 *  lpDir   ANSI string of current dir
 */

VOID
APIENTRY
GetSelectedDirectory(
                    WORD iDrive,
                    PSTR pszDir
                    )
{
    HWND hwnd;
    WORD iDriveT;

    if (iDrive) {
        for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
            hwnd;
            hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {
            iDriveT = (WORD)SendMessage(hwnd,FS_GETDRIVE,0,0L);
            if (iDrive == (WORD)(iDriveT - 'A' + 1))
                goto hwndfound;
        }
        if (!GetSavedDirectory(iDrive - 1, pszDir)) {
            SheGetDir(iDrive,pszDir);
            OemToCharBuff(pszDir,pszDir, _MAX_PATH);
        }
        return;
    } else
        hwnd = (HWND)SendMessage(hwndMDIClient,WM_MDIGETACTIVE,0,0L);

    hwndfound:
    SendMessage(hwnd,FS_GETDIRECTORY,MAXPATHLEN,(LPARAM)pszDir);

    StripBackslash(pszDir);
}


// avoid confusion in DOSs upper case mapping by converting to
// upper case before passing down to dos

VOID
APIENTRY
FixAnsiPathForDos(
                 LPSTR szPath
                 )
{
    if (GetNameType(szPath) == FILE_83_CI)
        AnsiUpper(szPath);

    AnsiToOem(szPath, szPath);
}

// refresh a MDI child window (works for any type of mdi child)

VOID
APIENTRY
RefreshWindow(
             HWND hwndActive
             )
{
    HWND hwndTree, hwndDir;
    LPARAM lParam;
    CHAR szDir[MAXPATHLEN];
    INT iDrive;

    cDrives = UpdateDriveList();  // updates rgiDrive[]
    InitDriveBitmaps();

    // make sure the thing is still there (floppy drive, net drive)

    iDrive = (INT)GetWindowLong(hwndActive, GWL_TYPE);
    if ((iDrive >= 0) && !CheckDrive(hwndActive, iDrive))
        return;

    // update the dir part first so tree can steal later

    if (hwndDir = HasDirWindow(hwndActive))
        SendMessage(hwndDir, FS_CHANGEDISPLAY, CD_PATH, 0L);

    if (hwndTree = HasTreeWindow(hwndActive)) {
        // remember the current directory
        SendMessage(hwndActive, FS_GETDIRECTORY, sizeof(szDir), (LPARAM)szDir);

        // update the drives windows
        SendMessage(hwndActive, FS_CHANGEDRIVES, 0, 0L);

        if (IsValidDisk(szDir[0] - 'A'))
            lParam = (LPARAM)szDir;
        else
            lParam = 0;

        // update the tree
        SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, TRUE), lParam);
    }

    if (hwndActive == hwndSearch)
        SendMessage(hwndActive, FS_CHANGEDISPLAY, CD_PATH, 0L);
}


VOID
APIENTRY
CheckEscapes(
            LPSTR szFile
            )
{
    CHAR szT[MAXPATHLEN];
    CHAR *p, *pT;

    for (p = szFile; *p; p = (LPSTR)AnsiNext(p)) {
        switch (*p) {
            case ' ':
            case ',':
            case ';':
            case '^':
            case '"':
                {
                    // this path contains an annoying character
                    lstrcpy(szT,szFile);
                    p = szFile;
                    *p++ = '"';
                    for (pT = szT; *pT; ) {
                        if (*pT == '^' || *pT == '"')
                            *p++ = '^';
                        if (IsDBCSLeadByte(*p++ = *pT++))
                            *p++ = *pT++;
                    }
                    *p++ = '"';
                    *p = 0;
                    return;
                }
        }
    }
}

HWND
APIENTRY
GetRealParent(
             HWND hwnd
             )
{
    // run up the parent chain until you find a hwnd
    // that doesn't have WS_CHILD set

    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
        hwnd = (HWND)GetWindowLongPtr(hwnd, GWLP_HWNDPARENT);

    return hwnd;
}

VOID
APIENTRY
WFHelp(
      HWND hwnd
      )
{
    if (!WinHelp(hwnd, szWinObjHelp, HELP_CONTEXT, dwContext)) {
        MyMessageBox(hwnd, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
    }

}

BOOL
APIENTRY
IsLastWindow()
{
    HWND hwnd;
    INT count;

    count = 0;

    // count all non title/search windows to see if close is allowed

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
        if (!GetWindow(hwnd, GW_OWNER) && ((INT)GetWindowLong(hwnd, GWL_TYPE) >= 0))
            count++;

    return count == 1;
}

// get connection information including disconnected drives
//
// in:
//        lpDev        device name "A:" "LPT1:", etc.
//        fClosed        if FALSE closed or error drives will be converted to
//                WN_SUCCESS return codes.  if TRUE return not connected
//                and error state values (ie, the caller knows about not
//                connected and error state drives)
// out:
//        lpPath        filled with net name if return is WN_SUCCESS (or not connected/error)
// returns:
//        WN_*        error code

WORD
APIENTRY
WFGetConnection(
               LPSTR lpDev,
               LPSTR lpPath,
               BOOL fClosed
               )
{
    DWORD cb;
    UINT err;
    UINT caps;


    cb = 64;

    caps = WNetGetCaps(WNNC_CONNECTION);
    if (caps & WNNC_CON_GETCONNECTIONS)
        err = WNetGetConnection(lpDev,lpPath,&cb);
    else
        return WN_NOT_CONNECTED;

    if (err == WN_NOT_CONNECTED &&
        !(caps & WNNC_CON_RESTORECONNECTION)) {
        if (GetProfileString(szNetwork,lpDev,szNULL,lpPath,64))
            err = WN_CONNECTION_CLOSED;
    }

    if (!fClosed)
        if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
            err = WN_SUCCESS;

    return (WORD)err;
}



// returns the number of this MDI window as well as returning
// the text with the number stripped off
//
// returns:
//      0       this title doesn't have a number
//      > 0     the title number
//      szTitle the title with the number stripped off

INT
APIENTRY
GetMDIWindowText(
                HWND hWnd,
                LPSTR szTitle,
                INT size
                )
{
    LPSTR lp, lpLast;

    ENTER("GetMDIWindowText");

    GetWindowText(hWnd, szTitle, size);

    lpLast = NULL;

    for (lp = szTitle; *lp; lp = AnsiNext(lp))
        if (*lp == ':')
            lpLast = lp;

    if (lpLast) {
        *lpLast++ = 0;
        PRINT(BF_PARMTRACE, "OUT: szTitle=%s", szTitle);
        PRINT(BF_PARMTRACE, "OUT: window#=%s", lpLast);
        LEAVE("GetMDIWindowText");
        return atoi(lpLast);    // return the window number
    } else {
        TRACE(BF_PARMTRACE, "OUT: window#=0");
        LEAVE("GetMDIWindowText");
        return 0;               // no number on this
    }
}

// set the MDI window text and add a ":#" on the end if
// there is another window with the same title.  this is to
// avoid confusion when there are multiple MDI children
// with the same title.  be sure to use GetMDIWindowText to
// strip off the number stuff.

VOID
APIENTRY
SetMDIWindowText(
                HWND hWnd,
                LPSTR szTitle
                )
{
    CHAR szTemp[MAXPATHLEN];
    CHAR szNumber[20];
    HWND hwnd;
    INT num, max_num;

    ENTER("SetMDIWindowText");
    PRINT(BF_PARMTRACE, "hWnd=%lx", hWnd);
    PRINT(BF_PARMTRACE, "IN: szTitle=%s", szTitle);

    max_num = 0;

    for (hwnd = GetWindow(hwndMDIClient, GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT)) {

        num = GetMDIWindowText(hwnd, szTemp, sizeof(szTemp));

        if (!lstrcmp(szTemp, szTitle)) {

            if (hwnd == hWnd)
                continue;

            if (!num) {
                lstrcat(szTemp, ":1");
                // if (wTextAttribs & TA_LOWERCASE)
                //    AnsiLower(szTemp);
                SetWindowText(hwnd, szTemp);
                num = 1;
            }
            max_num = max(max_num, num);
        }
    }

    if (max_num) {
        wsprintf(szNumber, ":%d", max_num+1);
        lstrcat(szTitle, szNumber);
    }

    // if (wTextAttribs & TA_LOWERCASE)
    //    AnsiLower(szTitle);
    SetWindowText(hWnd, szTitle);
    PRINT(BF_PARMTRACE, "OUT: szTitle=%s", szTitle);
    LEAVE("SetMDIWindowText");
}


#define ISDIGIT(c)  ((c) >= '0' && (c) <= '9')
#ifdef INLIBRARY
INT
APIENTRY
atoi(
    LPSTR sz
    )
{
    INT n = 0;
    BOOL bNeg = FALSE;

    if (*sz == '-') {
        bNeg = TRUE;
        sz++;
    }

    while (ISDIGIT(*sz)) {
        n *= 10;
        n += *sz - '0';
        sz++;
    }
    return bNeg ? -n : n;
}
#endif

// fills in rgiDrive[] and returns the number of drives

INT
APIENTRY
UpdateDriveList()
{
    INT i, cRealDrives = 0;
    DWORD dwDrives;

    dwDrives = GetLogicalDrives();

    for (i = 0; i < 26; i++) {
        if ((1 << i) & dwDrives) {
            rgiDrive[cRealDrives++] = i;
            rgiDriveType[i] =  MGetDriveType(i);
        } else {
            rgiDrive[i] = 0;
            rgiDriveType[i] = -1;        // invalidate the drivetype
        }

        if (apVolInfo[i]) {              // sothat volinfo is refreshed
            LocalFree(apVolInfo[i]);
            apVolInfo[i] = NULL;
        }
    }

    return cRealDrives;
}

int
GetBootDisk()
{
    CHAR szTemp[MAXPATHLEN];
        // well, close enough...
    if (GetWindowsDirectory(szTemp, sizeof(szTemp))) {
        return szTemp[0] - 'A';
    } else {
        return 'a';
    }
}


//
// IsCDROM()  - determine if a drive is a CDROM drive
//
//      iDrive      drive index (0=A, 1=B, ...)
//
// return TRUE/FALSE
//
WORD
APIENTRY
IsCDRomDrive(
            INT iDrive
            )
{
    if (rgiDriveType[iDrive] == DRIVE_CDROM)
        return (TRUE);
    return (FALSE);
}


// this is called for every drive at init time so it must
// be sure to not trigget things like the phantom B: drive support
//
// iDrive is a zero based drive number (0 = A, 1 = B)

WORD
APIENTRY
IsNetDrive(
          INT iDrive
          )
{
    INT err;
    CHAR szDrive[3];
    CHAR szConn[64];    // this really should be WNBD_MAX_LENGTH
                        // but this change would have to be many everywhere

    szDrive[0] = (CHAR)(iDrive+'A');
    szDrive[1] = ':';
    szDrive[2] = (CHAR)0;

    if (IsCDRomDrive(iDrive))   // this is bogus...  move this out
        return 0;

    err = WFGetConnection(szDrive, szConn, TRUE);

    if (err == WN_SUCCESS)
        return 1;

    if (err == WN_CONNECTION_CLOSED || err == WN_DEVICE_ERROR)
        return 2;

    return 0;
}


BOOL
APIENTRY
IsRemovableDrive(
                INT iDrive
                )
{
    return DriveType(iDrive) == DRIVE_REMOVABLE;
}


BOOL
APIENTRY
IsRemoteDrive(
             INT iDrive
             )
{
    return DriveType(iDrive) == DRIVE_REMOTE;
}


// iDrive   zero based drive number (A = 0)

BOOL
APIENTRY
IsRamDrive(
          INT iDrive
          )
{
    return DriveType(iDrive) == DRIVE_RAMDISK;
}


// get interesting stuff about a drive
//
// zero based drive numbers (0 = A, 1 = B)
//

DWORD
APIENTRY
GetClusterInfo(
              WORD drive
              )
{
    UNREFERENCED_PARAMETER(drive);
    return 0;
}



BOOL
APIENTRY
IsValidDisk(
           INT iDrive
           )
{
    if (apVolInfo[iDrive] == NULL)
        FillVolumeInfo(iDrive);

    return (apVolInfo[iDrive] != NULL);
}


VOID
APIENTRY
GetVolShare(
           WORD wDrive,
           LPSTR szVolShare
           )
{
    CHAR szDrive[5];

    szVolShare[0] = TEXT('\0');

    lstrcpy(szVolShare, "Objects");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsLFNSelected() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
IsLFNSelected()
{
    HWND  hwndActive;
    BOOL  fDir;
    LPSTR p;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    p = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, 2, (LPARAM)&fDir);
    if (p) {
        LocalFree((HANDLE)p);
    }

    return (fDir);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetSelection() -                                                        */

//  caller must free lpstr returned.
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPSTR
APIENTRY
GetSelection(
            INT iSelType
            )
{
    HWND  hwndActive;

    hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);

    return (LPSTR)SendMessage(hwndActive,FS_GETSELECTION, (WPARAM)iSelType, 0L);
}


//
// in:
//      pFrom   pointer that is used as start of selection search.
//              on subsequent calls pass in the previous non NULL
//              return value
//
// out:
//      pTo     buffer that receives the next file in the list
//              for non NULL return
//
// returns:
//      NULL    if no more files in this list (szFile) is undefined
//      pointer to be passed to subsequent calls to this function
//      to enumerate thorough the file list
//

LPSTR
APIENTRY
GetNextFile(
           LPSTR pFrom,
           LPSTR pTo,
           INT cbMax
           )
{
    INT i;

    ENTER("GetNextFile");
    PRINT(BF_PARMTRACE, "IN: pFrom=%s", pFrom);

    if (!pFrom)
        return NULL;

    /* Skip over leading spaces and commas. */
    while (*pFrom && (*pFrom == ' ' || *pFrom == ','))
        pFrom = (LPSTR)AnsiNext(pFrom);

    if (!*pFrom)
        return (NULL);

    if (*pFrom == '\"') {
        pFrom = (LPSTR)AnsiNext(pFrom);

        /* Find the next quote */
        for (i=0; *pFrom && *pFrom != '\"';) {
            if (*pFrom == '^') {
                pFrom = (LPSTR)AnsiNext(pFrom);
                if (!*pFrom)
                    break;
            }

            if (i < cbMax - 1) {
                i++;
                if (IsDBCSLeadByte(*pTo++ = *pFrom++)) {
                    i++;
                    *pTo++ = *pFrom++;
                }
            }
        }
        pFrom = (LPSTR)AnsiNext(pFrom);
    } else {
        /* Find the next space or comma. */
        for (i=0; *pFrom && *pFrom != ' ' && *pFrom != ',';) {
            if (*pFrom == '^') {
                pFrom = (LPSTR)AnsiNext(pFrom);
                if (!*pFrom)
                    break;
            }

            if (i < cbMax - 1) {
                i++;
                if (IsDBCSLeadByte(*pTo++ = *pFrom++)) {
                    i++;
                    *pTo++ = *pFrom++;
                }
            }
        }
    }

    *pTo = TEXT('\0');

    PRINT(BF_PARMTRACE, pTo ? "OUT: pTo=%s" : "OUT: pTo=NULL", pTo);
    LEAVE("GetNextFile");

    return (pFrom);
}


// sets the DOS current directory based on the currently active window

VOID
APIENTRY
SetWindowDirectory()
{
    CHAR szTemp[MAXPATHLEN];

    GetSelectedDirectory(0, szTemp);
    FixAnsiPathForDos(szTemp);
    SheChangeDir(szTemp);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SetDlgDirectory() -                                                     */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Sets the IDD_DIR field of 'hDlg' to whatever the active window says is the
 * active directory.
 *
 * this does not really change the DOS current directory
 */

VOID
APIENTRY
SetDlgDirectory(
               HWND hDlg,
               PSTR pszPath
               )
{
    HDC       hDC;
    INT       dx;
    RECT      rc;
    HWND      hDlgItem;
    HANDLE    L_hFont;
    CHAR      szPath[MAXPATHLEN+5];
    CHAR      szTemp[MAXPATHLEN+20];

    ENTER("SetDlgDirectory");

    if (pszPath)
        lstrcpy(szPath, pszPath);
    else
        GetSelectedDirectory(0, szPath);

    /* Make sure that the current directory fits inside the static text field. */
    hDlgItem = GetDlgItem(hDlg, IDD_DIR);
    GetClientRect(hDlgItem, &rc);

    if (LoadString(hAppInstance, IDS_CURDIRIS, szMessage, sizeof(szMessage))) {
        hDC = GetDC(hDlg);
        L_hFont = (HANDLE)SendMessage(hDlgItem, WM_GETFONT, 0, 0L);
        if (L_hFont = SelectObject(hDC, L_hFont)) {
            MGetTextExtent(hDC, szMessage, lstrlen(szMessage), &dx, NULL);
            CompactPath(hDC, szPath, (WORD)(rc.right-rc.left-dx));
        }
        SelectObject(hDC, L_hFont);
        ReleaseDC(hDlg, hDC);
        wsprintf(szTemp, szMessage, (LPSTR)szPath);
        SetDlgItemText(hDlg, IDD_DIR, szTemp);
    }

    LEAVE("SetDlgDirectory");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WritePrivateProfileBool() -                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID
APIENTRY
WritePrivateProfileBool(
                       LPSTR szKey,
                       BOOL bParam
                       )
{
    CHAR  szBool[6];

    wsprintf(szBool, "%d", bParam);
    WritePrivateProfileString(szSettings, szKey, szBool, szTheINIFile);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WFQueryAbort() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
WFQueryAbort()

{
    MSG   msg;

    while (PeekMessage(&msg, NULL, 0, 0, TRUE)) {
        if (!IsDialogMessage(hdlgProgress, &msg))
            DispatchMessage(&msg);
    }
    return (bUserAbort);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsWild() -                                                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE iff the path contains * or ? */

BOOL
APIENTRY
IsWild(
      LPSTR lpszPath
      )
{
    while (*lpszPath) {
        if (*lpszPath == '?' || *lpszPath == '*')
            return (TRUE);
        lpszPath = AnsiNext(lpszPath);
    }

    return (FALSE);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CheckSlashies() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Replaces frontslashes (evil) with backslashes (good). */

VOID
APIENTRY
CheckSlashies(
             LPSTR lpT
             )
{
    while (*lpT) {
        if (*lpT == '/')
            *lpT = '\\';
        lpT = AnsiNext(lpT);
    }
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddBackslash() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Ensures that a path ends with a backslash. */

VOID
APIENTRY
AddBackslash(
            LPSTR lpszPath
            )
{
    ENTER("AddBackslash");
    PRINT(BF_PARMTRACE, "IN: lpszPath=%s", lpszPath);

    if (*AnsiPrev(lpszPath,lpszPath+lstrlen(lpszPath)) != '\\')
        lstrcat(lpszPath, "\\");

    PRINT(BF_PARMTRACE, "OUT: lpszPath=%s", lpszPath);

    LEAVE("AddBackslash");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripBackslash() -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Removes a trailing backslash from a proper directory name UNLESS it is
 * the root directory.  Assumes a fully qualified directory path.
 */

VOID
APIENTRY
StripBackslash(
              LPSTR lpszPath
              )
{
    register WORD len;

    len = lstrlen(lpszPath) - (IsDBCSLeadByte(*AnsiPrev(lpszPath,lpszPath+lstrlen(lpszPath))) ? 2 : 1);
    if ((len == 2) || (lpszPath[len] != '\\'))
        return;

    lpszPath[len] = TEXT('\0');
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripFilespec() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Remove the filespec portion from a path (including the backslash). */

VOID
APIENTRY
StripFilespec(
             LPSTR lpszPath
             )
{
    LPSTR     p;

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (*p != ':') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (*p == ':')
        p++;

    /* Don't strip backslash from root directory entry. */
    if (p != lpszPath) {
        if ((*p == '\\') && (*(p-1) == ':'))
            p++;
    } else
        p++;

    *p = TEXT('\0');
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  StripPath() -                                                           */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Extract only the filespec portion from a path. */

VOID
APIENTRY
StripPath(
         LPSTR lpszPath
         )
{
    LPSTR     p;

    ENTER("StripPath");
    PRINT(BF_PARMTRACE, "IN: lpszPath=%s", lpszPath);

    p = lpszPath + lstrlen(lpszPath);
    while ((*p != '\\') && (*p != ':') && (p != lpszPath))
        p = AnsiPrev(lpszPath, p);

    if (p != lpszPath || *p == '\\')
        p++;

    if (p != lpszPath)
        lstrcpy(lpszPath, p);

    PRINT(BF_PARMTRACE, "OUT: lpszPath=%s", lpszPath);
    LEAVE("StripPath");
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  GetExtension() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns the extension part of a filename. */

LPSTR
APIENTRY
GetExtension(
            LPSTR pszFile
            )
{
    PSTR p, pSave = NULL;

    p = pszFile;
    while (*p) {
        if (*p == '.')
            pSave = p;
        p = (LPSTR)AnsiNext(p);
    }

    if (!pSave)
        return (p);

    return (LPSTR)AnsiNext(pSave);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindExtensionInList() -                                                 */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE if 'lpszExt' is somewhere in 'pszList'. */

BOOL
APIENTRY
FindExtensionInList(
                   LPSTR pszExt,
                   LPSTR pszList
                   )
{
    LPSTR p2;
    CHAR ch;

    while (*pszList) {
        /* Move to the next item in the list. */
        while ((*pszList) && (*pszList == ' '))
            pszList = (LPSTR)AnsiNext(pszList);

        if (!*pszList)
            break;

        /* NULL-terminate this item. */
        p2 = (LPSTR)AnsiNext(pszList);
        while ((*p2) && (*p2 != ' '))
            p2 = (LPSTR)AnsiNext(p2);
        ch = *p2;
        *p2 = TEXT('\0');
        if (!lstrcmpi(pszExt, pszList)) {
            *p2 = ch;
            return (TRUE);
        }
        *p2 = ch;
        pszList = p2;
    }
    return (FALSE);
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  MyMessageBox() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT
APIENTRY
MyMessageBox(
            HWND hWnd,
            WORD idTitle,
            WORD idMessage,
            WORD wStyle
            )
{
    CHAR  szTemp[MAXMESSAGELEN];
    HWND hwndT;

    LoadString(hAppInstance, idTitle, szTitle, sizeof(szTitle));

    if (idMessage < 32) {
        LoadString(hAppInstance, IDS_UNKNOWNMSG, szTemp, sizeof(szTemp));
        wsprintf(szMessage, szTemp, idMessage);
    } else
        LoadString(hAppInstance, idMessage, szMessage, sizeof(szMessage));

    if (hWnd)
        hwndT = GetLastActivePopup(hWnd);
    else
        hwndT = hWnd;

    return MessageBox(hwndT, szMessage, szTitle, wStyle | MB_TASKMODAL);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ExecProgram() -                                                         */
/*                                                                          */
/*  all strings are OEM                                                     */
/*--------------------------------------------------------------------------*/

/* Returns 0 for success.  Otherwise returns a IDS_ string code. */

WORD
APIENTRY
ExecProgram(
           LPSTR lpPath,
           LPSTR lpParms,
           LPSTR lpDir,
           BOOL bLoadIt
           )
{
    WORD          ret;
    INT           iCurCount;
    INT           i;
    HCURSOR       hCursor;

    ENTER("ExecProgram");

    ret = 0;

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    iCurCount = ShowCursor(TRUE) - 1;

    /* open the object
     */

    if (lpPath)
        OemToCharBuff(lpPath, lpPath, _MAX_PATH);
    if (lpParms)
        OemToCharBuff(lpParms, lpParms, _MAX_PATH);
    if (lpDir)
        OemToCharBuff(lpDir, lpDir, _MAX_PATH);

    // Shell Execute takes ansi string.
    //
    ret = (WORD)RealShellExecute(hwndFrame, NULL, lpPath, lpParms, lpDir, NULL, NULL, NULL, (WORD)(bLoadIt ? SW_SHOWMINNOACTIVE : SW_SHOWNORMAL), NULL);

    DosResetDTAAddress(); // undo any bad things COMMDLG did

    if (lpPath)
        AnsiToOem(lpPath, lpPath);
    if (lpParms)
        AnsiToOem(lpParms, lpParms);
    if (lpDir)
        AnsiToOem(lpDir, lpDir);

    switch (ret) {
        case 0:
        case 8:
            ret = IDS_NOMEMORYMSG;
            break;

        case 2:
            ret = IDS_FILENOTFOUNDMSG;
            break;

        case 3:
        case 5:        // access denied
            ret = IDS_BADPATHMSG;
            break;

        case 4:
            ret = IDS_MANYOPENFILESMSG;
            break;

        case 10:
            ret = IDS_NEWWINDOWSMSG;
            break;

        case 12:
            ret = IDS_OS2APPMSG;
            break;

        case 15:
            /* KERNEL has already put up a messagebox for this one. */
            ret = 0;
            break;

        case 16:
            ret = IDS_MULTIPLEDSMSG;
            break;

        case 18:
            ret = IDS_PMODEONLYMSG;
            break;

        case 19:
            ret = IDS_COMPRESSEDEXE;
            break;

        case 20:
            ret = IDS_INVALIDDLL;
            break;

        case SE_ERR_SHARE:
            ret = IDS_SHAREERROR;
            break;

        case SE_ERR_ASSOCINCOMPLETE:
            ret = IDS_ASSOCINCOMPLETE;
            break;

        case SE_ERR_DDETIMEOUT:
        case SE_ERR_DDEFAIL:
        case SE_ERR_DDEBUSY:
            ret = IDS_DDEFAIL;
            break;

        case SE_ERR_NOASSOC:
            ret = IDS_NOASSOCMSG;
            break;

        default:
            if (ret < 32)
                goto EPExit;

            if (bMinOnRun && !bLoadIt)
                ShowWindow(hwndFrame, SW_SHOWMINNOACTIVE);
            ret = 0;
    }

    EPExit:
    i = ShowCursor(FALSE);

#if 0

    /* Make sure that the cursor count is still balanced. */
    if (i != iCurCount)
        ShowCursor(TRUE);
#endif

    SetCursor(hCursor);

    PRINT(BF_PARMTRACE, "OUT: ret=%ud", ret);
    LEAVE("ExecProgram");
    return ret;
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsProgramFile() -                                                       */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE is the Path points to a file which has one of the extentions
 * listed in the "Programs=" portions of WIN.INI.
 */

BOOL
APIENTRY
IsProgramFile(
             LPSTR lpszPath
             )
{
    LPSTR szExt;
    CHAR szTemp[MAXPATHLEN] = {0};

    /* Move the string into our own DS. */
    strncpy(szTemp, lpszPath, sizeof(szTemp)/sizeof(szTemp[0])-1);

    /* Get the file's extension. */
    StripPath(szTemp);
    szExt = GetExtension(szTemp);

    if (!*szExt) {
        /* The specified path didn't have an extention.  It can't be a program. */
        return (FALSE);
    }

    return FindExtensionInList(szExt, szPrograms);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  IsDocument() -                                                          */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* Returns TRUE is the Path points to a file which has one of the extentions
 * listed in the "Documents=" portions of WIN.INI or one which has an Association.
 */

BOOL
APIENTRY
IsDocument(
          LPSTR lpszPath
          )
{
    LPSTR szExt;
    CHAR szTemp[MAXPATHLEN];

    /* Move the string into our own DS. */
    strncpy(szTemp, lpszPath, sizeof(szTemp)/sizeof(szTemp[0])-1);

    /* Get the file's extension. */
    StripPath(szTemp);
    szExt = GetExtension(szTemp);

    if (!*szExt) {
        /* The specified path didn't have an extention.  It can't be a program. */
        return (FALSE);
    }

    return FindExtensionInList(szExt, szDocuments);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\winobj.c ===
/****************************************************************************/
/*                                                                          */
/*  WINFILE.C -                                                             */
/*                                                                          */
/*      Windows File System Application                                     */
/*                                                                          */
/****************************************************************************/

#define NO_WF_GLOBALS
#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "stdlib.h"


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  Global Variables -                                                      */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL        bNetAdmin               = FALSE;
BOOL        bMinOnRun               = FALSE;
BOOL        bStatusBar              = TRUE;
BOOL        bConfirmDelete          = TRUE;
BOOL        bConfirmSubDel          = TRUE;
BOOL        bConfirmReplace         = TRUE;
BOOL        bConfirmMouse           = TRUE;
BOOL        bConfirmFormat          = TRUE;
BOOL        bSearchSubs             = TRUE;
BOOL        bUserAbort              = FALSE;
BOOL        bConnect                = FALSE;
BOOL        bDisconnect             = FALSE;
BOOL        bFileSysChanging        = FALSE;
BOOL        fShowSourceBitmaps      = TRUE;
BOOL    bMultiple;              // used to indicate multiple selection
BOOL    bFSCTimerSet = FALSE;
BOOL    bStoleTreeData = FALSE;
BOOL    bSaveSettings = TRUE;


CHAR        chFirstDrive;                       /* 'A' or 'a' */

CHAR        szExtensions[]          = "Extensions";
CHAR        szFrameClass[]          = "WOS_Frame";
CHAR        szTreeClass[]           = "WOS_Tree";
CHAR        szDrivesClass[]         = "WOS_Drives";
CHAR        szTreeControlClass[]    = "DirTree";
CHAR        szDirClass[]            = "WOS_Dir";
CHAR        szSearchClass[]         = "WOS_Search";

CHAR        szMinOnRun[]            = "MinOnRun";
CHAR        szStatusBar[]           = "StatusBar";
CHAR        szSaveSettings[]        = "Save Settings";

CHAR        szConfirmDelete[]       = "ConfirmDelete";
CHAR        szConfirmSubDel[]       = "ConfirmSubDel";
CHAR        szConfirmReplace[]      = "ConfirmReplace";
CHAR        szConfirmMouse[]        = "ConfirmMouse";
CHAR        szConfirmFormat[]       = "ConfirmFormat";
CHAR        szDirKeyFormat[]        = "dir%d";
CHAR        szWindow[]              = "Window";
CHAR        szFace[]                = "Face";
CHAR        szSize[]                = "Size";
CHAR        szLowerCase[]           = "LowerCase";
CHAR        szAddons[]              = "AddOns";
CHAR        szUndelete[]            = "UNDELETE.DLL";

CHAR        szDefPrograms[]         = "EXE COM BAT PIF";
CHAR        szINIFile[]             = "WINOBJ.INI";
CHAR        szWindows[]             = "Windows";
CHAR        szPrevious[]            = "Previous";
CHAR        szSettings[]            = "Settings";
CHAR        szInternational[]       = "Intl";
CHAR        szStarDotStar[]         = "*.*";
CHAR        szNULL[]                = "";
CHAR        szBlank[]               = " ";
CHAR        szEllipses[]            = "...";
CHAR        szReservedMarker[]      = "FAT16   ";
CHAR        szNetwork[]             = "Network";

CHAR        szDirsRead[32];
CHAR        szCurrentFileSpec[14]   = "*.*";
CHAR        szShortDate[11]         = "MM/dd/yy";
CHAR        szTime[2]               = ":";
CHAR        sz1159[9]               = "AM";
CHAR        sz2359[9]               = "PM";
CHAR        szComma[2]              = ",";
CHAR        szListbox[]             = "ListBox";        // window style

CHAR        szTheINIFile[64+12+3];
CHAR        szTitle[128];
CHAR        szMessage[MAXMESSAGELEN+1];
CHAR        szSearch[MAXPATHLEN+1];
CHAR        szStatusTree[80];
CHAR        szStatusDir[80];
CHAR        szOriginalDirPath[64+12+3]; /* OEM string!!!!!! */
CHAR        szBytes[10];
CHAR        szSBytes[10];

EFCB        VolumeEFCB ={
    0xFF,
    0, 0, 0, 0, 0,
    ATTR_VOLUME,
    0,
    '?','?','?','?','?','?','?','?','?','?','?',
    0, 0, 0, 0, 0,
    '?','?','?','?','?','?','?','?','?','?','?',
    0, 0, 0, 0, 0, 0, 0, 0, 0
};

INT         cDrives;
INT         dxDrive;
INT         dyDrive;
INT         dxDriveBitmap;
INT         dyDriveBitmap;
INT         dxEllipses;
INT         dxFolder;
INT         dyFolder;
INT         dyBorder;                   /* System Border Width/Height       */
INT         dyBorderx2;                 /* System Border Width/Height * 2   */
INT         dyStatus;                   /* Status Bar height                */
INT         dxStatusField;
INT         dxText;                     /* System Font Width 'M'            */
INT         dyText;                     /* System Font Height               */
//INT         dxFileName;
INT         dyFileName;
INT         iCurrentDrive;              /* Logical # of the current drive   */
INT         iFormatDrive;               /* Logical # of the drive to format */
INT         nFloppies;                  /* Number of Removable Drives       */
INT         rgiDrive[26];
INT         rgiDriveType[26];
VOLINFO     *(apVolInfo[26]);
INT         rgiDrivesOffset[26];
INT         iSelHilite              = -1;
INT         iTime                   = 0;        /* Default to 12-hour time  */
INT         iTLZero                 = TRUE;     /* Default to leading zeros */
INT         cDisableFSC             = 0;        /* has fsc been disabled?   */
INT         iReadLevel = 0;     // global.  if !0 someone is reading a tree
INT         dxFrame;
INT         dxClickRect;
INT         dyClickRect;

BOOL    bCancelTree;

HANDLE  hAccel              = NULL;
HANDLE  hAppInstance;

HBITMAP hbmBitmaps      = NULL;
HDC     hdcMem          = NULL;

INT iCurDrag = 0;

HICON   hicoTree        = NULL;
HICON   hicoTreeDir     = NULL;
HICON   hicoDir         = NULL;

HWND    hdlgProgress;
HWND    hwndFrame       = NULL;
HWND    hwndMDIClient   = NULL;
HWND    hwndSearch      = NULL;
HWND    hwndDragging    = NULL;

LPSTR    szPrograms;
LPSTR    szDocuments;

WORD    wTextAttribs    = TA_LOWERCASE;
WORD    wSuperDlgMode;
WORD    wFATSector      = (WORD)0xFFFF;
WORD    wFATMode        = 0;
WORD    wDOSversion;
UINT    wHelpMessage;
UINT    wBrowseMessage;
WORD    xTreeMax = 0; // current width of widest tree window

WORD    wNewView        = VIEW_NAMEONLY;
WORD    wNewSort        = IDD_NAME;
DWORD   dwNewAttribs    = ATTR_DEFAULT;

LONG lFreeSpace = -1L;
LONG lTotalSpace = -1L;

HFONT hFont;
HFONT hFontStatus;
CHAR szWinObjHelp[] = "WINOBJ.HLP";

INT iNumExtensions = 0;
EXTENSION extensions[MAX_EXTENSIONS];

FM_UNDELETE_PROC lpfpUndelete = NULL;
BOOL EnablePropertiesMenu (HWND,PSTR);
HHOOK hhkMessageFilter = NULL;

WORD wMenuID = 0;
HMENU hMenu = 0;
WORD  wMenuFlags = 0;
DWORD dwContext = 0L;

HANDLE hModUndelete = NULL;


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  WinMain() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

MMain(
     hInst,
     hPrevInst,
     lpCmdLine,
     nCmdShow
     )
//{
    MSG       msg;

    FBREAK(BF_START);
    ENTER("MMain");
    PRINT(BF_PARMTRACE, "lpCmdLine=%s", lpCmdLine);
    PRINT(BF_PARMTRACE, "nCmdShow=%ld", IntToPtr(nCmdShow));

    if (!InitFileManager(hInst, hPrevInst, lpCmdLine, nCmdShow)) {
        FreeFileManager();
        return FALSE;
    }

    while (GetMessage(&msg, NULL, 0, 0)) {

        // since we use RETURN as an accelerator we have to manually
        // restore ourselves when we see VK_RETURN and we are minimized

        if (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_RETURN && IsIconic(hwndFrame)) {
            ShowWindow(hwndFrame, SW_NORMAL);
        } else {
            if (!TranslateMDISysAccel(hwndMDIClient, &msg) &&
                (!hwndFrame || !TranslateAccelerator(hwndFrame, hAccel, &msg))) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    FreeFileManager();

    LEAVE("MMain");
    return (int)msg.wParam;
}


VOID
NoRunInLongDir(
              HWND hwndActive,
              HMENU hMenu
              )
{
    char szTemp[MAXPATHLEN];
    WORD L_wMenuFlags;

    // cannot run in a long directory
    SendMessage(hwndActive, FS_GETDIRECTORY, MAXPATHLEN, (LPARAM)szTemp);
    StripBackslash(szTemp);
    //wMenuFlags = IsLFN(szTemp) ? MF_BYCOMMAND | MF_GRAYED
    //                : MF_BYCOMMAND | MF_ENABLED;

    L_wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
    EnableMenuItem(hMenu, IDM_RUN, L_wMenuFlags);
}


/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FrameWndProc() -                                                        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

INT_PTR
APIENTRY
FrameWndProc(
            HWND hWnd,
            UINT wMsg,
            WPARAM wParam,
            LPARAM lParam
            )
{
    RECT     rc;
    HMENU    L_hMenu = NULL;

    STKCHK();

    switch (wMsg) {
        case WM_CREATE:
            TRACE(BF_WM_CREATE, "FrameWndProc - WM_CREATE");
            {
                CLIENTCREATESTRUCT    ccs;

                /* Store the Frame's hwnd. */
                hwndFrame = hWnd;

                // ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), IDM_WINDOW);
                // the extensions haven't been loaded yet so the window
                // menu is in the position of the first extensions menu
                ccs.hWindowMenu = GetSubMenu(GetMenu(hWnd), IDM_EXTENSIONS);
                ccs.idFirstChild = IDM_CHILDSTART;

                // create the MDI client at aproximate size to make sure
                // "run minimized" works

                GetClientRect(hwndFrame, &rc);

                hwndMDIClient = CreateWindow("MDIClient", NULL,
                                             WS_CHILD | WS_CLIPCHILDREN | WS_VSCROLL | WS_HSCROLL | WS_BORDER,
                                             // -dyBorder, -dyBorder,
                                             // rc.right + dyBorder,
                                             // rc.bottom - dyBorder - (bStatusBar ? dyStatus + dyBorder : 0),
                                             0, 0, rc.right, rc.bottom,
                                             hWnd, (HMENU)1, hAppInstance, (LPSTR)&ccs);
                if (!hwndMDIClient) {
                    MSG("FrameWndProc", "WM_CREATE failed!");
                    return -1L;
                }

                break;
            }

        case WM_INITMENUPOPUP:
            MSG("FrameWndProc", "WM_INITMENUPOPUP");
            {
                BOOL      bMaxed;
                WORD      wSort;
                WORD      wView;
                WORD      L_wMenuFlags;
                HWND      hwndActive;
                HWND      hwndTree, hwndDir;
                BOOL      bLFN;

                hwndActive = (HWND)SendMessage(hwndMDIClient, WM_MDIGETACTIVE, 0, 0L);
                if (hwndActive && GetWindowLong(hwndActive, GWL_STYLE) & WS_MAXIMIZE)
                    bMaxed = 1;
                else
                    bMaxed = 0;

                hwndTree = HasTreeWindow(hwndActive);
                hwndDir = HasDirWindow(hwndActive);
                wSort = (WORD)GetWindowLong(hwndActive, GWL_SORT);
                wView = (WORD)GetWindowLong(hwndActive, GWL_VIEW);

                L_hMenu = (HMENU)wParam;

                L_wMenuFlags = MF_BYCOMMAND | MF_ENABLED;

                //        bLFN = IsLFNSelected();
                bLFN = FALSE;       // For now, ignore the case.

                switch (LOWORD(lParam)-bMaxed) {
                    case IDM_FILE:
                        MSG("FrameWndProc", "IDM_FILE");
                        {
                            LPSTR     pSel;
                            BOOL      fDir;

                            if (!hwndDir)
                                L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            // EnableMenuItem(L_hMenu, IDM_PRINT,    L_wMenuFlags);
                            EnableMenuItem(L_hMenu, IDM_SELALL,   L_wMenuFlags);
                            EnableMenuItem(L_hMenu, IDM_DESELALL, L_wMenuFlags);

                            if (hwndActive == hwndSearch || hwndDir)
                                L_wMenuFlags = MF_BYCOMMAND;
                            else
                                L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            // EnableMenuItem(L_hMenu, IDM_ATTRIBS, L_wMenuFlags);
                            EnableMenuItem(L_hMenu, IDM_SELECT, L_wMenuFlags);

                            pSel = (LPSTR)SendMessage(hwndActive, FS_GETSELECTION, 1, (LPARAM)&fDir);

                            // can't print an lfn thing or a directory.
                            L_wMenuFlags = (WORD)((bLFN || fDir)
                                                ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED
                                                : MF_BYCOMMAND | MF_ENABLED);

                            EnableMenuItem(L_hMenu, IDM_PRINT, L_wMenuFlags);

                            // can't open an LFN file but can open an LFN dir
                            L_wMenuFlags = (WORD)((bLFN && !fDir)
                                                ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED
                                                : MF_BYCOMMAND | MF_ENABLED);

                            EnableMenuItem(L_hMenu, IDM_OPEN, L_wMenuFlags);

                            // See if we can enable the Properties... menu
                            if (EnablePropertiesMenu (hwndActive,pSel))
                                L_wMenuFlags = MF_BYCOMMAND;
                            else
                                L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;
                            EnableMenuItem (L_hMenu, IDM_ATTRIBS, L_wMenuFlags);

                            LocalFree((HANDLE)pSel);

                            NoRunInLongDir(hwndActive, L_hMenu);
                            break;
                        }

                    case IDM_DISK:
                        MSG("FrameWndProc", "IDM_DISK");

                        // be sure not to allow disconnect while any trees
                        // are still being read (iReadLevel != 0)

                        if (bDisconnect) {
                            INT i;

                            L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                            if (!iReadLevel) {
                                for (i=0; i < cDrives; i++) {
                                    wParam = rgiDrive[i];
                                    if ((!IsCDRomDrive((INT)wParam)) && (IsNetDrive((INT)wParam))) {
                                        L_wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
                                        break;
                                    }
                                }
                            }
                            EnableMenuItem(L_hMenu, IDM_DISCONNECT, L_wMenuFlags);
                        } else {
                            if (iReadLevel)
                                EnableMenuItem(L_hMenu, IDM_CONNECTIONS, MF_BYCOMMAND | MF_GRAYED);
                            else
                                EnableMenuItem(L_hMenu, IDM_CONNECTIONS, MF_BYCOMMAND | MF_ENABLED);
                        }

                        break;

                    case IDM_TREE:
                        MSG("FrameWndProc", "IDM_TREE");
                        if (!hwndTree || iReadLevel)
                            L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(L_hMenu, IDM_EXPONE,     L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_EXPSUB,     L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_EXPALL,     L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_COLLAPSE,   L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_ADDPLUSES,  L_wMenuFlags);

                        if (hwndTree)
                            CheckMenuItem(L_hMenu, IDM_ADDPLUSES, GetWindowLong(hwndActive, GWL_VIEW) & VIEW_PLUSES ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        break;

                    case IDM_VIEW:
                        MSG("FrameWndProc", "IDM_VIEW");
                        EnableMenuItem(L_hMenu, IDM_VNAME,    L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_VDETAILS, L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_VOTHER,   L_wMenuFlags);

                        if (hwndActive == hwndSearch || IsIconic(hwndActive))
                            L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;
                        else {
                            CheckMenuItem(L_hMenu, IDM_BOTH, hwndTree && hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                            CheckMenuItem(L_hMenu, IDM_DIRONLY, !hwndTree && hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                            CheckMenuItem(L_hMenu, IDM_TREEONLY, hwndTree && !hwndDir ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        }

                        EnableMenuItem(L_hMenu, IDM_BOTH,      L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_TREEONLY,  L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_DIRONLY,   L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_SPLIT,     L_wMenuFlags);

                        EnableMenuItem(L_hMenu, IDM_VINCLUDE, L_wMenuFlags);

                        wView &= VIEW_EVERYTHING;

                        CheckMenuItem(L_hMenu, IDM_VNAME,   (wView == VIEW_NAMEONLY) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(L_hMenu, IDM_VDETAILS,(wView == VIEW_EVERYTHING) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(L_hMenu, IDM_VOTHER,  (wView != VIEW_NAMEONLY && wView != VIEW_EVERYTHING) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        CheckMenuItem(L_hMenu, IDM_BYNAME, (wSort == IDD_NAME) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(L_hMenu, IDM_BYTYPE, (wSort == IDD_TYPE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(L_hMenu, IDM_BYSIZE, (wSort == IDD_SIZE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);
                        CheckMenuItem(L_hMenu, IDM_BYDATE, (wSort == IDD_DATE) ? MF_CHECKED | MF_BYCOMMAND : MF_UNCHECKED | MF_BYCOMMAND);

                        if (hwndDir)
                            L_wMenuFlags = MF_BYCOMMAND | MF_ENABLED;
                        else
                            L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(L_hMenu, IDM_BYNAME, L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_BYTYPE, L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_BYSIZE, L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_BYDATE, L_wMenuFlags);

                        break;

                    case IDM_OPTIONS:
                        MSG("FrameWndProc", "IDM_OPTIONS");
                        if (iReadLevel)
                            L_wMenuFlags = MF_BYCOMMAND | MF_GRAYED;

                        EnableMenuItem(L_hMenu, IDM_ADDPLUSES, L_wMenuFlags);
                        EnableMenuItem(L_hMenu, IDM_EXPANDTREE, L_wMenuFlags);

                        break;

                    default:
                        MSG("FrameWndProc", "default WM_COMMAND");
                        {
                            INT pos = (INT)LOWORD(lParam) - bMaxed;
                            INT index;

                            if ((pos >= IDM_EXTENSIONS) && (pos < (iNumExtensions + IDM_EXTENSIONS))) {
                                // HIWORD(lParam) is the menu handle
                                // LOWORD(lParam) is menu item delta.  DLL should
                                // add this to it's menu id if it want's to
                                // change the menu.

                                index = pos - IDM_EXTENSIONS;

                                (extensions[index].ExtProc)(hwndFrame, FMEVENT_INITMENU, (LPARAM)(L_hMenu));
                            }
                            break;
                        }
                }
                break;
            }

        case WM_PAINT:
            MSG("FrameWndProc", "WM_PAINT");
            {
                HDC           hdc;
                RECT          rcTemp;
                HBRUSH        hBrush;
                PAINTSTRUCT   ps;
                BOOL bEGA;
                HFONT hFontOld;

                hdc = BeginPaint(hWnd, &ps);

                if (!IsIconic(hWnd) && bStatusBar) {

                    GetClientRect(hWnd, &rc);
                    hFontOld = SelectObject(hdc, hFontStatus);

                    // status area, leave room for the top border
                    rc.top = rc.bottom - dyStatus + dyBorder;

                    bEGA = GetNearestColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT)) ==
                           GetNearestColor(hdc, GetSysColor(COLOR_BTNFACE));

                    if (!bEGA) {

                        // displays with button shadows

                        // draw the frame

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNFACE))) {

                            // top bottom

                            rcTemp = rc;
                            rcTemp.bottom = rcTemp.top + dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            rcTemp = rc;
                            rcTemp.top = rcTemp.bottom - dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left right

                            rcTemp = rc;
                            rcTemp.right = 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            rcTemp = rc;
                            rcTemp.left = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // middle

                            rcTemp = rc;
                            rcTemp.left  = dxStatusField - 4 * dyBorder;
                            rcTemp.right = dxStatusField + 4 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }

                        // shadow

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNSHADOW))) {

                            // left

                            rcTemp.left   = 8 * dyBorder;
                            rcTemp.right  = dxStatusField - 4 * dyBorder;
                            rcTemp.top    = rc.top + dyBorderx2;
                            rcTemp.bottom = rcTemp.top + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // right

                            rcTemp.left   = dxStatusField + 4 * dyBorder;
                            rcTemp.right  = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 1

                            rcTemp = rc;
                            rcTemp.left = 8 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            rcTemp.top += dyBorderx2;
                            rcTemp.bottom -= dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 2

                            rcTemp.left = dxStatusField + 4 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }
                        // the hilight

                        // hilight

                        if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNHIGHLIGHT))) {

                            // left

                            rcTemp.left   = 8 * dyBorder;
                            rcTemp.right  = dxStatusField - 4 * dyBorder;
                            rcTemp.top    = rc.bottom - 3 * dyBorder;
                            rcTemp.bottom = rcTemp.top + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // right

                            rcTemp.left   = dxStatusField + 4 * dyBorder;
                            rcTemp.right  = dxStatusField * 2 - 8 * dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 1

                            rcTemp = rc;
                            rcTemp.left = dxStatusField - 5 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            rcTemp.top += dyBorderx2;
                            rcTemp.bottom -= dyBorderx2;
                            FillRect(hdc, &rcTemp, hBrush);

                            // left side 2

                            rcTemp.left = 2 * dxStatusField - 9 * dyBorder;
                            rcTemp.right = rcTemp.left + dyBorder;
                            FillRect(hdc, &rcTemp, hBrush);

                            DeleteObject(hBrush);
                        }
                    }

                    // solid black line across top (above the status rc)

                    if (hBrush = CreateSolidBrush(GetSysColor(COLOR_BTNTEXT))) {
                        rcTemp = rc;
                        rcTemp.bottom = rcTemp.top;
                        rcTemp.top -= dyBorder;
                        FillRect(hdc, &rcTemp, hBrush);
                        DeleteObject(hBrush);
                    }

                    // set the text and background colors

                    SetTextColor(hdc, GetSysColor(COLOR_BTNTEXT));
                    SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));

                    // now the text, with a gray background

                    rcTemp.top    = rc.top + 3 * dyBorder;
                    rcTemp.bottom = rc.bottom - 3 * dyBorder;
                    rcTemp.left   = 9 * dyBorder;
                    rcTemp.right  = dxStatusField - 5 * dyBorder;

                    ExtTextOut(hdc, rcTemp.left + dyBorderx2, rcTemp.top,
                               ETO_OPAQUE | ETO_CLIPPED, bEGA ? &rc : &rcTemp, szStatusTree, lstrlen(szStatusTree), NULL);

                    rcTemp.left    = dxStatusField + 5 * dyBorder;
                    rcTemp.right   = dxStatusField * 2 - 9 * dyBorder;

                    ExtTextOut(hdc, rcTemp.left + dyBorderx2, rcTemp.top,
                               bEGA ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED, &rcTemp, szStatusDir, lstrlen(szStatusDir), NULL);

                    if (hFontOld)
                        SelectObject(hdc, hFontOld);
                }

                EndPaint(hWnd, &ps);
                break;
            }

        case WM_DESTROY:
            MSG("FrameWndProc", "WM_DESTROY");
            //FileCDR(NULL);
            if (!WinHelp(hwndFrame, szWinObjHelp, HELP_QUIT, 0L)) {
                MyMessageBox(hwndFrame, IDS_WINFILE, IDS_WINHELPERR, MB_OK | MB_ICONEXCLAMATION | MB_SYSTEMMODAL);
            }
            hwndFrame = NULL;
            PostQuitMessage(0);
            break;

        case WM_SIZE:
            MSG("FrameWndProc", "WM_SIZE");
            if (wParam != SIZEICONIC) {
                INT dx, dy;

                // make things look good by putting WS_BORDER on the
                // client, then adjust the thing so it gets clipped

                dx = LOWORD(lParam) + 2 * dyBorder;
                dy = HIWORD(lParam) + 2 * dyBorder;
                if (bStatusBar)
                    dy -= dyStatus;

                MoveWindow(hwndMDIClient, -dyBorder, -dyBorder, dx, dy, TRUE);

                if (bStatusBar) {
                    GetClientRect(hwndFrame, &rc);
                    rc.top = rc.bottom - dyStatus;
                    InvalidateRect(hWnd, &rc, TRUE);
                }
            }
            break;

        case WM_TIMER:

            MSG("FrameWndProc", "WM_TIMER");
            // this came from a FSC that wasn't generated by us
            bFSCTimerSet = FALSE;
            KillTimer(hWnd, 1);
            EnableFSC();
            break;

        case WM_FILESYSCHANGE:
            MSG("FrameWndProc", "WM_FILESYSCHANGE");
            {
                LPSTR lpTo;

                // if its a rename (including those trapped by kernel)
                // find the destination
                if (wParam == FSC_RENAME || wParam == 0x8056) {
                    if (wParam == 0x8056)
                        lpTo = (LPSTR)LOWORD(lParam);
                    else
                        lpTo = (LPSTR)lParam;
                    while (*lpTo++)
                        ;
                } else
                    lpTo = NULL;

                ChangeFileSystem((WORD)wParam, (LPSTR)lParam, lpTo);
                break;
            }

        case WM_SYSCOLORCHANGE:
        case WM_WININICHANGE:
            MSG("FrameWndProc", "WM_SYSCOLORCHANGE/WININICHANGE");
            if (!lParam || !lstrcmpi((LPSTR)lParam, szInternational)) {
                HWND hwnd;
                GetInternational();

                for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {

                    if (!GetWindow(hwnd, GW_OWNER))
                        InvalidateRect(hwnd, NULL, TRUE);
                }
            }
            if (!lParam || !_stricmp((LPSTR)lParam, "colors")) {    // win.ini section [colors]
                HWND hwnd;

                DeleteBitmaps();
                LoadBitmaps();

                InitDriveBitmaps();   // reset the drive bitmaps

                // we need to recread the drives windows to change
                // the bitmaps

                for (hwnd = GetWindow(hwndMDIClient,GW_CHILD);
                    hwnd;
                    hwnd = GetWindow(hwnd,GW_HWNDNEXT)) {

                    if (!GetWindow(hwnd, GW_OWNER))
                        SendMessage(hwnd, FS_CHANGEDRIVES, 0, 0L);
                }
            }
            break;

        case FM_GETFOCUS:
        case FM_GETDRIVEINFO:
        case FM_GETSELCOUNT:
        case FM_GETSELCOUNTLFN:
        case FM_GETFILESEL:
        case FM_GETFILESELLFN:
        case FM_REFRESH_WINDOWS:
        case FM_RELOAD_EXTENSIONS:
            return ExtensionMsgProc(wMsg, wParam, lParam);
            break;

        case WM_MENUSELECT:
            MSG("FrameWndProc", "WM_MENUSELECT");
            if (GET_WM_MENUSELECT_HMENU(wParam, lParam)) {
                // Save the menu the user selected
                wMenuID = GET_WM_MENUSELECT_CMD(wParam, lParam);
                wMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
                L_hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
                if (wMenuID >= IDM_CHILDSTART && wMenuID < IDM_HELPINDEX)
                    wMenuID = IDM_CHILDSTART;
            }
            break;

        case WM_ENDSESSION:
            if (wParam) {
#ifdef ORGCODE
                /* Yeah, I know I shouldn't have to save this, but I don't
                 * trust anybody
                 */
                BOOL bSaveExit = bExitWindows;
                bExitWindows = FALSE;

                /* Simulate an exit command to clean up, but don't display
                 * the "are you sure you want to exit", since somebody should
                 * have already taken care of that, and hitting Cancel has no
                 * effect anyway.
                 */
                AppCommandProc(IDM_EXIT, 0L);
                bExitWindows = bSaveExit;
#else
                AppCommandProc(IDM_EXIT);
#endif
            }
            break;

        case WM_CLOSE:

            MSG("FrameWndProc", "WM_ENDSESSION/WM_CLOSE");
            if (iReadLevel) {
                bCancelTree = 2;
                break;
            }

            wParam = IDM_EXIT;

            /*** FALL THRU ***/

        case WM_COMMAND:
            if (AppCommandProc(GET_WM_COMMAND_ID(wParam, lParam)))
                break;
            if (GET_WM_COMMAND_ID(wParam, lParam) == IDM_EXIT) {

                FreeExtensions();
                if (hModUndelete >= (HANDLE)32)
                    FreeLibrary(hModUndelete);

                DestroyWindow(hWnd);
                break;
            }
            /*** FALL THRU ***/

        default:

            if (wMsg == wHelpMessage) {

                if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_MENU) {

                    // Get outta menu mode if help for a menu item

                    if (wMenuID && L_hMenu) {
                        WORD m = wMenuID;       // save
                        HMENU hM = L_hMenu;
                        WORD  mf = wMenuFlags;

                        SendMessage(hWnd, WM_CANCELMODE, 0, 0L);

                        wMenuID   = m;          // restore
                        L_hMenu = hM;
                        wMenuFlags = mf;
                    }

                    if (!(wMenuFlags & MF_POPUP)) {

                        if (wMenuFlags & MF_SYSMENU)
                            dwContext = IDH_SYSMENU;
                        else
                            dwContext = wMenuID + IDH_HELPFIRST;

                        WFHelp(hWnd);
                    }

                } else if (GET_WM_COMMAND_ID(wParam, lParam) == MSGF_DIALOGBOX) {

                    // context range for message boxes

                    if (dwContext >= IDH_MBFIRST && dwContext <= IDH_MBLAST)
                        WFHelp(hWnd);
                    else
                        // let dialog box deal with it
                        PostMessage(GetRealParent(GET_WM_COMMAND_HWND(wParam, lParam)), wHelpMessage, 0, 0L);
                }

            } else {
                DEFMSG("FrameWndProc", (WORD)wMsg);
                return DefFrameProc(hWnd, hwndMDIClient, wMsg, wParam, lParam);
            }
    }

    return 0L;
}


LRESULT
APIENTRY
MessageFilter(
             INT nCode,
             WPARAM wParam,
             LPARAM lParam
             )
{
    LPMSG lpMsg = (LPMSG) lParam;
    if (nCode == MSGF_MENU) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            // Window of menu we want help for is in loword of lParam.

            PostMessage(hwndFrame, wHelpMessage, MSGF_MENU, MAKELONG((WORD)lpMsg->hwnd,0));
            return 1;
        }

    } else if (nCode == MSGF_DIALOGBOX) {

        if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_F1) {
            // Dialog box we want help for is in loword of lParam

            PostMessage(hwndFrame, wHelpMessage, MSGF_DIALOGBOX, MAKELONG(lpMsg->hwnd, 0));
            return 1;
        }

    }

    return (INT)DefHookProc(nCode, wParam, (LPARAM)lpMsg, &hhkMessageFilter);
}

/*============================================================================
;
; EnablePropertiesMenu
;
; The following function checks to see if we can enable the Properties...
; item in the File menu.  The Properties... menu should be disabled if:
;
; 1) The root directory is selected in the current tree window.
; 2) ONLY the .. directory is selected in the current directory window.
; 3) Nothing is selected in the window having the focus.
;
; Parameters:
;
; hwndActive    - Currently active window, contains a listbox in LASTFOCUS
; pSel          - Currently selected item.
;
; Return Value: This function returns TRUE if the Properties... menu item
;               should be enabled.
;
============================================================================*/

BOOL
EnablePropertiesMenu (
                     HWND hwndActive,
                     PSTR pSel
                     )

{
    HANDLE hDTA;      /* Handle to list box DTA data */
    WORD wHighlight;  /* Number of highlighted entries in listbox */
    LPMYDTA lpmydta; /* Pointer to listbox DTA data */
    BOOL bRet;        /* Return value */
    HWND hwndLB;

    bRet = FALSE;

    /* Can't get properties on root directory */

    if ((lstrlen (pSel) == 3 && pSel[2] == '\\'))
        return (FALSE);

    if (hwndActive == hwndSearch)
        hwndLB = (HWND)GetWindowLongPtr(hwndActive, GWLP_LASTFOCUSSEARCH);
    else
        hwndLB = (HWND)GetWindowLongPtr(hwndActive, GWLP_LASTFOCUS);

    if (!hwndLB)
        return (TRUE);

    wHighlight = (WORD) SendMessage (hwndLB,LB_GETSELCOUNT,0,0L);

    if (hwndActive == hwndSearch)
        return (wHighlight >= 1);

    /* Lock down DTA data */
    if (!(hDTA = (HANDLE)GetWindowLongPtr (GetParent(hwndLB),GWLP_HDTA)))
        return (TRUE);

    if (!(lpmydta = (LPMYDTA) LocalLock (hDTA)))
        return (TRUE);

    if (wHighlight <= 0)
        goto ReturnFalse;

    if (wHighlight > 1)
        goto ReturnTrue;

    /* If exactly one element is highlighted, make sure it is not .. */

    if (!(BOOL) SendMessage (hwndLB,LB_GETSEL,0,0L))
        goto ReturnTrue;

    /* Get the DTA index. */

    SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM) &lpmydta);
    if (!lpmydta)
        goto ReturnFalse;

    if ((lpmydta->my_dwAttrs & ATTR_DIR) &&
        (lpmydta->my_dwAttrs & ATTR_PARENT))
        goto ReturnFalse;

    ReturnTrue:

    bRet = TRUE;

    ReturnFalse:

    LocalUnlock (hDTA);
    return (bRet);
}

LONG
lmul(
    WORD w1,
    WORD w2
    )
{
    return (LONG)w1 * (LONG)w2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wfsys.c ===
/****************************************************************************/
/*                                      */
/*  WFSYS.C -                                   */
/*                                      */
/*  Routines for Making Bootable Floppies                   */
/*                                      */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

#define CSYSFILES   3   /* Three system files are to be copied */
#define SYSFILENAMELEN  16  /* Example "A:\????????.???\0" */

#define SEEK_END    2   /* Used by _llseek() */

/* Error Codes.  NOTE: Don't change this order! */
#define NOERROR     0   /* No error           */
#define NOMEMORY    1   /* Insufficient memory    */
#define NOSRCFILEBIOS   2   /* BIOS is missing    */
#define NOSRCFILEDOS    3   /* DOS is missing     */
#define NOSRCFILECMD    4   /* Command.Com is missing */
#define COPYFILEBIOS    5   /* Error in copying BIOS  */
#define COPYFILEDOS 6   /* Error in copying DOS   */
#define COPYFILECMD 7   /* Error in copying Command.com */
#define INVALIDBOOTSEC  8
#define INVALIDDSTDRIVE 9
#define DSTDISKERROR    10
#define NOTSYSABLE  11  /* First N clusters are NOT empty */
#define NOTSYSABLE1 12  /* First 2 entries in ROOT are not sys files */
#define NOTSYSABLE2 13  /* First N clusters are not allocated to SYS files */
#define NODISKSPACE 14  /* There is not sufficient disk space */

#define BUFFSIZE    8192
#define SECTORSIZE  512

LONG SysFileSize[CSYSFILES];

CHAR BIOSfile[SYSFILENAMELEN];
CHAR DOSfile[SYSFILENAMELEN];
CHAR COMMANDfile[130];  /* Command.com can have a full path name in COMSPEC= */
CHAR *SysFileNamePtr[CSYSFILES]; /* Ptrs to source file names */

/* SysNameTable contains the names of System files; First for PCDOS, the
 * second set for MSDOS.
 */
CHAR *SysNameTable[2][3] = {
    {"IBMBIO.COM", "IBMDOS.COM", "COMMAND.COM"},
    {"IO.SYS",     "MSDOS.SYS",  "COMMAND.COM"}
};


BOOL
IsSYSable(
         WORD    iSrceDrive,
         WORD    iDestDrive,
         CHAR    DestFileNames[][SYSFILENAMELEN],       /* NOTE: 2-dimensional array */
         LPSTR   lpFileBuff
         );



/*--------------------------------------------------------------------------*/
/*                                      */
/*  SameFilenames() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* This checks whether the two filenames are the same or not.
 * The problem lies in the fact that lpDirFileName points to the
 * filename as it appears in a directory (filename padded with blanks
 * up to eight characters and then followed by extension). But
 * szFileName is an ASCII string with no embedded blanks and has a
 * dot that seperates the extension from file name.
 */

BOOL
SameFilenames(
             LPSTR lpDirFileName,
             LPSTR szFileName
             )
{
    INT   i;
    CHAR  c1;
    CHAR  c2;

    /* lpDirFileName definitely has 11 characters (8+3). Nothing more!
     * Nothing less!
     */
    for (i=0; i < 11; i++) {
        c1 = *lpDirFileName++;
        c2 = *szFileName++;
        if (c2 == '.') {
            /* Skip all the blanks at the end of the filename */
            while (c1 == ' ' && i < 11) {
                c1 = *lpDirFileName++;
                i++;
            }

            c2 = *szFileName++;
        }
        if (c1 != c2)
            break;
    }
    return (i != 11);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  HasSystemFiles() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

/* See if the specified disk has IBMBIO.COM and IBMDOS.COM (or IO.SYS and
 * MSDOS.SYS).  If so, store their sizes in SysFileSize[].
 */

BOOL
APIENTRY
HasSystemFiles(
              WORD iDrive
              )
{
    INT      i;
    HFILE    fh;
    DPB      DPB;
    BOOL     rc;
    CHAR     ch;
    LPSTR    lpStr = NULL;
    LPSTR    lpFileBuff = NULL;
    OFSTRUCT OFInfo;
    HANDLE   hFileBuff = NULL;

    /* Initialise the source filename pointers */
    SysFileNamePtr[0] = &BIOSfile[0];
    SysFileNamePtr[1] = &DOSfile[0];
    SysFileNamePtr[2] = &COMMANDfile[0];

    /* Acertain the presence of BIOS/DOS/COMMAND and grab their sizes.
     * First we will try IBMBIO.COM. If it does not exist, then we will try
     * IO.SYS. It it also does not exist, then it is an error.
     */

    /* Get the DPB */
    if (GetDPB(iDrive, &DPB) != NOERROR)
        goto HSFError;

    /* Check if the iDrive has standard sector size; If it doesn't then report
     * error; (We can allocate a bigger buffer and proceed at this point, but
     * int25 to read an abosolute sector may not work in pmodes, because they
     * assume standard sector sizes;)
     * Fix for Bug #10632  --SANKAR-- 03-21-90
     */
    if (HIWORD(GetClusterInfo(iDrive)) > SECTORSIZE)
        goto HSFError;

    /* Allocate enough memory to read the first cluster of root dir. */
    if (!(hFileBuff = LocalAlloc(LHND, (DWORD)SECTORSIZE)))
        goto HSFError;

    if (!(lpFileBuff = LocalLock(hFileBuff)))
        goto HSFError;

    /* Read the first cluster of the root directory. */
    if (MyInt25(iDrive, lpFileBuff, 1, DPB.dir_sector))
        goto HSFError;

    /* Let us start with the first set of system files. */
    for (i=0; i <= CSYSFILES-1; i++) {
        lstrcpy((LPSTR)SysFileNamePtr[i], "C:\\");
        lstrcat((LPSTR)SysFileNamePtr[i], SysNameTable[0][i]);
        *SysFileNamePtr[i] = (BYTE)('A'+iDrive);
    }
    /* Get the command.com from the COMSPEC= environment variable */
    lpStr = MGetDOSEnvironment();

    /* Find the COMSPEC variable. */
    while (*lpStr != TEXT('\0')) {
        if (lstrlen(lpStr) > 8) {
            ch = lpStr[7];
            lpStr[7] = TEXT('\0');
            if (_stricmp(lpStr, (LPSTR)"COMSPEC") == 0) {
                lpStr[7] = ch;
                break;
            }
        }
        lpStr += lstrlen(lpStr)+1;
    }

    /* If no COMSPEC then things are really roached... */
    if (*lpStr == TEXT('\0'))
        goto HSFError;

    /* The environment variable is COMSPEC; Look for '=' char */
    while (*lpStr != '=')
        lpStr = AnsiNext(lpStr);

    /* Copy the command.com with the full pathname */
    lstrcpy((LPSTR)SysFileNamePtr[2], lpStr);

    /* Check if the IBMBIO.COM and IBMDOS.COM exist. */
    if (SameFilenames(lpFileBuff, (LPSTR)(SysFileNamePtr[0]+3)) ||
        SameFilenames(lpFileBuff+sizeof(DIRTYPE), (LPSTR)(SysFileNamePtr[1]+3))) {
        /* Check if at least IO.SYS and MSDOS.SYS exist. */
        lstrcpy((LPSTR)(SysFileNamePtr[0]+3), SysNameTable[1][0]);
        lstrcpy((LPSTR)(SysFileNamePtr[1]+3), SysNameTable[1][1]);
        if (SameFilenames(lpFileBuff, (SysFileNamePtr[0]+3)) ||
            SameFilenames(lpFileBuff+sizeof(DIRTYPE), (SysFileNamePtr[1]+3)))
            goto HSFError;
    }

    /* Check if COMMAND.COM exists in the source drive. */
    if ((fh = MOpenFile((LPSTR)SysFileNamePtr[2], (LPOFSTRUCT)&OFInfo, OF_READ)) == -1)
        goto HSFError;

    /* Get the file sizes. */
    SysFileSize[0] = ((LPDIRTYPE)lpFileBuff)->size;
    SysFileSize[1] = ((LPDIRTYPE)(lpFileBuff+sizeof(DIRTYPE)))->size;
    SysFileSize[2] = M_llseek(fh, 0L, SEEK_END);
    M_lclose(fh);
    rc = TRUE;
    goto HSFExit;

HSFError:
    rc = FALSE;

HSFExit:
    if (lpFileBuff)
        LocalUnlock(hFileBuff);
    if (hFileBuff)
        LocalFree(hFileBuff);
    if (lpStr)
        MFreeDOSEnvironment(lpStr);

    return (rc);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CalcFreeSpace() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* Given an array of filenames and the number of files, this function
 * calculates the freespace that would be created if those files are deleted.
 *
 * NOTE: This function returns TOTAL free space, (i.e) the summation of
 *   already existing free space and the space occupied by those files.
 */

INT
CalcFreeSpace(
             CHAR    DestFiles[][SYSFILENAMELEN],
             INT cFiles,
             INT cbCluster,
             WORD    wFreeClusters,
             WORD    wReqdClusters
             )
{
    INT   i;
    HFILE fh;
    LONG  lFileSize;
    OFSTRUCT OFInfo;

    ENTER("CalcFreeSpace");

    /* Find out the space already occupied by SYS files, if any. */
    for (i=0; i < cFiles; i++) {
        fh = MOpenFile(&DestFiles[i][0], &OFInfo, OF_READ);
        if (fh != (HFILE)-1) {
            /* Get the file size */
            lFileSize = M_llseek(fh, 0L, SEEK_END);

            if (lFileSize != -1L)
                wFreeClusters += LOWORD((lFileSize + cbCluster - 1)/cbCluster);

            M_lclose(fh);

            if (wFreeClusters >= wReqdClusters)
                return (wFreeClusters);
        }
    }
    LEAVE("CalcFreeSpace");
    return (wFreeClusters);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  CheckDiskSpace() -                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL
CheckDiskSpace(
              WORD    iDestDrive,
              INT cbCluster,              /* Bytes/Cluster of dest drive */
              CHAR    DestFileNames[][SYSFILENAMELEN],    /* NOTE: 2-dimensional array */
              BOOL    bDifferentSysFiles,
              CHAR    DestSysFiles[][SYSFILENAMELEN]
              )

{
    INT   i;
    INT   wFreeClusters;
    INT   wReqdClusters;

    /* Compute the number of clusters required. */
    wReqdClusters = 0;
    for (i=0; i < CSYSFILES; i++)
        wReqdClusters += LOWORD((SysFileSize[i] + cbCluster - 1) / cbCluster);

    /* Calculate the free disk space in clusters in the destination disk */
    wFreeClusters = LOWORD(GetFreeDiskSpace(iDestDrive) / cbCluster);

    if (wFreeClusters >= wReqdClusters)
        /* We have enough space. */
        return (TRUE);

    wFreeClusters = CalcFreeSpace(DestFileNames, CSYSFILES, cbCluster, (WORD)wFreeClusters, (WORD)wReqdClusters);
    if (wFreeClusters >= wReqdClusters)
        return (TRUE);

    /* Check if the sys files in the dest disk are different. */
    if (bDifferentSysFiles) {
        wFreeClusters = CalcFreeSpace(DestSysFiles, 2, cbCluster, (WORD)wFreeClusters, (WORD)wReqdClusters);
        if (wFreeClusters >= wReqdClusters)
            return (TRUE);
    }

    /* Insufficient disk space even if we delete the sys files. */
    return (FALSE);
}



/*--------------------------------------------------------------------------*/
/*                                      */
/*  IsSYSable() -                               */
/*                                      */
/*--------------------------------------------------------------------------*/

/* The requirements for the destination disk to be sysable are either:
 *
 * 1) first two directory entries are empty
 * 2) the first N clusters free where N = ceil (size IBMBIO/secPerClus)
 * 3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND
 *
 * - or -
 *
 * 1) the first two directory entries are IBMBIO.COM and IBMDOS.COM
 *                    or  IO.SYS and MSDOS.SYS
 * 2) the first N clusters are alloced to these files where N is defines above.
 * 3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND after
 *     deleting the IBMBIO/IBMDOS/COMMAND on the disk.
 *
 *  IMPORTANT NOTE:
 *  DestFileNames[][] contain the names of the sys files that would be
 *  created on the Destination diskette;
 *  DestSysFiles[][] contain the names of the sys files already
 *  present in the destination diskette, if any; Please Note that
 *  these two sets of filenames need not be the same, because you can
 *  install MSDOS on to a diskette that already has PCDOS and
 *  vice-versa.
 */

BOOL
IsSYSable(
         WORD    iSrceDrive,
         WORD    iDestDrive,
         CHAR    DestFileNames[][SYSFILENAMELEN],       /* NOTE: 2-dimensional array */
         LPSTR   lpFileBuff
         )
{
#ifdef LATER
    INT       i;
    DPB       DPB;
    WORD      clusTmp1, clusTmp2;
    WORD      clusBIOS, clusDOS;
    INT       cBytesPerCluster;
    INT       cBIOSsizeInClusters;
    BOOL      bDifferentDestFiles = FALSE;
    CHAR      chVolLabel[11];     /* This is NOT null terminated */
    DWORD     dwSerialNo;
    CHAR      DestSysFiles[2][SYSFILENAMELEN];
    INT       cContigClusters;
    DWORD     dwClusterInfo;
    CHAR      szTemp[SYSFILENAMELEN];

    /* Grab DPB for destination. */
    if (GetDPB(iDestDrive, &DPB))
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Get bytes per cluster for destination. */
    dwClusterInfo = GetClusterInfo(iDestDrive);
    /* Bytes per cluster = sectors per cluster * size of a sector   */
    cBytesPerCluster = LOWORD(dwClusterInfo) * HIWORD(dwClusterInfo);
    if (!cBytesPerCluster)
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Convert size of BIOS into full clusters */
    cBIOSsizeInClusters = LOWORD((SysFileSize[0] + cBytesPerCluster - 1) / cBytesPerCluster);

    /* Number of clusters required to be contiguous depends on DOS versions.
     * DOS 3.2 and below expect all clusters of BIOS to be contiguos.
     * But 3.3 and above expect only the first stub loader (<2K) to be contiguous.
     */
    cContigClusters = (GetDOSVersion() > 0x314) ?
                      ((2048 + cBytesPerCluster - 1)/cBytesPerCluster) :
                      cBIOSsizeInClusters;

    /* Grab first sector of destination root directory */
    if (MyInt25(iDestDrive, lpFileBuff, 1, DPB.dir_sector))
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Are the first two directory entries empty? */
    if ((lpFileBuff[0]           == 0 || (BYTE)lpFileBuff[0]           == 0xE5) &&
        (lpFileBuff[sizeof(DIRTYPE)] == 0 || (BYTE)lpFileBuff[sizeof(DIRTYPE)] == 0xE5)) {
        /* Any of first N (= BIOS size) clusters not empty? */
        for (i=0; i < cContigClusters; i++) {
            /* Has the user aborted? */
            if (WFQueryAbort())
                return (FALSE);
        }
    } else {
        /* Are the first two directory entries NOT BIOS/DOS? */
        for (i=0; i < 2; i++) {
            if ((!SameFilenames(lpFileBuff, SysNameTable[i][0])) ||
                (!SameFilenames(lpFileBuff+sizeof(DIRTYPE), SysNameTable[i][1]))) {
                /* Check if the destination files are the same as the source files */
                if (lstrcmpi(&DestFileNames[0][3], SysNameTable[i][0])) {
                    /* No! Delete the other set of filenames. */
                    DestSysFiles[0][0] = DestSysFiles[1][0] = (BYTE)('A'+iDestDrive);
                    lstrcpy(&DestSysFiles[0][1], ":\\");
                    lstrcpy(&DestSysFiles[0][3], SysNameTable[i][0]);
                    lstrcpy(&DestSysFiles[1][1], ":\\");
                    lstrcpy(&DestSysFiles[1][3], SysNameTable[i][1]);
                    bDifferentDestFiles = TRUE;
                }
                break;
            }
        }

        /* Did we find a match? */
        if (i == 2)
            /* Nope, the 2 entries are occupied by non-system files. */
            return (FALSE);

        /* Any of first N clusters NOT allocated to BIOS/DOS? */
        clusBIOS = ((LPDIRTYPE)lpFileBuff)->first;
        clusDOS = ((LPDIRTYPE)(lpFileBuff + sizeof(DIRTYPE)))->first;

        /* Do it the hard way, for each cluster 2..N+2 see if it is in the chain.
         */
        for (i=0; i < cContigClusters; i++) {
            clusTmp1 = clusBIOS;
            clusTmp2 = clusDOS;

            /* Check if cluster #i+2 is allocated to either of these files. */
            while (TRUE) {
                if (i+2 == (INT)clusTmp1 || i+2 == (INT)clusTmp2)
                    break;

//            if (clusTmp1 != -1)
                if (clusTmp1 < 0xFFF0)
                    clusTmp1 = 0;
//            if (clusTmp2 != -1)
                if (clusTmp2 < 0xFFF0)
                    clusTmp2 = 0;
//            if (clusTmp1 == -1 && clusTmp2 == -1)
                if (clusTmp1 >= 0xFFF0 && clusTmp2 >= 0xFFF0)
                    return FALSE;

                /* Did the user abort? */
                if (WFQueryAbort())
                    return FALSE;
            }
        }
    }

    /* Let us check if there is enough space on the dest disk. */
    if (CheckDiskSpace(iDestDrive, cBytesPerCluster, DestFileNames, bDifferentDestFiles, DestSysFiles) == FALSE)
        return (FALSE);

    /* Has the user aborted? */
    if (WFQueryAbort())
        return (FALSE);

    /* Get the Present Volume label and preserve it. */
    GetVolumeLabel(iDestDrive, (LPSTR)chVolLabel, FALSE);

    /*** NOTE: chVolLabel remains in OEM characters! ***/

    /* Get the serial no if any and preserve it. */
    dwSerialNo = ReadSerialNumber(iDestDrive, lpFileBuff);

    /* Copy and adjust boot sector from source to destination */
    if (WriteBootSector(iSrceDrive, iDestDrive, NULL, lpFileBuff) != NOERROR)
        return (FALSE);

    /* Restore the old volume label and serial number in the boot rec. */
    if (ModifyVolLabelInBootSec(iDestDrive, (LPSTR)chVolLabel, dwSerialNo, lpFileBuff))
        return (FALSE);

    /* Delete destination BIOS/DOS/COMMAND. */
    for (i=0; i < CSYSFILES; i++) {
        AnsiToOem(DestFileNames[i], szTemp);
        SetFileAttributes(szTemp, 0);
        DosDelete(szTemp);
        if ((bDifferentDestFiles) && (i < 2)) {
            SetFileAttributes(szTemp, 0);
            DosDelete(szTemp);
        }

        /* Has the user aborted? */
        if (WFQueryAbort())
            return (FALSE);
    }

    /* Reset the DPB_next_free field of the DPB to 2, sothat when IBMBIO.COM is
     * copied into this disk, the clusters will get allocated starting from 2.
     */
    ModifyDPB(iDestDrive);
#endif // LATER

    return (TRUE);
}


/*--------------------------------------------------------------------------*/
/*                                      */
/*  MakeSystemDiskette() -                          */
/*                                      */
/*--------------------------------------------------------------------------*/

/* This routine is intended to mimic the functions of the SYS command
 * under MSDOS:  to transfer a version of the operating system from a source
 * disk to a destination such that the destination will be bootable.
 *
 *  The requirements of the source disk is that it contain:
 *
 *      1) a command processor (COMMAND.COM)
 *      2) a default set of device drivers (IBMBIO.COM)
 *      3) an operating system (IBMDOS.COM)
 *      4) a boot sector appropriate to the device drivers
 *
 *  The requirements for the destination disk are either:
 *
 *      1) first two directory entries are empty
 *      2) the first N clusters free where N = ceil (size IBMBIO/secPerClus)
 *      3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND
 *
 *  - or -
 *
 *      1) the first two directory entries are IBMBIO.COM and IBMDOS.COM
 *                                         or  IO.SYS and MSDOS.SYS
 *      2) the first N clusters are alloced to these files where N is defined
 *          above
 *      3) there is enough room on the disk for IBMBIO/IBMDOS/COMMAND after
 *      deleting the IBMBIO/IBMDOS/COMMAND on the disk.
 *
 *  Inputs:
 *        iDestDrive 0-based drive number of formatted drive
 *                       for destination.
 *        bEmptyFloppy : TRUE if the floppy is empty; Useful when
 *          the floppy is just formatted; No need to check if
 *          it is Sysable;
 *  Returns:    0       Successful transferral of boot sector and files
 *      <> 0    error code.
 */


BOOL
APIENTRY
MakeSystemDiskette(
                  WORD iDestDrive,
                  BOOL bEmptyFloppy
                  )
{
    INT       i;
    HANDLE    hFileBuff;  /* Buffer to read in file contents etc., */
    LPSTR     lpFileBuff;
    CHAR      DestFileName[CSYSFILES][SYSFILENAMELEN];
    CHAR      szTemp1[SYSFILENAMELEN];
    CHAR      szTemp2[SYSFILENAMELEN];
    WORD      nSource;

    nSource = (WORD)GetBootDisk();


    if (!HasSystemFiles(nSource)) {
        LoadString(hAppInstance, IDS_SYSDISKNOFILES, szMessage, sizeof(szMessage));
        MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        bUserAbort = TRUE;
        return FALSE;
    }

    if (iDestDrive == nSource) {
        LoadString(hAppInstance, IDS_SYSDISKSAMEDRIVE, szMessage, sizeof(szMessage));
        MessageBox(hdlgProgress, szMessage, szTitle, MB_OK | MB_ICONSTOP);
        bUserAbort = TRUE;
        return FALSE;
    }

    /* Initialize variables for cleanup. */
    hFileBuff = NULL;
    lpFileBuff = NULL;

    /* Flush the DOS buffers. */
    DiskReset();

    if (!(hFileBuff = LocalAlloc(LHND, (DWORD)BUFFSIZE)))
        return (1);

    lpFileBuff = LocalLock(hFileBuff);

    for (i=0; i < (CSYSFILES - 1); i++) {
        /* Create the destination file names */
        lstrcpy((LPSTR)&DestFileName[i][0], (LPSTR)SysFileNamePtr[i]);
        DestFileName[i][0] = (BYTE)('A' + iDestDrive);
    }

    /* Copy just the Command.COM without any path name */
    lstrcpy((LPSTR)DestFileName[2], "X:\\");
    lstrcat((LPSTR)DestFileName[2], (LPSTR)SysNameTable[0][2]);
    DestFileName[2][0] = (BYTE)('A' + iDestDrive);

    /* Check if it is an empty floppy; If so, there is no need to check if it
     * is 'SYSable'. It is bound to be 'Sysable'. So, skip all the checks and
     * go ahead with copying the sys files.
     */
    if (!bEmptyFloppy) {

        /* Check if the Destination floppy is SYS-able */
        if (!IsSYSable(nSource, iDestDrive, DestFileName, lpFileBuff))
            goto MSDErrExit;

        /* Did the user abort? */
        if (WFQueryAbort())
            goto MSDErrExit;
    }

    /* Copy files */

    bCopyReport = FALSE;

    DisableFSC();

    for (i=0; i < CSYSFILES; i++) {
        /* Copy all files except command.com with sys attributes */
        AnsiToOem(SysFileNamePtr[i], szTemp1);
        AnsiToOem(DestFileName[i], szTemp2);

        /* Make sure the destination file is deleted first */
        SetFileAttributes(szTemp2, ATTR_ALL);
        WFRemove(szTemp2);

        // copy code preserves the attributes
        if (FileCopy(szTemp1, szTemp2))
            goto MSDErrExit2;

        if (WFQueryAbort())
            goto MSDErrExit2;
    }


    if (EndCopy())          // empty the copy queue
        goto MSDErrExit2;

    EnableFSC();

    /* Normal Exit. */

    LocalUnlock(hFileBuff);
    LocalFree(hFileBuff);

    return FALSE;     // success

    MSDErrExit2:

    EnableFSC();

    MSDErrExit:

    CopyAbort();      // Purge any copy commands in copy queue
    LocalUnlock(hFileBuff);
    LocalFree(hFileBuff);

    return TRUE;      // failure
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\winnet.h ===
/*
 *  Windows/Network Interface
 *  Copyright (C) Microsoft 1989
 *
 *  Standard WINNET Driver Header File, spec version 3.10
 *                       rev. 3.10.05 ;Internal
 */


/*
 *  SPOOLING - CONTROLLING JOBS
 */


#include "winnetwk.h"
#include "mpr.h"

#define	LPUINT	PUINT

#define WNJ_NULL_JOBID  0


WORD WNetOpenJob(LPTSTR,LPTSTR,WORD,LPINT);
WORD WNetCloseJob(WORD,LPINT,LPTSTR);
WORD WNetWriteJob(HANDLE,LPTSTR,LPINT);
WORD WNetAbortJob(WORD,LPTSTR);
WORD WNetHoldJob(LPTSTR,WORD);
WORD WNetReleaseJob(LPTSTR,WORD);
WORD WNetCancelJob(LPTSTR,WORD);
WORD WNetSetJobCopies(LPTSTR,WORD,WORD);

/*
 *  SPOOLING - QUEUE AND JOB INFO
 */

typedef struct _queuestruct {
    WORD    pqName;
    WORD    pqComment;
    WORD    pqStatus;
    WORD    pqJobcount;
    WORD    pqPrinters;
} QUEUESTRUCT;

typedef QUEUESTRUCT far * LPQUEUESTRUCT;

#define WNPRQ_ACTIVE    0x0
#define WNPRQ_PAUSE 0x1
#define WNPRQ_ERROR 0x2
#define WNPRQ_PENDING   0x3
#define WNPRQ_PROBLEM   0x4


typedef struct _jobstruct {
    WORD    pjId;
    WORD    pjUsername;
    WORD    pjParms;
    WORD    pjPosition;
    WORD    pjStatus;
    DWORD   pjSubmitted;
    DWORD   pjSize;
    WORD    pjCopies;
    WORD    pjComment;
} JOBSTRUCT;

typedef JOBSTRUCT far * LPJOBSTRUCT;

#define WNPRJ_QSTATUS       0x0007
#define  WNPRJ_QS_QUEUED        0x0000
#define  WNPRJ_QS_PAUSED        0x0001
#define  WNPRJ_QS_SPOOLING      0x0002
#define  WNPRJ_QS_PRINTING      0x0003
#define WNPRJ_DEVSTATUS     0x0FF8
#define  WNPRJ_DS_COMPLETE      0x0008
#define  WNPRJ_DS_INTERV        0x0010
#define  WNPRJ_DS_ERROR         0x0020
#define  WNPRJ_DS_DESTOFFLINE       0x0040
#define  WNPRJ_DS_DESTPAUSED        0x0080
#define  WNPRJ_DS_NOTIFY        0x0100
#define  WNPRJ_DS_DESTNOPAPER       0x0200
#define  WNPRJ_DS_DESTFORMCHG       0x0400
#define  WNPRJ_DS_DESTCRTCHG        0x0800
#define  WNPRJ_DS_DESTPENCHG        0x1000

#define SP_QUEUECHANGED     0x0500


WORD WNetWatchQueue(HWND,LPTSTR,LPTSTR,WORD);
WORD WNetUnwatchQueue(LPTSTR);
WORD WNetLockQueueData(LPTSTR,LPTSTR,LPQUEUESTRUCT FAR *);
WORD WNetUnlockQueueData(LPTSTR);



/* this is the data structure returned from LFNFindFirst and
 * LFNFindNext.  The last field, achName, is variable length.  The size
 * of the name in that field is given by cchName, plus 1 for the zero
 * terminator.
 */
typedef struct _filefindbuf2 {
    WORD fdateCreation;
    WORD ftimeCreation;
    WORD fdateLastAccess;
    WORD ftimeLastAccess;
    WORD fdateLastWrite;
    WORD ftimeLastWrite;
    DWORD cbFile;
    DWORD cbFileAlloc;
    WORD attr;
    DWORD cbList;
    BYTE cchName;
    BYTE achName[1];
} FILEFINDBUF2, FAR * PFILEFINDBUF2;

typedef BOOL (FAR PASCAL *PQUERYPROC)( void );

WORD LFNFindFirst(LPTSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindClose(HANDLE);
WORD LFNGetAttribute(LPTSTR,LPINT);
WORD LFNSetAttribute(LPTSTR,WORD);
WORD LFNCopy(LPTSTR,LPTSTR,PQUERYPROC);
WORD LFNMove(LPTSTR,LPTSTR);
WORD LFNDelete(LPTSTR);
WORD LFNMKDir(LPTSTR);
WORD LFNRMDir(LPTSTR);
WORD LFNGetVolumeLabel(WORD,LPTSTR);
WORD LFNSetVolumeLabel(WORD,LPTSTR);
WORD LFNParse(LPTSTR,LPTSTR,LPTSTR);
WORD LFNVolumeType(WORD,LPINT);

/* return values from LFNParse
 */
#define FILE_83_CI      0
#define FILE_83_CS      1
#define FILE_LONG       2

/* volumes types from LFNVolumeType
 */
#define VOLUME_STANDARD     0
#define VOLUME_LONGNAMES    1

// will add others later, == DOS int 21h error codes.

// this error code causes a call to WNetGetError, WNetGetErrorText
// to get the error text.
#define ERROR_NETWORKSPECIFIC   0xFFFF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\winnet.c ===
/*
 * This file contains stubs to simulate WINNET apis
 *
 * Createsd 4/23/91 sanfords
 */

#include <windows.h>
#include "winnet.h"

WORD
WNetOpenJob(
           LPTSTR szQueue,
           LPTSTR szJobTitle,
           WORD nCopies,
           LPINT lpfh
           )
{
    szQueue; szJobTitle; nCopies; lpfh;

    return (0);
}

WORD
WNetCloseJob(
            WORD fh,
            LPINT lpidJob,
            LPTSTR szQueue
            )
{
    fh; lpidJob; szQueue;

    return (0);
}

WORD
WNetWriteJob(
            HANDLE hJob,
            LPTSTR lpData,
            LPINT lpcb
            )
{
    hJob; lpData; lpcb;

    return (0);
}

WORD
WNetAbortJob(
            WORD fh,
            LPTSTR lpszQueue
            )
{
    fh; lpszQueue;

    return (0);
}


WORD
WNetHoldJob(
           LPTSTR szQueue,
           WORD idJob
           )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetReleaseJob(
              LPTSTR szQueue,
              WORD idJob
              )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetCancelJob(
             LPTSTR szQueue,
             WORD idJob
             )
{
    szQueue; idJob;

    return (0);
}

WORD
WNetSetJobCopies(
                LPTSTR szQueue,
                WORD idJob,
                WORD nCopies
                )
{
    szQueue; idJob; nCopies;

    return (0);
}

WORD
WNetWatchQueue(
              HWND hwnd,
              LPTSTR szLocal,
              LPTSTR szUsername,
              WORD wIndex
              )

{
    hwnd; szLocal; szUsername; wIndex;

    return (0);
}

WORD
WNetUnwatchQueue(
                LPTSTR szQueue
                )
{
    szQueue;

    return (0);
}

WORD
WNetLockQueueData(
                 LPTSTR szQueue,
                 LPTSTR szUsername,
                 LPQUEUESTRUCT *lplpQueue
                 )
{
    szQueue; szUsername; lplpQueue;

    return (0);
}

WORD
WNetUnlockQueueData(
                   LPTSTR szQueue
                   )
{
    szQueue;

    return (0);
}


// grabbed from win31 user\net.c

DWORD
APIENTRY
WNetErrorText(
             DWORD wError,
             LPTSTR lpsz,
             DWORD cbMax
             )
{
    DWORD wInternalError;
    DWORD cb = 0;
#ifdef LATER
    TCHAR szT[40];
#endif

    wsprintf( lpsz, TEXT("Error %d occurred"), wError);
    return cb;
}

#if LATERMAYBE
WORD LFNFindFirst(LPTSTR,WORD,LPINT,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindNext(HANDLE,LPINT,WORD,PFILEFINDBUF2);
WORD LFNFindClose(HANDLE);
WORD LFNGetAttribute(LPTSTR,LPINT);
WORD LFNSetAttribute(LPTSTR,WORD);
WORD LFNCopy(LPTSTR,LPTSTR,PQUERYPROC);
WORD LFNMove(LPTSTR,LPTSTR);
WORD LFNDelete(LPTSTR);
WORD LFNMKDir(LPTSTR);
WORD LFNRMDir(LPTSTR);
WORD LFNGetVolumeLabel(WORD,LPTSTR);
WORD LFNSetVolumeLabel(WORD,LPTSTR);
WORD LFNParse(LPTSTR,LPTSTR,LPTSTR);
WORD LFNVolumeType(WORD,LPINT);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wftree.c ===
/****************************************************************************/
/*                                                                          */
/*  WFTREE.C -                                                              */
/*                                                                          */
/*      Windows File System Tree Window Proc Routines                       */
/*                                                                          */
/****************************************************************************/

#include "winfile.h"
#include "winnet.h"
#include "lfn.h"
#include "wfcopy.h"

HICON GetTreeIcon(HWND hWnd);

VOID  APIENTRY CheckEscapes(LPSTR);

HICON
GetTreeIcon(
           HWND hWnd
           )
{
    HWND hwndTree, hwndDir;

    hwndTree = HasTreeWindow(hWnd);
    hwndDir = HasDirWindow(hWnd);

    if (hwndTree && hwndDir)
        return hicoTreeDir;
    else if (hwndTree)
        return hicoTree;
    else
        return hicoDir;
}



VOID
APIENTRY
GetTreeWindows(
              HWND hwnd,
              PHWND phwndTree,
              PHWND phwndDir,
              PHWND phwndDrives
              )
{
    if (phwndTree) {
        *phwndTree = GetDlgItem(hwnd, IDCW_TREECONTROL);
    }
    if (phwndDir) {
        *phwndDir  = GetDlgItem(hwnd, IDCW_DIR);
    }
    if (phwndDrives) {
        *phwndDrives = GetDlgItem(hwnd, IDCW_DRIVES);
    }
}


// returns hwndTree, hwndDir or hwndDrives depending on the focus tracking
// for the window.  if none is found we return NULL

HWND
APIENTRY
GetTreeFocus(
            HWND hwndTree
            )
{
    HWND hwnd, hwndLast = NULL;

    hwndLast = hwnd = (HWND)GetWindowLongPtr(hwndTree, GWLP_LASTFOCUS);

    while (hwnd && hwnd != hwndTree) {
        hwndLast = hwnd;
        hwnd = GetParent(hwnd);
    }

    return hwndLast;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CompactPath() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

BOOL
APIENTRY
CompactPath(
           HDC hDC,
           LPSTR lpszPath,
           WORD dx
           )
{
    register INT  len;
    INT           dxFixed, dxT;
    LPSTR         lpEnd;          /* end of the unfixed string */
    LPSTR         lpFixed;        /* start of text that we always display */
    BOOL          bEllipsesIn;
    CHAR          szTemp[MAXPATHLEN];

    /* Does it already fit? */
    MGetTextExtent(hDC, lpszPath, lstrlen(lpszPath), &dxFixed, NULL);
    if (dxFixed <= (INT)dx)
        return(TRUE);

    /* Search backwards for the '\', and man, it better be there! */
    lpFixed = lpszPath + lstrlen(lpszPath);
    while (*lpFixed != '\\')
        lpFixed = AnsiPrev(lpszPath, lpFixed);

    /* Save this guy to prevent overlap. */
    lstrcpy(szTemp, lpFixed);

    lpEnd = lpFixed;
    bEllipsesIn = FALSE;
    MGetTextExtent(hDC, lpFixed, lstrlen(lpFixed), &dxFixed, NULL);

    while (TRUE) {
        MGetTextExtent(hDC, lpszPath, (int)(lpEnd - lpszPath), &dxT, NULL);
        len = dxFixed + dxT;

        if (bEllipsesIn)
            len += dxEllipses;

        if (len <= (INT)dx)
            break;

        bEllipsesIn = TRUE;

        if (lpEnd <= lpszPath) {
            /* Things didn't fit. */
            lstrcpy(lpszPath, szEllipses);
            lstrcat(lpszPath, szTemp);
            return(FALSE);
        }

        /* Step back a character. */
        lpEnd = AnsiPrev(lpszPath, lpEnd);
    }

    if (bEllipsesIn) {
        lstrcpy(lpEnd, szEllipses);
        lstrcat(lpEnd, szTemp);
    }

    return(TRUE);
}



//
// BOOL  APIENTRY ResizeSplit(HWND hWnd, int dxSplit)
//
// creates/resizes children of the MDI child for the given path or resizes
// (perhaps creating and destroying) these guys based on the dxSplit
// parameter
//
// in:
//      hWnd    window to fiddle with
//      dxSpit  location of split between tree and dir panes
//              if less than size limit no tree is created
//              (current is destroyed)
//              if past limit on right margin the dir window
//              is destroyed (or not created)
//
// returns:
//      TRUE    success, windows created
//      FALSE   failure, windows failed creation, out of mem, or
//              the tree was in a state the couldn't be resized
//

BOOL
APIENTRY
ResizeSplit(
           HWND hWnd,
           INT dxSplit
           )
{
    RECT rc;
    HWND hwndTree, hwndDir, hwndDrives, hwndLB;
    DWORD dwTemp;

    GetTreeWindows(hWnd, &hwndTree, &hwndDir, &hwndDrives);

    if (hwndTree && GetWindowLong(hwndTree, GWL_READLEVEL))
        return FALSE;

    GetClientRect(hWnd, &rc);

    // create the drives

    if (!hwndDrives) {

        // make new drives window

        hwndDrives = CreateWindowEx(0, szDrivesClass, NULL,

                                    WS_CHILD | WS_VISIBLE,
                                    0, 0, 0, 0,
                                    hWnd, (HMENU)IDCW_DRIVES,
                                    hAppInstance, NULL);

        if (!hwndDrives)
            return FALSE;
    }

    if (dxSplit > dxDriveBitmap * 2) {

        if (!hwndTree) {        // make new tree window

            hwndTree = CreateWindowEx(0, szTreeControlClass,
                                      NULL, WS_CHILD | WS_VISIBLE,
                                      0, 0, 0, 0, hWnd, (HMENU)IDCW_TREECONTROL,
                                      hAppInstance, NULL);

            if (!hwndTree)
                return FALSE;

            // only reset this if the dir window already
            // exists, that is we are creating the tree
            // by splitting open a dir window

            if (hwndDir)
                SendMessage(hwndTree, TC_SETDRIVE, MAKEWORD(FALSE, 0), 0L);
        }
    } else if (hwndTree) {          // we are closing the tree window

        // If the directory window is empty, then set the focus to the
        // drives window.

        if (hwndDir) {
            hwndLB = GetDlgItem (hwndDir,IDCW_LISTBOX);
            if (hwndLB) {
                SendMessage (hwndLB,LB_GETTEXT,0,(LPARAM)(LPSTR) &dwTemp);
                if (!dwTemp)
                    SetFocus (hwndDrives);
            }
        }
        DestroyWindow(hwndTree);
        dxSplit = 0;
    }

    if ((rc.right - dxSplit) > dxDriveBitmap * 2) {

        if (!hwndDir) {
            hwndDir = CreateWindowEx(0, szDirClass, NULL,
                                     WS_CHILD | WS_VISIBLE,
                                     0, 0, 0, 0,
                                     hWnd,(HMENU)IDCW_DIR,
                                     hAppInstance, NULL);
            if (!hwndDir)
                return FALSE;
        }
    } else if (hwndDir) {
        DestroyWindow(hwndDir);
        dxSplit = rc.right;
    }

    UpdateStatus(hWnd);

    SetWindowLong(hWnd, GWL_SPLIT, dxSplit);

    return TRUE;
}



/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  TreeWndProc() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/

/* WndProc for the MDI child window containing the drives, volume, and
 * directory tree child windows.
 */

INT_PTR
APIENTRY
TreeWndProc(
           HWND hWnd,
           UINT wMsg,
           WPARAM wParam,
           LPARAM lParam
           )
{
    HWND hwndTree, hwndDir, hwndDrives, hwndFocus;
    CHAR szDir[MAXPATHLEN];
    RECT rc;
    HDC hdc;

    STKCHK();

    switch (wMsg) {
        case WM_FILESYSCHANGE:
            MSG("TreeWndProc", "WM_FILESYSCHANGE");

            if (hwndDir = HasDirWindow(hWnd))
                SendMessage(hwndDir, wMsg, wParam, lParam);

            break;

        case FS_CHANGEDRIVES:
            MSG("TreeWndProc", "FS_CHANGEDRIVES");
            {
                INT   iNewDrive;

                if (!(hwndDrives = GetDlgItem(hWnd, IDCW_DRIVES)))
                    break;

                DestroyWindow(hwndDrives);

                // see if this drive has gone, if so set this to the
                // last drive in the list

                iNewDrive = -1;

                if (!IsValidDisk((INT)GetWindowLong(hWnd, GWL_TYPE))) {
                    iNewDrive = rgiDrive[cDrives - 1];
                    SetWindowLong(hWnd, GWL_TYPE, iNewDrive);
                }

                hwndDrives = CreateWindowEx(0, szDrivesClass, NULL,
                                            WS_CHILD | WS_VISIBLE,
                                            0, 0, 0, 0,
                                            hWnd, (HMENU)IDCW_DRIVES,
                                            hAppInstance,
                                            NULL);

                if (!hwndDrives)
                    return -1L;

                // Don't show the new stuff if the tree window is iconic

                if (IsIconic(hWnd))
                    break;

                /* HACK!  Send SIZENOMDICRAP in the wParam of the size message.
                 * This will re-compute the sizes of all three areas of
                 * the tree window (in case the drive section grows or
                 * shrinks) and not pass it the size message on to the
                 * DefMDIChildProc() */

                GetClientRect(hWnd, &rc);
                SendMessage(hWnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));

                // refresh the tree if necessary

                if (iNewDrive >= 0) {

                    GetSelectedDirectory((WORD)(iNewDrive+1), szDir);

                    SendMessage(GetDlgItem(hWnd, IDCW_TREECONTROL),
                                TC_SETDRIVE, MAKEWORD(FALSE, 0), (LPARAM)szDir);
                }

                break;
            }

        case FS_GETSELECTION:
            {
#define pfDir            (BOOL *)lParam
                LPSTR p;

                MSG("TreeWndProc", "FS_GETSELECTION");

                GetTreeWindows(hWnd, &hwndTree, &hwndDir, &hwndDrives);
                hwndFocus = GetTreeFocus(hWnd);

                if (hwndFocus == hwndDir || !hwndTree) {
                    return SendMessage(hwndDir, FS_GETSELECTION, wParam, lParam);
                } else {
                    p = (LPSTR)LocalAlloc(LPTR, MAXPATHLEN);
                    if (p) {
                        SendMessage(hWnd, FS_GETDIRECTORY, MAXPATHLEN, (LPARAM)p);
                        StripBackslash(p);
                        CheckEscapes(p);
                        if (wParam == 2) {      // BUG ??? wParam should be fMostRecentOnly
                            if (pfDir) {
                                *pfDir = IsLFN(p);
                            }
                            LocalFree((HANDLE)p);
                            return (INT_PTR)p;
                        }
                    }
                    if (pfDir) {
                        *pfDir = TRUE;
                    }
                    return (INT_PTR)p;
                }
#undef pfDir
            }

        case FS_GETDIRECTORY:
            MSG("TreeWndProc", "FS_GETDIRECTORY");

            // wParam is the length of the string pointed to by lParam
            // returns in lParam ANSI directory string with
            // a trailing backslash.  if you want to do a SetCurrentDirecotor()
            // you must first StripBackslash() the thing!

            GetMDIWindowText(hWnd, (LPSTR)lParam, (INT)wParam);        // get the string
            StripFilespec((LPSTR)lParam);        // Remove the trailing extention
            AddBackslash((LPSTR)lParam);        // terminate with a backslash
            break;


        case FS_GETFILESPEC:
            MSG("TreeWndProc", "FS_GETFILESPEC");
            // returns the current filespec (from View.Include...).  this is
            // an uppercase ANSI string

            GetMDIWindowText(hWnd, (LPSTR)lParam, (INT)wParam);
            StripPath((LPSTR)lParam);
            break;

            // redirect these messages to the drive icons to get the same result as
            // dropping on the active drive.
            // this is especially useful when we are minimized

        case WM_DRAGSELECT:
        case WM_QUERYDROPOBJECT:
        case WM_DROPOBJECT:
            MSG("TreeWndProc", "WM..OBJECT");

            // Do nothing
            return(TRUE);

            if (hwndDrives = HasDrivesWindow(hWnd)) {
                return SendMessage(hwndDrives, wMsg, wParam, lParam);
            }

            if (hwndDir = HasDirWindow(hWnd)) {
                return SendMessage(hwndDir, wMsg, wParam, lParam);
            }

            break;

        case FS_GETDRIVE:
            MSG("TreeWndProc", "FS_GETDRIVE");

            GetTreeWindows(hWnd, &hwndTree, &hwndDir, NULL);

            if (hwndTree)
                return SendMessage(hwndTree, wMsg, wParam, lParam);
            else
                return SendMessage(hwndDir, wMsg, wParam, lParam);

            break;

        case WM_CREATE:
            TRACE(BF_WM_CREATE, "TreeWndProc - WM_CREATE");
            {
                INT dxSplit;
                WORD wDrive;

                // lpcs->lpszName is the path we are opening the
                // window for (has extension stuff "*.*")

#define lpcs ((LPCREATESTRUCT)lParam)
#define lpmdics ((LPMDICREATESTRUCT)(lpcs->lpCreateParams))

                wDrive = lpcs->lpszName[0];

                if (wDrive >= 'a')
                    wDrive -= 'a';
                else
                    wDrive -= 'A';

                SetWindowLong(hWnd, GWL_TYPE, wDrive);

                dxSplit = (SHORT)LOWORD(lpmdics->lParam);

                // if dxSplit is negative we split in the middle

                if (dxSplit < 0)
                    dxSplit = lpcs->cx / 2;

                SetWindowLong(hWnd, GWL_SPLIT, dxSplit);
                SetWindowLongPtr(hWnd, GWLP_LASTFOCUS, 0);
                SetWindowLong(hWnd, GWL_FSCFLAG, FALSE);

                if (!ResizeSplit(hWnd, dxSplit))
                    return -1;

                GetTreeWindows(hWnd, &hwndTree, &hwndDir, NULL);

                SetWindowLongPtr(hWnd, GWLP_LASTFOCUS, (LONG_PTR)(hwndTree ? hwndTree : hwndDir));

                break;
            }


        case WM_CLOSE:
            MSG("TreeWndProc", "WM_CLOSE");

            // don't allow the last MDI child to be closed!

            if (hwndTree = HasTreeWindow(hWnd)) {
                // don't close if we are reading the tree
                if (GetWindowLong(hwndTree, GWL_READLEVEL))
                    break;
            }

            // don't leve current dir on floppies
            GetSystemDirectory(szDir, sizeof(szDir));
            SheSetCurDrive(DRIVEID(szDir));

            if (!IsLastWindow())
                goto DEF_MDI_PROC;      // this will close this window

            break;

        case WM_MDIACTIVATE:
            MSG("TreeWndProc", "WM_MDIACTIVATE");
            if (GET_WM_MDIACTIVATE_FACTIVATE(hWnd, wParam, lParam)) {           // we are receiving the activation

                lFreeSpace = -1L;
                UpdateStatus(hWnd);

                hwndFocus = (HWND)GetWindowLongPtr(hWnd, GWLP_LASTFOCUS);
                SetFocus(hwndFocus);
            } else if (hwndDrives = HasDrivesWindow(hWnd))
                SendMessage(hwndDrives,wMsg,wParam,lParam);
            break;

        case WM_SETFOCUS:
            MSG("TreeWndProc", "WM_SETFOCUS");

            hwndFocus = (HWND)GetWindowLongPtr(hWnd, GWLP_LASTFOCUS);
            SetFocus(hwndFocus);
            break;

        case WM_INITMENUPOPUP:
            MSG("TreeWndProc", "WM_INITMENUPOPUP");
            if (HIWORD(lParam)) {
                EnableMenuItem((HMENU)wParam, SC_CLOSE,
                               IsLastWindow() ? MF_BYCOMMAND | MF_DISABLED | MF_GRAYED :
                               MF_ENABLED);
            }
            break;


        case WM_SYSCOMMAND:
            MSG("TreeWndProc", "WM_SYSCOMMAND");

            if (wParam != SC_SPLIT)
                goto DEF_MDI_PROC;

            GetClientRect(hWnd, &rc);

            lParam = MAKELONG(rc.right / 2, 0);

            // fall through

        case WM_LBUTTONDOWN:
            MSG("TreeWndProc", "WM_LBUTTONDOWN");
            {
                MSG msg;
                INT x, y, dx, dy;

                if (IsIconic(hWnd))
                    break;

                if (hwndDrives = GetDlgItem(hWnd, IDCW_DRIVES)) {
                    GetClientRect(hwndDrives, &rc);
                    y = rc.bottom;
                } else {
                    y = 0;
                }

                x = LOWORD(lParam);

                GetClientRect(hWnd, &rc);

                dx = 4;
                dy = rc.bottom - y;   // the height of the client less the drives window

                hdc = GetDC(hWnd);

                // split bar loop

                PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);

                SetCapture(hWnd);

                while (GetMessage(&msg, NULL, 0, 0)) {

                    if (msg.message == WM_KEYDOWN || msg.message == WM_SYSKEYDOWN ||
                        (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST)) {

                        if (msg.message == WM_LBUTTONUP || msg.message == WM_LBUTTONDOWN)
                            break;

                        if (msg.message == WM_KEYDOWN) {

                            if (msg.wParam == VK_LEFT) {
                                msg.message = WM_MOUSEMOVE;
                                msg.pt.x -= 2;
                            } else if (msg.wParam == VK_RIGHT) {
                                msg.message = WM_MOUSEMOVE;
                                msg.pt.x += 2;
                            } else if (msg.wParam == VK_RETURN ||
                                       msg.wParam == VK_ESCAPE) {
                                break;
                            }

                            SetCursorPos(msg.pt.x, msg.pt.y);
                        }

                        if (msg.message == WM_MOUSEMOVE) {

                            // erase old

                            PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                            ScreenToClient(hWnd, &msg.pt);
                            x = msg.pt.x;

                            // put down new

                            PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                        }
                    } else {
                        DispatchMessage(&msg);
                    }
                }
                ReleaseCapture();

                // erase old

                PatBlt(hdc, x - dx / 2, y, dx, dy, PATINVERT);
                ReleaseDC(hWnd, hdc);

                if (msg.wParam != VK_ESCAPE) {
                    if (ResizeSplit(hWnd, x))
                        SendMessage(hWnd, WM_SIZE, SIZENOMDICRAP, MAKELONG(rc.right, rc.bottom));
                }

                break;
            }

        case WM_QUERYDRAGICON:
            MSG("TreeWndProc", "WM_QUERYDRAGICON");
            return (INT_PTR)GetTreeIcon(hWnd);
            break;

        case WM_ERASEBKGND:
            MSG("TreeWndProc", "WM_ERASEBKGND");

            if (IsIconic(hWnd)) {
                // this paints the background of the icon properly, doing
                // brush allignment and other nasty stuff

                DefWindowProc(hWnd, WM_ICONERASEBKGND, wParam, 0L);
            } else {
                goto DEF_MDI_PROC;
            }
            break;

        case WM_PAINT:
            MSG("TreeWndProc", "WM_PAINT");
            {
                PAINTSTRUCT ps;

                hdc = BeginPaint(hWnd, &ps);


                if (IsIconic(hWnd)) {
                    DrawIcon(hdc, 0, 0, GetTreeIcon(hWnd));
                } else {
                    RECT rc2;

                    GetClientRect(hWnd, &rc);
                    rc.left = GetSplit(hWnd);

                    if (rc.left >= rc.right)
                        rc.left = 0;

                    rc.right = rc.left + dxFrame;

                    GetClientRect(HasDrivesWindow(hWnd), &rc2);

                    rc2.top = rc2.bottom;
                    rc2.bottom += dyBorder;
                    rc2.left = rc.left;
                    rc2.right = rc.right;
                    FillRect(hdc, &rc2, GetStockObject(BLACK_BRUSH));

                    // draw the black pane handle

                    rc.top = rc.bottom - GetSystemMetrics(SM_CYHSCROLL);
                    FillRect(hdc, &rc, GetStockObject(BLACK_BRUSH));
                }

                EndPaint(hWnd, &ps);
                break;
            }


        case WM_SIZE:
            if (wParam != SIZEICONIC)
                ResizeWindows(hWnd,LOWORD(lParam),HIWORD(lParam));

            // if wParam is SIZENOMDICRAP this WM_SIZE was generated by us.
            // don't let this through to the DefMDIChildProc().
            // that might change the min/max state, (show parameter)
            if (wParam == SIZENOMDICRAP)
                break;
            /*** FALL THRU ***/

        default:

            DEF_MDI_PROC:

            return DefMDIChildProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}


VOID
ResizeWindows(
             HWND hwndParent,
             WORD dxWindow,
             WORD dyWindow
             )
{
    INT dy, split;
    INT cDriveRows, cDrivesPerRow;
    DWORD dw;
    HWND hwndTree,hwndDir,hwndDrives;

    GetTreeWindows(hwndParent, &hwndTree, &hwndDir, &hwndDrives);

    split = GetSplit(hwndParent);

    // user has been fixed to do this right

    dy = dyWindow + dyBorder;

    if (hwndTree) {
        if (!hwndDir)
            MoveWindow(hwndTree, dxFrame, 0, dxWindow - dxFrame + dyBorder, dy, TRUE);
        else
            MoveWindow(hwndTree, -dyBorder, 0, split + dyBorder, dy, TRUE);
    }

    if (hwndDir) {
        if (!hwndTree)
            MoveWindow(hwndDir, dxFrame, 0, dxWindow - dxFrame + dyBorder, dy, TRUE);
        else
            MoveWindow(hwndDir, split + dxFrame, 0,
                       dxWindow - split - dxFrame + dyBorder, dy, TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\winfile.h ===
/****************************************************************************/
/*                                                                          */
/*  WINFILE.H -                                                             */
/*                                                                          */
/*  Include for WINFILE program                                             */
/*                                                                          */
/****************************************************************************/

#define NOCOMM
#define WIN31

#include <windows.h>
#include <port1632.h>
#include <winuserp.h>
#include <setjmp.h>
#include <string.h>
#include <memory.h>
#include <shellapi.h>
#include <shlapip.h>
#include "wfext.h"
#include "wfhelp.h"
#include "dbg.h"

#undef CheckEscapes

#define DwordAlign(cb)      ((cb + 3) & ~3)

typedef HWND NEAR *PHWND;

#define SIZENOMDICRAP       944

#define MAXDOSFILENAMELEN   12+1            // includes the NULL
#define MAXDOSPATHLEN       (68+MAXDOSFILENAMELEN)  // includes the NULL

#define MAXLFNFILENAMELEN   260
#define MAXLFNPATHLEN       260

#define MAXFILENAMELEN      MAXLFNFILENAMELEN
#define MAXPATHLEN          MAXLFNPATHLEN

#define MAXTITLELEN         32
#define MAXMESSAGELEN       (50 + MAXFILENAMELEN * 2)

#include "wfdisk.h"

// struct for volume info

#define MAX_VOLNAME             12
#define MAX_FILESYSNAME         12

typedef struct _VOLINFO {
    DWORD     dwVolumeSerialNumber;
    DWORD     dwMaximumComponentLength;
    DWORD     dwFileSystemFlags;
    DWORD     dwDriveType;
    CHAR      szVolumeName[MAX_VOLNAME];
    CHAR      szFileSysName[MAX_FILESYSNAME];
} VOLINFO;


/*--------------------------------------------------------------------------*/
/*                                      */
/*  Function Templates                              */
/*                                      */
/*--------------------------------------------------------------------------*/

BOOL   APIENTRY FileCDR(FARPROC);
VOID   APIENTRY KernelChangeFileSystem(LPSTR,WORD);

/* WFDOSDIR.ASM */
DWORD  APIENTRY GetExtendedError(VOID);
VOID   APIENTRY DosGetDTAAddress(VOID);
VOID   APIENTRY DosResetDTAAddress(VOID);
BOOL   APIENTRY DosFindFirst(LPDOSDTA, LPSTR, WORD);
BOOL   APIENTRY DosFindNext(LPDOSDTA);
BOOL   APIENTRY DosDelete(LPSTR);
INT    APIENTRY GetCurrentVolume(LPSTR);
INT    APIENTRY UpdateDriveList(VOID);
WORD   APIENTRY GetFirstCDROMDrive(VOID);
// WORD   APIENTRY GetFileAttributes(LPSTR);
// WORD   APIENTRY SetFileAttributes(LPSTR, WORD);
DWORD  APIENTRY GetFreeDiskSpace(WORD);
DWORD  APIENTRY GetTotalDiskSpace(WORD);
INT    APIENTRY ChangeVolumeLabel(INT, LPSTR);
INT    APIENTRY GetVolumeLabel(INT, LPSTR, BOOL);
INT    APIENTRY DeleteVolumeLabel(INT);
INT    APIENTRY CreateVolumeFile(LPSTR);
INT    APIENTRY CreateVolumeLabel(INT, LPSTR);
INT    APIENTRY MySetVolumeLabel(INT, BOOL, LPSTR);

INT    APIENTRY WF_CreateDirectory(HWND, LPSTR);
WORD   APIENTRY FileCopy(LPSTR szSource, LPSTR szDest);

/* WFDISK.C */
DWORD  APIENTRY LongShift(DWORD dwValue, WORD wCount);
VOID   APIENTRY SetDASD(WORD, BYTE);
LPDBT  APIENTRY GetDBT(VOID);
HANDLE  APIENTRY BuildDevPB(PDevPB);
VOID   APIENTRY DiskReset(VOID);
WORD   APIENTRY GetDPB(WORD, PDPB);
VOID   APIENTRY SetDPB(WORD, PBPB, PDPB);
INT    APIENTRY ModifyDPB(WORD);
INT    APIENTRY MyInt25(WORD, LPSTR, WORD, WORD);
INT    APIENTRY MyReadWriteSector(LPSTR, WORD, WORD, WORD, WORD, WORD);
INT    APIENTRY GenericReadWriteSector(LPSTR, WORD, WORD, WORD, WORD, WORD);
VOID   APIENTRY lStrucCopy(LPSTR, LPSTR, WORD);
INT    APIENTRY FormatTrackHead(WORD, WORD, WORD, WORD, LPSTR);
INT    APIENTRY GenericFormatTrack(WORD, WORD, WORD, WORD, LPSTR);
INT    APIENTRY MyGetDriveType(WORD);
INT    APIENTRY WriteBootSector(WORD, WORD, PBPB, LPSTR);
WORD   APIENTRY GetDriveCapacity(WORD);
DWORD  APIENTRY DreamUpSerialNumber(VOID);
DWORD  APIENTRY GetClusterInfo(WORD);
DWORD  APIENTRY ReadSerialNumber(INT, LPSTR);
INT    APIENTRY ModifyVolLabelInBootSec(INT, LPSTR, DWORD, LPSTR);
LPSTR  GetRootPath(WORD wDrive);

/* WFUTIL.C */
INT  APIENTRY GetBootDisk(VOID);
VOID  APIENTRY FixAnsiPathForDos(LPSTR szPath);
VOID  APIENTRY RefreshWindow(HWND hwndActive);
BOOL  APIENTRY IsLastWindow(VOID);
//LPSTR  APIENTRY AddCommas(LPSTR szBuf, DWORD dw);
VOID  APIENTRY GetVolShare(WORD wDrive, LPSTR szVolShare);
VOID  APIENTRY InvalidateChildWindows(HWND hwnd);
BOOL  APIENTRY IsValidDisk(INT iDrive);
LPSTR  APIENTRY GetSelection(INT iSelType);
LPSTR  APIENTRY GetNextFile(LPSTR pCurSel, LPSTR szFile, INT size);
VOID  APIENTRY SetWindowDirectory(VOID);
VOID  APIENTRY SetDlgDirectory(HWND hDlg, PSTR pszPath);
VOID  APIENTRY WritePrivateProfileBool(LPSTR szKey, BOOL bParam);
VOID  APIENTRY WritePrivateProfileInt(LPSTR szKey, INT wParam);
BOOL  APIENTRY IsWild(LPSTR lpszPath);
VOID  APIENTRY AddBackslash(LPSTR lpszPath);
VOID  APIENTRY StripBackslash(LPSTR lpszPath);
VOID  APIENTRY StripFilespec(LPSTR lpszPath);
VOID  APIENTRY StripPath(LPSTR lpszPath);
LPSTR  APIENTRY GetExtension(LPSTR pszFile);
BOOL  APIENTRY FindExtensionInList(LPSTR pszExt, LPSTR pszList);
INT   APIENTRY MyMessageBox(HWND hWnd, WORD idTitle, WORD idMessage, WORD wStyle);
WORD  APIENTRY ExecProgram(LPSTR,LPSTR,LPSTR,BOOL);
BOOL  APIENTRY IsProgramFile(LPSTR lpszPath);
BOOL  APIENTRY IsDocument(LPSTR lpszPath);
BOOL  APIENTRY IsRemovableDrive(INT);
BOOL  APIENTRY IsRemoteDrive(INT);
VOID  APIENTRY SetMDIWindowText(HWND hWnd, LPSTR szTitle);
INT   APIENTRY GetMDIWindowText(HWND hWnd, LPSTR szTitle, INT size);
BOOL  APIENTRY ResizeSplit(HWND hWnd, INT dxSplit);

/* WFDIRSRC.C */
HCURSOR  APIENTRY GetMoveCopyCursor(VOID);
VOID  APIENTRY SetLBFont(HWND hWnd, HWND hwndLB, HANDLE hFont);
VOID  APIENTRY DrawItem(LPDRAWITEMSTRUCT lpLBItem, LPSTR szLine, DWORD dwAttrib, BOOL bHilight, WORD *pTabs);
VOID  APIENTRY DSDragLoop(HWND hwndLB, WPARAM wParam, LPDROPSTRUCT lpds, BOOL bSearch);
VOID  APIENTRY DSRectItem(HWND hwndLB, INT iSel, BOOL bFocusOn, BOOL bSearch);
INT   APIENTRY DSTrackPoint(HWND hWnd, HWND hwndLB, WPARAM wParam, LPARAM lParam, BOOL bSearch);
VOID  APIENTRY DSSetSelection(HWND hwndLB, BOOL bSelect, LPSTR szSpec, BOOL bSearch);
INT   APIENTRY FixTabsAndThings(HWND hwndLB, WORD *pwTabs, INT iMaxWidthFileName, WORD wViewOpts);

VOID  APIENTRY UpdateStatus(HWND hWnd);
BOOL  APIENTRY CompactPath(HDC hdc, LPSTR szPath, WORD dx);
VOID  APIENTRY SetActiveDirectory(VOID);
VOID  APIENTRY GetInternational(VOID);
VOID  APIENTRY BuildDocumentString(VOID);
BOOL  APIENTRY LoadBitmaps(VOID);
BOOL  APIENTRY InitFileManager(HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpszCmdLine, INT nCmdShow);
VOID  APIENTRY InitDriveBitmaps(VOID);
VOID  APIENTRY InitExtensions(VOID);
VOID  APIENTRY FreeFileManager(VOID);
VOID  APIENTRY DeleteBitmaps(VOID);
BOOL  APIENTRY FormatFloppy(HWND hWnd, WORD nDestDrive, INT iCapacity, BOOL bMakeSysDisk, BOOL bQuick);
BOOL  APIENTRY HasSystemFiles(WORD iDrive);
BOOL  APIENTRY MakeSystemDiskette(WORD nDestDrive, BOOL bEmptyDisk);
INT   APIENTRY CopyDiskette(HWND hwnd, WORD nSrcDrive, WORD nDestDrive);
VOID  APIENTRY ChangeFileSystem(WORD wOper, LPSTR lpPath, LPSTR lpTo);
WORD  APIENTRY DMMoveCopyHelper(LPSTR pFrom, LPSTR pTo, BOOL bCopy);
WORD  APIENTRY WFMoveCopyDriver(LPSTR pFrom, LPSTR pTo, WORD wFunc);
WORD  APIENTRY IsTheDiskReallyThere(HWND hwnd, register LPSTR pPath, WORD wFunc);
WORD  APIENTRY WFPrint(LPSTR szFile);
VOID  APIENTRY GetSelectedDirectory(WORD iDrive, PSTR pszDir);
VOID  APIENTRY SaveDirectory(PSTR pszDir);
INT   APIENTRY GetSelectedDrive(VOID);
VOID  APIENTRY GetTextStuff(HDC hdc);
INT   APIENTRY GetHeightFromPointsString(LPSTR szPoints);

INT   APIENTRY GetDrive(HWND hwnd, POINT pt);

VOID  APIENTRY CheckSlashies(LPSTR);
VOID  APIENTRY SetSourceDir(LPDROPSTRUCT lpds); // wfdir.c
VOID  APIENTRY UpdateSelection(HWND hwndLB);
DWORD  APIENTRY GetVolShareExtent(HWND hWnd);       // wfdrives.c


BOOL  APIENTRY WFQueryAbort(VOID);

VOID  APIENTRY EnableFSC( VOID );
VOID  APIENTRY DisableFSC( VOID );

VOID  APIENTRY ResizeWindows(HWND hwndParent,WORD dxWindow, WORD dyWindow);
BOOL  APIENTRY CheckDrive(HWND hwnd, INT nDrive);
INT_PTR  APIENTRY FrameWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
BOOL     APIENTRY AppCommandProc(WORD id);
INT_PTR  APIENTRY TreeWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DriveWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DrivesWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY VolumeWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY TreeChildWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY TreeControlWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DirWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SearchWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

INT_PTR  APIENTRY DrivesDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AssociateDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SearchDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY RunDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SelectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY FontDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SuperDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AttribsDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY MakeDirDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ExitDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskLabelDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ChooseDriveDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY FormatDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY Format2DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ProgressDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskCopyDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY DiskCopy2DlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ConnectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY PreviousDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY OtherDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY SortByDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY IncludeDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY ConfirmDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR  APIENTRY AboutDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
VOID  APIENTRY SaveWindows(HWND hwndMain);
INT  APIENTRY PutDate(LPFILETIME lpftDate, LPSTR szStr);
INT  APIENTRY PutTime(LPFILETIME lpftTime, LPSTR szStr);
INT  APIENTRY PutSize(DWORD dwSize, LPSTR szOutStr);
INT  APIENTRY PutAttributes(register DWORD dwAttribute, register LPSTR szStr);
BOOL  APIENTRY CreateSavedWindows(VOID);
HWND  APIENTRY CreateDirWindow(register LPSTR szPath, BOOL bReplaceOpen, HWND hwndActive);
HWND  APIENTRY CreateTreeWindow(LPSTR szDir, INT dxSplit);
VOID  APIENTRY GetTreeWindows(HWND hwnd, PHWND phwndTree, PHWND phwndDir, PHWND hwndDrives);
HWND  APIENTRY GetTreeFocus(HWND hWnd);
VOID  APIENTRY SetTreeCase(HWND hWnd);
INT   APIENTRY GetSplit(HWND hwnd);
HWND  APIENTRY GetMDIChildFromDecendant(HWND hwnd);
INT   APIENTRY GetDrive(HWND hwnd, POINT pt);
WORD  APIENTRY IsNetDrive(INT iDrive);
WORD  APIENTRY IsCDRomDrive(INT iDrive);
BOOL  APIENTRY IsRamDrive(INT wDrive);
WORD  APIENTRY WFGetConnection(LPSTR,LPSTR,BOOL);
WORD  APIENTRY NetCheck(LPSTR,WORD);

VOID  APIENTRY InitExtensions(VOID);

VOID  APIENTRY NewTree(INT iDrive, HWND hWnd);
INT   APIENTRY FormatDiskette(HWND hwnd);
VOID  APIENTRY NewFont(VOID);
HWND  APIENTRY GetRealParent(HWND hwnd);
VOID  APIENTRY WFHelp(HWND hwnd);
LRESULT APIENTRY MessageFilter(INT nCode, WPARAM wParam, LPARAM lParam);
VOID  APIENTRY UpdateConnections(VOID);
VOID APIENTRY FillVolumeInfo(INT iVol);
WORD APIENTRY WFCopy(PSTR,PSTR);
WORD APIENTRY StartCopy(VOID);
WORD APIENTRY EndCopy(VOID);
VOID APIENTRY CopyAbort(VOID);
VOID APIENTRY QualifyPath(PSTR);
VOID APIENTRY wfYield(VOID);

LONG APIENTRY lmul(WORD w1, WORD w2);

#define DEBUGF(foo)
#define STKCHK()

#define TA_LOWERCASE    0x01
#define TA_BOLD     0x02
#define TA_ITALIC   0x04

#ifndef NO_WF_GLOBALS

/*--------------------------------------------------------------------------*/
/*                                      */
/*  Global Externs                              */
/*                                      */
/*--------------------------------------------------------------------------*/

extern BOOL bNetAdmin;
extern BOOL bMinOnRun;
extern BOOL bReplace;
extern BOOL bStatusBar;
extern BOOL bConfirmDelete;
extern BOOL bConfirmSubDel;
extern BOOL bConfirmReplace;
extern BOOL bConfirmMouse;
extern BOOL bConfirmFormat;
extern BOOL bSaveSettings;
extern BOOL bSearchSubs;
extern BOOL bUserAbort;
extern BOOL bConnect;
extern BOOL bDisconnect;
extern BOOL bFileSysChanging;
extern BOOL fShowSourceBitmaps;
extern BOOL bMultiple;
extern BOOL bFSCTimerSet;
extern BOOL bSaveSettings;


extern CHAR chFirstDrive;

extern CHAR szExtensions[];
extern CHAR szFrameClass[];
extern CHAR szTreeClass[];
extern CHAR szDriveClass[];
extern CHAR szDrivesClass[];
extern CHAR szVolumeClass[];
extern CHAR szTreeChildClass[];
extern CHAR szTreeControlClass[];
extern CHAR szDirClass[];
extern CHAR szSearchClass[];

extern CHAR szSaveSettings[];
extern CHAR szMinOnRun[];
extern CHAR szReplace[];
extern CHAR szLowerCase[];
extern CHAR szStatusBar[];
extern CHAR szCurrentView[];
extern CHAR szCurrentSort[];
extern CHAR szCurrentAttribs[];
extern CHAR szConfirmDelete[];
extern CHAR szConfirmSubDel[];
extern CHAR szConfirmReplace[];
extern CHAR szConfirmMouse[];
extern CHAR szConfirmFormat[];
extern CHAR szTreeKey[];
extern CHAR szDirKeyFormat[];
extern CHAR szWindow[];

extern CHAR szDefPrograms[];
extern CHAR szINIFile[];
extern CHAR szWindows[];
extern CHAR szPrevious[];
extern CHAR szSettings[];
extern CHAR szInternational[];
extern CHAR szStarDotStar[];
extern CHAR szNULL[];
extern CHAR szBlank[];
extern CHAR szEllipses[];
extern CHAR szReservedMarker[];
extern CHAR szNetwork[];

extern CHAR szDirsRead[32];
extern CHAR szCurrentFileSpec[];
extern CHAR szShortDate[];
extern CHAR szTime[];
extern CHAR sz1159[];
extern CHAR sz2359[];
extern CHAR szComma[2];
extern CHAR szDated[];
extern CHAR szListbox[];
extern CHAR szWith[];

extern CHAR szTheINIFile[64+12+3];
extern CHAR szTitle[128];
extern CHAR szMessage[MAXMESSAGELEN+1];
extern CHAR szSearch[MAXPATHLEN+1];
extern CHAR szStatusTree[80];
extern CHAR szStatusDir[80];
extern CHAR szOriginalDirPath[64+12+3];
extern CHAR szFace[];
extern CHAR szSize[];
extern CHAR     szAddons[];
extern CHAR     szUndelete[];
extern CHAR szWinObjHelp[];
extern CHAR szSaveSettings[];
extern CHAR     szBytes[10];
extern CHAR     szSBytes[10];

extern INT  cKids;
extern INT  cDrives;
extern INT  dxDrive;
extern INT  dyDrive;
extern INT  dxDriveBitmap;
extern INT  dyDriveBitmap;
extern INT  dxEllipses;
extern INT  dxBraces;
extern INT  dxFolder;
extern INT  dyFolder;
extern INT  dyBorder;       /* System Border Width/Height       */
extern INT  dyBorderx2;     /* System Border Width/Height * 2   */
extern INT  dyStatus;       /* Status Bar height            */
extern INT  dxStatusField;
extern INT  dxText;         /* System Font Width 'M'        */
extern INT  dyText;         /* System Font Height           */
extern INT  dxFileName;
extern INT  dyFileName;
extern INT  dxFileDetails;
extern INT  iFormatDrive;       /* Logical # of the drive to format */
extern INT  iCurrentDrive;      /* Logical # of the drive to format */
extern INT  nFloppies;      /* Number of Removable Drives       */
extern INT  rgiDrive[26];
extern INT  rgiDriveType[26];
extern VOLINFO *(apVolInfo[26]);
extern INT  rgiInt13Drive[26];
extern INT  rgiDrivesOffset[26];
extern INT  idViewChecked;
extern INT  idSortChecked;
extern INT  defTabStops[];
extern INT  iSelHilite;
extern INT  iTime;
extern INT  iTLZero;
extern INT  cDisableFSC;
extern INT  iReadLevel;
extern INT  dxFrame;
extern INT  dyTitle;
extern INT  dxClickRect;
extern INT  dyClickRect;

extern HANDLE   hAccel;
extern HANDLE   hAppInstance;

extern HBITMAP  hbmBitmaps;
extern HDC  hdcMem;

extern INT  iCurDrag;
extern HICON    hicoTree;
extern HICON    hicoTreeDir;
extern HICON    hicoDir;

extern HWND hdlgProgress;
extern HWND hwndFrame;
extern HWND hwndLastActiveDir;
extern HWND hwndMDIClient;
extern HWND hwndSearch;
extern HWND hwndDragging;       /* source window of DM */

extern LPSTR szPrograms;
extern LPSTR szDocuments;

extern WORD wTextAttribs;
extern WORD wSuperDlgMode;
extern WORD wCDROMIndex;
extern WORD wDOSversion;
extern UINT wHelpMessage;
extern UINT wBrowseMessage;

extern WORD wNewView;
extern WORD wNewSort;
extern DWORD dwNewAttribs;
extern WORD xTreeMax;

extern LONG lFreeSpace;
extern LONG lTotalSpace;

extern BOOL bPaintBackground;
extern BOOL bCancelTree;

extern HFONT hFont;
extern HFONT hFontStatus;

extern EXTENSION extensions[MAX_EXTENSIONS];
extern INT iDeltaStart;
extern INT iNumExtensions;
extern DWORD ( APIENTRY *lpfpUndelete)(HWND, LPSTR);

extern HHOOK hhkMessageFilter;
extern DWORD dwContext;
extern HANDLE hModUndelete;
extern WORD fFormatFlags;
extern WORD nLastDriveInd;

#endif // ndef NO_WF_GLOBALS

/*--------------------------------------------------------------------------*/
/*                                      */
/*  Defines                                 */
/*                                      */
/*--------------------------------------------------------------------------*/

#define TABCHAR             '\t'

#define DO_LISTOFFILES      1L

#define WS_MDISTYLE (WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_SYSMENU | WS_CAPTION | WS_THICKFRAME | WS_MAXIMIZEBOX)
#define WS_DIRSTYLE (WS_CHILD | LBS_SORT | LBS_NOTIFY | LBS_OWNERDRAWFIXED | LBS_EXTENDEDSEL | LBS_NOINTEGRALHEIGHT | LBS_WANTKEYBOARDINPUT)
#define WS_SEARCHSTYLE  (WS_DIRSTYLE | LBS_HASSTRINGS | WS_VSCROLL)


/* Extra Window Word Offsets */

// szTreeClass & szSearchClass common..

#define GWL_TYPE            0   // > 0 Tree, -1 = search
#define GWL_VIEW            4
#define GWL_SORT            8
#define GWL_ATTRIBS         12
#define GWL_FSCFLAG         16

// szTreeClass only...

#define GWLP_LASTFOCUS       20
#define GWL_SPLIT           24

// szSearchClass only...

#define GWLP_HDTASEARCH      20
#define GWLP_TABARRAYSEARCH  24  // on                   szSearchClass
#define GWLP_LASTFOCUSSEARCH 28  // on                   szSearchClass

// szDirClass...

#define GWLP_HDTA            0
#define GWLP_TABARRAY        4

// szDrivesClass...

#define GWL_CURDRIVEIND     0   // current selection in drives window
#define GWL_CURDRIVEFOCUS   4   // current focus in drives window
#define GWLP_LPSTRVOLUME     8   // LPSTR to Volume/Share string

// szTreeControlClass

#define GWL_READLEVEL       0   // iReadLevel for each tree control window



// GWL_TYPE numbers

#define TYPE_TREE           0   // and all positive numbers (drive number)
#define TYPE_SEARCH         -1


/* WM_FILESYSCHANGE message wParam value */
#define FSC_CREATE          0
#define FSC_DELETE          1
#define FSC_RENAME          2
#define FSC_ATTRIBUTES      3
#define FSC_NETCONNECT      4
#define FSC_NETDISCONNECT   5
#define FSC_REFRESH         6
#define FSC_MKDIR           7
#define FSC_RMDIR           8

#define WM_LBTRACKPT        0x131

#define TC_SETDRIVE         0x944
#define TC_GETCURDIR        0x945
#define TC_EXPANDLEVEL      0x946
#define TC_COLLAPSELEVEL    0x947
#define TC_GETDIR           0x948
#define TC_SETDIRECTORY     0x949
#define TC_TOGGLELEVEL      0x950

#define FS_CHANGEDISPLAY    (WM_USER+0x100)
#define FS_CHANGEDRIVES     (WM_USER+0x101)
#define FS_GETSELECTION     (WM_USER+0x102)
#define FS_GETDIRECTORY     (WM_USER+0x103)
#define FS_GETDRIVE         (WM_USER+0x104)
#define WM_OWNERDRAWBEGIN   (WM_USER+0x105)
#define WM_OWNERDRAWEND     (WM_USER+0x106)
#define FS_SETDRIVE         (WM_USER+0x107)
#define FS_GETFILESPEC      (WM_USER+0x108)
#define FS_SETSELECTION     (WM_USER+0x109)

#define ATTR_READWRITE      0x0000
#define ATTR_READONLY       FILE_ATTRIBUTE_READONLY     // == 0x0001
#define ATTR_HIDDEN         FILE_ATTRIBUTE_HIDDEN       // == 0x0002
#define ATTR_SYSTEM         FILE_ATTRIBUTE_SYSTEM       // == 0x0004
#define ATTR_VOLUME         0x0008
#define ATTR_DIR            FILE_ATTRIBUTE_DIRECTORY    // == 0x0010
#define ATTR_ARCHIVE        FILE_ATTRIBUTE_ARCHIVE      // == 0x0020
#define ATTR_NORMAL         FILE_ATTRIBUTE_NORMAL       // == 0x0080
#define ATTR_PARENT         0x0040  // my hack DTA bits
#define ATTR_LFN            0x1000  // my hack DTA bits
#define ATTR_RWA            (ATTR_READWRITE | ATTR_ARCHIVE)
#define ATTR_ALL            (ATTR_READONLY | ATTR_HIDDEN | ATTR_SYSTEM | ATTR_DIR | ATTR_ARCHIVE | ATTR_NORMAL)
#define ATTR_PROGRAMS       0x0100
#define ATTR_DOCS           0x0200
#define ATTR_OTHER          0x0400
#define ATTR_EVERYTHING     (ATTR_ALL | ATTR_PROGRAMS | ATTR_DOCS | ATTR_OTHER | ATTR_PARENT)
#define ATTR_DEFAULT        (ATTR_EVERYTHING & ~(ATTR_HIDDEN | ATTR_SYSTEM))
#define ATTR_HS             (ATTR_HIDDEN | ATTR_SYSTEM)

#define ATTR_TYPES          0x00ff0000
#define ATTR_SYMLINK        0x00010000
#define ATTR_ADAPTER        0x00020000
#define ATTR_CONTROLLER     0x00030000
#define ATTR_DEVICE         0x00040000
#define ATTR_DRIVER         0x00050000
#define ATTR_EVENT          0x00060000
#define ATTR_EVENTPAIR      0x00070000
#define ATTR_FILE           0x00080000
#define ATTR_MUTANT         0x00090000
#define ATTR_PORT           0x000a0000
#define ATTR_PROFILE        0x000b0000
#define ATTR_SECTION        0x000c0000
#define ATTR_SEMAPHORE      0x000d0000
#define ATTR_TIMER          0x000e0000
#define ATTR_TYPE           0x000f0000
#define ATTR_PROCESS        0x00100000

#define ATTR_USED           (0x00BF | ATTR_TYPES)

#define ATTR_RETURNED       0x2000  /* used in DTA's by copy */

#define CD_PATH             0x0001
#define CD_VIEW             0x0002
#define CD_SORT             0x0003
#define CD_PATH_FORCE       0x0004
#define CD_SEARCHUPDATE     0x0005
#define CD_ALLOWABORT       0x8000

#define VIEW_NAMEONLY       0x0000
#define VIEW_UPPERCASE      0x0001
#define VIEW_SIZE           0x0002
#define VIEW_DATE           0x0004
#define VIEW_TIME           0x0008
#define VIEW_FLAGS          0x0010
#define VIEW_PLUSES         0x0020
#define VIEW_EVERYTHING     (VIEW_SIZE | VIEW_TIME | VIEW_DATE | VIEW_FLAGS)

#define CBSECTORSIZE        512

#define INT13_READ          2
#define INT13_WRITE         3

#define ERR_USER            0xF000

/* Child Window IDs */
#define IDCW_DRIVES         1
#define IDCW_DIR            2
#define IDCW_TREELISTBOX    3
#define IDCW_TREECONTROL    5
#define IDCW_LISTBOX        6   // list in search


#define HasDirWindow(hwnd)      GetDlgItem(hwnd, IDCW_DIR)
#define HasTreeWindow(hwnd)     GetDlgItem(hwnd, IDCW_TREECONTROL)
#define HasDrivesWindow(hwnd)   GetDlgItem(hwnd, IDCW_DRIVES)
#define GetSplit(hwnd)          ((int)GetWindowLong(hwnd, GWL_SPLIT))


/* Menu Command Defines */
#define IDM_FILE            0
#define IDM_OPEN            101
#define IDM_PRINT           102
#define IDM_ASSOCIATE       103
#define IDM_SEARCH          104
#define IDM_RUN             105
#define IDM_MOVE            106
#define IDM_COPY            107
#define IDM_DELETE          108
#define IDM_RENAME          109
#define IDM_ATTRIBS         110
#define IDM_MAKEDIR         111
#define IDM_SELALL          112
#define IDM_DESELALL        113
#define IDM_UNDO            114
#define IDM_EXIT            115
#define IDM_SELECT          116
#define IDM_UNDELETE        117
#define IDM_DISK            7
#define IDM_DISKCOPY        801
#define IDM_LABEL           802
#define IDM_FORMAT          803
#define IDM_SYSDISK         804
#define IDM_CONNECT         805
#define IDM_DISCONNECT      806
#define IDM_DRIVESMORE      851
#define IDM_CONNECTIONS     852
#define IDM_TREE            1
#define IDM_EXPONE          201
#define IDM_EXPSUB          202
#define IDM_EXPALL          203
#define IDM_COLLAPSE        204
#define IDM_NEWTREE         205
#define IDM_VIEW            2
#define IDM_VNAME           301
#define IDM_VDETAILS        302
#define IDM_VOTHER          303

#define IDM_BYNAME          304
#define IDM_BYTYPE          305
#define IDM_BYSIZE          306
#define IDM_BYDATE          307

#define IDM_VINCLUDE        309
#define IDM_REPLACE         310

#define IDM_TREEONLY        311
#define IDM_DIRONLY         312
#define IDM_BOTH            313
#define IDM_SPLIT           314

#define IDM_OPTIONS         3
#define IDM_CONFIRM         401
#define IDM_LOWERCASE       402
#define IDM_STATUSBAR       403
#define IDM_MINONRUN        404
#define IDM_ADDPLUSES       405
#define IDM_EXPANDTREE      406
#define IDM_FONT            410
#define IDM_SAVESETTINGS    411

#define IDM_EXTENSIONS      5

#define IDM_WINDOW          10      // IDM_EXTENSIONS + MAX_EXTENSIONS
#define IDM_CASCADE         1001
#define IDM_TILE            1002
#define IDM_REFRESH         1003
#define IDM_ARRANGE         1004
#define IDM_NEWWINDOW       1005
#define IDM_CHILDSTART      1006

#define IDM_HELP            11      // IDM_WINDOW + 1
#define IDM_HELPINDEX       1101
#define IDM_HELPKEYS        0x001E
#define IDM_HELPCOMMANDS    0x0020
#define IDM_HELPPROCS       0x0021
#define IDM_HELPHELP        1102
#define IDM_ABOUT           1103

#define BITMAPS             100
#define FILES_WIDTH         16
#define FILES_HEIGHT        16
#define DRIVES_WIDTH        27
#define DRIVES_HEIGHT       14

#define APPICON             200
#define TREEICON            201
#define DIRICON             202
#define WINDOWSICON         203
#define TREEDIRICON         204

#define SINGLEMOVECURSOR    300 // move is even
#define MULTMOVECURSOR      302
#define SINGLECOPYCURSOR    301 // copy is odd
#define MULTCOPYCURSOR      303

#define APPCURSOR           300
#define DIRCURSOR           301
#define DOCCURSOR           302
#define FILECURSOR          304
#define FILESCURSOR         305
#define SPLITCURSOR         306

#define APPCURSORC          310
#define DIRCURSORC          311
#define DOCCURSORC          312
#define FILECURSORC         314
#define FILESCURSORC        315

#define WFACCELTABLE        400

#define FRAMEMENU           500

/* Indexes into the mondo bitmap */
#define BM_IND_APP          0
#define BM_IND_DOC          1
#define BM_IND_FIL          2
#define BM_IND_RO           3
#define BM_IND_DIRUP        4
#define BM_IND_CLOSE        5
#define BM_IND_CLOSEPLUS    6
#define BM_IND_OPEN         7
#define BM_IND_OPENPLUS     8
#define BM_IND_OPENMINUS    9
#define BM_IND_CLOSEMINUS   10
#define BM_IND_CLOSEDFS     11
#define BM_IND_OPENDFS      12
#define BM_IND_TYPEBASE     13

#define IDS_ENDSESSION      40  /* Must be > 32 */
#define IDS_ENDSESSIONMSG   41
#define IDS_COPYDISK        50
#define IDS_INSERTDEST      51
#define IDS_INSERTSRC       52
#define IDS_INSERTSRCDEST   53
#define IDS_FORMATTINGDEST  54
#define IDS_COPYDISKERR     55
#define IDS_COPYDISKERRMSG  56
#define IDS_COPYDISKSELMSG  57
#define IDS_COPYSRCDESTINCOMPAT 58
#define IDS_PERCENTCOMP     60
#define IDS_CREATEROOT      61
#define IDS_COPYSYSFILES    62
#define IDS_FORMATERR       63
#define IDS_FORMATERRMSG    64
//#define IDS_FORMATCURERR    65
#define IDS_FORMATCOMPLETE  66
#define IDS_FORMATANOTHER   67
#define IDS_FORMATCANCELLED 68
#define IDS_SYSDISK         70
#define IDS_SYSDISKRUSURE   71
#define IDS_SYSDISKERR      72
#define IDS_SYSDISKNOFILES  73
#define IDS_SYSDISKSAMEDRIVE    74
#define IDS_SYSDISKADDERR   75
#define IDS_NETERR          80
#define IDS_NETCONERRMSG    81
#define IDS_NETDISCONCURERR 82
#define IDS_NETDISCONWINERR 83
#define IDS_NETDISCON       84
#define IDS_NETDISCONRUSURE 85
#define IDS_NETDISCONERRMSG 86
#define IDS_FILESYSERR      90
#define IDS_ATTRIBERR       91
#define IDS_MAKEDIRERR      92
#define IDS_LABELDISKERR    93
#define IDS_SEARCHERR       94
#define IDS_SEARCHNOMATCHES 95
#define IDS_MAKEDIREXISTS   96
#define IDS_SEARCHREFRESH   97
#define IDS_ASSOCFILE       100
#define IDS_DRIVETEMP       101
#define IDS_EXECERRTITLE    110
#define IDS_UNKNOWNMSG      111
#define IDS_NOMEMORYMSG     112
#define IDS_FILENOTFOUNDMSG 113
#define IDS_BADPATHMSG      114
#define IDS_MANYOPENFILESMSG    115
#define IDS_NOASSOCMSG      116
#define IDS_MULTIPLEDSMSG   117
#define IDS_ASSOCINCOMPLETE 118
#define IDS_MOUSECONFIRM    120
#define IDS_COPYMOUSECONFIRM    121
#define IDS_MOVEMOUSECONFIRM    122
#define IDS_EXECMOUSECONFIRM    123
#define IDS_WINFILE         124
#define IDS_ONLYONE         125
#define IDS_TREETITLE       126
#define IDS_SEARCHTITLE     127
#define IDS_NOFILESTITLE    130
#define IDS_NOFILESMSG      131
#define IDS_TOOMANYTITLE    132
#define IDS_OOMTITLE        133
#define IDS_OOMREADINGDIRMSG    134
#define IDS_CURDIRIS        140
#define IDS_COPY            141
#define IDS_ANDCOPY         142
#define IDS_RENAME          143
#define IDS_ANDRENAME       144
#define IDS_FORMAT          145
#define IDS_FORMATSELDISK   146
//#define IDS_MAKESYSDISK     147
#define IDS_DISCONNECT      148
#define IDS_DISCONSELDISK   149
#define IDS_CREATINGMSG     150
#define IDS_REMOVINGMSG     151
#define IDS_COPYINGMSG      152
#define IDS_RENAMINGMSG     153
#define IDS_MOVINGMSG       154
#define IDS_DELETINGMSG     155
#define IDS_PRINTINGMSG     156
#define IDS_NOSUCHDRIVE     160
#define IDS_MOVEREADONLY    161
#define IDS_RENAMEREADONLY  162
#define IDS_CONFIRMREPLACE  163
#define IDS_CONFIRMREPLACERO    164 /* Confirm/readonly */
#define IDS_CONFIRMRMDIR    165 /* Must be confirm + 1 */
#define IDS_CONFIRMRMDIRRO  166
#define IDS_CONFIRMDELETE   167
#define IDS_CONFIRMDELETERO 168
#define IDS_COPYINGTITLE    169
#define IDS_REMOVINGDIRMSG  170
#define IDS_STATUSMSG       180
#define IDS_DIRSREAD        181
#define IDS_DRIVEFREE       182
#define IDS_SEARCHMSG       183
#define IDS_DRIVE           184
#define IDS_SELECTEDFILES   185
#define IDS_NETDISCONOPEN   186
#define IDS_STATUSMSG2      187
#define IDS_DRIVENOTREADY   188
#define IDS_UNFORMATTED     189

#define IDS_CANTPRINTTITLE  190
#define IDS_PRINTFNF        191
#define IDS_PRINTDISK       192
#define IDS_PRINTMEMORY     193
#define IDS_PRINTERROR      194
#define IDS_TREEABORT       195
#define IDS_TREEABORTTITLE  196
#define IDS_DESTFULL        197
#define IDS_WRITEPROTECTFILE    198
#define IDS_FORMATQUICKFAILURE  199

#define IDS_OS2APPMSG       200
#define IDS_NEWWINDOWSMSG   201
#define IDS_PMODEONLYMSG    202

#define IDS_DDEFAIL         203

#define IDS_FORMATCONFIRM   210
#define IDS_FORMATCONFIRMTITLE  211
#define IDS_DISKCOPYCONFIRM 212
#define IDS_DISKCOPYCONFIRMTITLE    213
#define IDS_CLOSE           214
#define IDS_UNDELETE        215
#define IDS_CONNECT         216
#define IDS_CONNECTIONS     217
#define IDS_PATHNOTTHERE    218
#define IDS_PROGRAMS        219
#define IDS_ASSOCIATE       220
#define IDS_RUN             221
#define IDS_PRINTERRTITLE   222
#define IDS_WINHELPERR      223
#define IDS_NOEXEASSOC          224
#define IDS_ASSOCNOTEXE         225
#define IDS_ASSOCNONE           226
#define IDS_NOFILES             227
#define IDS_PRINTONLYONE        228
#define IDS_COMPRESSEDEXE       229
#define IDS_INVALIDDLL          230
#define IDS_SHAREERROR          231
#define IDS_CREATELONGDIR       232
#define IDS_CREATELONGDIRTITLE  233
#define IDS_BYTES       234
#define IDS_SBYTES      235

#define IDS_DRIVEBASE       300
#define IDS_12MB            (300 + DS96)
#define IDS_360KB           (300 + DS48)
#define IDS_144MB           (300 + DS144M)
#define IDS_720KB           (300 + DS720KB)
#define IDS_288MB           (300 + DS288M)
#define IDS_DEVICECAP       (300 + DS288M + 1)


#define IDS_FFERR_MEM       400
#define IDS_FFERR_USERABORT 401
#define IDS_FFERR_SRCEQDST  402
#define IDS_FFERR_SECSIZE   403
#define IDS_FFERR_DRIVETYPE 404
//#define IDS_FFERR_BADTRACK  405
//#define IDS_FFERR_WRITEBOOT 406
//#define IDS_FFERR_WRITEFAT  407
//#define IDS_FFERR_WRITEROOT 408
#define IDS_FFERR_SYSFILES  409
#define IDS_FFERR_MEDIASENSE    410
#define IDS_FFERR       411

#define IDS_OPENINGMSG          420
#define IDS_CLOSINGMSG          421


#define IDS_COPYERROR       1000
#define IDS_VERBS       1010
#define IDS_ACTIONS     1020
#define IDS_REPLACING       1030
#define IDS_CREATING        1031
#define IDS_REASONS     1040    // error codes strings (range += 255)


#define DE_INVFUNCTION      0x01        // DOS error codes (int21 returns)
#define DE_FILENOTFOUND     0x02
#define DE_PATHNOTFOUND     0x03
#define DE_NOHANDLES        0x04
#define DE_ACCESSDENIED     0x05
#define DE_INVHANDLE        0x06
#define DE_INSMEM           0x08
#define DE_INVFILEACCESS    0x0C
#define DE_DELCURDIR        0x10
#define DE_NOTSAMEDEVICE    0x11
#define DE_NODIRENTRY       0x12

#define DE_WRITEPROTECTED   0x13    // extended error start here
#define DE_ACCESSDENIEDNET  0x41

#define DE_NODISKSPACE      0x70    // our own error codes
#define DE_SAMEFILE     0x71
#define DE_MANYSRC1DEST     0x72
#define DE_DIFFDIR      0x73
#define DE_ROOTDIR      0x74
#define DE_OPCANCELLED      0x75
#define DE_DESTSUBTREE      0x76
#define DE_WINDOWSFILE      0x77
#define DE_ACCESSDENIEDSRC  0x78
#define DE_PATHTODEEP       0x79
#define DE_MANYDEST         0x7A
#define DE_RENAMREPLACE     0x7B
#define DE_HOWDIDTHISHAPPEN 0xFF    // internal error

#define ERRORONDEST     0x80    // indicate error on destination file


#include "wfdlgs.h"

// struct for save and restore of window positions

typedef struct {
    CHAR szDir[MAXPATHLEN];
    RECT rc;
    POINT pt;
    INT sw;
    INT view;
    INT sort;
    INT attribs;
    INT split;
} SAVE_WINDOW, NEAR *PSAVE_WINDOW;


#define SC_SPLIT            100

// Temporary. copied from win31 windows.h and slightly modified.
// We can delete these definitions once USER incorporates these in winuser.h

#define     GlobalAllocPtr(flags, cb)   \
    (GlobalLock(GlobalAlloc((flags), (cb))))
#define     GlobalFreePtr(lp)       \
    (GlobalUnlock(lp), (BOOL)(ULONG_PTR)GlobalFree((lp)))


WORD APIENTRY WFRemove(PSTR pszFile);
WORD APIENTRY WFMove(PSTR pszFrom, PSTR pszTo);

// These errors aren't in shellapi.h as yet. till such time...
/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE      27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

// the LPDROPSTRUCT->dwData will point to this structure

typedef struct {         /* dodata */
    LPSTR pch;           // in win31 this is LOWORD(lpds->dwData)
    HANDLE hMemGlobal;   // in win31 this is HIWORD(lpds->dwData)
} DRAGOBJECTDATA, FAR *LPDRAGOBJECTDATA;


#include "dlg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wnetcaps.c ===
/*
 *	History:
 *	    kevinl	08-Jan-1991	Created
 */

#include "winfile.h"
#include <winnet.h>
#include "wnetcaps.h"

UINT    wConnectionCaps ;
UINT    wDialogCaps ;
UINT    wAdminCaps ;

/*****
 *
 *  WNetGetCaps
 *
 *  WinNet API Function -- see spec for parms and return values.
 *
 */

UINT
WNetGetCaps(
           UINT  nIndex
           )
{
    /* Under NT, the network can be stopped at anytime, so we
     * check everytime someone queries what capabilities we have.
     * Thus overall, we represent a consistent picture to the user (though
     * there will be times when an application may be out of date).
     */

    DWORD dwRet;
    DWORD dwBuffSize = 50;
    CHAR szUserName[50];

    dwRet = WNetGetUser( NULL, szUserName, &dwBuffSize );

    switch ( dwRet ) {
        case WN_NO_NETWORK:

            wConnectionCaps = 0 ;
            wDialogCaps = 0 ;
            wAdminCaps  = 0 ;

            break ;

        default:
            wConnectionCaps =  ( WNNC_CON_ADDCONNECTION     |
                                 WNNC_CON_CANCELCONNECTION  |
                                 WNNC_CON_GETCONNECTIONS     );

            wDialogCaps     =  ( WNNC_DLG_CONNECTIONDIALOG |
                                 WNNC_DLG_DEVICEMODE       |
                                 WNNC_DLG_PROPERTYDIALOG    ) ;

            wAdminCaps      =  ( WNNC_ADM_GETDIRECTORYTYPE   |
                                 WNNC_ADM_DIRECTORYNOTIFY     ) ;
            break ;
    }

    switch (nIndex) {
        case WNNC_CONNECTION:
            return	wConnectionCaps;

        case WNNC_DIALOG:
            return	wDialogCaps;

        case WNNC_ADMIN:
            return  wAdminCaps;

        default:
            return	0;
    }
}  /* WNetGetCaps */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\winobj\wnetcaps.h ===
#ifndef _WNETCAPS_INCLUDED
    #define _WNETCAPS_INCLUDED


UINT WNetGetCaps( UINT  nIndex );

#define WNNC_CONNECTION         0x00000006
#define  WNNC_CON_ADDCONNECTION     0x00000001
#define  WNNC_CON_CANCELCONNECTION  0x00000002
#define  WNNC_CON_GETCONNECTIONS    0x00000004

#define  WNNC_CON_BROWSEDIALOG      0x00000010

#define  WNNC_CON_RESTORECONNECTION 0x00000020
#define  WNNC_CON_ADDCONNECTION2    0x00000040
#define  WNNC_CON_ENUM              0x00000080

#define WNNC_DIALOG             0x00000008
#define  WNNC_DLG_DEVICEMODE        0x00000001

#define  WNNC_DLG_ConnectDialog     0x00000004
#define  WNNC_DLG_DisconnectDialog  0x00000008


#define  WNNC_DLG_PROPERTYDIALOG    0x00000020
#define  WNNC_DLG_CONNECTIONDIALOG  0x00000040

#define WNNC_ADMIN              0x00000009
#define  WNNC_ADM_GETDIRECTORYTYPE  0x00000001
#define  WNNC_ADM_DIRECTORYNOTIFY   0x00000002
#define  WNNC_ADM_LONGNAMES         0x00000004

//
//  BROWSE DIALOG
//

#define WNBD_CONN_UNKNOWN   0x0
#define WNBD_CONN_DISKTREE  0x1
#define WNBD_CONN_PRINTQ    0x3
#define WNBD_MAX_LENGTH     0x80    // path length, includes the NULL

#define WNTYPE_DRIVE    1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER  3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR    1
#define WNDN_RMDIR    2
#define WNDN_MVDIR    3

#endif  // _WNETCAPS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wperf\calcperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    perfmtrp.h

Abstract:

    This module contains NT/Win32 Perfmtr private data and types

Author:

    Mark Enstrom (marke) 28-Mar-1991

Revision History:

--*/

#ifndef _CALCPERFH_INCLUDED_
#define _CALCPERFH_INCLUDED_

#define MAX_PROCESSOR 16
#define DATA_LIST_LENGTH 100
#define DELAY_SECONDS 2

//
// display const
//

#define SAVE_SUBJECTS  (MAX_PROCESSOR+12+3+1)
#define BORDER_WIDTH   2
#define INDENT_WIDTH   8
#define GRAPH_WIDTH    130
#define GRAPH_HEIGHT   40
#define PERF_METER_CPU_CYCLE 10

//
//  time constant for sampling performance
//

#define PERF_TIME_DELAY 1000

//
//  types of display modes
//

#define DISPLAY_MODE_CPU_ONLY   0
#define DISPLAY_MODE_CPU        10
#define DISPLAY_MODE_VM         20
#define DISPLAY_MODE_CACHE      30
#define DISPLAY_MODE_POOL       40
#define DISPLAY_MODE_IO         50
#define DISPLAY_MODE_LPC        60
#define DISPLAY_MODE_SVR        70

//
// structure to save screen statistics
//

typedef struct _CPU_DATA_LIST
{
    PUCHAR   KernelTime;
    PUCHAR   UserTime;
    PUCHAR   TotalTime;
} CPU_DATA_LIST,*PCPU_DATA_LIST;


typedef struct _PERF_DATA_LIST
{
    PULONG  PerfData;
} PERF_DATA_LIST,*PPERF_DATA_LIST;

//
//  This info packet is associated with each
//  performance item
//

typedef struct tagDISPLAYITEM
{
    HDC     MemoryDC;
    HBITMAP MemoryBitmap;
    ULONG   Max;
    ULONG   PositionX;
    ULONG   PositionY;
    ULONG   Width;
    ULONG   Height;
    ULONG   NumberOfElements;
    ULONG   CurrentDrawingPos;
    RECT    Border;
    RECT    GraphBorder;
    RECT    TextBorder;
    BOOL    Display;
    BOOL    ChangeScale;
    ULONG   KernelTime[DATA_LIST_LENGTH];
    ULONG   UserTime[DATA_LIST_LENGTH];
    ULONG   TotalTime[DATA_LIST_LENGTH];
    ULONG   DpcTime[DATA_LIST_LENGTH];
    ULONG   InterruptTime[DATA_LIST_LENGTH];

} DISPLAY_ITEM,*PDISPLAY_ITEM;

//
// flag to activate each menu selection
//

#define DISPLAY_INACTIVE 0
#define DISPLAY_ACTIVE   1


//
//  Keep book-keeping info for all processors
//

typedef struct _CPU_VALUE
{
        LARGE_INTEGER   KernelTime;
        LARGE_INTEGER   UserTime;
        LARGE_INTEGER   IdleTime;
        LARGE_INTEGER   DpcTime;
        LARGE_INTEGER   InterruptTime;
        ULONG           InterruptCount;
} CPU_VALUE,*PCPU_VALUE;



BOOL
UpdatePerfInfo(
   PULONG   DataPointer,
   ULONG    NewDataValue,
   PULONG   OldMaxValue
   );


VOID
InitListData(
   PDISPLAY_ITEM    PerfListItem,
   ULONG            NumberOfItems
   );

#endif /* _CALCPERFH_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wperf\wperf.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    winperf.h

Abstract:

   This module contains the definit

Author:

    Mark Lucovsky (markl) 28-Mar-1991

Revision History:

--*/

#ifndef _WINPERFH_INCLUDED_
#define _WINPERFH_INCLUDED_

#define DIALOG_SUCCESS  100
#define DIALOG_CANCEL   0

#define IDM_EXIT        1100
#define IDM_SELECT      1101
#define IDM_ALL         1103
#define TIMER_ID        1001
#define IDM_CPU_GRP     1002
#define IDM_PERF_GRP    1003
#define IDM_SEL_DLG     1004
#define IDM_STYLE_GRP   1005


#define IDM_CPU0        101
#define IDM_CPU1        102
#define IDM_CPU2        103
#define IDM_CPU3        104
#define IDM_CPU4        105
#define IDM_CPU5        106
#define IDM_CPU6        107
#define IDM_CPU7        108
#define IDM_CPU8        109
#define IDM_CPU9        110
#define IDM_CPU10       111
#define IDM_CPU11       112
#define IDM_CPU12       113
#define IDM_CPU13       114
#define IDM_CPU14       115
#define IDM_CPU15       116
#define IDM_PGFLT       117
#define IDM_PGAV        118
#define IDM_CONTEXT     119
#define IDM_1TB         120
#define IDM_2TB         121
#define IDM_SYSCALL     122
#define IDM_INT         123
#define IDM_POOL        124
#define IDM_NONPOOL     125
#define IDM_PROCESS     126
#define IDM_THREAD      127
#define IDM_ALIGN       128
#define IDM_EXCEPT      129
#define IDM_FLOAT       130
#define IDM_INS_EMUL    131
#define IDM_CPU_TOTAL   132
#define IDM_SEL_LINE    133
#define IDM_SEL_BAR     134


#define WINPERF_ICON 1011
#define CPUTHERM_ICON 1012
#define BALL_BITMAP 1011

#define CPU_STYLE_LINE 0
#define CPU_STYLE_BAR 1


#include "calcperf.h"


typedef struct _WINPERF_INFO
{
    DWORD   WindowPositionX;
    DWORD   WindowPositionY;
    DWORD   WindowSizeX;
    DWORD   WindowSizeY;
    DWORD   DisplayElement[SAVE_SUBJECTS];
    DWORD   DisplayMode;
    DWORD   CpuStyle;
    HPEN    hBluePen;
    HPEN    hRedPen;
    HPEN    hGreenPen;
    HPEN    hMagentaPen;
    HPEN    hYellowPen;
    HPEN    hDotPen;
    HBRUSH  hBackground;
    HBRUSH  hRedBrush;
    HBRUSH  hGreenBrush;
    HBRUSH  hBlueBrush;
    HBRUSH  hMagentaBrush;
    HBRUSH  hYellowBrush;
    HBRUSH  hLightBrush;
    HBRUSH  hDarkBrush;
    HFONT   LargeFont;
    HFONT   MediumFont;
    HFONT   SmallFont;
    HFONT   hOldFont;
    HMENU   hMenu;
    HWND    hWndMain;
    UINT_PTR TimerId;
    UINT    NumberOfProcessors;
    BOOL    DisplayMenu;
} WINPERF_INFO,*PWINPERF_INFO;






BOOL
InitApplication(
   HANDLE hInstance,
   HBRUSH hBackground
   );


BOOL
InitInstance(
    HANDLE          hInstance,
    int             nCmdShow
    );



LRESULT APIENTRY
MainWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );



LRESULT APIENTRY
CpuWndProc(
   HWND  hWnd,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );


BOOL
APIENTRY About(
   HWND     hDlg,
   UINT     message,
   WPARAM   wParam,
   LPARAM   lParam
   );




BOOL    APIENTRY MoveToEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY SetViewportExtEx(IN HDC, IN int, IN int, OUT LPSIZE);
BOOL    APIENTRY SetViewportOrgEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY SetWindowExtEx(IN HDC, IN int, IN int, OUT LPSIZE);
BOOL    APIENTRY SetWindowOrgEx(IN HDC, IN int, IN int, OUT LPPOINT);
BOOL    APIENTRY GetWindowExtEx(IN HDC, OUT LPSIZE);
BOOL    APIENTRY GetCurrentPositionEx(IN HDC, OUT LPPOINT);
BOOL    APIENTRY MGetWindowExt(HDC hdc, INT * pcx, INT * pcy);
BOOL    APIENTRY MGetCurrentPosition(HDC hdc, INT * px, INT * py);
HANDLE  APIENTRY MGetInstHandle(VOID);

LPSTR   MGetCmdLine(VOID);


VOID
UpdateCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient
   );

VOID
DrawCpuMeter(
   IN   HDC    hDC,
   IN   SHORT  cxClient,
   IN   SHORT  cyClient,
   IN   ULONG DisplayItem
   );

VOID
ReScalePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

BOOL
CalcCpuTime(
   PDISPLAY_ITEM    PerfListItem
   );

ULONG
InitPerfInfo(VOID);


VOID
InitProfileData(PWINPERF_INFO pWinperfInfo);







VOID
SaveProfileData(PWINPERF_INFO pWinperfInfo);

VOID
DrawPerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );


VOID
UpdatePerfWindow(
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItem
    );

//
//  change style constants
//

#define STYLE_ENABLE_MENU  WS_OVERLAPPEDWINDOW
#define STYLE_DISABLE_MENU (WS_THICKFRAME+WS_BORDER)


LRESULT APIENTRY
DbgWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );


BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    );



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   UINT  message,
   WPARAM wParam,
   LPARAM lParam
   );

VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );


BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    );


VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    );

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    );

#endif /* _WINPERFH_INCLUDED_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wperf\draw.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    Draw.c

Abstract:

   Win32 application to display performance statictics. This routine implements
   graphics output for display windows.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-07-92     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <math.h>
#include <errno.h>
#include "Wperf.h"

extern DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
extern WINPERF_INFO    WinperfInfo;
extern PUCHAR          PerfNames[];



BOOLEAN
FitPerfWindows(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Calculate all parameters to fit the given number of
    windows into the app window. Fill out the data structure
    for each sub-window

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/

{
    RECT    ClientRect;
    int     cx,cy;
    UINT    Index;
    int     ActiveWindows,IndexX,IndexY;
    int     WindowsX,WindowsY,WindowWidth,WindowHeight;
    int     LastRowWidth,LoopWidth;
    double  fWindowsX,fActiveWindows,fcx,fcy;

    //
    //  Find out the client area bounds
    //

    GetClientRect(hWnd,&ClientRect);

    cx = ClientRect.right;
    cy = ClientRect.bottom - 2;   // subtract 2 to give a little more border

    //
    //  Find out how many perf windows are active
    //

    ActiveWindows = 0;

    for (Index=0;Index<NumberOfWindows;Index++) {
        if (DisplayItems[Index].Display == TRUE) {
            ActiveWindows++;
        }
    }

    //
    // Return if there are no active windows to display
    //

    if (ActiveWindows == 0) {
        return(TRUE);
    }


    //
    //  Now convert the window dimensions to floating point and
    //  then take the square root of the window dimension to find
    //  out the number of windows in the x direction
    //

    fActiveWindows = 1.0 * ActiveWindows;

    fcx = 1.0 * cx;
    fcy = 1.0 * cy;

    if (fcy != 0.0) {
        fWindowsX = sqrt((fcx * fActiveWindows) / fcy);
    }   else {

        //
        // If fcy = 0 then return since this is an error condition that
        // would cause a divide by zero.
        //

        return(FALSE);
    }

    //
    // convert back to integer
    //

    WindowsX = (int)fWindowsX;

    if (WindowsX == 0) {
        WindowsX = 1;
    } else if (WindowsX > ActiveWindows) {
        WindowsX = ActiveWindows;
    }

    WindowsY = ActiveWindows / WindowsX;

    //
    //  Add on extra line to Y to take care of the left over windows ie:
    //  if there are 15 active windows and the x number = 7 then y = 2 with 1
    //  left over.
    //

    Index = ActiveWindows - (WindowsX * WindowsY);

    if (Index > 0) {
        WindowsY++;
        LastRowWidth = cx / Index;
    } else {
        LastRowWidth = cx / WindowsX;
    }

    WindowWidth  = cx / WindowsX;
    WindowHeight = cy / WindowsY;

    //
    // Assign positions for each active window
    //

    Index  = 0;

    for (IndexY=0;IndexY<WindowsY;IndexY++) {
        for (IndexX=0;IndexX<WindowsX;IndexX++) {

            //
            // Find the next active display item
            //

            while ((DisplayItems[Index].Display != TRUE) && (Index < NumberOfWindows)) {
                Index++;
            }

            //
            //  Add y fixup for last row
            //

            if (IndexY == WindowsY - 1) {
                LoopWidth = LastRowWidth;
            } else {
                LoopWidth = WindowWidth;
            }


            DisplayItems[Index].PositionX = LoopWidth  * IndexX;
            DisplayItems[Index].PositionY = WindowHeight * IndexY + 1;  // +1 for more top border
            DisplayItems[Index].Width     = LoopWidth - 1;
            DisplayItems[Index].Height    = WindowHeight - 1;

            //
            // Last Column fix-up to use all of window.
            //

            if (IndexX == WindowsX - 1) {
                DisplayItems[Index].Width = cx - DisplayItems[Index].PositionX - 1;
            }

            //
            //
            //

            Index++;

            if (Index >= NumberOfWindows) {
                break;
            }

        }


        if (Index >= NumberOfWindows) {
            break;
        }


    }



    return(TRUE);
}



VOID
CalcDrawFrame(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Calculate all borders for graphics windows

Arguments:

    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;
    LONG    GraphHeight,TextHeight;
    BOOLEAN TextWindow;

    double  fx1,fx2,fy1;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->PositionX + 2;
    x2 = DisplayItem->PositionX + DisplayItem->Width - 2;
    y1 = DisplayItem->PositionY + 2;
    y2 = DisplayItem->PositionY + DisplayItem->Height - 2;

    //
    // find out in there is enough space for a text window
    //

    if ((y2 - y1 - 12) > 30) {

        TextWindow = TRUE;

        //
        // Calculate dimensions for a text window and a graphics window
        //
        // fx1 = portion of the window - bordres and free space
        //
        // fx2 = fraction of window used for graphics
        //
        // fy1 = fraction of winddow used for text
        //

        fx1 = (y2 - y1 - 10);

        fx2 = fx1 * 0.6666;
        fy1 = fx1 * 0.3333;

        GraphHeight = (LONG)fx2;
        TextHeight  = (LONG)fy1;

        if (TextHeight > 20) {
            GraphHeight += TextHeight-20;
            TextHeight = 20;
        }

        //
        // Calculate window boundaries
        //

        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y1 + 4 + GraphHeight + 1;

        tx1 = x1 + 4;
        tx2 = x2 - 4;
        ty1 = gy2 + 1 + 2 + 1;  // border,free space,border
        ty2 = gy2 + TextHeight + 1;

    }   else {

        TextWindow = FALSE;
        GraphHeight = y2 - y1 - 10;
        gx1 = x1 + 4;
        gx2 = x2 - 4;
        gy1 = y1 + 4;
        gy2 = y2 - 4;
        tx1 = tx2 = ty1 = ty2 = 0;

    }

    //
    // Fill in structures for drawing text and graphics
    //

    DisplayItem->Border.left        = x1;
    DisplayItem->Border.right       = x2;
    DisplayItem->Border.top         = y1;
    DisplayItem->Border.bottom      = y2;

    DisplayItem->GraphBorder.left   = gx1;
    DisplayItem->GraphBorder.right  = gx2;
    DisplayItem->GraphBorder.top    = gy1;
    DisplayItem->GraphBorder.bottom = gy2;

    DisplayItem->TextBorder.left    = tx1;
    DisplayItem->TextBorder.right   = tx2;
    DisplayItem->TextBorder.top     = ty1;
    DisplayItem->TextBorder.bottom  = ty2;
}




VOID
DrawFrame(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw the window frame for a performance window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    DrawRect;
    LONG    x1,x2,y1,y2;
    LONG    gx1,gx2,gy1,gy2;
    LONG    tx1,tx2,ty1,ty2;

    //
    // Draw a 3-d stand out box around item window
    //

    x1 = DisplayItem->Border.left;
    x2 = DisplayItem->Border.right;
    y1 = DisplayItem->Border.top;
    y2 = DisplayItem->Border.bottom;

    gx1 = DisplayItem->GraphBorder.left;
    gx2 = DisplayItem->GraphBorder.right;
    gy1 = DisplayItem->GraphBorder.top;
    gy2 = DisplayItem->GraphBorder.bottom;

    tx1 = DisplayItem->TextBorder.left;
    tx2 = DisplayItem->TextBorder.right;
    ty1 = DisplayItem->TextBorder.top;
    ty2 = DisplayItem->TextBorder.bottom;

    //
    // Draw top border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y1 + 2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw Left border in light shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x1 + 2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // Draw right border in dark shade
    //


    DrawRect.left   = x2 - 2;
    DrawRect.right  = x2;
    DrawRect.top    = y1;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // draw bottom in dark shade
    //

    DrawRect.left   = x1;
    DrawRect.right  = x2;
    DrawRect.top    = y2-2;
    DrawRect.bottom = y2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw graphics area single border
    //

    //
    // Draw top border in dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy1+1;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw Left border in Dark shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx1 + 1;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

    //
    // Draw right border in Light shade
    //


    DrawRect.left   = gx2 - 1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    //
    // draw bottom in Light shade
    //

    DrawRect.left   = gx1;
    DrawRect.right  = gx2;
    DrawRect.top    = gy2-1;
    DrawRect.bottom = gy2;

    FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    if (tx2 > 0) {

        //
        // Draw top border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty1 + 1;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw Left border in Dark shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx1 + 1;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hDarkBrush);

        //
        // Draw right border in Light shade
        //


        DrawRect.left   = tx2 - 1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

        //
        // draw bottom in Light shade
        //

        DrawRect.left   = tx1;
        DrawRect.right  = tx2;
        DrawRect.top    = ty2-1;
        DrawRect.bottom = ty2;

        FillRect(hDC,&DrawRect,WinperfInfo.hLightBrush);

    }
}




VOID
DrawPerfText(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item
    )
/*++

Routine Description:

    Draw text into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    TextRect;
    UCHAR   TextStr[50];
    UINT    FontSize;

    //
    // Check that text display is enabled
    //

    if (DisplayItem->TextBorder.right == 0) {
        return;
    }

    TextRect.left = DisplayItem->TextBorder.left +1;
    TextRect.right = DisplayItem->TextBorder.right -1;
    TextRect.top = DisplayItem->TextBorder.top +1;
    TextRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&TextRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  TextRect.bottom - TextRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);
    }

    DrawText(
                hDC,
                PerfNames[Item],
                strlen(PerfNames[Item]),
                &TextRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );


    //
    // Build the numeric value
    //

    wsprintf(TextStr,"   %li",DisplayItem->TotalTime[0]);

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &TextRect,
                DT_RIGHT | DT_VCENTER | DT_SINGLELINE
             );




    SelectObject(hDC,WinperfInfo.hOldFont);

}





VOID
DrawPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Draw graphics into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect;
    ULONG   Scale,i,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth +1;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&MemGraphRect,WinperfInfo.hBackground);

    MemGraphRect.right  = GraphWidth;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //

    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
                    MemGraphRect.right - Scale * i,
                    MemGraphRect.bottom - (DisplayItem->KernelTime[i] * GraphHeight)/DisplayItem->Max
               );

        }

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->UserTime[i] * GraphHeight)/DisplayItem->Max);

        }

        //
        // Select DPC Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->DpcTime[i] * GraphHeight)/DisplayItem->Max);

        }
        //
        // Select Interrupt Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->InterruptTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);

        for (i=1;((i<DATA_LIST_LENGTH) && i * Scale < GraphWidth);i++) {
            LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->InterruptTime[i] * GraphHeight)/DisplayItem->Max);

        }
    }

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);
    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    for (i=1;((i<DATA_LIST_LENGTH) && i*Scale < GraphWidth);i++) {
        LineTo(DisplayItem->MemoryDC,
               MemGraphRect.right - Scale * i,
               MemGraphRect.bottom - (DisplayItem->TotalTime[i] * GraphHeight)/DisplayItem->Max);

    }



    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}

VOID
ShiftPerfGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Shift memory bitmap 1 location left then draw the 1 new data point.
    BitBlt this to the screen.


Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,MemGraphRect,FillArea;
    ULONG   Scale,GraphWidth,GraphHeight;



    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left -1;
    GraphHeight = GraphRect.bottom - GraphRect.top -1;

    //
    // Memory bitmap is zero-offset for all windows, add 1 to make fillrect fill out
    // to right and bottom edge
    //

    MemGraphRect.left   = 0;
    MemGraphRect.right  = GraphWidth;
    MemGraphRect.top    = 0;
    MemGraphRect.bottom = GraphHeight;

    if (DisplayItem->Max == 0) {
        DisplayItem->Max = 1;
    }

    //
    // calculate scale from data to perf window
    //
    // X scale factor (100 items in x space). Scale can not be less than 1
    //

    Scale = (GraphWidth -1)/ DATA_LIST_LENGTH;
    if (Scale == 0) {
        Scale = 1;
    }

    //
    // Shift memory image left by scale
    //


    BitBlt( DisplayItem->MemoryDC,
            0,
            0,
            GraphWidth+1 - Scale,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            Scale,
            0,
            SRCCOPY);


    //
    // Fill The new area on the right of the screen
    //

    FillArea.left   = GraphWidth +1 - Scale;
    FillArea.right  = GraphWidth +1;
    FillArea.top    = 0;
    FillArea.bottom = GraphHeight +1;

    FillRect(DisplayItem->MemoryDC,&FillArea,WinperfInfo.hBackground);


    //
    // Draw the 1 new data point
    //


    //
    //  Draw UserTime if needed
    //

    if (DisplayItem->NumberOfElements>1) {

        //
        // Select kernel pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedPen);

        MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->KernelTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->KernelTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select User Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->UserTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->UserTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select DPC Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->DpcTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->DpcTime[1] * GraphHeight)/DisplayItem->Max
              );

        //
        // Select Interrupt Pen
        //

        SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaPen);

        MoveToEx(
                    DisplayItem->MemoryDC,
                    MemGraphRect.right,
                    MemGraphRect.bottom - (DisplayItem->InterruptTime[0] * GraphHeight)/ DisplayItem->Max,
                    (LPPOINT)NULL
                 );

        LineTo(
                DisplayItem->MemoryDC,
                MemGraphRect.right - Scale,
                MemGraphRect.bottom - (DisplayItem->InterruptTime[1] * GraphHeight)/DisplayItem->Max
              );

    }

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBluePen);

    MoveToEx(DisplayItem->MemoryDC,
             MemGraphRect.right,
             MemGraphRect.bottom - (DisplayItem->TotalTime[0] * GraphHeight)/ DisplayItem->Max,
             (LPPOINT)NULL);




    LineTo(DisplayItem->MemoryDC,
            MemGraphRect.right - Scale,
            MemGraphRect.bottom - (DisplayItem->TotalTime[1] * GraphHeight)/DisplayItem->Max);



    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth+1,
            GraphHeight+1,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);


}



BOOLEAN
CreateMemoryContext(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Create a memory context and a memory bitmap for each perf window



Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    int     Width;
    int     Height;

    if (DisplayItem->Display == TRUE) {

        //
        //  Calculate width of memory bitmap needed
        //

        Width  = DisplayItem->GraphBorder.right - DisplayItem->GraphBorder.left;
        Height = DisplayItem->GraphBorder.bottom - DisplayItem->GraphBorder.top;

        if ((Width<=0) || (Height <= 0)) {

            //
            // Disable this window that is to small to be seen
            //

            //DisplayItem->Display = FALSE;

            //return(TRUE);

            //
            // make a fake width and height
            //

            Width  = 1;
            Height = 1;
        }

        //
        //  Create DC and Bitmap
        //

        DisplayItem->MemoryDC     = CreateCompatibleDC(hDC);

        if (DisplayItem->MemoryDC == NULL) {
            return(FALSE);
        }


        DisplayItem->MemoryBitmap = CreateCompatibleBitmap(hDC,Width,Height);

        if (DisplayItem->MemoryBitmap == 0) {
            return(FALSE);
        }

        SelectObject(DisplayItem->MemoryDC,DisplayItem->MemoryBitmap);

    }

    return(TRUE);
}



VOID
DeleteMemoryContext(
    PDISPLAY_ITEM   DisplayItem
    )
/*++

Routine Description:

    Delete memory bitmap and context

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{

    if (DisplayItem->MemoryDC != NULL) {
        DeleteDC(DisplayItem->MemoryDC);
    }

    if (DisplayItem->MemoryBitmap != NULL) {
        DeleteObject(DisplayItem->MemoryBitmap);
    }

}








#define	BOX_DEPTH	3

VOID
DrawCpuBarGraph(
    HDC             hDC,
    PDISPLAY_ITEM   DisplayItem,
    UINT            Item

    )
/*++

Routine Description:

    Draw a 3-d like CPU bar graph into the perf window

Arguments:

    hDC         - Device Context for window
    DisplayItem - Data structure with all perf window info

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    RECT    GraphRect,DrawRect;
    ULONG   i,GraphWidth,GraphHeight,CpuGraphHeight;
    ULONG   BarWidth,BarHeight,tHeight,kHeight,uHeight,dHeight,iHeight;
    POINT   PolyPoint[4];
    HPEN    hOldPen;
    UINT    FontSize;
    UCHAR   TextStr[100];
    ULONG   nItems,UserBase, KerBase, DPCbase, TotBase, IntBase;


    nItems = 5;

    GraphRect.left   = DisplayItem->GraphBorder.left   + 1;
    GraphRect.right  = DisplayItem->GraphBorder.right  - 1;
    GraphRect.top    = DisplayItem->GraphBorder.top    + 1;
    GraphRect.bottom = DisplayItem->GraphBorder.bottom - 1;

    GraphWidth  = GraphRect.right  - GraphRect.left;
    GraphHeight = GraphRect.bottom - GraphRect.top;


    BarWidth   = GraphWidth/((nItems*4)+4);
    BarHeight  = GraphHeight/((nItems*4)+4);

    CpuGraphHeight = GraphHeight - 2 * BarHeight;

    //
    // Jump Out if window is too small
    //

    if (BarWidth == 0) {
        return;
    }

    //
    // Calculate Heights
    //

    uHeight = (DisplayItem->UserTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    UserBase = 2;
    kHeight = (DisplayItem->KernelTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    KerBase = 6;
    dHeight = (DisplayItem->DpcTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    DPCbase = 10;
    iHeight = (DisplayItem->InterruptTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    IntBase = 14;
    tHeight = (DisplayItem->TotalTime[0] * CpuGraphHeight)/ DisplayItem->Max;
    TotBase = 18;

    DrawRect.left   = 0;
    DrawRect.right  = GraphWidth;
    DrawRect.top    = 0;
    DrawRect.bottom = GraphHeight;

    FillRect(DisplayItem->MemoryDC,&DrawRect,WinperfInfo.hBackground);
    SelectObject(DisplayItem->MemoryDC,GetStockObject(GRAY_BRUSH));

    //
    // Draw Background, face 1 (left side)
    //

    PolyPoint[0].x = DrawRect.left + BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight/2);

    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (GraphHeight - BarHeight/2);

    PolyPoint[3].x = DrawRect.left + BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - (GraphHeight - BOX_DEPTH*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Background, face 2 (bottom)
    //

    PolyPoint[0].x = DrawRect.left + BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight/2);

    //  Left line
    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    //  Back line
    PolyPoint[2].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    //	Bottom line.
    PolyPoint[3].x = DrawRect.left + (nItems*4)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - (BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Background, face 3 (Back Side)
    //

    PolyPoint[0].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BOX_DEPTH*BarHeight/2);

    PolyPoint[1].x = DrawRect.left + BOX_DEPTH*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (GraphHeight - BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom    - (GraphHeight - BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (nItems*4+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom    - ((BOX_DEPTH*BarHeight)/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Scale Lines if the window height is large ( > 200)
    //


    if ((DrawRect.bottom - DrawRect.top) > 200) {

        hOldPen = SelectObject(DisplayItem->MemoryDC,WinperfInfo.hDotPen);
        SetBkMode(DisplayItem->MemoryDC,TRANSPARENT);

	//
	//	Back
	//

	for (i=1;i<10;i++) {
            MoveToEx(DisplayItem->MemoryDC,
                     BOX_DEPTH*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10)),
                     NULL
                    );

            LineTo(DisplayItem->MemoryDC,
                     (nItems*4+2)*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10))
                );
        }

	//
	//	Left Side
	//

	for (i=1;i<10;i++) {
            MoveToEx(DisplayItem->MemoryDC,
                     BarWidth,
                     DrawRect.bottom  - (BarHeight/2 + (i*CpuGraphHeight/10)),
                     NULL
                    );

            LineTo(DisplayItem->MemoryDC,
                     BOX_DEPTH*BarWidth,
                     DrawRect.bottom  - (BOX_DEPTH*BarHeight/2 + (i*CpuGraphHeight/10))
                  );
        }


        SelectObject(DisplayItem->MemoryDC,hOldPen);
    }

    //
    //  Draw CPU User time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hGreenBrush);

    PolyPoint[0].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (uHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (uHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw User Box Side
    //

    PolyPoint[0].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 + uHeight);

    PolyPoint[3].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (BarHeight + uHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw User Box Top
    //

    PolyPoint[0].x = DrawRect.left + (UserBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (uHeight +  BarHeight);

    PolyPoint[1].x = DrawRect.left + (UserBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (uHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (UserBase+BOX_DEPTH)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (uHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (UserBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (uHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Kernel time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hRedBrush);

    PolyPoint[0].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( kHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Side
    //

    PolyPoint[0].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +kHeight);

    PolyPoint[3].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Top
    //

    PolyPoint[0].x = DrawRect.left + (KerBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (kHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (KerBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (kHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (KerBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (kHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (KerBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (kHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU DPC time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hYellowBrush);

    PolyPoint[0].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( dHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw DPC Box Side
    //

    PolyPoint[0].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +dHeight);

    PolyPoint[3].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw DPC Box Top
    //

    PolyPoint[0].x = DrawRect.left + (DPCbase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (dHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (DPCbase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (dHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (DPCbase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (dHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (DPCbase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (dHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Interrupt time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hMagentaBrush);

    PolyPoint[0].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( iHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Interrupt Box Side
    //

    PolyPoint[0].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 +iHeight);

    PolyPoint[3].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Interrupt Box Top
    //

    PolyPoint[0].x = DrawRect.left + (IntBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (iHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (IntBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (iHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (IntBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (iHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (IntBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (iHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    //  Draw CPU Total time BOX, face
    //

    SelectObject(DisplayItem->MemoryDC,WinperfInfo.hBlueBrush);

    PolyPoint[0].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (BarHeight);

    PolyPoint[2].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - ( tHeight + BarHeight);

    PolyPoint[3].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw CPU Total Box Side
    //

    PolyPoint[0].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom    - (BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom   - (3*BarHeight/2);

    PolyPoint[2].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (3*BarHeight/2 + tHeight);

    PolyPoint[3].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + BarHeight);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Draw Kernel Box Top
    //

    PolyPoint[0].x = DrawRect.left + (TotBase)*BarWidth;
    PolyPoint[0].y = DrawRect.bottom - (tHeight + BarHeight);

    PolyPoint[1].x = DrawRect.left + (TotBase+2)*BarWidth;
    PolyPoint[1].y = DrawRect.bottom - (tHeight + BarHeight);

    PolyPoint[2].x = DrawRect.left + (TotBase+3)*BarWidth;
    PolyPoint[2].y = DrawRect.bottom  - (tHeight + 3*BarHeight/2);

    PolyPoint[3].x = DrawRect.left + (TotBase+1)*BarWidth;
    PolyPoint[3].y = DrawRect.bottom  - (tHeight + 3*BarHeight/2);

    Polygon(DisplayItem->MemoryDC,&PolyPoint[0],4);

    //
    // Update screen with memory image
    //

    BitBlt(
            hDC,
            GraphRect.left,
            GraphRect.top,
            GraphWidth,
            GraphHeight,
            DisplayItem->MemoryDC,
            0,
            0,
            SRCCOPY);

    //
    // Draw Text output for CPU bar-graph window
    //


    DrawRect.left = DisplayItem->TextBorder.left +2;
    DrawRect.right = DisplayItem->TextBorder.right -2;
    DrawRect.top = DisplayItem->TextBorder.top +1;
    DrawRect.bottom = DisplayItem->TextBorder.bottom -1;

    FillRect(hDC,&DrawRect,WinperfInfo.hBackground);

    SetBkColor(hDC,RGB(192,192,192));

    //
    //  Decide which font to draw with
    //

    FontSize =  DrawRect.bottom - DrawRect.top;

    if (FontSize >= 15) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.LargeFont);
    } else if (FontSize > 10) {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.MediumFont);
    } else {
        WinperfInfo.hOldFont = SelectObject(hDC,WinperfInfo.SmallFont);

    }

    strcpy(TextStr,PerfNames[Item]);

    if ((DrawRect.right - DrawRect.left) > 120) {
        strcat(TextStr," User,Kernel,Dpc,Int,Total");
    } else {
        strcat(TextStr," U K D I T");
    }

    DrawText(
                hDC,
                TextStr,
                strlen(TextStr),
                &DrawRect,
                DT_LEFT | DT_VCENTER | DT_SINGLELINE
             );



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wperf\calcperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   CalcPerf.c

Abstract:

   calculate perfoemance statistics

Author:



Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <assert.h>
#include "calcperf.h"

SYSTEM_EXCEPTION_INFORMATION                ExceptionInfo;
SYSTEM_EXCEPTION_INFORMATION                PreviousExceptionInfo;
SYSTEM_PERFORMANCE_INFORMATION              PerfInfo;
SYSTEM_PERFORMANCE_INFORMATION              PreviousPerfInfo;
POBJECT_TYPE_INFORMATION                    ObjectInfo;
WCHAR                                       Buffer[ 256 ];
STRING                                      DeviceName;
UNICODE_STRING                              DeviceNameU;
OBJECT_ATTRIBUTES                           ObjectAttributes;
NTSTATUS                                    Status;

CCHAR                                       NumberOfProcessors;
SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAX_PROCESSOR];

CPU_VALUE                                   PreviousCpuData[MAX_PROCESSOR];

//
//  make the maximum for pages available a "grow only" max. (since the
//  amount of memory in a machine is limited. Set to 1 Mbytes here.
//

ULONG                                       PgAvailMax = 16384;
ULONG                                       PreviousInterruptCount;
ULONG                                       InterruptCount;


ULONG
InitPerfInfo(
    VOID
    )

/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

   None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-21-91      Initial code

--*/

{

    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    int                                         i;

    //
    //  Init Nt performance interface
    //

    NtQuerySystemInformation(
       SystemExceptionInformation,
       &ExceptionInfo,
       sizeof(ExceptionInfo),
       NULL
    );

    PreviousExceptionInfo = ExceptionInfo;

    NtQuerySystemInformation(
       SystemPerformanceInformation,
       &PerfInfo,
       sizeof(PerfInfo),
       NULL
    );

    PreviousPerfInfo = PerfInfo;

    NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    NumberOfProcessors = BasicInfo.NumberOfProcessors;

    if (NumberOfProcessors > MAX_PROCESSOR) {
        return(0);
    }

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    PPerfInfo = ProcessorInfo;

    PreviousInterruptCount = 0;

    for (i=0; i < NumberOfProcessors; i++) {

        PreviousInterruptCount           += PPerfInfo->InterruptCount;
        PreviousCpuData[i].KernelTime     = PPerfInfo->KernelTime;
        PreviousCpuData[i].UserTime       = PPerfInfo->UserTime;
        PreviousCpuData[i].IdleTime       = PPerfInfo->IdleTime;
        PreviousCpuData[i].DpcTime        = PPerfInfo->DpcTime;
        PreviousCpuData[i].InterruptTime  = PPerfInfo->InterruptTime;
	PreviousCpuData[i].InterruptCount = PPerfInfo->InterruptCount;

        PPerfInfo++;
    }

    return(NumberOfProcessors);
}

BOOL
CalcCpuTime(
   PDISPLAY_ITEM PerfListItem
   )

/*++

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Return Value:


Revision History:

      10-21-91      Initial code

--*/

{

    LARGE_INTEGER   CurrentTime;
    LARGE_INTEGER   PreviousTime;
    LARGE_INTEGER   ElapsedTime;
    LARGE_INTEGER   ElapsedSystemTime;
    LARGE_INTEGER   PercentTime;
    LARGE_INTEGER   DeltaKernelTime,DeltaUserTime,DeltaIdleTime;
    LARGE_INTEGER   DeltaInterruptTime,DeltaDpcTime;
    LARGE_INTEGER   TotalElapsedTime;
    LARGE_INTEGER   TotalKernelTime;
    LARGE_INTEGER   TotalUserTime;
    LARGE_INTEGER   TotalIdleTime;
    LARGE_INTEGER   TotalDpcTime;
    LARGE_INTEGER   TotalInterruptTime;
    ULONG           ProcessCount, ThreadCount;
    ULONG           ListIndex;
    ULONG           Total;

//    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;

    //
    //   get system performance info
    //

    NtQuerySystemInformation(
       SystemExceptionInformation,
       &ExceptionInfo,
       sizeof(ExceptionInfo),
       NULL
    );

    NtQuerySystemInformation(
       SystemPerformanceInformation,
       &PerfInfo,
       sizeof(PerfInfo),
       NULL
    );

    NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAX_PROCESSOR,
       NULL
    );

    ObjectInfo = (POBJECT_TYPE_INFORMATION)Buffer;
    NtQueryObject( NtCurrentProcess(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );

    ProcessCount = ObjectInfo->TotalNumberOfObjects;

    NtQueryObject( NtCurrentThread(),
                       ObjectTypeInformation,
                       ObjectInfo,
                       sizeof( Buffer ),
                       NULL
                     );

    ThreadCount = ObjectInfo->TotalNumberOfObjects;

    //
    //  calculate Kernel,User,Total times for each CPU.
    //  SUM the interrupt count accross all CPUs
    //

    InterruptCount = 0;

    TotalElapsedTime.QuadPart = 0;
    TotalKernelTime  = TotalElapsedTime;
    TotalUserTime    = TotalElapsedTime;
    TotalIdleTime    = TotalElapsedTime;
    TotalInterruptTime = TotalElapsedTime;
    TotalDpcTime     = TotalElapsedTime;

    for (ListIndex=0;ListIndex<MAX_PROCESSOR;ListIndex++) {

        //
        //  Increment the interrupt count for each processor
        //

        InterruptCount += ProcessorInfo[ListIndex].InterruptCount;

        //
        //  Calculate the % kernel,user,total for each CPU.
	//
	//  Note that DPC and Interrupt time are charged against kernel time
	//  already.
        //

        PreviousTime.QuadPart = PreviousCpuData[ListIndex].KernelTime.QuadPart+
                        PreviousCpuData[ListIndex].UserTime.QuadPart;


        CurrentTime.QuadPart  = ProcessorInfo[ListIndex].KernelTime.QuadPart+
                        ProcessorInfo[ListIndex].UserTime.QuadPart;

        ElapsedSystemTime.QuadPart = CurrentTime.QuadPart - PreviousTime.QuadPart;

        //
        //  UserTime =      (User) *100
        //              ----------------
        //               Kernel + User
        //
        //
        //                        Idle *100
        //  TotalTime = 100 -  --------------
        //                      Kernel + User
        //
        //
        //
        //                   (Kernel - Idle - DPC - Interrupt)*100
        //  KernelTime =     -------------------
        //                     Kernel + User
        //

        DeltaUserTime.QuadPart = ProcessorInfo[ListIndex].UserTime.QuadPart -
                        PreviousCpuData[ListIndex].UserTime.QuadPart;

        DeltaIdleTime.QuadPart = ProcessorInfo[ListIndex].IdleTime.QuadPart -
                        PreviousCpuData[ListIndex].IdleTime.QuadPart;

        DeltaDpcTime.QuadPart = ProcessorInfo[ListIndex].DpcTime.QuadPart -
                        PreviousCpuData[ListIndex].DpcTime.QuadPart;

	DeltaInterruptTime.QuadPart = ProcessorInfo[ListIndex].InterruptTime.QuadPart -
                        PreviousCpuData[ListIndex].InterruptTime.QuadPart;

        DeltaKernelTime.QuadPart = ProcessorInfo[ListIndex].KernelTime.QuadPart -
                        PreviousCpuData[ListIndex].KernelTime.QuadPart;

        DeltaKernelTime.QuadPart = DeltaKernelTime.QuadPart -
                        DeltaIdleTime.QuadPart -
			DeltaDpcTime.QuadPart -
			DeltaInterruptTime.QuadPart;

        //
        // accumulate per CPU information for the Total CPU field
        //

        TotalElapsedTime.QuadPart += ElapsedSystemTime.QuadPart;
        TotalIdleTime.QuadPart += DeltaIdleTime.QuadPart;
        TotalUserTime.QuadPart += DeltaUserTime.QuadPart;
        TotalKernelTime.QuadPart += DeltaKernelTime.QuadPart;
        TotalDpcTime.QuadPart += DeltaDpcTime.QuadPart;
        TotalInterruptTime.QuadPart += DeltaInterruptTime.QuadPart;

	//
        //  Update old time value entries
        //

        PreviousCpuData[ListIndex].UserTime     = ProcessorInfo[ListIndex].UserTime;
        PreviousCpuData[ListIndex].KernelTime   = ProcessorInfo[ListIndex].KernelTime;
        PreviousCpuData[ListIndex].IdleTime     = ProcessorInfo[ListIndex].IdleTime;
        PreviousCpuData[ListIndex].DpcTime      = ProcessorInfo[ListIndex].DpcTime;
        PreviousCpuData[ListIndex].InterruptTime= ProcessorInfo[ListIndex].InterruptTime;

        //
        // If the elapsed system time is not zero, then compute the percentage
        // of time spent in user, kernel, DPC, and interupt mode. Otherwise, default the time
        // to zero.
        //

        if (ElapsedSystemTime.QuadPart != 0) {

            //
            //  Calculate User Time %
            //

            ElapsedTime.QuadPart = DeltaUserTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save User Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],PercentTime.LowPart,NULL);

            //
            //  Calculate Total Cpu time
            //

            ElapsedTime.QuadPart = DeltaIdleTime.QuadPart*100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save Total Time
            //

            Total = 100 - PercentTime.LowPart;
            if (Total > 100) {
                Total  = 100;
            }

            UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],Total,NULL);

            //
            //  Calculate Kernel Time %
            //

            ElapsedTime.QuadPart = DeltaKernelTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save Kernel Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],PercentTime.LowPart,NULL);

            //
            //  Calculate DPC Time %
            //

            ElapsedTime.QuadPart = DeltaDpcTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save DPC Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],PercentTime.LowPart,NULL);

	    //
            //  Calculate Interrupt Time %
            //

            ElapsedTime.QuadPart = DeltaInterruptTime.QuadPart * 100;
            PercentTime.QuadPart = ElapsedTime.QuadPart / ElapsedSystemTime.QuadPart;

            //
            //  Save DPC Time
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],PercentTime.LowPart,NULL);

        } else {

            //
            // Set percentage of user and kernel time to zero.
            //

            UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],100,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],0,NULL);
            UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],0,NULL);
        }
    }

    //
    //  save pagefaults and update next entry
    //

    PerfListItem[ListIndex].ChangeScale  = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.PageFaultCount - PreviousPerfInfo.PageFaultCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save pages available
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.AvailablePages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save context switch count per interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.ContextSwitches - PreviousPerfInfo.ContextSwitches)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save first level TB fills per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.FirstLevelTbFills - PreviousPerfInfo.FirstLevelTbFills)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save second level tb fills per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.SecondLevelTbFills - PreviousPerfInfo.SecondLevelTbFills)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save system calls per time interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (PerfInfo.SystemCalls - PreviousPerfInfo.SystemCalls)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;


    //
    //  save interrupt count per interval
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (InterruptCount - PreviousInterruptCount)/DELAY_SECONDS,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save paged pool pages
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.PagedPoolPages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save non-paged pool pages
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    PerfInfo.NonPagedPoolPages,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save Process count
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    ProcessCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save ThreadCount
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    ThreadCount,
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save alignment fixup count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.AlignmentFixupCount -
                        PreviousExceptionInfo.AlignmentFixupCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save exception dispatch count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.ExceptionDispatchCount -
                        PreviousExceptionInfo.ExceptionDispatchCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    //  save floating emulation count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.FloatingEmulationCount -
                        PreviousExceptionInfo.FloatingEmulationCount),
                    &PerfListItem[ListIndex].Max);

    ListIndex++;

    //
    //  save byte/word emulation count per period
    //

    PerfListItem[ListIndex].ChangeScale = UpdatePerfInfo(
                    &PerfListItem[ListIndex].TotalTime[0],
                    (ExceptionInfo.ByteWordEmulationCount -
                        PreviousExceptionInfo.ByteWordEmulationCount),
                    &PerfListItem[ListIndex].Max);
    ListIndex++;

    //
    // If the elapsed system time is not zero, then compute the percentage
    // of time spent in user and kdrnel mode. Otherwise, default the time
    // to zero.
    //

    if (TotalElapsedTime.QuadPart != 0) {

        //
        //  Calculate and save total CPU value
        //

        ElapsedTime.QuadPart = TotalUserTime.QuadPart * 100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalKernelTime.QuadPart * 100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalIdleTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;

        //
        //  Save Total Time
        //

        Total = 100 - PercentTime.LowPart;
        if (Total > 100) {
            Total  = 100;
        }

        UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],Total,NULL);

        ElapsedTime.QuadPart = TotalDpcTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],PercentTime.LowPart,NULL);

        ElapsedTime.QuadPart = TotalInterruptTime.QuadPart *100;
        PercentTime.QuadPart = ElapsedTime.QuadPart / TotalElapsedTime.QuadPart;
        UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],PercentTime.LowPart,NULL);

    } else {

        //
        // Set percentage of user and kernel time to zero.
        //

        UpdatePerfInfo(&PerfListItem[ListIndex].UserTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].KernelTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].DpcTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].InterruptTime[0],0,NULL);
        UpdatePerfInfo(&PerfListItem[ListIndex].TotalTime[0],100,NULL);
    }

    //
    // done with setting values, save settings and return
    //

    PreviousExceptionInfo = ExceptionInfo;
    PreviousPerfInfo = PerfInfo;
    PreviousInterruptCount = InterruptCount;
    return(TRUE);
}


BOOL
UpdatePerfInfo(
   PULONG    DataPointer,
   ULONG     NewDataValue,
   PULONG    OldMaxValue
   )

/*++

Routine Description:

    Shift array of DATA_LIST_LENGTH USORTS and add the new value to the
    start of list

Arguments:

    DataPointer  - Pointer to the start of a DATA_LIST_LENGTH array
    NewDataValue - Data element to be added
    OldMaxValue  - Scale value

Return Value:

    TRUE is MaxValue must be increased or decreased

Revision History:

      10-21-91      Initial code

--*/

{

    ULONG   Index;
    ULONG   ScanMax;

    //
    //  Shift DataArray while keeping track of the max value
    //
    //  Set temp max to 100 to init a minimum maximum
    //

    ScanMax = 100;
    for (Index=DATA_LIST_LENGTH-1;Index>=1;Index--) {
        DataPointer[Index] = DataPointer[Index-1];
        if (DataPointer[Index] > ScanMax) {
            ScanMax = DataPointer[Index];
        }
    }

    //
    // add and check first value
    //

    DataPointer[0] = NewDataValue;
    if (NewDataValue > ScanMax) {
        ScanMax = NewDataValue;
    }

    //
    //  If OldMaxValue = NULL then do not do a max limit check
    //

    if (OldMaxValue == NULL) {
        return(FALSE);
    }

    //
    //  If Max values changed then undate the new max
    //  value and return TRUE.
    //

    if (ScanMax != *OldMaxValue) {
        *OldMaxValue = ScanMax;
        return(TRUE);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wperf\wperf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

   Wperf.c

Abstract:

   Win32 application to display performance statictics.

Author:

   Mark Enstrom  (marke)

Environment:

   Win32

Revision History:

   10-20-91     Initial version



--*/

//
// set variable to define global variables
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <errno.h>
#include "wperf.h"

//
// global handles
//

HANDLE  hInst;

//
// Selected Display Mode (read from wp2.ini), default set here.
//

DISPLAY_ITEM    PerfDataList[SAVE_SUBJECTS];
WINPERF_INFO    WinperfInfo;

//
// Window names
//

PUCHAR PerfNames[] = {
    "CPU0",
    "CPU1",
    "CPU2",
    "CPU3",
    "CPU4",
    "CPU5",
    "CPU6",
    "CPU7",
    "CPU8",
    "CPU9",
    "CPU10",
    "CPU11",
    "CPU12",
    "CPU13",
    "CPU14",
    "CPU15",
    "PAGE FLT",
    "PAGES AVAIL",
    "CONTEXT SW/S",
    "1st TB MISS/S",
    "2nd TB MISS/S",
    "SYSTEM CALLS/S",
    "INTERRUPT/S",
    "PAGE POOL",
    "NON-PAGE POOL",
    "PROCESSES",
    "THREADS",
    "ALIGN FIXUP",
    "EXCEPT DSPTCH",
    "FLOAT EMULAT",
    "INSTR EMULAT",
    "CPU"
};


int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )

/*++

Routine Description:

   Windows entry point routine


Arguments:

Return Value:

   status of operation

Revision History:

      03-21-91      Initial code

--*/
{
   MSG      msg;
   HBRUSH   BackBrush;


    //
    // check for other instances of this program
    //

    BackBrush = CreateSolidBrush(RGB(192,192,192));

    if (!InitApplication(hInstance,BackBrush)) {
        //DbgPrint("Init Application fails\n");
        return (FALSE);
    }

    //
    // Perform initializations that apply to a specific instance
    //

    if (!InitInstance(hInstance, nCmdShow)){
        return (FALSE);
    }

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //

    while (GetMessage(&msg,        // message structure
            NULL,                  // handle of window receiving the message
            0,                     // lowest message to examine
            0))                    // highest message to examine
        {
        TranslateMessage(&msg);    // Translates virtual key codes
        DispatchMessage(&msg);     // Dispatches message to window
    }

    DeleteObject(BackBrush);

    return (int)(msg.wParam);      // Returns the value from PostQuitMessage
}

BOOL
InitApplication(
    HANDLE  hInstance,
    HBRUSH  hBackground
    )

/*++

Routine Description:

   Initializes window data and registers window class.

Arguments:

   hInstance   - current instance
   hBackground - background fill brush

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    WNDCLASS  wc;
    BOOL      ReturnStatus;

    //
    // Fill in window class structure with parameters that describe the
    // main window.
    //

    wc.style         = CS_DBLCLKS;                          // Class style(s).
    wc.lpfnWndProc   = MainWndProc;                         // Function to retrieve messages for
                                                            // windows of this class.
    wc.cbClsExtra    = 0;                                   // No per-class extra data.
    wc.cbWndExtra    = 0;                                   // No per-window extra data.
    wc.hInstance     = hInstance;                           // Application that owns the class.
    wc.hIcon         = LoadIcon(hInstance,                  //
                            MAKEINTRESOURCE(WINPERF_ICON)); // Load Winperf icon
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);         // Load default cursor
    wc.hbrBackground = hBackground;;                        // Use background passed to routine
    wc.lpszMenuName  = "winperfMenu";                       // Name of menu resource in .RC file.
    wc.lpszClassName = "WinPerfClass";                      // Name used in call to CreateWindow.

    ReturnStatus = RegisterClass(&wc);
    return(ReturnStatus);
}

BOOL
InitInstance(
    HANDLE hInstance,
    int nCmdShow
    )

/*++

Routine Description:

   Save instance handle and create main window. This function performs
   initialization tasks that cannot be shared by multiple instances.

Arguments:

    hInstance - Current instance identifier.
    nCmdShow  - Param for first ShowWindow() call.

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    DWORD   WindowStyle;

    //
    // Save the instance handle in a static variable, which will be used in
    // many subsequent calls from this application to Windows.
    //

    hInst = hInstance;

    //
    // init the window position and size to be in the upper corner of
    // the screen, 200x100
    //
    //  What I want here is a way to get the WINDOW dimensions
    //

    WinperfInfo.WindowPositionX = 640 - 200;
    WinperfInfo.WindowPositionY = 0;
    WinperfInfo.WindowSizeX     = 200;
    WinperfInfo.WindowSizeY     = 100;
    WinperfInfo.CpuStyle        = CPU_STYLE_LINE;

    //
    //  read profile data from .ini file
    //

    InitProfileData(&WinperfInfo);
    WinperfInfo.hMenu = LoadMenu(hInstance,"winperfMenu");

    //
    // Create a main window for this application instance.
    //

    WinperfInfo.hWndMain = CreateWindow(
        "WinPerfClass",                 // See RegisterClass() call.
        "Perf Meter",                   // Text for window title bar.
        WS_OVERLAPPEDWINDOW,            // window style
        WinperfInfo.WindowPositionX,    // Default horizontal position.
        WinperfInfo.WindowPositionY,    // Default vertical position.
        WinperfInfo.WindowSizeX,        // Default width.
        WinperfInfo.WindowSizeY,        // Default height.
        NULL,                           // Overlapped windows have no parent.
        NULL,                           // Use the window class menu.
        hInstance,                      // This instance owns this window.
        NULL                            // Pointer not needed.
    );

    //
    // Decide on whether or not to display the menu and caption
    // based on the window class read from the .ini file
    //

    if (WinperfInfo.DisplayMode==STYLE_ENABLE_MENU) {
        WinperfInfo.DisplayMenu = TRUE;

    } else {
        WinperfInfo.DisplayMenu = FALSE;
        WindowStyle = GetWindowLong(WinperfInfo.hWndMain,GWL_STYLE);
        WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
        SetWindowPos(WinperfInfo.hWndMain, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
        SetWindowLong(WinperfInfo.hWndMain,GWL_STYLE,WindowStyle);
        SetMenu(WinperfInfo.hWndMain,NULL);
    }

    //
    // If window could not be created, return "failure"
    //

    if (!WinperfInfo.hWndMain) {
      return (FALSE);
    }

    //
    // Make the window visible; update its client area; and return "success"
    //

    SetFocus(WinperfInfo.hWndMain);
    ShowWindow(WinperfInfo.hWndMain, SW_SHOWNORMAL);
    UpdateWindow(WinperfInfo.hWndMain);

    return (TRUE);
}

LRESULT APIENTRY
MainWndProc(
   HWND   hWnd,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process messages.

Arguments:

   hWnd    - window hande
   message - type of message
   wParam  - additional information
   lParam  - additional information

Return Value:

   status of operation

Revision History:

      02-17-91      Initial code

--*/

{

    PAINTSTRUCT   ps;

    //
    //   process each message
    //

    switch (message) {

        //
        // create window
        //

        case WM_CREATE:
        {
            HDC hDC = GetDC(hWnd);
            BOOLEAN   Fit;
            UINT      Index;


            //
            // make brushes and pens
            //

            WinperfInfo.hBluePen     = CreatePen(PS_SOLID,1,RGB(000,000,128));
            WinperfInfo.hRedPen      = CreatePen(PS_SOLID,1,RGB(255,000,000));
            WinperfInfo.hGreenPen    = CreatePen(PS_SOLID,1,RGB(000,255,000));
            WinperfInfo.hMagentaPen  = CreatePen(PS_SOLID,1,RGB(255,000,254));
            WinperfInfo.hYellowPen   = CreatePen(PS_SOLID,1,RGB(255,255,000));
            WinperfInfo.hDotPen      = CreatePen(PS_DOT,1,RGB(000,000,000));

            WinperfInfo.hBackground  = CreateSolidBrush(RGB(192,192,192));
            WinperfInfo.hLightBrush  = CreateSolidBrush(RGB(255,255,255));
            WinperfInfo.hDarkBrush   = CreateSolidBrush(RGB(128,128,128));
            WinperfInfo.hRedBrush    = CreateSolidBrush(RGB(255,000,000));
            WinperfInfo.hGreenBrush  = CreateSolidBrush(RGB(000,255,000));
            WinperfInfo.hBlueBrush   = CreateSolidBrush(RGB(000,000,255));
            WinperfInfo.hMagentaBrush= CreateSolidBrush(RGB(255,000,254));
            WinperfInfo.hYellowBrush = CreateSolidBrush(RGB(255,255,000));

            //
            //  create thee fonts using NT default font families
            //

            WinperfInfo.SmallFont      = CreateFont(8,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Small Fonts");

            WinperfInfo.MediumFont      = CreateFont(10,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");

            WinperfInfo.LargeFont      = CreateFont(14,
                                 0,
                                 0,
                                 0,
                                 400,
                                 FALSE,
                                 FALSE,
                                 FALSE,
                                 ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS,
                                 DRAFT_QUALITY,
                                 DEFAULT_PITCH,
                                 "Times New Roman");


            //
            // create a system timer event to call performance gathering routines by.
            //

            WinperfInfo.TimerId = SetTimer(hWnd,
                                           TIMER_ID,
                                           1000 * DELAY_SECONDS,
                                           NULL);

            //
            // init display variables
            //

            InitPerfWindowDisplay(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            //
            //  Fit the perf windows into the main window
            //

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                //DbgPrint("FitPerfWindows Fails         !\n");
            }

            for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                CalcDrawFrame(&PerfDataList[Index]);


                if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                    MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }

            }

            //
            // init performance routines
            //

            WinperfInfo.NumberOfProcessors = InitPerfInfo();

            //
            // release the DC handle
            //

            ReleaseDC(hWnd,hDC);

      }
      break;

      //
      // re-size
      //

      case WM_SIZE:

      {
            int     i;
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;
            BOOLEAN Fit;

            //DbgPrint("WM_SIZE display active[0] = %i\n",(int)PerfDataList[0].Display);

            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            Fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

            if (!Fit) {
                //DbgPrint("WM_SIZE error, FitPerf returns FALSE\n");
            }

            for (i=0;i<SAVE_SUBJECTS;i++) {
                DeleteMemoryContext(&PerfDataList[i]);
                CalcDrawFrame(&PerfDataList[i]);

                if (!CreateMemoryContext(hDC,&PerfDataList[i])) {
                    MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                    DestroyWindow(hWnd);
                    break;
                }
            }

            //
            // force window to be re-painted
            //

            InvalidateRect(hWnd,NULL,TRUE);

            //
            // release the DC handle
            //


            ReleaseDC(hWnd,hDC);



      }
      break;

      case WM_MOVE:
      {
            HDC     hDC = GetDC(hWnd);
            RECT    ClientRect;


            //
            // get size of cleint area
            //

            GetWindowRect(hWnd,&ClientRect);

            WinperfInfo.WindowPositionX = ClientRect.left;
            WinperfInfo.WindowPositionY = ClientRect.top;
            WinperfInfo.WindowSizeX     = ClientRect.right  - ClientRect.left;
            WinperfInfo.WindowSizeY     = ClientRect.bottom - ClientRect.top;

            ReleaseDC(hWnd,hDC);

      }

      break;


      //
      // command from application menu
      //

    case WM_COMMAND:



            switch (wParam){

               //
               // exit window
               //

               case IDM_EXIT:

                  DestroyWindow(hWnd);
                  break;

               //
               // about command
               //

            case IDM_SELECT:
            {
                HDC     hDC = GetDC(hWnd);
                INT_PTR DialogResult;
                int Index;
                BOOLEAN fit;

                DialogResult = DialogBox(hInst,
                                         MAKEINTRESOURCE(IDM_SEL_DLG),
                                         hWnd,
                                         SelectDlgProc);

                if (DialogResult == DIALOG_SUCCESS) {

                    fit = FitPerfWindows(hWnd,hDC,PerfDataList,SAVE_SUBJECTS);

                    if (!fit) {
                        //DbgPrint("Fit Fails\n");
                    }

                    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                        DeleteMemoryContext(&PerfDataList[Index]);
                        CalcDrawFrame(&PerfDataList[Index]);

                        if (!CreateMemoryContext(hDC,&PerfDataList[Index])) {
                            MessageBox(hWnd,"Error Allocating Memory","Winperf",MB_OK);
                            DestroyWindow(hWnd);
                            break;
                        }
                    }

                    InvalidateRect(hWnd,NULL,TRUE);

                }

                ReleaseDC(hWnd,hDC);
            }

            break;


            default:
                return (DefWindowProc(hWnd, message, wParam, lParam));
            }

            break;

        case WM_PAINT:

            //
            // repaint the window
            //

            {

                int i;
                HDC hDC = BeginPaint(hWnd,&ps);



                SelectObject(hDC,GetStockObject(NULL_BRUSH));

                for (i=0;i<SAVE_SUBJECTS;i++) {

                    if (PerfDataList[i].Display == TRUE) {

                        DrawFrame(hDC,&PerfDataList[i]);

                        //
                        //  Draw each item, for CPU items decide whether to draw
                        //  line graphs or CPU bar graphs
                        //

                        if (
                            ((i < MAX_PROCESSOR) || (i == (IDM_CPU_TOTAL - IDM_CPU0))) &&
                            (WinperfInfo.CpuStyle == CPU_STYLE_BAR)
                           ) {

                            DrawCpuBarGraph(hDC,&PerfDataList[i],i);

                        } else {

                            DrawPerfText(hDC,&PerfDataList[i],i);
                            DrawPerfGraph(hDC,&PerfDataList[i]);
                        }

                    }
                }

                EndPaint(hWnd,&ps);

            }
            break;


        case WM_TIMER:
        {
            int i;
            HDC hDC = GetDC(hWnd);

            CalcCpuTime(PerfDataList);

            //
            // update all performance information
            //

            for (i=0;i<SAVE_SUBJECTS;i++) {

                if (PerfDataList[i].Display == TRUE) {

                    //
                    // for cpu0-7 and cpu total, check for cpu bar graph or
                    // cpu line graph
                    //

                    if (
                        ((i < MAX_PROCESSOR) || (i == (IDM_CPU_TOTAL - IDM_CPU0))) &&
                        (WinperfInfo.CpuStyle == CPU_STYLE_BAR)
                       ) {

                        DrawCpuBarGraph(hDC,&PerfDataList[i],i);

                    } else {


                        DrawPerfText(hDC,&PerfDataList[i],i);

                        if (PerfDataList[i].ChangeScale) {
                            DrawPerfGraph(hDC,&PerfDataList[i]);
                        } else {
                            ShiftPerfGraph(hDC,&PerfDataList[i]);
                        }

                    }

                }
            }


            ReleaseDC(hWnd,hDC);

        }
        break;

        //
        // handle a double click
        //

        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            DWORD   WindowStyle;


            //
            // get old window style, take out caption and menu
            //

            if (!IsIconic(hWnd)) {

                if (WinperfInfo.DisplayMenu) {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle &  (~STYLE_ENABLE_MENU)) | STYLE_DISABLE_MENU;
                    SetMenu(hWnd,NULL);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_DISABLE_MENU;
                    WinperfInfo.DisplayMenu = FALSE;

                } else {
                    WindowStyle = GetWindowLong(hWnd,GWL_STYLE);
                    WindowStyle = (WindowStyle & (~STYLE_DISABLE_MENU)) | STYLE_ENABLE_MENU;
                    SetMenu(hWnd,WinperfInfo.hMenu);
                    SetWindowLong(hWnd,GWL_STYLE,WindowStyle);
                    SetWindowPos(hWnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_DRAWFRAME);
                    ShowWindow(hWnd,SW_SHOW);
                    WinperfInfo.DisplayMode=STYLE_ENABLE_MENU;
                    WinperfInfo.DisplayMenu = TRUE;
                }
            } else {
                DefWindowProc(hWnd, message, wParam, lParam);
            }


        }
        break;

        //
        //  enable dragging with mouse in non-client
        //

        case WM_NCHITTEST:
        {

            lParam = DefWindowProc(hWnd, message, wParam, lParam);
            if ((WinperfInfo.DisplayMenu==FALSE) && (lParam == HTCLIENT)) {
                return(HTCAPTION);
            } else {
                return(lParam);
            }


        }
        break;

        case WM_DESTROY:
        {
            UINT    Index;

            //
            // Save profile info
            //

            SaveProfileData(&WinperfInfo);

            //
            // Delete Windows Objects
            //

            KillTimer(hWnd,TIMER_ID);

            DeleteObject(WinperfInfo.hRedPen);
            DeleteObject(WinperfInfo.hGreenPen);
            DeleteObject(WinperfInfo.hBluePen);
            DeleteObject(WinperfInfo.hYellowPen);
            DeleteObject(WinperfInfo.hMagentaPen);
            DeleteObject(WinperfInfo.hDotPen);

	    DeleteObject(WinperfInfo.hBackground);
            DeleteObject(WinperfInfo.hLightBrush);
            DeleteObject(WinperfInfo.hDarkBrush);
            DeleteObject(WinperfInfo.hRedBrush);
            DeleteObject(WinperfInfo.hGreenBrush);
            DeleteObject(WinperfInfo.hBlueBrush);
            DeleteObject(WinperfInfo.hMagentaBrush);
            DeleteObject(WinperfInfo.hYellowBrush);

            for (Index=0;Index<SAVE_SUBJECTS;Index++ ) {
                DeleteMemoryContext(&PerfDataList[Index]);
            }

            //
            // Destroy window
            //

            PostQuitMessage(0);
         }
         break;


        default:

            //
            // Passes message on if unproccessed
            //

            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return 0;
}



INT_PTR
APIENTRY SelectDlgProc(
   HWND hDlg,
   UINT message,
   WPARAM wParam,
   LPARAM lParam
   )

/*++

Routine Description:

   Process message for select dialog box.

Arguments:

   hDlg    - window handle of the dialog box
   message - type of message
   wParam  - message-specific information
   lParam  - message-specific information

Return Value:

   status of operation


Revision History:

      03-21-91      Initial code

--*/

{
    UINT    ButtonState;
    UINT    Index;

    switch (message) {
    case WM_INITDIALOG:

        //
        // Init Buttons with PerfDataList Structure
        //

        for (Index = 0; Index< SAVE_SUBJECTS; Index++) {
            if (Index < MAX_PROCESSOR) {
                if (Index < WinperfInfo.NumberOfProcessors) {
                    if (PerfDataList[Index].Display == TRUE) {
                        SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,1,0);

                    } else {
                        SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,0,0);
                    }

                } else {

                    //
                    // Disable display if > WinperfInfo.NumberOfProcessors
                    //
                    // Also Disable radio button
                    //

                    PerfDataList[Index].Display = FALSE;
                    EnableWindow(GetDlgItem(hDlg,IDM_CPU0+Index),FALSE);
                }

            } else {

                //
                // Set or clear radio button based on display variable
                //

                if (PerfDataList[Index].Display == TRUE) {
                    SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,1,0);

                } else {
                    SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_SETCHECK,0,0);
                }
            }
        }

        //
        // Beyond the end of the save subjects lies the cpu Style, set this to either style
        //

        if (WinperfInfo.CpuStyle == CPU_STYLE_LINE) {
            CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_LINE);

        } else {
            CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_BAR);
        }

        return (TRUE);

    case WM_COMMAND:

           switch(wParam) {

               //
               // end function
               //

           case IDOK:


                for (Index=0;Index<SAVE_SUBJECTS;Index++) {
                   ButtonState = (UINT)SendDlgItemMessage(hDlg,IDM_CPU0+Index,BM_GETCHECK,0,0);
                   if (ButtonState == 1) {
                       PerfDataList[Index].Display = TRUE;
                       WinperfInfo.DisplayElement[Index] = 1;

                   } else {
                       PerfDataList[Index].Display = FALSE;
                       WinperfInfo.DisplayElement[Index] = 0;
                   }

                }

                //
                // Check CPU bar graph
                //

                ButtonState = IsDlgButtonChecked(hDlg,IDM_SEL_LINE);
                if (ButtonState == 1) {
                    WinperfInfo.CpuStyle = CPU_STYLE_LINE;

                } else {
                    WinperfInfo.CpuStyle = CPU_STYLE_BAR;
                }

                EndDialog(hDlg, DIALOG_SUCCESS);
                return (TRUE);

           case IDCANCEL:

                EndDialog(hDlg, DIALOG_CANCEL );
                return (TRUE);

            //
            // CPU STYLE
            //

            case IDM_SEL_LINE:
                CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_LINE);
                return(TRUE);

            case IDM_SEL_BAR:
                CheckRadioButton(hDlg,IDM_SEL_LINE,IDM_SEL_BAR,IDM_SEL_BAR);
                return(TRUE);
        }

    }
    return (FALSE);
}

VOID
InitProfileData(
    PWINPERF_INFO pWinperfInfo
    )

/*++

Routine Description:

    Attempt tp read the following fields from the winperf.ini file

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None, values are set to default before a call to this operation. If there is a problem then
    default:values are left unchanged.

Revision History:

      02-17-91      Initial code

--*/

{

    DWORD   PositionX,PositionY,SizeX,SizeY,Mode,Index,Element[SAVE_SUBJECTS],CpuStyle;
    UCHAR   TempStr[256];

    PositionX = GetPrivateProfileInt("winperf","PositionX"  ,pWinperfInfo->WindowPositionX,"winperf.ini");
    PositionY = GetPrivateProfileInt("winperf","PositionY"  ,pWinperfInfo->WindowPositionY,"winperf.ini");
    SizeX     = GetPrivateProfileInt("winperf","SizeX"      ,pWinperfInfo->WindowSizeX    ,"winperf.ini");
    SizeY     = GetPrivateProfileInt("winperf","SizeY"      ,pWinperfInfo->WindowSizeY    ,"winperf.ini");

    //
    // read the first deiplay element with default 1
    //

    Element[0] = GetPrivateProfileInt("winperf","DisplayElement0",1,"winperf.ini");

    //
    // read the rest of the display elements with default 0
    //

    for (Index=1;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"DisplayElement%i",Index);
        Element[Index] = GetPrivateProfileInt("winperf",TempStr,0,"winperf.ini");
    }

    Mode      = GetPrivateProfileInt("winperf","DisplayMode",pWinperfInfo->DisplayMode    ,"winperf.ini");
    CpuStyle  = GetPrivateProfileInt("winperf","CpuStyle",pWinperfInfo->CpuStyle    ,"winperf.ini");

    pWinperfInfo->WindowPositionX = PositionX;
    pWinperfInfo->WindowPositionY = PositionY;
    pWinperfInfo->WindowSizeX     = SizeX;
    pWinperfInfo->WindowSizeY     = SizeY;

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        pWinperfInfo->DisplayElement[Index] = Element[Index];
    }
    pWinperfInfo->DisplayMode     = Mode;
    pWinperfInfo->CpuStyle        = CpuStyle;
}

VOID
SaveProfileData(
    PWINPERF_INFO pWinperfInfo
    )

/*++

Routine Description:

    Save profile data

Arguments:

    WindowPositionX - Window initial x position
    WindowPositionY - Window initial y position
    WindowSizeX     - Window initial width
    WindowSizey     - Window Initial height
    DisplayMode     - Window initial display mode

Return Value:


    None.

Revision History:

      02-17-91      Initial code

--*/

{
    UCHAR    TempStr[50],TempName[50];
    UINT     Index;

    wsprintf(TempStr,"%i",pWinperfInfo->WindowPositionX);
    WritePrivateProfileString("winperf","PositionX",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowPositionY);
    WritePrivateProfileString("winperf","PositionY",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowSizeX);
    WritePrivateProfileString("winperf","SizeX",TempStr,"winperf.ini");

    wsprintf(TempStr,"%i",pWinperfInfo->WindowSizeY);
    WritePrivateProfileString("winperf","SizeY",TempStr,"winperf.ini");

    for (Index=0;Index<SAVE_SUBJECTS;Index++) {
        wsprintf(TempStr,"%li",pWinperfInfo->DisplayElement[Index]);
        wsprintf(TempName,"DisplayElement%li",Index);
        WritePrivateProfileString("winperf",TempName,TempStr,"winperf.ini");

    }


    wsprintf(TempStr,"%li",pWinperfInfo->DisplayMode);
    WritePrivateProfileString("winperf","DisplayMode",TempStr,"winperf.ini");

    wsprintf(TempStr,"%li",pWinperfInfo->CpuStyle);
    WritePrivateProfileString("winperf","CpuStyle",TempStr,"winperf.ini");

}









BOOLEAN
InitPerfWindowDisplay(
    IN  HWND            hWnd,
    IN  HDC             hDC,
    IN  PDISPLAY_ITEM   DisplayItems,
    IN  ULONG           NumberOfWindows
    )

/*++

Routine Description:

    Init All perf windows to active, init data

Arguments:

    hDC             -   Screen context
    DisplayItems    -   List of display structures
    NumberOfWindows -   Number of sub-windows

Return Value:

    Status

Revision History:

      02-17-91      Initial code

--*/
{
    int     Index1;
    UINT    Index;

    for (Index=0;Index<NumberOfWindows;Index++) {

        if (WinperfInfo.DisplayElement[Index] == 0) {
            DisplayItems[Index].Display = FALSE;
        } else {
            DisplayItems[Index].Display = TRUE;
        }

        DisplayItems[Index].CurrentDrawingPos = 0;

        if (Index < MAX_PROCESSOR) {
            DisplayItems[Index].NumberOfElements = 3;
            DisplayItems[Index].Max = 100;
        } else if (Index == (IDM_CPU_TOTAL - IDM_CPU0)) {
            DisplayItems[Index].NumberOfElements = 3;
            DisplayItems[Index].Max = 100;
        } else {
            DisplayItems[Index].NumberOfElements = 1;
        }


        for (Index1=0;Index1<DATA_LIST_LENGTH;Index1++) {
            DisplayItems[Index].KernelTime[Index1] = 0;
            DisplayItems[Index].UserTime[Index1] = 0;
            DisplayItems[Index].DpcTime[Index1] = 0;
            DisplayItems[Index].InterruptTime[Index1] = 0;
            DisplayItems[Index].TotalTime[Index1] = 0;
        }
    }

    return(TRUE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ws\ws.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ws.c

Abstract:

    Utility program to set both the console window size and buffer size.

Author:

    Steve Wood (stevewo) 01-Feb-1992

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <ctype.h>
#include <string.h>

void
Usage()
{
    printf("Usage: ws [-w WindowColumns,WindowRows][-b BufferColumns,BufferRows]\n");
    exit(1);
}

__cdecl main( argc, argv )
int argc;
char *argv[];
{
    int i;
    char *s;
    HANDLE ScreenHandle;
    DWORD WindowRows,WindowColumns;
    DWORD BufferRows,BufferColumns;
    COORD BufferSize;
    CONSOLE_SCREEN_BUFFER_INFO sbi;
    SMALL_RECT WindowSize;
    COORD LargestScreenSize;
    USHORT MaxRows;
    USHORT MaxCols;

    ScreenHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (!GetConsoleScreenBufferInfo( ScreenHandle, &sbi )) {
        fprintf( stderr, "WS: Unable to read current console mode.\n" );
        exit( 1 );
        }

    BufferRows = sbi.dwSize.Y;
    BufferColumns = sbi.dwSize.X;
    WindowRows = sbi.srWindow.Bottom - sbi.srWindow.Top + 1;
    WindowColumns = sbi.srWindow.Right - sbi.srWindow.Left + 1;
    LargestScreenSize = GetLargestConsoleWindowSize( ScreenHandle );

    try {
        for (i=1; i<argc; i++) {
            s = argv[ i ];
            if (*s == '-' || *s == '/') {
                s++;
                switch( tolower( *s ) ) {

                    //
                    // Set window size
                    //

                    case 'w':
                        if (sscanf( argv[++i], "%d,%d", &WindowColumns, &WindowRows ) != 2) {
                            printf("Invalid usage\n");
                            Usage();
                        }
                        break;

                    //
                    // Set buffer size
                    //

                    case 'b':
                        if (sscanf( argv[++i], "%d,%d", &BufferColumns, &BufferRows ) != 2) {
                            printf("Invalid usage\n");
                            Usage();
                        }
                        break;


                    default:
                        Usage();
                    }
                }
            else {
                printf( "Error - argv[ %u ]: %s\n", i, argv[ i ] );
                Usage();
                }
            }
        }
    except ( EXCEPTION_EXECUTE_HANDLER ) {
        Usage();
        }

    MaxRows = (USHORT)min( (int)WindowRows, (int)(sbi.dwSize.Y) );
    MaxRows = (USHORT)min( (int)MaxRows, (int)LargestScreenSize.Y );
    MaxCols = (USHORT)min( (int)WindowColumns, (int)(sbi.dwSize.X) );
    MaxCols = (USHORT)min( (int)MaxCols, (int)LargestScreenSize.X );


    WindowSize.Top = 0;
    WindowSize.Left = 0;
    WindowSize.Bottom = MaxRows - (SHORT)1;
    WindowSize.Right = MaxCols - (SHORT)1;
    SetConsoleWindowInfo( ScreenHandle, TRUE, &WindowSize );

    BufferSize.X = (SHORT)BufferColumns;
    BufferSize.Y = (SHORT)BufferRows;
    SetConsoleScreenBufferSize( ScreenHandle, BufferSize );

    printf( "WS -w %d,%d -b %d,%d\n", MaxCols, MaxRows, BufferColumns, BufferRows );
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\advert.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       advert.c
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "Remote.h"

// ===================================================
// CLIENT END OF THE MAILSLOT
// ===================================================

#define  INITIAL_AD_RATE 15*1000          //10 Sec.  REMOVE
#define  MAXIMUM_AD_RATE 45*60*1000       //1  hour
#define  INITIAL_SLEEP_PERIOD 2*60*1000   //Initial Sleep Period REMOVE - change to 5 min.
#define  KDCONNECTED TEXT("Kernel Debugger connection established.")

extern   TCHAR           SaveFileName[64];
extern   SESSION_TYPE    ClientList[10];
extern   HANDLE          ListenThreadH;

HANDLE   hRead;

HANDLE
IsConnectedToClient(
    TCHAR *ClientName
    );

BOOL
WaitForString(
    HANDLE hRead,
    TCHAR   *str
    );

VOID
InitAd(
   BOOL IsAdvertise
   );

VOID
ShutAd(
   BOOL IsAdvertise
   );

DWORD
Advertise(
    TCHAR *PipeName
    );


VOID
InitAd(
   BOOL IsAdvertise
   )
{
    if (IsAdvertise)
    {
            HANDLE hThread;
            DWORD  WhoCares;
            hThread=CreateThread
            (
                 (LPSECURITY_ATTRIBUTES)NULL,
                 0,
                 (LPTHREAD_START_ROUTINE)Advertise,
                 (LPVOID)PipeName,
                 0,
                 &WhoCares
            );
            CloseHandle(hThread);
    }

}

VOID
ShutAd(
   BOOL IsAdvertise
   )
{
    if (IsAdvertise)
        SAFECLOSEHANDLE(hRead);
}

DWORD
Advertise(
    TCHAR *PipeName
    )
{
    DWORD   WaitTime=INITIAL_AD_RATE;
    DWORD   NameLen=32;
    HANDLE  hThread;
    TCHAR    SendBuff[256];
    DWORD   tmp;
    HANDLE  hMailSlot;
    TCHAR    Hostname[32];
    Sleep(INITIAL_SLEEP_PERIOD);

    hRead=CreateFile(
                     SaveFileName,
                     GENERIC_READ|GENERIC_WRITE,
                     FILE_SHARE_READ|FILE_SHARE_WRITE,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL);

    if (hRead==INVALID_HANDLE_VALUE)
    {
        return(1);
    }

    hMailSlot=CreateFile(
                             TEXT("\\\\NTDEV\\MAILSLOT\\REMOTE\\ADVERTISE"),
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE,
                             (LPSECURITY_ATTRIBUTES)NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             (HANDLE)NULL
                            );

    if (hMailSlot==INVALID_HANDLE_VALUE)
    {
        return(2);
    }


    GetComputerName(HostName,&NameLen);
    _stprintf(SendBuff,TEXT("%.31s %.31s %.63s"),HostName,PipeName,ChildCmd);
    if (!WaitForString(hRead,KDCONNECTED))
    {
        return(1);
    }

    while(TRUE)
    {
        if (!(WriteFile(
                        hMailSlot,
                        (LPVOID)SendBuff,
                        (DWORD)_tcslen(SendBuff)+1,
                        &tmp,
                        NULL
                       )
             )
           )
        {
            //ERRORMSSG(TEXT("WriteFile Failed on Mailslot"));
            Sleep(10*60*1000);
        }
        else
        {
            Sleep(15*1000);
            while ((hThread=IsConnectedToClient(TEXT("SKYLINK")))!=NULL)
            {
                WaitForSingleObject(hThread,INFINITE);
                WaitTime=INITIAL_AD_RATE;
                WaitForString(hRead,KDCONNECTED); //REMOVE COMMENT
            }
            WaitTime=min(MAXIMUM_AD_RATE,2*WaitTime);
            Sleep(WaitTime);
        }

    }
    return(0); //Should never get here

}

BOOL
WaitForString(
    HANDLE hRead,
    TCHAR   *str
    )
{
    int   len=_tcslen(str);
    TCHAR  Buff[512];
    TCHAR  *BuffEnd=Buff;
    TCHAR  *BuffPos=Buff;
    TCHAR  *strPos=str;
    int   matchcount=0;
    BOOL  Found=FALSE;
    DWORD bytesread;

    while(!Found)
    {
        while (BuffPos==BuffEnd)
        {
            BuffPos=Buff;
            SetLastError(0);
	        if ((!ReadFile(hRead,Buff,512,&bytesread,NULL))||(bytesread==0))
            {
                if ((GetLastError()!=ERROR_HANDLE_EOF)&&(GetLastError()!=0))
                {
                    return(FALSE);
                }
                Sleep(2*60*1000);
            }
            BuffEnd=Buff+bytesread;
        }

        while(!Found && (BuffPos!=BuffEnd))
        {
            if (*(BuffPos++)==*(strPos++))
            {
                matchcount++;
                if (matchcount==len)
                    Found=TRUE;
            }
            else
            {
                matchcount=0;
                strPos=str;
            }
        }
    }
    return(Found);
}

HANDLE
IsConnectedToClient(
    TCHAR *ClientName
    )
{
    extern SESSION_TYPE ClientList[MAX_SESSION];
    int i;

    for (i=0;i<MAX_SESSION;i++)
    {
        if ((ClientList[i].Active==TRUE) &&
            (_tcscmp(ClientName,ClientList[i].Name)==0)
           )
        {
            return(ClientList[i].hThread);
        }
    }
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\remote.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    Remote.c

Abstract:

    This module contains the main() entry point for Remote.
    Calls the Server or the Client depending on the first parameter.


Author:

    Rajivendra Nath (rajnath) 2-Jan-1993

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include "Remote.h"

TCHAR   HostName[HOSTNAMELEN];
TCHAR * ChildCmd;
TCHAR*  PipeName;
TCHAR*  ServerName;
TCHAR*  Username;
TCHAR*  Password;
HANDLE  MyOutHandle;
BOOL    bIPLocked=FALSE;

BOOL   IsAdvertise=TRUE;
DWORD  ClientToServerFlag;

TCHAR* ColorList[]={
	TEXT("black"),
	TEXT("blue"),
	TEXT("green"),
	TEXT("cyan"),
	TEXT("red"),
	TEXT("purple"),
	TEXT("yellow"),
	TEXT("white"),
	TEXT("lblack"),
	TEXT("lblue"),
	TEXT("lgreen"),
	TEXT("lcyan"),
	TEXT("lred"),
	TEXT("lpurple"),
	TEXT("lyellow"),
	TEXT("lwhite")
};

WORD
GetColorNum(
    TCHAR* color
    );

VOID
SetColor(
    WORD attr
    );

BOOL
GetNextConnectInfo(
    TCHAR** SrvName,
    TCHAR** PipeName
    );



CONSOLE_SCREEN_BUFFER_INFO csbiOriginal;

int _cdecl _tmain(int argc, TCHAR *argv[])
{
    WORD  RunType;              // Server or Client end of Remote
    DWORD len=HOSTNAMELEN-1;
    int   i, FirstArg;

    BOOL  bSetAttrib=FALSE;     // Change Console Attributes
    BOOL  bPromptForArgs=FALSE; // Is /P option
	BOOL  bIPSession=TRUE;           // Is /N for Named Pipes
    TCHAR	szTitle[100];		// New Title
    TCHAR	orgTitle[100];	// Old Title
    WORD  wAttrib;              // Console Attributes

    GetComputerName((LPTSTR)HostName,&len);

    MyOutHandle=GetStdHandle(STD_OUTPUT_HANDLE);

    //
    // Save Existing Values
    //

    //
    //Colors /f   <ForeGround> /b <BackGround>
    //


    //
    //Title  /T Title
    //

    if (GetConsoleScreenBufferInfo(MyOutHandle,&csbiOriginal)) {

        wAttrib = csbiOriginal.wAttributes;
        if (!GetConsoleTitle(orgTitle,sizeof(orgTitle)/sizeof(orgTitle[0]))) {
            orgTitle[0] = 0;
        }

    } else {

        //
        // either stdout is a pipe, or it wasn't opened for
        // GENERIC_READ along with GENERIC_WRITE, in which
        // case our color manipulations will work so we need
        // to pick default colors.
        //

        wAttrib = FOREGROUND_GREEN |
                  FOREGROUND_INTENSITY;

        orgTitle[0] = 0;
    }

    //
    // Parameter Processing
    //
    // For Server:
    // Remote /S <Executable>  <PipeName> [Optional Params]
    //
    // For Client:
    // Remote /C <Server Name> <PipeName> [Optional Params]
    // or
    // Remote /P
    // This will loop continously prompting for different
    // Servers and Pipename


    if ((argc<2)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
    {

        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    switch(argv[1][1])
    {

    case 'c':
    case 'C':

        //
        // Is Client End of Remote
        //

        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ServerName=argv[2];
        PipeName=argv[3];
        FirstArg=4;
        RunType=REMOTE_CLIENT;
        break;


    case 'p':
    case 'P':

        //
        // Is Client End of Remote
        //

        bPromptForArgs=TRUE;
        RunType=REMOTE_CLIENT;
        FirstArg=2;
        break;


    case 's':
    case 'S':
        //
        // Is Server End of Remote
        //
        if ((argc<4)||((argv[1][0]!='/')&&(argv[1][0]!='-')))
        {

            DisplayServerHlp();
            DisplayClientHlp();
            return(1);
        }

        ChildCmd=argv[2];
        PipeName=argv[3];
        FirstArg=4;

        RunType=REMOTE_SERVER;
        break;


    default:
        DisplayServerHlp();
        DisplayClientHlp();
        return(1);
    }

    if (RunType==REMOTE_SERVER)
    {
    	//
    	// Base Name of Executable
    	// For setting the title
    	//

        TCHAR *tcmd=ChildCmd;

        while ((*tcmd!=' ')    &&(*tcmd!=0))   tcmd++;
        while ((tcmd!=ChildCmd)&&(*tcmd!='\\'))tcmd--;

        _stprintf( szTitle, TEXT("%-8.8s [WSRemote /C %s %s]"), tcmd, HostName, PipeName);
    }

    //
    //Process Common (Optional) Parameters
    //

    for (i=FirstArg;i<argc;i++)
    {

        if ((argv[i][0]!='/')&&(argv[i][0]!='-'))
        {
            _tprintf( TEXT("Invalid parameter %s:Ignoring\n"),argv[i]);
            continue;
        }

        switch(argv[i][1])
        {
		case 'u':    // Only Valid for Server End
        case 'U':    // Username To Use to Connect to Session
            i++;
            if (i>=argc)
            {
                _tprintf( TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            Username=(argv[i]);
            break;

		case 'p':    // Only Valid for Server End
        case 'P':    // Password To Use to Connect to Session
            i++;
            if (i>=argc)
            {
                _tprintf( TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            Password=(argv[i]);
            break;

        case 'l':    // Only Valid for client End
        case 'L':    // Max Number of Lines to recieve from Server
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            LinesToSend=(DWORD)_ttoi(argv[i])+1;
            break;

        case 't':    // Title to be set instead of the default
        case 'T':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            _stprintf( szTitle, TEXT("%s"),argv[i]);
            break;

        case 'b':    // Background color
        case 'B':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    bSetAttrib=TRUE;
                    wAttrib=col<<4|(wAttrib&0x000f);
                }
                break;
            }

        case 'f':    // Foreground color
        case 'F':
            i++;
            if (i>=argc)
            {
                _tprintf(TEXT("Incomplete Param %s..Ignoring\n"),argv[i-1]);
                break;
            }
            {
                WORD col=GetColorNum(argv[i]);
                if (col!=0xffff)
                {
                    bSetAttrib=TRUE;
                    wAttrib=col|(wAttrib&0x00f0);
                }
                break;
            }

        case 'q':
        case 'Q':
            IsAdvertise=FALSE;
            ClientToServerFlag|=0x80000000;
            break;
		
		case 'n':
        case 'N':
            bIPSession=FALSE;
            break;
		
		case 'i':
        case 'I':
            bIPLocked=TRUE;
            break;
        default:
            _tprintf(TEXT("Unknown Parameter=%s %s\n"),argv[i-1],argv[i]);
            break;

        }

    }

    //
    //Now Set various Parameters
    //

    //
    //Colors
    //

    SetColor(wAttrib);

    if (RunType==REMOTE_CLIENT)
    {
        BOOL done=FALSE;

        //
        // Set Client end defaults and start client
        //



        while(!done)
        {
            if (!bPromptForArgs ||
                GetNextConnectInfo(&ServerName,&PipeName)
               )
            {
                _stprintf( szTitle, TEXT("WSRemote /C %s %s"),ServerName,PipeName);
                SetConsoleTitle(szTitle);

                
				if (!bIPSession)
				{
				//
                // Start Client (Client.C)
                //
                Client(ServerName,PipeName);
				}
				else
				{
				SockClient(ServerName,PipeName);
				}
            }
            done=!bPromptForArgs;
        }
    }

    if (RunType==REMOTE_SERVER)
    {
		SetConsoleTitle(szTitle);

        //
        // Start Server (Server.C)
        //
        Server(ChildCmd,PipeName);
    }

    //
    //Reset Colors
    //
    SetColor(csbiOriginal.wAttributes);
    if (orgTitle[0]) {
        SetConsoleTitle(orgTitle);
    }

    ExitProcess(0);
	return( 1 );
}
/*************************************************************/
VOID
ErrorExit(
    TCHAR* str
    )
{
    _tprintf(TEXT("Error-%d:%s\n"),GetLastError(),str);
    ExitProcess(1);
}

/*************************************************************/
DWORD
ReadFixBytes(
    HANDLE hRead,
    TCHAR*  Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    )
{
    DWORD xyzBytesRead=0;
    DWORD xyzBytesToRead=ToRead;
    TCHAR* xyzbuff=Buffer;

    while(xyzBytesToRead!=0)
    {
        if (!ReadFile(hRead,xyzbuff,xyzBytesToRead,&xyzBytesRead,NULL))
        {
            return(xyzBytesToRead);
        }

        xyzBytesToRead-=xyzBytesRead;
        xyzbuff+=xyzBytesRead;
    }
    return(0);

}
/*************************************************************/

/*************************************************************/
DWORD
SockReadFixBytes(
    SOCKET hSocket,
    TCHAR*  Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    )
{
    DWORD xyzBytesRead=0;
    DWORD xyzBytesToRead=ToRead;
    TCHAR* xyzbuff=Buffer;

    while(xyzBytesToRead!=0)
    {
        if (!ReadSocket(hSocket,xyzbuff,xyzBytesToRead,&xyzBytesRead))
        {
            return(xyzBytesToRead);
        }

        xyzBytesToRead-=xyzBytesRead;
        xyzbuff+=xyzBytesRead;
    }
    return(0);

}
/*************************************************************/

VOID
DisplayClientHlp()
{
    _tprintf(TEXT("\n   To Start the CLIENT end of WSREMOTE\n"));
    _tprintf(TEXT("   ---------------------------------\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /C <ServerName> <Unique Id> [Param]\n"));
    _tprintf(TEXT("   Example: WSREMOTE /C iisdebug   70\n"));
    _tprintf(TEXT("            This would connect to a server session on \n"));
    _tprintf(TEXT("            iisdebug with id \"70\" if there was a\n"));
    _tprintf(TEXT("            WSREMOTE /S <\"Cmd\"> 70\n"));
    _tprintf(TEXT("            started on the machine iisdebug.\n\n"));
    _tprintf(TEXT("   To Exit: %cQ (Leaves the Remote Server Running)\n"),COMMANDCHAR);
    _tprintf(TEXT("   [Param]: /L <# of Lines to Get>\n"));
    _tprintf(TEXT("   [Param]: /F <Foreground color eg blue, lred..>\n"));
    _tprintf(TEXT("   [Param]: /B <Background color eg cyan, lwhite..>\n"));
	_tprintf(TEXT("   [Param]: /N (Connect over Named Pipes)\n"));
	_tprintf(TEXT("   [Param]: /U <Username> (Username to connect)\n"));
	_tprintf(TEXT("   [Param]: /P <Password> (Password to connect)\n"));
    _tprintf(TEXT("\n"));
}
/*************************************************************/

VOID
DisplayServerHlp()
{

#define WRITEF2(VArgs)            {                                                 \
                                    HANDLE xh=GetStdHandle(STD_OUTPUT_HANDLE);     \
                                    TCHAR   VBuff[256];                             \
                                    DWORD  tmp;                                    \
                                    _stprintf VArgs;                                 \
                                    WriteFile(xh,VBuff,lstrlen(VBuff),&tmp,NULL);   \
                                 }                                                 \


    _tprintf(TEXT("\n   To Start the SERVER end of WSREMOTE\n"));
    _tprintf(TEXT("   ---------------------------------\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /S <\"Cmd\"> <Unique Id or Port Number> [Param]\n"));
    _tprintf(TEXT("   Syntax : WSREMOTE /S <\"Cmd\"> <Unique Id or Port Number> [Param]\n"));
    _tprintf(TEXT("   Example: WSREMOTE /S \"cmd.exe\" inetinfo\n"));
    _tprintf(TEXT("            To interact with this \"Cmd\" \n"));
    _tprintf(TEXT("            from some other machine\n"));
    _tprintf(TEXT("            - start the client end by:\n"));
    _tprintf(TEXT("            REMOTE /C %s  PortNum\n\n"),HostName);
    _tprintf(TEXT("   To Exit: %cK \n"),COMMANDCHAR);
    _tprintf(TEXT("   [Param]: /F <Foreground color eg yellow, black..>\n"));
    _tprintf(TEXT("   [Param]: /B <Background color eg lblue, white..>\n"));
	_tprintf(TEXT("   [Param]: /I (Turns ON IP Blocking)\n"));
	_tprintf(TEXT("   [Param]: /U <Username> (Username to connect)\n"));
	_tprintf(TEXT("   [Param]: /P <Password> (Password to connect)\n"));
    _tprintf(TEXT("\n"));

}

WORD
GetColorNum(
    TCHAR *color
    )
{
    WORD wIndex;

    _tcslwr(color);
    for (wIndex=0;wIndex<16;wIndex++)
    {
        if (_tcscmp(ColorList[wIndex],color)==0)
        {
            return(wIndex);
        }
    }
    return ((WORD)_ttoi(color));
}

VOID
SetColor(
    WORD attr
    )
{
	COORD  origin={0,0};
    DWORD  dwrite;
    FillConsoleOutputAttribute
    (
    	MyOutHandle,attr,csbiOriginal.dwSize.
    	X*csbiOriginal.dwSize.Y,origin,&dwrite
    );
    SetConsoleTextAttribute(MyOutHandle,attr);
}

BOOL
GetNextConnectInfo(
    TCHAR** SrvName,
    TCHAR** PipeName
    )
{
    static TCHAR szServerName[64];
    static TCHAR szPipeName[32];
    TCHAR *s;
    int StringLen;

    __try
    {
        ZeroMemory(szServerName,64);
        ZeroMemory(szPipeName,32);
        SetConsoleTitle( TEXT("Remote - Prompting for next Connection"));
        _tprintf(TEXT("Debugger machine (server): "));
        fflush(stdout);

        if (!fgets(szServerName, sizeof(szServerName), stdin)) {
            return FALSE;
        }

        StringLen = strlen(szServerName);

        if (!StringLen || (!feof(stdin) && szServerName[StringLen-1] != '\n')) {
            return FALSE;
        }

        if (szServerName[StringLen-1] == '\n') {
            if (StringLen == 1) {
                return (FALSE);
            }
            szServerName[StringLen-1] = '\0';
        }

        if (szServerName[0] == COMMANDCHAR &&
            (szServerName[1] == 'q' || szServerName[1] == 'Q')
           )
        {
            return(FALSE);
        }

        if (s = _tcschr( szServerName, ' ' )) {
            *s++ = '\0';
            while (*s == ' ') {
                s += 1;
            }
            *PipeName=_tcscpy(szPipeName, s);
            _tprintf(szPipeName);
            fflush(stdout);
        }
        if (_tcslen(szPipeName) == 0) {
            _tprintf(TEXT("Debuggee machine : "));
            fflush(stdout);
            if (!fgets(szPipeName, sizeof(szPipeName), stdin)) {
                return FALSE;
            }
    
            StringLen = strlen(szPipeName);
    
            if (!StringLen || (!feof(stdin) && szPipeName[StringLen-1] != '\n')) {
                return FALSE;
            }
    
            if (szPipeName[StringLen-1] == '\n') {
                szPipeName[StringLen-1] = '\0';
            }
        }

        if (s = _tcschr(szPipeName, ' ')) {
            *s++ = '\0';
        }

        if (szPipeName[0] == COMMANDCHAR &&
            (szPipeName[1] == 'q' || szPipeName[1] == 'Q')
           )
        {
            return(FALSE);
        }
        _tprintf(TEXT("\n\n"));
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(FALSE);  // Ignore exceptions
    }
    return(TRUE);
}


/*************************************************************/
VOID
Errormsg(
    TCHAR* str
    )
{
    _tprintf(TEXT("Error (%d) - %s\n"),GetLastError(),str);
}

/*************************************************************/

BOOL ReadSocket(SOCKET s,TCHAR * buff,int len,DWORD* dread)
{
    BOOL    bRet    = FALSE;
    DWORD   numread;

#ifdef UNICODE
    char *	pszAnsiStr	= (char *)calloc( (len + 1), sizeof(char) );

    if (pszAnsiStr)
    {
        int nErr;
        numread = (DWORD)recv( s, pszAnsiStr, len, 0);

        if (SOCKET_ERROR != numread)
        {
            nErr    = MultiByteToWideChar(  CP_ACP,
                                            MB_PRECOMPOSED,
                                            pszAnsiStr,
                                            len,
                                            buff,
                                            len );

            if (nErr)
            {
                *dread  = numread;
                bRet    = TRUE;
            }

            //Base64Decode(buff,DecodeBuffer);
        }

        free( pszAnsiStr );
    }
#else
    numread = (DWORD)recv( s, buff, len, 0);

    if (SOCKET_ERROR != numread)
    {
        *dread  = numread;
        bRet    = TRUE;
    }

#endif
    return bRet;
}

// returns TRUE if successful, false otherwise
BOOL WriteSocket(
        SOCKET  s,
        TCHAR * buff,
        int     len,
        DWORD*  dsent)
{
    BOOL    bRet    = FALSE;
    DWORD   numsent;

#ifdef UNICODE

    int     nStrLen = lstrlen( buff );

    if (nStrLen)
    {
        char * pszAnsiStr   = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                buff,
                                                nStrLen,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                numsent = (DWORD)send(s, pszAnsiStr, nStrLen, 0);
                if (SOCKET_ERROR != numsent)
                {
                    *dsent  = numsent;
                    bRet    = TRUE;
                }
            }

            //Base64Decode(buff,DecodeBuffer);
            free( pszAnsiStr );
        }
    }
#else
    numsent = (DWORD)send(s, buff, len, 0);
    if (SOCKET_ERROR != numsent)
    {
        *dsent  = numsent;
        bRet    = TRUE;
    }

#endif
    return  bRet;
}

#ifdef UNICODE
// returns TRUE if successful, false otherwise
BOOL WriteSocketA(
        SOCKET  s,
        char *  pszAnsiStr,
        int     len,
        DWORD * dsent)
{
    BOOL    bRet    = FALSE;
    DWORD   numsent;

    numsent = (DWORD)send(s, pszAnsiStr, len, 0);

    if (SOCKET_ERROR != numsent)
    {
        *dsent  = numsent;
        bRet    = TRUE;
    }

    //Base64Decode(buff,DecodeBuffer);
    return  bRet;
}
#endif

////////////////////////////////////////////////
unsigned char Base64Table[64] =
{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/'};

VOID
Base64Encode(
    TCHAR * String,
    DWORD StringLength,
    TCHAR * EncodeBuffer)
{
    DWORD  EncodeDword;
    int    Index;

    memset(EncodeBuffer, 0, 2 * StringLength);

    Index = 0;

    while (StringLength >= 3) {
        //
        // Encode a three byte chunk
        //

        EncodeDword = (String[0] << 16) & 0xff0000;

        EncodeDword += (String[1] << 8) & 0xff00;

        EncodeDword += String[2] & 0xff;

        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
        EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 6) & 63];
        EncodeBuffer[Index++] = Base64Table[EncodeDword & 63];

        String += 3;
        StringLength -= 3;
    }

    switch (StringLength) {
        case 1:
            EncodeDword = (String[0] << 16) & 0xff0000;
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
            EncodeBuffer[Index++] = '=';
            EncodeBuffer[Index++] = '=';
            break;
        case 2:
            EncodeDword = (String[0] << 16) & 0xff0000;
            EncodeDword += (String[1] << 8) & 0xff00;

            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 18) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 12) & 63];
            EncodeBuffer[Index++] = Base64Table[(EncodeDword >> 6) & 63];
            EncodeBuffer[Index++] = '=';
            break;
    }

    EncodeBuffer[Index] = 0;

    return;
}
int
GetBase64Index(
    TCHAR A)
{
    int i;

    for (i=0; i<64; i++) {
        if (Base64Table[i] == A) {
            return i;
        }
    }

    return -1;
}
VOID
Base64Decode(
    TCHAR * String,
    TCHAR * DecodeBuffer)
{
    DWORD  DecodeDword;
    int    Index = 0;

    memset(DecodeBuffer, 0, _tcslen(String));

    if (_tcslen(String) % 4) {
        printf("WCAT INTERNAL ERROR %s %d\n", __FILE__, __LINE__);
        return;
    }

    while (*String) {
        //
        // Decode a four byte chunk
        //

        if (GetBase64Index(String[0]) < 0) {
            //
            // Invalid string
            //

            printf("WCAT INTERNAL ERROR %s %d\n", __FILE__, __LINE__);
            return;
        }

        DecodeDword = ((unsigned int) GetBase64Index(String[0])) << 18;

        if (GetBase64Index(String[1]) >= 0) {
            //
            // still more characters
            //

            DecodeDword += ((unsigned int) GetBase64Index(String[1])) << 12;
            if (GetBase64Index(String[2]) >= 0) {
                //
                // still more characters
                //

                DecodeDword += ((unsigned int) GetBase64Index(String[2])) << 6;
                if (GetBase64Index(String[3]) >= 0) {
                    //
                    // still more characters
                    //

                    DecodeDword += (unsigned int) GetBase64Index(String[3]);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 8) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) (DecodeDword & 0xff);
                } else {
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
                    DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 8) & 0xff);
                }
            } else {
                DecodeBuffer[Index++] = (unsigned char) ((DecodeDword >> 16) & 0xff);
            }
        }

        String += 4;
    }

    return;
}

VOID
SplitUserName(
    TCHAR * FullName,
    TCHAR * Domain,
    TCHAR * UserName)
{
    TCHAR * Slash;
    Slash = _tcsstr(FullName, TEXT(":"));

    if (Slash) {
        // there is a domain name

        *Slash = 0;
        _tcscpy(Domain, FullName);
        _tcscpy(UserName, Slash+1);
        *Slash = ':';
    } else {
        *Domain = 0;
        _tcscpy(UserName, FullName);
    }
}

#ifdef UNICODE

// caller must free buffer
WCHAR * inet_ntoaw(
    struct in_addr stInet
)
{
    char *  pszAnsiInetStr  = inet_ntoa( stInet );

    int nStrLen = strlen( pszAnsiInetStr );

    WCHAR * pszInetStr  = (WCHAR *)calloc( (nStrLen + 1), sizeof( TCHAR ));

    int nErr    = MultiByteToWideChar(  CP_ACP,
                                        MB_PRECOMPOSED,
                                        pszAnsiInetStr,
                                        nStrLen,
                                        pszInetStr,
                                        nStrLen );

    if (!nErr)
    {
        free( pszInetStr );
        pszInetStr  = NULL;
    }

    return pszInetStr;
}

BOOL ReadFileW(
    HANDLE          hFile,      // handle of file to read
    WCHAR *         pszBuffer,  // pointer to buffer that receives data
    DWORD           dwLength,   // number of bytes to read
    LPDWORD         pdwRead,    // pointer to number of bytes read
    LPOVERLAPPED    pData       // pointer to structure for data
)
{
    BOOL    bRet    = FALSE;
    char *  pszAnsi = (char *)calloc( dwLength + 1, sizeof(char *));

    if (pszAnsi)
    {
        bRet    = ReadFile( hFile,
                            pszAnsi,
                            dwLength,
                            pdwRead,
                            pData);

        if (bRet)
        {
            int nErr    = MultiByteToWideChar(  CP_ACP,
                                                MB_PRECOMPOSED,
                                                pszAnsi,
                                                *pdwRead,
                                                pszBuffer,
                                                *pdwRead );

            if (!nErr)
            {
                bRet    = FALSE;
            }
        }

        free( pszAnsi );
    }

    return bRet;
}

BOOL WriteFileW(
    HANDLE          hFile,      // handle to file to write to
    WCHAR *         pszBuffer,  // pointer to data to write to file
    DWORD           dwWrite,    // number of bytes to write
    LPDWORD         pdwWritten, // pointer to number of bytes written
    LPOVERLAPPED    pData       // pointer to structure for overlapped I/O
)
{
    BOOL    bRet    = FALSE;
    int     nStrLen = lstrlen( pszBuffer );

    if (nStrLen)
    {
        char * pszAnsiStr   = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                pszBuffer,
                                                nStrLen,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                bRet    = WriteFile(    hFile,
                                        pszAnsiStr,
                                        dwWrite,
                                        pdwWritten,
                                        pData);
            }

            free( pszAnsiStr );
        }
    }

    return bRet;
}

// caller most free buffer
BOOL    GetAnsiStr(
    WCHAR * pszWideStr,
    char *  pszAnsiStr,
    UINT    uBufSize
)
{
    BOOL    bRet    = FALSE;
    if (pszWideStr && pszAnsiStr)
    {
        int     nStrLen = lstrlen( pszWideStr );

        if (nStrLen)
        {
            int nErr    = WideCharToMultiByte(  CP_ACP,
                                                WC_COMPOSITECHECK,
                                                pszWideStr,
                                                nStrLen,
                                                pszAnsiStr,
                                                uBufSize - 1,
                                                NULL,
                                                NULL );
            if (nErr)
            {
                pszAnsiStr[nStrLen] = '\0';
                bRet    = TRUE;
            }
        }
    }
    return  bRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    Client.c

Abstract:

    The Client component of Remote. Connects to the remote
    server using named pipes. It sends its stdin to
    the server and output everything from server to
    its stdout.

Author:

    Rajivendra Nath (rajnath) 2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"

HANDLE*
EstablishSession(
    TCHAR *server,
    TCHAR *pipe
    );

SOCKET*
SockEstablishSession(
    TCHAR *server,
    TCHAR *pipe
    );

DWORD
GetServerOut(
    PVOID *Noarg
    );

DWORD
SockGetServerOut(
    PVOID *Noarg
    );

DWORD
SendServerInp(
    PVOID *Noarg
    );

DWORD
SockSendServerInp(
    PVOID *Noarg
    );

BOOL
FilterClientInp(
    TCHAR *buff,
    int count
    );

BOOL
SockFilterClientInp(
    TCHAR *buff,
    int count
    );

BOOL
Mych(
    DWORD ctrlT
    );

BOOL
SockMych(
    DWORD ctrlT
    );

VOID
SendMyInfo(
    PHANDLE Pipes
    );

VOID
SockSendMyInfo(
    SOCKET MySocket
    );


HANDLE iothreads[2];
HANDLE MyStdInp;
HANDLE MyStdOut;
HANDLE ReadPipe;
HANDLE WritePipe;
SOCKET RWSocket;


CONSOLE_SCREEN_BUFFER_INFO csbi;

TCHAR   MyEchoStr[30];
BOOL   CmdSent;
DWORD  LinesToSend=LINESTOSEND;

VOID
Client(
    TCHAR* Server,
    TCHAR* Pipe
    )
{
    HANDLE *Connection;
    DWORD  tid;


    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    _tprintf(TEXT("****************************************\n"));
    _tprintf(TEXT("***********     WSREMOTE    ************\n"));
    _tprintf(TEXT("***********      CLIENT     ************\n"));
    _tprintf(TEXT("****************************************\n"));

    if ((Connection=EstablishSession(Server,Pipe))==NULL)
        return;


    ReadPipe=Connection[0];
    WritePipe=Connection[1];


    SetConsoleCtrlHandler((PHANDLER_ROUTINE)Mych,TRUE);

    // Start Thread For Server --> Client Flow
    if ((iothreads[0]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
            (DWORD)0,                           // Use same stack size.
            (LPTHREAD_START_ROUTINE)GetServerOut, // Thread procedure.
            (LPVOID)NULL,              // Parameter to pass.
            (DWORD)0,                           // Run immediately.
            (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }



    //
    // Start Thread for Client --> Server Flow
    //

    if ((iothreads[1]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)SendServerInp, // Thread procedure.
                    (LPVOID)NULL,          // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }

    WaitForMultipleObjects(2,iothreads,FALSE,INFINITE);

    TerminateThread(iothreads[0],1);
    TerminateThread(iothreads[1],1);
    _tprintf(TEXT("*** SESSION OVER ***\n"));
}


VOID
SockClient(
    TCHAR* Server,
    TCHAR* Pipe
    )
{
    SOCKET *Connection;
    DWORD  tid;
	int nRet;


    MyStdInp=GetStdHandle(STD_INPUT_HANDLE);
    MyStdOut=GetStdHandle(STD_OUTPUT_HANDLE);

    _tprintf(TEXT("**************************************\n"));
    _tprintf(TEXT("***********     WSREMOTE    ************\n"));
    _tprintf(TEXT("***********      CLIENT(IP) ************\n"));
    _tprintf(TEXT("**************************************\n"));

    if ((Connection=SockEstablishSession(Server,Pipe))==NULL)
        return;

	RWSocket = *Connection;  

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)SockMych,TRUE);

    // Start Thread For Server --> Client Flow
    if ((iothreads[0]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
            (DWORD)0,                           // Use same stack size.
            (LPTHREAD_START_ROUTINE)SockGetServerOut, // Thread procedure.
            (LPVOID)NULL,              // Parameter to pass.
            (DWORD)0,                           // Run immediately.
            (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }



    //
    // Start Thread for Client --> Server Flow
    //

    if ((iothreads[1]=CreateThread((LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)SockSendServerInp, // Thread procedure.
                    (LPVOID)NULL,          // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&tid))==NULL)              // Thread identifier.
    {

        Errormsg(TEXT("Could Not Create rwSrv2Cl Thread"));
        return;
    }

    WaitForMultipleObjects(2,iothreads,FALSE,INFINITE);

    TerminateThread(iothreads[0],1);
    TerminateThread(iothreads[1],1);
	
//	_tprintf(TEXT("Calling WSACleanup()....\n"));
	nRet = WSACleanup();
    _tprintf(TEXT("*** SESSION OVER ***\n"));
}

DWORD
GetServerOut(
    PVOID *Noarg
    )

{
    TCHAR buffin[200];
    DWORD  dread=0,tmp;

    while(ReadFile(ReadPipe,buffin,200,&dread,NULL))
    {
        if (dread!=0)
        {
           if (!WriteFile(MyStdOut,buffin,dread,&tmp,NULL))
            break;
        }

    }
    return(1);
}


DWORD
SockGetServerOut(
    PVOID *Noarg
    )
{
    
	TCHAR buffin[200];
    DWORD  dread=0,tmp;

    while(ReadSocket(RWSocket,buffin,200,&dread))
    {
        if (dread!=0)
        {
           if (!WriteFile(MyStdOut,buffin,dread,&tmp,NULL))
            break;
        }

    }
    return(1);
}

DWORD
SendServerInp(
    PVOID *Noarg
    )

{
    TCHAR buff[200];
    DWORD  dread,dwrote;
    SetLastError(0);

    while(ReadFile(MyStdInp,buff,200,&dread,NULL))
    {
        if (FilterClientInp(buff,dread))
            continue;
          if (!WriteFile(WritePipe,buff,dread,&dwrote,NULL))
            break;
    }
    return(0);
}

DWORD
SockSendServerInp(
    PVOID *Noarg
    )

{
    TCHAR buff[200];
    DWORD  dread,dwrote;
    SetLastError(0);

    while(ReadFile(MyStdInp,buff,200,&dread,NULL))
    {
       if (SockFilterClientInp(buff,dread))
            continue;
		if (!WriteSocket(RWSocket,buff,dread,&dwrote))
            break;
		memset(buff, 0, sizeof(buff));
      
    }
    return(0);
}

BOOL
SockSendAuth(
    SOCKET s
    )

{
    TCHAR	EncodeBuffer[1024];
    TCHAR * pEncodeBuffer; 
	TCHAR	UserBuffer[1024];
//    TCHAR *	String = UserBuffer;
    DWORD	dwrote;
	int		len;
	BOOL	bRet;

    SetLastError(0);
	
	memset(EncodeBuffer, 0, sizeof(EncodeBuffer));
	
	_stprintf(	UserBuffer,
		        TEXT("%s:%s"),
				Username,
				Password);

    pEncodeBuffer = EncodeBuffer + _tcslen(EncodeBuffer);
	len = _tcslen(UserBuffer);
    Base64Encode(UserBuffer, _tcslen(UserBuffer), pEncodeBuffer);
    len = _tcslen(pEncodeBuffer);

	bRet = WriteSocket(s,pEncodeBuffer,len,&dwrote);
	
	return TRUE;
}

BOOL
FilterClientInp(
    TCHAR *buff,
    int count
    )
{

    if (count==0)
        return(TRUE);

    if (buff[0]==2)  //Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);//do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
              CloseHandle(WritePipe);
              return(FALSE);

        case 'h':
        case 'H':
              _tprintf(TEXT("%cM : Send Message\n"),COMMANDCHAR);
              _tprintf(TEXT("%cP : Show Popup on Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cS : Status of Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cQ : Quit client\n"),COMMANDCHAR);
              _tprintf(TEXT("%cH : This Help\n"),COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
SockFilterClientInp(
    TCHAR *buff,
    int count
    )
{
int nRet;

    if (count==0)
        return(TRUE);

    if (buff[0]==2)  //Adhoc screening of ^B so that i386kd/mipskd
        return(TRUE);//do not terminate.

    if (buff[0]==COMMANDCHAR)
    {
        switch (buff[1])
        {
        case 'k':
        case 'K':
        case 'q':
        case 'Q':
			  nRet = shutdown(RWSocket, SD_BOTH);
			  if (nRet == SOCKET_ERROR)
				_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
              closesocket(RWSocket);
              return(FALSE);

        case 'h':
        case 'H':
              _tprintf(TEXT("%cM : Send Message\n"),COMMANDCHAR);
              _tprintf(TEXT("%cP : Show Popup on Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cS : Status of Server\n"),COMMANDCHAR);
              _tprintf(TEXT("%cQ : Quit client\n"),COMMANDCHAR);
              _tprintf(TEXT("%cH : This Help\n"),COMMANDCHAR);
              return(TRUE);

        default:
              return(FALSE);
        }

    }
    return(FALSE);
}

BOOL
Mych(
   DWORD ctrlT
   )

{
    TCHAR  c[2];
    DWORD tmp;
    DWORD send=1;
    c[0]=CTRLC;
    if (ctrlT==CTRL_C_EVENT)
    {
        if (!WriteFile(WritePipe,c,send,&tmp,NULL))
        {
            Errormsg(TEXT("Error Sending ^c\n"));
            return(FALSE);
        }
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)

       )
    {
        CloseHandle(WritePipe); //Will Shutdown naturally
    }
    return(FALSE);
}

BOOL
SockMych(
   DWORD ctrlT
   )

{
    TCHAR  c[2];
    DWORD tmp;
    DWORD send=1;
    c[0]=CTRLC;
    if (ctrlT==CTRL_C_EVENT)
    {
        if (!WriteSocket(RWSocket,c,send,&tmp))
        {
            Errormsg(TEXT("Error Sending ^c\n"));
            return(FALSE);
        }
        return(TRUE);
    }
    if ((ctrlT==CTRL_BREAK_EVENT)||
        (ctrlT==CTRL_CLOSE_EVENT)||
        (ctrlT==CTRL_LOGOFF_EVENT)||
        (ctrlT==CTRL_SHUTDOWN_EVENT)

       )
    {
        CloseHandle(WritePipe); //Will Shutdown naturally
    }
    return(FALSE);
}

HANDLE*
EstablishSession(
    TCHAR *server,
    TCHAR *srvpipename
    )
{
    static HANDLE PipeH[2];
    TCHAR   pipenameSrvIn[200];
    TCHAR   pipenameSrvOut[200];

    _stprintf(pipenameSrvIn ,SERVER_READ_PIPE ,server,srvpipename);
    _stprintf(pipenameSrvOut,SERVER_WRITE_PIPE,server,srvpipename);

    if ((INVALID_HANDLE_VALUE==(PipeH[0]=CreateFile(pipenameSrvOut,
        GENERIC_READ ,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL))) ||
        (INVALID_HANDLE_VALUE==(PipeH[1]=CreateFile(pipenameSrvIn ,
        GENERIC_WRITE,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL)))) {

        DWORD Err=GetLastError();
        TCHAR msg[128];

        Errormsg(TEXT("*** Unable to Connect ***"));
        //
        // Print a helpful message
        //
        switch(Err)
        {
            case 2: _stprintf(msg,TEXT("Invalid PipeName %s"),srvpipename);break;
            case 53:_stprintf(msg,TEXT("Server %s not found"),server);break;
            default:
                FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|
                               FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL, Err, 0, msg, 128, NULL);
                break;

        }
        _tprintf(TEXT("Diagnosis:%s\n"),msg);

        return(NULL);
    }

    _tprintf(TEXT("Connected..\n\n"));

    SendMyInfo(PipeH);

    return(PipeH);
}


SOCKET*
SockEstablishSession(
    TCHAR *server,
    TCHAR *srvpipename
    )
{
    static SOCKET   Socket;

    int				nRet;
    LPHOSTENT       lpHostEntry         = NULL;
	SOCKADDR_IN		sa;
	WORD			wVersionRequested	= MAKEWORD(1,1);
	WSADATA			wsaData;
	unsigned short	usPort;
#ifdef UNICODE
    int             nStrLen;
#endif

	//
	// Initialize WinSock
	//
	nRet = WSAStartup(wVersionRequested, &wsaData);
	if (nRet)
	{
	_tprintf(TEXT("Initialize WinSock Failed"));
		return NULL;
	}
	// Check version
	if (wsaData.wVersion != wVersionRequested)
	{       
	_tprintf(TEXT("Wrong WinSock Version"));
		return NULL;
	}


	// 
	// Lookup host
	//
#ifdef UNICODE
    nStrLen	= lstrlen( server );

    if (nStrLen)
    {
        char *  pszAnsiStr  = (char *)malloc( nStrLen + 1 );

        if (pszAnsiStr)
        {
            int nErr    = WideCharToMultiByte(  CP_THREAD_ACP,
                                                WC_COMPOSITECHECK,
                                                server,
                                                -1,
                                                pszAnsiStr,
                                                nStrLen,
                                                NULL,
                                                NULL );

            if (!nErr)
            {
                DWORD dwErr = GetLastError();

                switch( dwErr )
                {
                    case ERROR_INSUFFICIENT_BUFFER:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INSUFFICIENT_BUFFER"));
                        break;
                    case ERROR_INVALID_FLAGS:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INVALID_FLAGS"));
                        break;
                    case ERROR_INVALID_PARAMETER:
                        _tprintf(TEXT("error: gethostbyname-- WideCharToMultiByte Error: ERROR_INVALID_PARAMETER"));
                        break;
                }

                free( pszAnsiStr );
                return NULL;
            }

            lpHostEntry = gethostbyname( pszAnsiStr );
            free( pszAnsiStr );
        }
    }
#else
    lpHostEntry = gethostbyname( server );
#endif
    if (lpHostEntry == NULL)
	{
		_tprintf(TEXT("wsremote: gethostbyname() error "));
		return NULL;
	}

	//
	// Fill in the server address structure
	//
	sa.sin_family = AF_INET;
	sa.sin_addr = *((LPIN_ADDR)*lpHostEntry->h_addr_list);

	usPort = (unsigned short)_ttoi( srvpipename );
	sa.sin_port = htons(usPort);	

	//	
	// Create a TCP/IP stream socket
	//
	
	Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (Socket == INVALID_SOCKET)
	{
		_tprintf(TEXT("socket()"));
		return NULL;
	}

	//
	// Request a connection
	//
	nRet = connect(Socket, 
	               (LPSOCKADDR)&sa, 
				   sizeof(SOCKADDR_IN));
	if (nRet == SOCKET_ERROR)
	{
		int	iWSAErr;
		iWSAErr	= WSAGetLastError();

		_tprintf( TEXT("connect(), Error: %d"), iWSAErr );
			return NULL;
	}

	SockSendMyInfo(Socket);

    return(&Socket);
}

VOID
SendMyInfo(
    PHANDLE pipeH
    )
{
    HANDLE rPipe=pipeH[0];
    HANDLE wPipe=pipeH[1];

    DWORD  hostlen=HOSTNAMELEN-1;
    WORD   BytesToSend=sizeof(SESSION_STARTUPINFO);
    DWORD  tmp;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;
    DWORD  BytesToRead;
    TCHAR   *buff;

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    GetComputerName((TCHAR *)ssi.ClientName,&hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    {
        DWORD NewCode=MAGICNUMBER;
        TCHAR  Name[15];

        _tcscpy(Name,(TCHAR *)ssi.ClientName);
        memcpy(&Name[11],(TCHAR *)&NewCode,sizeof(NewCode));

        WriteFile(wPipe,(TCHAR *)Name,HOSTNAMELEN-1,&tmp,NULL);
        if (!ReadFile(rPipe ,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,NULL) || (ssr.MagicNumber!=MAGICNUMBER))
        {
            _tprintf(TEXT("WSREMOTE FAILED TO CONNECT TO SERVER..\n"));
            WriteFile(MyStdOut,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp,NULL);
            return;
        }

        //Get Rest of the info-its not the old server

        ReadFixBytes(rPipe,(TCHAR *)&ssr.Size,sizeof(ssr.Size),0);
        ReadFixBytes(rPipe,(TCHAR *)&ssr.FileSize,sizeof(ssr)-sizeof(ssr.FileSize)-sizeof(ssr.MagicNumber),0);

    }

    if (!WriteFile(wPipe,(TCHAR *)&ssi,BytesToSend,&tmp,NULL))
    {
       Errormsg(TEXT("INFO Send Error"));
       return;
    }

    BytesToRead=MINIMUM(ssr.FileSize,ssi.LinesToSend*CHARS_PER_LINE);
    buff=calloc(BytesToRead+1,1);
    if (buff!=NULL)
    {
        DWORD  bytesread=0;

        if (ReadFile(rPipe,buff,BytesToRead,&bytesread,NULL)) 
        {
            WriteFile(MyStdOut,buff,bytesread,&tmp,NULL);
        }
        free(buff);
    }

}

VOID
SockSendMyInfo(
    SOCKET MySocket
    )
{
    BOOL                bRet;
#ifdef UNICODE
    char                szAnsiName[HOSTNAMELEN];
#endif
    DWORD               hostlen                 = HOSTNAMELEN-1;
    DWORD               BytesToRead;
    DWORD               tmp;
    DWORD               NewCode                 = MAGICNUMBER;
    SESSION_STARTUPINFO ssi;
    SESSION_STARTREPLY  ssr;
    int                 nRet;
    TCHAR               Name[HOSTNAMELEN];

    TCHAR *             buff;
    WORD                BytesToSend             = sizeof(SESSION_STARTUPINFO);
       

    ssi.Size=BytesToSend;
    ssi.Version=VERSION;

    GetComputerName((TCHAR *)ssi.ClientName,&hostlen);
    ssi.LinesToSend=LinesToSend;
    ssi.Flag=ClientToServerFlag;

    bRet = SockSendAuth(MySocket);

    // append on magic number
    _tcscpy(Name, ssi.ClientName);

#ifdef UNICODE
    GetAnsiStr( (TCHAR *)&Name, (char *)&szAnsiName, HOSTNAMELEN );

    memcpy(&szAnsiName[11], &NewCode, sizeof(DWORD) );

    WriteSocketA( MySocket,(char *)&szAnsiName,HOSTNAMELEN-1,&tmp);
#else
    memcpy(&Name[11], &NewCode, sizeof(DWORD) );

    WriteSocket( MySocket,(TCHAR *)Name,HOSTNAMELEN-1,&tmp);
#endif
    ReadSocket(MySocket ,(TCHAR *)&ssr.MagicNumber,sizeof(ssr.MagicNumber),&tmp);

    if (ssr.MagicNumber!=MAGICNUMBER)
    {
        _tprintf(TEXT("WSREMOTE FAILED TO CONNECT TO SERVER..\n"));
        nRet = shutdown(MySocket, SD_BOTH);
        if (nRet == SOCKET_ERROR)
            _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
        closesocket(MySocket);
        return;
    }

    //Get Rest of the info-its not the old server

    SockReadFixBytes(MySocket,(TCHAR *)&ssr.Size,sizeof(ssr.Size),0);
    SockReadFixBytes(MySocket,(TCHAR *)&ssr.FileSize,sizeof(ssr)-sizeof(ssr.FileSize)-sizeof(ssr.MagicNumber),0);

    if (!WriteSocket(MySocket,(TCHAR *)&ssi,BytesToSend,&tmp))
    {
       _tprintf(TEXT("INFO Send Error"));
       return;
    }

    BytesToRead=MINIMUM(ssr.FileSize,ssi.LinesToSend*CHARS_PER_LINE);
    buff=calloc(BytesToRead+1,1);

    if (buff!=NULL)
    {
        DWORD  bytesread=0;

        ReadSocket(MySocket,buff,BytesToRead,&bytesread);
        WriteFile(MyStdOut,buff,bytesread,&tmp,NULL);

        free(buff);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\remote.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       remote.h
//
//--------------------------------------------------------------------------

#ifndef __WSREMOTE_H__
#define __WSREMOTE_H__

#include <winsock2.h>
#include <tchar.h>

#define VERSION             7
#define REMOTE_SERVER       1
#define REMOTE_CLIENT       2

#define SERVER_READ_PIPE    TEXT("\\\\%s\\PIPE\\%sIN")   //Client Writes and Server Reads
#define SERVER_WRITE_PIPE   TEXT("\\\\%s\\PIPE\\%sOUT")  //Server Reads  and Client Writes

#define COMMANDCHAR         '@' //Commands intended for remote begins with this
#define CTRLC               3

#define CLIENT_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_RED|BACKGROUND_BLUE
#define SERVER_ATTR         FOREGROUND_INTENSITY|FOREGROUND_GREEN|FOREGROUND_BLUE|BACKGROUND_RED

//
//Some General purpose Macros
//
#define MINIMUM(x,y)          ((x)>(y)?(y):(x))
#define MAXIMUM(x,y)          ((x)>(y)?(x):(y))

#define ERRORMSSG(str)      _tprintf(TEXT("Error %d - %s [%s %d]\n"),GetLastError(),str,__FILE__,__LINE__)
#define SAFECLOSEHANDLE(x)  {if (x!=INVALID_HANDLE_VALUE) {CloseHandle(x);x=INVALID_HANDLE_VALUE;}}


                                    // All because printf does not work
                                    // with NT IO redirection
                                    //

#define WRITEF(VArgs)            {                                                 \
                                    HANDLE xh=GetStdHandle(STD_OUTPUT_HANDLE);     \
                                    TCHAR   VBuff[256];                             \
                                    DWORD  tmp;                                    \
                                    _stprintf VArgs;                                 \
                                    WriteFile(xh,VBuff,lstrlen(VBuff),&tmp,NULL);   \
                                 }                                                 \

#define HOSTNAMELEN         16

#define CHARS_PER_LINE      45

#define MAGICNUMBER     0x31109000
#define BEGINMARK       '\xfe'
#define ENDMARK         '\xff'
#define LINESTOSEND     200

#define MAX_SESSION     10

typedef struct
{
    DWORD    Size;
    DWORD    Version;
    TCHAR     ClientName[15];
    DWORD    LinesToSend;
    DWORD    Flag;
}   SESSION_STARTUPINFO;

typedef struct
{
    DWORD MagicNumber;      //New Remote
    DWORD Size;             //Size of structure
    DWORD FileSize;         //Num bytes sent
}   SESSION_STARTREPLY;

typedef struct
{
    TCHAR    Name[HOSTNAMELEN];     //Name of client Machine;
    BOOL    Active;         //Client at the other end connected
    BOOL    CommandRcvd;    //True if a command recieved
    BOOL    SendOutput;     //True if Sendoutput output
    HANDLE  PipeReadH;      //Client sends its StdIn  through this
    HANDLE  PipeWriteH;     //Client gets  its StdOut through this
    HANDLE  rSaveFile;      //Sessions read handle to SaveFile
    HANDLE  hThread;        //Session Thread
    HANDLE  MoreData;       //Event handle set if data available to be read
	SOCKET	Socket;			//Socket for IP Session
	TCHAR    szIP[16];			//IP Address of Client, if NOT IP then NULL
} SESSION_TYPE;



VOID
Server(
    TCHAR* ChildCmd,
    TCHAR* PipeName
    );


VOID
Client(
    TCHAR* ServerName,
    TCHAR* PipeName
    );

VOID
SockClient(
    TCHAR* ServerName,
    TCHAR* PipeName
    );

VOID
ErrorExit(
    TCHAR* str
    );

VOID
DisplayClientHlp(
    );

VOID
DisplayServerHlp(
    );

ULONG
DbgPrint(
    PCH Format,
    ...
    );

DWORD
ReadFixBytes(
    HANDLE hRead,
    TCHAR   *Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    );

DWORD
SockReadFixBytes(
    SOCKET hSocket,
    TCHAR   *Buffer,
    DWORD  ToRead,
    DWORD  TimeOut   //ignore for timebeing
    );

VOID
Errormsg(
    TCHAR* str
    );

BOOL ReadSocket(
		SOCKET s,
		TCHAR * buff,
		int len,
		DWORD* dread);

BOOL WriteSocket(
        SOCKET  s,
        TCHAR * buff,
        int     len,
        DWORD*  dsent);

VOID
Base64Encode(
    TCHAR * String,
    DWORD StringLength,
    TCHAR * EncodeBuffer);

VOID
Base64Decode(
    TCHAR * String,
    TCHAR * DecodeBuffer);

int
GetBase64Index(
    TCHAR A);

VOID
SplitUserName(
    TCHAR * FullName,
    TCHAR * Domain,
    TCHAR * UserName);

#ifdef UNICODE
BOOL WriteSocketA(
        SOCKET  s,
        char *  pszAnsiStr,
        int     len,
        DWORD * dsent);

// caller must free buffer
WCHAR * inet_ntoaw(
    struct in_addr stInet );

BOOL ReadFileW(
    HANDLE          hFile,      // handle of file to read
    WCHAR *         pszBuffer,  // pointer to buffer that receives data
    DWORD           dwLength,   // number of bytes to read
    LPDWORD         pdwRead,    // pointer to number of bytes read
    LPOVERLAPPED    pData       // pointer to structure for data
);

BOOL WriteFileW(
    HANDLE          hFile,      // handle to file to write to
    WCHAR *         pszBuffer,  // pointer to data to write to file
    DWORD           dwWrite,    // number of bytes to write
    LPDWORD         pdwWritten, // pointer to number of bytes written
    LPOVERLAPPED    pData       // pointer to structure for overlapped I/O
);

BOOL    GetAnsiStr(
    WCHAR * pszWideStr,
    char *  pszAnsiStr,
    UINT    uBufSize
);

#endif UNICODE

extern TCHAR   HostName[HOSTNAMELEN];
extern TCHAR*  ChildCmd;
extern TCHAR*  PipeName;
extern TCHAR*  ServerName;
extern TCHAR*  Username;
extern TCHAR*  Password;
extern HANDLE MyOutHandle;
extern DWORD  LinesToSend;
extern BOOL   IsAdvertise;
extern BOOL   bIPLocked;
extern DWORD  ClientToServerFlag;

#endif //__WSREMOTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wsremote.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ws2hdr\ws2hdr.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ws2hdr.c

Abstract:

    Munges the WinSock 2.0 header file.

    This program scans stdin, searching for begin and end tags. Lines of
    text between these tags are assumed to be function prototypes of the
    form:

        function_linkage
        return_type
        calling_convention
        function_name(
            parameters,
            parameters,
            ...
            );

    For each such function prototype found, the following is output:

        #if INCL_WINSOCK_API_PROTOTYPES
        function_linkage
        return_type
        calling_convention
        function_name(
            parameters,
            parameters,
            ...
            );
        #endif

        #if INCL_WINSOCK_API_TYPEDEFS
        typedef
        return_type
        (calling_convention * LPFN_FUNCTION_NAME)(
            parameters,
            parameters,
            ...
            );
        #endif

Author:

    Keith Moore (keithmo)        09-Dec-1995

Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <string.h>


//
// Private constants.
//

#define MAX_HEADER_LINE 128
#define MAX_API_LINES   32

#define BEGIN_APIS      "/*BEGIN_APIS*/"
#define END_APIS        "/*END_APIS*/"


INT
__cdecl
main(
    INT    argc,
    CHAR * argv[]
    )
{

    CHAR lineBuffer[MAX_HEADER_LINE];
    CHAR apiBuffer[MAX_API_LINES][MAX_HEADER_LINE];
    INT i;
    INT apiLineNumber = 0;
    INT fileLineNumber = 0;
    BOOL inApis = FALSE;
    BOOL beginApis;
    BOOL endApis;

    //
    // This app takes no command line arguments.
    //

    if( argc != 1 ) {

        fprintf(
            stderr,
            "WS2HDR v1.01 " __DATE__ "\n"
            );

        fprintf(
            stderr,
            "use: ws2hdr < file1 > file2\n"
            );

        return 1;

    }

    //
    // Read stdin until exhausted.
    //

    while( fgets( lineBuffer, sizeof(lineBuffer), stdin ) != NULL ) {

        fileLineNumber++;

        //
        // fgets() leaves the terminating '\n' on the string; remove it.
        //

        lineBuffer[strlen(lineBuffer) - 1] = '\0';

        //
        // Check for our tags.
        //

        beginApis = FALSE;
        endApis = FALSE;

        if( _stricmp( lineBuffer, BEGIN_APIS ) == 0 ) {

            beginApis = TRUE;

        } else if( _stricmp( lineBuffer, END_APIS ) == 0 ) {

            endApis = TRUE;

        }

        //
        // Warn if we got an invalid tag.
        //

        if( beginApis && inApis ) {

            fprintf(
                stderr,
                "WARNING: unexpected %s, line %d\n",
                BEGIN_APIS,
                fileLineNumber
                );

            continue;

        }

        if( endApis && !inApis ) {

            fprintf(
                stderr,
                "WARNING: unexpected %s, line %d\n",
                END_APIS,
                fileLineNumber
                );

            continue;

        }

        //
        // Remember if we're currently between tags.
        //

        if( beginApis ) {

            inApis = TRUE;
            continue;

        }

        if( endApis ) {

            inApis = FALSE;
            continue;

        }

        //
        // If we're not between tags, or if the line is empty, just
        // output the line.
        //

        if( !inApis ) {

            printf( "%s\n", lineBuffer );
            continue;

        }

        if( lineBuffer[0] == '\0' ) {

            printf( "\n" );
            continue;

        }

        //
        // Add the line to our buffer. If the line doesn't end in ';',
        // then we're not at the end of the prototype, so keep reading
        // and scanning.
        //

        strcpy( &apiBuffer[apiLineNumber++][0], lineBuffer );

        if( lineBuffer[strlen(lineBuffer) - 1] != ';' ) {

            continue;

        }

        //
        // At this point the following are established in apiBuffer:
        //
        //  apiBuffer[0] == function linkage
        //  apiBuffer[1] == return type
        //  apiBuffer[2] == calling convention
        //  apiBuffer[3] == function name (with trailing '(')
        //  apiBuffer[4..n-1] == parameters
        //  apiBuffers[n] == ");"
        //

        //
        // First, dump out the prototype with its appropriate CPP protector.
        //

        printf( "#if INCL_WINSOCK_API_PROTOTYPES\n" );

        for( i = 0 ; i < apiLineNumber ; i++ ) {

            printf( "%s\n", &apiBuffer[i][0] );

        }

        printf( "#endif // INCL_WINSOCK_API_PROTOTYPES\n" );
        printf( "\n" );

        //
        // Now dump out the typedef with its appropriate CPP protector.
        //
        // Note that we must munge the api function name around a bit
        // first. Specifically, we remove the trailing '(' and map the
        // name to uppercase.
        //

        printf( "#if INCL_WINSOCK_API_TYPEDEFS\n" );

        apiBuffer[3][strlen( &apiBuffer[3][0] ) - 1] = '\0';
        _strupr( &apiBuffer[3][0] );

        printf( "typedef\n" );
        printf( "%s\n", &apiBuffer[1][0] );
        printf( "(%s * LPFN_%s)(\n", &apiBuffer[2][0], &apiBuffer[3][0] );

        for( i = 4 ; i < apiLineNumber ; i++ ) {

            printf( "%s\n", &apiBuffer[i][0] );

        }

        printf( "#endif // INCL_WINSOCK_API_TYPEDEFS\n" );

        //
        // Start over at the next input line.
        //

        apiLineNumber = 0;

    }

    return 0;

}   // main
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wsremote\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    Server.c

Abstract:

    The server component of Remote. It spawns a child process
    and redirects the stdin/stdout/stderr of child to itself.
    Waits for connections from clients - passing the
    output of child process to client and the input from clients
    to child process.

Author:

    Rajivendra Nath (rajnath) 2-Jan-1992

Environment:

    Console App. User mode.

Revision History:

--*/

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include "Remote.h"


#define MAX_SESSION   10

#define COMMANDFORMAT     TEXT("%c%-15s    [%-15s %s]\n%c")
#define LOCALNAME         TEXT("Local")
#define LOCALCLIENT(x)    (strcmp((char *)(x->Name),LOCALNAME)==0)
#define RemoteInfo(prt,flg) {if (!(flg&&0x80000000)) prt;}


#define CMDSTRING(OutBuff,InpBuff,Client,szTime)  {                              \
                                                    _stprintf                      \
                                                    (                            \
                                                       &OutBuff[0],COMMANDFORMAT,\
                                                       BEGINMARK,InpBuff,        \
                                                       Client->Name,szTime,      \
                                                       ENDMARK                   \
                                                    );                           \
                                                 }                               \

#ifdef UNICODE
int MakeCommandString(
    TCHAR * pszOutput,
    TCHAR * pszInput,
    TCHAR * pszName,
    TCHAR * pszTime);
#endif

#define BUFFSIZE      256

#ifdef INTERNALUSECOMPONENT
VOID InitAd(BOOL IsAdvertise);
VOID ShutAd(BOOL IsAdvertise);
#endif

static SOCKET listenSocket;
SESSION_TYPE ClientList[MAX_SESSION];


HANDLE  ChildStdInp;     //Server Writes to  it
HANDLE  ChildStdOut;     //Server Reads from it
HANDLE  ChildStdErr;     //Server Reads from it

HANDLE  SaveFile;       //File containing all that was
                        //output by child process.
                        //Each connection opens a handle to this file
                        //and is sent through PipeWriteH.

TCHAR   SaveFileName[MAX_PATH+1]; //Name of above file - all new sessions need
HANDLE  ChldProc;
HANDLE  ListenThreadH;
HANDLE  SockListenThreadH;

// GetFormattedTime -- returns pointer to formatted time
//
// returns pointer to static buffer which should be OK.
//


TCHAR * GetFormattedTime(VOID)
{
    static TCHAR    szTime[30];

    //
    // Get time and format to characters
    //

    GetTimeFormat( LOCALE_USER_DEFAULT,
                   TIME_NOSECONDS | TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER,
                   NULL,   // use current time
                   NULL,   // use default format
                   szTime,
                   30 );

    return( (TCHAR *)&szTime );
}


HANDLE
ForkChildProcess(          // Creates a new process
    TCHAR *cmd,             // Redirects its stdin,stdout
    PHANDLE in,            // and stderr - returns the
    PHANDLE out,           // corresponding pipe ends.
    PHANDLE err
    );

HANDLE
OldForkChildProcess(       //Same as above except different
    TCHAR *cmd,             //method for redirection...for
    PHANDLE in,            //compatibility with.
    PHANDLE out,
    PHANDLE err
    );


DWORD
ListenForSession(          //THREAD:Listens for new connections and
    TCHAR * pipe             //spawns of new seesions - Updates the
    );                     //Status in Client DataStructure.



DWORD
NewSession(                //Manages the session with a client.
    SESSION_TYPE* Client
    );

DWORD                      //2 THREAD:Each reads either
GetChldOutput(             //StdOut or StdErr of child and
    HANDLE rhandle          //writes to SaveFile.
    );



DWORD
TransferFileToClient(      //X THREADS:Reads the save
    SESSION_TYPE* Client        //file and sendsoutput to a client.
    );


DWORD
GetClientInput(            //X THREADS:Gets input from Child pipe
    SESSION_TYPE* Client       //and sends to childs StdIn.
    );

BOOL
FilterCommand(             //Filters input from client
    SESSION_TYPE *cl,      //for commands intended for REMOTE
    TCHAR *buff,
    int dread
    );

DWORD
LocalSession(
    PVOID noarg
    );

DWORD
RemoteSession(
    SESSION_TYPE* Client
    );

BOOL
SrvCtrlHand(
    DWORD event
    );

VOID
SendStatus(
    HANDLE hClientPipe
    );

VOID
SockSendStatus(
    SOCKET MySocket
    );

DWORD
ShowPopup(
    TCHAR *mssg
    );

VOID
RemoveInpMark(
    TCHAR* Buff,
    DWORD Size
    );

VOID
CloseClient(
    SESSION_TYPE *Client
    );

VOID
InitClientList(
    );

/*************************************************************/
/*************************************************************/

DWORD
SockListenForSession(          //THREAD:Listens for new connections and
    TCHAR* pipe             //spawns of new seesions - Updates the
    );                     //Status in Client DataStructure.

DWORD
SockNewSession(                //Manages the session with a client.
    SESSION_TYPE* Client
    );

DWORD
SockTransferFileToClient(      //X THREADS:Reads the save
    SESSION_TYPE* Client        //file and sendsoutput to a client.
    );

DWORD
SockRemoteSession(
    SESSION_TYPE* Client
    );

DWORD
SockGetClientInput(            //X THREADS:Gets input from Child pipe
    SESSION_TYPE* Client       //and sends to childs StdIn.
    );

BOOL
SockAuthenticate(
    SOCKET MySocket
    );
/*************************************************************/
/*************************************************************/


/*************************************************************/
VOID
Server(                    //Main routine for server.
    TCHAR* ChildCmd,
    TCHAR* PipeName
    )
{
    WORD wVersionRequested = MAKEWORD(1,1);
    WSADATA wsaData;

    DWORD  ThreadID ;//No use
    HANDLE WaitH[3];
    DWORD  WaitObj;
    TCHAR   tmpdir[MAX_PATH+1];
    int nRet;

    _tprintf(TEXT("**************************************\n")
             TEXT("***********    WSREMOTE   ************\n")
             TEXT("***********     SERVER    ************\n")
             TEXT("**************************************\n")
             TEXT("To Connect: WSRemote /C %s %s\n\n"),HostName,PipeName);

    InitClientList();

    //
    // Initialize WinSock
    //
    nRet = WSAStartup(wVersionRequested, &wsaData);
    if (nRet)
    {
        _tprintf(TEXT("Initialize WinSock Failed"));
        return ;
    }
    // Check version
    if (wsaData.wVersion != wVersionRequested)
    {
        _tprintf(TEXT("Wrong WinSock Version"));
        return;
    }

    //
    // set environment variable
    //

    SetEnvironmentVariable(TEXT("_REMOTE"), PipeName);

    //
    //Start the command as a child process
    //

    ChldProc=ForkChildProcess(ChildCmd,&ChildStdInp,&ChildStdOut,&ChildStdErr);

    //
    //Create a tempfile for storing Child process output.
    //
    {
         DWORD rc = GetTempPath(sizeof(tmpdir),tmpdir);
         if (!rc || rc > sizeof(tmpdir))
         {
            _stprintf(tmpdir,TEXT("%s"),TEXT("."));
         }
         if (!GetTempFileName(tmpdir,TEXT("REMOTE"),0,SaveFileName))
              GetTempFileName(TEXT("."),TEXT("REMOTE"),0,SaveFileName);
    }


    if ((SaveFile=CreateFile(
                             (LPCTSTR)SaveFileName,           /* address of name of the file  */           \
                             GENERIC_READ|GENERIC_WRITE,      /* access (read/write) mode */               \
                             FILE_SHARE_READ|FILE_SHARE_WRITE,/* share mode   */                           \
                             (LPSECURITY_ATTRIBUTES)NULL,     /* security descriptor  */                   \
                             CREATE_ALWAYS,                   /* how to create    */                       \
                             FILE_ATTRIBUTE_NORMAL,           /* File Attribute */                    /* file attributes  */                       \
                             (HANDLE)NULL))==NULL)
    {
        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Could not Create Output File"));
    }


    //
    //Start 2 threads to save the output from stdout and stderr of cmd to savefile.
    //

    if ((WaitH[0]=CreateThread(
                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                     (DWORD)0,                              // Use same stack size.
                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure.
                     (LPVOID)ChildStdErr,                   // Parameter to pass.
                     (DWORD)0,                              // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed to Create GetGhldOutput#1 Thread"));
    }


    if ((WaitH[1]=CreateThread(
                     (LPSECURITY_ATTRIBUTES)NULL,           // No security attributes.
                     (DWORD)0,                              // Use same stack size.
                     (LPTHREAD_START_ROUTINE)GetChldOutput, // Thread procedure.
                     (LPVOID)ChildStdOut,                   // Parameter to pass.
                     (DWORD)0,                              // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed to Create GetGhldOutput#2 Thread"));
    }


    //
    //Start Thread to listen for new Connections
    //

    if ((ListenThreadH=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)ListenForSession, // Thread procedure.
                     (LPVOID)PipeName,       // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create ListenForSession Thread"));

    }


    //
    //Start Thread to listen for new Connections
    //

    if ((SockListenThreadH=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)SockListenForSession, // Thread procedure.
                     (LPVOID)PipeName,       // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create SockListenForSession Thread"));

    }

    //
    //Start Local Thread
    //

    if ((ClientList[0].hThread=CreateThread((LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                    (DWORD)0,                           // Use same stack size.
                    (LPTHREAD_START_ROUTINE)LocalSession, // Thread procedure.
                    (LPVOID)NULL,        // Parameter to pass.
                    (DWORD)0,                           // Run immediately.
                    (LPDWORD)&ThreadID))==NULL)
    {

        TerminateProcess(ChldProc,0);
        ErrorExit(TEXT("Failed To Create ListenForSession Thread"));

    }

    SetConsoleCtrlHandler((PHANDLER_ROUTINE)SrvCtrlHand,TRUE);

#ifdef INTERNALUSECOMPONENT
    InitAd(IsAdvertise);
#endif

    WaitH[2]=ChldProc;
    WaitObj=WaitForMultipleObjects(3,WaitH,FALSE,INFINITE);
    switch (WaitObj-WAIT_OBJECT_0)
    {
        case 0:      // Error Writing to savefile
        case 1:
            TerminateProcess(ChldProc,0);
            break;
        case 2:      // Child Proc Terminated
            break;

        default:     // Out of Some Resource
            _tprintf(TEXT("Out of Resource Error %d..Terminating\n"),GetLastError());
            break;

    }

    TerminateThread(ListenThreadH,0);
    // SOCK:
    TerminateThread(SockListenThreadH,0);

#ifdef INTERNALUSECOMPONENT
    ShutAd(IsAdvertise);
#endif


    CloseHandle(ChildStdInp);
    CloseHandle(ChildStdOut);
    CloseHandle(ChildStdErr);

     //WSACleanup
    WSACleanup();
    _tprintf(TEXT("\nCalling WSACleanup()..\n"));

    _tprintf(TEXT("\nRemote:Parent exiting. Child(%s) dead..\n"),ChildCmd);

    CloseHandle(SaveFile);

    {
        int i;
        for (i=0;i<MAX_SESSION;i++)
            CloseClient(&ClientList[i]);
    }

    if (!DeleteFile(SaveFileName))
          _tprintf(TEXT("Temp File %s not deleted..\n"),SaveFileName);

    return;
}
/*************************************************************/
HANDLE
ForkChildProcess(          // Creates a new process
    TCHAR *cmd,             // Redirects its stdin,stdout
    PHANDLE inH,            // and stderr - returns the
    PHANDLE outH,           // corresponding pipe ends.
    PHANDLE errH
    )

{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    HANDLE ChildIn;
    HANDLE ChildOut;
    HANDLE ChildErr;

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //
    //Create Parent_Write to ChildStdIn Pipe
    //

    if (!CreatePipe(&ChildIn,inH,&lsa,0))
        ErrorExit(TEXT("Could Not Create Parent-->Child Pipe"));

    //
    //Create ChildStdOut to Parent_Read pipe
    //

    if (!CreatePipe(outH,&ChildOut,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //
    //Create ChildStdOut to Parent_Read pipe
    //

    if (!CreatePipe(errH,&ChildErr,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //
    // Lets Redirect Console StdHandles - easy enough
    //


    si.cb=sizeof(STARTUPINFO);
    si.lpReserved=NULL;
    si.lpTitle=NULL;
    si.lpDesktop=NULL;
    si.dwX=si.dwY=si.dwYSize=si.dwXSize=0;
    si.dwFlags=STARTF_USESTDHANDLES;
    si.hStdInput =ChildIn;
    si.hStdOutput=ChildOut;
    si.hStdError =ChildErr;
    si.wShowWindow=SW_SHOW;
    si.lpReserved2=NULL;
    si.cbReserved2=0;

    //
    //Create Child Process
    //

    if (!CreateProcess( NULL,
                cmd,
                NULL,
                NULL,
                TRUE,
                NORMAL_PRIORITY_CLASS,
                NULL,
                NULL,
                &si,
                &pi))
    {
        if (GetLastError()==2)
            _tprintf(TEXT("Executable %s not found\n"),cmd);
        ErrorExit(TEXT("Could Not Create Child Process"));
    }

    //
    //Close unneccesary Handles and Restore the crt handles
    //

    CloseHandle(ChildIn);
    CloseHandle(ChildOut);
    CloseHandle(ChildErr);

    return(pi.hProcess);
}
/*************************************************************/
HANDLE
OldForkChildProcess(
    TCHAR *cmd,
    PHANDLE inH,
    PHANDLE outH,
    PHANDLE errH
    )
{
    SECURITY_ATTRIBUTES lsa;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;

    HANDLE OldStdIn =GetStdHandle(STD_INPUT_HANDLE);
    HANDLE OldStdOut=GetStdHandle(STD_OUTPUT_HANDLE);
    HANDLE OldStdErr=GetStdHandle(STD_ERROR_HANDLE);

    HANDLE ChildStdIn;
    HANDLE ChildStdOut;
    HANDLE ChildStdErr;

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=NULL;
    lsa.bInheritHandle=TRUE;

    //Create Parent_Write to ChildStdIn Pipe
    if (!CreatePipe(&ChildStdIn,inH,&lsa,0))
        ErrorExit(TEXT("Could Not Create Parent-->Child Pipe"));

    //Create ChildStdOut to Parent_Read pipe
    if (!CreatePipe(outH,&ChildStdOut,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //Create ChildStdOut to Parent_Read pipe
    if (!CreatePipe(errH,&ChildStdErr,&lsa,0))
        ErrorExit(TEXT("Could Not Create Child-->Parent Pipe"));

    //Make ChildStdIn and Out as standard handles and get it inherited by child
    if (!SetStdHandle(STD_INPUT_HANDLE,ChildStdIn))
        ErrorExit(TEXT("Could not change StdIn"));

    if (!SetStdHandle(STD_OUTPUT_HANDLE,ChildStdOut))
        ErrorExit(TEXT("Could Not change StdOut"));

    if (!SetStdHandle(STD_ERROR_HANDLE,ChildStdErr))
        ErrorExit(TEXT("Could Not change StdErr"));

    si.cb=sizeof(STARTUPINFO);
    si.lpReserved=NULL;
    si.lpTitle=NULL;
    si.lpDesktop=NULL;
    si.dwX=si.dwY=si.dwYSize=si.dwXSize=si.dwFlags=0L;
    si.wShowWindow=SW_SHOW;
    si.lpReserved2=NULL;
    si.cbReserved2=0;

    //Create Child Process
    if (!CreateProcess( NULL,
                        cmd,
                        NULL,
                        NULL,
                        TRUE,
                        NORMAL_PRIORITY_CLASS,
                        NULL,
                        NULL,
                        &si,
                        &pi))
        ErrorExit(TEXT("Could Not Create Child Process"));

    //reset StdIn StdOut
    if (!SetStdHandle(STD_INPUT_HANDLE,OldStdIn))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }
    if (!SetStdHandle(STD_OUTPUT_HANDLE,OldStdOut))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }

    if (!SetStdHandle(STD_ERROR_HANDLE,OldStdErr))
    {
        TerminateProcess(pi.hProcess,1);
        ErrorExit(TEXT("Could not RESET StdIn"));
    }

    //Close unneccesary Handles
    CloseHandle(ChildStdIn);
    CloseHandle(ChildStdOut);
    CloseHandle(ChildStdErr);
    return(pi.hProcess);
}
/*************************************************************/

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif
/*************************************************************/
DWORD
ListenForSession(
   TCHAR* pipename
   )
{
    int    i;
    DWORD  ThreadID;
    HANDLE PipeH[2];
    SECURITY_DESCRIPTOR SecurityDescriptor;
    SECURITY_ATTRIBUTES lsa;

    TCHAR   fullnameIn[BUFFSIZE];
    TCHAR   fullnameOut[BUFFSIZE];


    _stprintf(fullnameIn,SERVER_READ_PIPE  ,TEXT("."),pipename);
    _stprintf(fullnameOut,SERVER_WRITE_PIPE,TEXT("."),pipename);
    //
    // Initialize the security descriptor that we're going to
    // use - everyone has access (use remote.exe if you want /u support)
    //

    InitializeSecurityDescriptor
    (
        &SecurityDescriptor,
        SECURITY_DESCRIPTOR_REVISION
    );

    (VOID) SetSecurityDescriptorDacl
           (
               &SecurityDescriptor,
               TRUE,
               NULL,
               FALSE
           );

    lsa.nLength=sizeof(SECURITY_ATTRIBUTES);
    lsa.lpSecurityDescriptor=&SecurityDescriptor;
    lsa.bInheritHandle=TRUE;

    while(TRUE)
    {
        PipeH[0]=CreateNamedPipe
                 (
                    fullnameIn ,
                    PIPE_ACCESS_INBOUND ,
                    PIPE_TYPE_BYTE,
                    PIPE_UNLIMITED_INSTANCES,
                    0,0,0,&lsa
                 );

        PipeH[1]=CreateNamedPipe
                 (
                    fullnameOut,
                    PIPE_ACCESS_OUTBOUND,
                    PIPE_TYPE_BYTE,
                    PIPE_UNLIMITED_INSTANCES,
                    0,0,0,&lsa
                 );

        if (!ConnectNamedPipe(PipeH[0],NULL))
        {
            if (GetLastError()!=ERROR_PIPE_CONNECTED)
            {
                CloseHandle(PipeH[0]);
                CloseHandle(PipeH[1]);
                continue;
            }

        }

        if (!ConnectNamedPipe(PipeH[1],NULL))
        {
            if (GetLastError()!=ERROR_PIPE_CONNECTED)
            {
                CloseHandle(PipeH[0]);
                CloseHandle(PipeH[1]);
                continue;
            }
        }

        //
        //Look For a Free Slot & if not- then terminate connection
        //

        for (i=1;i<MAX_SESSION;i++)
        {
            //
            // Locate a Free Client block
            //
            if (!ClientList[i].Active)
                break;
        }

        if (i<MAX_SESSION)
        {
            //
            // Initialize the Client
            //
            ClientList[i].PipeReadH=PipeH[0];
            ClientList[i].PipeWriteH=PipeH[1];
            ClientList[i].Active=TRUE;
            ClientList[i].SendOutput=TRUE;
            ClientList[i].CommandRcvd=FALSE;

        }
        else
        {
            _tprintf(TEXT("Remote:Closing New Session - No more slots\n"));
            CloseHandle(PipeH[0]);
            CloseHandle(PipeH[1]);
            continue;
        }

        //
        //start new thread for this connection
        //

        if((ClientList[i].hThread=CreateThread (
                     (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                     (DWORD)0,                           // Use same stack size.
                     (LPTHREAD_START_ROUTINE)RemoteSession, // Thread procedure.
                     (LPVOID)&ClientList[i],             // Parameter to pass.
                     (DWORD)0,                           // Run immediately.
                     (LPDWORD)&ThreadID))==NULL)
        {
            CloseClient(&ClientList[i]);
            continue;
        }
    }
    return(0);
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif

/*************************************************************/
DWORD
RemoteSession(
    SESSION_TYPE         *MyClient
    )
{
    DWORD                ReadCnt;
    SESSION_STARTUPINFO  ssi;
    TCHAR                 *headerbuff;
    TCHAR                 msg[BUFFSIZE];
    DWORD                tmp;
    SESSION_STARTREPLY   ssr;

    memset((TCHAR *)&ssi,0,sizeof(ssi));

    if ((MyClient->rSaveFile=CreateFile(
        SaveFileName,
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,NULL))==NULL)

    {
        CloseClient(MyClient);
        return(1);
    }



    {
        DWORD reply=0;

        ReadFixBytes(MyClient->PipeReadH,(TCHAR *)MyClient->Name,HOSTNAMELEN-1,0);

        //
        //Last four Bytes contains a code
        //

        memcpy((TCHAR *)&reply,(TCHAR *)&(MyClient->Name[11]),4);

        if (reply!=MAGICNUMBER)
        {
            //
            // Unknown client
            //
            CloseClient(MyClient);
            return(1);
        }

        ssr.MagicNumber=MAGICNUMBER;
        ssr.Size=sizeof(ssr);
        ssr.FileSize=GetFileSize( MyClient->rSaveFile, &tmp );

        WriteFile(MyClient->PipeWriteH,(TCHAR *)&ssr,sizeof(ssr),&tmp,NULL);
    }

    if (ReadFixBytes(MyClient->PipeReadH,(TCHAR *)&(ssi.Size),sizeof(ssi.Size),0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    if (ssi.Size>1024)      //Sanity Check
    {
        _stprintf(msg,TEXT("%s"),"Server:Unknown Header..Terminating session\n");
        WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);
        CloseClient(MyClient);
        return(1);

    }


    if ((headerbuff=(TCHAR *)calloc(ssi.Size,1))==NULL)
    {
        _stprintf(msg,TEXT("%s"),"Server:Not Enough Memory..Terminating session\n");
        WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);
        CloseClient(MyClient);
        return(1);

    }

    ReadCnt=ssi.Size-sizeof(ssi.Size);
    if (ReadFixBytes(MyClient->PipeReadH,(TCHAR *)headerbuff,ReadCnt,0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    memcpy((TCHAR *)&ssi+sizeof(ssi.Size),headerbuff,sizeof(ssi)-sizeof(ssi.Size));
    free(headerbuff);

    /* Version  */
    if (ssi.Version!=VERSION)
    {
         _stprintf(msg,TEXT("WSRemote Warning:Server Version=%d Client Version=%d\n"),VERSION,ssi.Version);
         WriteFile(MyClient->PipeWriteH,msg,_tcslen(msg),&tmp,NULL);

    }

    /* Name  */
    {
        memcpy(MyClient->Name,ssi.ClientName,15);
        MyClient->Name[14]=0;

    }

    /* Lines  */
    if (ssi.LinesToSend!=-1)
    {
        long  PosFromEnd=ssi.LinesToSend*CHARS_PER_LINE;
        DWORD BytesToSend=MINIMUM((DWORD)PosFromEnd,ssr.FileSize);
        DWORD BytesRead;
        TCHAR  *buff=(TCHAR *)calloc(BytesToSend+1,1);

        if (ssr.FileSize > (DWORD)PosFromEnd)
        {
            SetFilePointer( MyClient->rSaveFile,
                            -PosFromEnd,
                            (PLONG)NULL,
                            FILE_END
                           );

        }

        if (buff!=NULL)
        {
            if (!ReadFile(MyClient->rSaveFile,buff,BytesToSend,&BytesRead,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }

            RemoveInpMark(buff,BytesRead);
            if (!WriteFile(MyClient->PipeWriteH,buff,BytesRead,&tmp,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }
        }
        free(buff);

    }

    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Connected To %s [%s]\n"),MyClient->Name,GetFormattedTime()),ssi.Flag);
    NewSession(MyClient);
    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Disconnected From %s [%s]\n"),MyClient->Name,GetFormattedTime()),ssi.Flag);
    CloseClient(MyClient);
    return(0);
}
/*************************************************************/
DWORD
NewSession(
    SESSION_TYPE* MyClient
    )
{
    DWORD        ThreadId;
    HANDLE       rwThread[3];

    MyClient->MoreData=CreateEvent
    (
            (LPSECURITY_ATTRIBUTES) NULL,/* address of security attributes	*/
            FALSE,                	     /* flag for manual-reset event	*/
            TRUE,	                     /* flag for initial state	*/
            NULL	                     /* address of event-object name	*/
    );



    if ((rwThread[0]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)GetClientInput, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        return(GetLastError());
    }


    if ((rwThread[1]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)TransferFileToClient, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        CloseHandle(rwThread[0]);
        return(GetLastError());
    }

    rwThread[2]=ChldProc;
    WaitForMultipleObjects(3, rwThread,FALSE, INFINITE);

    TerminateThread(rwThread[0],1);
    TerminateThread(rwThread[1],1);

    CloseHandle(rwThread[0]);
    CloseHandle(rwThread[1]);

    return(0);
}
/*************************************************************/
DWORD
GetChldOutput(
    HANDLE readH
    )
{
    TCHAR  buff[BUFFSIZE];
    DWORD dread;
    DWORD tmp;


    while(ReadFile(readH,buff,BUFFSIZE-1,&dread,NULL))
    {
        buff[dread]='\0';

        if (!WriteFile(SaveFile,buff,dread,&tmp,NULL))
        {
            return(1);
        }

        //
        // Signal Reader Thread that more data
        //
        {
            int i;
            DWORD err; //REMOVE
            for (i=0;i<MAX_SESSION;i++)
            {
                if (ClientList[i].Active)
                {
                    if (!SetEvent(ClientList[i].MoreData))
                    	err=GetLastError(); //REMOVE
                }
            }
        }
    }
    return(1);
}
/*************************************************************/
DWORD
TransferFileToClient(
    SESSION_TYPE *MyClient
    )
{

    TCHAR          buffin[BUFFSIZE],buffout[BUFFSIZE],cmdbuff[BUFFSIZE];
    DWORD  tmp;
    DWORD  dread=0,dwrite=0;
    BOOL   incmd=FALSE;
    DWORD  cmdP=0;
    DWORD  i;
    TCHAR   MyEchoStr[30];

    _stprintf(MyEchoStr,TEXT("[%-15s"),MyClient->Name);

    while(ReadFile(MyClient->rSaveFile,buffin,BUFFSIZE-1,&dread,NULL))
    {
        if (dread==0)
        {
            WaitForSingleObject(MyClient->MoreData,INFINITE);
            continue;
        }
        dwrite=0;
        for(i=0;i<dread;i++)
        {
            if (incmd)
            {
                if ((buffin[i]==ENDMARK)||(cmdP==BUFFSIZE-1))
                {
                    incmd=FALSE;
                    cmdbuff[cmdP]=0;
                    if ((_tcsstr(cmdbuff,MyEchoStr)==NULL)||
                        (!MyClient->CommandRcvd))
                    {
                        if (!WriteFile(
                            MyClient->PipeWriteH,
                            cmdbuff,cmdP,&tmp,NULL))
                        {
                            return(1);
                        }
                    }
                    cmdP=0;
                }
                else
                {
                    cmdbuff[cmdP++]=buffin[i];
                }
            }
            else
            {

                if (buffin[i]==BEGINMARK)
                {
                    if (dwrite!=0)
                    {
                        if (!WriteFile(
                            MyClient->PipeWriteH,
                            buffout,dwrite,&tmp,NULL))
                        {
                            return(1);
                        }
                        dwrite=0;
                    }
                    incmd=TRUE;
                    continue;
                }
                else
                {
                    buffout[dwrite++]=buffin[i];
                }
            }
        }

        if (dwrite!=0)
        {
            if (!WriteFile(
                MyClient->PipeWriteH,
                buffout,dwrite,&tmp,NULL))
            {
                return(0);
            }
        }
    }
    return(1);
}

/*************************************************************/
DWORD
GetClientInput(
    SESSION_TYPE *MyClient
    )
{
    TCHAR buff[BUFFSIZE];
    DWORD tmp,dread;

#ifdef UNICODE
    while(ReadFileW(MyClient->PipeReadH,buff,BUFFSIZE,&dread,NULL))
#else
    while(ReadFile(MyClient->PipeReadH,buff,BUFFSIZE,&dread,NULL))
#endif
    {
        buff[dread]=0;
        MyClient->CommandRcvd=TRUE;

        if (FilterCommand(MyClient,buff,dread))
            continue;


        if (!WriteFile(ChildStdInp,buff,dread,&tmp,NULL))
        {
            ExitThread(0);
        }
    }
    return(1);
}
/*************************************************************/

BOOL
FilterCommand(
    SESSION_TYPE *cl,
    TCHAR *buff,
    int dread
    )
{
    TCHAR	inp_buff[4096];
    TCHAR   tmpchar;
    TCHAR   ch[3];
    DWORD   tmp;
    int     len;
    DWORD   ThreadID; //Useless

    if (dread==0)
        return(FALSE);

    buff[dread]=0;


    if (buff[0]==COMMANDCHAR)
    {
        switch(buff[1])
        {
            case 'l':
            case 'L':
				  if (bIPLocked == FALSE)
				  {
						bIPLocked=TRUE;
						_tprintf(TEXT("**LOCK: No IP Sessions Allowed\n"));
				  }
				  else
				  {
					bIPLocked=FALSE;
						_tprintf(TEXT("**LOCK: IP Sessions Now Allowed\n"));
				  }
                  break;
        case 'o':
        case 'O': cl->SendOutput=!cl->SendOutput;
                  break;
        case 'k':
        case 'K':TerminateProcess(ChldProc,1);
                 break;
        case 's':
        case 'S':
                 SendStatus(cl->PipeWriteH);
                 break;

        case 'p':
        case 'P':
        {
            TCHAR  *mssg=(TCHAR *)calloc(4096,1); //Free it in called Proc
            TCHAR  *ack=TEXT("WSRemote:Popup Shown..\n");

            if (mssg==NULL)
                break;

            _stprintf(mssg,TEXT("From %s [%s]\n\n%s\n"),cl->Name,GetFormattedTime(),&buff[2]);
            CreateThread(
                  (LPSECURITY_ATTRIBUTES)NULL,         // No security attributes.
                  (DWORD)0,              // Use same stack size.
                  (LPTHREAD_START_ROUTINE)ShowPopup, // Thread procedure.
                  (LPVOID)mssg,          // Parameter to pass.
                  (DWORD)0,              // Run immediately.
                  (LPDWORD)&ThreadID
                 );
#ifdef UNICODE
            WriteFileW(cl->PipeWriteH,ack,_tcslen(ack),&tmp,NULL);
#else
            WriteFile(cl->PipeWriteH,ack,_tcslen(ack),&tmp,NULL);
#endif
            break;
         }

        case 'm':
        case 'M':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
#ifdef UNICODE
                WriteFileW(SaveFile,inp_buff,len,&tmp,NULL);
#else
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
#endif
                break;

        case '@':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,&buff[1],cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
#ifdef UNICODE
                WriteFileW(SaveFile,inp_buff,len,&tmp,NULL);
#else
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
#endif
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process
                break;


        default :
                _stprintf(inp_buff,TEXT("%s"),"** Unknown Command **\n");
#ifdef UNICODE
                WriteFileW( cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#else
                WriteFile( cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#endif
            case 'h':
            case 'H':
            {
#ifdef UNICODE
                _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                WriteFileW(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#else
                _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
                _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                WriteFile(cl->PipeWriteH,inp_buff,_tcslen(inp_buff),&tmp,NULL);
#endif
                break;
            }
        }
        return(TRUE);
    }


    if ((buff[0]<26))
    {
        BOOL    ret=FALSE;
#ifdef UNICODE
        TCHAR * pszTime;
#endif

        _stprintf(ch,TEXT("^%c"),buff[0]+64);
#ifdef UNICODE
        pszTime = GetFormattedTime();
        MakeCommandString( inp_buff, ch, cl->Name, pszTime);
#else
        CMDSTRING(inp_buff,ch,cl,GetFormattedTime());
#endif
        len=_tcslen(inp_buff);

        if (buff[0]==CTRLC)
        {
            cl->CommandRcvd=FALSE;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
            ret=TRUE; //Already sent to child
        }

        WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
        return(ret); //FALSE:send it to child StdIn
    }


    tmpchar=buff[dread-2]; //must be 13;but just incase
    buff[dread-2]=0;
#ifdef UNICODE
    MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
    CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
    buff[dread-2]=tmpchar;
    len=_tcslen(inp_buff);
    WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
    return(FALSE);
}
/*************************************************************/

BOOL
SockFilterCommand(
    SESSION_TYPE *cl,
    TCHAR *buff,
    int dread
    )
{
    TCHAR       inp_buff[4096];
    TCHAR       tmpchar;
    TCHAR       ch[3];
    DWORD      tmp;
    int        len;
    DWORD      ThreadID; //Useless

    if (dread==0)
        return(FALSE);

    buff[dread]=0;

    if (buff[0]==COMMANDCHAR)
    {
        switch(buff[1])
        {
        case 'o':
        case 'O': cl->SendOutput=!cl->SendOutput;
                  break;
        case 'k':
        case 'K':TerminateProcess(ChldProc,1);
                 break;
        case 's':
        case 'S':
                 SockSendStatus(cl->Socket);
                 break;

        case 'p':
        case 'P':
        {
            TCHAR  *mssg=(TCHAR *)calloc(4096,1); //Free it in called Proc
            TCHAR  *ack=TEXT("WSRemote:Popup Shown..\n");

            if (mssg==NULL)
                break;

            _stprintf(mssg,TEXT("From %s [%s]\n\n%s\n"),cl->Name,GetFormattedTime(),&buff[2]);
            CreateThread(
                  (LPSECURITY_ATTRIBUTES)NULL,         // No security attributes.
                  (DWORD)0,              // Use same stack size.
                  (LPTHREAD_START_ROUTINE)ShowPopup, // Thread procedure.
                  (LPVOID)mssg,          // Parameter to pass.
                  (DWORD)0,              // Run immediately.
                  (LPDWORD)&ThreadID
                 );
            WriteSocket(cl->Socket,ack,_tcslen(ack),&tmp);
            break;
         }

        case 'm':
        case 'M':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
                break;

        case '@':
                buff[dread-2]=0;
#ifdef UNICODE
                MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
                CMDSTRING(inp_buff,&buff[1],cl,GetFormattedTime());
#endif
                len=_tcslen(inp_buff);
                WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
                //
                // Remove the first @ sign
                //
                MoveMemory(buff,&buff[1],dread-1);
                buff[dread-1]=' ';
                return(FALSE); //Send it it to the chile process
                break;


        default :
                _stprintf(inp_buff,TEXT("%s"),"** Unknown Command **\n");
                WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
        case 'h':
        case 'H':
                 _stprintf(inp_buff,TEXT("%cM: To Send Message\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cP: To Generate popup\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cK: To kill the server\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 _stprintf(inp_buff,TEXT("%cH: This Help\n"),COMMANDCHAR);
                 WriteSocket(cl->Socket,inp_buff,_tcslen(inp_buff),&tmp);
                 break;
        }
        return(TRUE);
    }


    if ((buff[0]<26))
    {
        BOOL ret=FALSE;

        _stprintf(ch,TEXT("^%c"),buff[0]+64);
#ifdef UNICODE
        MakeCommandString( inp_buff, ch, cl->Name, GetFormattedTime());
#else
        CMDSTRING(inp_buff,ch,cl,GetFormattedTime());
#endif
        len=_tcslen(inp_buff);


        if (buff[0]==CTRLC)
        {
            cl->CommandRcvd=FALSE;
            GenerateConsoleCtrlEvent(CTRL_C_EVENT,0);
            ret=TRUE; //Already sent to child
        }

        WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
        return(ret); //FALSE:send it to child StdIn
    }


    tmpchar=buff[dread-2]; //must be 13;but just incase
    buff[dread-2]=0;
#ifdef UNICODE
    MakeCommandString( inp_buff, buff, cl->Name, GetFormattedTime());
#else
    CMDSTRING(inp_buff,buff,cl,GetFormattedTime());
#endif
    buff[dread-2]=tmpchar;
    len=_tcslen(inp_buff);
    WriteFile(SaveFile,inp_buff,len,&tmp,NULL);
    return(FALSE);
}
/*************************************************************/



VOID
SendStatus(
    HANDLE hClientPipe
    )
{
    TCHAR  buff[1024];
    int   i;
    DWORD tmp;
    TCHAR  *env=(TCHAR *)GetEnvironmentStrings();
    DWORD ver=GetVersion();

    _stprintf(buff,TEXT("Command = %s\n"),ChildCmd);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Server = %s PIPE=%s\n"),HostName,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

	_stprintf(buff,TEXT("IP Blocking= %d\n"),(DWORD)bIPLocked);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Username= %s Password=%s\n"),Username,Password);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("Build = %d \n"),((WORD *)&ver)[1]);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    for (i=1;i<MAX_SESSION;i++)
    {
        if (ClientList[i].Active)
        {
            _stprintf(buff,TEXT("ACTIVE SESSION=%s\n"),ClientList[i].Name);
            WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);
        }
    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("ENVIRONMENT VARIABLES\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);


    __try
    {
        while (*env!=0)
        {
            _stprintf(buff,TEXT("%s\n"),env);
            WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

            while(*(env++)!=0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _stprintf(buff,TEXT("Exception Generated Getting Environment Block\n"),env);
        WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);

    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteFile(hClientPipe,buff,_tcslen(buff),&tmp,NULL);
    return;
}
/*************************************************************/
VOID
SockSendStatus(
    SOCKET MySocket
    )
{
    TCHAR  buff[1024];
    int   i;
    DWORD tmp;
    TCHAR  *env=(TCHAR *)GetEnvironmentStrings();
    DWORD ver=GetVersion();

    _stprintf(buff,TEXT("Command = %s\n"),ChildCmd);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("Server = %s Port=%s\n"),HostName,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

	_stprintf(buff,TEXT("IP Blocking= %d\n"),(DWORD)bIPLocked);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("Username= %s Password=%s\n"),Username,Password);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
	
	_stprintf(buff,TEXT("Build = %d \n"),((WORD *)&ver)[1]);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    for (i=1;i<MAX_SESSION;i++)
    {
        if (ClientList[i].Active)
        {
            _stprintf(buff,TEXT("ACTIVE SESSION=%s from IP %s \n"),ClientList[i].Name, ClientList[i].szIP );
            WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
        }
    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("ENVIRONMENT VARIABLES\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);


    __try
    {
        while (*env!=0)
        {
            _stprintf(buff,TEXT("%s\n"),env);
            WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

            while(*(env++)!=0);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _stprintf(buff,TEXT("Exception Generated Getting Environment Block\n"),env);
        WriteSocket(MySocket,buff,_tcslen(buff),&tmp);

    }

    _stprintf(buff,TEXT("====================\n"),Server,PipeName);
    WriteSocket(MySocket,buff,_tcslen(buff),&tmp);
    return;
}
/*************************************************************/


DWORD
ShowPopup(
    TCHAR *mssg
    )
{
    MessageBox(GetActiveWindow(),mssg,TEXT("***WSREMOTE***"),MB_OK|MB_SETFOREGROUND);
    free(mssg);
    return(0);

}
/*************************************************************/
BOOL SrvCtrlHand(
    DWORD event
    )
{
    if (event==CTRL_BREAK_EVENT)
    {
        TerminateProcess(ChldProc,1);
        return(TRUE);
    }
    else if (event==CTRL_C_EVENT)
        return(TRUE);
    return(FALSE);
}
/*************************************************************/

DWORD   LocalSession(PVOID noarg)
{
    //Local is ClientList[0]
    TCHAR *name=(TCHAR *)ClientList[0].Name;

    _tcscpy(name,LOCALNAME);
    if ((ClientList[0].rSaveFile=CreateFile(SaveFileName,GENERIC_READ|GENERIC_WRITE,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL))==NULL)
    {
        _tprintf(TEXT("WSRemote:Cannot open ReadHandle to Savefile:%d\n"),GetLastError());
        ClientList[0].Active=FALSE;
        return(1);

    }

    ClientList[0].PipeReadH=GetStdHandle(STD_INPUT_HANDLE);
    ClientList[0].PipeWriteH=GetStdHandle(STD_OUTPUT_HANDLE);
    ClientList[0].SendOutput=TRUE;
    ClientList[0].Active=TRUE;
    NewSession(&ClientList[0]);
    CloseClient(&ClientList[0]);
    return(0);
}

VOID
CloseClient(
    SESSION_TYPE *Client
    )
{
	int nRet;
    ZeroMemory(Client->Name,HOSTNAMELEN);

    if (Client->PipeReadH!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->PipeReadH);
        Client->PipeReadH=INVALID_HANDLE_VALUE;
    }

    if (Client->PipeWriteH!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->PipeWriteH);
        Client->PipeWriteH=INVALID_HANDLE_VALUE;
    }

    if (Client->rSaveFile!=INVALID_HANDLE_VALUE)
    {
        CloseHandle(Client->rSaveFile);
        Client->rSaveFile=INVALID_HANDLE_VALUE;
    }
    if (Client->MoreData!=NULL)
    {
        CloseHandle(Client->MoreData);
        Client->MoreData=NULL;
    }
	 if (Client->Socket!=INVALID_SOCKET)
    {
		 nRet = shutdown(Client->Socket, SD_BOTH);
	     if (nRet == SOCKET_ERROR)
				_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
        closesocket(Client->Socket);
		
        Client->Socket=INVALID_SOCKET;
    }
    ZeroMemory(Client->szIP,16);

    Client->Active=FALSE; //Keep it last else synch problem.
    return;
}

VOID
InitClientList(
    )
{
    int i;
    for (i=0;i<MAX_SESSION;i++)
    {
        ZeroMemory(ClientList[i].Name,HOSTNAMELEN);
        ClientList[i].PipeReadH=INVALID_HANDLE_VALUE;
        ClientList[i].PipeWriteH=INVALID_HANDLE_VALUE;
        ClientList[i].rSaveFile=INVALID_HANDLE_VALUE;
        ClientList[i].MoreData=NULL;
		ClientList[i].Socket=INVALID_SOCKET;
        ClientList[i].Active=FALSE;
        ClientList[i].CommandRcvd=FALSE;
        ClientList[i].SendOutput=FALSE;
        ClientList[i].hThread=NULL;
		ZeroMemory(ClientList[i].szIP,16);
    }
    return;
}



VOID
RemoveInpMark(
    TCHAR* Buff,
    DWORD Size
    )

{
    DWORD i;
    for (i=0;i<Size;i++)
    {
        switch (Buff[i])
        {
        case BEGINMARK:
            Buff[i]=' ';
            break;

        case ENDMARK:
            if (i<2)
            {
                Buff[i]= ' ';
            }
            else
            {
                Buff[i]  =Buff[i-1];
                Buff[i-1]=Buff[i-2];
                Buff[i-2]=' ';
            }
            break;

        default:
           break;
       }
    }
}


/*************************************************************/
DWORD
SockListenForSession(
   TCHAR* szListenPort
   )
{
	// Bind and Listen
	DWORD			ThreadID;	
	SOCKADDR_IN		saServer;
	int				nRet;
	unsigned short	usPort;
	int				i;

	// Accept
	SOCKET 			socketClient;
	SOCKADDR_IN 	SockAddr;
	int				nLen;

	int				iWSAErr;
    TCHAR *         pszInetAddress  = NULL;
	//
	// Create a TCP/IP stream socket
	//

	listenSocket = socket (	AF_INET,
				SOCK_STREAM,
				IPPROTO_TCP);

	if (listenSocket == INVALID_SOCKET)
	{
		_tprintf (TEXT("Could not create listen socket: %d"), WSAGetLastError() );
 		return FALSE;
	}

	//
	// Get the port number
	// TODO: Check szListenPort for Alpha Chars
	//
	usPort = (unsigned short)_ttoi( szListenPort );
	if (usPort == 0)
	{
		_tprintf (TEXT("**Invalid Listen Port: %s\n"),szListenPort);
		_tprintf (TEXT("**No Socket Connections Allowed....\n"));
		
		nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
			 _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	saServer.sin_port = htons(usPort);

	//
	// Fill in the rest of the address structure
	//
	saServer.sin_family = AF_INET;
	saServer.sin_addr.s_addr = INADDR_ANY;

	//
	// Bind our name to the socket
	//
	nRet = bind(	listenSocket,
			(LPSOCKADDR)&saServer,
			sizeof(struct sockaddr));

	if (nRet == SOCKET_ERROR)
	{
		_tprintf (TEXT("bind() error: %d"), WSAGetLastError() );
		nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
	  		_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	//
	// Set the Socket to listen
	//
	nRet = listen(listenSocket, SOMAXCONN);
	if (nRet == SOCKET_ERROR)
	{
		_tprintf (TEXT("listen error() error: %d"), WSAGetLastError() );
		 nRet = shutdown(listenSocket, SD_BOTH);
		  if (nRet == SOCKET_ERROR)
	  		_tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
		closesocket(listenSocket);
		return FALSE;
	}

	while (1)
	{

		// Block on Accept()
		nLen = sizeof(SOCKADDR_IN);
		socketClient = accept	(listenSocket,
					(LPSOCKADDR)&SockAddr,
					&nLen);
		if (socketClient == INVALID_SOCKET)
		{
			//Accept Failed
			_tprintf (TEXT("accept error() error: %d"), WSAGetLastError() );
			break;
		}// if

#ifdef UNICODE
        pszInetAddress = inet_ntoaw(SockAddr.sin_addr);
#else
        pszInetAddress = inet_ntoa(SockAddr.sin_addr);

#endif

        _tprintf(   TEXT("\nCONNECT on socket: %d\nFROM ip: %s"),
                    socketClient,
                    pszInetAddress );

		//
		//Look For a Free Slot & if not- then terminate connection
		//

		for (i=1;i<MAX_SESSION;i++)
		{
			//
			// Locate a Free Client block
			//
			if (!ClientList[i].Active)
				break;
		}// for

		if ( (i<MAX_SESSION) && (bIPLocked == FALSE) )
		{
			//
			// Initialize the Client
			//
			ClientList[i].PipeReadH=INVALID_HANDLE_VALUE;
			ClientList[i].PipeWriteH=INVALID_HANDLE_VALUE;
			ClientList[i].Active=TRUE;
			ClientList[i].SendOutput=TRUE;
			ClientList[i].CommandRcvd=FALSE;
			// SOCK
			ClientList[i].Socket=socketClient;
			_tcscpy(ClientList[i].szIP,pszInetAddress);

#ifdef UNICODE
            free( pszInetAddress );
#endif

			//
			//start new thread for this connection
			//

			if((ClientList[i].hThread=CreateThread (
						 (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
						 (DWORD)0,                           // Use same stack size.
						 (LPTHREAD_START_ROUTINE)SockRemoteSession, // Thread procedure.
						 (LPVOID)&ClientList[i],             // Parameter to pass.
						 (DWORD)0,                           // Run immediately.
						 (LPDWORD)&ThreadID))==NULL)
			{
				CloseClient(&ClientList[i]);
				continue;
			}// if
			}
			else
			{
				_tprintf(TEXT("WSRemote:Closing New Session - No more slots or IP is Locked Out\n"));
				nRet = shutdown(socketClient, SD_BOTH);
				if (nRet == SOCKET_ERROR)
	  				 _tprintf(TEXT("** shutdown()..error %d"), WSAGetLastError());
				closesocket(socketClient);
				continue;
			}//if


	}// while

	iWSAErr	= WSAGetLastError();

	_tprintf (TEXT("FATAL ERROR, Exiting SockListenForSession: %d"),
			iWSAErr	);
	return 0;
}


/*************************************************************/
DWORD
SockRemoteSession(
    SESSION_TYPE         *MyClient
    )
{
//Declare Variables
//
    DWORD               ReadCnt;
    DWORD               tmp;
    SESSION_STARTUPINFO ssi;
    TCHAR *             headerbuff;
    TCHAR               msg[BUFFSIZE];
    SESSION_STARTREPLY  ssr;
    DWORD               reply           =0;
    BOOL                bRet;

    if ((MyClient->rSaveFile=CreateFile(
        SaveFileName,
        GENERIC_READ|GENERIC_WRITE,
        FILE_SHARE_READ|FILE_SHARE_WRITE,
        NULL,OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,NULL))==NULL)

    {
        CloseClient(MyClient);
        return(1);
    }

    bRet = SockAuthenticate(MyClient->Socket);
    if (bRet == FALSE)
    {
        _tprintf(TEXT("\nAuth:Bad Username or Password\n"));
        CloseClient(MyClient);
        return(1);
    }

//    ReadSocket( MyClient->Socket,
//                (TCHAR *)MyClient->Name,
//                HOSTNAMELEN-1,
//                &dwBytesRead);

    SockReadFixBytes(MyClient->Socket,(TCHAR *)MyClient->Name,HOSTNAMELEN-1,0);

        //
        //Last four Bytes contains a code
        //

        memcpy((TCHAR *)&reply,(TCHAR *)&(MyClient->Name[11]),4);

        if (reply!=MAGICNUMBER)
        {
            //
            // Unknown client
            //
            CloseClient(MyClient);
            return(1);
        }

        ssr.MagicNumber=MAGICNUMBER;
        ssr.Size=sizeof(ssr);
        ssr.FileSize=GetFileSize( MyClient->rSaveFile, &tmp );

        send(MyClient->Socket,(const char *)&ssr,sizeof(ssr),0);



    if (SockReadFixBytes(MyClient->Socket,(TCHAR *)&(ssi.Size),sizeof(ssi.Size),0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    if (ssi.Size>1024)      //Sanity Check
    {
        _stprintf(msg,TEXT("%s"),"Server:Unknown Header..Terminating session\n");
        WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
        CloseClient(MyClient);
        return(1);

    }


    if ((headerbuff=(TCHAR *)calloc(ssi.Size,1))==NULL)
    {
        _stprintf(msg,TEXT("%s"),"Server:Not Enough Memory..Terminating session\n");
        WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
        CloseClient(MyClient);
        return(1);

    }

    ReadCnt=ssi.Size-sizeof(ssi.Size);
    if (SockReadFixBytes(MyClient->Socket,(TCHAR *)headerbuff,ReadCnt,0)!=0)
    {
        CloseClient(MyClient);
        return(1);
    }

    memcpy((TCHAR *)&ssi+sizeof(ssi.Size),headerbuff,sizeof(ssi)-sizeof(ssi.Size));
    free(headerbuff);

    /* Version  */
    if (ssi.Version!=VERSION)
    {
         _stprintf(msg,TEXT("WSRemote Warning:Server Version=%d Client Version=%d\n"),VERSION,ssi.Version);
         WriteSocket(MyClient->Socket,msg,_tcslen(msg),&tmp);
    }

    /* Name  */
    {
        memcpy(MyClient->Name,ssi.ClientName,15);
        MyClient->Name[14]=0;

    }

    /* Lines  */
    if (ssi.LinesToSend!=-1)
    {
        long  PosFromEnd=ssi.LinesToSend*CHARS_PER_LINE;
        DWORD BytesToSend=MINIMUM((DWORD)PosFromEnd,ssr.FileSize);
        DWORD BytesRead;
        TCHAR  *buff=(TCHAR *)calloc(BytesToSend+1,1);

        if (ssr.FileSize > (DWORD)PosFromEnd)
        {
            SetFilePointer( MyClient->rSaveFile,
                            -PosFromEnd,
                            (PLONG)NULL,
                            FILE_END
                           );

        }

        if (buff!=NULL)
        {
            if (!ReadFile(MyClient->rSaveFile,buff,BytesToSend,&BytesRead,NULL))
            {
                CloseClient(MyClient);
                return(1);
            }

            RemoveInpMark(buff,BytesRead);
            if (!WriteSocket(MyClient->Socket,buff,BytesRead,&tmp))
            {
                CloseClient(MyClient);
                return(1);
            }
        }
        free(buff);

    }

    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Connected To %s ip=%s [%s]\n"),MyClient->Name,MyClient->szIP,GetFormattedTime()),ssi.Flag);
    SockNewSession(MyClient);
    RemoteInfo(_tprintf(TEXT("\n**WSRemote:Disconnected From %s ip=%s [%s]\n"),MyClient->Name,MyClient->szIP,GetFormattedTime()),ssi.Flag);
    CloseClient(MyClient);
    return(0);
}

/*************************************************************/
DWORD
SockNewSession(
    SESSION_TYPE* MyClient
    )
{
    DWORD        ThreadId;
    HANDLE       rwThread[3];

    MyClient->MoreData=CreateEvent
    (
            (LPSECURITY_ATTRIBUTES) NULL,/* address of security attributes	*/
            FALSE,                	     /* flag for manual-reset event	*/
            TRUE,	                     /* flag for initial state	*/
            NULL	                     /* address of event-object name	*/
    );



    if ((rwThread[0]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)SockGetClientInput, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        return(GetLastError());
    }

    if ((rwThread[1]=CreateThread (
                        (LPSECURITY_ATTRIBUTES)NULL,        // No security attributes.
                        (DWORD)0,                           // Use same stack size.
                        (LPTHREAD_START_ROUTINE)SockTransferFileToClient, // Thread procedure.
                        (LPVOID)MyClient,                    // Parameter to pass.
                        (DWORD)0,                           // Run immediately.
                        (LPDWORD)&ThreadId))==NULL)
    {
        CloseHandle(rwThread[0]);
        return(GetLastError());
    }

    rwThread[2]=ChldProc;
    WaitForMultipleObjects(3, rwThread,FALSE, INFINITE);

    TerminateThread(rwThread[0],1);
    TerminateThread(rwThread[1],1);

    CloseHandle(rwThread[0]);
    CloseHandle(rwThread[1]);

    return(0);
}

/*************************************************************/
DWORD
SockGetClientInput(
    SESSION_TYPE *MyClient
    )
{
    TCHAR	buf[BUFFSIZE];
    DWORD	tmp,
			dread;

	memset(buf, 0, sizeof(buf));
	
	while(ReadSocket(MyClient->Socket,buf,BUFFSIZE,&dread))
    {
        buf[sizeof(buf)]=0;
        MyClient->CommandRcvd=TRUE;

		if (0 == buf[0] )
			return(1);

        if (SockFilterCommand(MyClient,buf,dread))
            continue;


        if (!WriteFile(ChildStdInp,buf,dread,&tmp,NULL))
        {
            ExitThread(0);
        }
		memset(buf, 0, sizeof(buf));
    }
    return(1);
}

/*************************************************************/
DWORD
SockTransferFileToClient(
    SESSION_TYPE *MyClient
    )
{

    TCHAR	buffin[BUFFSIZE],
			buffout[BUFFSIZE],
			cmdbuff[BUFFSIZE];
    DWORD  tmp;
    DWORD  dread=0,dwrite=0;
    BOOL   incmd=FALSE;
    DWORD  cmdP=0;
    DWORD  i;
    TCHAR  MyEchoStr[30];

    _stprintf(MyEchoStr,TEXT("[%-15s"),MyClient->Name);


    while(ReadFile(MyClient->rSaveFile,buffin,BUFFSIZE-1,&dread,NULL))
    {
        if (dread==0)
        {
            WaitForSingleObject(MyClient->MoreData,INFINITE);
            continue;
        }
        dwrite=0;
        for(i=0;i<dread;i++)
        {
            if (incmd)
            {
                if ((buffin[i]==ENDMARK)||(cmdP==BUFFSIZE-1))
                {
                    incmd=FALSE;
                    cmdbuff[cmdP]=0;
                    if ((_tcsstr(cmdbuff,MyEchoStr)==NULL)||
                        (!MyClient->CommandRcvd))
                    {
                       //if (!send (MyClient->Socket, cmdbuff, cmdP, 0));
						//if (!SendBuffer(MyClient, cmdbuff, cmdP))
						if (!WriteSocket(MyClient->Socket, cmdbuff,cmdP,&tmp))
                        {
                            return(1);
                        }
                    }
                    cmdP=0;
                }
                else
                {
                    cmdbuff[cmdP++]=buffin[i];
                }
            }
            else
            {

                if (buffin[i]==BEGINMARK)
                {
                    if (dwrite!=0)
                    {
						//if (!send (MyClient->Socket, buffout, dwrite, 0));
                        //if (!SendBuffer(MyClient, buffout, dwrite))
						if (!WriteSocket(
                            MyClient->Socket,
                            buffout,dwrite,&tmp))
                        {
                            return(1);
                        }
                        dwrite=0;
                    }
                    incmd=TRUE;
                    continue;
                }
                else
                {
                    buffout[dwrite++]=buffin[i];
                }
            }
        }

        if (dwrite!=0)
        {
			//if (!send (MyClient->Socket, buffout, dwrite, 0));
            //if (!SendBuffer(MyClient, buffout, dwrite))
			if (!WriteSocket(
                MyClient->Socket,
                buffout,dwrite,&tmp))
            {
                return(0);
            }
        }
    }
    return(1);
}


BOOL
SockAuthenticate(
    SOCKET MySocket
    )
{
	BOOL	bRead;
	DWORD	dread;
	int		bufflen;
	int		iCmp;
	TCHAR	EncodeBuffer[1024];
	TCHAR	CheckEncodeBuffer[1024];
	TCHAR	UserBuffer[1024];
    TCHAR * String						= UserBuffer;
	TCHAR * pEncodeBuffer;
	TCHAR * pCheckEncodeBuffer;

    SetLastError(0);
	
	memset(CheckEncodeBuffer, 0, sizeof(CheckEncodeBuffer));
	
	_stprintf(
        UserBuffer,        TEXT("%s:%s"),
        Username,
        Password);

    pCheckEncodeBuffer = CheckEncodeBuffer + _tcslen(CheckEncodeBuffer);
    Base64Encode(UserBuffer, _tcslen(UserBuffer), pCheckEncodeBuffer);
    bufflen = _tcslen(pCheckEncodeBuffer);

	memset(EncodeBuffer, 0, sizeof(EncodeBuffer));

	bRead = ReadSocket(MySocket,EncodeBuffer,bufflen,&dread);
	
	pEncodeBuffer = EncodeBuffer;

	iCmp = _tcscmp(pEncodeBuffer, pCheckEncodeBuffer);
	if (iCmp != 0)
		return FALSE;

	return TRUE;

}

#ifdef UNICODE
int MakeCommandString(
    TCHAR * pszOutput,
    TCHAR * pszInput,
    TCHAR * pszName,
    TCHAR * pszTime
)
{
    int nStrLen =_stprintf( pszOutput,
                            TEXT("\xfe%-15s    [%-15s %s]\n\xff"),
                            pszInput,
                            pszName,
                            pszTime );

    return nStrLen;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wsfslib\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987-1998
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 * 04/16/98 - QFE DerrickG (mdg):
 *            - modified dtqo_s.dtqo_resv from "unsigned short" to "unsigned long"
 *              to accommodate large symbol counts
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
	unsigned long	dtqo_resv;	 /* Reserved			*/ // mdg 98/4
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clVar;	 /* Number of dyntrc variables	*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |  
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|            
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            | 
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            | 
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             | 
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             | 
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"               
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF 
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module    
            USHORT  tmihdr_usID;           // Module identifier         
            CHAR    tmihdr_resv[30];       // Reserved                   
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnBit;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here 
};

typedef struct tmirec_s tmirec_t;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wsfslib\wsexport.h ===
/*
 * Module Name:  WSEXPORT.H
 *
 * Description:
 *
 * Working set tuner include file for WSINFO and WSEXPORT.  Contains 
 * common constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */


/*
 *	Constant definitions.
 */

#define DEFAULT_DELAY	0	/* Defaults for command line arguments */
#define DEFAULT_RATE	1000	
#define DEFAULT_BUFSZ	0x100000
#define DEFAULT_SNAPS	0

#define TIMEOUT		1000	/* Default timeout value */

#define WSINFO_ON	1	/* Defines for argv[1] */
#define WSINFO_OFF	0
#define WSINFO_PAUSE	2
#define WSINFO_RESUME	3
#define WSINFO_QUERY	4
#define WSINFO_MAX	5

#define SEM_ACQUIRED	0x1	/* Resource definitions */
#define SEM_OPEN	0x2
#ifdef SHM_USED
#define SHM_OPEN	0x4
#endif /* SHM_USED */



/*
 *	Function prototypes.
 */

USHORT FAR PASCAL WsInfoOn( VOID );
USHORT FAR PASCAL WsInfoOff( VOID );
USHORT FAR PASCAL WsInfoPause( VOID );
USHORT FAR PASCAL WsInfoResume( VOID );
USHORT FAR PASCAL WsInfoQuery( VOID );
USHORT FAR PASCAL WsInfoInit( PSZ, PSZ, PSZ, ULONG, ULONG, ULONG, BOOL, BOOL );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wsfslib\wserror.h ===
/*
 * Module Name:  WSERROR.H
 *
 * Description:
 *
 * Working set tuner error message include file.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */


/*
 *	Constant definitions.
 */
#ifdef	ERROR
#undef	ERROR
#endif
#define ERROR		1		/* Exit processing codes */
#define NOEXIT 		0xFFFF	
#define NO_MSG		FALSE
#define PRINT_MSG	TRUE
					/* Message defines */
#define MSG_BUFFER_SIZE	0
#define MSG_DYNTRC	1
#define MSG_FILE_CREATE	2
#define MSG_FILE_OPEN	3
#define MSG_FILE_OFFSET	4
#define MSG_FILE_READ	5
#define MSG_FILE_WRITE	6
#define MSG_SEM_CREATE	7
#define MSG_SEM_OPEN	8
#define MSG_SEM_ACQUIRE	9
#ifdef SHM_USED
#define MSG_SHM_CREATE	10
#define MSG_SHM_ACCESS	11
#endif /* SHM_USED */
#define MSG_FILE_BAD_HDR 12
#define MSG_NO_MEM	 13
#define MSG_EXEC_PGM	 14
#define MSG_TRACE_ON	 15
#define MSG_TRACE_OFF	 16
#define MSG_WSINFO_ON	 17
#define MSG_WSPREPRO	 18
#define MSG_WSPDUMP	 19
#define MSG_WSREDUCE	 20

// These messages are order dependent; they must correspond to the 'MSG_'
// definitions above.
static CHAR	*pchMsg[] = {
	"%s %s:  WARNING - RESULT BUFFER TOO SMALL (0x%lx BYTES) %s\n",
	"%s %s:  FATAL ERROR (%d) FROM DOSDYNAMICTRACE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT OPEN FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT SET POINTER FOR FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT READ FILE %s (POSSIBLY CORRUPT)\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT WRITE FILE %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT OPEN SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT ACQUIRE SEMAPHORE NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT CREATE SHARED MEMORY NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT ACCESS SHARED MEMORY NAMED %s\n",
	"%s %s:  FATAL ERROR (%d) - BAD FILE HEADER %s\n",
	"%s %s:  FATAL ERROR  - COULD NOT ALLOCATE (%ld BYTES) MEMORY FOR %s\n",
	"%s %s:  FATAL ERROR (%d) - Dos32ExecPgm(%s)\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT INSERT TRACEPOINTS IN %s\n",
	"%s %s:  WARNING (%d) - COULD NOT REMOVE TRACEPOINTS FROM %s\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT COLLECT DATA, %s FAILED\n",
	"%s %s:  ERROR (%d) - COULD NOT POSTPROCESS .WSI FILE, %s FAILED\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT DUMP WSP DATA, %s FAILED\n",
	"%s %s:  FATAL ERROR (%d) - COULD NOT REDUCE WSP DATA, %s FAILED\n",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstcat\wstcat.c ===
/*
 * Module Name:  WSTCAT.C
 *								
 * Program:	 WSTCAT
 *								
 *								
 * Description:							
 *
 * Concatenates multiple WSP files, for the same module, into one WSP file.
 * Creates a single TMI file from the resulting files.
 *
 *
 * Modification History:
 *
 * 	8-20-92	Created									marklea
 *    4-24-98, QFE:                             DerrickG (mdg)
 *             - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *             - support for long file names (LFN) of input/output files
 *             - removed limit on symbol name lengths
 *	
 *	
 *				
 *								
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wsdata.h>
#include <..\wsfslib\wserror.h>
#include <..\wsfslib\wsfslib.h>

#include <ntverp.h>
#define MODULE       "WSTCAT"
#define VERSION      VER_PRODUCTVERSION_STR

/*
 *	Global variable declaration and initialization.
 */
static ULONG	rc = NO_ERROR;			// Return code


typedef struct tagTMI{
   CHAR  *pszFxnName;
	ULONG ulAddr;
	ULONG ulSize;
	ULONG ulIndex;
	BOOL  fSet;
}TMI;

typedef struct indxMOD{
	ULONG	ulSetCnt;   // mdg 4/98
	ULONG	ulFxnTot;
	ULONG	ulOffset;
	ULONG	ulSnaps;
	PULONG	pulBitStrings;
	FILE	*hFileNDX;
	TMI		*tmi;
}NDXMOD;


typedef struct tagMOD{
	ULONG	ulSetCnt;   // mdg 4/98
	UINT	uiLeft;
	ULONG	ulOffset;
	ULONG	ulSnaps;
	FILE	*hFileWxx;
	PULONG	pulAddr;
}WSTMOD;

NDXMOD	nmod;
WSTMOD	wmod[256];

CHAR	*szFileWSP;		//WSP file name
CHAR	*szFileTMI;		//TMI file name
CHAR	*szFileWxx;		//extra wsp files
CHAR	*szFileTxx;		//extra tmi files
CHAR	*szModName;		//Module or DLL name
CHAR  *szFileWSPtmp; // Temporary .WSP file name
CHAR  *szFileTMItmp; // Temporary .TMI file name
ULONG	clVarTot = 0;		// Total number of dwords in bitstr
UINT	uiModCount;

WSPHDR	WspHdr, tmpHdr;

FILE	*hFileWSP;			
FILE	*hFileTmpWSP;
FILE	*hFileTMI;
FILE	*hFileTmpTMI;

/*
 *	    Function prototypes.
 */
VOID 	wspCatSetup(VOID);
VOID 	wspCatUsage(VOID);
VOID 	wspCat(VOID);
INT 	wspCatExit(INT, USHORT, UINT, ULONG, LPSTR);
int  	WspBCompare (ULONG, PULONG);
LONG 	WspBSearch (ULONG ulAddr, WSTMOD wmod);


/****************************** M A I N **************************************
*
*	Function:	main (INT argc, CHAR *argv[])
*
*
*	Purpose:	Parses command line and dumps the WSP and TMI files
*
*	Usage:		[d:][path]wstcat modulename
*
*	where:		modulename is the name of the module whose wXX files
*				you want to concatenate.
*
*	Returns:	NONE
*
*****************************************************************************/



VOID __cdecl main (INT argc, CHAR *argv[])
{

    ConvertAppToOem( argc, argv );
	if (argc != 2) {
		wspCatUsage();
      exit( -1 );
	}
	else {
      UINT     nLen;
      char *   pDot;
      
      if ((pDot = strrchr( argv[ 1 ], '.' )) != NULL)
         *pDot = '\0';
      nLen = strlen( argv[1] ) + 1;

      szModName = malloc( nLen );
      if (szModName)
		strcpy(szModName, argv[1]);
      else {
          exit(1);
      }
      szFileWSP = malloc( nLen + 4 );
      if (szFileWSP)
		strcat( strcpy( szFileWSP, szModName ), ".WSP" );
      else {
          free(szModName);
          exit(1);
      }
      szFileTMI = malloc( nLen + 4 );
      if (szFileTMI)
		strcat( strcpy( szFileTMI, szModName ), ".TMI" );
      else {
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileWxx = malloc( nLen + 4 );
      if (szFileWxx)
		strcat( strcpy( szFileWxx, szModName ), ".Wxx" );
      else {
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileTxx = malloc( nLen + 4 );
      if (szFileTxx)
		strcat( strcpy( szFileTxx, szModName ), ".Txx" );
      else {
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileWSPtmp = malloc( nLen + 4 );
      if (szFileWSPtmp)
		strcat( strcpy( szFileWSPtmp, szModName ), ".Wzz" );
      else {
          free(szFileTxx);
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
      szFileTMItmp = malloc( nLen + 4 );
      if (szFileTMItmp)
		strcat( strcpy( szFileTMItmp, szModName ), ".Tzz" );
      else {
          free(szFileTMItmp);
          free(szFileTxx);
          free(szFileWxx);
          free(szFileTMI);
          free(szFileWSP);
          free(szModName);
          exit(1);
      }
   }

	// Setup input files for dump processing.
	wspCatSetup();
	wspCat();

   // Free allocated memory
   free( szModName );
   free( szFileWSP );
   free( szFileTMI );
   free( szFileWxx );
   free( szFileTxx );
}

/*
 *			
 ***LP wspCatSetup
 *					
 *							
 * Effects:							
 *								
 * Opens the module's WSP and TMI input files, seeks to the start of the
 * first function's bitstring data in the WSP file, and allocates memory
 * to hold one function's bitstring.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspCatExit()
 *	with ERROR.
 *	
 */

VOID wspCatSetup(VOID)
{
	ULONG	ulTmp;
	UINT	uiExt = 0;
	UINT	x;
   char *   pszTmpName;



	/* Open input WSP file.  Read and validate WSP file header.*/

	rc = WsWSPOpen(szFileWSP, &hFileWSP,(PFN)wspCatExit,
				   (wsphdr_t *)&WspHdr, ERROR, PRINT_MSG );

	if(rc){
		exit(rc);		
	}

	//
	// Open a temporary tmi file to hold concatenated information.
	// This file will be renamed to module.tmi when the cat process
	// is complete, and the current module.tmi will be renamed to module.txx.
	//
	hFileTMI = fopen(szFileTMI, "rt");
    if (!hFileTMI) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileTMI);
    }
	hFileTmpTMI = fopen(szFileTMItmp, "wt");
    if (!hFileTmpTMI) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileTMItmp);
    }
    pszTmpName = malloc( 128 + 1 );
    if (pszTmpName) {
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        fputs (fgets (pszTmpName, 128, hFileTMI), hFileTmpTMI);
        free( pszTmpName );
    }
	fclose(hFileTMI);

	//
	//	Set key, module specific information
	//
	clVarTot 	  = WspHdr.ulSnaps;
	nmod.ulSnaps  = WspHdr.ulSnaps;
	nmod.ulSetCnt = WspHdr.ulSetSymbols;   // mdg 4/98
	nmod.ulOffset = WspHdr.ulOffset;

	nmod.ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspCatExit,
							  0, (PCHAR)0);
	//
	// Open a temporary wsp file to hold concatenated information.
	// This file will be renamed to module.wsp when the cat process
	// is complete, and the current module.wsp will be renamed to module.wxx.
	// The header is also written.
	//
	hFileTmpWSP = fopen(szFileWSPtmp, "wb");
    if (!hFileTmpWSP) {
		wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, GetLastError(), szFileWSPtmp);
    }
   WspHdr.ulOffset = sizeof(WSPHDR) + strlen( szModName );  // Set data location correctly
	fwrite(&WspHdr, sizeof(WSPHDR), 1, hFileTmpWSP);
	fwrite(szModName, strlen(szModName), 1, hFileTmpWSP);

	//
	//	Allocate memory to hold TMI data for each Symbol in the
	//	main TMI file
	//
	nmod.tmi = (TMI *)malloc(nmod.ulFxnTot * sizeof(TMI));
	if (nmod.tmi == NULL) {
		wspCatExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				nmod.ulFxnTot * sizeof(TMI), "nmod.tmi[]");
	}

	//
	//	Read data for each symbol record in the key TMI file
	//
	for (x = 0; x < nmod.ulFxnTot ; x++ ) {
		nmod.tmi[x].ulSize = WsTMIReadRec(&pszTmpName, &(nmod.tmi[x].ulIndex),
								&(nmod.tmi[x].ulAddr), hFileTMI,
								(PFN)wspCatExit, (PCHAR)0);
		nmod.tmi[x].pszFxnName = pszTmpName;

    }

	fclose(hFileTMI);

	//
	//	Get Txx and Wxx specific information
	//
	while(rc == NO_ERROR){

		//
		//	Modify the file name to the first wxx and txx file
		//
		sprintf(szFileWxx, "%s.w%02d", szModName, uiExt+1);
		sprintf(szFileTxx, "%s.t%02d", szModName, uiExt+1);

		//
		//	Open file.Wxx and read header information.
		//
		rc = WsWSPOpen(szFileWxx, &(wmod[uiExt].hFileWxx),(PFN)wspCatExit,
					   (wsphdr_t *)&tmpHdr, NOEXIT, NO_MSG );

		//
		//	Check for an error from the open command.  Could be the last
		//	file.
		//
		if(rc == NO_ERROR){
			
			clVarTot += tmpHdr.ulSnaps;  //Increment the total number of
										 //Snapshots by the number from
										 //each data file.
			wmod[uiExt].ulSetCnt = tmpHdr.ulSetSymbols;  // mdg 4/98
			wmod[uiExt].uiLeft 	 = tmpHdr.ulSetSymbols; // mdg 4/98
			wmod[uiExt].ulOffset = tmpHdr.ulOffset;
			wmod[uiExt].ulSnaps  = tmpHdr.ulSnaps;
			wmod[uiExt].pulAddr  = (ULONG *)malloc(wmod[uiExt].ulSetCnt *  // mdg 4/98
												  sizeof(ULONG));
			//
			//	Open the TMI file associated with this data file
			//
			WsTMIOpen(szFileTxx, &hFileTMI,(PFN)wspCatExit,
					  0, (PCHAR)0);
			//
			//	Read each address from the TMI file.
			//
			if(rc == NO_ERROR){
				for (x = 0; x < wmod[uiExt].ulSetCnt ; x++ ) {  // mdg 4/98
					WsTMIReadRec(&pszTmpName, &ulTmp, (wmod[uiExt].pulAddr)+x,
								 hFileTMI, (PFN)wspCatExit, (PCHAR)0);
					free( pszTmpName );

				}
			}
		}

		//
		//	Increment the module index
		//
		uiExt++;


	}
	uiModCount = uiExt;

	//
	//	Allocate enough memory to hold all the bit strings for each module
	//	in a single array.
	//
	nmod.pulBitStrings = (ULONG *) malloc(clVarTot * sizeof(ULONG));

	if (nmod.pulBitStrings == NULL)
		wspCatExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				clVarTot * sizeof(ULONG), "pulBitStrings[]");


}


/*
 *			
 ***LP wspCat
 *					
 *							
 * Effects:							
 *								
 * For each function,
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspCatExit()
 *	with ERROR.
 *	
 */

VOID wspCat(VOID)
{
	UINT		uiFxn = 0;			// Function number.
	UINT		x     = 0;
	PULONG		pulBitStrings;		// Pointer to bitstring data.
	ULONG		culSnaps = 0;		// Cumulative snapshots.
	LONG		lIndex   = 0;		// Index to WSP file.
	BOOL		fSetBits = FALSE;
    CHAR    	szBuffer [256];
	ULONG    ulNewSetCnt = 0;  // mdg 4/98


	for (uiFxn = 0; uiFxn < nmod.ulFxnTot; uiFxn++)
	{

		pulBitStrings = &(nmod.pulBitStrings[0]);
		culSnaps = nmod.ulSnaps;

		//
		// Check to see if any non-zero bit strings remain
		//
		if(uiFxn < nmod.ulSetCnt){ // mdg 4/98
			//
			// Seek to function's bitstring in WSP file.
			// only for the first function
			//
			if(!uiFxn){
				if ((rc = fseek(hFileWSP,nmod.ulOffset,SEEK_SET))!=NO_ERROR)
					wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
								rc, szModName);
			}
		
			//
			// Read bitstring for NDX api
			//
			if (fread(pulBitStrings, sizeof(ULONG), nmod.ulSnaps, hFileWSP) != (sizeof(ULONG) * nmod.ulSnaps))
                wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, 0, szModName);
			fSetBits = TRUE;
		}
		//
		// If not, set the bitstring to '0'.  This is faster than seeking
		// to each bit string when they are zero.
		//
		else
			memset(pulBitStrings, '\0' , (sizeof(ULONG) * nmod.ulSnaps));

		//
		// Increment the pointer to allow for the addition of the next
		// bitstring set
		//
		pulBitStrings += nmod.ulSnaps;
		//
		// Now search WSTMOD array for a matching Function address
		//
		for (x=0; x < uiModCount - 1 ; x++ ) {
			culSnaps += wmod[x].ulSnaps;
			//
			// See if there are any functions that remain
			// and if so search for them
			//
			if(wmod[x].uiLeft){
				lIndex = WspBSearch(nmod.tmi[uiFxn].ulAddr, wmod[x]);
				//
				// If search has found a matching address, get the bitstring
				// and append it pulBitStrings
				//
				if (lIndex >= 0L) {

					lIndex = wmod[x].ulOffset +
							  ( lIndex * (wmod[x].ulSnaps * sizeof(ULONG)));

					if (rc = fseek(wmod[x].hFileWxx, lIndex, SEEK_SET) != NO_ERROR)
                        wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, rc, szModName);

					if (fread(pulBitStrings, sizeof(ULONG), wmod[x].ulSnaps, wmod[x].hFileWxx) !=
                            (sizeof(ULONG) * wmod[x].ulSnaps)) 
                    {
                        wspCatExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET, 0, szModName);
                    
                    }

					wmod[x].uiLeft--;
					fSetBits = TRUE;
				}
				//
				// Otherwise, set all bytes to 0
				//
				else{
					memset(pulBitStrings, '\0' , (sizeof(ULONG) * wmod[x].ulSnaps));
				}
			}
			//
			// Otherwise, set all bytes to 0
			//
			else
				memset(pulBitStrings, '\0' , (sizeof(ULONG) * wmod[x].ulSnaps));

			//
			// Now increment the pointer to allow for appending of additional
			// bitstring data.
			//
			pulBitStrings += wmod[x].ulSnaps;
		}
		//
		// Now we need to write the TMI & WSP file with the concatenated
		// bitstring (only if set)
		//
		nmod.tmi[uiFxn].fSet = fSetBits;
		if (fSetBits) {
			ulNewSetCnt++; // 4/98
			sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %ld ",
				(LONG)nmod.tmi[uiFxn].ulIndex, nmod.tmi[uiFxn].ulAddr,
            nmod.tmi[uiFxn].ulSize, strlen( nmod.tmi[uiFxn].pszFxnName ));
			fwrite(szBuffer, sizeof(char), strlen(szBuffer), hFileTmpTMI);
         fputs( nmod.tmi[uiFxn].pszFxnName, hFileTmpTMI );
         fputc( '\n', hFileTmpTMI );
			fwrite(nmod.pulBitStrings, sizeof(ULONG), culSnaps, hFileTmpWSP);
			fSetBits = FALSE;
		}

	}

	//
	// Now write all the TMI symbols not set to the temporary .tmi file
	//
    memset(nmod.pulBitStrings, '\0' , (sizeof(ULONG) * culSnaps));
	for (uiFxn = 0; uiFxn < nmod.ulFxnTot; uiFxn++) {
		if (!nmod.tmi[uiFxn].fSet) {
			sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %ld ",
				(LONG)nmod.tmi[uiFxn].ulIndex, nmod.tmi[uiFxn].ulAddr,
            nmod.tmi[uiFxn].ulSize, strlen( nmod.tmi[uiFxn].pszFxnName ));
			fwrite(szBuffer, sizeof(char), strlen(szBuffer), hFileTmpTMI);
         fputs( nmod.tmi[uiFxn].pszFxnName, hFileTmpTMI );
         fputc( '\n', hFileTmpTMI );
			fwrite(nmod.pulBitStrings, sizeof(ULONG), culSnaps, hFileTmpWSP);
		}
    }
	//
	// Seek to the beginning of the WSP file and update the snapshot
	// count in the header
	//
    if (!fseek(hFileTmpWSP, 0L, SEEK_SET)) {
        WspHdr.ulSnaps = culSnaps;
        WspHdr.ulSetSymbols = ulNewSetCnt;  // mdg 4/98
        fprintf(stdout,"Set symbols: %lu\n", WspHdr.ulSetSymbols);  // mdg 4/98
        fwrite(&WspHdr, sizeof(WSPHDR), 1, hFileTmpWSP);
    }
	_fcloseall();

	//
	// Rename the non-cat'd .wsp file and rename the cat'd temporary .wsp
	// to the original .wsp.  We might also consider deleting all the
	// Wxx and Txx files.
	//
	sprintf (szFileWxx, "%s.%s", szModName, "WSP");
	sprintf (szFileTxx, "%s.%s", szModName, "WXX");
	remove(szFileTxx);
	if (rename(szFileWxx, szFileTxx) !=0){
		printf("Unable to rename file %s to %s\n", szFileWxx, szFileTxx);
	}
	else{
		if (rename(szFileWSPtmp, szFileWSP) !=0){
			printf ("Unable to rename %s to %s!\n", szFileWSPtmp, szFileWxx);
		}
	}
	//
	// Rename the non-cat'd .tmi file and rename the cat'd temporary .tmi
	// to the original .tmi.  We might also consider deleting all the
	// Wxx and Txx files.
	//
	sprintf (szFileWxx, "%s.%s", szModName, "TMI");
	sprintf (szFileTxx, "%s.%s", szModName, "TXX");
	remove(szFileTxx);
	if (rename(szFileWxx, szFileTxx) !=0){
		printf("Unable to rename file %s to %s\n", szFileWxx, szFileTxx);
	}
	else{
		if (rename(szFileTMItmp, szFileTMI) !=0){
			printf ("Unable to rename %s to %s!\n", szFileTMItmp, szFileWxx);
		}
	}


}



/*
 *			
 * wspCatUsage	
 *					
 *							
 * Effects:							
 *								
 *	Prints out usage message, and exits with an error.			
 *								
 * Returns:							
 *	
 *	Exits with ERROR.	
 */

VOID wspCatUsage(VOID)
{
	printf("\nUsage: %s moduleName[.WSP]\n\n", MODULE);
	printf("       \"moduleName\" is the name of the module file to combine.\n\n");
	printf("%s %s\n", MODULE, VERSION);

    exit(ERROR);
}

/*
 *			
 ***LP wspCatExit
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.			
 *								
 ***								
 * Returns:							
 *	
 *	Void, else exits.
 */

INT wspCatExit(INT iExitCode, USHORT fPrintMsg, UINT uiMsgCode,
				ULONG ulParam1,  LPSTR pszParam2)
{
   /* Print message, if necessary. */
   if (fPrintMsg)
   {
      printf(pchMsg[uiMsgCode], MODULE, VERSION , ulParam1, pszParam2);
   }


   // Special case:  do NOT exit if called with NOEXIT.
   if (iExitCode != NOEXIT)
      exit(iExitCode);
   return(uiMsgCode);
}

/***********************  W s p B S e a r c h *******************************
 *
 *   Function:	WspBSearch(ULONG ulAddr, PULONG pulAddr)
 *
 *   Purpose:	Binary search function for finding a match in the WST array
 *
 *
 *   Parameters:
 *
 *
 *
 *   Returns:	ULONG	lIndex;
 *
 *   History:	8-5-92	Marklea - created
 *
 */

LONG WspBSearch (ULONG ulAddr, WSTMOD wmod)
{
    int 	i;
//    ULONG   ulHigh = (ULONG)wmod.usSetCnt;
    ULONG   ulHigh = (ULONG)wmod.ulSetCnt;   // mdg 4/98
    ULONG   ulLow  = 0;
    ULONG   ulMid;


    while(ulLow < ulHigh){
		ulMid = ulLow + (ulHigh - ulLow) /2;
		if((i = WspBCompare(ulAddr, wmod.pulAddr+ulMid)) < 0) {
			ulHigh = ulMid;
		}
		else if (i > 0) {
			ulLow = ulMid + 1;
		}
		else {
			return (ulMid);
		}

    }

    return (-1L);

} /* WspBSearch () */

/***********************  W s p B C o m p a r e ********************************
 *
 *   Function:	WspBCompare(ULONG ulAddr, PULONG pulAddr)
 *
 *   Purpose:	Compare values for Binary search
 *
 *
 *   Parameters:
 *
 *   Returns:	-1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:	8-3-92	Marklea - created
 *
 */

int WspBCompare(ULONG ulAddr, PULONG pulAddr)
{
    return (ulAddr < *pulAddr ? -1:
			ulAddr == *pulAddr ? 0:
			1);

} /* WspBCompare () */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdll\wst.c ===
/*** WST.C - Working Set Tuner Data Collection Program.
 *
 *
 * Title:
 *
 *  WST- Working Set Tuner Data Collection Program.
 *
 *  Copyright (c) 1992-1994, Microsoft Corporation.
 *  Reza Baghai.
 *
 * Description:
 *
 *  The Working Set Tuner tool is organized as follows:
 *
 *     o WST.c ........ Tools main body
 *     o WST.h
 *     o WST.def
 *
 *
 *
 * Design/Implementation Notes
 *
 *  The following defines can be used to control output of all the
 *  debugging information to the debugger via KdPrint() for the checked
 *  builds:
 *
 *  (All debugging options are undefined for free/retail builds)
 *
 *  PPC
 *  ---
 *
 *  PPC experiences problems when reading symbols in CRTDLL.dll
 *
 *  #ifdef INFODBG   : Displays messages to indicate when data dumping/
 *                                 clearing operations are completed.  It has no effect
 *                                 on timing.  *DEFAULT*
 *
 *  #ifdef SETUPDBG  : Displays messages during memory management and
 *                                 symbol lookup operations.  It has some affect
 *                                         on timing whenever a chuck of memory is committed.
 *
 *  #ifdef C6            : Generate code using C6 compiler.  C6 compiler
 *                                         calls _mcount() as the profiling routine where as
 *                                 C8 calls _penter().
 *
 *
 *
 *
 * Modification History:
 *
 *    92.07.28  RezaB -- Created
 *    94.02.08  a-honwah -- ported to MIPS and ALPHA
 *    98.04.28  DerrickG (mdg) -- QFE:
 *              - use private grow-on-demand heap for Wststrdup() - large symbol count
 *              - remove unused code associated with patching - reduce irrelevant mem usage
 *              - modify WSP file format for large symbol count (long vs. short)
 *              - modify TMI file write routine for arbitrary function name sizes
 *              - added UnmapDebugInformation() to release symbols from DBGHELP
 *              - eliminated dump for modules with no symbols
 *              - modified WST.INI parsing code for more robust section recognition
 *              - added MaxSnaps WST.INI entry in [Time Interval] section to control
 *                memory allocated for snapshot data
 *              - Modified SetSymbolSearchPath() to put current directory first in
 *                search path per standard - see docs for SymInitialize()
 *              - Removed unused internal version number (it's already in the .rc)
 *
 */

#if DBG
//
// Don't do anything for the checked builds, let it be controlled from the
// sources file.
//
#else
//
// Disable all debugging options.
//
#undef INFODBG
#undef SETUPDBG
#define SdPrint(_x_)
#define IdPrint(_x_)
#endif

#ifdef SETUPDBG
#define SdPrint(_x_)    DbgPrint _x_
#else
#define SdPrint(_x_)
#endif

#ifdef INFODBG
#define IdPrint(_x_)    DbgPrint _x_
#else
#define IdPrint(_x_)
#endif



/* * * * * * * * * * * * *  I N C L U D E    F I L E S  * * * * * * * * * * */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <excpt.h>

#include <windows.h>

#include <dbghelp.h>

#include "wst.h"
#include "wstexp.h"

#if defined(_AMD64_)

VOID
penter (
    VOID
    )

{
    return;
}

#endif

#if defined(ALPHA) || defined(AXP64)
#define REG_BUFFER_SIZE         (sizeof(DWORDLONG) * 64)
#elif defined(IA64)
#define REG_BUFFER_SIZE         sizeof(CONTEXT) / sizeof(DWORDLONG)
#endif


#if defined(ALPHA) || defined(IA64)
//typedef double DWORDLONG;  // bobw not needed in NT5
void SaveAllRegs (DWORDLONG *pSaveRegs) ;
void RestoreAllRegs (DWORDLONG *pSaveRegs) ;
void penter(void);
#endif

void     SetSymbolSearchPath  (void);
LPSTR    lpSymbolSearchPath = NULL;
#define  NO_CALLER   10L

/* * * * * * * * * *  G L O B A L   D E C L A R A T I O N S  * * * * * * * * */


/* * * * * * * * * *  F U N C T I O N   P R O T O T Y P E S  * * * * * * * * */

BOOLEAN  WSTMain  (IN PVOID DllHandle, ULONG Reason,
                   IN PCONTEXT Context OPTIONAL);

BOOLEAN  WstDllInitializations (void);

void     WstRecordInfo (DWORD_PTR dwAddress, DWORD_PTR dwPrevAddress);

void     WstGetSymbols (PIMG pCurImg, PSZ pszImageName, PVOID pvImageBase,
                        ULONG ulCodeLength,
                        PIMAGE_COFF_SYMBOLS_HEADER DebugInfo);

void     WstDllCleanups (void);

INT      WstAccessXcptFilter (ULONG ulXcptNo, PEXCEPTION_POINTERS pXcptPtr);

HANDLE   WstInitWspFile (PIMG pImg);

void     WstClearBitStrings (PIMG pImg);

void     WstDumpData (PIMG pImg);

void     WstRotateWsiMem (PIMG pImg);

void     WstWriteTmiFile (PIMG pImg);

int      WstCompare  (PWSP, PWSP);
void     WstSort     (WSP wsp[], INT iLeft, INT iRight);
int      WstBCompare (DWORD_PTR *, PWSP);
PWSP     WstBSearch  (DWORD_PTR dwAddr, WSP wspCur[], INT n);
void     WstSwap     (WSP wsp[], INT i, INT j);

DWORD    WstDumpThread  (PVOID pvArg);
DWORD    WstClearThread (PVOID pvArg);
DWORD    WstPauseThread (PVOID pvArg);

void       WstDataOverFlow(void);

#ifdef BATCHING
BOOL     WstOpenBatchFile (VOID);
#endif

#if defined(_PPC_)
//BOOL  WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
#endif


/* * * * * * * * * * *  G L O B A L    V A R I A B L E S  * * * * * * * * * */

HANDLE              hWspSec;
PULONG              pulShared;
HANDLE              hSharedSec;
HANDLE            hWstHeap = NULL;   // mdg 4/98 for private heap

IMG                 aImg [MAX_IMAGES];
int                 iImgCnt;

HANDLE              hGlobalSem;
HANDLE              hLocalSem;
HANDLE              hDoneEvent;
HANDLE              hDumpEvent;
HANDLE              hClearEvent;
HANDLE              hPauseEvent;
HANDLE              hDumpThread;
HANDLE              hClearThread;
HANDLE              hPauseThread;
DWORD              DumpClientId;
DWORD               ClearClientId;
DWORD               PauseClientId;
PSZ                 pszBaseAppImageName;
PSZ                    pszFullAppImageName;
WSTSTATE               WstState = NOT_STARTED;
char                   achPatchBuffer [PATCHFILESZ+1] = "???";
PULONG              pulWsiBits;
PULONG              pulWspBits;
PULONG              pulCurWsiBits;
static UINT         uiTimeSegs= 0;
ULONG                  ulSegSize;
ULONG             ulMaxSnapULONGs = (MAX_SNAPS_DFLT + 31) / 32;   // mdg 98/3
ULONG                  ulSnaps = 0L;
ULONG                  ulBitCount = 0L;
LARGE_INTEGER       liStart;
int                 iTimeInterval = 0;   // mdg 98/3
BOOL                fInThread = FALSE;
ULONG               ulThdStackSize = 16*PAGE_SIZE;
BOOL                fPatchImage = FALSE;
SECURITY_DESCRIPTOR SecDescriptor;
LARGE_INTEGER       liOverhead = {0L, 0L};

#ifdef BATCHING
HANDLE              hBatchFile;
BOOL                   fBatch = TRUE;
#endif



/* * * * * *  E X P O R T E D   G L O B A L    V A R I A B L E S  * * * * * */
/* none */





/******************************  W S T M a i n  *******************************
 *
 *  WSTMain () -
 *              This is the DLL entry routine.  It performs
 *              DLL's initializations and cleanup.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  TRUE if successful
 *          FALSE otherwise.
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

BOOLEAN WSTMain (IN PVOID DllHandle,
                 ULONG Reason,
                 IN PCONTEXT Context OPTIONAL)

{
    DllHandle;    // avoid compiler warnings
    Context;  // avoid compiler warnings


    if (Reason == DLL_PROCESS_ATTACH) {
        //
        // Initialize the DLL data
        //
#if defined(_PPC_LIBC)
        if (!_CRT_INIT(DllHandle, Reason, Context))
            return(FALSE);
#endif
        KdPrint (("WST:  DLL_PROCESS_ATTACH\n"));
        WstDllInitializations ();
    } else if (Reason == DLL_PROCESS_DETACH) {
        //
        // Cleanup time
        //
#if defined(_PPC_LIBC)
        if (!_CRT_INIT(DllHandle, Reason, Context))
            return(FALSE);
#endif
        KdPrint (("WST:  DLL_PROCESS_DETACH\n"));
        WstDllCleanups ();
    }
#if defined(DBG)
    else {
        KdPrint (("WST:  DLL_PROCESS_??\n"));  // mdg 98/3
    }
#endif   // DBG

    return (TRUE);

} /* WSTMain() */

/******************  W s t s t r d u p  ****************************
 *
 *  Wststrdup () -
 *     Allocate a memory and then duplicate a string
 *     It is here because we don't want to use strdup in crtdll.dll
 *
 *  ENTRY   LPSTR
 *
 *  EXIT    LPSTR
 *
 *  RETURN  NULL if failed
 *          LPSTR is success
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */
LPSTR Wststrdup (LPTSTR lpInput)
// No NULL return ever - throws exception if low on memory
{
    size_t   StringLen;
    LPSTR    lpOutput;

#if defined(DBG)
    if (NULL == lpInput) {
        KdPrint (("WST:  Wststrdup() - NULL pointer\n"));    // mdg 98/3
        return NULL;
    }
#endif
    if (NULL == hWstHeap) {
        hWstHeap = HeapCreate( HEAP_GENERATE_EXCEPTIONS, 1, 0 );   // Create min size growable heap
    }
    StringLen = strlen( lpInput ) + 1;
    lpOutput = HeapAlloc( hWstHeap, HEAP_GENERATE_EXCEPTIONS, StringLen );
    if (lpOutput)
        CopyMemory( lpOutput, lpInput, StringLen );

    return lpOutput;
}



/******************  W s t D l l I n i t i a l i z a t i o n s  ***************
 *
 *  WstDllInitializations () -
 *              Performs the following initializations:
 *
 *              o  Create LOCAL semaphore (not named)
 *                      o  Create/Open global storage for WST data
 *                      o  Locate all the executables/DLLs in the address and
 *                 grab all the symbols
 *              o  Sort the symbol list
 *              o  Set the profiling flag to TRUE
 *
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  TRUE if successful
 *          FALSE otherwise.
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

BOOLEAN WstDllInitializations ()
{
    DWORD_PTR                    dwAddr = 0L;
    DWORD                        dwPrevAddr = 0L;
    ANSI_STRING                  ObjName;
    UNICODE_STRING               UnicodeName;
    OBJECT_ATTRIBUTES           ObjAttributes;
    PLDR_DATA_TABLE_ENTRY    LdrDataTableEntry;
    PPEB                         Peb;
    PSZ                          ImageName;
    PLIST_ENTRY                  Next;
    ULONG                        ExportSize;
    PIMAGE_EXPORT_DIRECTORY  ExportDirectory;
    STRING                       ImageStringName;
    LARGE_INTEGER                AllocationSize;
    SIZE_T                       ulViewSize;
    LARGE_INTEGER                liOffset = {0L, 0L};
    HANDLE                       hIniFile;
    NTSTATUS                    Status;
    IO_STATUS_BLOCK              iostatus;
    char                         achTmpImageName [32];
    PCHAR                        pchPatchExes = "";
    PCHAR                        pchPatchImports = "";
    PCHAR                        pchPatchCallers = "";
    PCHAR                        pchTimeInterval = "";
    PVOID                       ImageBase;
    ULONG                       CodeLength;
    LARGE_INTEGER                liFreq;
    PIMG                     pImg;
    PIMAGE_NT_HEADERS            pImageNtHeader;
    TCHAR                        atchProfObjsName[160] = PROFOBJSNAME;
    PTEB                        pteb = NtCurrentTeb();
    LARGE_INTEGER             liStartTicks;
    LARGE_INTEGER             liEndTicks;
    ULONG                        ulElapsed;
    PCHAR                           pchEntry;
    int                          i;                  // To match "->iSymCnt"
#ifndef _WIN64
    PIMAGE_DEBUG_INFORMATION pImageDbgInfo = NULL;
#endif


    /*
     ***
     */

    SetSymbolSearchPath();

    // Create public share security descriptor for all the named objects
    //

    Status = RtlCreateSecurityDescriptor (
                                         &SecDescriptor,
                                         SECURITY_DESCRIPTOR_REVISION1
                                         );
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlCreateSecurityDescriptor failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }

    Status = RtlSetDaclSecurityDescriptor (
                                          &SecDescriptor,       // SecurityDescriptor
                                          TRUE,                 // DaclPresent
                                          NULL,                 // Dacl
                                          FALSE                 // DaclDefaulted
                                          );
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlSetDaclSecurityDescriptor failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }


    /*
     ***
     */

    // Initialization for GLOBAL semaphore creation (named)
    //
    RtlInitString (&ObjName, GLOBALSEMNAME);
    Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    // Create GLOBAL semaphore
    //
    Status = NtCreateSemaphore (&hGlobalSem,
                                SEMAPHORE_QUERY_STATE     |
                                SEMAPHORE_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                1L,
                                1L);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "GLOBAL semaphore creation failed - 0x%lx\n", Status));  // mdg 98/3
        return (FALSE);
    }


    /*
     ***
     */

    // Create LOCAL semaphore (not named - only for this process context)
    //
    Status = NtCreateSemaphore (&hLocalSem,
                                SEMAPHORE_QUERY_STATE     |
                                SEMAPHORE_MODIFY_STATE    |
                                SYNCHRONIZE,
                                NULL,
                                1L,
                                1L);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "LOCAL semaphore creation failed - 0x%lx\n",  // mdg 98/3
                  Status));
        return (FALSE);
    }


    /*
     ***
     */

    // Initialize for allocating shared memory
    //
    RtlInitString(&ObjName, SHAREDNAME);
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes(&ObjAttributes,
                               &UnicodeName,
                               OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                               NULL,
                               &SecDescriptor);

    AllocationSize.HighPart = 0;
    AllocationSize.LowPart = PAGE_SIZE;

    // Create a read-write section
    //
    Status = NtCreateSection(&hSharedSec,
                             SECTION_MAP_READ | SECTION_MAP_WRITE,
                             &ObjAttributes,
                             &AllocationSize,
                             PAGE_READWRITE,
                             SEC_RESERVE,
                             NULL);
    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtCreateSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    ulViewSize = AllocationSize.LowPart;
    pulShared = NULL;

    // Map the section - commit all
    //
    Status = NtMapViewOfSection (hSharedSec,
                                 NtCurrentProcess(),
                                 (PVOID *)&pulShared,
                                 0L,
                                 PAGE_SIZE,
                                 NULL,
                                 &ulViewSize,
                                 ViewUnmap,
                                 0L,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtMapViewOfSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    *pulShared = 0L;

    /*
     ***
     */

    hIniFile = CreateFile (
                          WSTINIFILE,                     // The filename
                          GENERIC_READ,                   // Desired access
                          FILE_SHARE_READ,                // Shared Access
                          NULL,                           // Security Access
                          OPEN_EXISTING,                  // Read share access
                          FILE_ATTRIBUTE_NORMAL,          // Open option
                          NULL);                          // No template file

    if (hIniFile == INVALID_HANDLE_VALUE) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "Error openning %s - 0x%lx\n", WSTINIFILE, GetLastError()));
        return (FALSE);
    }

    Status = NtReadFile(hIniFile,                // DLL patch file handle
                        0L,                       // Event - optional
                        NULL,                     // Completion routine - optional
                        NULL,                     // Completion routine argument - optional
                        &iostatus,                // Completion status
                        (PVOID)achPatchBuffer,    // Buffer to receive data
                        PATCHFILESZ,              // Bytes to read
                        &liOffset,                // Byte offset - optional
                        0L);                      // Target process - optional

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "Error reading %s - 0x%lx\n", WSTINIFILE, Status));
        return (FALSE);
    } else if (iostatus.Information >= PATCHFILESZ) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "initialization file buffer too small (%lu)\n", PATCHFILESZ));
        return (FALSE);
    } else {
        achPatchBuffer [iostatus.Information] = '\0';
        _strupr (achPatchBuffer);

        // Allow for headers to appear in any order in .INI or be absent
        pchPatchExes = strstr( achPatchBuffer, PATCHEXELIST );
        pchPatchImports = strstr( achPatchBuffer, PATCHIMPORTLIST );
        pchTimeInterval = strstr( achPatchBuffer, TIMEINTERVALIST );
        if (pchPatchExes != NULL) {
            if (pchPatchExes > achPatchBuffer)
                *(pchPatchExes - 1) = '\0';
        } else {
            pchPatchExes = "";
        }
        if (pchPatchImports != NULL) {
            if (pchPatchImports > achPatchBuffer)
                *(pchPatchImports - 1) = '\0';
        } else {
            pchPatchImports = "";
        }
        if (pchTimeInterval != NULL) {
            const char *   pSnapsEntry = strstr( pchTimeInterval, MAX_SNAPS_ENTRY );

            if (pchTimeInterval > achPatchBuffer)
                *(pchTimeInterval - 1) = '\0';
            if (pSnapsEntry) {
                long     lSnapsEntry =
                atol( pSnapsEntry + sizeof( MAX_SNAPS_ENTRY ) - 1 );
                if (lSnapsEntry > 0)
                    ulMaxSnapULONGs = (lSnapsEntry + 31) / 32;
            }
        } else {
            pchTimeInterval = "";
        }
    }

    NtClose (hIniFile);

    SdPrint (("WST:  WstDllInitializations() - Patching info:\n"));
    SdPrint (("WST:    -- %s\n", pchPatchExes));
    SdPrint (("WST:    -- %s\n", pchPatchImports));
    SdPrint (("WST:    -- %s\n", pchTimeInterval));


    /*
     ***
     */

    // Initialize for allocating global storage for WSPs
    //
    _ui64toa ((ULONG64)pteb->ClientId.UniqueProcess, atchProfObjsName+75, 10);
    _ui64toa ((ULONG64)pteb->ClientId.UniqueThread,  atchProfObjsName+105, 10);
    strcat (atchProfObjsName, atchProfObjsName+75);
    strcat (atchProfObjsName, atchProfObjsName+105);

    SdPrint (("WST:  WstDllInitializations() - %s\n", atchProfObjsName));

    RtlInitString(&ObjName, atchProfObjsName);
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    AllocationSize.HighPart = 0;
    AllocationSize.LowPart = MEMSIZE;

    // Create a read-write section
    //
    Status =NtCreateSection(&hWspSec,
                            SECTION_MAP_READ | SECTION_MAP_WRITE,
                            &ObjAttributes,
                            &AllocationSize,
                            PAGE_READWRITE,
                            SEC_RESERVE,
                            NULL);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtCreateSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    ulViewSize = AllocationSize.LowPart;
    pImg = &aImg[0];
    pImg->pWsp = NULL;

    // Map the section - commit the first 4 * COMMIT_SIZE pages
    //
    Status = NtMapViewOfSection(hWspSec,
                                NtCurrentProcess(),
                                (PVOID *)&(pImg->pWsp),
                                0L,
                                COMMIT_SIZE * 4,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllInitializations() - "
                  "NtMapViewOfSection() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    try /* EXCEPT - to handle access violation exception. */ {
        //
        // Locate all the executables/DLLs in the address and get their symbols
        //
        BOOL fTuneApp = FALSE;  // Set if whole app is to be tuned
        iImgCnt = 0;
        Peb = NtCurrentPeb();
        Next = Peb->Ldr->InMemoryOrderModuleList.Flink;

        for (; Next != &Peb->Ldr->InMemoryOrderModuleList; Next = Next->Flink) {
            IdPrint (("WST:  WstDllInitializations() - Walking module chain: 0x%lx\n", Next));
            LdrDataTableEntry =
            (PLDR_DATA_TABLE_ENTRY)
            (CONTAINING_RECORD(Next,LDR_DATA_TABLE_ENTRY,InMemoryOrderLinks));

            ImageBase = LdrDataTableEntry->DllBase;
            if ( Peb->ImageBaseAddress == ImageBase ) {

                RtlUnicodeStringToAnsiString (&ImageStringName,
                                              &LdrDataTableEntry->BaseDllName,
                                              TRUE);
                ImageName = ImageStringName.Buffer;
                pszBaseAppImageName = ImageStringName.Buffer;

                RtlUnicodeStringToAnsiString (&ImageStringName,
                                              &LdrDataTableEntry->FullDllName,
                                              TRUE);
                pszFullAppImageName = ImageStringName.Buffer;
                //
                //      Skip the object directory name (if any)
                //
                if ( (pszFullAppImageName = strchr(pszFullAppImageName, ':')) ) {
                    pszFullAppImageName--;
                } else {
                    pszFullAppImageName = pszBaseAppImageName;
                }
                IdPrint (("WST:  WstDllInitializations() - FullAppImageName: %s\n", pszFullAppImageName));
            } else {
                ExportDirectory =
                (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData (
                                                                      ImageBase,
                                                                      TRUE,
                                                                      IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                      &ExportSize);

                ImageName = (PSZ)((ULONG_PTR)ImageBase + ExportDirectory->Name);
                IdPrint (("WST:  WstDllInitializations() - ImageName: %s\n", ImageName));
            }

            pImageNtHeader = RtlImageNtHeader (ImageBase);

            _strupr (strcpy (achTmpImageName, ImageName));
            pchEntry = strstr (pchPatchExes, achTmpImageName);
            if (pchEntry) {
                if (*(pchEntry-1) == ';') {
                    pchEntry = NULL;
                } else if ( Peb->ImageBaseAddress == ImageBase )
                    fTuneApp = TRUE;
            }

            if ( strcmp (achTmpImageName, WSTDLL) && (pchEntry || fTuneApp) ) {
                if ( !fPatchImage )
                    fPatchImage = TRUE;
                //
                // Locate the code range.
                //
                pImg->pszName = Wststrdup (ImageName);
                pImg->ulCodeStart = 0L;
                pImg->ulCodeEnd = 0L;
                pImg->iSymCnt = 0;

#ifndef _WIN64
                pImageDbgInfo = MapDebugInformation (0L,
                                                     ImageName,
                                                     lpSymbolSearchPath,
                                                     (DWORD)ImageBase);

                if (pImageDbgInfo == NULL) {
                    IdPrint (("WST:  WstDllInitializations() - "
                              "No symbols for %s\n", ImageName));
                } else if ( pImageDbgInfo->CoffSymbols == NULL ) {
                    IdPrint (("WST:  WstDllInitializations() - "
                              "No coff symbols for %s\n", ImageName));
                } else {
                    PIMAGE_COFF_SYMBOLS_HEADER  DebugInfo;

                    DebugInfo = pImageDbgInfo->CoffSymbols;
                    if (DebugInfo->LvaToFirstSymbol == 0L) {
                        IdPrint (("WST:  WstDllInitializations() - "
                                  "Virtual Address to coff symbols not set for %s\n",
                                  ImageName));
                    } else {
                        CodeLength = (DebugInfo->RvaToLastByteOfCode -
                                      DebugInfo->RvaToFirstByteOfCode) - 1;
                        pImg->ulCodeStart = (ULONG)ImageBase +
                                            DebugInfo->RvaToFirstByteOfCode;
                        pImg->ulCodeEnd = pImg->ulCodeStart + CodeLength;
                        IdPrint(( "WST:  WstDllInitializations() - %ul total symbols\n", DebugInfo->NumberOfSymbols ));
                        WstGetSymbols (pImg, ImageName, ImageBase, CodeLength,
                                       DebugInfo);
                    }
                    // mdg 98/3
                    // Must release debug information - should not stay around cluttering up memory!
                    if (!UnmapDebugInformation( pImageDbgInfo ))
                        KdPrint(("WST:  WstDllInitializations() - failure in UnmapDebugInformation()\n"));
                    pImageDbgInfo = NULL;
                } // if pImageDbgInfo->CoffSymbols != NULL
#endif      // _WIN64

                IdPrint (("WST:  WstDllInitializations() - @ 0x%08lx "
                          "image #%d = %s; %d symbols extracted\n", (ULONG)ImageBase, iImgCnt,
                          ImageName, pImg->iSymCnt));
                pImg->pWsp[pImg->iSymCnt].pszSymbol = UNKNOWN_SYM;
                pImg->pWsp[pImg->iSymCnt].ulFuncAddr = UNKNOWN_ADDR;
                pImg->pWsp[pImg->iSymCnt].ulBitString = 0;  // mdg 98/3
                pImg->pWsp[pImg->iSymCnt].ulCodeLength = 0;  // mdg 98/3
                (pImg->iSymCnt)++;

                //
                // Set wsi.
                //
                pImg->pulWsi = pImg->pulWsiNxt = (PULONG)
                                                 (pImg->pWsp + pImg->iSymCnt);
                RtlZeroMemory (pImg->pulWsi,
                               pImg->iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));


                //
                // Set wsp.
                //
                pImg->pulWsp = (PULONG)(pImg->pulWsi +
                                        (pImg->iSymCnt * ulMaxSnapULONGs));
                RtlZeroMemory (pImg->pulWsp,
                               pImg->iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));

                //
                // Sort wsp & set code lengths
                //
                WstSort (pImg->pWsp, 0, pImg->iSymCnt-1);
                //
                // Last symbol length is set to be the same as length of
                // (n-1)th symbol or remaining code length of module
                //
                i = pImg->iSymCnt - 1;  // mdg 98/3 (assert pImg->iSymCnt is at least 1)
                if (i--) {   // Test count & set index to top symbol
                    pImg->pWsp[i].ulCodeLength = (ULONG)(
                    i ? pImg->pWsp[i].ulFuncAddr - pImg->pWsp[i - 1].ulFuncAddr
                    : pImg->ulCodeEnd + 1 - pImg->pWsp[i].ulFuncAddr);

                    while (i-- > 0) {   // Enumerate symbols & set index
                        pImg->pWsp[i].ulCodeLength = (ULONG)(pImg->pWsp[i+1].ulFuncAddr -
                                                     pImg->pWsp[i].ulFuncAddr);
                    }
                }

                //
                // Setup next pWsp
                //
                (pImg+1)->pWsp = (PWSP)(pImg->pulWsp +
                                        (pImg->iSymCnt * ulMaxSnapULONGs));
                iImgCnt++;
                pImg++;

                if (iImgCnt == MAX_IMAGES) {
                    KdPrint(("WST:  WstDllInitialization() - Not enough "
                             "space allocated for all images\n"));
                    return (FALSE);
                }
            }

        }  // if (Next != &Peb->Ldr->InMemoryOrderModuleList)
    } // try
    //
    // + : transfer control to the handler (EXCEPTION_EXECUTE_HANDLER)
    // 0 : continue search             (EXCEPTION_CONTINUE_SEARCH)
    // - : dismiss exception & continue   (EXCEPTION_CONTINUE_EXECUTION)
    //
    except ( WstAccessXcptFilter (GetExceptionCode(), GetExceptionInformation()) )
    {
        //
        // Should never get here since filter never returns
        // EXCEPTION_EXECUTE_HANDLER.
        //
        KdPrint (("WST:  WstDllInitializations() - *LOGIC ERROR* - "
                  "Inside the EXCEPT: (xcpt=0x%lx)\n", GetExceptionCode()));
    }
    /*
     ***
     */

    //
    // Get the frequency
    //
    NtQueryPerformanceCounter (&liStart, &liFreq);

    if (strlen(pchTimeInterval) > (sizeof(TIMEINTERVALIST)+1))  // mdg 98/3
        iTimeInterval = atoi (pchTimeInterval+sizeof(TIMEINTERVALIST)+1);
    if ( iTimeInterval == 0 ) {
        //
        // Use the default value
        //
        iTimeInterval = TIMESEG;
    }
    ulSegSize = iTimeInterval * (liFreq.LowPart / 1000);

#ifdef BATCHING
    fBatch = WstOpenBatchFile();
#endif

    SdPrint (("WST:  Time interval:  Millisecs=%d  Ticks=%lu\n",
              iTimeInterval, ulSegSize));

    if (fPatchImage) {

        // Initialization for DONE event creation
        //
        RtlInitString (&ObjName, DONEEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create DONE event
        //
        Status = NtCreateEvent (&hDoneEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                TRUE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "DONE event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for DUMP event creation
        //
        RtlInitString (&ObjName, DUMPEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create DUMP event
        //
        Status = NtCreateEvent (&hDumpEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "DUMP event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for CLEAR event creation
        //
        RtlInitString (&ObjName, CLEAREVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);

        // Create CLEAR event
        //
        Status = NtCreateEvent (&hClearEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "CLEAR event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }


        // Initialization for PAUSE event creation
        //
        RtlInitString (&ObjName, PAUSEEVENTNAME);
        Status = RtlAnsiStringToUnicodeString (&UnicodeName, &ObjName, TRUE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "RtlAnsiStringToUnicodeString failed - 0x%lx\n", Status));
            return (FALSE);
        }

        InitializeObjectAttributes (&ObjAttributes,
                                    &UnicodeName,
                                    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    &SecDescriptor);
        // Create PAUSE event
        //
        Status = NtCreateEvent (&hPauseEvent,
                                EVENT_QUERY_STATE    |
                                EVENT_MODIFY_STATE |
                                SYNCHRONIZE,
                                &ObjAttributes,
                                NotificationEvent,
                                FALSE);
        RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllInitializations() - "
                      "PAUSE event creation failed - 0x%lx\n", Status));  // mdg 98/3
            return (FALSE);
        }

        //
        // Calculate excess overhead for WstRecordInfo
        //
        liOverhead.HighPart = 0L;
        liOverhead.LowPart  = 0xFFFFFFFF;
        for (i=0; i < NUM_ITERATIONS; i++) {
            NtQueryPerformanceCounter (&liStartTicks, NULL);
            //
            WSTUSAGE(NtCurrentTeb()) = 0L;

#ifdef i386
            _asm
            {
                push  edi
                mov     edi, dword ptr [ebp+4]
                mov     dwAddr, edi
                mov     edi, dword ptr [ebp+8]
                mov     dwPrevAddr, edi
                pop     edi
            }
#endif

#if defined(ALPHA) || defined(IA64)
            {
                PULONG  pulAddr;
                DWORDLONG SaveRegisters [REG_BUFFER_SIZE] ;

                SaveAllRegs (SaveRegisters);

                pulAddr = (PULONG) dwAddr;
                pulAddr -= 1;

                RestoreAllRegs (SaveRegisters);
            }
#elif defined(_X86_)
            SaveAllRegs ();
            RestoreAllRegs ();
#endif
            WSTUSAGE(NtCurrentTeb()) = 0L;
            Status = NtWaitForSingleObject (hLocalSem, FALSE, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllInitilizations() - "
                          "Wait for LOCAL semaphore failed - 0x%lx\n", Status));
            }
            liStart.QuadPart = liStart.QuadPart - liStart.QuadPart ;
            liStart.QuadPart = liStart.QuadPart + liStart.QuadPart ;
            liStart.QuadPart = liStart.QuadPart + liStart.QuadPart ;

            Status = NtReleaseSemaphore (hLocalSem, 1, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllInitializations() - "
                          "Error releasing LOCAL semaphore - 0x%lx\n", Status));
            }
            WSTUSAGE(NtCurrentTeb()) = 0L;
            //
            NtQueryPerformanceCounter (&liEndTicks, NULL);
            ulElapsed = liEndTicks.LowPart - liStartTicks.LowPart;
            if (ulElapsed < liOverhead.LowPart) {
                liOverhead.LowPart = ulElapsed;
            }
        }
        SdPrint (("WST:  WstDllInitializations() - WstRecordInfo() overhead = %lu\n",
                  liOverhead.LowPart));

        // Start monitor threads
        //
        hDumpThread = CreateThread (
                                   NULL,                                   // no security attribute
                                   (DWORD)1024L,                           // initial stack size
                                   (LPTHREAD_START_ROUTINE)WstDumpThread,  // thread starting address
                                   NULL,                                   // no argument for the thread
                                   (DWORD)0,                               // no creation flag
                                   &DumpClientId);                         // address for thread id
        hClearThread = CreateThread (
                                    NULL,                                   // no security attribute
                                    (DWORD)1024L,                           // initial stack size
                                    (LPTHREAD_START_ROUTINE)WstClearThread, // thread starting address
                                    NULL,                                   // no argument for the thread
                                    (DWORD)0,                               // no creation flag
                                    &ClearClientId);                        // address for thread id
        hPauseThread = CreateThread (
                                    NULL,                                   // no security attribute
                                    (DWORD)1024L,                           // initial stack size
                                    (LPTHREAD_START_ROUTINE)WstPauseThread, // thread starting address
                                    NULL,                                   // no argument for the thread
                                    (DWORD)0,                               // no creation flag
                                    &PauseClientId);                        // address for thread id

        NtQueryPerformanceCounter (&liStart, NULL);
        WstState = STARTED;
    }

    return (TRUE);

} /* WstDllInitializations () */





/******************************  _ p e n t e r  ******************************
 *
 *  _penter() / _mcount() -
 *              This is the main profiling routine.  This routine is called
 *              upon entry of each routine in the profiling DLL/EXE.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              Compiling apps with -Gp option trashs EAX initially.
 *
 */
#ifdef i386
void __cdecl _penter ()
#elif defined(ALPHA) || defined(IA64) || defined(_AMD64_)
void c_penter (ULONG_PTR dwPrevious, ULONG_PTR dwCurrent)
#endif
{
    DWORD_PTR        dwAddr;
    DWORD_PTR        dwPrevAddr;
    ULONG_PTR        ulInWst ;
#if defined(ALPHA) || defined(_AXP64_) || defined(IA64)
    PULONG  pulAddr;
    DWORDLONG SaveRegisters [REG_BUFFER_SIZE];
    SaveAllRegs(SaveRegisters) ;
#endif

    dwAddr = 0L;
    dwPrevAddr = 0L;
    ulInWst = WSTUSAGE(NtCurrentTeb());

    if (WstState != STARTED) {
        goto Exit0;
    } else if (ulInWst) {
        goto Exit0;
    }


    //
    //  Put the address of the calling function into var dwAddr
    //
#ifdef i386
    _asm
    {
        push  edi
        mov     edi, dword ptr [ebp+4]
        mov     dwAddr, edi
        mov     edi, dword ptr [ebp+8]
        mov     dwPrevAddr, edi
        pop     edi
    }
#endif

#if defined(ALPHA) || defined(IA64)
    dwPrevAddr = NO_CALLER;
    dwAddr = dwCurrent;
    // GetCaller (&dwAddr, 0x0220);  // FIXFIX StackSize

    // now check if we are calling from the stub we created
    pulAddr = (PULONG) dwAddr;
    pulAddr -= 1;

    if (*(pulAddr)          == 0x681b4000  &&
        (*(pulAddr  + 1)     == 0xa75e0008) &&
        (*(pulAddr  + 8)     == 0xfefe55aa) ) {

        // get the address that we will go after the penter function
        dwAddr = *(pulAddr + 4) & 0x0000ffff;
        if (*(pulAddr + 5) & 0x00008000) {
            // fix the address since we have to add one when
            // we created our stub code
            dwAddr -= 1;
        }
        dwAddr = dwAddr << 16;
        dwAddr |= *(pulAddr + 5) & 0x0000ffff;

        // get the caller to the stub
        dwPrevAddr = dwPrevious;
        // GetStubCaller (&dwPrevAddr, 0x0220);   // FIXFIX StackSize
    }


#endif


    //
    //  Call WstRecordInfo for this API
    //
#ifdef i386
    SaveAllRegs ();
#endif

    WstRecordInfo (dwAddr, dwPrevAddr);

#ifdef i386
    RestoreAllRegs ();
#endif


    Exit0:

#if defined(ALPHA) || defined(IA64)
    RestoreAllRegs (SaveRegisters);
#endif

    return;
} /* _penter() / _mcount()*/

void __cdecl _mcount ()
{
}





/*************************  W s t R e c o r d I n f o  ************************
 *
 *  WstRecordInfo (dwAddress) -
 *
 *  ENTRY   dwAddress - Address of the routine just called
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

void WstRecordInfo (DWORD_PTR dwAddress, DWORD_PTR dwPrevAddress)
{

    NTSTATUS         Status;
    INT          x;
    INT              i, iIndex;
    PWSP         pwspTmp;
    LARGE_INTEGER   liNow, liTmp;
    LARGE_INTEGER    liElapsed;
    CHAR         *pszSym;

#ifdef BATCHING
    CHAR         szBatchBuf[128];
    DWORD            dwCache;
    DWORD            dwHits;
    DWORD            dwBatch;
    IO_STATUS_BLOCK ioStatus;
#endif


    WSTUSAGE(NtCurrentTeb()) = 1;

    //
    //  Wait for the semaphore object to suspend execution of other threads
    //
    Status = NtWaitForSingleObject (hLocalSem, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstRecordInfo() - "
                  "Wait for LOCAL semaphore failed - 0x%lx\n", Status));
    }

    NtQueryPerformanceCounter(&liNow, NULL);
    liElapsed.QuadPart = liNow.QuadPart - liStart.QuadPart ;


    //   SdPrint(("WST:  WstRecordInfo() - Elapsed time: %ld\n", liElapsed.LowPart));

    //
    //  WstBSearch is a binary find function that will return the address of
    //  the wsp record we want
    //

    //   SdPrint(("WST:  WstRecordInfo() - Preparing for WstBSearch of 0x%lx\n",
    //      dwAddress-5));

    pwspTmp = NULL;
    for (i=0; i<iImgCnt; i++) {
        if ( (dwAddress >= aImg[i].ulCodeStart) &&
             (dwAddress < aImg[i].ulCodeEnd) ) {
#ifdef i386
            pwspTmp = WstBSearch(dwAddress-5, aImg[i].pWsp, aImg[i].iSymCnt);
            if (!pwspTmp) {
                pwspTmp = WstBSearch(UNKNOWN_ADDR, aImg[i].pWsp, aImg[i].iSymCnt);
            }
#else
            // the following works for both MIPS and ALPHA

            pwspTmp = WstBSearch(dwAddress, aImg[i].pWsp, aImg[i].iSymCnt);
            if (!pwspTmp) {
                // symbol not found
                pwspTmp = WstBSearch(UNKNOWN_ADDR, aImg[i].pWsp, aImg[i].iSymCnt);
            }
#endif
            break;
        }
    }
    iIndex = i;

    if (pwspTmp) {
        pszSym = pwspTmp->pszSymbol;
        pwspTmp->ulBitString |= 1;
    } else {
        SdPrint (("WST:  WstRecordInfo() - LOGIC ERROR - Completely bogus addr = 0x%08lx\n",
                  dwAddress));   // We could also get here if moduled compiled with -Gh but no COFF symbols available
    }

    if (liElapsed.LowPart >= ulSegSize) {
        SdPrint(("WST:  WstRecordInfo() - ulSegSize expired; "
                 "Preparing to shift the BitStrings\n"));

        if (ulBitCount < 31) {
            for (i=0; i<iImgCnt; i++) {
                for (x=0; x < aImg[i].iSymCnt ; x++ ) {
                    aImg[i].pWsp[x].ulBitString <<= 1;
                }
            }
        }

        liElapsed.LowPart = 0L;
        ulBitCount++;
        NtQueryPerformanceCounter(&liStart, NULL);
        liNow = liStart;

        if (ulBitCount == 32) {
            SdPrint(("WST:  WstRecordInfo() - Dump Bit Strings\n"));
            for (i=0; i<iImgCnt; i++) {
                for (x=0; x < aImg[i].iSymCnt ; x++ ) {
                    aImg[i].pulWsiNxt[x] = aImg[i].pWsp[x].ulBitString;
                    aImg[i].pWsp[x].ulBitString = 0L;
                }
                aImg[i].pulWsiNxt += aImg[i].iSymCnt;
            }
            ulSnaps++;
            ulBitCount = 0;
            if (ulSnaps == ulMaxSnapULONGs) {
                KdPrint (("WST:  WstRecordInfo() - No more space available"
                          " for next time snap data!\n"));
                //
                // Dump and clear the data
                //
                WstDataOverFlow();
            }
        }
    }

#ifdef BATCHING
    //
    //  The following code will get the current batching information
    //  if the DLL was compiled with the BATCHING variable set.  You
    //  should not have this variable set if you are tuning GDI.
    //
    if (fBatch) {
        GdiGetCsInfo(&dwHits, &dwBatch, &dwCache);

        if (dwHits)
            GdiResetCsInfo();

        if (dwBatch == 10)
            GdiResetCsInfo();

        while (*(pszSym++) != '_');

        sprintf(szBatchBuf, "%s:%s,%ld,%ld,%ld\n",
                aImg[iIndex].pszName, pszSym, dwHits, dwBatch, dwCache);
        Status = NtWriteFile(hBatchFile,
                             NULL,
                             NULL,
                             NULL,
                             &ioStatus,
                             szBatchBuf,
                             strlen(szBatchBuf),
                             NULL,
                             NULL
                            );

        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstRecodInfo() - "
                      "NtWriteFile() failed on hBatchFile - 0x%lx\n", Status));
        }
    }//Batching info
#endif


    //
    //  We call NtQueryPerformanceCounter here to account for the overhead
    //  required for doing our work
    //
    NtQueryPerformanceCounter(&liTmp, NULL);
    liElapsed.QuadPart = liTmp.QuadPart - liNow.QuadPart ;
    liStart.QuadPart = liStart.QuadPart + liElapsed.QuadPart ;
    liStart.QuadPart = liStart.QuadPart + liOverhead.QuadPart ;

    //
    // Release semaphore to continue execution of other threads
    //
    Status = NtReleaseSemaphore (hLocalSem, 1, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstRecordInfo () - "
                  "Error releasing LOCAL semaphore - 0x%lx\n", Status));
    }

    WSTUSAGE(NtCurrentTeb()) = 0L;

} /* WstRecordInfo () */





/********************  W s t C l e a r B i t S t r i n g  *********************
 *
 *  Function:   WstClearBitStrings (pImg)
 *
 *  Purpose:    This function clears the BitString for each symbol.
 *
 *  Parameters: pImg - Current image data structure pointer
 *
 *  Returns:    -none-
 *
 *  History:    8-3-92  Marklea - created
 *
 */

void WstClearBitStrings (PIMG pImg)
{
    UINT    uiLshft = 0;
    INT  x;


    //
    //  Since we are completed with the profile, we need to create a
    //  DWORD out of the balance of the bitString.  We do this by  left
    //  shifting the bitstring by difference between the bitCount and
    //  32.
    //
    if (ulBitCount < 32) {
        uiLshft =(UINT)(31 - ulBitCount);
        for (x=0; x < pImg->iSymCnt; x++) {
            pImg->pWsp[x].ulBitString <<= uiLshft;
            pImg->pulWsiNxt[x] = pImg->pWsp[x].ulBitString;
        }
        pImg->pulWsiNxt += pImg->iSymCnt;
    }


} /* WstClearBitStrings () */





/***********************  W s t I n i t W s p F i l e  ***********************
 *
 *   Function:  WstInitWspFile (pImg)
 *
 *   Purpose:   This function will create a WSP file and dump the header
 *               information for the file.
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:   Handle to the WSP file.
 *
 *   History:   8-3-92  Marklea - created
 *
 */

HANDLE WstInitWspFile (PIMG pImg)
{
    CHAR    szOutFile [256] = WSTROOT;
    CHAR szModName [128] = {0};
    PCHAR pDot;
    CHAR szExt [5] = "WSP";
    WSPHDR  wsphdr;
    DWORD   dwBytesWritten;
    BOOL    fRet;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    int      iExt = 0;

    //
    //  Prepare the filename path
    //
    strcat (szOutFile, pImg->pszName);

    //
    //  Open the file for binary output.
    //
    pImg->fDumpAll = TRUE;
    while (iExt < 256) {
        strcpy ((strchr(szOutFile,'.'))+1, szExt);
        hFile = CreateFile ( szOutFile,      // WSP file handle
                             GENERIC_WRITE |
                             GENERIC_READ, // Desired access
                             0L,             // Read share access
                             NULL,           // No EaBuffer
                             CREATE_NEW,
                             FILE_ATTRIBUTE_NORMAL,
                             0);             // EaBuffer length
        if (hFile != INVALID_HANDLE_VALUE) {
            IdPrint(("WST:  WstInitWspFile() - WSP file name: %s\n",
                     szOutFile));
            if (iExt != 0) {
                pImg->fDumpAll = FALSE;
            }
            break;
        }
        iExt++;
        sprintf (szExt, "W%02x", iExt);
    }
    if (iExt == 256) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error creating %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return (hFile);
    }

    //
    //  Fill a WSP header structure
    //

    strcpy(szModName, pImg->pszName);
    pDot = strchr(szModName, '.');
    if (pDot)
        strcpy(pDot, "");

    strcpy(wsphdr.chFileSignature, "WSP");
    wsphdr.ulTimeStamp   = 0L;
    wsphdr.usId         = 0;
    wsphdr.ulApiCount    = 0;
    wsphdr.ulSetSymbols  = pImg->ulSetSymbols;
    wsphdr.ulModNameLen  = strlen(szModName);
    wsphdr.ulSegSize = (ULONG)iTimeInterval;
    wsphdr.ulOffset      = wsphdr.ulModNameLen + (ULONG)sizeof(WSPHDR);
    wsphdr.ulSnaps      = ulSnaps;

    //
    //  Write header and module name
    //
    fRet = WriteFile(hFile,                      // Wsp file handle
                     (PVOID)&wsphdr,           // Buffer of data
                     (ULONG)sizeof(WSPHDR),    // Bytes to write
                     &dwBytesWritten,          // Bytes written
                     NULL);

    if (!fRet) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError));
        return (NULL);
    }

    fRet = WriteFile (hFile,                 // Wsp file handle
                      (PVOID)szModName,         // Buffer of data
                      (ULONG)strlen(szModName),     // Bytes to write
                      &dwBytesWritten,
                      NULL);
    if (!fRet) {
        KdPrint (("WST:  WstInitWspFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return (NULL);
    }

    return (hFile);

} /* WstInitWspFile () */





/**************************  W s t D u m p D a t a  **************************
 *
 *   Function:  WstDumpData (pImg)
 *
 *   Purpose:
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:   NONE
 *
 *   History:   8-3-92  Marklea - created
 *
 */

void WstDumpData (PIMG pImg)
{
    INT      x = 0;
    DWORD    dwBytesWritten;
    BOOL     fRet;
    HANDLE   hWspFile;


    if ( !(hWspFile = WstInitWspFile(pImg)) ) {
        KdPrint (("WST:  WstDumpData() - Error creating WSP file.\n"));
        return;
    }

    //
    // Write all the symbols with any bits set
    //
    for (x=0; x<pImg->iSymCnt; x++) {
        if (pImg->pWsp[x].ulBitString) {
            fRet = WriteFile(
                            hWspFile,                          // Wsp file handle
                            (PVOID)(pImg->pulWsp+(x*ulSnaps)),  // Buffer of data
                            ulSnaps * sizeof(ULONG),           // Bytes to write
                            &dwBytesWritten,                       // Bytes written
                            NULL);                             // Optional
            if (!fRet) {
                KdPrint (("WST:  WstDumpData() - "
                          "Error writing to WSP file - 0x%lx\n",
                          GetLastError()));
                return;
            }
        }
    }
    //
    // Now write all the symbols with no bits set
    //
    if (pImg->fDumpAll) {
        for (x=0; x<pImg->iSymCnt; x++) {
            if (pImg->pWsp[x].ulBitString == 0L) {
                fRet = WriteFile(
                                hWspFile,                           // Wsp file handle
                                (PVOID)(pImg->pulWsp+(x*ulSnaps)),  // Buffer of data
                                ulSnaps * sizeof(ULONG),            // Bytes to write
                                &dwBytesWritten,                    // Bytes written
                                NULL);                              // Optional
                if (!fRet) {
                    KdPrint (("WST:  WstDumpData() - "
                              "Error writing to WSP file - 0x%lx\n",
                              GetLastError()));
                    return;
                }
            }
        }
    }

    fRet = CloseHandle(hWspFile);
    if (!fRet) {
        KdPrint (("WST:  WstDumpData() - "
                  "Error closing %s - 0x%lx\n", "WSI file",
                  GetLastError()));
        return;
    }

} /* WstDumpData () */





/************************  W s t W r i t e T m i F i l e **********************
 *
 *   Function:  WstWriteTmiFile (pImg)
 *
 *   Purpose:  Write all the symbole info for the current image to its TMI
 *             file.
 *
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:    -none-
 *
 *   History:   8-5-92  Marklea - created
 *
 */

void WstWriteTmiFile (PIMG pImg)
{
    CHAR    szOutFile [256] = WSTROOT;
    CHAR    szBuffer [256];
    CHAR szExt [5] = "TMI";
    HANDLE  hTmiFile;
    INT     x;
    DWORD   dwBytesWritten;
    BOOL    fRet;
    int     iExt = 0;
    PSZ     pszSymbol;
    ULONG    nSymbolLen;


    //
    //  Prepare the filename path
    //
    strcat (szOutFile, pImg->pszName);

    //
    //  Open the file for binary output.
    //
    pImg->fDumpAll = TRUE;
    KdPrint (("WST:  WstWriteTmiFile() - creating TMI for %s\n", szOutFile));
    while (iExt < 256) {
        strcpy ((strchr(szOutFile,'.'))+1, szExt);
        hTmiFile = CreateFile ( szOutFile,      // TMI file handle
                                GENERIC_WRITE |
                                GENERIC_READ, // Desired access
                                0L,             // Read share access
                                NULL,           // No EaBuffer
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                0);             // EaBuffer length
        if (hTmiFile != INVALID_HANDLE_VALUE) {
            IdPrint(("WST:  WstWriteTmiFile() - TMI file name: %s\n",
                     szOutFile));
            if (iExt != 0) {
                pImg->fDumpAll = FALSE;
            }
            break;
        }
        iExt++;
        sprintf (szExt, "T%02x", iExt);
    }
    if (iExt == 256) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error creating %s - 0x%lx\n", szOutFile,
                  GetLastError()));
        return;
    }

    sprintf(szBuffer, "/* %s for NT */\n"
            "/* Total Symbols= %lu */\n"
            "DO NOT DELETE\n"
            "%d\n"
            "TDFID   = 0\n",
            pImg->pszName,
            pImg->fDumpAll ? pImg->iSymCnt : pImg->ulSetSymbols,
            iTimeInterval);
    //
    //  Write header
    //
    fRet = WriteFile(hTmiFile,                 // Tmi file handle
                     (PVOID)szBuffer,        // Buffer of data
                     (ULONG)strlen(szBuffer), // Bytes to write
                     &dwBytesWritten,        // Bytes written
                     NULL);

    if (!fRet) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error writing to %s - 0x%lx\n", szOutFile,
                  GetLastError));
        return;
    }

    //
    // Dump all the symbols with set bits.
    //
    IdPrint (("WST:  WstWriteTmiFile() - Dumping set symbols...\n"));
    for (x=0; x<pImg->iSymCnt ; x++) {
        if (pImg->pWsp[x].ulBitString) {
            pszSymbol =
            (pImg->pWsp[x].pszSymbol);
            nSymbolLen = strlen( pszSymbol );   // mdg 98/4

            sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %lu ", // mdg 98/4
                    (LONG)x, pImg->pWsp[x].ulFuncAddr,
                    pImg->pWsp[x].ulCodeLength, nSymbolLen);
            //
            //  Write symbol line
            //
            fRet = WriteFile(hTmiFile,               // Tmi file handle
                             (PVOID)szBuffer,    // Buffer of data
                             (ULONG)strlen(szBuffer), // Bytes to write
                             &dwBytesWritten,  // Bytes written
                             NULL)
                   && WriteFile(hTmiFile,                  // Tmi file handle
                                (PVOID)pszSymbol,   // Buffer of data
                                nSymbolLen,       // Bytes to write
                                &dwBytesWritten,  // Bytes written
                                NULL)
                   && WriteFile(hTmiFile,                  // Tmi file handle
                                (PVOID)"\n",      // Buffer of data
                                1,                // Bytes to write
                                &dwBytesWritten,  // Bytes written
                                NULL);

            if (!fRet) {
                KdPrint (("WST:  WstWriteTmiFile() - "
                          "Error writing to %s - 0x%lx\n", szOutFile,
                          GetLastError));
                return;
            }
        }
    }
    //
    // Now dump all the symbols without any bits set.
    //
    IdPrint (("WST:  WstWriteTmiFile() - Dumping unset symbols...\n"));
    if (pImg->fDumpAll) {
        for (x=0; x<pImg->iSymCnt ; x++ ) {
            if (!pImg->pWsp[x].ulBitString) {
                pszSymbol =
                (pImg->pWsp[x].pszSymbol);
                nSymbolLen = strlen( pszSymbol );   // mdg 98/4
                sprintf(szBuffer, "%ld 0000:%08lx 0x%lx %lu ", // mdg 98/4
                        (LONG)x, pImg->pWsp[x].ulFuncAddr,
                        pImg->pWsp[x].ulCodeLength, nSymbolLen);
                //
                //      Write symbol line
                //
                fRet = WriteFile(hTmiFile,                // Tmi file handle
                                 (PVOID)szBuffer, // Buffer of data
                                 (ULONG)strlen(szBuffer), // Bytes to write
                                 &dwBytesWritten,  // Bytes written
                                 NULL)
                       && WriteFile(hTmiFile,               // Tmi file handle
                                    (PVOID)pszSymbol,    // Buffer of data
                                    nSymbolLen,       // Bytes to write
                                    &dwBytesWritten,  // Bytes written
                                    NULL)
                       && WriteFile(hTmiFile,               // Tmi file handle
                                    (PVOID)"\n",      // Buffer of data
                                    1,                // Bytes to write
                                    &dwBytesWritten,  // Bytes written
                                    NULL);

                if (!fRet) {
                    KdPrint (("WST:  WstWriteTmiFile() - "
                              "Error writing to %s - 0x%lx\n", szOutFile,
                              GetLastError));
                    return;
                }
            }
        }
    }

    fRet = CloseHandle(hTmiFile);
    if (!fRet) {
        KdPrint (("WST:  WstWriteTmiFile() - "
                  "Error closing %s - 0x%lx\n", szOutFile, GetLastError()));
        return;
    }

}  /* WstWriteTmiFile () */





/***********************  W s t R o t a t e W s i M e m ***********************
 *
 *   Function:  WstRotateWsiMem (pImg)
 *
 *   Purpose:
 *
 *
 *   Parameters: pImg - Current image data structure pointer
 *
 *   Returns:    -none-
 *
 *   History:   8-5-92  Marklea - created
 *
 */

void WstRotateWsiMem (PIMG pImg)
{
    ULONG    ulCurSnap;
    ULONG    ulOffset;
    int      x;
    PULONG  pulWsp;


    pulWsp = pImg->pulWsp;
    pImg->ulSetSymbols = 0;

    for (x=0; x<pImg->iSymCnt; x++) {
        ulOffset = 0L;
        ulCurSnap = 0L;
        pImg->pWsp[x].ulBitString = 0L;

        while (ulCurSnap < ulSnaps) {

            ulOffset = (ULONG)x + ((ULONG)pImg->iSymCnt * ulCurSnap);
            *pulWsp = *(pImg->pulWsi + ulOffset);
            pImg->pWsp[x].ulBitString |= (*pulWsp);
            pulWsp++;
            ulCurSnap++;
        }

        if (pImg->pWsp[x].ulBitString) {
            /*
                     SdPrint (("WST:  WstRotateWsiMem() - set:  %s\n",
                        pImg->pWsp[x].pszSymbol));
            */
            (pImg->ulSetSymbols)++;
        }
    }

    IdPrint (("WST:  WstRotateWsiMem() - Number of set symbols = %lu\n",
              pImg->ulSetSymbols));

} /* WstRotateWsiMwm () */





/***********************  W s t G e t S y m b o l s  *************************
 *
 *  WstGetSymbols (pCurWsp, pszImageName, pvImageBase, ulCodeLength, DebugInfo)
 *              This routine stores all the symbols for the current
 *              image into pCurWsp
 *
 *  ENTRY   upCurWsp - Pointer to current WSP structure
 *              pszImageName - Pointer to image name
 *              pvImageBase - Current image base address
 *              ulCodeLength - Current image code length
 *                      DebugInfo - Pointer to the coff debug info structure
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */
#ifndef _WIN64

void WstGetSymbols (PIMG pCurImg,
                    PSZ   pszImageName,
                    PVOID pvImageBase,
                    ULONG ulCodeLength,
                    PIMAGE_COFF_SYMBOLS_HEADER DebugInfo)
{
    IMAGE_SYMBOL             Symbol;
    PIMAGE_SYMBOL            SymbolEntry;
    PUCHAR                   StringTable;
    ULONG                    i;
    char                     achTmp[9];
    PWSP                     pCurWsp;
    PSZ                      ptchSymName;


    pCurWsp = pCurImg->pWsp;
    achTmp[8] = '\0';

    //
    // Crack the COFF symbol table
    //
    SymbolEntry = (PIMAGE_SYMBOL)
                  ((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol);
    StringTable = (PUCHAR)((ULONG)DebugInfo + DebugInfo->LvaToFirstSymbol +
                           DebugInfo->NumberOfSymbols * (ULONG)IMAGE_SIZEOF_SYMBOL);

    //
    // Loop through all symbols in the symbol table.
    //
    for (i = 0; i < DebugInfo->NumberOfSymbols; i++) {
        //
        // Skip thru aux symbols..
        //
        RtlMoveMemory (&Symbol, SymbolEntry, IMAGE_SIZEOF_SYMBOL);

        if (Symbol.SectionNumber == 1) {   //code section
            if (ISFCN( Symbol.Type )) {  // mdg 98/3 Also picks up WEAK_EXTERNAL functions
                //
                // This symbol is within the code.
                //
                pCurImg->iSymCnt++;
                pCurWsp->ulBitString = 0L;
                pCurWsp->ulFuncAddr = Symbol.Value + (ULONG)pvImageBase;
                if (Symbol.N.Name.Short) {
                    strncpy (achTmp, (PSZ)&(Symbol.N.Name.Short), 8);
#ifdef i386
                    // only need to strip leading underscore for i386.
                    // mips and alpha are ok.
                    if (achTmp[0] == '_') {
                        pCurWsp->pszSymbol = Wststrdup (&achTmp[1]);
                    } else {
                        pCurWsp->pszSymbol = Wststrdup (achTmp);
                    }
#else
                    pCurWsp->pszSymbol = Wststrdup (achTmp);
#endif
                } else {
                    ptchSymName = (PSZ)&StringTable[Symbol.N.Name.Long];
#ifdef i386
                    // only need to strip leading underscore for i386.
                    // mips and alpha are ok.
                    if (*ptchSymName == '_') {
                        ptchSymName++;
                    }
#endif

                    pCurWsp->pszSymbol = Wststrdup (ptchSymName);
                }

                //            IdPrint(( "WST:  WstGetSymbols() - 0x%lx = %s\n", pCurWsp->ulFuncAddr, pCurWsp->pszSymbol ));

                pCurWsp++;
            }
        }
        SymbolEntry = (PIMAGE_SYMBOL)((ULONG)SymbolEntry + IMAGE_SIZEOF_SYMBOL);
    }

} /* WstGetSymbols () */
#endif





/***********************  W s t D l l C l e a n u p s  ***********************
 *
 *  WstDllCleanups () -
 *              Dumps the end data, closes all semaphores and events, and
 *              closes DUMP, CLEAR & PAUSE thread handles.
 *
 *  ENTRY   -none-
 *
 *  EXIT    -none-
 *
 *  RETURN  -none-
 *
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

void WstDllCleanups ()
{
    NTSTATUS  Status;
    int       i;


    if (WstState != NOT_STARTED) {
        WstState = STOPPED;

        IdPrint(("WST:  WstDllCleanups() - Outputting data...\n"));   // mdg 98/3

        if (ulBitCount != 0L) {
            ulSnaps++;
        }

        //
        // Get the GLOBAL semaphore.. (valid accross all process contexts)
        //
        Status = NtWaitForSingleObject (hGlobalSem, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllCleanups() - "
                      "ERROR - Wait for GLOBAL semaphore failed - 0x%lx\n",
                      Status));
        }
        for (i=0; i<iImgCnt; i++) {
            if (aImg[i].iSymCnt > 1) {   // Don't dump modules w/o symbols (the 1 is UNKNOWN) mdg 98/4
                WstClearBitStrings (&aImg[i]);
                WstRotateWsiMem (&aImg[i]);
                WstDumpData (&aImg[i]);
                WstWriteTmiFile (&aImg[i]);
            }
        }
        //
        // Release the GLOBAL semaphore so other processes can dump data
        //
        Status = NtReleaseSemaphore (hGlobalSem, 1, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDllCleanups() - "
                      "Error releasing GLOBAL semaphore - 0x%lx\n", Status));
        }

        IdPrint(("WST:  WstDllCleanups() - ...Done.\n"));
    }

    if (fInThread) {
        (*pulShared)--;
        fInThread = FALSE;
        if ( (int)*pulShared <= 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDllCleanups() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n", Status));
            }
        }
    }


    // Unmap and close shared block section
    //
    Status = NtUnmapViewOfSection (NtCurrentProcess(), (PVOID)pulShared);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtUnmapViewOfSection() - 0x%lx\n", Status));
    }

    Status = NtClose(hSharedSec);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtClose() - 0x%lx\n", Status));
    }

    // Unmap and close WSP section
    //
    Status = NtUnmapViewOfSection (NtCurrentProcess(), (PVOID)aImg[0].pWsp);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtUnmapViewOfSection() - 0x%lx\n", Status));
    }

    Status = NtClose(hWspSec);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - NtClose() - 0x%lx\n", Status));
    }
    // Free private heap
    //
    if (NULL != hWstHeap) {
        if (!HeapDestroy( hWstHeap )) { // Eliminate private heap & allocations
            KdPrint (("WST:  WstDllCleanups() -"
                      "ERROR - HeapDestroy() - 0x%lx\n", GetLastError()));
        }
    }

    // Close GLOBAL semaphore
    //
    Status = NtClose (hGlobalSem);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - Could not close the GLOBAL semaphore - 0x%lx\n",
                  Status));
    }

    //
    // Close LOCAL semaphore
    //
    Status = NtClose (hLocalSem);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDllCleanups() - "
                  "ERROR - Could not close the LOCAL semaphore - 0x%lx\n",
                  Status));
    }

    if (fPatchImage) {
        //
        // Close all events
        //
        NtClose (hDoneEvent);
        NtClose (hDumpEvent);
        NtClose (hClearEvent);
        NtClose (hPauseEvent);

        //
        // Close thread handles - threads are terminated during DLL detaching
        // process.
        //
        CloseHandle (hDumpThread);
        CloseHandle (hClearThread);
        CloseHandle (hPauseThread);

    }


} /* WstDllCleanups () */





/*******************  W s t A c c e s s X c p t F i l t e r  ******************
 *
 *  WstAccessXcptFilter (ulXcptNo, pXcptInfoPtr) -
 *              Commits COMMIT_SIZE  more pages of memory if exception is access
 *          violation.
 *
 *  ENTRY   ulXcptNo - exception number
 *              pXcptInfoPtr - exception report record info pointer
 *
 *  EXIT    -none-
 *
 *  RETURN  EXCEPTIONR_CONTINUE_EXECUTION : if access violation exception
 *                      and mem committed successfully
 *              EXCEPTION_CONTINUE_SEARCH : if non-access violation exception
 *                      or cannot commit more memory
 *  WARNING:
 *              -none-
 *
 *  COMMENT:
 *              -none-
 *
 */

INT WstAccessXcptFilter (ULONG ulXcptNo, PEXCEPTION_POINTERS pXcptPtr)
{
    NTSTATUS  Status;
    SIZE_T    ulSize = COMMIT_SIZE;
    PVOID     pvMem = (PVOID)pXcptPtr->ExceptionRecord->ExceptionInformation[1];


    if (ulXcptNo != EXCEPTION_ACCESS_VIOLATION) {
        return (EXCEPTION_CONTINUE_SEARCH);
    } else {
        Status = NtAllocateVirtualMemory (NtCurrentProcess(),
                                          &pvMem,
                                          0L,
                                          &ulSize,
                                          MEM_COMMIT,
                                          PAGE_READWRITE);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstAccessXcptFilter() - "
                      "Error committing more memory @ 0x%08lx - 0x%08lx "
                      "- TEB=0x%08lx\n", pvMem, Status, NtCurrentTeb()));
            return (EXCEPTION_CONTINUE_SEARCH);
        } else {
            SdPrint (("WST:  WstAccessXcptFilter() - "
                      "Committed %d more pages @ 0x%08lx - TEB=0x%08lx\n",
                      COMMIT_SIZE/PAGE_SIZE, pvMem, NtCurrentTeb()));
        }

        return (EXCEPTION_CONTINUE_EXECUTION);
    }

} /* WstAccessXcptFilter () */





/*****************************************************************************/
/*******  S O R T / S E A R C H   U T I L I T Y   F U N C T I O N S  *********/
/*****************************************************************************/


/*************************  W s t C o m p a r e  *****************************
 *
 *   Function:  WstCompare(PVOID val1,PVOID val2)
 *
 *   Purpose:   Compare values for qsort
 *
 *
 *   Parameters: PVOID
 *
 *   Returns:   -1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:   8-3-92  Marklea - created
 *
 */

int WstCompare (PWSP val1, PWSP val2)
{
    return (val1->ulFuncAddr < val2->ulFuncAddr ? -1:
            val1->ulFuncAddr == val2->ulFuncAddr ? 0:
            1);

} /* WstComapre () */





/***********************  W s t B C o m p a r e ********************************
 *
 *   Function:  WstBCompare(PDWORD pdwVal1, PVOID val2)
 *
 *   Purpose:   Compare values for Binary search
 *
 *
 *   Parameters: PVOID
 *
 *   Returns:   -1 if val1 < val2
 *    1 if val1 > val2
 *    0 if val1 == val2
 *
 *   History:   8-3-92  Marklea - created
 *
 */

int WstBCompare (DWORD_PTR *pdwVal1, PWSP val2)
{
#if  defined(_X86_)
    return (*pdwVal1 < val2->ulFuncAddr ? -1:
            *pdwVal1 == val2->ulFuncAddr ? 0:
            1);
#elif defined(ALPHA) || defined(IA64) || defined(_AMD64_)
    int dwCompareCode = 0;

    if (*pdwVal1 < val2->ulFuncAddr) {
        dwCompareCode = -1;
    } else if (*pdwVal1 >= val2->ulFuncAddr + val2->ulCodeLength) {
        dwCompareCode = 1;
    }
    return (dwCompareCode);
#endif

} /* WstBCompare () */




/***********************  W s t S o r t **************************************
 *
 *   Function:  WstSort(WSP wsp[], INT iLeft, INT iRight)
 *
 *   Purpose:   Sort WSP array for binary search
 *
 *
 *   Parameters: wsp[]  Pointer to WSP array
 *   iLeft   Left most index value for array
 *   iRight  Rightmost index value for array
 *
 *   Returns:   NONE
 *
 *   History:   8-4-92  Marklea - created
 *
 */

void WstSort (WSP wsp[], INT iLeft, INT iRight)
{
    INT     i, iLast;


    if (iLeft >= iRight) {
        return;
    }


    WstSwap(wsp, iLeft, (iLeft + iRight)/2);

    iLast = iLeft;

    for (i=iLeft+1; i <= iRight ; i++ ) {
        if (WstCompare(&wsp[i], &wsp[iLeft]) < 0) {
            if (!wsp[i].ulFuncAddr) {
                SdPrint(("WST:  WstSort() - Error in symbol list ulFuncAddr: "
                         "0x%lx [%d]\n", wsp[i].ulFuncAddr, i));
            }
            WstSwap(wsp, ++iLast, i);
        }
    }

    WstSwap(wsp, iLeft, iLast);
    WstSort(wsp, iLeft, iLast-1);
    WstSort(wsp, iLast+1, iRight);

} /* WstSort () */





/***********************  W s t S w a p **************************************
 *
 *   Function:  WstSwap(WSP wsp[], INT i, INT j)
 *
 *   Purpose:   Helper function for WstSort to swap WSP array values
 *
 *
 *   Parameters: wsp[]  Pointer to WSP array
 *   i  index value to swap to
 *   i  index value to swap from
 *
 *   Returns:   NONE
 *
 *   History:   8-4-92  Marklea - created
 *
 */

void WstSwap (WSP wsp[], INT i, INT j)
{
    WSP wspTmp;


    wspTmp = wsp[i];
    wsp[i] = wsp[j];
    wsp[j] = wspTmp;

} /* WstSwap () */





/***********************  W s t B S e a r c h *******************************
 *
 *   Function:  WstBSearch(DWORD dwAddr, WSP wspCur[], INT n)
 *
 *   Purpose:   Binary search function for finding a match in the WSP array
 *
 *
 *   Parameters: dwAddr Address of calling function
 *   wspCur[]Pointer to WSP containg value to match with dwAddr
 *   n  Number of elements in WSP array
 *
 *   Returns:   PWSP    Pointer to matching WSP
 *
 *   History:   8-5-92  Marklea - created
 *
 */

PWSP WstBSearch (DWORD_PTR dwAddr, WSP wspCur[], INT n)
{
    int  i;
    ULONG   ulHigh = n;
    ULONG   ulLow  = 0;
    ULONG   ulMid;

    while (ulLow < ulHigh) {
        ulMid = ulLow + (ulHigh - ulLow) /2;
        if ((i = WstBCompare(&dwAddr, &wspCur[ulMid])) < 0) {
            ulHigh = ulMid;
        } else if (i > 0) {
            ulLow = ulMid + 1;
        } else {
            return (&wspCur[ulMid]);
        }
    }

    return (NULL);

} /* WstBSearch () */




/**************************  W s t D u m p t h r e a d  ***********************
 *
 *              WstDumpThread (pvArg) -
 *              This routine is executed as the DUMP notification thread.
 *              It will wait on an event before calling the dump routine.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *              RETURN  0
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *                              Leaves profiling turned off.
 *
 */

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)                   // Not all control paths return (due to infinite loop)
#endif

DWORD WstDumpThread (PVOID pvArg)
{
    NTSTATUS  Status;
    int       i;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstDumpThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the DUMP event..
        //
        Status = NtWaitForSingleObject (hDumpEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDumpThread() - "
                      "ERROR - Wait for DUMP event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstDumpThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;
        if (WstState != NOT_STARTED) {

            IdPrint (("WST:  Profiling stopped & DUMPing data... \n"));

            // Stop profiling
            //
            WstState = NOT_STARTED;

            // Dump the data
            //
            if (ulBitCount != 0L) {
                ulSnaps++;
            }

            //
            // Get the GLOBAL semaphore.. (valid accross all process contexts)
            //
            Status = NtWaitForSingleObject (hGlobalSem, FALSE, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "ERROR - Wait for GLOBAL semaphore failed - 0x%lx\n",
                          Status));
            }
            for (i=0; i<iImgCnt; i++) {
                if (aImg[i].iSymCnt > 1) {   // Don't dump modules w/o symbols (the 1 is UNKNOWN) mdg 98/4
                    WstClearBitStrings (&aImg[i]);
                    WstRotateWsiMem (&aImg[i]);
                    WstDumpData (&aImg[i]);
                    WstWriteTmiFile (&aImg[i]);
                }
            }
            //
            // Release the GLOBAL semaphore so other processes can dump data
            //
            Status = NtReleaseSemaphore (hGlobalSem, 1, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "Error releasing GLOBAL semaphore - 0x%lx\n", Status));
            }

            IdPrint (("WST:  ...data DUMPed & profiling stopped.\n"));
        }

        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstDumpThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstDumpThread () */



/************************  W s t C l e a r T h r e a d  ***********************
 *
 *              WstClearThread (hNotifyEvent) -
 *              This routine is executed as the CLEAR notification thread.
 *                              It will wait on an event before calling the clear routine
 *                              and restarting profiling.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

DWORD WstClearThread (PVOID pvArg)
{
    NTSTATUS  Status;
    int       i;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstClearThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the CLEAR event..
        //
        Status = NtWaitForSingleObject (hClearEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstClearThread() - "
                      "Wait for CLEAR event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstClearThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;

        IdPrint (("WST:  Profiling stopped & CLEARing data...\n"));

        // Stop profiling while clearing data
        //
        WstState = STOPPED;

        // Clear WST info
        //
        ulBitCount = 0L;
        ulSnaps = 0L;

        for (i=0; i<iImgCnt; i++) {
            aImg[i].pulWsiNxt = aImg[i].pulWsi;
            RtlZeroMemory (aImg[i].pulWsi,
                           aImg[i].iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));
            RtlZeroMemory (aImg[i].pulWsp,
                           aImg[i].iSymCnt * ulMaxSnapULONGs * sizeof(ULONG));
        }
        NtQueryPerformanceCounter (&liStart, NULL);

        // Resume profiling
        //
        WstState = STARTED;

        IdPrint (("WST:  ...data is CLEARed & profiling restarted.\n"));
        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST:  WstClearThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstClearThread () */


/************************  W s t P a u s e T h r e a d  ***********************
 *
 *              WstPauseThread (hNotifyEvent) -
 *                              This routine is executed as the PAUSE notification thread.
 *                              It will wait on an event before pausing the profiling.
 *
 *              ENTRY   pvArg - thread's single argument
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

DWORD WstPauseThread (PVOID pvArg)
{
    NTSTATUS  Status;


    pvArg;   // prevent compiler warnings


    SdPrint (("WST:  WstPauseThread() started.. TEB=0x%lx\n", NtCurrentTeb()));

    for (;;) {
        //
        // Wait for the PASUE event..
        //
        Status = NtWaitForSingleObject (hPauseEvent, FALSE, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstPauseThread() - "
                      "Wait for PAUSE event failed - 0x%lx\n", Status));
        }
        Status = NtResetEvent (hDoneEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            KdPrint (("WST:  WstPauseThread() - "
                      "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
        }
        fInThread = TRUE;
        (*pulShared)++;
        if (WstState == STARTED) {
            //
            // Stop profiling
            //
            WstState = STOPPED;

            IdPrint (("WST:  Profiling stopped.\n"));
        }

        (*pulShared)--;
        if ( *pulShared == 0L ) {
            Status = NtSetEvent (hDoneEvent, NULL);
            if (!NT_SUCCESS(Status)) {
                KdPrint (("WST: WstPauseThread() - "
                          "ERROR - Setting DONE event failed - 0x%lx\n",
                          Status));
            }
        }

        fInThread = FALSE;
    }

    return 0;

} /* WstPauseThread () */


#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


/***********************  W s t D a t a O v e r F l o w  **********************
 *
 *              WstDataOverFlow () -
 *                              This routine is called upon lack of space for storing next
 *              time snap data.  It dumps and then clears the WST data.
 *
 *              ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              -none-
 *
 */

void WstDataOverFlow(void)
{
    NTSTATUS   Status;

    //
    // Dump data
    //
    Status = NtResetEvent (hDoneEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - "
                  "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
    }
    Status = NtPulseEvent (hDumpEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtPulseEvent() "
                  "failed for DUMP event - %lx\n", Status));
    }
    Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtWaitForSingleObject() "
                  "failed for DONE event - %lx\n", Status));
    }

    //
    // Clear data
    //
    Status = NtResetEvent (hDoneEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - "
                  "ERROR - Resetting DONE event failed - 0x%lx\n", Status));
    }
    Status = NtPulseEvent (hClearEvent, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtPulseEvent() "
                  "failed for CLEAR event - %lx\n", Status));
    }
    //
    // Wait for the DONE event..
    //
    Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstDataOverFlow() - NtWaitForSingleObject() "
                  "failed for DONE event - %lx\n", Status));
    }
} /* WstDataOverFlow() */



#ifdef BATCHING

BOOL WstOpenBatchFile(VOID)
{
    NTSTATUS             Status;
    ANSI_STRING              ObjName;
    UNICODE_STRING           UnicodeName;
    OBJECT_ATTRIBUTES        ObjAttributes;
    IO_STATUS_BLOCK          iostatus;
    RtlInitString(&ObjName, "\\Device\\Harddisk0\\Partition1\\wst\\BATCH.TXT");
    Status = RtlAnsiStringToUnicodeString(&UnicodeName, &ObjName, TRUE);

    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstOpenBatchFile() - "
                  "RtlAnsiStringToUnicodeString() failed - 0x%lx\n", Status));
        return (FALSE);
    }

    InitializeObjectAttributes (&ObjAttributes,
                                &UnicodeName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                &SecDescriptor);

    Status = NtCreateFile(&hBatchFile,
                          GENERIC_WRITE | SYNCHRONIZE,      // Desired access
                          &ObjAttributes,               // Object attributes
                          &iostatus,                        // Completion status
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_WRITE,
                          FILE_OVERWRITE_IF,
                          FILE_SEQUENTIAL_ONLY |        // Open option
                          FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0L);

    RtlFreeUnicodeString (&UnicodeName);   // HWC 11/93
    if (!NT_SUCCESS(Status)) {
        KdPrint (("WST:  WstOpenBatchFile() - "
                  "NtCreateFile() failed - 0x%lx\n", Status));
        return (FALSE);
    }
    return(TRUE);

} /* WstOpenBatchFile () */

#endif


/*******************  S e t S y m b o l S e a r c h P a t h  ******************
 *
 *      SetSymbolSearchPath ()
 *              Return complete search path for symbols files (.dbg)
 *
 *      ENTRY   -none-
 *
 *      EXIT    -none-
 *
 *      RETURN  -none-
 *
 *      WARNING:
 *              -none-
 *
 *      COMMENT:
 *              "lpSymbolSearchPath" global LPSTR variable will point to the
 *              search path.
 */
#define FilePathLen                256

void SetSymbolSearchPath (void)
{
    CHAR  SymPath[FilePathLen];
    CHAR  AltSymPath[FilePathLen];
    CHAR  SysRootPath[FilePathLen];
    LPSTR lpSymPathEnv=SymPath;
    LPSTR lpAltSymPathEnv=AltSymPath;
    LPSTR lpSystemRootEnv=SysRootPath;
    ULONG cbSymPath;
    DWORD dw;
    HANDLE hMemoryHandle;

    SymPath[0] = AltSymPath[0] = SysRootPath[0] = '\0';

    cbSymPath = 18;
    if (GetEnvironmentVariable("_NT_SYMBOL_PATH", SymPath, sizeof(SymPath))) {
        cbSymPath += strlen(lpSymPathEnv) + 1;
    }

    if (GetEnvironmentVariable("_NT_ALT_SYMBOL_PATH", AltSymPath, sizeof(AltSymPath))) {
        cbSymPath += strlen(lpAltSymPathEnv) + 1;
    }

    if (GetEnvironmentVariable("SystemRoot", SysRootPath, sizeof(SysRootPath))) {
        cbSymPath += strlen(lpSystemRootEnv) + 1;
    }

    hMemoryHandle = GlobalAlloc (GHND, cbSymPath+1);
    if (!hMemoryHandle) {
        return;
    }

    lpSymbolSearchPath = GlobalLock (hMemoryHandle);
    if (!lpSymbolSearchPath) {
        GlobalFree( hMemoryHandle ); // mdg 98/3
        return;
    }


    strcat(lpSymbolSearchPath,".");

    if (*lpAltSymPathEnv) {
        dw = GetFileAttributes(lpAltSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpAltSymPathEnv);
        }
    }
    if (*lpSymPathEnv) {
        dw = GetFileAttributes(lpSymPathEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpSymPathEnv);
        }
    }
    if (*lpSystemRootEnv) {
        dw = GetFileAttributes(lpSystemRootEnv);
        if ( dw != 0xffffffff && dw & FILE_ATTRIBUTE_DIRECTORY ) {
            strcat(lpSymbolSearchPath,";");
            strcat(lpSymbolSearchPath,lpSystemRootEnv);
        }
    }

} /* SetSymbolSearchPath () */

#ifdef i386

//+-------------------------------------------------------------------------
//
//  Function:    SaveAllRegs
//
//  Synopsis:    Save all regs.
//
//  Arguments:   nothing
//
//  Returns:     none
//
//--------------------------------------------------------------------------

Naked void SaveAllRegs(void)
{
    _asm
    {
        push   ebp
        mov    ebp,esp         ; Remember where we are during this stuff
        ; ebp = Original esp - 4

                push   eax             ; Save all regs that we think we might
        push   ebx             ; destroy
        push   ecx
        push   edx
        push   esi
        push   edi
        pushfd
        push   ds
        push   es
        push   ss
        push   fs
        push   gs

        mov    eax,[ebp+4]     ; Grab Return Address
        push   eax             ; Put Return Address on Stack so we can RET

        mov    ebp,[ebp+0]     ; Restore original ebp

        //
        // This is how the stack looks like before the RET statement
        //
        //        +-----------+
        //        |  Ret Addr |         + 3ch       CurrentEBP + 4
        //        +-----------+
        //        |  Org ebp  |         + 38h       CurrentEBP + 0
        //        +-----------+
        //        |    eax    |         + 34h
        //        +-----------+
        //        |    ebx    |         + 30h
        //        +-----------+
        //        |    ecx    |         + 2ch
        //        +-----------+
        //        |    edx    |         + 24h
        //        +-----------+
        //        |    esi    |         + 20h
        //        +-----------+
        //        |    edi    |         + 1ch
        //        +-----------+
        //        |   eflags  |         + 18h
        //        +-----------+
        //        |     ds    |         + 14h
        //        +-----------+
        //        |     es    |         + 10h
        //        +-----------+
        //        |     ss    |         + ch
        //        +-----------+
        //        |     fs    |         + 8h
        //        +-----------+
        //        |     gs    |         + 4h
        //        +-----------+
        //        |  Ret Addr |     ESP + 0h
        //        +-----------+

        ret
    }
}


//+-------------------------------------------------------------------------
//
//  Function:    RestoreAllRegs
//
//  Synopsis:    restore all regs
//
//  Arguments:   nothing
//
//  Returns:     none
//
//--------------------------------------------------------------------------

Naked void RestoreAllRegs(void)
{
    _asm
    {
        //
        // This is how the stack looks like upon entering this routine
        //
        //        +-----------+
        //        |  Ret Addr |         + 38h [ RetAddr for SaveAllRegs() ]
        //        +-----------+
        //        |  Org ebp  |         + 34h
        //        +-----------+
        //        |    eax    |         + 30h
        //        +-----------+
        //        |    ebx    |         + 2Ch
        //        +-----------+
        //        |    ecx    |         + 28h
        //        +-----------+
        //        |    edx    |         + 24h
        //        +-----------+
        //        |    esi    |         + 20h
        //        +-----------+
        //        |    edi    |         + 1Ch
        //        +-----------+
        //        |   eflags  |         + 18h
        //        +-----------+
        //        |     ds    |         + 14h
        //        +-----------+
        //        |     es    |         + 10h
        //        +-----------+
        //        |     ss    |         + Ch
        //        +-----------+
        //        |     fs    |         + 8h
        //        +-----------+
        //        |     gs    |         + 4h
        //        +-----------+
        //        |  Ret EIP  |     ESP + 0h  [ RetAddr for RestoreAllRegs() ]
        //        +-----------+
        //


        push   ebp             ; Save a temporary copy of original BP
        mov    ebp,esp         ; BP = Original SP + 4

                                      //
                                      // This is how the stack looks like NOW!
                                      //
                                      //        +-----------+
                                      //        |  Ret Addr |         + 3Ch [ RetAddr for SaveAllRegs() ]
                                      //        +-----------+
                                      //        |  Org ebp  |         + 38h [ EBP before SaveAllRegs()  ]
                                      //        +-----------+
                                      //        |    eax    |         + 34h
                                      //        +-----------+
                                      //        |    ebx    |         + 30h
                                      //        +-----------+
                                      //        |    ecx    |         + 2Ch
                                      //        +-----------+
                                      //        |    edx    |         + 28h
                                      //        +-----------+
                                      //        |    esi    |         + 24h
                                      //        +-----------+
                                      //        |    edi    |         + 20h
                                      //        +-----------+
                                      //        |   eflags  |         + 1Ch
                                      //        +-----------+
                                      //        |     ds    |         + 18h
                                      //        +-----------+
                                      //        |     es    |         + 14h
                                      //        +-----------+
                                      //        |     ss    |         + 10h
                                      //        +-----------+
                                      //        |     fs    |         + Ch
                                      //        +-----------+
                                      //        |     gs    |         + 8h
                                      //        +-----------+
                                      //        |  Ret EIP  |     ESP + 4h   [ RetAddr for RestoreAllRegs() ]
                                      //        +-----------+
                                      //        |    EBP    |     ESP + 0h  or EBP + 0h
                                      //        +-----------+
                                      //

                                      pop    eax             ; Get Original EBP
        mov    [ebp+38h],eax   ; Put it in the original EBP place
        ; This EBP is the EBP before calling
        ;  RestoreAllRegs()
        pop    eax             ; Get ret address forRestoreAllRegs ()
            mov    [ebp+3Ch],eax   ; Put Return Address on Stack

        pop    gs              ; Restore all regs
        pop    fs
        pop    ss
        pop    es
        pop    ds
        popfd
        pop    edi
        pop    esi
        pop    edx
        pop    ecx
        pop    ebx
        pop    eax
        pop    ebp

        ret
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wsfslib\wsfslib.h ===
/*
 * Module Name:  WSFSLIB.H
 *
 * Description:
 *
 * Working set tuner include file for WSFSLIB library functions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987-1998
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/26/90	- created			
 * 04/16/98 - QFE DerrickG (mdg):
 *            - Removed WsGetWSDIR(), change return from WsTMIReadRec()
 *						
 */


/*
 *	Constant definitions.
 */



/*
 *	Function prototypes.
 */
typedef enum   // Progress indicator for console functions
{
   WSINDF_NEW,       // Start new indicator: value = 100% limit
   WSINDF_PROGRESS,  // Set progress of current indicator; value = progress toward limit
   WSINDF_FINISH     // Mark indicator as finished; value ignored
}  WsIndicator_e;
VOID FAR PASCAL WsProgress( WsIndicator_e eFunc, const char *pszLbl, unsigned long nVal );
extern BOOL fWsIndicator;
#define WsIndicator( x, y, z )   if (fWsIndicator) WsProgress( x, y, z )

typedef int (*PFN)(UINT, INT, UINT, ULONG, LPSTR);

USHORT FAR PASCAL 	WsWSPOpen( PSZ, FILE **, PFN, wsphdr_t *, INT, INT );
ULONG  FAR PASCAL 	WsTMIOpen( PSZ, FILE **, PFN, USHORT, PCHAR );
ULONG  FAR PASCAL 	WsTMIReadRec( PSZ *, PULONG, PULONG, FILE *, PFN, PCHAR );  // mdg 98/4
LPVOID APIENTRY 	AllocAndLockMem(DWORD cbMem, HGLOBAL *hMem);
BOOL   APIENTRY 	UnlockAndFreeMem(HGLOBAL hMem);
void ConvertAppToOem( unsigned argc, char* argv[] );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstcat\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
	unsigned short	dtqo_resv;	 /* Reserved			*/
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clSegSize;	 /* Time Segment size*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            |
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module
            USHORT  tmihdr_usID;           // Module identifier
            CHAR    tmihdr_resv[30];       // Reserved
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnBit;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here
};

typedef struct tmirec_s tmirec_t;

typedef struct tagWSPhdr{
    char    chFileSignature[4];
    ULONG   ulTimeStamp;
    ULONG   ulApiCount;
    USHORT  usId;
    ULONG   ulSetSymbols;  // mdg 4/98
    ULONG   ulModNameLen;
    ULONG   ulSegSize;
    ULONG   ulOffset;
    ULONG   ulSnaps;
}WSPHDR;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdll\wstexp.h ===
/*** WSTEXP.H - Prototypes for WST's exported routines.
 *
 *
 * Title:
 *	wstexp.h - used by WST.c
 *
 *	Copyright (c) 1992, Microsoft Corporation.
 *      Reza Baghai.
 *
 *
 * Modification History:
 *	92.07.29  RezaB -- Created
 *
 */

void  __cdecl _mcount  (void);
void  __cdecl _penter  (void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wsfslib\wsfslib.c ===
/*
 * Module Name:  WSFSLIB.C
 *								
 * Library/DLL:  Common library functions for handling working set tuner files.
 *								
 *								
 * Description:							
 *
 * Library routines called by the working set tuner programs to open and
 * read working set tuner files.  These functions may be useful to ISVs, etc.,
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/26/90	- created			
 *						
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include <wserror.h>
#include <wsdata.h>
#include <wsfslib.h>

#define MAXLINE 128


BOOL fWsIndicator = FALSE;

/*
 *	    Function declarations and prototypes.
 */


/*
 *			
 ***EP WsWSPOpen
 *					
 * Effects:							
 *								
 * Opens a WSP file, and reads and validates the file header.
 *
 * Returns:							
 *	
 *	Returns 0.  If an error is encountered, exits with ERROR via an
 *	indirect call through pfnExit.
 */

USHORT FAR PASCAL
WsWSPOpen( PSZ pszFileName, FILE **phFile, PFN pfnExit, wsphdr_t *pWspHdr,
		INT iExitCode, INT iOpenPrintCode )
{
	ULONG	rc = NO_ERROR;
	INT		iRet = 0;
	ULONG	cbRead = 0;
	size_t	stRead = 0;

	/* Open module's input WSP file. */

	if ((*phFile = fopen(pszFileName, "rb")) == NULL)
	{
		iRet = (*pfnExit)(iExitCode, iOpenPrintCode, MSG_FILE_OPEN, rc,
				pszFileName);
		return((USHORT)iRet);
	}



	/* Read WSP file header. */
	stRead = fread((PVOID) pWspHdr, (ULONG) sizeof(*pWspHdr),1, *phFile);
	if(!stRead)
	{
		iRet = (*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_OPEN, rc,
				pszFileName);
		return((USHORT)iRet);
	}


	/* Read module pathname (directly follows file header). */

#ifdef DEBUG
	printf("WspHdr (%s): ulTime 0x%lx, ulSnaps 0x%lx, OffBits 0x%lx\n",
//			szModPath, pWspHdr->wsphdr_ulTimeStamp,
			pszFileName, pWspHdr->wsphdr_ulTimeStamp, // mdg 4/98
			pWspHdr->wsphdr_ulSnaps, pWspHdr->wsphdr_ulOffBits);
#endif /* DEBUG */

	/* Validate the WSP file header. */
	if (_strcmpi(pWspHdr->wsphdr_chSignature, "WSP"))
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1, pszFileName);

	return(NO_ERROR);
}


/*
 *			
 ***EP WsTMIOpen
 *					
 * Effects:							
 *								
 * Opens a TMI file, and reads and validates the file header.
 *
 * Returns:							
 *	
 *	Returns the number of records in the TMI file.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

ULONG FAR PASCAL
WsTMIOpen( PSZ pszFileName, FILE **phFile, PFN pfnExit, USHORT usId, PCHAR pch)
{
	//ULONG	ulTmp;
	ULONG	rc = NO_ERROR;
	ULONG	cbRead = 0;
	ULONG	cFxns = 0;
	CHAR	szLineTMI[MAXLINE];	// Line from TMI file
	CHAR	szTDFID[8];		// TDF Identifier string
	ULONG	ulTDFID = 0;		// TDF Identifier

	/* Open TMI file (contains function names, etc., in ASCII). */

	if ((*phFile = fopen(pszFileName, "rt")) == NULL)
	{
		(*pfnExit)(NOEXIT, PRINT_MSG, MSG_FILE_OPEN, rc,
			pszFileName);
		return(MSG_FILE_OPEN);
	}

	/* Validate TMI file. */
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
							// # fxns
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
	szLineTMI[strlen(szLineTMI) - 1] = '\0';
	if (sscanf(szLineTMI,"/* Total Symbols= %u */", &cFxns) != 1){
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	}
							// MODNAME
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
							// MAJOR
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
							// TDFID
	if (fgets(szLineTMI, MAXLINE, *phFile) == NULL)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	if (sscanf(szLineTMI, "TDFID   = %s", szTDFID) != 1)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
				pszFileName);
	ulTDFID = strtoul(szTDFID, (char **) 0, 0);

	/* Check identifier field */

	if (ulTDFID != (ULONG) usId)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1,
				pszFileName);

	return(cFxns);
}


/*
 *			
 ***EP WsTMIReadRec
 *					
 * Effects:							
 *								
 * Reads a record from a TMI file, including the variable length function
 * name.
 *
 * Returns:							
 *	
 *	Function size, in bytes, from this record.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

ULONG FAR PASCAL
WsTMIReadRec( PSZ *ppszFxnName, PULONG pulFxnIndex, PULONG pulFxnAddr,
			  FILE *hFile, PFN pfnExit, PCHAR pch)
{
	ULONG	rc;
	ULONG	cbFxn;
	UINT	uiFxnAddrObj;	// object portion of function address
	ULONG	cbFxnName;		// size in bytes of function name
	// Read in function name, etc.

	rc = fscanf(hFile, "%ld %x:%lx 0x%lx %ul",  // mdg 98/4
				pulFxnIndex, &uiFxnAddrObj, pulFxnAddr, &cbFxn,
				&cbFxnName);

	if (rc != 5)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc, "TMI file");

   *ppszFxnName = malloc( 1 + cbFxnName );   // Allocate space for function name
   if (*ppszFxnName == NULL)  // Abort if no mem
		(*pfnExit)(ERROR, PRINT_MSG, MSG_NO_MEM, 1 + cbFxnName, "TMI file");
   rc = fgetc( hFile ); // Skip leading blank space
   fgets( *ppszFxnName, cbFxnName + 1, hFile );
   rc = fgetc( hFile );
	if (rc != '\n' || strlen( *ppszFxnName ) != cbFxnName)
		(*pfnExit)(ERROR, PRINT_MSG, MSG_FILE_READ, rc, "TMI file");

   return(cbFxn);
}

LPVOID APIENTRY AllocAndLockMem(DWORD cbMem, HGLOBAL *hMem)
{

	//
	// Changed to GHND from GMEM_MOVABLE
	//
	*hMem = GlobalAlloc(GHND, cbMem);

	if(!*hMem) {
		return(NULL);
	}

	return(GlobalLock(*hMem));
}

BOOL APIENTRY  UnlockAndFreeMem(HGLOBAL hMem)
{
	BOOL fRet;

	fRet = GlobalUnlock(hMem);
	if (fRet) {
		return(fRet);
	}

	if (!GlobalFree(hMem)) {
		return(FALSE);
	}

	return(TRUE);

}

void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;

    for( i=0; i<argc; i++ ) {
        CharToOem( argv[i], argv[i] );
    }
    SetFileApisToOEM();
}


/*
 *			
 ***EP WsIndicator
 *					
 * Effects:							
 *								
 * Displays a progress indicator on the console. Doesn't use stdout which may be
 * redirected.
 *					
 * Parameters:							
 *								
 * eFunc             Description                         nVal
 * WSINDF_NEW,       Start new indicator                 Value of 100% limit
 * WSINDF_PROGRESS,  Set progress of current indicator   Value of progress toward limit
 * WSINDF_FINISH     Mark indicator as finished          -ignored-
 * -invalid-         Do nothing
 *
 * In all valid cases, pszLabel sets string to display before indicator. If NULL,
 * uses last set string.
 *
 * Returns:							
 *	
 *	Function size, in bytes, from this record.  If an error is
 *	encountered, exits with ERROR via an indirect call through pfnExit.
 */

VOID FAR PASCAL
WsProgress( WsIndicator_e eFunc, const char *pszLbl, unsigned long nVal )
{
   static unsigned long
                     nLimit = 0, nCurrent = 0;
   static const char *
                     pszLabel = "";
   static unsigned   nLabelLen = 0;
   static char       bStarted = FALSE;
   static unsigned   nLastLen = 0;
   static HANDLE     hConsole = NULL;
   DWORD             pnChars;

   switch (eFunc)
   {
   case WSINDF_NEW:
      if (bStarted)
         WsIndicator( WSINDF_FINISH, NULL, 0 );
      bStarted = TRUE;
      nLimit = nVal;
      nCurrent = 0;
      nLastLen = ~0; // Force redraw
      WsIndicator ( WSINDF_PROGRESS, pszLbl, 0 );
      break;

   case WSINDF_PROGRESS:
      if (!bStarted)
         break;
      if (pszLbl != NULL)
      {
         pszLabel = pszLbl;
         nLabelLen = strlen( pszLabel );
      }
      if (nVal > nCurrent) // Compare to current progress (ignore reverses)
         if (nVal <= nLimit)
            nCurrent = nVal;
         else
            nCurrent = nLimit;
      {                    // Calculate an indicator string and print it
         unsigned nLen = (unsigned) ((40.1 * (double)nCurrent) / nLimit);
         char *   pszBuf;

         if (nLastLen == nLen)   // Optimization - Don't redraw if result would be the same
         {
            if (pszLbl == NULL)
               break;
         }
         else
            nLastLen = nLen;
         if (hConsole == NULL)
         {
            hConsole = CreateFile( "CONOUT$", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL );
            if (hConsole == NULL)   // Couldn't get the console for some reason?
               break;
         }
         WriteConsole( hConsole, "\r", 1, &pnChars, NULL );
         WriteConsole( hConsole, pszLabel, nLabelLen, &pnChars, NULL );
         WriteConsole( hConsole, " ", 1, &pnChars, NULL );
         pszBuf = malloc( nLen + 1 );
         if (pszBuf == NULL)  // No memory? Oh, well...
            break;
         memset( pszBuf, '-', nLen );
         pszBuf[nLen] = '\0';
         WriteConsole( hConsole, pszBuf, nLen, &pnChars, NULL );
         free( pszBuf);
      }
      break;

   case WSINDF_FINISH:
      if (!bStarted)
         break;
      WsIndicator( WSINDF_PROGRESS, pszLbl, nLimit );
      if (hConsole != NULL)
      {
         WriteConsole( hConsole, "\n", 1, &pnChars, NULL );
         CloseHandle( hConsole );
         hConsole = NULL;
      }
      bStarted = FALSE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdll\wst.h ===
/*** WST.H - Public defines and structure definitions for WST tool.
 *
 *
 * Title:
 *	Working Set Tuner Data Collection Tool include file used by WST.c
 *
 *	Copyright (c) 1992, Microsoft Corporation.
 *      Reza Baghai.
 *
 *
 * Modification History:
 *	92.07.28  RezaB -- Created
 *
 */



/* * * * * * * *   C o m m o n   M i s c .   D e f i n e s   * * * * * * * */

#define Naked       _declspec (naked)    // For asm functions

#define  MEMSIZE	 		64*1024*1024	// 64 MB virtual memory for data -
											// initially RESERVED - will be
											// COMITTED as needed.
#define  MAX_IMAGES 	    200		 	    // Limit on num of modules in proc
#define  PAGE_SIZE	    	4096	 		// 4K pages
#define  PATCHFILESZ	    PAGE_SIZE	 	// WST.INI file maximum size
#define  COMMIT_SIZE	    96*PAGE_SIZE 	// Mem chunck to be commited
#define  TIMESEG			1000 		    // Default time seg size in milisecs
#define  NUM_ITERATIONS     1000 	 	 	// Number of iterations used to
											// calculate overheads
#define  UNKNOWN_SYM   		"_???"
#define  UNKNOWN_ADDR  		0xffffffff
#define  MAX_SNAPS_DFLT   		3200   // Default # snaps if not specified in WST.INI
#define  MAX_SNAPS_ENTRY   "MAXSNAPS=" // mdg 98/3
#define  FILENAMELENGTH     256
#define  WSTDLL 	    	"WST.DLL"
#define  CRTDLL 	    	"CRTDLL.DLL"
#define  KERNEL32 	    	"KERNEL32.DLL"
#define  PATCHEXELIST	    "[EXES]"
#define  PATCHIMPORTLIST    "[PATCH IMPORTS]"
#define  TIMEINTERVALIST    "[TIME INTERVAL]"
#define  GLOBALSEMNAME	    "\\BaseNamedObjects\\WSTGlobalSem"
#define  PATCHSECNAME	    "\\BaseNamedObjects\\WSTPatch"
#define  PROFOBJSNAME	    "\\BaseNamedObjects\\WSTObjs"
#define  WSTINIFILE	    	 "c:\\wst\\wst.ini"
#define  WSTROOT	    	    "c:\\wst\\"
#define  DONEEVENTNAME	    "\\BaseNamedObjects\\WSTDoneEvent"
#define  DUMPEVENTNAME	    "\\BaseNamedObjects\\WSTDumpEvent"
#define  CLEAREVENTNAME     "\\BaseNamedObjects\\WSTClearEvent"
#define  PAUSEEVENTNAME	    "\\BaseNamedObjects\\WSTPauseEvent"
#define  SHAREDNAME		    "\\BaseNamedObjects\\WSTSHARED"
#define  WSTUSAGE(x)		((ULONG_PTR)(x->Instrumentation[3]))



/* * * * * * * * * *  G l o b a l   D e c l a r a t i o n s  * * * * * * * * */

typedef enum {
    NOT_STARTED,
    STARTED,
	STOPPED,
} WSTSTATE;

typedef struct _wsp {
	PSTR	pszSymbol;				// Pointer to Symbol name
	ULONG_PTR	ulFuncAddr;				// Function address of symbol
	ULONG	ulCodeLength;			// Length of this symbols code
	ULONG	ulBitString;			// Bitstring for tuning.
} WSP;
typedef WSP * PWSP;

typedef struct _img {
	PSTR	pszName;			
	ULONG_PTR   ulCodeStart;
	ULONG_PTR   ulCodeEnd;
	PWSP    pWsp;
	int     iSymCnt;
	PULONG  pulWsi;
	PULONG  pulWsp;
	PULONG  pulWsiNxt;
	ULONG   ulSetSymbols;
	BOOL    fDumpAll;
} IMG;
typedef IMG * PIMG;


typedef struct tagWSPhdr{
    char    chFileSignature[4];
    ULONG   ulTimeStamp;
    ULONG   ulApiCount;
    USHORT  usId;
    ULONG   ulSetSymbols;
    ULONG   ulModNameLen;
    ULONG   ulSegSize;
    ULONG   ulOffset;
    ULONG   ulSnaps;
}WSPHDR;


/* * * *  E x t e r n a l   F u n c t i o n   D e c l a r a t i o n s  * * * */

extern void GdiGetCsInfo (PDWORD, PDWORD, PDWORD);
extern void GdiResetCsInfo (void);

#ifdef i386
extern void SaveAllRegs (void);
extern void RestoreAllRegs (void);
#endif

#define STUB_SIGNATURE     0xfefe55aa   // Mips Patch Stub signature
#define  CAIROCRT           "CAIROCRT.DLL"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdll\ia64\wstutl.s ===
//    TITLE("Wst Utility")
//++
//    Copyright (c) 1992-1994, Microsoft Corporation.
//
//    Description:
//        SaveAllRegs ()
//              - save all IA64 registers
//
//        RestoreAllRegs ()
//              - restore all IA64 registers
//
//
//--


#include "ksia64.h"

        PublicFunction(c_penter)

//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       SaveAllRegs(
//            IN  OUT PDWORDLONG   pSaveBuffer)
//
// Description:
//
//       This function saves the EM registers into the supplied buffer
//
// Input:
//
//       a0: pSaveBuffer - Pointer CONTEXT buffer where the registers should be
//                         saved.
//
// Output:
//
//       Stores the registers in the supplied buffer.
//
// Return value:
//
//       None
//
//
//
//--------------------------------------------------------------------

        LEAF_ENTRY(SaveAllRegs)


//
// Save all integer registers and flush the RSE
//

        .prologue
        .regstk     1, 10, 0, 0

        rbsp        = loc9
        rpfs        = loc8
        rbrp        = loc7
        rpr         = loc6
        runat       = loc4
        tmpbsp      = t20


        alloc       rpfs = ar.pfs, 1, 10, 0, 0
        add         loc0 = CxIntGp, a0
        add         loc1 = CxIntT8, a0
        ;;

        flushrs
        .save       ar.unat, loc4
        mov         runat = ar.unat
        mov         rpr = pr

        PROLOGUE_END

        .mem.offset 0,0
        st8.spill.nta [loc0] = gp, CxIntT0 - CxIntGp
        .mem.offset 0,8
        st8.spill.nta [loc1] = t8, CxIntT9 - CxIntT8
        add         loc2 = CxIntGp, a0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t0, CxIntT1 - CxIntT0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t9, CxIntT10 - CxIntT9
        shr         loc2 = loc2, 3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t1, CxIntS0 - CxIntT1
        .mem.offset 0,8
        st8.spill.nta [loc1] = t10, CxIntT11 - CxIntT10
        and         t0 = 0x3f, loc2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s0, CxIntS1 - CxIntS0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t11, CxIntT12 - CxIntT11
        cmp4.ge     pt1, pt0 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s1, CxIntS2 - CxIntS1
        .mem.offset 0,8
        st8.spill.nta [loc1] = t12, CxIntT13 - CxIntT12
 (pt1)  sub         t1 = 1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s2, CxIntS3 - CxIntS2
        .mem.offset 0,8
        st8.spill.nta [loc1] = t13, CxIntT14 - CxIntT13
 (pt0)  add         t1 = -1, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = s3, CxIntV0 - CxIntS3
        .mem.offset 0,8
        st8.spill.nta [loc1] = t14, CxIntT15 - CxIntT14
 (pt0)  sub         t8 = 65, t0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = v0, CxIntTeb - CxIntV0
        .mem.offset 0,8
        st8.spill.nta [loc1] = t15, CxIntT16 - CxIntT15
        nop.i       0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = teb, CxIntT2 - CxIntTeb
        .mem.offset 0,8
        st8.spill.nta [loc1] = t16, CxIntT17 - CxIntT16
        mov         rbrp = brp
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t2, CxIntT3 - CxIntT2
        .mem.offset 0,8
        st8.spill.nta [loc1] = t17, CxIntT18 - CxIntT17
        mov         t11 = bs0
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t3, CxIntSp - CxIntT3
        .mem.offset 0,8
        st8.spill.nta [loc1] = t18, CxIntT19 - CxIntT18
        mov         t12 = bs1
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = sp, CxIntT4 - CxIntSp
        .mem.offset 0,8
        st8.spill.nta [loc1] = t19, CxIntT20 - CxIntT19
        mov         t13 = bs2
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t4, CxIntT5 - CxIntT4
        .mem.offset 0,8
        st8.spill.nta [loc1] = t20, CxIntT21 - CxIntT20
        mov         t14 = bs3
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t5, CxIntT6 - CxIntT5
        .mem.offset 0,8
        st8.spill.nta [loc1] = t21, CxIntT22 - CxIntT21
        mov         t15 = bs4
        ;;

        .mem.offset 0,0
        st8.spill.nta [loc0] = t6, CxIntT7 - CxIntT6
        .mem.offset 0,8
        st8.spill.nta [loc1] = t22, CxPreds - CxIntT22
        mov         t16 = bt0
        ;;

        st8.spill.nta [loc0] = t7
        st8.nta     [loc1] = rpr, CxIntNats - CxPreds   // save predicates
        mov         t17 = bt1
        ;;

        mov         t9 = ar.unat
        mov         t4 = ar.fpsr
        add         loc2 = CxBrRp, a0
        ;;

        add         loc3 = CxBrS3, a0
  (pt1) shl         t9 = t9, t1
  (pt0) shr.u       t2 = t9, t1
        ;;

//
// Save branch registers.
//

        st8.nta     [loc2] = rbrp, CxBrS0 - CxBrRp  // save brp
        st8.nta     [loc3] = t14, CxBrS4 - CxBrS3   // save bs3
  (pt0) shl         t3 = t9, t8
        ;;

        st8.nta     [loc2] = t11, CxBrS1 - CxBrS0   // save bs0
        st8.nta     [loc3] = t15, CxBrT0 - CxBrS4   // save bs4
  (pt0) or          t9 = t2, t3
        ;;

        st8.nta     [loc2] = t12, CxBrS2 - CxBrS1   // save bs1
        st8.nta     [loc3] = t16, CxBrT1 - CxBrT0   // save bt0
        add         loc0 = CxStFPSR, a0
        ;;

        st8.nta     [loc2] = t13                    // save bs2
        st8.nta     [loc3] = t17                    // save bt1
        add         loc2 = CxStFSR, a0
        ;;

        st8.nta     [loc0] = t4                     // save fpsr
        st8.nta     [loc1] = t9                     // save nat bits
        add         loc1 = CxStFIR, a0
        ;;

        mov         t0 = ar.fsr
        mov         t1 = ar.fir
        mov         t2 = ar.fdr
        ;;

        st8.nta     [loc2] = t0, CxStFDR - CxStFSR
        st8.nta     [loc1] = t1
        ;;

        st8.nta     [loc2] = t2

        mov         rbsp = ar.bsp
        add         loc2 = CxFltS0, a0
        add         loc3 = CxFltS1, a0
        ;;

//
// Save floating status and floating registers f0 - f127.
//

        stf.spill.nta [loc2] = fs0, CxFltS2 - CxFltS0
        stf.spill.nta [loc3] = fs1, CxFltS3 - CxFltS1
        shr         t0 = rpfs, 7
        ;;

        stf.spill.nta [loc2] = fs2, CxFltT0 - CxFltS2
        stf.spill.nta [loc3] = fs3, CxFltT1 - CxFltS3
        and         t0 = 0x7f, t0
        ;;

        stf.spill.nta [loc2] = ft0, CxFltT2 - CxFltT0
        stf.spill.nta [loc3] = ft1, CxFltT3 - CxFltT1
        shr         t1 = rbsp, 3
        ;;

        stf.spill.nta [loc2] = ft2, CxFltT4 - CxFltT2
        stf.spill.nta [loc3] = ft3, CxFltT5 - CxFltT3
        and         t1 = 0x3f, t1
        ;;

        stf.spill.nta [loc2] = ft4, CxFltT6 - CxFltT4
        stf.spill.nta [loc3] = ft5, CxFltT7 - CxFltT5
        sub         t2 = t0, t1
        ;;

        stf.spill.nta [loc2] = ft6, CxFltT8 - CxFltT6
        stf.spill.nta [loc3] = ft7, CxFltT9 - CxFltT7
        cmp4.le     pt1, pt0 = t2, zero
        ;;

        stf.spill.nta [loc2] = ft8, CxFltS4 - CxFltT8
        stf.spill.nta [loc3] = ft9, CxFltS5 - CxFltT9
 (pt0)  add         t2 = -1, t2
        ;;

        stf.spill.nta [loc2] = fs4, CxFltS6 - CxFltS4
        stf.spill.nta [loc3] = fs5, CxFltS7 - CxFltS5
 (pt0)  add         t0 = 1, t0
        ;;

        stf.spill.nta [loc2] = fs6, CxFltS8 - CxFltS6
        stf.spill.nta [loc3] = fs7, CxFltS9 - CxFltS7
 (pt0)  add         t2 = -63, t2
        ;;

        stf.spill.nta [loc2] = fs8, CxFltS10 - CxFltS8
        stf.spill.nta [loc3] = fs9, CxFltS11 - CxFltS9
 (pt0)  cmp4.ge.unc pt2, pt3 = t2, zero
        ;;

        stf.spill.nta [loc2] = fs10, CxFltS12 - CxFltS10
        stf.spill.nta [loc3] = fs11, CxFltS13 - CxFltS11
 (pt1)  br.cond.spnt Rcc20
        ;;

Rcc10:
 (pt2)  add         t0 = 1, t0
 (pt2)  add         t2 = -63, t2
 (pt3)  br.cond.sptk Rcc20
        ;;

        cmp4.ge     pt2, pt3 = t2, zero
        nop.m       0
        br          Rcc10

Rcc20:
        stf.spill.nta [loc2] = fs12, CxFltS14 - CxFltS12
        stf.spill.nta [loc3] = fs13, CxFltS15 - CxFltS13
        add         tmpbsp = -8, rbsp
        ;;

        stf.spill.nta [loc2] = fs14, CxFltS16 - CxFltS14
        stf.spill.nta [loc3] = fs15, CxFltS17 - CxFltS15
        shl         t0 = t0, 3
        ;;

        stf.spill.nta [loc2] = fs16, CxFltS18 - CxFltS16
        stf.spill.nta [loc3] = fs17, CxFltS19 - CxFltS17
        sub         rbsp = rbsp, t0
        ;;

        stf.spill.nta [loc2] = fs18, CxFltF32 - CxFltS18
        stf.spill.nta [loc3] = fs19, CxFltF33 - CxFltS19
        nop.i       0
        ;;

//
// Save application registers, control information and set context flags.
//

        User=pt0
        Krnl=pt1
        rdcr=t1
        mask=t2
        sol=t4
        rpsr=t5
        is=t6
        rccv=t7
        rlc=t8
        rec=t9
        rrsc=t10
        rrnat=t11
        flag=t16
        addr0=t17
        addr1=t18
        tmp=t19

        mov         rrsc = ar.rsc
        tbit.nz     Krnl, User = sp, 62         // bit 62 is 1 when
        mov         rlc = ar.lc
        ;;

        mov         ar.rsc = zero               // put RSE in lazy mode
        mov         rccv = ar.ccv
        mov         rec = ar.ec
        ;;                                      // in kernel

 (Krnl) mov         rpsr = psr
 (User) mov         rpsr = psr.um
        add         addr0 = CxApUNAT, a0

        mov         rrnat = ar.rnat
        add         addr1 = CxApLC, a0

 (Krnl) mov         rdcr = cr.dcr
 (Krnl) movl        tmp = 1 << PSR_BN
        ;;

        st8.nta     [addr0] = runat, CxApEC - CxApUNAT
        st8.nta     [addr1] = rlc, CxApCCV - CxApLC
 (Krnl) or          rpsr = tmp, rpsr
        ;;

        st8.nta     [addr0] = rec, CxApDCR - CxApEC
        st8.nta     [addr1] = rccv, CxRsPFS - CxApCCV
        mov         tmp = 1
        ;;

        st8.nta     [addr0] = rdcr, CxRsBSP - CxApDCR
        st8.nta     [addr1] = rpfs, CxRsBSPSTORE - CxRsPFS
        shl         tmp = tmp, 63
        ;;

        st8.nta     [addr0] = rbsp, CxRsRSC - CxRsBSP
        st8.nta     [addr1] = rbsp, CxRsRNAT - CxRsBSPSTORE
        or          rpfs = rpfs, tmp            // validate IFS
        ;;

        st8.nta     [addr0] = rrsc, CxStIIP - CxRsRSC
        st8.nta     [addr1] = rrnat, CxStIFS - CxRsRNAT
        mov         mask = RNAT_ALIGNMENT
        ;;

        st8.nta     [addr0] = rbrp, CxStIPSR - CxStIIP
        add         tmp = CxContextFlags, a0
        mov         flag = CONTEXT_FULL         // full context saved.
        ;;

        st8.nta     [addr0] = rpsr              // save psr
        st8.nta     [addr1] = rpfs
        or          tmpbsp = tmpbsp, mask
        ;;

        mov         ar.rsc = rrsc               // restore RSC
        st4.nta     [tmp] = flag

        mov         ar.unat = runat             // restore ar.unat
        st8.nta     [tmpbsp] = rrnat
 (p0)   br.ret.sptk brp                         // return to caller.

        LEAF_EXIT(SaveAllRegs)


//++
//
// VOID
// RestoreAllRegs (
//    IN PCONTEXT ContextRecord,
//    )
//
// Routine Description:
//
//    This function restores the registers of the caller from the specified
//    context.
//
//    N.B. The context record is assumed to be 16-byte aligned.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies the address of a context record.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(RestoreAllRegs)

        dest1=t8
        dest2=t9
        rlc=t10
        rpreds=t11
        rbrp=t12
        rbsp=t13
        rpfs=t14
        runat=t15
        rpreds=t16
        rsp=t17
        rfpsr=t18
        jb=t19
        tmp=t20
        src1=t21
        src2=t22

        .regstk     2, 9, 2, 0

        alloc       t4 = ar.pfs, 2, 11, 2, 0
        ARGPTR(a0)

        add         src1 = CxIntNats, a0
        add         src2 = CxPreds, a0
        add         tmp = CxIntGp, a0
        ;;

        ld8.nt1     t17 = [src1], CxBrRp - CxIntNats
        ld8.nt1     t16 = [src2], CxBrS0 - CxPreds
        shr         tmp = tmp, 3
        ;;

        ld8.nt1     t0 = [src1], CxBrS1 - CxBrRp
        ld8.nt1     t1 = [src2], CxBrS2 - CxBrS0
        and         tmp = 0x3f, tmp
        ;;

        ld8.nt1     t2 = [src1], CxBrS3 - CxBrS1
        ld8.nt1     t3 = [src2], CxBrS4 - CxBrS2
        cmp4.ge     pt1, pt0 = 1, tmp
        ;;

        ld8.nt1     t4 = [src1], CxBrT0 - CxBrS3
        ld8.nt1     t5 = [src2], CxBrT1 - CxBrS4
 (pt1)  sub         loc5 = 1, tmp
        ;;

        ld8.nt1     t6 = [src1], CxApUNAT - CxBrT0
        ld8.nt1     t7 = [src2], CxApLC - CxBrT1
 (pt0)  add         loc5 = -1, tmp
        ;;

        ld8.nt1     loc0 = [src1], CxApEC - CxApUNAT
        ld8.nt1     t8 = [src2], CxApCCV - CxApLC
 (pt0)  sub         loc6 = 65, tmp
        ;;

        ld8.nt1     t9 = [src1], CxApDCR - CxApEC
        ld8.nt1     t10 = [src2], CxRsPFS - CxApCCV
 (pt1)  shr.u       t17 = t17, loc5
        ;;

        ld8.nt1     loc1 = [src1], CxRsBSP - CxApDCR
        ld8.nt1     t11 = [src2], CxRsRSC - CxRsPFS
 (pt0)  shl         loc7 = t17, loc5
        ;;

        ld8.nt1     loc2 = [src1], CxStIIP - CxRsBSP
        ld8.nt1     loc3 = [src2], CxStIFS - CxRsRSC
 (pt0)  shr.u       loc8 = t17, loc6
        ;;

        ld8.nt1     loc9 = [src1]
        ld8.nt1     loc10 = [src2]
 (pt0)  or          t17 = loc7, loc8
        ;;

        mov         ar.unat = t17
        add         src1 = CxFltS0, a0
        shr         t12 = loc2, 3
        ;;

        add         src2 = CxFltS1, a0
        and         t12 = 0x3f, t12             // current rnat save index
        and         t13 = 0x7f, loc10           // total frame size
        ;;

        mov         ar.ccv = t10
        add         t14 = t13, t12
        mov         ar.pfs = t11
        ;;

Rrc20:
        cmp4.gt     pt1, pt0 = 63, t14
        ;;
 (pt0)  add         t14 = -63, t14
 (pt0)  add         t13 = 1, t13
        ;;

        nop.m       0
 (pt1)  shl         t13 = t13, 3
 (pt0)  br.cond.spnt Rrc20
        ;;

        add         loc2 = loc2, t13
        nop.f       0
        mov         pr = t16, -1

        ldf.fill.nt1  fs0 = [src1], CxFltS2 - CxFltS0
        ldf.fill.nt1  fs1 = [src2], CxFltS3 - CxFltS1
        mov         brp = t0
        ;;

        ldf.fill.nt1  fs2 = [src1], CxFltT0 - CxFltS2
        ldf.fill.nt1  fs3 = [src2], CxFltT1 - CxFltS3
        mov         bs0 = t1
        ;;

        ldf.fill.nt1  ft0 = [src1], CxFltT2 - CxFltT0
        ldf.fill.nt1  ft1 = [src2], CxFltT3 - CxFltT1
        mov         bs1 = t2
        ;;

        ldf.fill.nt1  ft2 = [src1], CxFltT4 - CxFltT2
        ldf.fill.nt1  ft3 = [src2], CxFltT5 - CxFltT3
        mov         bs2 = t3
        ;;

        ldf.fill.nt1  ft4 = [src1], CxFltT6 - CxFltT4
        ldf.fill.nt1  ft5 = [src2], CxFltT7 - CxFltT5
        mov         bs3 = t4
        ;;

        ldf.fill.nt1  ft6 = [src1], CxFltT8 - CxFltT6
        ldf.fill.nt1  ft7 = [src2], CxFltT9 - CxFltT7
        mov         bs4 = t5
        ;;

        ldf.fill.nt1  ft8 = [src1], CxFltS4 - CxFltT8
        ldf.fill.nt1  ft9 = [src2], CxFltS5 - CxFltT9
        mov         bt0 = t6
        ;;

        ldf.fill.nt1  fs4 = [src1], CxFltS6 - CxFltS4
        ldf.fill.nt1  fs5 = [src2], CxFltS7 - CxFltS5
        mov         bt1 = t7
        ;;

        ldf.fill.nt1  fs6 = [src1], CxFltS8 - CxFltS6
        ldf.fill.nt1  fs7 = [src2], CxFltS9 - CxFltS7
        mov         ar.lc = t8
        ;;

        ldf.fill.nt1  fs8 = [src1], CxFltS10 - CxFltS8
        ldf.fill.nt1  fs9 = [src2], CxFltS11 - CxFltS9
        mov         ar.ec = t9
        ;;

        ldf.fill.nt1  fs10 = [src1], CxFltS12 - CxFltS10
        ldf.fill.nt1  fs11 = [src2], CxFltS13 - CxFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], CxFltS14 - CxFltS12
        ldf.fill.nt1  fs13 = [src2], CxFltS15 - CxFltS13
        add         loc6 = CxIntGp, a0
        ;;

        ldf.fill.nt1  fs14 = [src1], CxFltS16 - CxFltS14
        ldf.fill.nt1  fs15 = [src2], CxFltS17 - CxFltS15
        add         loc7 = CxIntT0, a0
        ;;

        ldf.fill.nt1  fs16 = [src1], CxFltS18 - CxFltS16
        ldf.fill.nt1  fs17 = [src2], CxFltS19 - CxFltS17
        add         t19 = CxRsRNAT, a0
        ;;

        ldf.fill.nt1  fs18 = [src1]
        ldf.fill.nt1  fs19 = [src2]
        add         t7 = CxStFPSR, a0
        ;;

        ld8.nt1     loc8 = [t7]                 // load fpsr from context
        ld8.nt1     loc5 = [t19]                // load rnat from context
        nop.i       0

        ld8.fill.nt1 gp = [loc6], CxIntT1 - CxIntGp
        ld8.fill.nt1 t0 = [loc7], CxIntS0 - CxIntT0
        ;;

        ld8.fill.nt1 t1 = [loc6], CxIntS1 - CxIntT1
        ld8.fill.nt1 s0 = [loc7], CxIntS2 - CxIntS0
        ;;

        ld8.fill.nt1 s1 = [loc6], CxIntS3 - CxIntS1
        ld8.fill.nt1 s2 = [loc7], CxIntV0 - CxIntS2
        ;;

        ld8.fill.nt1 s3 = [loc6], CxIntTeb - CxIntS3
        ld8.fill.nt1 v0 = [loc7], CxIntT2 - CxIntV0
        ;;

        ld8.fill.nt1 teb = [loc6], CxIntT3 - CxIntTeb
        ld8.fill.nt1 t2 = [loc7], CxIntSp - CxIntT2
        ;;

        ld8.fill.nt1 t3 = [loc6], CxIntT4 - CxIntT3
        ld8.fill.nt1 loc4 = [loc7], CxIntT5 - CxIntSp
        ;;

        ld8.fill.nt1 t4 = [loc6], CxIntT6 - CxIntT4
        ld8.fill.nt1 t5 = [loc7], CxIntT7 - CxIntT5
        ;;

        ld8.fill.nt1 t6 = [loc6], CxIntT8 - CxIntT6
        ld8.fill.nt1 t7 = [loc7], CxIntT9 - CxIntT7
        ;;

        ld8.fill.nt1 t8 = [loc6], CxIntT10 - CxIntT8
        ld8.fill.nt1 t9 = [loc7], CxIntT11 - CxIntT9
        ;;

        ld8.fill.nt1 t10 = [loc6], CxIntT12 - CxIntT10
        ld8.fill.nt1 t11 = [loc7], CxIntT13 - CxIntT11
        ;;

        ld8.fill.nt1 t12 = [loc6], CxIntT14 - CxIntT12
        ld8.fill.nt1 t13 = [loc7], CxIntT15 - CxIntT13
        ;;

        ld8.fill.nt1 t14 = [loc6], CxIntT16 - CxIntT14
        ld8.fill.nt1 t15 = [loc7], CxIntT17 - CxIntT15
        ;;

        ld8.fill.nt1 t16 = [loc6], CxIntT18 - CxIntT16
        ld8.fill.nt1 t17 = [loc7], CxIntT19 - CxIntT17
        ;;

        ld8.fill.nt1 t18 = [loc6], CxIntT20 - CxIntT18
        ld8.fill.nt1 t19 = [loc7], CxIntT21 - CxIntT19
        ;;

        ld8.fill.nt1 t20 = [loc6], CxIntT22 - CxIntT20
        ld8.fill.nt1 t21 = [loc7]
        ;;

        rsm         1 << PSR_I
        ld8.fill.nt1 t22 = [loc6]
        ;;

        rsm         1 << PSR_IC
        movl        t0 = 1 << IFS_V
        ;;

        mov         ar.fpsr = loc8              // set fpsr
        mov         ar.unat = loc0
        ;;

        srlz.d
        or          loc10 = t0, loc10           // set ifs valid bit
        ;;

        mov         cr.iip = loc9
        mov         cr.ifs = loc10
        bsw.0
        ;;

        mov         cr.dcr = loc1
        mov         r17 = loc2                  // put BSP in a shadow reg
        or          r16 = 0x3, loc3             // put RSE in eager mode

        mov         ar.rsc = r0                 // put RSE in enforced lazy
        nop.m       0
        add         r20 = CxStIPSR, a0
        ;;

        ld8.nt1     r20 = [r20]                 // load IPSR
        mov         r18 = loc4                  // put SP in a shadow reg
        mov         r19 = loc5                  // put RNaTs in a shadow reg
        ;;

        alloc       t0 = 0, 0, 0, 0
        mov         cr.ipsr = r20
        mov         sp = r18
        ;;

        loadrs
        ;;
        mov         ar.bspstore = r17
        nop.i       0
        ;;

        mov         ar.rnat = r19               // set rnat register
        mov         ar.rsc = r16                // restore RSC
        bsw.1
        ;;

        LEAF_EXIT(RestoreAllRegs)



//--------------------------------------------------------------------
// Routine:
//
//       VOID
//       penter(
//            VOID)
//
// Description:
//
//       This function loads the return address and current address in to two
//       parameter registers, then calls the C version (c_penter)
//
// Input:
//
//       None
//
// Output:
//
//       None
//
// Return value:
//
//       None
//
//
//
//--------------------------------------------------------------------

        LEAF_ENTRY(penter)

        .regstk 0, 1, 2, 0

        //
        // This to be filled in when the compiler implements /Gh switch
        //

        br.call.sptk brp = c_penter

        LEAF_EXIT(penter)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstune\wsdata.h ===
/*
 * Module Name:  WSDATA.H
 *
 * Description:
 *
 * Working set tuner include file.  Contains common structure
 * declarations and constant definitions.
 *
 *
 *	This is an OS/2 2.x specific file
 *
 *	IBM/Microsoft Confidential
 *
 *	Copyright (c) IBM Corporation 1987, 1989
 *	Copyright (c) Microsoft Corporation 1987, 1989
 *
 *	All Rights Reserved
 *
 * Modification History:		
 *				
 *	03/23/90	- created			
 *						
 */

/*
 *	Constant definitions.
 */

#define NUM_VAR_BITS	(sizeof(ULONG) << 3)

#ifdef TMIFILEHACK
#define	MAXLINE	80
#endif /* TMIFILEHACK */

/*
 *	    Type definitions and structure declarations.
 */

typedef ULONG	fxnbits_t;

struct	dtqo_s	{
	unsigned long	dtqo_hMTE;	 /* MTE handle			*/
	unsigned short	dtqo_usID;	 /* Identifier			*/
//	unsigned short	dtqo_SymCnt;	 /* Reserved			*/
	unsigned long	dtqo_SymCnt;	 /* Reserved			*/ // mdg 4/98
	unsigned long	dtqo_cbPathname; /* Module pathname length	*/
	unsigned long	dtqo_clSegSize;	 /* Number of dyntrc variables	*/
};

typedef struct	dtqo_s	dtqo_t;


/*
 * WSI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      sentinel 0 (dtgp_s)              | <----------
 *	|=======================================|           |
 *	|      snapshot 0 (dtgp_s) for module X |           | S
 *	|---------------------------------------|           | n
 *	|      dynamic trace variables for X    |           | a
 *	|---------------------------------------|           | p
 *	|      snapshot 0 (dtgp_s) for module Y |           | s
 *	|---------------------------------------|           | h
 *	|      dynamic trace variables for Y    |           | o
 *	|---------------------------------------|           | t
 *	|               etc.                    |           |
 *	|=======================================|           | D
 *	|      sentinel 1 (dtgp_s)              |           | a
 *	|=======================================|           | t
 *	|      snapshot 1 (dtgp_s) for module X |           | a
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for X    |           |
 *	|---------------------------------------|           |
 *	|      snapshot 1 (dtgp_s) for module Y |           |
 *	|---------------------------------------|           |
 *	|      dynamic trace variables for Y    |           |
 *	|---------------------------------------|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      sentinel 2 (dtgp_s)              |           |
 *	|=======================================|           |
 *	|               etc.                    |           |
 *	|=======================================|           |
 *	|      end sentinel (dtgp_s)            |           |
 *	|_______________________________________| <----------
 *	|_______________________________________|
 *	|                                       | <---------- Q
 *	|      dtqo_s for module X              |           | u
 *	|---------------------------------------|           | e
 *	|      module X pathname string         |           | r
 *	|=======================================|           | y
 *	|      dtqo_s for module Y              |           |
 *	|---------------------------------------|           | I
 *	|      module Y pathname string         |           | n
 *	|=======================================|           | f
 *	|               etc.                    | <---------- o
 *	|=======================================|
 *	|_______________________________________|
 *	
 */


				/* WSI file header format */
struct wsihdr_s {
	CHAR	wsihdr_chSignature[4];	// file signature
	ULONG	wsihdr_ulLevel;		// format level
	ULONG	wsihdr_ulTimeStamp;	// time stamp
	ULONG	wsihdr_ulOffGetvar;	// offset to DT_GETVAR data
	ULONG	wsihdr_ulOffQuery;	// offset to DT_QUERY data
	ULONG	wsihdr_cbFile;		// size of file (in bytes)
	ULONG	wsihdr_ulSnaps;		// number of snapshots
};

typedef struct wsihdr_s wsihdr_t;

/*
 * WSP file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              wsphdr_s                 |
 *	|---------------------------------------|
 *	|         module pathname array         |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 bitstring            |
 *      |      (rounded to DWORD boundary)      |
 *	|=======================================|
 *	|      function #1 bitstring            |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* WSP file header format */
struct wsphdr_s {
	CHAR	wsphdr_chSignature[4];	// file signature
	ULONG	wsphdr_ulTimeStamp;	// time stamp
	dtqo_t	wsphdr_dtqo;		// query info
	ULONG	wsphdr_ulOffBits;	// offset to first bitstring
	ULONG	wsphdr_ulSnaps;		// number of snapshots
	/* followed by module pathname char array, length specified in dtqo */
};

typedef struct wsphdr_s wsphdr_t;


/*
 * TMI file layout:
 *
 *	_________________________________________
 *	|                                       |
 *	|              tmihdr_s                 |
 *	|_______________________________________|
 *	|_______________________________________|
 *	|      function #0 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #0 name array           |
 *	|=======================================|
 *	|      function #1 tmirec_s             |
 *	|---------------------------------------|
 *	|      function #1 name array           |
 *	|=======================================|
 *	|              etc.                     |
 *	|=======================================|
 *	|_______________________________________|
 *	
 */

				/* TMI file header. */
typedef struct  tmihdr_s {
            CHAR    tmihdr_chSignature[4]; // "TMI\0"
            USHORT  tmihdr_usMajor;        // Range 0x0001 to 0x00FF
            USHORT  tmihdr_cTmiRec;        // Number of tmirec in file
            CHAR    tmihdr_chModName[256]; // Name of traced module
            USHORT  tmihdr_usID;           // Module identifier
            CHAR    tmihdr_resv[30];       // Reserved
};

typedef struct tmihdr_s tmihdr_t;

				/* Per-function information from TMI file */
struct tmirec_s {
	ULONG	tmirec_ulFxnIndex;	// function's bit reference position
	ULONG	tmirec_usFxnAddrObj;	// object portion of function address
	ULONG	tmirec_ulFxnAddrOff;	// offset portion of function address
	ULONG	tmirec_cbFxn;		// size of function (in bytes)
	USHORT	tmirec_cbFxnName;	// size in bytes of function name
	CHAR	tmirec_FxnName[1];	// bytes of function name start here
};

typedef struct tmirec_s tmirec_t;

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdump\wstdump.c ===
/*++

   wstdump.c
	   Dump routines for WST

   History:
       10-26-92  RezaB - created.

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>

#include <wst.h>

#include "wstdump.h"


//
// dump clear switches and defaults
//
WORD fDump = FALSE;
WORD fClear = FALSE;
WORD fPause = TRUE;


HANDLE  hDoneEvent;
HANDLE  hDumpEvent;
HANDLE  hClearEvent;
HANDLE	hPauseEvent;
HANDLE	hdll;

SECURITY_DESCRIPTOR  SecDescriptor;


//
// error handling
//
#define LOG_FILE "wstdump.log"
FILE *pfLog;


void    	  ClearDumpInfo  (void);
INT_PTR APIENTRY DialogProc(HWND, UINT, WPARAM, LPARAM);


/*++

  Main Routine

--*/

int WinMain(HINSTANCE hInstance,HINSTANCE hPrevInst,LPSTR lpCmdLine,int nCmdShow)
{
    NTSTATUS           Status;
    STRING	       	   EventName;
    UNICODE_STRING     EventUnicodeName;
    OBJECT_ATTRIBUTES  EventAttributes;


    // Prevent compiler from complaining..
    //
    hPrevInst;
    lpCmdLine;
    nCmdShow;


    // Open the log file for logging possible errors
    //
    pfLog = fopen (LOG_FILE, "w");
    if (!pfLog) {
        exit (1);
    }


    // Create public share security descriptor for all the named objects
    //

    Status = RtlCreateSecurityDescriptor (
		&SecDescriptor,
		SECURITY_DESCRIPTOR_REVISION1
		);
    if (!NT_SUCCESS(Status)) {
	fprintf (pfLog, "WSTDUMP: main () - RtlCreateSecurityDescriptor() "
		       "failed - %lx\n", Status);
	exit (1);
    }

    Status = RtlSetDaclSecurityDescriptor (
		&SecDescriptor,	   	// SecurityDescriptor
		TRUE,		   		// DaclPresent
		NULL,		   		// Dacl
		FALSE		   		// DaclDefaulted
		);
    if (!NT_SUCCESS(Status)) {
	fprintf (pfLog, "WSTDUMP: main () - RtlSetDaclSecurityDescriptor() "
		       "failed - %lx\n", Status);
	exit (1);
    }


    // Initialization for DONE event creation
    //
    RtlInitString (&EventName, DONEEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
       fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                       "failed for DUMP event name - %lx\n", Status);
	   exit (1);
    }
    //
    // Create DONE event
    //
    Status = NtCreateEvent (&hDoneEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            TRUE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create DUMP event - %lx\n", Status);
        exit (1);
    }


    // Initialization for DUMP event creation
    //
    RtlInitString (&EventName, DUMPEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                       "failed for DUMP event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create DUMP event
    //
    Status = NtCreateEvent (&hDumpEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create DUMP event - %lx\n", Status);
        exit (1);
    }


    // Initialization for CLEAR event creation
    //
    RtlInitString (&EventName, CLEAREVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
                        "failed for CLEAR event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create CLEAR event
    //
    Status = NtCreateEvent (&hClearEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
                        "failed to create CLEAR event - %lx\n", Status);
        exit (1);
    }


    // Initialization for PAUSE event creation
    //
    RtlInitString (&EventName, PAUSEEVENTNAME);

    Status = RtlAnsiStringToUnicodeString (&EventUnicodeName,
					   &EventName,
                                           TRUE);
    if (NT_SUCCESS(Status)) {
	InitializeObjectAttributes (&EventAttributes,
				    &EventUnicodeName,
				    OBJ_OPENIF | OBJ_CASE_INSENSITIVE,
				    NULL,
				    &SecDescriptor);
    }
    else {
        fprintf (pfLog, "WSTDUMP: main () - RtlAnsiStringToUnicodeString() "
			"failed for PAUSE event name - %lx\n", Status);
        exit (1);
    }
    //
    // Create PAUSE event
    //
    Status = NtCreateEvent (&hPauseEvent,
                            EVENT_QUERY_STATE    |
                              EVENT_MODIFY_STATE |
                              SYNCHRONIZE,
							&EventAttributes,
                            NotificationEvent,
                            FALSE);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: main () - NtCreateEvent() "
			"failed to create PAUSE event - %lx\n", Status);
        exit (1);
    }


    //
    // show dialog box
    //
    DialogBox(hInstance, "DumpDialog", NULL, DialogProc);

    return (0);

} /* main */


/*++

   Clears and/or dump profiling info to the dump file.

   Input:
       -none-

   Output:
       -none-
--*/

void ClearDumpInfo (void)
{
    NTSTATUS   Status;


    //
    // Pause profiling?
    //
    if (fPause) {
	Status = NtPulseEvent (hPauseEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
			    "failed for PAUSE event - %lx\n", Status);
            exit (1);
        }
    }
    //
    // Dump data?
    //
    else if (fDump) {
        Status = NtPulseEvent (hDumpEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
                            "failed for DUMP event - %lx\n", Status);
            exit (1);
        }
    }
    //
    // Clear data?
    //
    else if (fClear) {
        Status = NtPulseEvent (hClearEvent, NULL);
        if (!NT_SUCCESS(Status)) {
            fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtPulseEvent() "
                            "failed for CLEAR event - %lx\n", Status);
            exit (1);
        }
    }
    //
	// Wait for the DONE event..
    //
	Sleep (500);
	Status = NtWaitForSingleObject (hDoneEvent, FALSE, NULL);
    if (!NT_SUCCESS(Status)) {
        fprintf (pfLog, "WSTDUMP: ClearDumpInfo () - NtWaitForSingleObject() "
                        "failed for DONE event - %lx\n", Status);
        exit (1);
    }

} /* ClearDumpInfo() */



/*++

   Dump dialog procedure -- exported to windows.
   Allows user to change defaults:  dump, clear, and ".dmp" as dump
   file extension.

   Input:
       Messages from windows:
           - WM_INITDIALOG - initialize dialog box
           - WM_COMMAND    - user input received

   Output:
       returns TRUE if message processed, false otherwise

   SideEffects:
       global flags fDump and fClear may be altered

--*/

INT_PTR APIENTRY DialogProc(HWND hDlg, UINT wMesg, WPARAM wParam, LPARAM lParam)
{
    HICON hIcon;


    lParam;   //Avoid Compiler warnings

    switch (wMesg) {

        case WM_CREATE:

            hIcon = LoadIcon ((HINSTANCE)hDlg, "WSTDUMP.ICO");
            SetClassLongPtr (hDlg, GCLP_HICON, (LONG_PTR)hIcon);
            return TRUE;


        case WM_INITDIALOG:

			CheckDlgButton(hDlg, ID_DUMP, fDump);
            CheckDlgButton(hDlg, ID_CLEAR, fClear);
			CheckDlgButton(hDlg, ID_PAUSE, fPause);
            return TRUE;


        case WM_COMMAND:

            switch (wParam) {

                case IDOK:
					if (fDump) {
                        SetWindowText(hDlg, "Dumping Data..");
                    }
                    else if (fClear) {
                        SetWindowText(hDlg, "Clearing Data..");
                    }
					else if (fPause) {
						SetWindowText(hDlg, "Stopping WST..");
                    }

                    ClearDumpInfo();
					SetWindowText(hDlg, "WST Dump Utility");
                    return (TRUE);

                case IDEXIT:
                    EndDialog(hDlg, IDEXIT);
                    return (TRUE);

                case ID_DUMP:
					fDump = TRUE;
					fPause = FALSE;
					fClear = FALSE;
                    CheckDlgButton(hDlg, ID_DUMP, fDump);
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_CLEAR, fClear);
                    return (TRUE);

                case ID_CLEAR:
					fClear = TRUE;
					fPause = FALSE;
					fDump = FALSE;
                    CheckDlgButton(hDlg, ID_CLEAR, fClear);
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_DUMP, fDump);
                    return (TRUE);

				case ID_PAUSE:
					fPause = TRUE;
					fClear = FALSE;
					fDump = FALSE;
					CheckDlgButton(hDlg, ID_PAUSE, fPause);
					CheckDlgButton(hDlg, ID_CLEAR, fClear);
					CheckDlgButton(hDlg, ID_DUMP, fDump);
					return (TRUE);

            }

    }

    return (FALSE);     /* did not process a message */

} /* DialogProc() */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\dlg.h ===
#define IDD_MAIN                    100
#define IDS_USERID                  102
#define IDS_LOGONSESSION            104
#define IDC_DEFAULTOWNER            106
#define IDL_DISABLEDGROUPS          111
#define IDB_DISABLEPRIVILEGE        112
#define IDB_ENABLEPRIVILEGE         113
#define IDL_ENABLEDPRIVILEGES       117
#define IDL_DISABLEDPRIVILEGES      118
#define IDL_ENABLEDGROUPS           123
#define IDB_DISABLEGROUP            124
#define IDB_ENABLEGROUP             125
#define IDC_PRIMARYGROUP            126
#define IDB_MORE                    110
#define IDS_TOKENID                 208
#define IDS_EXPIRATIONTIME          209
#define IDS_TOKENTYPE               210
#define IDS_IMPERSONATION           211
#define IDS_DYNAMICCHARGED          212
#define IDS_DYNAMICAVAILABLE        213
#define IDS_MODIFIEDID              214
#define IDD_MORE                    101
#define IDD_WINDOWLIST              220
#define IDD_WINDOWLISTDELETE        221
#define IDLB_WINDOWLIST             222
#define IDD_ABOUT                   4000
#define IDD_ACTIVEWINDOW            4500
#define IDD_                        200
#define IDEF_GROUPNAME              202
#define IDD_GROUPADD                300
#define IDD_GROUPDELETE             400
#define IDCB_GROUPLIST              401
#define IDD_GROUPSELECT             600
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstdump\wstdump.h ===
/*++
 wstdump.h

  Definitions for dialog box controls in WST dump routine.

  rezab 10-26-92

--*/


#define IDOK          1
#define IDEXIT        2

#define ID_STARTVAL   100
#define ID_PAUSE      100
#define ID_CLEAR      101
#define ID_DUMP       102

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstune\wstune.h ===
#define	INCL_DOS
#define	INCL_DOSERRORS
#define CCHMAXPATHCOMP	256
#define MAXLINE    300  // mdg 98/4

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wsdata.h>
#include <..\wsfslib\wserror.h>
#include <limits.h>
#include <..\wsfslib\wsfslib.h>

#define SdPrint(_x_)	DbgPrint _x_


extern CHAR *szProgName; /* so all parts of the program will know the name */
extern CHAR *pszVersion;	// Current program version number
#ifdef DEBUG
extern BOOL fDbgVerbose;
#endif   // DEBUG

BOOL wspDumpMain( CHAR *szBaseFile, CHAR *szDatExt, BOOL fRandom, BOOL fVerbose );
BOOL wsReduceMain( CHAR *szFileWSP );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstune\wstune.c ===
/*
 * Module Name:	 WSTUNE.C
 *
 * Program:	 WSTUNE
 *
 *
 * Description:
 *
 * Shell to call former programs WSDUMP and WSREDUCE
 *
 *
 *	Microsoft Confidential
 *
 *	Copyright (c) Microsoft Corporation 1992-1998
 *
 *	All Rights Reserved
 *
 * Modification History:
 *
 *	8-31-92:	Made single exe from wspdump, wsreduce and wstune	marklea
 * 4-13-98: QFE                                                DerrickG (mdg):
 *          - support for long file names (LFN) of input/output files
 *          - based .TMI file name exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths
 *          - removed -F & -V flags for non-debug; made verbose global for WsRed...()
 *          - made program name & version global; read version from ntverp.h
 *         
 *
 */
#include "wstune.h"

#include <ntverp.h>



#define COMMAND_LINE_LEN 128
#define FILE_NAME_LEN 40

#define FAKE_IT 1

#define ERR fprintf(stderr

VOID wsTuneUsage(VOID);


CHAR *szProgName = "WSTUNE";
CHAR *pszVersion = VER_PRODUCTVERSION_STR;   // Current product version number
INT nMode;
#ifdef DEBUG
BOOL fDbgVerbose = FALSE;
#endif   // DEBUG

/* main()
 *
 * parses command line args
 */
INT __cdecl main(INT argc,CHAR **argv)
{
   CHAR 	*szBaseName = NULL;
	CHAR 	*szNull;
	BOOL 	fOutPut = FALSE;
	BOOL	fNoReduce = FALSE;
	BOOL	fNoDump = FALSE;
	INT		cArgCnt = 0;

   ConvertAppToOem( argc, argv );
   nMode = 0; // default flags set

    while (--argc && (**(++argv) == '-' || **argv=='/'))
    {
        while(*(++(*argv))) switch (**argv)
        {
			case '?':
				wsTuneUsage();
				break;

#ifdef DEBUG
         case 'f':
			case 'F':
				nMode |= FAKE_IT;
				break;
#endif   // DEBUG
			case 'O':
			case 'o':
				fOutPut = TRUE;
				break;
			case 'N':
			case 'n':
				fNoDump = TRUE;
				break;
			case 'D':
			case 'd':
				fNoReduce = TRUE;
				break;
#ifdef DEBUG
         case 'V':
         case 'v':
            fDbgVerbose = TRUE;
            break;
#endif   // DEBUG
         case 'P':
         case 'p':
            fWsIndicator = TRUE;
            break;


         default: ERR,"%s: Unrecognized switch: %c\n",
                    szProgName,**argv);
                    return(-1);
        }
    }

    /* any files? */
    if (argc <1)
    {
	   wsTuneUsage();
	   return(-1);
    }

    /* now we go to work -- walk through the file names on the command line */
    while (argc--)
    {
      szBaseName = *(argv++);

      printf("%s: using \042%s\042\n",szProgName,szBaseName);

		if (szNull = strchr(szBaseName, '.'), szNull) {
			*szNull = '\0';
		}

      /* WSREDUCE file.WSP */
      if (!(nMode & FAKE_IT)){
		   if (!fNoReduce){
				wsReduceMain( szBaseName );
			}
		}

		if (!fNoDump){
			
			/* WSPDUMP /V /Ffile.WSP /Tfile.TMI /Rfile.WSR > file.DT */

			if(!(nMode & FAKE_IT)){
            wspDumpMain( szBaseName, (fOutPut ? ".DT" : NULL), TRUE, TRUE );
			}

			/* wspdump /Ffile.wsp /Tfile.tmi > file.DN */

			if (!(nMode & FAKE_IT) && fOutPut){
            wspDumpMain( szBaseName, ".DN", FALSE, FALSE );
			}
		}
    }
   return 0;   // mdg 98/4
}


/*
 *			
 * VOID wsTuneUsage	(VOID)
 *					
 *							
 * Effects:							
 *								
 *	Prints out usage message, and exits with an error.			
 *								
 * Returns:							
 *	
 *	Exits with ERROR.	
 */

VOID wsTuneUsage(VOID)
{
   printf("\nUsage: %s [/O] [/D] [/N] [?] moduleName1[.WSP] [...]\n\n", szProgName);
   printf(
      "  /O   Dump analysis data to file (*.DT tuned, *.DN not tuned)\n"
      "  /N   Analyze bitstring data only, create .WSR and .PRF files (turns off /O)\n"
      "  /D   Dump analysis data only; use existing .WSR file (turns off /N)\n"
#ifdef DEBUG
      "  /F   Fake run for command-line parser debugging\n"
      "  /V   Verbose mode for debugging\n"
#endif   // DEBUG
      "  /P   Display a progress indicator\n"
      "  /?   Display this usage message\n\n"
      "       \"moduleNameX\" is the name(s) of the module file(s) to tune.\n\n"
      );
	printf("%s %s\n", szProgName, pszVersion);

   exit(ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstune\wspdump.c ===
/*
 * Module Name:  WSPDUMP.C
 *								
 * Program:	 WSPDUMP
 *								
 *								
 * Description:							
 *
 * Dumps the contents of a WSP file.
 *
 * Contitional compilation notes:
 *
 * Modification History:
 *
 *	6-12-92:    Adapted OS/2 version of wspdump for NT	    		marklea
 *	6-17-92:    Modified wspDumpBits to dump in correct order   	marklea
 *	6-18-92:    Added page useage information		    			marklea
 *	8-31-92:	Made single exe from wspdump, wsreduce and wstune	marklea
 * 4-13-98: QFE                                                DerrickG (mdg):
 *          - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *          - support for long file names (LFN) of input/output files
 *          - removed buggy reference to WSDIR env. variable
 *          - based .TMI file name exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths - return allocated name from WsTMIReadRec()
 *          - removed unused static declarations
 *								
 */

#include "wstune.h"

/*
 *	Global variable declaration and initialization.
 */

typedef struct fxn_t{
    CHAR   	*pszFxnName;
    ULONG   cbFxn;
	ULONG	ulTmiIndex;
	ULONG	ulOrigIndex;
}FXN;
typedef FXN *PFXN;

/*
 *	    Function prototypes.
 */

static VOID wspDumpSetup( VOID );
static VOID wspDumpRandom( VOID );
static UINT wspDumpBits( VOID );
static VOID wspDumpExit( UINT, USHORT, UINT, ULONG, PSZ );
static void wspDumpCleanup( void );
static VOID wspDumpSeq(VOID);
static int  __cdecl wspCompare(const void *fxn1, const void *fxn2);



static CHAR *szFileWSP = NULL;	// WSP file name
static CHAR *szFileTMI = NULL;	// TMI file name
static CHAR *szFileWSR = NULL;	// WSR file name
static CHAR *szDatFile = NULL;	// DAT file name


static ULONG	rc = NO_ERROR;	// Return code
static ULONG	ulTmp;			// Temp variable for Dos API returns
static ULONG	ulFxnIndex;		// Original index in symbol table
static FILE		*hFileWSP;		// Input WSP file handle
static FILE		*hFileTMI;		// Input TMI file handle
static FILE    *hFileDAT;      // Data file for dump
static wsphdr_t WspHdr;			// Input WSP file header
static BOOL 	fRandom = FALSE;	// Flag for random mode
static BOOL 	fVerbose = FALSE;	// Flag for verbose mode
static ULONG	ulFxnTot = 0;		// Total number of functions
static ULONG	clVarTot = 0;		// Total number of dwords in bitstr
static ULONG	*pulFxnBitstring;	// Function bitstring
static ULONG	ulSetSym = 0;		// Number of symbols set   // mdg 4/98
static BOOL	fDatFile = FALSE;

/*
 * Procedure wspDumpMain		
 *					
 *						
 ***
 * Effects:						
 *	
 * Constructs .WSP and .TMI input names from input basefile name. If szDatExt is
 * not NULL, appends it to szBaseFile to create output data file name. If fRandom,
 * constructs a .WSR output file. If fVerbose, adds extra output to data file.
 *
 * Processes the input files and displays the function reference data
 * for each function in the specified module WSP file.
 *
 */
BOOL wspDumpMain( CHAR *szBaseFile, CHAR *szDatExt, BOOL fRndm, BOOL fVbose )
{
	size_t	c;
    char *   pSlash;

    fRandom = fRndm;
    fVerbose = fVbose;
    // mdg 98/4 Allocate space for filenames - don't use static buffers
    c = 5 + strlen( szBaseFile ); // Length to allocate for filenames
    szFileWSP = malloc( c );
    if (szFileWSP) {
         strcat( strcpy( szFileWSP, szBaseFile ), ".WSP" );
    } else {
         return (1);
    }
    szFileTMI = malloc( c );
    if (szFileTMI) {
         strcat( strcpy( szFileTMI, szBaseFile ), ".TMI" );
    } else {
         free(szFileWSP);
        return (1);
    }

    // Create output file in current directory
    if (NULL != (pSlash = strrchr( szBaseFile, '\\' ))
        || NULL != (pSlash = strrchr( szBaseFile, '/' ))
        || NULL != (pSlash = strrchr( szBaseFile, ':' )))
    {
        c = strlen( ++pSlash ) + 5;
    } else
        pSlash = szBaseFile;

    if (fRandom) {
        szFileWSR = malloc( c );
        if (szFileWSR) {
            strcat( strcpy( szFileWSR, pSlash ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            return (1);
        }
    }
    if (szDatExt != NULL) {
        fDatFile = TRUE;
        szDatFile = malloc( c - 4 + strlen( szDatExt ) );
        if (szDatFile) {
            strcat( strcpy( szDatFile, pSlash ), szDatExt );
        } else {
            free(szFileWSR);
            free(szFileTMI);
            free(szFileWSP);
            return (1);
        }
    } else {
       fDatFile = FALSE;
       szDatFile = "";
    }

	// Setup input files for dump processing.
	wspDumpSetup();		

	/* Print the WSP file info, either randomly (based on WSR file
	 * input) or sequentially (the default).
	 */
	if (fRandom == TRUE)
		wspDumpRandom();
	else
		wspDumpSeq();
		
   wspDumpCleanup();

   return(NO_ERROR);
}

/*
 *			
 ***LP wspDumpSetup
 *					
 *							
 * Effects:							
 *								
 * Opens the module's WSP and TMI input files, seeks to the start of the
 * first function's bitstring data in the WSP file, and allocates memory
 * to hold one function's bitstring.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

VOID
wspDumpSetup()
{
	CHAR	szLineTMI[MAXLINE];	// Line from TMI file

	if(fDatFile){
		hFileDAT = fopen (szDatFile, "wt");
		if (hFileDAT == NULL) {
			printf("Error creating file %s, will send output to stdout.\n",
				   szDatFile);
			hFileDAT = stdout;
		}
	}
   else hFileDAT = stdout;

	/* Open input WSP file.  Read and validate WSP file header.*/

	rc = WsWSPOpen(szFileWSP, &hFileWSP,(PFN)wspDumpExit,&WspHdr,ERROR,PRINT_MSG);
	ulSetSym = WspHdr.wsphdr_dtqo.dtqo_SymCnt;
	clVarTot = WspHdr.wsphdr_ulSnaps;
	fprintf(stdout, "\n%s:  Set symbol count=%lu - Segment size=%ld\n",   // mdg 4/98
	   szDatFile, WspHdr.wsphdr_dtqo.dtqo_SymCnt,
	   WspHdr.wsphdr_dtqo.dtqo_clSegSize);


	/* Open TMI file (contains function names, obj:offset, size, etc.).
	 * Verify that the TMI file identifier matches the module
	 * identifier from the WSP file.
	 */
	ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspDumpExit,
				0, (PCHAR)0);


	if (!fseek(hFileTMI, 0L, SEEK_SET)) {
        return;
    }
	fgets(szLineTMI, MAXLINE, hFileTMI);

	/* Print module header information for output file */
	szLineTMI[strlen(szLineTMI)-1] = '\0';

	fprintf(hFileDAT,"\nDUMP OF FUNCTION REFERENCES FOR '%s':\n\n",szLineTMI);

   fclose (hFileTMI);
	ulFxnTot = WsTMIOpen(szFileTMI, &hFileTMI, (PFN) wspDumpExit,
				0, (PCHAR)0);

	/* Allocate memory to hold one function's entire bitstring. */

	pulFxnBitstring = (ULONG *) malloc(clVarTot * sizeof(ULONG));
	if (pulFxnBitstring == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				clVarTot * sizeof(ULONG), "pulFxnBitstring[]");
}

/*
 *			
 ***LP wspDumpSeq
 *					
 *							
 * Effects:							
 *								
 * For each function, prints the bitstring in ASCII form.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

VOID wspDumpSeq(VOID)
{
	UINT	uiFxn = 0;			// Function number
	UINT	cTouched=0;			// Count of touched pages
	BOOL	fTouched=0;			// Flag to indicate page is touched.   // mdg 4/98
	UINT	i=0;				// Generic counter
	ULONG	cbFxnCum =0;		// Cumulative function sizes
	PFXN	Fxn;				// pointer to array of fxn name ptrs
	FILE 	*fpFileWSR = NULL;	// WSR file pointer
	ULONG	cbFBits = 0;		// Count of bytes in bitstring
	UINT	uiPageCount=0;		// Pages touched.
	ULONG	ulMaxBytes=0;		// Bytes of touched pages.


	/* Allocate memory for function names. */
	Fxn = (PFXN) malloc(ulFxnTot * sizeof(FXN));
	if (Fxn == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				ulFxnTot * sizeof(FXN), "Fxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", ulFxnTot );
	/* Read function names from TMI file. */
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		Fxn[uiFxn].cbFxn = WsTMIReadRec(&Fxn[uiFxn].pszFxnName, &ulFxnIndex, &ulTmp, hFileTMI,
					(PFN) wspDumpExit, (PCHAR)0);
		Fxn[uiFxn].ulOrigIndex = ulFxnIndex;
		Fxn[uiFxn].ulTmiIndex = (ULONG)uiFxn;

	}

	qsort(Fxn, ulFxnTot, sizeof(FXN), wspCompare);
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	cbFBits = clVarTot * sizeof(ULONG);

   WsIndicator( WSINDF_NEW, "Write Data Out", ulFxnTot );
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{

      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		/* Seek to function's bitstring in WSP file. */
		if ((rc = fseek(hFileWSP,(WspHdr.wsphdr_ulOffBits+(Fxn[uiFxn].ulTmiIndex*cbFBits)),SEEK_SET))!=NO_ERROR)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
					rc, szFileWSP);

		fprintf(hFileDAT,"Fxn '%s' (#%d):\n\t", Fxn[uiFxn].pszFxnName, Fxn[uiFxn].ulOrigIndex);
      free(Fxn[uiFxn].pszFxnName);  // mdg 98/4: Free allocated name string
      Fxn[uiFxn].pszFxnName = NULL;
		// Print this function's reference bitstring.
		// and if it has had a bit set, set touched flag to true

		if(wspDumpBits()){
			fTouched |=1;
			ulMaxBytes += Fxn[uiFxn].cbFxn;
		}
			

		fprintf(hFileDAT,"%-28s %10ld bytes.\n","Function size:", Fxn[uiFxn].cbFxn);
		cbFxnCum += Fxn[uiFxn].cbFxn;
		fprintf(hFileDAT,"%-28s %10ld bytes.\n\n","Cumulative function sizes:",
			cbFxnCum);

		//Checck to see if a 4k page boundry has been reached

		if(cbFxnCum >= (4096+(4096 * uiPageCount))){
		    for(i=0; i < 60; i++){
				fprintf(hFileDAT, "*");
		    }

		    fprintf(hFileDAT,"\n\nTotal function sizes has reached or exceeds %d bytes.\n\n",
			    (4096+(4096*uiPageCount)));
		    ++uiPageCount;

		    //Check to see of the page has been touched.

		    if(fTouched){
				fprintf(hFileDAT,"This page has been touched.\n");
				++cTouched;
		    }
		    else{
				fprintf(hFileDAT,"This page has not been touched.\n");
		    }
		    fTouched = 0;


		    for(i=0; i < 60; i++){
				fprintf(hFileDAT, "*");
		    }
		    fprintf(hFileDAT, "\n\n");
		}

	}
    ++uiPageCount;
    if(fTouched){
		fprintf(hFileDAT,"\n\n");
		for(i=0; i < 70; i++){
			fprintf(hFileDAT, "=");
		}
	    ++cTouched;
	    fprintf(hFileDAT,"\n\nThis page has been touched.");
    }
    fprintf(hFileDAT,"\n\n");
    for(i=0; i < 70; i++){
		fprintf(hFileDAT, "=");
    }

    fprintf(hFileDAT,"\n\n%-28s %10ld bytes\n\n","Cumulative function size:", cbFxnCum);
	 fprintf(hFileDAT,"%-28s %10d bytes\n\n", "Size of functions touched:", ulMaxBytes);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total page count:", uiPageCount);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total pages touched:", cTouched);

   WsIndicator( WSINDF_FINISH, NULL, 0 );
}

/*
 *			
 ***LP wspDumpBits
 *					
 *							
 * Effects:							
 *								
 * Prints a function's reference bitstring (verbose mode only), followed
 * by the sum of the "on" bits.
 *								
 * Returns:							
 *
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 *	
 */

UINT
wspDumpBits()
{
	ULONG	clVar = 0;		// Current dword of bitstring
	UINT	uiBit = 0;		// Result of bit test (1 or 0)
	UINT	cBitsOn;		// Count of "on" bits
	ULONG	*pulBits;		// Pointer to ULONG packets of bits
	CHAR	szTmp[33];
	CHAR	szBits[33];

	cBitsOn = 0;
	pulBits = pulFxnBitstring;

			    /* Read next dword of function's bitstring. */

	szBits[0] = '\0';
	szTmp[0] = '\0';
	for (clVar = 0; clVar < clVarTot; clVar++, pulBits++)
	{
	    rc = fread((PVOID)pulBits,
		(ULONG) sizeof(ULONG),1, hFileWSP);
	    if(rc == 1)
		rc = NO_ERROR;
	    else
		rc = 2;


	    if (rc != NO_ERROR)
		    wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_READ,
				rc, szFileWSP);

		if (*pulBits == 0)
		{
			if (fVerbose == TRUE)
				fprintf(hFileDAT,"00000000000000000000000000000000");
		}
		else
		for (uiBit = 0; uiBit < NUM_VAR_BITS; uiBit++)
		{
		
			if (*pulBits & 1)
			{
				cBitsOn++;
				if (fVerbose == TRUE){
					strcpy(szTmp,szBits);
					strcpy(szBits,"1");
					strcat(szBits,szTmp);
				}
			}
			else
			{
				if (fVerbose == TRUE){
					strcpy(szTmp,szBits);
					strcpy(szBits,"0");
					strcat(szBits,szTmp);
				}
			}
			
			*pulBits = *pulBits >> 1;
		}
		if (fVerbose == TRUE)
		{
			if ((clVar % 2) != 0){
				fprintf(hFileDAT,"%s",szBits);
				szBits[0]='\0';
				fprintf(hFileDAT,"\n\t");
			}
			else{
				fprintf(hFileDAT,"%s",szBits);
				szBits[0]='\0';
				fprintf(hFileDAT," ");
			}
		}
	}
	fprintf(hFileDAT,"\n\t*** Sum of '1' bits = %ld\n\n", cBitsOn);

	return(cBitsOn);
}

/*
 *			
 ***LP wspDumpRandom
 *					
 *							
 * Effects:							
 *								
 * For each function ordinal specified in the WSR file, prints the
 * corresponding function's reference bitstring in ASCII form (verbose
 * mode only), followed by a sum of the "on" bits..
 *								
 * Returns:							
 *	
 *	Void.  If an error is encountered, exits through wspDumpExit()
 *	with ERROR.
 */

VOID
wspDumpRandom()
{
	UINT	uiFxn = 0;			// Function number
	UINT	cTouched=0;			// Count of touched pages
	BOOL	fTouched=0;			// Flag to indicate page is touched.   // mdg 4/98
	UINT	i=0;				// Generic counter
	ULONG	cbFxnCum =0;		// Cumulative function sizes
	PFXN	Fxn;				// pointer to array of fxn name ptrs
	ULONG	ulFxnOrd;			// function number within module
	FILE 	*fpFileWSR = NULL;	// WSR file pointer
	ULONG	cbFBits = 0;		// Count of bytes in bitstring
	UINT	uiPageCount=0;		// Pages touched.
	ULONG	ulMaxBytes=0;		// Bytes of touched pages.

	/* Open WSR file (contains function ordinal numbers in ASCII). */

	if ((fpFileWSR = fopen(szFileWSR, "r")) == NULL)
	{
		wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OPEN, rc, szFileWSR);
	}

	/* Allocate memory for function names. */
	Fxn = (PFXN) malloc(ulFxnTot * sizeof(FXN));
	if (Fxn == NULL)
		wspDumpExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				ulFxnTot * sizeof(FXN), "Fxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", ulFxnTot );
	/* Read function names from TMI file. */
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		Fxn[uiFxn].cbFxn = WsTMIReadRec(&Fxn[uiFxn].pszFxnName, &ulFxnIndex, &ulTmp, hFileTMI,
					(PFN) wspDumpExit, (PCHAR)0);

	}
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	cbFBits = clVarTot * sizeof(ULONG);

   WsIndicator( WSINDF_NEW, "Write Data Out", ulFxnTot );
	for (uiFxn = 0; uiFxn < ulFxnTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		/* Read function number from WSR file. */
		rc = fscanf(fpFileWSR, "%ld\n", &ulFxnOrd);
		if (rc != 1)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_READ,
						rc, szFileWSR);

		/* Seek to function's bitstring in WSP file. */
		if ((rc = fseek(hFileWSP,(WspHdr.wsphdr_ulOffBits+(ulFxnOrd*cbFBits)),SEEK_SET))!=NO_ERROR)
			wspDumpExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,
					rc, szFileWSP);

		fprintf(hFileDAT,"Fxn '%s' (#%d):\n\t", Fxn[ulFxnOrd].pszFxnName, ulFxnOrd);
      free(Fxn[ulFxnOrd].pszFxnName);  // mdg 98/4: Free allocated name string
      Fxn[ulFxnOrd].pszFxnName = NULL;

		// Print this function's reference bitstring.
		// and if it has had a bit set, set touched flag to true

		if(uiFxn < ulSetSym){   // mdg 4/98
			if(wspDumpBits()){
				fTouched |= 1;
				ulMaxBytes += Fxn[ulFxnOrd].cbFxn;
			}
		}
		else{
			fprintf(hFileDAT,"\n\t*** Sum of '1' bits = %ld\n\n", 0L);
		}


			

		fprintf(hFileDAT,"%-28s %10ld bytes.\n","Function size:", Fxn[ulFxnOrd].cbFxn);
		cbFxnCum += Fxn[ulFxnOrd].cbFxn;
		fprintf(hFileDAT,"%-28s %10ld bytes.\n\n","Cumulative function sizes:",
			cbFxnCum);

		//Check to see if a 4k page boundry has been reached

		if(cbFxnCum >= (4096+(4096 * uiPageCount))){
		    for(i=0; i < 60; i++){
			fprintf(hFileDAT, "*");
		    }

		    fprintf(hFileDAT,"\n\nTotal function sizes has reached or exceeds %d bytes.\n\n",
			    (4096+(4096*uiPageCount)));
		    ++uiPageCount;

		    //Check to see of the page has been touched.

		    if(fTouched){
			fprintf(hFileDAT,"This page has been touched.\n");
			++cTouched;
		    }
		    else{
			fprintf(hFileDAT,"This page has not been touched.\n");
		    }
		    fTouched = 0;


		    for(i=0; i < 60; i++){
			fprintf(hFileDAT, "*");
		    }
		    fprintf(hFileDAT, "\n\n");
		}

	}
    ++uiPageCount;
    if(fTouched){
	fprintf(hFileDAT,"\n\n");
	for(i=0; i < 70; i++){
	    fprintf(hFileDAT, "=");
	}
	    ++cTouched;
	    fprintf(hFileDAT,"\n\nThis page has been touched.");
    }
    fprintf(hFileDAT,"\n\n");
    for(i=0; i < 70; i++){
	fprintf(hFileDAT, "=");
    }

    fprintf(hFileDAT,"\n\n%-28s %10ld bytes\n\n","Cumulative function size:", cbFxnCum);
	fprintf(hFileDAT,"%-28s %10d bytes\n\n", "Size of functions touched:", ulMaxBytes);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total page count:", uiPageCount);
    fprintf(hFileDAT,"%-28s %10d\n\n", "Total pages touched:", cTouched);
   WsIndicator( WSINDF_FINISH, NULL, 0 );

}


/*
 *			
 ***LP wspDumpExit
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.			
 *								
 ***								
 * Returns:							
 *	
 *	Void, else exits.
 */

VOID
wspDumpExit(uiExitCode, fPrintMsg, uiMsgCode, ulParam1, pszParam2)
UINT	uiExitCode;
USHORT	fPrintMsg;
UINT	uiMsgCode;
ULONG	ulParam1;
PSZ	pszParam2;
{


   /* Print message, if necessary. */
   if (fPrintMsg == TRUE)
   {
      printf(pchMsg[uiMsgCode], szProgName, pszVersion, ulParam1, pszParam2);
   }

   // Special case:  do NOT exit if called with NOEXIT.
   if (uiExitCode == NOEXIT)
      return;

   wspDumpCleanup();
   exit(uiExitCode);
}


/*
 *			
 ***LP wspDumpCleanup
 *					
 *							
 ***							
 *							
 * Effects:							
 *								
 *	Frees up resources (as necessary).		
 *								
 ***								
 * Returns:							
 *	
 *	Void.
 */
void
wspDumpCleanup( void )
{
	_fcloseall();

   free( szFileWSP );
   free( szFileTMI );
   if (fRandom)
      free( szFileWSR );
   if (fDatFile)
      free( szDatFile );
}



int __cdecl wspCompare(const void *fxn1, const void *fxn2)
{
    return (((PFXN)fxn1)->ulOrigIndex < ((PFXN)fxn2)->ulOrigIndex ? -1:
			((PFXN)fxn1)->ulOrigIndex == ((PFXN)fxn2)->ulOrigIndex ? 0:
			1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\wst\wstune\wsreduce.c ===
/*
 * Module Name:	 WSREDUCE.C
 *
 * Program:	 WSREDUCE
 *
 *
 * Description:
 *
 * Performs data reduction on the function reference data collected
 * by WST.DLL.  Analyzes the WSP file information, and produces
 * a suggested list for the ordering of functions within the tuned
 * modules.  An ASCII version of the reordered function list is written
 * to stdout.  In addition, a WSR file for each reduced module is
 * produced for subsequent use by WSPDUMP /R.
 *
 * The reduction algorithm employed by WSREDUCE is described in detail
 * in WSINSTR.DOC.  Briefly, each function monitored by the working set tuner
 * is considered to be a vertex in a graph.  There is an edge from vertex
 * "A" to vertex "B" if the function reference strings for "A" and "B"
 * have any overlapping 1 bits.  Likewise, there is an edge from vertex "B"
 * to vertex "A".  The edges between vertices are weighted depending on
 * the relative importance of the ending vertex, and the number of
 * overlapping bits between the start and end vertices.  The relative
 * importance of the end vertices, and the weighted edges between
 * vertices, is stored in a decision matrix.  A greedy algorithm is run on
 * the decision matrix to determine a better ordering for the measured
 * functions.
 *
 *
 *	Microsoft Confidential
 *
 *	Copyright (c) Microsoft Corporation 1992
 *
 *	All Rights Reserved
 *
 * Modification History:
 *
 *	Modified for NT June 13, 1992	MarkLea.
 * 4-23-98: QFE - Performance unacceptable on high function counts      DerrickG (mdg):
 *          - new WSP file format for large symbol counts (ULONG vs. USHORT)
 *          - support for long file names (LFN) of input/output files
 *          - removed buggy reference to WSDIR env. variable
 *          - removed command-line parsing from wsReduceMain()
 *          - based .TMI & .WSR file names exclusively on .WSP name for consistency
 *          - removed limit on symbol name lengths - return allocated name from WsTMIReadRec()
 *          - removed unused code and symbols
 *          - Analyzed the code blocked off by OPTIMIZE - it doesn't produce the same
 *            output as non-OPTIMIZEd code, and is buggy (won't build as is) - removed.
 *          - Removed multiple module capabilities from code (shell sends one at a time)
 *          - I addressed memory and performance issues by using a smaller allocation
 *            for WsDecision (USHORT vs. long), using one value to mark a taken vertex
 *            (as opposed to half the value space by using -1), and an optional
 *            progress indicator to reassure users. Modified wsRedScaleWsDecision()
 *            to maximize the scaled values (using some more float math).
 *          - Added "pnEdges" and "nEdgeCount" to function structure. If the number
 *            of set functions is < USHRT_MAX (very likely, even for very large
 *            projects), allocate as needed a sorted index for WsRedReorder(). This
 *            cuts dramatically the number of passes through the matrix searching for
 *            the next edge to consider, and permits some other optimizations. The
 *            optimized algorithm produces identical results for the important high
 *            usage high overlap functions, but could diverge in the results for low
 *            usage (2 or 1 hits) low overlap functions. Differences are not
 *            significant from a results performance perspective - a better algorithm
 *            would give marginally better results. The original algorithm is in place
 *            bracketed with "#ifdef SLOWMO".
 *         
 *
 */

#include "wstune.h"
/*
 *	    Function prototypes.
 */

VOID wsRedInitialization( VOID );
VOID wsRedInitModules( VOID );
VOID wsRedInitFunctions( VOID );
VOID wsRedSetup( VOID );
VOID wsRedSetWsDecision( VOID );
VOID wsRedScaleWsDecision( VOID );
VOID wsRedWeightWsDecision( VOID );
#ifdef   SLOWMO
UINT wsRedChooseEdge( UINT );
#else    // SLOWMO
UINT wsRedChooseEdgeOpt( UINT ); // mdg 98/4 Alternate optimized edge chooser
INT  __cdecl wsRedChooseEdgeOptCmp ( const UINT *, const UINT * );
BOOL wsRedChooseEdgeOptAlloc( UINT uiIndex );
UINT wsRedChooseEdgeOptNextEdge( UINT uiIndex, BOOL bNoSelectOpt );
#endif   // SLOWMO
VOID wsRedReorder( VOID );
VOID wsRedOutput( VOID );
VOID wsRedOpenWSR( FILE **);
VOID wsRedExit( UINT, USHORT, UINT, ULONG, PSZ );
VOID wsRedCleanup(VOID);

/*
 *	    Type definitions and structure declarations.
 */

				/* Data reduction per module information */
struct wsrmod_s {
	FILE	 *wsrmod_hFileWSR;	// module's WSR file pointer
	FILE	 *wsrmod_hFileTMI;		// module's TMI file pointer
	FILE	 *wsrmod_hFileWSP;		// module's WSP file handle
	union {
		PCHAR	wsrmod_pchModName;// pointer to module base name
		PCHAR	wsrmod_pchModFile;// pointer to WSP file name
	} wsrmod_un;
	ULONG	wsrmod_ulOffWSP;	// offset of first function bitstring
};

typedef struct wsrmod_s wsrmod_t;

				/* Data reduction per function information */
struct wsrfxn_s {
	PCHAR	wsrfxn_pchFxnName;	// pointer to function name
	ULONG	wsrfxn_cbFxn;		// Size of function in bytes
	BOOL	wsrfxn_fCandidate;	// Candidate flag
#ifndef  SLOWMO
   UINT     nEdgesLeft;    // Count of sorted edges left to consider in WsDecision for this function
   UINT     nEdgesAlloc;   // Number of items allocated in pnEdges
   UINT *   pnEdges;       // Allocated array of sorted edges for this function
#endif   // SLOWMO
};

typedef struct wsrfxn_s wsrfxn_t;



/*
 *	Global variable declaration and initialization.
 */

static char *szFileWSP = NULL;   // WSP file name
static char	*szFileTMI = NULL;   // TMI file name
static char *szFileWSR = NULL;   // WSR file name

static ULONG	rc = NO_ERROR;	// Return code
static ULONG	ulTmp;			// Temp variable for Dos API returns
static UINT	    cTmiFxns = 0;	// Number of functions in tmi file
static UINT		cFxnsTot = 0;	// Total number of functions
static UINT		cSnapsTot = 0;	// Total number of snapshots
static UINT		cbBitStr = 0;	// Number of bytes per fxn bitstring
#ifdef DEBUG
static BOOL		fVerbose = FALSE;	// Flag for verbose mode
#endif /* DEBUG */
#ifndef TMIFILEHACK
static BOOL	fFxnSizePresent = FALSE; // Flag for function size availability
#endif /* !TMIFILEHACK */

static wsrmod_t WsrMod; 		// Module information
static wsrmod_t *pWsrMod = &WsrMod; // Pointer for legacy use
static wsrfxn_t *WsrFxn;		// Pointer to function information
static ULONG	*FxnBits;		// Pointer to dword of bitstring
static ULONG	*FxnOrder;		// Pointer to ordered list of
                              //	function ordinals
typedef USHORT  WsDecision_t;
#define WSDECISION_TAKEN   USHRT_MAX   // Reserve highest value for special code
#define WsDecision_MAX     (WSDECISION_TAKEN-1) // Use fullest spread for decision matrix
static WsDecision_t	**WsDecision;  // Decision matrix for data reduction; mdg 98/4 use small alloc for large symbol counts
static ULONG	ulRefHi1 = 0;		// Highest diagonal value (for WsRedScaleWsDecision)
static ULONG	ulRefHi2 = 0;		// Second highest diagonal value (for WsRedScaleWsDecision)
static UINT    uiSelected = 0;   // Highest function ordinal selected (for WsRedReorder)
static UINT    cFxnOrder = 0;    // Count of ordered functions
#ifndef  SLOWMO
static UINT    nFxnToSort;       // To pass static value to wsRedChooseEdgeOptCmp()
#endif   // SLOWMO

static FILE   	*hFileWLK = NULL; // Handle to file containing ordered
HGLOBAL			hMem[10];
ULONG			ulFxnIndex;		// Index of original TMI order of function.

#ifdef TMR
ULONG		pqwTime0[2];
#endif /* TMR */

/*
 * Procedure wsReduceMain
 *
 *
 ***
 * Effects:
 *
 * Performs data reduction and analysis on the input modules' function reference
 * data.
 *
 *	szBaseName	Specifies a module WSP file name
 */

BOOL wsReduceMain( CHAR *szBaseName )
{
	size_t	i;
    char *   pSlash;

    szFileWSP = malloc( i = strlen( szBaseName ) + 5 );
    if (szFileWSP) {
        szFileWSP = strcat( strcpy(szFileWSP , szBaseName ), ".WSP" );
    } else {
        exit(1);
    }
    szFileTMI = malloc( i );
    if (szFileTMI) {
        szFileTMI = strcat( strcpy( szFileTMI, szBaseName ), ".TMI" );
    } else {
        free(szFileWSP);
        exit(1);
    }
#ifdef DEBUG
    fVerbose = fDbgVerbose;
#endif   // DEBUG

   // Create output file in current directory
    if (NULL != (pSlash = strrchr( szBaseName, '\\' ))
        || NULL != (pSlash = strrchr( szBaseName, '/' ))
        || NULL != (pSlash = strrchr( szBaseName, ':' )))
    {
        ++pSlash;
        szFileWSR = malloc(strlen( pSlash ) + 5 );
        if (szFileWSR) {
            szFileWSR = strcat( strcpy(szFileWSR, pSlash ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            exit(1);
        }
    } else {
        szFileWSR = malloc( i );
        if (szFileWSR) {
            szFileWSR = strcat( strcpy( szFileWSR, szBaseName ), ".WSR" );
        } else {
            free(szFileTMI);
            free(szFileWSP);
            exit(1);
        }
    }

#ifdef TMR
	DosTmrQueryTime((PQWORD)pqwTime0);
	printf("Top of Main, 0x%lx:0x%lx\n", pqwTime0[1], pqwTime0[0]);
#endif /* TMR */

	pWsrMod->wsrmod_un.wsrmod_pchModFile = szFileWSP;
#ifdef DEBUG
   printf("\t%s\n", pWsrMod->wsrmod_un.wsrmod_pchModFile);
#endif /* DEBUG */

	// Initialize module and function information structures.
   wsRedInitialization();

	// Set up weighted decision matrix.
	wsRedSetup();

	// Perform the function reference data analysis.
	wsRedReorder();

	// Output the analysis results.
	wsRedOutput();

	// Cleanup memory allocations.
	wsRedCleanup();
   free( szFileWSP );
   free( szFileWSR );
   free( szFileTMI );

	return(NO_ERROR);
}

/*
 *
 ***LP wsRedInitialization
 *
 *
 * Effects:
 *	- Calls wsRedInitModules to:
 *		o Open and validate each module's WSP file.
 *		o Open and validate each module's TMI file.
 *	- Calls wsRedInitFunctions to:
 *		o Set up WsrFxn[] with per function information.
 *		o Allocate FxnBits[].
 *	- Allocates WsDecision[][].
 *	- Allocates and initializes DiagonalFxn[].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitialization()
{
	UINT	 i;			// Loop counter


	// Setup module information.
	wsRedInitModules();

	// Setup function information for each module.
	wsRedInitFunctions();

	// Allocate the decision matrix, WsDecision[cFxnsTot][cFxnsTot].
	WsDecision = (WsDecision_t **) AllocAndLockMem((cFxnsTot * cFxnsTot * sizeof(WsDecision_t)) + (cFxnsTot * sizeof(WsDecision_t *)), &hMem[1]);
	if (WsDecision == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				(cFxnsTot+1)*cFxnsTot*sizeof(WsDecision_t), "WsDecision[][]");
   for (i = 0; i < cFxnsTot; i++)
	{
      WsDecision[i] = (WsDecision_t *) (WsDecision+cFxnsTot)+(i*cFxnsTot);
	}

}

/*
 *
 ***LP wsRedInitModules
 *
 *
 * Effects:
 *	- Opens and validates each module's WSP file.
 *	- Opens and validates each module's TMI file.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitModules()
{
	wsphdr_t 	WspHdr;						// WSP file header
	UINT		cFxns = 0;					// Number of functions for this module
	ULONG		ulTimeStamp = 0;			// Time stamp
	ULONG		ulTDFID = 0;				// TDF Identifier


	/* Open module's input WSP file.  Read and validate
	 * WSP file header.
	 */

	rc = WsWSPOpen(pWsrMod->wsrmod_un.wsrmod_pchModFile,
			&(pWsrMod->wsrmod_hFileWSP), (PFN) wsRedExit,
			&WspHdr, ERROR, PRINT_MSG );
	if (NULL == (pWsrMod->wsrmod_un.wsrmod_pchModName = malloc( 1 + WspHdr.wsphdr_dtqo.dtqo_cbPathname )))
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				WspHdr.wsphdr_dtqo.dtqo_cbPathname + 1,
				pWsrMod->wsrmod_un.wsrmod_pchModFile);
   rc = fread( pWsrMod->wsrmod_un.wsrmod_pchModName, WspHdr.wsphdr_dtqo.dtqo_cbPathname,
      1, pWsrMod->wsrmod_hFileWSP );
   if (rc != 1)
		wsRedExit(ERROR, PRINT_MSG, MSG_FILE_BAD_HDR, (ULONG)-1L,
				pWsrMod->wsrmod_un.wsrmod_pchModFile);
   pWsrMod->wsrmod_un.wsrmod_pchModName[WspHdr.wsphdr_dtqo.dtqo_cbPathname] = '\0';

	ulTimeStamp = WspHdr.wsphdr_ulTimeStamp;
	cSnapsTot = WspHdr.wsphdr_ulSnaps;
	cbBitStr = cSnapsTot * sizeof(ULONG);

	pWsrMod->wsrmod_ulOffWSP = WspHdr.wsphdr_ulOffBits;

	/*
	 * Open associated TMI file.  Assume it lives in same directory.
	 * Read and validate TMI header. Increment cFxnsTot.
	 */
	cTmiFxns = WsTMIOpen(szFileTMI, &(pWsrMod->wsrmod_hFileTMI),
				(PFN) wsRedExit,
				0, (PCHAR)0);
	cFxns = WspHdr.wsphdr_dtqo.dtqo_SymCnt;

#ifdef DEBUG
	printf("%s file header: # fxns = %ld, TDF ID = 0x%x\n", szFileTMI,
			cFxns, (UINT) WspHdr.wsphdr_dtqo.dtqo_usID);
#endif /* DEBUG */

	cFxnsTot = cFxns;

	// If no function data to analyze, just exit without error.
	if (cFxnsTot == 0)
		wsRedExit(NO_ERROR, NO_MSG, NO_MSG, 0, NULL);
}


/*
 *
 ***LP wsRedInitFunctions
 *
 *
 * Effects:
 *	- Sets up WsrFxn[] with per function information.
 *	- Allocates FxnBits[].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedInitFunctions()
{
	UINT	uiFxn = 0;		// Function number
	UINT	cFxns = 0;		// Number of functions for this module


	// Allocate memory for per function info, WsrFxn[cFxnsTot].
	WsrFxn = (wsrfxn_t *) AllocAndLockMem(cFxnsTot*sizeof(wsrfxn_t), &hMem[3]);
	if (WsrFxn == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				cFxnsTot * sizeof(wsrfxn_t), "WsrFxn[]");

   WsIndicator( WSINDF_NEW, "Load Functions", cFxnsTot );
	// Initialize WsrFxn[cFxnsTot].
   uiFxn = 0;		// loop index init
	cFxns = cFxnsTot; // loop invariant
#ifdef DEBUG
   if (fVerbose)
   {
		printf("Initializing WsrFxn[] for %s:\n\tstart/end fxn indices (%d/%d)\n",
			pWsrMod->wsrmod_un.wsrmod_pchModName, uiFxn,
			cFxns - 1);

		printf("TMI file handle: %ld\n",pWsrMod->wsrmod_hFileTMI);
   }
#endif /* DEBUG */
	for (; uiFxn < cFxns; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		WsrFxn[uiFxn].wsrfxn_cbFxn =
			WsTMIReadRec(&(WsrFxn[uiFxn].wsrfxn_pchFxnName),&ulFxnIndex,&ulTmp,pWsrMod->wsrmod_hFileTMI,
				 (PFN) wsRedExit, (PCHAR)0);
#ifdef DEBUG
		if (fVerbose)
			printf("\tWsrFxn[%d] %s\n",
				uiFxn, WsrFxn[uiFxn].wsrfxn_pchFxnName );
#endif /* DEBUG */
		WsrFxn[uiFxn].wsrfxn_fCandidate = TRUE;


	}

	// Close TMI file.
	fclose(pWsrMod->wsrmod_hFileTMI);

   WsIndicator( WSINDF_FINISH, NULL, 0 );

	// Allocate space to hold 32 snapshots for each function.
	FxnBits = (ULONG *) AllocAndLockMem(cFxnsTot*sizeof(ULONG), &hMem[4]);
	if (FxnBits == NULL)
		wsRedExit(ERROR, PRINT_MSG, MSG_NO_MEM,
				cFxnsTot * sizeof(ULONG), "FxnBits[]");
}

/*
 *
 ***LP wsRedSetup
 *
 *
 * Effects:
 *
 * Initializes the data structures used to analyze the function
 * reference bitstrings, including the weighted decision matrix.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedSetup()
{
	wsRedSetWsDecision();		// set up initial decision matrix
	wsRedScaleWsDecision();		// scale the decision matrix
	wsRedWeightWsDecision();	// weight the matrix "edge" entries
}

/*
 *
 ***LP wsRedSetWsDecision
 *
 *
 * Effects:
 *
 * Initializes and weights the decision matrix, WsDecision[][].
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedSetWsDecision()
{
   UINT	i = 0, j = 0;		// Temporary loop indexes
   UINT	uiFxn = 0;		// Function number
   UINT	uiFBits = 0;		// Loop index for bitstring dwords
   UINT	clFBits = 0;		// Count of fxn bitstring dwords
   ULONG	ulResult = 0;		// Returned from procedure call
   FILE	*hFile;			// File handle

   /* For each dword of snapshot bitstrings...*/
   clFBits = (cbBitStr + sizeof(ULONG) - 1) / sizeof(ULONG);
   WsIndicator( WSINDF_NEW, "Fill In Matrix", clFBits * cFxnsTot );
   for (uiFBits = 0; uiFBits < clFBits; uiFBits++)
   {
      ULONG       ulOffWSP;

      WsIndicator( WSINDF_PROGRESS, "Reading Snaps ", 0 );
      // Fill in FxnBits for this snapshot
#ifdef DEBUG
      if (fVerbose)
         printf( "Setting up FxnBits snapshot %lu for %s\n",
            uiFBits, pWsrMod->wsrmod_un.wsrmod_pchModName );
#endif /* DEBUG */
      hFile = pWsrMod->wsrmod_hFileWSP;
      ulOffWSP = uiFBits + pWsrMod->wsrmod_ulOffWSP;
      for ( uiFxn = 0; uiFxn < cFxnsTot; uiFxn++, ulOffWSP += cbBitStr) // Loop functions
      {
         // Seek to next dword of function's bitstring.
         if ((rc = fseek( hFile, ulOffWSP, SEEK_SET )) != NO_ERROR)
            wsRedExit(ERROR, PRINT_MSG, MSG_FILE_OFFSET,rc,
               pWsrMod->wsrmod_un.wsrmod_pchModName);

         // Read next dword of function's bitstring.
         rc = fread( &(FxnBits[uiFxn]), sizeof(ULONG), 1, hFile );
         if(rc != 1)
            wsRedExit(ERROR, PRINT_MSG, MSG_FILE_READ, rc,
               pWsrMod->wsrmod_un.wsrmod_pchModName);
      }  // for each function

      WsIndicator( WSINDF_PROGRESS, "Fill In Matrix", 0 );
      hFile = pWsrMod->wsrmod_hFileWSP;
#ifdef DEBUG
      if (fVerbose)
         printf("Setting up WsDecision[][] for %s:\n\tstart/end fxn indices (%d/%d)\n",
            pWsrMod->wsrmod_un.wsrmod_pchModName,
            uiFxn, cFxnsTot - 1);
#endif /* DEBUG */
      /* For each function... */
      for ( uiFxn = 0; uiFxn < cFxnsTot; uiFxn++ )
      {
         WsIndicator( WSINDF_PROGRESS, NULL, (uiFBits * cFxnsTot) + uiFxn );
         // Get the current snapshot
         ulTmp = FxnBits[uiFxn];
#ifdef DEBUG
         if (fVerbose)
            printf("\tFxnBits[%d] = 0x%lx\n", uiFxn, ulTmp);
#endif /* DEBUG */

         /* If there are bits set... */
         if (ulTmp != 0)
         {
            /* Sum the "on" bits  and add the result
             * to WsDecision[uiFxn][uiFxn].
             */
            ulResult = 0;
	         while (ulTmp)
            {
               ++ulResult;
               ulTmp &= ulTmp - 1;
            }
            ulTmp = WsDecision[uiFxn][uiFxn] += (WsDecision_t)ulResult;
            if (ulTmp > ulRefHi2)   // Set the highest two diagonal values on the last pass
               if (ulTmp > ulRefHi1)
               {
                  ulRefHi2 = ulRefHi1;
                  ulRefHi1 = ulTmp;
                  uiSelected = uiFxn;  // Remember highest value's index
               }
               else
                  ulRefHi2 = ulTmp;

            /* Sum the overlapping "on" bits for this
             * function's dword with each preceding
             * function's dword, and add the results to
             * WsDecision[][].
             */

            for (i = 0; i < uiFxn; i++)
            {
	            ulTmp = FxnBits[i] & FxnBits[uiFxn];
               if (ulTmp)  // mdg 98/4
               {
	               ulResult = 0;
	               while (ulTmp)
                  {
                     ++ulResult;
                     ulTmp &= ulTmp - 1;
                  }
                  WsDecision[uiFxn][i] += (WsDecision_t)ulResult;
                  WsDecision[i][uiFxn] += (WsDecision_t)ulResult;
               }

            }   /* End For each previous function's dword */
         }	/* End If there are bits set...*/
      }	/* End For each function... */
   }	/* End For each dword of bitstrings */
   WsIndicator( WSINDF_FINISH, NULL, 0 );

#ifdef DEBUG
	if (fVerbose)
	{
		printf("\nRAW MATRIX:\n");
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			printf("row %4d:\n", uiFxn);
			for (i = 0; i < cFxnsTot; i++)
				printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
			printf("\n");
		}
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedOpenWSR
 *
 *
 * Effects:
 *	Opens the output WSR files, one per module.  If only one module
 *	is being reduced, also opens a WLK file, setting the WLK file handle
 *	as a side effect.
 *
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedOpenWSR(FILE **phFileWLK)
{
	/* Close WSP file, and open module output file. */
	fclose(pWsrMod->wsrmod_hFileWSP);

	if ((pWsrMod->wsrmod_hFileWSR = fopen(szFileWSR, "w"))
				== NULL)
	{
		wsRedExit(ERROR, PRINT_MSG,MSG_FILE_OPEN,rc, szFileWSR);
	}

	/* We're only analyzing ONE module. Also open a WLK
	 * file.  This file will contain the function names in their
	 * reordered sequence.  The linker will use this file to
	 * automatically reorder functions.  Note that we reuse szFileWSR
	 * here.
	 */

	strcpy(strstr(szFileWSR, ".WSR"), ".PRF");
	if ((*phFileWLK = fopen(szFileWSR, "w")) == NULL)
		wsRedExit(ERROR, PRINT_MSG,MSG_FILE_OPEN,rc, szFileWSR);
}

/*
 *
 ***LP wsRedScaleWsDecision
 *
 *
 * Effects:
 *
 * If necessary, scales the diagonal values of the matrix to avoid overflow
 * during calculations of the weighted edges (below).  Sets up DiagonalFxn[]
 * as a side effect.  Note that we go through gyrations to set
 * DiagonalFxn up backwards, so that qsort() will handle ties a little better.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedScaleWsDecision()
{
	UINT	i = 0, j = 0;		// Temporary loop indexes
	UINT	uiFxn = 0;			// Function number
	double	fTmp;				// Temporary float variable
	WsDecision_t	lTmp;

	fTmp = (double)ulRefHi1 * (double)ulRefHi2;
	if (fTmp > WsDecision_MAX)
	{
		// Scale down the diagonal.  Don't allow rescaled entries
		// to be zero if they were non-zero before scaling.

		fTmp /= WsDecision_MAX;
		printf("%s %s: WARNING -- Scaling back the reduction matrix by %f.\n",
					    szProgName, pszVersion, fTmp);
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			lTmp = WsDecision[uiFxn][uiFxn];
			if (lTmp)
			{
				lTmp = (WsDecision_t)(lTmp / fTmp);  // Discard any remainders to avoid potential overflows
				if (lTmp == 0)
					WsDecision[uiFxn][uiFxn] = 1;
				else
					WsDecision[uiFxn][uiFxn] = lTmp;
			}
		}
#ifdef DEBUG
		if (fVerbose)
		{
			printf("\nSCALED MATRIX:\n");
			for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
			{
				printf("row %4d:\n", uiFxn);
				for (i = 0; i < cFxnsTot; i++)
					printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
				printf("\n");
			}
		}
#endif /* DEBUG */
	}

#ifdef DEBUG
	if (fVerbose)
	{
		printf("Got ulRefHi1 = %ld, ulRefHi2 = %ld\n",
				ulRefHi1, ulRefHi2);
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedWeightWsDecision
 *
 *
 * Effects:
 *
 * Weights the decision matrix edges from start vertex to end vertex,
 * depending on the relative importance of the end vertex.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedWeightWsDecision()
{
	UINT	i = 0, j = 0;		// Temporary loop indexes
	UINT	uiFxn = 0;		// Function number

   WsIndicator( WSINDF_NEW, "Weight Matrix ", cFxnsTot );
	for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
   {
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		for (i = 0; i < cFxnsTot; i++)
		{
			if (uiFxn == i)
				continue;
         if (WsDecision[uiFxn][i])  // mdg 98/4
            WsDecision[uiFxn][i] *= WsDecision[i][i];
		}
   }
   WsIndicator( WSINDF_FINISH, NULL, 0 );

#ifdef DEBUG
	if (fVerbose)
	{
		printf("\nWEIGHTED MATRIX:\n");
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
		{
			printf("row %4d:\n", uiFxn);
			for (i = 0; i < cFxnsTot; i++)
				printf("0x%lx ", (LONG)WsDecision[uiFxn][i]);
			printf("\n");
		}
	}
#endif /* DEBUG */

}

/*
 *
 ***LP wsRedReorder
 *
 * Requires:
 *
 * Effects:
 *
 * A greedy algorithm is used to determine a better ordering for the functions
 * whose reference patterns are represented in the decision matrix.  The
 * algorithm is as follows:
 *
 *	o Select the function whose value on the diagonal is greatest.
 *	  The selected function becomes the current starting vertex,
 *	  and is first on the list of ordered functions.  Mark that it
 *	  is no longer a candidate function.  Note that this does NOT mean
 *	  that its vertex is removed from the graph.
 *
 *	o While there is more than one function remaining as a candidate:
 *
 *	  - Choose the edge of greatest weight leading from the current
 *	    starting vertex.  Ties are broken as follows:  If one of the
 *	    tied ending vertices is in the selected set and the other is
 *	    not, choose the edge whose ending vertex is already selected
 *	    (because we already know that vertex is "important"); further
 *	    ties are broken by choosing the end vertex whose diagonal value
 *	    is greatest.
 *
 *	  - If the ending vertex chosen above is still a candidate (i.e., not
 *	    already selected), then select it for the list of ordered
 *	    functions, and mark that it is no longer a candidate.
 *
 *	  - Set the matrix entry for the chosen edge to some invalid value,
 *	    so that edge will never be chosen again.
 *
 *	  - Set current starting vertex equal to the ending vertex chosen
 *	    above.
 *
 *	o Select the one remaining function for the list of ordered functions.
 *
 * mdg 98/4: Added "pnEdges" and "nEdgeCount" to function structure. If the number
 *            of set functions is < USHRT_MAX (very likely, even for very large
 *            projects), allocate as needed a sorted index for WsRedReorder(). This
 *            cuts dramatically the number of passes through the matrix searching for
 *            the next edge to consider.
 *
 * Returns:
 *
 *	Void.
 */

VOID
wsRedReorder()
{
	UINT	uiFxn = 0;		// Function number
	UINT	i = 0;			// Temporary loop index
	UINT	cCandidates = 0;	// Count of candidates remaining
	UINT	uiEdge = 0;		// Function ordinal edge selected

	/* Reuse FxnBits[] for the ordered list of functions, FxnOrder[]. */
   WsIndicator( WSINDF_NEW, "Reorder Matrix", cFxnsTot );
	FxnOrder = FxnBits;
	memset((PVOID) FxnOrder, 0, cFxnsTot * sizeof(ULONG));

	cCandidates = cFxnsTot;

	FxnOrder[cFxnOrder++] = uiSelected;
	WsrFxn[uiSelected].wsrfxn_fCandidate = FALSE;
	--cCandidates;

	while (cCandidates > 1)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, cFxnsTot - cCandidates );
		/* Follow highest weighted edge from selected vertex. */
#ifdef   SLOWMO
      uiEdge = wsRedChooseEdge(uiSelected);
#else    // SLOWMO
      uiEdge = wsRedChooseEdgeOpt( uiSelected );
#endif   // SLOWMO
#ifdef DEBUG
		if (fVerbose)
			printf("choose edge (%d->%d)\n", uiSelected, uiEdge);
#endif
		uiSelected = uiEdge;
		if (WsrFxn[uiEdge].wsrfxn_fCandidate)
		{
			FxnOrder[cFxnOrder++] = uiSelected;
			WsrFxn[uiSelected].wsrfxn_fCandidate = FALSE;
			--cCandidates;
		}
	}
   WsIndicator( WSINDF_FINISH, NULL, 0 );

	if (cCandidates == 1)
	{
		for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
			if (WsrFxn[uiFxn].wsrfxn_fCandidate)
			{
				FxnOrder[cFxnOrder++] = uiFxn;
				break;
			}
	}
}

#ifdef   SLOWMO
/*
 *
 ***LP wsRedChooseEdge
 *
 *
 * Effects:
 *
 *	"Selects" a function from the candidate pool, based on weighted
 *	edge from 'index' function to a candidate function.
 *
 *
 *
 * Returns:
 *
 *	Ordinal number of selected function.
 *
 */

UINT
wsRedChooseEdge(UINT uiIndex)
{
	UINT	uiFxn = 0;		// 